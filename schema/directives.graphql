# =============================================================================
# Custom Directive Definitions for NasNetConnect
# =============================================================================
# These directives enable:
# 1. Input validation (@validate) - Generates Zod schemas
# 2. Platform mapping (@mikrotik, @openwrt, @vyos) - Multi-platform support
# 3. Capability gating (@capability) - Feature-based access control
# =============================================================================

# -----------------------------------------------------------------------------
# Validation Directive
# -----------------------------------------------------------------------------
# Used to define validation constraints on input fields and field definitions.
# These constraints are:
# - Processed by graphql-codegen to generate Zod validation schemas
# - Used by gqlgen for server-side validation
#
# Example usage:
#   input CreateUserInput {
#     username: String! @validate(minLength: 3, maxLength: 32, pattern: "^[a-z0-9_]+$")
#     email: String! @validate(format: EMAIL)
#     age: Int @validate(min: 0, max: 150)
#   }
# -----------------------------------------------------------------------------
directive @validate(
  "Minimum value for numeric types"
  min: Int
  "Maximum value for numeric types"
  max: Int
  "Minimum length for string types"
  minLength: Int
  "Maximum length for string types"
  maxLength: Int
  "Regular expression pattern for string validation"
  pattern: String
  "Predefined format validation (EMAIL, URL, UUID, IPV4, IPV6, MAC, CIDR)"
  format: ValidateFormat
) on INPUT_FIELD_DEFINITION | FIELD_DEFINITION | ARGUMENT_DEFINITION

"""
Predefined validation formats for common data types
"""
enum ValidateFormat {
  EMAIL
  URL
  UUID
  IPV4
  IPV6
  MAC
  CIDR
  HOSTNAME
  FQDN
}

# -----------------------------------------------------------------------------
# Platform Mapping Directives
# -----------------------------------------------------------------------------
# These directives map GraphQL fields to platform-specific API paths.
# The resolver layer uses these to translate operations to router commands.
#
# Example usage:
#   type Interface {
#     name: String! @mikrotik(path: "/interface", field: "name") @openwrt(ubus: "network.interface", field: "interface")
#   }
# -----------------------------------------------------------------------------

"""
Maps field to MikroTik RouterOS API path and command
"""
directive @mikrotik(
  "RouterOS API path (e.g., '/ip/address', '/interface/ethernet')"
  path: String!
  "Field name in RouterOS response if different from GraphQL field"
  field: String
  "RouterOS command (print, add, set, remove) - defaults to contextual"
  cmd: String
) on FIELD_DEFINITION | OBJECT

"""
Maps field to OpenWrt ubus call
"""
directive @openwrt(
  "Ubus namespace and method (e.g., 'network.interface', 'system.board')"
  ubus: String!
  "Method to call (list, call, etc.)"
  method: String
  "Field name in ubus response if different from GraphQL field"
  field: String
) on FIELD_DEFINITION | OBJECT

"""
Maps field to VyOS configuration path
"""
directive @vyos(
  "VyOS configuration path (e.g., 'interfaces ethernet eth0')"
  path: String!
  "Field name in VyOS response if different from GraphQL field"
  field: String
) on FIELD_DEFINITION | OBJECT

# -----------------------------------------------------------------------------
# Capability Directive
# -----------------------------------------------------------------------------
# Gates field access based on router capabilities.
# Resolver checks if connected router has required capabilities before
# attempting to fetch/mutate the field.
#
# Example usage:
#   type WirelessInterface {
#     channel: Int! @capability(requires: ["wireless"])
#     wifiWave2: Boolean @capability(requires: ["wireless", "wifi-wave2"])
#   }
# -----------------------------------------------------------------------------
directive @capability(
  "List of required capability identifiers"
  requires: [String!]!
) on FIELD_DEFINITION | OBJECT

# -----------------------------------------------------------------------------
# Subscription Directive
# -----------------------------------------------------------------------------
# Marks a field as subscribable for real-time updates.
#
# Example usage:
#   type Subscription {
#     interfaceTraffic(interfaceId: ID!): TrafficUpdate! @realtime(interval: 1000)
#   }
# -----------------------------------------------------------------------------
directive @realtime(
  "Update interval in milliseconds"
  interval: Int
  "Topic/channel name for pub/sub"
  topic: String
) on FIELD_DEFINITION

# -----------------------------------------------------------------------------
# Caching Directive
# -----------------------------------------------------------------------------
# Hints for client-side and server-side caching behavior.
#
# Example usage:
#   type SystemInfo {
#     version: String! @cache(maxAge: 3600)
#     uptime: Duration! @cache(maxAge: 5)
#   }
# -----------------------------------------------------------------------------
directive @cache(
  "Maximum age in seconds"
  maxAge: Int!
  "Cache scope (PRIVATE for user-specific, PUBLIC for shared)"
  scope: CacheScope
) on FIELD_DEFINITION

enum CacheScope {
  PRIVATE
  PUBLIC
}

# -----------------------------------------------------------------------------
# Deprecated with migration hint
# -----------------------------------------------------------------------------
# Extended deprecation with migration guidance.
#
# Example usage:
#   type Query {
#     oldEndpoint: Data @deprecated(reason: "Use newEndpoint", replacement: "newEndpoint")
#   }
# -----------------------------------------------------------------------------
directive @migrateFrom(
  "The old field/type name this replaces"
  field: String!
  "Version when migration should be complete"
  removeInVersion: String
) on FIELD_DEFINITION | OBJECT | INPUT_FIELD_DEFINITION

# -----------------------------------------------------------------------------
# Sensitive Data Directive
# -----------------------------------------------------------------------------
# Marks fields containing sensitive data that should be redacted in logs
# and stripped from error responses in production mode.
#
# Example usage:
#   input CredentialsInput {
#     username: String!
#     password: String! @sensitive
#     apiKey: String @sensitive
#   }
#
#   type RouterSecret {
#     encryptedPassword: String! @sensitive
#     sshKey: String @sensitive
#   }
# -----------------------------------------------------------------------------
"""
Marks field as containing sensitive data (passwords, tokens, keys).
Values are redacted in logs and error responses.
"""
directive @sensitive on FIELD_DEFINITION | INPUT_FIELD_DEFINITION | ARGUMENT_DEFINITION

# -----------------------------------------------------------------------------
# Auth Directive
# -----------------------------------------------------------------------------
# Requires authentication and optional role/permission checks.
# Must be authenticated to access fields with this directive.
#
# Example usage:
#   type Mutation {
#     deleteRouter(id: ID!): Boolean! @auth(requires: "admin")
#     updateSettings: Settings! @auth  # Just requires authentication
#   }
# -----------------------------------------------------------------------------
"""
Requires authentication to access this field.
Optionally requires a specific role or permission.
"""
directive @auth(
  "Required role or permission level (e.g., 'admin', 'operator', 'viewer')"
  requires: String
) on FIELD_DEFINITION | OBJECT
