# =============================================================================
# Network Management GraphQL Schema
# =============================================================================
# This schema defines types for advanced network management including:
# - VLAN interfaces (802.1Q)
# - Bridge port VLAN configuration
# - Network topology
#
# These types extend the base Interface type defined in schema.graphql
# =============================================================================

# -----------------------------------------------------------------------------
# VLAN Types
# -----------------------------------------------------------------------------

"""
A VLAN (Virtual LAN) interface for network segmentation using 802.1Q tagging
"""
type Vlan implements Node {
  "Unique VLAN identifier"
  id: ID!
  "VLAN interface name (e.g., vlan10, vlan-guest)"
  name: String! @validate(minLength: 1, maxLength: 100) @mikrotik(path: "/interface/vlan", field: "name")
  "802.1Q VLAN ID (1-4094)"
  vlanId: Int! @validate(min: 1, max: 4094) @mikrotik(path: "/interface/vlan", field: "vlan-id")
  "Parent interface (bridge or physical interface)"
  interface: Interface! @mikrotik(path: "/interface/vlan", field: "interface")
  "MTU setting (optional, inherits from parent if not set)"
  mtu: Int @validate(min: 68, max: 65535) @mikrotik(path: "/interface/vlan", field: "mtu")
  "MAC address of the VLAN interface"
  macAddress: MAC @mikrotik(path: "/interface/vlan", field: "mac-address")
  "Whether the VLAN interface is disabled"
  disabled: Boolean! @mikrotik(path: "/interface/vlan", field: "disabled")
  "Whether the VLAN interface is running (link up)"
  running: Boolean! @mikrotik(path: "/interface/vlan", field: "running")
  "User comment"
  comment: String @mikrotik(path: "/interface/vlan", field: "comment")
  "IP addresses assigned to this VLAN"
  ipAddresses: [IpAddress!]!
  "Traffic statistics for this VLAN"
  statistics: InterfaceStats
}

"""
Input for creating a new VLAN interface
"""
input VlanInput {
  "VLAN interface name (alphanumeric, hyphens, underscores)"
  name: String! @validate(minLength: 1, maxLength: 100, pattern: "^[a-zA-Z0-9_-]+$")
  "802.1Q VLAN ID (1-4094)"
  vlanId: Int! @validate(min: 1, max: 4094)
  "Parent interface ID (bridge or physical interface)"
  interface: ID!
  "MTU setting (optional, inherits from parent if not set)"
  mtu: Int @validate(min: 68, max: 65535)
  "User comment"
  comment: String @validate(maxLength: 255)
}

"""
Filter options for querying VLANs
"""
input VlanFilter {
  "Filter by parent interface ID"
  parentInterface: ID
  "Filter by VLAN ID range"
  vlanIdRange: IntRange
  "Filter by name containing this string"
  nameContains: String
}

"""
Integer range for filtering
"""
input IntRange {
  "Minimum value (inclusive)"
  min: Int
  "Maximum value (inclusive)"
  max: Int
}

"""
Result of a VLAN mutation (create, update)
"""
type VlanMutationResult {
  "Whether the operation succeeded"
  success: Boolean!
  "The created or updated VLAN (if successful)"
  vlan: Vlan
  "Configuration preview (RouterOS commands that will be executed)"
  preview: ConfigPreview
  "Errors that occurred during the operation"
  errors: [MutationError!]
}

"""
Result of a delete operation
"""
type DeleteResult {
  "Whether the deletion succeeded"
  success: Boolean!
  "Success or error message"
  message: String
  "Errors that occurred during deletion"
  errors: [MutationError!]
}

"""
Preview of RouterOS configuration commands
"""
type ConfigPreview {
  "RouterOS commands to be executed"
  commands: [String!]!
  "Warnings about the configuration changes"
  warnings: [String!]
  "Resources that will be affected"
  affectedResources: [AffectedResource!]
}

"""
Resource affected by a configuration change
"""
type AffectedResource {
  "Resource type (ip-address, dhcp-server, firewall-rule, etc.)"
  type: String!
  "Resource ID"
  id: ID!
  "Resource name or description"
  name: String!
  "How the resource will be affected (modified, disabled, removed)"
  impact: ResourceImpact!
}

"""
Impact level for affected resources
"""
enum ResourceImpact {
  "Resource will be modified"
  MODIFIED
  "Resource will be disabled"
  DISABLED
  "Resource will be removed"
  REMOVED
  "Connections will be dropped"
  CONNECTION_DROP
}

# -----------------------------------------------------------------------------
# IP Address Types
# -----------------------------------------------------------------------------

"""
An IP address assigned to an interface
"""
type IpAddress implements Node {
  "Unique IP address identifier"
  id: ID!
  "IP address with CIDR notation (e.g., 192.168.10.1/24)"
  address: String! @validate(format: CIDR) @mikrotik(path: "/ip/address", field: "address")
  "Network address (calculated from address and netmask)"
  network: String
  "Broadcast address (calculated from address and netmask)"
  broadcast: String
  "Interface this IP is assigned to"
  interface: Interface! @mikrotik(path: "/ip/address", field: "interface")
  "Whether this IP is disabled"
  disabled: Boolean! @mikrotik(path: "/ip/address", field: "disabled")
  "Whether this IP was dynamically assigned (via DHCP client)"
  dynamic: Boolean! @mikrotik(path: "/ip/address", field: "dynamic")
  "Whether this IP is invalid (conflicting or error state)"
  invalid: Boolean! @mikrotik(path: "/ip/address", field: "invalid")
  "User comment"
  comment: String @validate(maxLength: 255) @mikrotik(path: "/ip/address", field: "comment")
}

"""
Input for creating or updating an IP address
"""
input IpAddressInput {
  "IP address with CIDR notation (e.g., 192.168.10.1/24)"
  address: String! @validate(format: CIDR)
  "Interface ID to assign this IP to"
  interfaceId: ID!
  "User comment"
  comment: String @validate(maxLength: 255)
  "Whether this IP is disabled"
  disabled: Boolean
}

"""
Result of an IP address mutation (create, update)
"""
type IpAddressMutationResult {
  "Whether the operation succeeded"
  success: Boolean!
  "The created or updated IP address (if successful)"
  ipAddress: IpAddress
  "Configuration preview (RouterOS commands)"
  preview: ConfigPreview
  "Errors that occurred during the operation"
  errors: [MutationError!]
}

"""
Result of an IP address deletion with dependency checking
"""
type IpAddressDeleteResult {
  "Whether the deletion succeeded"
  success: Boolean!
  "Success or error message"
  message: String
  "Impact analysis for this IP address deletion"
  impactAnalysis: IpAddressImpactAnalysis
  "Errors that occurred during deletion"
  errors: [MutationError!]
}

"""
Analysis of the impact of deleting an IP address
"""
type IpAddressImpactAnalysis {
  "Whether this IP is used as a gateway by DHCP servers"
  usedByDhcpServers: [DhcpServer!]!
  "Whether this IP is referenced in firewall rules"
  usedInFirewallRules: [FirewallRuleReference!]!
  "Whether this IP is used in NAT rules"
  usedInNatRules: [NatRuleReference!]!
  "Number of active connections using this IP"
  activeConnections: Int!
  "Severity of the deletion"
  severity: ConfirmationSeverity!
  "Human-readable impact message"
  message: String!
  "List of consequences of deleting this IP"
  consequences: [String!]!
  "Whether the IP can be safely deleted"
  canDelete: Boolean!
}

"""
NAT rule reference type (lightweight for dependency tracking).
For full NAT rule management, see NatRule type in firewall.graphql.
"""
type NatRuleReference {
  "NAT rule ID"
  id: ID!
  "Rule chain (srcnat, dstnat)"
  chain: String!
  "Action (masquerade, dst-nat, src-nat)"
  action: String!
  "Source address"
  srcAddress: String
  "Destination address"
  dstAddress: String
  "To address (for dst-nat)"
  toAddress: String
  "Whether the rule is disabled"
  disabled: Boolean!
}

"""
Result of checking IP address conflicts
"""
type IpConflictResult {
  "Whether the IP conflicts with existing assignments"
  hasConflict: Boolean!
  "List of conflicting IP addresses"
  conflicts: [IpConflict!]!
  "Human-readable message"
  message: String!
}

"""
Details about an IP address conflict
"""
type IpConflict {
  "Conflicting IP address ID"
  id: ID!
  "Conflicting IP address"
  address: String!
  "Interface where conflict exists"
  interface: Interface!
  "Type of conflict"
  conflictType: IpConflictType!
  "Explanation of the conflict"
  explanation: String!
}

"""
Type of IP address conflict
"""
enum IpConflictType {
  "Exact IP address match on different interface"
  EXACT
  "IP addresses are in overlapping subnets"
  SUBNET_OVERLAP
  "IP is the broadcast address of another subnet"
  BROADCAST
  "IP is the network address of another subnet"
  NETWORK
}

"""
Dependencies for an IP address
"""
type IpAddressDependencies {
  "IP address ID"
  ipAddressId: ID!
  "DHCP servers using this IP as gateway"
  dhcpServers: [DhcpServer!]!
  "Static routes using this IP"
  routes: [Route!]!
  "NAT rules referencing this IP"
  natRules: [NatRuleReference!]!
  "Firewall rules referencing this IP"
  firewallRules: [FirewallRuleReference!]!
  "Whether the IP has any dependencies"
  hasDependencies: Boolean!
}

"""
Interface traffic statistics
"""
type InterfaceStats {
  "Total bytes transmitted"
  txBytes: Size!
  "Total bytes received"
  rxBytes: Size!
  "Total packets transmitted"
  txPackets: Size!
  "Total packets received"
  rxPackets: Size!
  "Transmission errors"
  txErrors: Int!
  "Receive errors"
  rxErrors: Int!
  "Transmission drops"
  txDrops: Int!
  "Receive drops"
  rxDrops: Int!
}

"""
Historical interface statistics with time-series data
"""
type InterfaceStatsHistory {
  "Interface ID"
  interfaceId: ID!
  "Time-series data points"
  dataPoints: [StatsDataPoint!]!
  "Aggregation interval (e.g., 5m, 1h)"
  interval: Duration!
  "Start of the time range"
  startTime: DateTime!
  "End of the time range"
  endTime: DateTime!
}

"""
A single data point in interface statistics history
"""
type StatsDataPoint {
  "Timestamp of the data point"
  timestamp: DateTime!
  "Transmit rate in bytes per second"
  txBytesPerSec: Float!
  "Receive rate in bytes per second"
  rxBytesPerSec: Float!
  "Transmit rate in packets per second"
  txPacketsPerSec: Float!
  "Receive rate in packets per second"
  rxPacketsPerSec: Float!
  "Transmission errors in this interval"
  txErrors: Int!
  "Receive errors in this interval"
  rxErrors: Int!
}

"""
Input for specifying a time range
"""
input StatsTimeRangeInput {
  "Start of the time range"
  start: DateTime!
  "End of the time range"
  end: DateTime!
}

# -----------------------------------------------------------------------------
# Bridge Port VLAN Configuration
# -----------------------------------------------------------------------------

"""
VLAN configuration for a bridge port (trunk/access port setup)
"""
type BridgePortVlanConfig {
  "Bridge port ID"
  portId: ID!
  "Port VLAN ID (PVID) for untagged traffic"
  pvid: Int! @validate(min: 1, max: 4094)
  "Frame types allowed on this port"
  frameTypes: BridgePortFrameTypes!
  "Tagged VLANs allowed on this port (trunk mode)"
  taggedVlans: [Int!]! @validate(min: 1, max: 4094)
  "Untagged VLANs on this port (typically just PVID)"
  untaggedVlans: [Int!]! @validate(min: 1, max: 4094)
  "Port mode (trunk or access)"
  mode: PortMode!
}

"""
Frame types that can be admitted on a bridge port
"""
enum BridgePortFrameTypes {
  "Accept all frames (tagged and untagged)"
  ADMIT_ALL
  "Accept only untagged and priority-tagged frames"
  ADMIT_ONLY_UNTAGGED_AND_PRIORITY_TAGGED
  "Accept only VLAN-tagged frames"
  ADMIT_ONLY_VLAN_TAGGED
}

"""
Port mode for VLAN configuration
"""
enum PortMode {
  "Trunk port (carries multiple VLANs with tagging)"
  TRUNK
  "Access port (single VLAN, untagged)"
  ACCESS
}

"""
Input for configuring bridge port VLAN settings
"""
input BridgePortVlanInput {
  "Port VLAN ID (PVID) for untagged traffic"
  pvid: Int! @validate(min: 1, max: 4094)
  "Frame types allowed on this port"
  frameTypes: BridgePortFrameTypes!
  "Tagged VLANs (for trunk ports)"
  taggedVlans: [Int!] @validate(min: 1, max: 4094)
  "Port mode (trunk or access)"
  mode: PortMode!
}

# -----------------------------------------------------------------------------
# VLAN Dependencies
# -----------------------------------------------------------------------------

"""
Resources that depend on a VLAN interface
"""
type VlanDependencies {
  "VLAN interface ID"
  vlanId: ID!
  "IP addresses assigned to this VLAN"
  ipAddresses: [IpAddress!]!
  "DHCP servers using this VLAN"
  dhcpServers: [DhcpServer!]!
  "Firewall rules referencing this VLAN"
  firewallRules: [FirewallRuleReference!]!
  "Routes using this VLAN interface"
  routes: [Route!]!
  "Number of active connections on this VLAN"
  activeConnections: Int!
  "Whether the VLAN has any dependencies"
  hasDependencies: Boolean!
}

"""
DHCP server (minimal type for dependencies)
"""
type DhcpServer {
  "DHCP server ID"
  id: ID!
  "DHCP server name"
  name: String!
  "Interface the DHCP server is bound to"
  interface: Interface!
  "Whether the DHCP server is disabled"
  disabled: Boolean!
}

"""
Firewall rule reference type (lightweight for dependency tracking).
For full firewall rule management, see FirewallRule type in firewall.graphql.
"""
type FirewallRuleReference {
  "Firewall rule ID"
  id: ID!
  "Rule chain"
  chain: String!
  "Rule action"
  action: String!
  "Input interface filter"
  inInterface: String
  "Output interface filter"
  outInterface: String
  "Whether the rule is disabled"
  disabled: Boolean!
}

"""
Route type for static and dynamic routing
"""
type Route implements Node {
  "Route ID"
  id: ID!
  "Destination network in CIDR notation"
  destination: CIDR! @mikrotik(path: "/ip/route", field: "dst-address")
  "Gateway address"
  gateway: IPv4 @mikrotik(path: "/ip/route", field: "gateway")
  "Interface used for this route"
  interface: String @mikrotik(path: "/ip/route", field: "interface")
  "Route distance/metric (1-255)"
  distance: Int! @validate(min: 1, max: 255) @mikrotik(path: "/ip/route", field: "distance")
  "Routing mark for policy routing"
  routingMark: String @mikrotik(path: "/ip/route", field: "routing-mark")
  "Routing table name (main, vpn, etc.)"
  routingTable: String @mikrotik(path: "/ip/route", field: "routing-table")
  "Route type (static, connected, dynamic, BGP, OSPF)"
  type: RouteType!
  "Route scope"
  scope: RouteScope!
  "User comment"
  comment: String @validate(maxLength: 255) @mikrotik(path: "/ip/route", field: "comment")
  "Whether the route is active"
  active: Boolean!
  "Whether the route is disabled"
  disabled: Boolean @mikrotik(path: "/ip/route", field: "disabled")
}

"""
Route type classification
"""
enum RouteType {
  "Static route (manually configured)"
  STATIC
  "Connected route (directly connected network)"
  CONNECTED
  "Dynamic route (learned via routing protocol)"
  DYNAMIC
  "BGP route"
  BGP
  "OSPF route"
  OSPF
}

"""
Route scope
"""
enum RouteScope {
  "Global route (forwarded between interfaces)"
  GLOBAL
  "Link-local route (not forwarded)"
  LINK
  "Host-local route"
  HOST
}

"""
Input for creating or updating a route
"""
input RouteInput {
  "Destination network in CIDR notation"
  destination: CIDR!
  "Gateway address (optional if interface is provided)"
  gateway: IPv4
  "Interface used for this route (optional if gateway is provided)"
  interface: String
  "Route distance/metric (1-255, default: 1)"
  distance: Int @validate(min: 1, max: 255)
  "Routing mark for policy routing"
  routingMark: String
  "Routing table name (default: main)"
  routingTable: String
  "User comment"
  comment: String @validate(maxLength: 255)
}

"""
Result of a route mutation (create, update)
"""
type RouteMutationResult {
  "Whether the operation succeeded"
  success: Boolean!
  "Success or error message"
  message: String
  "The created or updated route (if successful)"
  route: Route
}

"""
Result of a route deletion with impact analysis
"""
type RouteDeleteResult {
  "Whether the deletion succeeded"
  success: Boolean!
  "Success or error message"
  message: String
  "Impact analysis for this route deletion"
  impactAnalysis: RouteImpactAnalysis!
}

"""
Analysis of the impact of deleting a route
"""
type RouteImpactAnalysis {
  "Whether this is the default route (0.0.0.0/0)"
  isDefaultRoute: Boolean!
  "Description of affected traffic"
  affectedTraffic: String!
  "Severity of the deletion (CRITICAL for default route, STANDARD for others)"
  severity: ConfirmationSeverity!
  "Human-readable message about the impact"
  message: String!
  "List of consequences of deleting this route"
  consequences: [String!]!
}

"""
Severity level for confirmation dialogs
"""
enum ConfirmationSeverity {
  "Critical operation requiring explicit confirmation"
  CRITICAL
  "Standard operation with brief confirmation"
  STANDARD
}

"""
Result of checking gateway reachability
"""
type GatewayReachabilityResult {
  "Whether the gateway is reachable"
  reachable: Boolean!
  "Ping latency in milliseconds (null if unreachable)"
  latency: Int
  "Interface through which gateway is reachable (null if unreachable)"
  interface: String
  "Human-readable message about reachability"
  message: String!
}

# -----------------------------------------------------------------------------
# VLAN Topology Types
# -----------------------------------------------------------------------------

"""
Node in a VLAN network topology diagram
"""
type TopologyNode {
  "Node ID"
  id: ID!
  "Node type (bridge, vlan, port)"
  type: TopologyNodeType!
  "Display label"
  label: String!
  "Sub-label (optional)"
  sublabel: String
  "Node position in the diagram"
  position: TopologyPosition!
  "Additional node data"
  data: JSON
  "Node styling"
  style: TopologyNodeStyle
}

"""
Type of topology node
"""
enum TopologyNodeType {
  "Bridge interface"
  BRIDGE
  "VLAN interface"
  VLAN
  "Physical port"
  PORT
}

"""
Position of a node in the topology
"""
type TopologyPosition {
  "X coordinate"
  x: Float!
  "Y coordinate"
  y: Float!
}

"""
Styling for topology nodes
"""
type TopologyNodeStyle {
  "Fill color (CSS color)"
  fill: String
  "Stroke color (CSS color)"
  stroke: String
  "Stroke width in pixels"
  strokeWidth: Float
}

"""
Edge connecting nodes in a topology
"""
type TopologyEdge {
  "Edge ID"
  id: ID!
  "Source node ID"
  source: ID!
  "Target node ID"
  target: ID!
  "Edge label (optional)"
  label: String
  "Additional edge data"
  data: JSON
  "Edge styling"
  style: TopologyEdgeStyle
}

"""
Styling for topology edges
"""
type TopologyEdgeStyle {
  "Stroke color (CSS color)"
  stroke: String
  "Stroke width in pixels"
  strokeWidth: Float
  "Stroke dash array (for dashed lines)"
  strokeDasharray: String
}

"""
VLAN topology data (nodes and edges)
"""
type VlanTopology {
  "Topology nodes (bridges, VLANs, ports)"
  nodes: [TopologyNode!]!
  "Topology edges (connections)"
  edges: [TopologyEdge!]!
}

# -----------------------------------------------------------------------------
# Query Extensions
# -----------------------------------------------------------------------------

extend type Query {
  """
  Get all IP addresses on a router with optional filtering
  """
  ipAddresses(
    "Router ID to query"
    routerId: ID!
    "Optional: filter by interface ID"
    interfaceId: ID
  ): [IpAddress!]! @capability(requires: ["interface"])

  """
  Get a specific IP address by ID
  """
  ipAddress(
    "Router ID"
    routerId: ID!
    "IP address ID"
    id: ID!
  ): IpAddress @capability(requires: ["interface"])

  """
  Check if an IP address conflicts with existing assignments
  """
  checkIpConflict(
    "Router ID"
    routerId: ID!
    "IP address to check (CIDR notation)"
    address: String!
    "Interface ID (optional, for scoped check)"
    interfaceId: ID
    "Exclude this IP ID from conflict check (for updates)"
    excludeId: ID
  ): IpConflictResult! @capability(requires: ["interface"])

  """
  Get dependencies for an IP address (DHCP servers, routes, etc.)
  """
  ipAddressDependencies(
    "Router ID"
    routerId: ID!
    "IP address ID"
    id: ID!
  ): IpAddressDependencies! @capability(requires: ["interface"])

  """
  Get all VLANs on a router with optional filtering
  """
  vlans(
    "Router ID to query"
    routerId: ID!
    "Optional filters"
    filter: VlanFilter
  ): [Vlan!]! @capability(requires: ["interface"])

  """
  Get a specific VLAN by ID
  """
  vlan(
    "VLAN ID"
    id: ID!
  ): Vlan @capability(requires: ["interface"])

  """
  Check if a VLAN ID is available on a parent interface
  """
  checkVlanIdAvailable(
    "Router ID"
    routerId: ID!
    "Parent interface ID"
    parentInterface: ID!
    "VLAN ID to check"
    vlanId: Int!
  ): Boolean! @capability(requires: ["interface"])

  """
  Get dependencies for a VLAN (IP addresses, DHCP, routes, etc.)
  """
  vlanDependencies(
    "VLAN ID"
    id: ID!
  ): VlanDependencies @capability(requires: ["interface"])

  """
  Get VLAN topology for a bridge
  """
  vlanTopology(
    "Router ID"
    routerId: ID!
    "Bridge ID"
    bridgeId: ID!
  ): VlanTopology @capability(requires: ["interface"])

  """
  Get all routes on a router with optional filtering
  """
  routes(
    "Router ID to query"
    routerId: ID!
    "Filter by routing table name (main, vpn, etc.)"
    table: String
    "Filter by route type (STATIC, CONNECTED, DYNAMIC, etc.)"
    type: RouteType
  ): [Route!]! @capability(requires: ["routing"])

  """
  Get a specific route by ID
  """
  route(
    "Router ID"
    routerId: ID!
    "Route ID"
    id: ID!
  ): Route @capability(requires: ["routing"])

  """
  Check if a gateway address is reachable from the router
  """
  checkGatewayReachability(
    "Router ID"
    routerId: ID!
    "Gateway IP address to check"
    gateway: IPv4!
  ): GatewayReachabilityResult! @capability(requires: ["routing"])

  """
  Get historical interface statistics for bandwidth analysis
  """
  interfaceStatsHistory(
    "Router ID"
    routerId: ID!
    "Interface ID"
    interfaceId: ID!
    "Time range for the query"
    timeRange: StatsTimeRangeInput!
    "Aggregation interval (default: 5m)"
    interval: Duration = "5m"
  ): InterfaceStatsHistory! @capability(requires: ["interface"])
}

# -----------------------------------------------------------------------------
# Mutation Extensions
# -----------------------------------------------------------------------------

extend type Mutation {
  """
  Assign a new IP address to an interface
  """
  createIpAddress(
    "Router ID"
    routerId: ID!
    "IP address input"
    input: IpAddressInput!
  ): IpAddressMutationResult! @capability(requires: ["interface"])

  """
  Update an existing IP address
  """
  updateIpAddress(
    "Router ID"
    routerId: ID!
    "IP address ID"
    id: ID!
    "Updated IP address data"
    input: IpAddressInput!
  ): IpAddressMutationResult! @capability(requires: ["interface"])

  """
  Remove an IP address from an interface
  """
  deleteIpAddress(
    "Router ID"
    routerId: ID!
    "IP address ID to delete"
    id: ID!
  ): IpAddressDeleteResult! @capability(requires: ["interface"])

  """
  Create a new VLAN interface
  """
  createVlan(
    "Router ID"
    routerId: ID!
    "VLAN input data"
    input: VlanInput!
  ): VlanMutationResult! @capability(requires: ["interface"])

  """
  Update an existing VLAN interface
  """
  updateVlan(
    "VLAN ID"
    id: ID!
    "Updated VLAN data"
    input: VlanInput!
  ): VlanMutationResult! @capability(requires: ["interface"])

  """
  Delete a VLAN interface
  """
  deleteVlan(
    "VLAN ID to delete"
    id: ID!
  ): DeleteResult! @capability(requires: ["interface"])

  """
  Configure VLAN settings on a bridge port (trunk/access)
  """
  configureBridgePortVlan(
    "Router ID"
    routerId: ID!
    "Bridge port ID"
    portId: ID!
    "VLAN configuration"
    input: BridgePortVlanInput!
  ): VlanMutationResult! @capability(requires: ["interface"])

  """
  Create a new static route
  """
  createRoute(
    "Router ID"
    routerId: ID!
    "Route input data"
    input: RouteInput!
  ): RouteMutationResult! @capability(requires: ["routing"])

  """
  Update an existing route
  """
  updateRoute(
    "Router ID"
    routerId: ID!
    "Route ID"
    id: ID!
    "Updated route data"
    input: RouteInput!
  ): RouteMutationResult! @capability(requires: ["routing"])

  """
  Delete a route with impact analysis
  """
  deleteRoute(
    "Router ID"
    routerId: ID!
    "Route ID to delete"
    id: ID!
  ): RouteDeleteResult! @capability(requires: ["routing"])
}

# -----------------------------------------------------------------------------
# Subscription Extensions
# -----------------------------------------------------------------------------

extend type Subscription {
  """
  Subscribe to IP address changes (create, update, delete)
  """
  ipAddressChanged(
    "Router ID to monitor"
    routerId: ID!
  ): IpAddressChangeEvent! @capability(requires: ["interface"])

  """
  Subscribe to VLAN interface changes (create, update, delete)
  """
  vlanChanged(
    "Router ID to monitor"
    routerId: ID!
  ): Vlan! @capability(requires: ["interface"])

  """
  Subscribe to real-time interface statistics updates
  """
  interfaceStatsUpdated(
    "Router ID to monitor"
    routerId: ID!
    "Interface ID to monitor"
    interfaceId: ID!
    "Polling interval (default: 5s, minimum: 1s)"
    interval: Duration = "5s"
  ): InterfaceStats! @capability(requires: ["interface"])
}

"""
Event emitted when an IP address changes
"""
type IpAddressChangeEvent {
  "Type of change (CREATED, UPDATED, DELETED)"
  changeType: ChangeType!
  "The IP address that changed"
  ipAddress: IpAddress
  "IP address ID (for deletions)"
  ipAddressId: ID!
  "Timestamp of the change"
  timestamp: DateTime!
}

# Note: ChangeType enum is defined in schema.graphql

# =============================================================================
# Tunnel Management Types
# =============================================================================
# Support for network tunnels (IPIP, GRE, EoIP, VXLAN) for connecting
# remote networks securely with L2/L3 overlay capabilities
# =============================================================================

# -----------------------------------------------------------------------------
# Tunnel Types
# -----------------------------------------------------------------------------

"""
Network tunnel types supported by MikroTik RouterOS
"""
enum TunnelType {
  "IP-in-IP tunnel (RFC 2003) - Basic L3 encapsulation"
  IPIP
  "Generic Routing Encapsulation (RFC 2784) - L3 with optional IPsec"
  GRE
  "Ethernet over IP - Layer 2 tunnel for bridge extension"
  EOIP
  "Virtual eXtensible LAN (RFC 7348) - L2 overlay network"
  VXLAN
  "Secure Socket Tunneling Protocol (future support)"
  SSTP
  "Layer 2 Tunneling Protocol (future support)"
  L2TP
}

"""
A network tunnel interface for connecting remote networks
"""
type Tunnel implements Node {
  "Unique tunnel identifier"
  id: ID!
  "Tunnel interface name"
  name: String! @validate(minLength: 1, maxLength: 100, pattern: "^[a-zA-Z0-9_-]+$") @mikrotik(path: "/interface/{type}", field: "name")
  "Tunnel protocol type"
  type: TunnelType!
  "Local endpoint IP address"
  localAddress: String! @validate(format: IPV4) @mikrotik(path: "/interface/{type}", field: "local-address")
  "Remote endpoint IP address"
  remoteAddress: String! @validate(format: IPV4) @mikrotik(path: "/interface/{type}", field: "remote-address")
  "Operational status of the tunnel"
  status: InterfaceStatus!
  "MTU setting for the tunnel interface"
  mtu: Int @validate(min: 68, max: 65535) @mikrotik(path: "/interface/{type}", field: "mtu")
  "IPsec profile name (GRE tunnels only)"
  ipsecProfile: String @mikrotik(path: "/interface/gre", field: "ipsec-profile")
  "Tunnel ID (EoIP tunnels only, must be unique per remote address pair)"
  tunnelId: Int @validate(min: 0, max: 65535) @mikrotik(path: "/interface/eoip", field: "tunnel-id")
  "VXLAN Network Identifier (VXLAN tunnels only)"
  vni: Int @validate(min: 1, max: 16777215) @mikrotik(path: "/interface/vxlan", field: "vni")
  "VXLAN port (default 4789)"
  port: Int @validate(min: 1, max: 65535) @mikrotik(path: "/interface/vxlan", field: "port")
  "VTEP peer addresses (VXLAN tunnels only)"
  vtepPeers: [String!] @mikrotik(path: "/interface/vxlan/vteps", field: "remote-ip")
  "Traffic statistics for this tunnel"
  statistics: InterfaceStats
  "User comment"
  comment: String @validate(maxLength: 255) @mikrotik(path: "/interface/{type}", field: "comment")
  "Whether the tunnel is disabled"
  disabled: Boolean @mikrotik(path: "/interface/{type}", field: "disabled")
}

"""
Input for creating or updating a tunnel
"""
input TunnelInput {
  "Tunnel interface name (alphanumeric, hyphens, underscores)"
  name: String! @validate(minLength: 1, maxLength: 100, pattern: "^[a-zA-Z0-9_-]+$")
  "Tunnel protocol type"
  type: TunnelType!
  "Local endpoint IP address"
  localAddress: String! @validate(format: IPV4)
  "Remote endpoint IP address"
  remoteAddress: String! @validate(format: IPV4)
  "MTU setting (optional, default calculated based on tunnel type)"
  mtu: Int @validate(min: 68, max: 65535)
  "IPsec profile name (GRE tunnels only)"
  ipsecProfile: String
  "Tunnel ID (EoIP tunnels only, 0-65535)"
  tunnelId: Int @validate(min: 0, max: 65535)
  "VXLAN Network Identifier (VXLAN tunnels only, 1-16777215)"
  vni: Int @validate(min: 1, max: 16777215)
  "VXLAN port (default 4789)"
  port: Int @validate(min: 1, max: 65535)
  "VTEP peer addresses (VXLAN tunnels only)"
  vtepPeers: [String!]
  "User comment"
  comment: String @validate(maxLength: 255)
}

"""
IPsec profile for GRE tunnel encryption
"""
type IpsecProfile {
  "IPsec profile ID"
  id: ID!
  "Profile name"
  name: String! @mikrotik(path: "/interface/ipsec/profile", field: "name")
  "User comment"
  comment: String @mikrotik(path: "/interface/ipsec/profile", field: "comment")
}

"""
Result of a tunnel connectivity test
"""
type TunnelTestResult {
  "Whether the remote endpoint is reachable"
  reachable: Boolean!
  "Average ping latency in milliseconds (null if unreachable)"
  latency: Float
  "Throughput in Mbps (null if iperf not available)"
  throughput: Float
  "Path MTU discovered (null if not tested)"
  mtuPath: Int
  "Suggestions for common connectivity issues"
  suggestions: [String!]!
}

"""
MTU guidance for tunnel configuration
"""
type MtuGuidance {
  "Tunnel type this guidance applies to"
  tunnelType: TunnelType!
  "Protocol overhead in bytes"
  overhead: Int!
  "Recommended MTU based on base MTU (typically 1500)"
  recommendedMtu: Int!
  "Human-readable explanation of the overhead"
  explanation: String!
}

"""
Result of a tunnel mutation (create, update)
"""
type TunnelMutationResult {
  "Whether the operation succeeded"
  success: Boolean!
  "The created or updated tunnel (if successful)"
  tunnel: Tunnel
  "Configuration preview (RouterOS commands)"
  preview: String
  "MTU guidance for the tunnel type"
  mtuGuidance: MtuGuidance
  "Errors that occurred during the operation"
  errors: [String!]!
}

# -----------------------------------------------------------------------------
# Tunnel Query Extensions
# -----------------------------------------------------------------------------

extend type Query {
  """
  Get all tunnels on a router with optional filtering by type
  """
  tunnels(
    "Router ID to query"
    routerId: ID!
    "Optional: filter by tunnel type"
    type: TunnelType
  ): [Tunnel!]! @capability(requires: ["interface"])

  """
  Get a specific tunnel by ID
  """
  tunnel(
    "Router ID"
    routerId: ID!
    "Tunnel ID"
    id: ID!
  ): Tunnel @capability(requires: ["interface"])

  """
  Get available IPsec profiles for GRE tunnel encryption
  """
  ipsecProfiles(
    "Router ID to query"
    routerId: ID!
  ): [IpsecProfile!]! @capability(requires: ["interface"])
}

# -----------------------------------------------------------------------------
# Tunnel Mutation Extensions
# -----------------------------------------------------------------------------

extend type Mutation {
  """
  Create a new tunnel interface
  """
  createTunnel(
    "Router ID"
    routerId: ID!
    "Tunnel configuration"
    input: TunnelInput!
  ): TunnelMutationResult! @capability(requires: ["interface"])

  """
  Update an existing tunnel interface
  """
  updateTunnel(
    "Router ID"
    routerId: ID!
    "Tunnel ID"
    id: ID!
    "Updated tunnel configuration"
    input: TunnelInput!
  ): TunnelMutationResult! @capability(requires: ["interface"])

  """
  Delete a tunnel interface
  """
  deleteTunnel(
    "Router ID"
    routerId: ID!
    "Tunnel ID to delete"
    id: ID!
  ): TunnelMutationResult! @capability(requires: ["interface"])

  """
  Test tunnel connectivity and path MTU
  """
  testTunnel(
    "Router ID"
    routerId: ID!
    "Tunnel ID to test"
    id: ID!
  ): TunnelTestResult! @capability(requires: ["interface"])
}

# -----------------------------------------------------------------------------
# Tunnel Subscription Extensions
# -----------------------------------------------------------------------------

extend type Subscription {
  """
  Subscribe to tunnel status changes (create, update, delete)
  """
  tunnelChanged(
    "Router ID to monitor"
    routerId: ID!
  ): Tunnel! @capability(requires: ["interface"])
}

# =============================================================================
# Port Mirroring Management Types
# =============================================================================
# Support for port mirroring (span/monitor ports) for traffic analysis and
# debugging network issues
# =============================================================================

# -----------------------------------------------------------------------------
# Port Mirror Types
# -----------------------------------------------------------------------------

"""
Direction of traffic to mirror
"""
enum MirrorDirection {
  "Mirror only ingress (incoming) traffic"
  INGRESS
  "Mirror only egress (outgoing) traffic"
  EGRESS
  "Mirror both ingress and egress traffic"
  BOTH
}

"""
A port mirror configuration for traffic monitoring and analysis
"""
type PortMirror implements Node {
  "Unique port mirror identifier"
  id: ID!
  "Descriptive name for the mirror configuration"
  name: String! @validate(minLength: 1, maxLength: 100, pattern: "^[a-zA-Z0-9_-]+$")
  "Source interfaces being mirrored"
  sourceInterfaces: [Interface!]! @mikrotik(path: "/interface/bridge/port", field: "interface")
  "Destination interface where mirrored traffic is sent"
  destinationInterface: Interface! @mikrotik(path: "/interface/bridge/port", field: "mirror-target")
  "Direction of traffic to mirror"
  direction: MirrorDirection!
  "Whether the mirror is enabled"
  enabled: Boolean!
  "User comment"
  comment: String @validate(maxLength: 255)
  "Statistics for the destination interface"
  statistics: PortMirrorStats
}

"""
Statistics for a port mirror destination interface
"""
type PortMirrorStats {
  "Total mirrored packets"
  mirroredPackets: Size!
  "Total mirrored bytes"
  mirroredBytes: Size!
  "Destination interface current load"
  destinationLoad: Float!
  "Whether the destination is saturated (dropping packets)"
  isSaturated: Boolean!
}

"""
Input for creating a new port mirror configuration
"""
input CreatePortMirrorInput {
  "Descriptive name for the mirror configuration"
  name: String! @validate(minLength: 1, maxLength: 100, pattern: "^[a-zA-Z0-9_-]+$")
  "Source interface IDs to mirror (must be bridge members)"
  sourceInterfaceIds: [ID!]! @validate(minLength: 1)
  "Destination interface ID for mirrored traffic"
  destinationInterfaceId: ID!
  "Direction of traffic to mirror (default: BOTH)"
  direction: MirrorDirection
  "User comment"
  comment: String @validate(maxLength: 255)
}

"""
Input for updating an existing port mirror configuration
"""
input UpdatePortMirrorInput {
  "Updated name"
  name: String @validate(minLength: 1, maxLength: 100, pattern: "^[a-zA-Z0-9_-]+$")
  "Updated source interface IDs (must be bridge members)"
  sourceInterfaceIds: [ID!] @validate(minLength: 1)
  "Updated destination interface ID"
  destinationInterfaceId: ID
  "Updated direction of traffic to mirror"
  direction: MirrorDirection
  "Updated comment"
  comment: String @validate(maxLength: 255)
}

"""
Result of a port mirror mutation (create, update)
"""
type PortMirrorMutationResult {
  "Whether the operation succeeded"
  success: Boolean!
  "The created or updated port mirror (if successful)"
  portMirror: PortMirror
  "Configuration preview (RouterOS commands)"
  preview: ConfigPreview
  "Errors that occurred during the operation"
  errors: [MutationError!]
}

# -----------------------------------------------------------------------------
# Port Mirror Query Extensions
# -----------------------------------------------------------------------------

extend type Query {
  """
  Get all port mirror configurations on a router
  """
  portMirrors(
    "Router ID to query"
    routerId: ID!
  ): [PortMirror!]! @capability(requires: ["interface"])

  """
  Get a specific port mirror by ID
  """
  portMirror(
    "Router ID"
    routerId: ID!
    "Port mirror ID"
    id: ID!
  ): PortMirror @capability(requires: ["interface"])
}

# -----------------------------------------------------------------------------
# Port Mirror Mutation Extensions
# -----------------------------------------------------------------------------

extend type Mutation {
  """
  Create a new port mirror configuration
  """
  createPortMirror(
    "Router ID"
    routerId: ID!
    "Port mirror configuration"
    input: CreatePortMirrorInput!
  ): PortMirrorMutationResult! @capability(requires: ["interface"])

  """
  Update an existing port mirror configuration
  """
  updatePortMirror(
    "Router ID"
    routerId: ID!
    "Port mirror ID"
    id: ID!
    "Updated configuration"
    input: UpdatePortMirrorInput!
  ): PortMirrorMutationResult! @capability(requires: ["interface"])

  """
  Delete a port mirror configuration
  """
  deletePortMirror(
    "Router ID"
    routerId: ID!
    "Port mirror ID to delete"
    id: ID!
  ): DeleteResult! @capability(requires: ["interface"])

  """
  Enable a port mirror configuration
  """
  enablePortMirror(
    "Router ID"
    routerId: ID!
    "Port mirror ID"
    id: ID!
  ): PortMirrorMutationResult! @capability(requires: ["interface"])

  """
  Disable a port mirror configuration
  """
  disablePortMirror(
    "Router ID"
    routerId: ID!
    "Port mirror ID"
    id: ID!
  ): PortMirrorMutationResult! @capability(requires: ["interface"])
}

# -----------------------------------------------------------------------------
# Port Mirror Subscription Extensions
# -----------------------------------------------------------------------------

extend type Subscription {
  """
  Subscribe to port mirror status changes
  """
  portMirrorChanged(
    "Router ID to monitor"
    routerId: ID!
  ): PortMirror! @capability(requires: ["interface"])
}
