# =============================================================================
# Connection Diagnostics GraphQL Schema Extension
# =============================================================================
# This schema provides types and operations for diagnosing router connection
# issues, providing actionable troubleshooting suggestions, and exposing
# circuit breaker state.
# Story: NAS-3.10 - Implement Connection Diagnostics
# =============================================================================

# -----------------------------------------------------------------------------
# Diagnostic Types
# -----------------------------------------------------------------------------

"""
Severity level for diagnostic suggestions
"""
enum SuggestionSeverity {
  "Informational message, no action required"
  INFO
  "Warning that may affect functionality"
  WARNING
  "Error that needs to be addressed"
  ERROR
  "Critical issue blocking connectivity"
  CRITICAL
}

"""
Category of connection error for classification
"""
enum ErrorCategory {
  "Connection or response timeout"
  TIMEOUT
  "Connection actively refused"
  REFUSED
  "Authentication failed"
  AUTH_FAILED
  "Protocol-level error"
  PROTOCOL_ERROR
  "Network unreachable or DNS failure"
  NETWORK_ERROR
  "TLS/SSL certificate or handshake error"
  TLS_ERROR
}

"""
Status of a single port check
"""
type PortStatus {
  "Port number checked"
  port: Int!
  "Service name (API, API-SSL, SSH, Telnet, HTTP, HTTPS)"
  service: String!
  "Whether the port is open and accepting connections"
  open: Boolean!
  "Response time in milliseconds (if port is open)"
  responseTimeMs: Int
  "Error message (if port is closed)"
  error: String
}

"""
TLS certificate status for secure connections
"""
type TLSStatus {
  "Whether the certificate is valid"
  valid: Boolean!
  "Certificate issuer"
  issuer: String
  "Certificate subject"
  subject: String
  "Certificate expiration date"
  expiresAt: DateTime
  "Error message (if certificate is invalid)"
  error: String
}

"""
Authentication test status
"""
type AuthStatus {
  "Whether authentication was tested"
  tested: Boolean!
  "Whether authentication succeeded"
  success: Boolean!
  "Error message (if authentication failed)"
  error: String
  "Error code mapped to ErrorCodes (A5xx)"
  errorCode: String
}

"""
Actionable diagnostic suggestion
"""
type DiagnosticSuggestion {
  "Severity level of the issue"
  severity: SuggestionSeverity!
  "Short title describing the issue"
  title: String!
  "Detailed description of the issue"
  description: String!
  "Recommended action to resolve the issue"
  action: String!
  "Link to relevant documentation"
  docsUrl: String
}

"""
Comprehensive diagnostic report for a router
"""
type DiagnosticReport {
  "Router ID being diagnosed"
  routerId: ID!
  "When the diagnostic was run"
  timestamp: DateTime!
  "Whether the router is reachable on the network"
  networkReachable: Boolean!
  "Status of each checked port"
  portStatus: [PortStatus!]!
  "TLS certificate status (if TLS ports were checked)"
  tlsStatus: TLSStatus
  "Authentication test status"
  authStatus: AuthStatus!
  "Actionable suggestions based on diagnostic results"
  suggestions: [DiagnosticSuggestion!]!
  "Raw text report for clipboard/export"
  rawReport: String!
}

"""
Record of a single protocol connection attempt
"""
type ConnectionAttempt {
  "Protocol that was attempted"
  protocol: Protocol!
  "When the attempt started"
  startedAt: DateTime!
  "When the attempt ended"
  endedAt: DateTime!
  "Whether the attempt succeeded"
  success: Boolean!
  "Error code if failed"
  errorCode: String
  "Error message if failed"
  errorMessage: String
  "Error category for classification"
  errorCategory: ErrorCategory
}

"""
Circuit breaker status for a router
"""
type CircuitBreakerStatus {
  "Router ID"
  routerId: ID!
  "Current circuit breaker state"
  state: CircuitBreakerState!
  "Number of consecutive failures"
  failureCount: Int!
  "Failure threshold before circuit opens"
  failureThreshold: Int!
  "Seconds until auto-retry (when circuit is open)"
  cooldownRemainingSeconds: Int
  "When the last failure occurred"
  lastFailureAt: DateTime
  "When the last success occurred"
  lastSuccessAt: DateTime
}

# -----------------------------------------------------------------------------
# Query Extensions
# -----------------------------------------------------------------------------

extend type Query {
  """
  Get recent connection attempts for a router.
  Returns the most recent attempts, ordered newest first.
  """
  connectionAttempts(
    "Router ID to get attempts for"
    routerId: ID!
    "Maximum number of attempts to return (default: 10)"
    limit: Int = 10
  ): [ConnectionAttempt!]!

  """
  Get circuit breaker status for a router.
  Shows current state, failure counts, and cooldown timing.
  """
  circuitBreakerStatus(routerId: ID!): CircuitBreakerStatus!
}

# -----------------------------------------------------------------------------
# Mutation Extensions
# -----------------------------------------------------------------------------

extend type Mutation {
  """
  Run comprehensive diagnostics on a router connection.
  Performs network reachability check, port scanning, TLS validation,
  and authentication testing. Rate limited to 1 request per 10 seconds per router.
  """
  runDiagnostics(routerId: ID!): DiagnosticReport!

  """
  Manually reset the circuit breaker for a router.
  This allows immediate reconnection attempts even if the circuit is open.
  Use with caution as it bypasses the backoff protection.
  """
  resetCircuitBreaker(routerId: ID!): CircuitBreakerStatus!
}

# -----------------------------------------------------------------------------
# Subscription Extensions
# -----------------------------------------------------------------------------

extend type Subscription {
  """
  Subscribe to circuit breaker state changes for a router.
  Emits an event whenever the circuit breaker transitions between states.
  """
  circuitBreakerStateChanged(
    "Router ID to monitor (optional, all routers if not specified)"
    routerId: ID
  ): CircuitBreakerStatus!
}

# =============================================================================
# Internet Troubleshooting (No Internet Wizard)
# =============================================================================
# This schema provides types and operations for diagnosing internet connectivity
# issues on routers, running automated diagnostics, and applying fixes.
# Story: NAS-5.11 - Implement No Internet Troubleshooting Wizard
# =============================================================================

# -----------------------------------------------------------------------------
# Internet Troubleshooting Types
# -----------------------------------------------------------------------------

"""
Diagnostic step identifier for internet troubleshooting
"""
enum TroubleshootStepType {
  "Check WAN interface status"
  WAN
  "Ping default gateway"
  GATEWAY
  "Ping external internet server"
  INTERNET
  "Test DNS resolution"
  DNS
  "Verify NAT/masquerade rules"
  NAT
}

"""
Status of a diagnostic step
"""
enum TroubleshootStepStatus {
  "Step not yet started"
  PENDING
  "Step currently executing"
  RUNNING
  "Step completed successfully"
  PASSED
  "Step failed"
  FAILED
  "Step skipped"
  SKIPPED
}

"""
Confidence level for a fix suggestion
"""
enum FixConfidence {
  "High confidence this fix will resolve the issue"
  HIGH
  "Medium confidence, may resolve the issue"
  MEDIUM
  "Low confidence, worth trying as last resort"
  LOW
}

"""
Status of a fix application
"""
enum FixApplicationStatus {
  "Fix is available but not yet applied"
  AVAILABLE
  "Fix is being applied"
  APPLYING
  "Fix was applied successfully"
  APPLIED
  "Fix application failed"
  FAILED
  "Fix was applied but issue persists"
  ISSUE_PERSISTS
}

"""
Result of a single diagnostic step
"""
type TroubleshootStepResult {
  "Whether the check passed"
  success: Boolean!
  "User-friendly message about the result"
  message: String!
  "Technical details for debugging"
  details: String
  "Execution time in milliseconds"
  executionTimeMs: Int!
  "Detected error code"
  issueCode: String
  "Target that was checked (IP, interface name, etc.)"
  target: String
}

"""
Suggested fix for a failed diagnostic step
"""
type TroubleshootFixSuggestion {
  "Unique issue code (e.g., WAN_DISABLED, NO_DEFAULT_ROUTE)"
  issueCode: String!
  "User-friendly fix title"
  title: String!
  "Detailed explanation of what will be fixed"
  explanation: String!
  "Confidence level for this fix"
  confidence: FixConfidence!
  "Whether user confirmation is required before applying"
  requiresConfirmation: Boolean!
  "Whether this is a manual fix (requires user action)"
  isManualFix: Boolean!
  "Manual steps if this cannot be automated"
  manualSteps: [String!]
  "RouterOS command that will be executed"
  command: String
  "Rollback command if fix needs to be reverted"
  rollbackCommand: String
}

"""
ISP contact information
"""
type ISPInfo {
  "ISP name"
  name: String!
  "ISP support phone number"
  phone: String
  "ISP support website URL"
  url: String
}

"""
A single step in the troubleshooting wizard
"""
type TroubleshootStep {
  "Step type/ID"
  id: TroubleshootStepType!
  "Step display name"
  name: String!
  "Step description"
  description: String!
  "Current status of this step"
  status: TroubleshootStepStatus!
  "Result of executing this step"
  result: TroubleshootStepResult
  "Suggested fix if step failed"
  fix: TroubleshootFixSuggestion
  "When the step started"
  startedAt: DateTime
  "When the step completed"
  completedAt: DateTime
}

"""
Complete troubleshooting session
"""
type TroubleshootSession {
  "Unique session identifier"
  id: ID!
  "Router being diagnosed"
  routerId: ID!
  "All diagnostic steps"
  steps: [TroubleshootStep!]!
  "Current step index (0-based)"
  currentStepIndex: Int!
  "Overall session status"
  status: TroubleshootSessionStatus!
  "Detected WAN interface name"
  wanInterface: String
  "Detected default gateway IP"
  gateway: String
  "Detected ISP information"
  ispInfo: ISPInfo
  "Fixes that have been applied"
  appliedFixes: [String!]!
  "When the session started"
  startedAt: DateTime!
  "When the session completed"
  completedAt: DateTime
}

"""
Overall status of a troubleshooting session
"""
enum TroubleshootSessionStatus {
  "Session created but not started"
  IDLE
  "Detecting network configuration"
  INITIALIZING
  "Running diagnostic steps"
  RUNNING
  "Waiting for user decision on fix"
  AWAITING_FIX_DECISION
  "Applying a fix"
  APPLYING_FIX
  "Verifying fix worked"
  VERIFYING_FIX
  "Session completed"
  COMPLETED
  "Session was cancelled"
  CANCELLED
}

"""
Result of starting a troubleshooting session
"""
type StartTroubleshootPayload {
  "The created session"
  session: TroubleshootSession
  "Errors that occurred"
  errors: [MutationError!]
}

"""
Result of running a diagnostic step
"""
type RunTroubleshootStepPayload {
  "Updated step with result"
  step: TroubleshootStep!
  "Errors that occurred"
  errors: [MutationError!]
}

"""
Result of applying a fix
"""
type ApplyFixPayload {
  "Whether fix was applied successfully"
  success: Boolean!
  "User-friendly message"
  message: String!
  "Fix application status"
  status: FixApplicationStatus!
  "Errors that occurred"
  errors: [MutationError!]
}

"""
Network configuration detection result
"""
type NetworkConfigDetection {
  "Detected WAN interface name"
  wanInterface: String!
  "Detected default gateway IP"
  gateway: String
  "Detected ISP information"
  ispInfo: ISPInfo
}

# -----------------------------------------------------------------------------
# Query Extensions (Internet Troubleshooting)
# -----------------------------------------------------------------------------

extend type Query {
  """
  Get a troubleshooting session by ID
  """
  troubleshootSession(id: ID!): TroubleshootSession

  """
  Detect WAN interface from default route
  """
  detectWanInterface(routerId: ID!): String!

  """
  Detect default gateway from DHCP client or static route
  """
  detectGateway(routerId: ID!): String

  """
  Detect ISP information from WAN IP
  """
  detectISP(routerId: ID!): ISPInfo
}

# -----------------------------------------------------------------------------
# Mutation Extensions (Internet Troubleshooting)
# -----------------------------------------------------------------------------

extend type Mutation {
  """
  Start a new troubleshooting session for a router.
  Automatically detects network configuration and begins diagnostics.
  """
  startTroubleshoot(routerId: ID!): StartTroubleshootPayload!

  """
  Run a specific diagnostic step in a session
  """
  runTroubleshootStep(
    "Session ID"
    sessionId: ID!
    "Step to run"
    stepType: TroubleshootStepType!
  ): RunTroubleshootStepPayload!

  """
  Apply a suggested fix for a failed diagnostic step
  """
  applyTroubleshootFix(
    "Session ID"
    sessionId: ID!
    "Issue code to fix"
    issueCode: String!
  ): ApplyFixPayload!

  """
  Verify a fix by re-running the diagnostic step
  """
  verifyTroubleshootFix(
    "Session ID"
    sessionId: ID!
    "Step to verify"
    stepType: TroubleshootStepType!
  ): RunTroubleshootStepPayload!

  """
  Cancel a troubleshooting session
  """
  cancelTroubleshoot(sessionId: ID!): TroubleshootSession!
}

# -----------------------------------------------------------------------------
# Subscription Extensions (Internet Troubleshooting)
# -----------------------------------------------------------------------------

extend type Subscription {
  """
  Subscribe to troubleshooting session progress.
  Emits events as steps are executed, fixes are applied, and results are updated.
  """
  troubleshootProgress(sessionId: ID!): TroubleshootSession!
}

# =============================================================================
# Traceroute Diagnostic Tool
# =============================================================================
# This schema provides types and operations for running traceroute diagnostics
# from the router to discover network paths and identify latency issues.
# Story: NAS-5.8 - Implement Traceroute Diagnostic Tool
# =============================================================================

# -----------------------------------------------------------------------------
# Traceroute Types
# -----------------------------------------------------------------------------

"""
Status of a single hop in a traceroute
"""
enum HopStatus {
  "Hop responded successfully"
  SUCCESS
  "Hop did not respond (timeout)"
  TIMEOUT
  "Destination unreachable at this hop"
  UNREACHABLE
  "Access prohibited (firewall/ACL)"
  PROHIBITED
}

"""
Protocol to use for traceroute probes
"""
enum TracerouteProtocol {
  "ICMP echo request (default)"
  ICMP
  "UDP probes"
  UDP
  "TCP SYN probes"
  TCP
}

"""
A single probe result within a hop
"""
type HopProbe {
  "Probe number (1-3 typically)"
  probeNumber: Int!
  "Latency in milliseconds (null for timeout)"
  latencyMs: Float
  "Whether the probe succeeded"
  success: Boolean!
  "ICMP error code if probe failed"
  icmpCode: String
}

"""
A single hop in the traceroute path
"""
type TracerouteHop {
  "Hop number (1-based)"
  hopNumber: Int!
  "IP address of the hop (null for timeout)"
  address: String
  "Reverse DNS hostname (if available)"
  hostname: String
  "Individual probe results for this hop"
  probes: [HopProbe!]!
  "Status of this hop"
  status: HopStatus!
  "Average latency across successful probes"
  avgLatencyMs: Float
  "Packet loss percentage for this hop (0-100)"
  packetLoss: Float!
}

"""
Complete traceroute result
"""
type TracerouteResult {
  "Target hostname or IP address"
  target: String!
  "Resolved target IP address"
  targetIp: String!
  "Protocol used for probes"
  protocol: TracerouteProtocol!
  "Maximum hops configured"
  maxHops: Int!
  "Discovered hops in order"
  hops: [TracerouteHop!]!
  "Whether traceroute completed"
  completed: Boolean!
  "Whether destination was reached"
  reachedDestination: Boolean!
  "Total time from start to completion (ms)"
  totalTimeMs: Float!
  "When the traceroute started"
  startedAt: DateTime!
  "When the traceroute completed (if finished)"
  completedAt: DateTime
}

"""
Input parameters for starting a traceroute
"""
input TracerouteInput {
  "Target hostname or IP address"
  target: String!
  "Maximum number of hops (default: 30, max: 64)"
  maxHops: Int = 30
  "Timeout per hop in milliseconds (default: 3000)"
  timeout: Int = 3000
  "Number of probes per hop (default: 3)"
  probeCount: Int = 3
  "Protocol to use for probes (default: ICMP)"
  protocol: TracerouteProtocol = ICMP
}

"""
Job status for async traceroute execution
"""
enum JobStatus {
  "Job has been created"
  STARTED
  "Job is currently running"
  RUNNING
  "Job completed successfully"
  COMPLETE
  "Job was cancelled by user"
  CANCELLED
  "Job encountered an error"
  ERROR
}

"""
Traceroute job reference for subscription tracking
"""
type TracerouteJob {
  "Unique job identifier"
  jobId: ID!
  "Current job status"
  status: JobStatus!
}

"""
Event type for traceroute progress updates
"""
enum TracerouteEventType {
  "A new hop was discovered"
  HOP_DISCOVERED
  "Traceroute completed"
  COMPLETE
  "Traceroute encountered an error"
  ERROR
  "Traceroute was cancelled"
  CANCELLED
}

"""
Progress event emitted during traceroute execution
"""
type TracerouteProgressEvent {
  "Job identifier"
  jobId: ID!
  "Type of event"
  eventType: TracerouteEventType!
  "Newly discovered hop (for HOP_DISCOVERED events)"
  hop: TracerouteHop
  "Final result (for COMPLETE events)"
  result: TracerouteResult
  "Error message (for ERROR events)"
  error: String
}

# -----------------------------------------------------------------------------
# Mutation Extensions (Traceroute)
# -----------------------------------------------------------------------------

extend type Mutation {
  """
  Start a traceroute from the router to the target.
  Returns a job ID for subscription tracking.
  """
  runTraceroute(
    "Device/router ID to run traceroute from"
    deviceId: ID!
    "Traceroute parameters"
    input: TracerouteInput!
  ): TracerouteJob!

  """
  Cancel a running traceroute job.
  """
  cancelTraceroute(
    "Job ID to cancel"
    jobId: ID!
  ): Boolean!
}

# -----------------------------------------------------------------------------
# Subscription Extensions (Traceroute)
# -----------------------------------------------------------------------------

extend type Subscription {
  """
  Subscribe to traceroute progress updates.
  Emits an event for each hop discovered and when traceroute completes.
  """
  tracerouteProgress(
    "Job ID to monitor"
    jobId: ID!
  ): TracerouteProgressEvent!
}

# =============================================================================
# DNS Cache & Diagnostics
# =============================================================================
# This schema provides types and operations for DNS cache management and
# diagnostics, including cache statistics, flushing, and server benchmarking.
# Story: NAS-6.12 - Implement DNS Cache & Diagnostics
# =============================================================================

# -----------------------------------------------------------------------------
# DNS Cache Types
# -----------------------------------------------------------------------------

"""
DNS cache statistics for monitoring cache usage
"""
type DnsCacheStats {
  "Total number of entries in the DNS cache"
  totalEntries: Int!
  "Cache size used in bytes"
  cacheUsedBytes: Size!
  "Maximum cache size in bytes"
  cacheMaxBytes: Size!
  "Cache usage percentage (0-100)"
  cacheUsagePercent: Float!
  "Cache hit rate percentage (0-100)"
  hitRatePercent: Float
  "Most queried domains (top 10)"
  topDomains: [DnsTopDomain!]!
  "When the statistics were collected"
  timestamp: DateTime!
}

"""
A frequently queried domain in the DNS cache
"""
type DnsTopDomain {
  "Domain name"
  domain: String!
  "Number of queries for this domain"
  queryCount: Int!
  "Last query time"
  lastQueried: DateTime
}

"""
Result of flushing the DNS cache
"""
type FlushDnsCacheResult {
  "Whether the cache was flushed successfully"
  success: Boolean!
  "Number of entries removed from the cache"
  entriesRemoved: Int!
  "Cache statistics before flushing"
  beforeStats: DnsCacheStats!
  "Cache statistics after flushing"
  afterStats: DnsCacheStats!
  "User-friendly message"
  message: String!
  "When the flush was executed"
  timestamp: DateTime!
}

"""
Benchmark result for a single DNS server
"""
type DnsBenchmarkServerResult {
  "DNS server IP address"
  server: String!
  "Response time in milliseconds (-1 if unreachable)"
  responseTimeMs: Int!
  "Server status (Fastest, Good, Slow, Unreachable)"
  status: DnsServerStatus!
  "Whether the server responded successfully"
  success: Boolean!
  "Error message (if server failed)"
  error: String
}

"""
Status classification for DNS servers in benchmark
"""
enum DnsServerStatus {
  "Fastest responding server"
  FASTEST
  "Server responded in acceptable time (<100ms)"
  GOOD
  "Server responded slowly (>100ms)"
  SLOW
  "Server did not respond"
  UNREACHABLE
}

"""
Complete benchmark result comparing all configured DNS servers
"""
type DnsBenchmarkResult {
  "Test hostname used for benchmarking"
  testHostname: String!
  "Results for each tested server, sorted by response time"
  serverResults: [DnsBenchmarkServerResult!]!
  "Fastest server"
  fastestServer: DnsBenchmarkServerResult
  "When the benchmark was executed"
  timestamp: DateTime!
  "Total benchmark execution time in milliseconds"
  totalTimeMs: Int!
}

# -----------------------------------------------------------------------------
# DNS Lookup Tool
# -----------------------------------------------------------------------------
# This schema provides types and operations for DNS lookups, supporting
# multiple record types and server comparisons for troubleshooting.
# Story: NAS-5.9 - Implement DNS Lookup Tool
# =============================================================================

# -----------------------------------------------------------------------------
# DNS Lookup Types
# -----------------------------------------------------------------------------

"""
DNS lookup status codes
"""
enum DnsLookupStatus {
  "Query completed successfully"
  SUCCESS
  "Domain does not exist (NXDOMAIN)"
  NXDOMAIN
  "DNS server failure (SERVFAIL)"
  SERVFAIL
  "Query timed out"
  TIMEOUT
  "Query refused by server"
  REFUSED
  "Network error occurred"
  NETWORK_ERROR
}

"""
DNS record types supported
"""
enum DnsRecordType {
  "IPv4 address record"
  A
  "IPv6 address record"
  AAAA
  "Mail exchange record"
  MX
  "Text record"
  TXT
  "Canonical name record"
  CNAME
  "Name server record"
  NS
  "Pointer record (reverse DNS)"
  PTR
  "Start of authority record"
  SOA
  "Service record"
  SRV
}

"""
Single DNS record
"""
type DnsRecord {
  "Record name (query hostname)"
  name: String!
  "Record type"
  type: DnsRecordType!
  "Time to live in seconds"
  ttl: Int!
  "Record data (IP, hostname, text, etc.)"
  data: String!
  "Priority (for MX/SRV records)"
  priority: Int
  "Weight (for SRV records)"
  weight: Int
  "Port (for SRV records)"
  port: Int
}

"""
Result of a DNS lookup operation
"""
type DnsLookupResult {
  "Hostname that was queried"
  hostname: String!
  "Record type that was queried"
  recordType: DnsRecordType!
  "Query status"
  status: DnsLookupStatus!
  "Resolved records"
  records: [DnsRecord!]!
  "DNS server used"
  server: String!
  "Query time in milliseconds"
  queryTime: Int!
  "Whether response was authoritative"
  authoritative: Boolean!
  "Error message (if query failed)"
  error: String
  "When the query was executed"
  timestamp: DateTime!
}

"""
DNS server configuration
"""
type DnsServer {
  "Server IP address"
  address: String!
  "Whether this is the primary DNS server"
  isPrimary: Boolean!
  "Whether this is the secondary DNS server"
  isSecondary: Boolean!
}

"""
Collection of DNS servers
"""
type DnsServers {
  "All configured DNS servers"
  servers: [DnsServer!]!
  "Primary DNS server address"
  primary: String!
  "Secondary DNS server address (if configured)"
  secondary: String
}

"""
Input for DNS lookup operation
"""
input DnsLookupInput {
  "Device/router ID to run lookup from"
  deviceId: String!
  "Hostname or IP address to look up"
  hostname: String!
  "DNS record type to query"
  recordType: DnsRecordType!
  "DNS server to use (defaults to router's configured DNS)"
  server: String
  "Query timeout in seconds (default: 5)"
  timeout: Int
}

# -----------------------------------------------------------------------------
# Query Extensions (DNS Cache & Diagnostics)
# -----------------------------------------------------------------------------

extend type Query {
  """
  Get configured DNS servers for a device.
  Returns primary and secondary DNS servers configured on the router.
  """
  dnsServers(
    "Device/router ID"
    deviceId: String!
  ): DnsServers!

  """
  Get DNS cache statistics including entries, size, hit rate, and top domains.
  """
  dnsCacheStats(
    "Device/router ID"
    deviceId: String!
  ): DnsCacheStats!

  """
  Run DNS server benchmark against all configured DNS servers.
  Tests each server with a well-known hostname (google.com) and returns
  response times sorted from fastest to slowest.
  """
  dnsBenchmark(
    "Device/router ID"
    deviceId: String!
  ): DnsBenchmarkResult!
}

# -----------------------------------------------------------------------------
# Mutation Extensions (DNS Cache & Diagnostics)
# -----------------------------------------------------------------------------

extend type Mutation {
  """
  Perform DNS lookup (synchronous request-response).
  Queries the specified DNS server for the hostname and record type.
  Uses RouterOS native DNS lookup for A/AAAA records when possible,
  falls back to Go resolver for other record types.
  """
  runDnsLookup(
    "DNS lookup parameters"
    input: DnsLookupInput!
  ): DnsLookupResult!

  """
  Flush the DNS cache on the router.
  Clears all cached DNS entries and returns before/after statistics.
  """
  flushDnsCache(
    "Device/router ID"
    deviceId: String!
  ): FlushDnsCacheResult!
}

# =============================================================================
# Route Lookup Diagnostic Tool
# =============================================================================
# Provides route lookup functionality for troubleshooting routing decisions
# Story: NAS-6.10 - Implement Route Lookup Diagnostic
# =============================================================================

"""
Status of a VPN tunnel
"""
enum TunnelStatus {
  "Tunnel is connected and active"
  CONNECTED
  "Tunnel is disconnected"
  DISCONNECTED
  "Tunnel is attempting to connect"
  CONNECTING
}

"""
VPN tunnel information for routes through VPN
"""
type VPNTunnelInfo {
  "Tunnel name"
  name: String!
  "Tunnel type (wireguard, ipsec, ovpn, l2tp, gre, eoip)"
  type: String!
  "Current tunnel connection status"
  status: TunnelStatus!
  "Remote endpoint address"
  remoteAddress: String
}

"""
A candidate route that matches the destination
"""
type RouteLookupCandidate {
  "The route object"
  route: Route!
  "Prefix length (24 for /24, 8 for /8)"
  prefixLength: Int!
  "Administrative distance"
  distance: Int!
  "Whether this route was selected"
  selected: Boolean!
  "Reason for selection or non-selection"
  selectionReason: String
}

"""
Result of a route lookup operation
"""
type RouteLookupResult {
  "Destination IP that was looked up"
  destination: String!
  "The selected route (null if no route found)"
  matchedRoute: Route
  "Gateway IP for the selected route"
  gateway: String
  "Outgoing interface for the selected route"
  interface: String
  "Administrative distance of selected route"
  distance: Int
  "Route type (STATIC, CONNECTED, DYNAMIC, BGP, OSPF)"
  routeType: RouteType!
  "Whether this is the default route (0.0.0.0/0)"
  isDefaultRoute: Boolean!
  "All candidate routes that match destination"
  candidateRoutes: [RouteLookupCandidate!]!
  "Human-readable explanation of route selection"
  explanation: String!
  "VPN tunnel info if route goes through VPN"
  vpnTunnel: VPNTunnelInfo
}

extend type Query {
  """
  Look up which route will be used for a destination IP.
  Supports optional source address for policy routing testing.
  """
  routeLookup(
    routerId: ID!
    destination: IPv4!
    source: IPv4
  ): RouteLookupResult!
}
