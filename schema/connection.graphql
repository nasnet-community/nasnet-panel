# =============================================================================
# Connection Management GraphQL Schema Extension
# =============================================================================
# This schema provides types and operations for managing persistent router
# connections with automatic reconnection, circuit breaker, and health monitoring.
# Story: NAS-3.5 - Implement Connection Management
# =============================================================================

# -----------------------------------------------------------------------------
# Connection Types
# -----------------------------------------------------------------------------

"""
Protocol used for router communication
"""
enum Protocol {
  "REST API protocol (RouterOS 7.1+)"
  REST
  "Binary API protocol (port 8728)"
  API
  "TLS-encrypted binary API (port 8729)"
  API_SSL
  "SSH protocol (port 22)"
  SSH
  "Telnet protocol (port 23)"
  TELNET
}

"""
Reason for router disconnection
"""
enum DisconnectReason {
  "Unknown reason"
  UNKNOWN
  "User manually disconnected"
  MANUAL
  "Network failure"
  NETWORK_FAILURE
  "Authentication failed"
  AUTH_FAILURE
  "Connection timed out"
  TIMEOUT
  "Circuit breaker is open"
  CIRCUIT_OPEN
  "Application shutting down"
  SHUTDOWN
}

"""
Circuit breaker state
"""
enum CircuitBreakerState {
  "Circuit is closed (normal operation)"
  CLOSED
  "Circuit is open (blocking requests)"
  OPEN
  "Circuit is half-open (testing recovery)"
  HALF_OPEN
}

"""
Detailed connection status for a router
"""
type ConnectionDetails {
  "Current connection state"
  state: ConnectionStatus!

  "Protocol currently in use"
  protocol: Protocol

  "User's preferred protocol (if set)"
  preferredProtocol: Protocol

  "When the connection was established"
  connectedAt: DateTime

  "Connection uptime duration"
  uptime: Duration

  "When the last disconnection occurred"
  disconnectedAt: DateTime

  "Most recent error message"
  lastError: String

  "When the last error occurred"
  lastErrorTime: DateTime

  "Reason for disconnection"
  disconnectReason: DisconnectReason

  "Number of reconnection attempts made"
  reconnectAttempts: Int!

  "When the next reconnection attempt will be made"
  nextReconnectAt: DateTime

  "Current circuit breaker state"
  circuitBreakerState: CircuitBreakerState!

  "Router version (if connected)"
  version: String

  "When the last health check was performed"
  lastHealthCheck: DateTime

  "Consecutive passed health checks"
  healthChecksPassed: Int!

  "Consecutive failed health checks"
  healthChecksFailed: Int!

  "Security warning if using insecure protocol (e.g., Telnet)"
  securityWarning: String

  "Recommendation for upgrading to a more secure protocol"
  upgradeRecommendation: String

  "Whether the current protocol is considered legacy/insecure"
  isLegacyProtocol: Boolean!
}

"""
Health check result for a router
"""
type HealthCheckResult {
  "Router ID"
  routerId: ID!

  "Whether the router is healthy"
  healthy: Boolean!

  "When the check was performed"
  checkedAt: DateTime!

  "Response time in milliseconds"
  responseTimeMs: Int

  "Error message if unhealthy"
  error: String
}

"""
Connection manager statistics
"""
type ConnectionStats {
  "Total number of connections"
  totalConnections: Int!

  "Number of connected routers"
  connected: Int!

  "Number of connecting routers"
  connecting: Int!

  "Number of disconnected routers"
  disconnected: Int!

  "Number of reconnecting routers"
  reconnecting: Int!

  "Number of routers in error state"
  error: Int!
}

# -----------------------------------------------------------------------------
# Query Extensions
# -----------------------------------------------------------------------------

extend type Query {
  "Get detailed connection status for a router"
  connectionDetails(routerId: ID!): ConnectionDetails

  "Get health check result for a router"
  routerHealth(routerId: ID!): HealthCheckResult

  "Get connection manager statistics"
  connectionStats: ConnectionStats!
}

# -----------------------------------------------------------------------------
# Mutation Extensions
# -----------------------------------------------------------------------------

extend type Mutation {
  "Set preferred protocol for a router"
  setPreferredProtocol(
    "Router ID"
    routerId: ID!
    "Preferred protocol"
    protocol: Protocol!
  ): SetPreferredProtocolPayload!

  "Manually trigger reconnection to a router"
  reconnectRouter(
    "Router ID"
    routerId: ID!
  ): ReconnectRouterPayload!

  "Perform immediate health check on a router"
  checkRouterHealth(
    "Router ID"
    routerId: ID!
  ): HealthCheckResult!
}

# -----------------------------------------------------------------------------
# Mutation Payloads
# -----------------------------------------------------------------------------

type SetPreferredProtocolPayload {
  "The updated router"
  router: Router
  "Updated connection details"
  connectionDetails: ConnectionDetails
  "Errors that occurred"
  errors: [MutationError!]
}

type ReconnectRouterPayload {
  "The router being reconnected"
  router: Router
  "Updated connection details"
  connectionDetails: ConnectionDetails
  "Whether reconnection was initiated"
  initiated: Boolean!
  "Rate limit wait time if rate limited"
  waitTimeMs: Int
  "Errors that occurred"
  errors: [MutationError!]
}

# -----------------------------------------------------------------------------
# Subscription Extensions
# -----------------------------------------------------------------------------

extend type Subscription {
  "Subscribe to connection health updates"
  connectionHealth(
    "Router ID to monitor (optional, all routers if not specified)"
    routerId: ID
  ): HealthCheckResult!

  "Subscribe to circuit breaker state changes"
  circuitBreakerChanged(
    "Router ID to monitor"
    routerId: ID!
  ): CircuitBreakerEvent!
}

"""
Event emitted when circuit breaker state changes
"""
type CircuitBreakerEvent {
  "Router ID"
  routerId: ID!
  "Previous state"
  previousState: CircuitBreakerState!
  "New state"
  newState: CircuitBreakerState!
  "Consecutive failures that triggered the change"
  consecutiveFailures: Int!
  "When the state changed"
  timestamp: DateTime!
}
