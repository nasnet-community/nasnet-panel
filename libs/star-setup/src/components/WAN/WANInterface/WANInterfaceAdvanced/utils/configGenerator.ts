import type {
  WANWizardState,
  WANLink,
} from "../types";
import type {
  WANState,

  Ethernet,
  Wireless,
  Sfp,
  LTE} from "@nas-net/star-context";

// Convert advanced state to StarContext WANState format
export function generateWANState(
  advancedState: WANWizardState,
): Partial<WANState> {
  // For backward compatibility, use the first two links as Foreign/Domestic
  const foreignLink = advancedState.links[0];
  const domesticLink = advancedState.links[1];

  // Convert UI state to WANState format
  // Note: This will need proper mapping from UI links to WANLink structure
  const wanState: Partial<WANState> = {
    // WANLink expects a different structure - this needs proper conversion
    // Temporarily commenting out until proper conversion is implemented
    // WANLink: advancedState.links,
  };

  // Create legacy WANLink format
  if (foreignLink) {
    const foreignWANLink: WANLink = {
      WANConfigs: [{
        name: foreignLink.name || "Foreign Link",
        InterfaceConfig: {
          InterfaceName: foreignLink.interfaceName as Ethernet | Wireless | Sfp | LTE,
          WirelessCredentials: foreignLink.wirelessCredentials,
        },
        ConnectionConfig: foreignLink.ConnectionConfig,
        priority: foreignLink.priority,
        weight: foreignLink.weight,
      }]
    };

    wanState.WANLink = {
      Foreign: foreignWANLink,
    };

    if (domesticLink) {
      const domesticWANLink: WANLink = {
        WANConfigs: [{
          name: domesticLink.name || "Domestic Link",
          InterfaceConfig: {
            InterfaceName: domesticLink.interfaceName as Ethernet | Wireless | Sfp | LTE,
            WirelessCredentials: domesticLink.wirelessCredentials,
          },
          ConnectionConfig: domesticLink.ConnectionConfig,
          priority: domesticLink.priority,
          weight: domesticLink.weight,
        }]
      };
      wanState.WANLink!.Domestic = domesticWANLink;
    }
  }

  return wanState;
}

// Generate MikroTik RouterOS commands from advanced state
export function generateRouterOSCommands(
  advancedState: WANWizardState,
): string[] {
  const commands: string[] = [];

  // Header
  commands.push("# WAN Configuration Generated by WAN Advanced");
  commands.push(`# Mode: ${advancedState.mode}`);
  commands.push(`# Links: ${advancedState.links.length}`);
  commands.push("");

  // Configure each WAN link
  advancedState.links.forEach((link, index) => {
    commands.push(`# WAN Link ${index + 1}: ${link.name}`);

    // Interface configuration
    if (link.vlanConfig?.enabled) {
      commands.push(
        `/interface vlan add interface=${link.interfaceName} vlan-id=${link.vlanConfig.id} name=vlan-wan${index + 1}`,
      );
    }

    // Wireless configuration
    if (link.interfaceType === "Wireless" && link.wirelessCredentials) {
      commands.push(
        `/interface wireless security-profiles add name=wan${index + 1}-profile authentication-types=wpa2-psk mode=dynamic-keys wpa2-pre-shared-key="${link.wirelessCredentials.Password}"`,
      );
      commands.push(
        `/interface wireless set ${link.interfaceName} mode=station ssid="${link.wirelessCredentials.SSID}" security-profile=wan${index + 1}-profile`,
      );
    }

    // LTE configuration
    if (link.interfaceType === "LTE" && link.lteSettings) {
      commands.push(
        `/interface lte apn add name=wan${index + 1}-apn apn="${link.lteSettings.apn}"`,
      );
      commands.push(
        `/interface lte set ${link.interfaceName} apn-profile=wan${index + 1}-apn`,
      );
    }

    // Connection configuration
    const interfaceName = link.vlanConfig?.enabled
      ? `vlan-wan${index + 1}`
      : link.interfaceName;

    switch (link.connectionType) {
      case "DHCP":
        commands.push(
          `/ip dhcp-client add interface=${interfaceName} add-default-route=yes use-peer-dns=yes disabled=no`,
        );
        break;

      case "PPPoE":
        if (link.connectionConfig?.pppoe) {
          commands.push(
            `/interface pppoe-client add interface=${interfaceName} user="${link.connectionConfig.pppoe.username}" password="${link.connectionConfig.pppoe.password}" add-default-route=yes use-peer-dns=yes disabled=no name=pppoe-wan${index + 1}`,
          );
        }
        break;

      case "Static":
        if (link.connectionConfig?.static) {
          const { ipAddress, subnet, gateway, DNS } =
            link.connectionConfig.static;
          commands.push(
            `/ip address add address=${ipAddress}/${calculateCIDR(subnet)} interface=${interfaceName}`,
          );
          commands.push(
            `/ip route add gateway=${gateway} distance=${index + 1}`,
          );
          commands.push(
            `/ip dns set servers=${DNS}`,
          );
        }
        break;
    }

    // MAC address spoofing
    if (link.macAddress?.enabled && link.macAddress.address) {
      commands.push(
        `/interface ethernet set ${link.interfaceName} mac-address=${link.macAddress.address}`,
      );
    }

    commands.push("");
  });

  // Multi-link configuration
  if (advancedState.links.length > 1 && advancedState.multiLinkStrategy) {
    commands.push("# Multi-WAN Configuration");

    switch (advancedState.multiLinkStrategy.strategy) {
      case "LoadBalance":
        generateLoadBalanceCommands(advancedState, commands);
        break;

      case "Failover":
        generateFailoverCommands(advancedState, commands);
        break;

      case "Both":
        generateLoadBalanceCommands(advancedState, commands);
        generateFailoverCommands(advancedState, commands);
        break;
    }
  }

  return commands;
}

// Generate load balance commands
function generateLoadBalanceCommands(
  advancedState: WANWizardState,
  commands: string[],
): void {
  const method = advancedState.multiLinkStrategy?.loadBalanceMethod || "PCC";

  commands.push(`# Load Balance Configuration (${method})`);

  switch (method) {
    case "PCC":
      // PCC (Per Connection Classifier) implementation
      commands.push("/ip firewall mangle");
      advancedState.links.forEach((link, index) => {
        const classifier = `src-address-and-port:${advancedState.links.length}/${index}`;
        commands.push(
          `add chain=prerouting in-interface-list=LAN connection-mark=no-mark per-connection-classifier=${classifier} action=mark-connection new-connection-mark=wan${index + 1}_conn`,
        );
        commands.push(
          `add chain=prerouting in-interface-list=LAN connection-mark=wan${index + 1}_conn action=mark-routing new-routing-mark=to_wan${index + 1}`,
        );
      });
      break;

    case "NTH":
      // NTH (Nth packet) implementation
      commands.push("/ip firewall mangle");
      advancedState.links.forEach((link, index) => {
        commands.push(
          `add chain=prerouting in-interface-list=LAN nth=${advancedState.links.length},${index} action=mark-routing new-routing-mark=to_wan${index + 1}`,
        );
      });
      break;

    case "ECMP": {
      // ECMP (Equal Cost Multi-Path) implementation
      commands.push("/ip route");
      const gateways = advancedState.links
        .map((link, index) => {
          if (
            link.connectionType === "Static" &&
            link.connectionConfig?.static?.gateway
          ) {
            return link.connectionConfig.static.gateway;
          }
          return `pppoe-wan${index + 1}`;
        })
        .join(",");
      commands.push(
        `add dst-address=0.0.0.0/0 gateway=${gateways} check-gateway=ping`,
      );
      break;
    }
  }

  commands.push("");
}

// Generate failover commands
function generateFailoverCommands(
  advancedState: WANWizardState,
  commands: string[],
): void {
  commands.push("# Failover Configuration");
  commands.push("/ip route");

  const sortedLinks = [...advancedState.links].sort(
    (a, b) => (a.priority || 0) - (b.priority || 0),
  );

  sortedLinks.forEach((link, index) => {
    const distance = (link.priority || index + 1) * 10;

    if (
      link.connectionType === "Static" &&
      link.connectionConfig?.static?.gateway
    ) {
      commands.push(
        `add dst-address=0.0.0.0/0 gateway=${link.connectionConfig.static.gateway} distance=${distance} check-gateway=ping`,
      );
    } else if (link.connectionType === "PPPoE") {
      commands.push(
        `add dst-address=0.0.0.0/0 gateway=pppoe-wan${advancedState.links.indexOf(link) + 1} distance=${distance}`,
      );
    } else {
      commands.push(
        `add dst-address=0.0.0.0/0 gateway=${link.interfaceName} distance=${distance}`,
      );
    }
  });

  commands.push("");
}

// Calculate CIDR notation from subnet mask
function calculateCIDR(subnet: string): number {
  const parts = subnet.split(".").map(Number);
  const binary = parts.map((n) => n.toString(2).padStart(8, "0")).join("");
  return binary.split("1").length - 1;
}

// Generate summary text for the configuration
export function generateConfigSummary(advancedState: WANWizardState): string {
  const lines: string[] = [];

  lines.push(
    `Configuration Mode: ${advancedState.mode === "easy" ? "Easy" : "Advanced"}`,
  );
  lines.push(`Number of WAN Links: ${advancedState.links.length}`);
  lines.push("");

  advancedState.links.forEach((link, index) => {
    lines.push(`WAN Link ${index + 1}: ${link.name}`);
    lines.push(`  Interface: ${link.interfaceType} (${link.interfaceName})`);
    lines.push(`  Connection: ${link.connectionType}`);

    if (link.weight) {
      lines.push(`  Weight: ${link.weight}%`);
    }
    if (link.priority) {
      lines.push(`  Priority: ${link.priority}`);
    }
    lines.push("");
  });

  if (advancedState.multiLinkStrategy) {
    lines.push(
      `Multi-WAN Strategy: ${advancedState.multiLinkStrategy.strategy}`,
    );
    if (advancedState.multiLinkStrategy.loadBalanceMethod) {
      lines.push(
        `  Load Balance Method: ${advancedState.multiLinkStrategy.loadBalanceMethod}`,
      );
    }
  }

  return lines.join("\n");
}
