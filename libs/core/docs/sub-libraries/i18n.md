# Internationalization (i18n) Library Reference

> Comprehensive guide to `@nasnet/core/i18n` — the i18next-powered internationalization system for NasNetConnect

## Table of Contents

1. [Overview](#overview)
2. [i18next Configuration](#i18next-configuration)
3. [Supported Languages](#supported-languages)
4. [RTL Support](#rtl-support)
5. [Namespace System](#namespace-system)
6. [Translation Key Catalog](#translation-key-catalog)
7. [I18nProvider Component](#i18nprovider-component)
8. [Typed Hooks](#typed-hooks)
9. [useFormatters Hook](#useformatters-hook)
10. [How to Add New Translations](#how-to-add-new-translations)
11. [How to Add a New Language](#how-to-add-a-new-language)

---

## Overview

The `@nasnet/core/i18n` library provides a comprehensive internationalization system built on **i18next** with React integration. It features:

- **Lazy-loaded language packs** — Only the default English is bundled; other languages load on demand
- **RTL language support** — Automatic HTML dir and lang attribute management for Persian and other RTL languages
- **Namespace organization** — Default namespaces loaded at startup; feature namespaces load on-demand for bundle efficiency
- **Locale-aware formatting** — Dates, numbers, bytes, durations, bandwidth with Intl API
- **Typed hooks** — Full TypeScript support with type-safe translation keys

## i18next Configuration

### Setup Details

The i18next instance is configured in `libs/core/i18n/src/i18n.ts`:

```typescript
i18n
  .use(HttpBackend)           // Load language files via HTTP
  .use(LanguageDetector)      // Auto-detect user language
  .use(initReactI18next)      // React integration
  .init({
    fallbackLng: 'en',                                  // Fallback language
    supportedLngs: ['en', 'fa'],                        // Supported languages
    ns: ['common', 'validation', 'errors'],             // Default namespaces
    defaultNS: 'common',                                // Default namespace
    detection: {
      order: ['localStorage', 'navigator'],             // Detection order
      caches: ['localStorage'],                         // Cache language choice
      lookupLocalStorage: 'nasnet-language',            // Storage key
    },
    backend: {
      loadPath: '/locales/{{lng}}/{{ns}}.json',        // Translation file path
    },
    interpolation: {
      escapeValue: false,                              // React auto-escapes
    },
    react: {
      useSuspense: true,                               // Use Suspense for lazy loading
    },
  });
```

### Key Design Decisions

1. **English bundled, others lazy-loaded** — English is always available as fallback; other language packs fetch on demand
2. **HttpBackend for dynamic loading** — Translations load from `/locales/{{lng}}/{{ns}}.json` at runtime
3. **Browser language detection** — Detects user's language from localStorage first, then browser settings
4. **Suspense support** — Integrates with React Suspense for loading states

## Supported Languages

### Language Configuration

Defined in `i18n.ts`:

```typescript
export const supportedLanguages = ['en', 'fa'] as const;
export type SupportedLanguage = (typeof supportedLanguages)[number];

export const languageNames: Record<SupportedLanguage, string> = {
  en: 'English',
  fa: 'فارسی',  // Persian (native script)
};
```

**Supported Languages:**
- **English** (`en`) — Default language, always bundled
- **Persian** (`fa`) — RTL language, lazy-loaded

### Language Files

Translation files are organized in `libs/core/i18n/src/locales/`:

```
locales/
├── en/
│   ├── common.json         # Common UI terms
│   ├── validation.json     # Form validation messages
│   ├── errors.json         # Error messages
│   ├── dashboard.json      # Dashboard feature
│   ├── network.json        # Network feature
│   ├── vpn.json           # VPN feature
│   ├── wifi.json          # WiFi feature
│   ├── firewall.json      # Firewall feature
│   ├── router.json        # Router feature
│   ├── services.json      # Services feature
│   └── diagnostics.json   # Diagnostics feature
└── fa/
    ├── common.json
    ├── validation.json
    ├── errors.json
    ├── dashboard.json
    ├── network.json
    ├── vpn.json
    ├── wifi.json
    ├── firewall.json
    ├── router.json
    ├── services.json
    └── diagnostics.json
```

## RTL Support

### RTL Language Detection

Two utility functions help manage RTL languages:

```typescript
/**
 * Check if a language is RTL
 * @param lang - Language code (e.g., 'en', 'fa')
 * @returns true if the language is right-to-left
 */
export function isRTLLanguage(lang: string): boolean {
  return rtlLanguages.includes(lang as SupportedLanguage);
}

/**
 * Get the text direction for a language
 * @param lang - Language code
 * @returns 'ltr' (left-to-right) or 'rtl' (right-to-left)
 */
export function getLanguageDirection(lang: string): 'ltr' | 'rtl' {
  return isRTLLanguage(lang) ? 'rtl' : 'ltr';
}
```

RTL languages are defined as:

```typescript
export const rtlLanguages: readonly SupportedLanguage[] = ['fa'];
```

### DirectionProvider Component

Automatically manages document direction:

```typescript
<I18nProvider>
  <DirectionProvider>
    <App />
  </DirectionProvider>
</I18nProvider>
```

**What it does:**
- Sets `document.documentElement.dir` to 'rtl' or 'ltr'
- Sets `document.documentElement.lang` to current language code
- Sets `data-direction` attribute on HTML element for CSS selectors
- Updates automatically when language changes

**Example CSS:**

```css
html[data-direction='rtl'] .sidebar {
  float: right;
  border-left: 1px solid #ccc;
  border-right: none;
}

html[data-direction='ltr'] .sidebar {
  float: left;
  border-right: 1px solid #ccc;
  border-left: none;
}
```

## Namespace System

### Default Namespaces

Loaded on app initialization (bundled with the app):

```typescript
export const defaultNamespaces = ['common', 'validation', 'errors'] as const;

export type DefaultNamespace = (typeof defaultNamespaces)[number];
```

**Namespaces:**
- **common** — Shared UI terms, buttons, labels, navigation
- **validation** — Form field validation messages
- **errors** — Application error messages

### Feature Namespaces

Lazy-loaded when components use them:

```typescript
export const featureNamespaces = [
  'wizard',       // Setup wizard navigation
  'network',      // Network interfaces, ARP, DHCP, DNS, routes, traffic, VLANs
  'dashboard',    // Dashboard widgets, bandwidth, resource gauges, logs
  'vpn',         // VPN servers, clients, protocols, status
  'wifi',        // Wireless interfaces, clients, security
  'firewall',    // Filter rules, NAT, mangle, raw, address lists
  'services',    // Feature marketplace, service management, templates
  'diagnostics', // Ping, traceroute, DNS lookup, device scan, troubleshoot
  'router',      // Router discovery, panel, overview, health
] as const;

export type FeatureNamespace = (typeof featureNamespaces)[number];
```

### Namespace Loading

**Default namespaces** are loaded immediately:
```typescript
const { t } = useTranslation();  // Loads 'common' by default
const { t: tValidation } = useTranslation('validation');
```

**Feature namespaces** load on-demand with Suspense:
```typescript
function VPNPage() {
  const { t } = useTranslation('vpn');  // Lazy-loads vpn.json
  return <h1>{t('vpn.title')}</h1>;
}
```

## Translation Key Catalog

### Common Namespace (`common.json`)

Core application terminology:

```
app.name              → "NasNetConnect"
app.version           → Application version
header.navigation.*   → Navigation links
buttons.save          → "Save"
buttons.cancel        → "Cancel"
buttons.delete        → "Delete"
buttons.edit          → "Edit"
labels.*              → Form labels
status.*              → Status indicators
messages.*            → Informational messages
```

### Validation Namespace (`validation.json`)

Form validation messages:

```
validation.required                    → "This field is required"
validation.string.min                  → "Must be at least {{min}} characters"
validation.string.max                  → "Must be at most {{max}} characters"
validation.string.email                → "Please enter a valid email"
validation.number.min                  → "Must be at least {{min}}"
validation.number.max                  → "Must be at most {{max}}"
validation.ipv4                        → "Invalid IPv4 address"
validation.ipv6                        → "Invalid IPv6 address"
validation.mac                         → "Invalid MAC address"
validation.port                        → "Port must be between 1 and 65535"
validation.vlanId                      → "VLAN ID must be between 1 and 4094"
```

### Errors Namespace (`errors.json`)

Application error messages:

```
errors.network.connection              → "Failed to connect"
errors.network.timeout                 → "Request timed out"
errors.server.internal                 → "Internal server error"
errors.authentication.failed           → "Authentication failed"
errors.authorization.denied            → "Access denied"
```

### Feature Namespaces

Each feature has its own namespace for domain-specific terms:

```
// network.json
network.interfaces.title
network.interfaces.name
network.ip.address
network.routes.destination

// vpn.json
vpn.protocols.wireguard
vpn.protocols.openvpn
vpn.peers.endpoint
vpn.status.connected

// firewall.json
firewall.rules.filter
firewall.rules.nat
firewall.chains.input
firewall.chains.forward
firewall.chains.output
```

## I18nProvider Component

### Setup

Wrap your application with the I18nProvider:

```typescript
// main.tsx
import { I18nProvider, DirectionProvider } from '@nasnet/core/i18n';
import App from './App';

const loadingFallback = <div>Loading...</div>;

export default function Root() {
  return (
    <I18nProvider loadingFallback={loadingFallback}>
      <DirectionProvider>
        <App />
      </DirectionProvider>
    </I18nProvider>
  );
}
```

### Component Props

```typescript
interface I18nProviderProps {
  /** React components to wrap with i18n support */
  children: ReactNode;

  /**
   * Fallback UI shown while loading language pack
   * @default null (renders nothing while loading)
   */
  loadingFallback?: ReactNode;
}
```

### Suspense Behavior

The I18nProvider uses React Suspense to handle lazy-loaded language packs:

1. When a component requests a language/namespace that hasn't loaded yet, Suspense triggers
2. The `loadingFallback` is displayed during loading
3. Once the translation file loads, the component renders with translations
4. Subsequent accesses to the same namespace are instant (cached in memory)

## Typed Hooks

### useTranslation Hook

Access translations with full TypeScript support:

```typescript
/**
 * Hook for accessing translations
 * @param ns - Translation namespace(s) to load
 * @returns Object with `t` function and i18n instance
 */
function useTranslation(ns?: TranslationNamespace | TranslationNamespace[]): {
  t: TFunction;
  i18n: i18nInstance;
  ready: boolean;
}
```

**Usage:**

```typescript
import { useTranslation } from '@nasnet/core/i18n';

function Dashboard() {
  // Load 'common' by default
  const { t } = useTranslation();

  return <h1>{t('header.navigation.dashboard')}</h1>;
}

function VPNPage() {
  // Load 'vpn' namespace
  const { t } = useTranslation('vpn');

  return <h1>{t('vpn.title')}</h1>;
}

function AdvancedSetup() {
  // Load multiple namespaces
  const { t } = useTranslation(['common', 'validation', 'network']);

  return (
    <>
      <h1>{t('common:app.name')}</h1>
      <p>{t('validation:validation.required')}</p>
    </>
  );
}
```

### Trans Component

For complex translations with nested components:

```typescript
import { Trans } from '@nasnet/core/i18n';

function WelcomeMessage({ name }: { name: string }) {
  return (
    <Trans i18nKey="welcome.message">
      Welcome <strong>{{ name }}</strong> to NasNetConnect
    </Trans>
  );
}
```

### useDirection Hook

Get current text direction:

```typescript
import { useDirection } from '@nasnet/core/i18n';

function Sidebar() {
  const { direction, isRTL } = useDirection();

  return (
    <aside style={{ direction }}>
      {isRTL ? 'راهنما' : 'Guide'}
    </aside>
  );
}
```

**Returns:**

```typescript
interface DirectionContextValue {
  /** Current text direction ('ltr' | 'rtl') */
  direction: Direction;
  /** Convenience boolean flag for RTL detection */
  isRTL: boolean;
}
```

## useFormatters Hook

Provides locale-aware formatting functions:

```typescript
import { useFormatters } from '@nasnet/core/i18n';

function ResourceStatus({ createdAt, bytesUsed, bandwidth }: Props) {
  const { formatDate, formatBytes, formatBandwidth } = useFormatters();

  return (
    <div>
      <p>Created: {formatDate(createdAt, { includeTime: true })}</p>
      <p>Storage: {formatBytes(bytesUsed)}</p>
      <p>Bandwidth: {formatBandwidth(bandwidth)}</p>
    </div>
  );
}
```

### Formatter Functions

#### formatDate

Formats dates according to locale settings:

```typescript
function formatDate(
  date: Date | string | number,
  options?: DateFormatOptions
): string
```

**Options:**

```typescript
interface DateFormatOptions {
  /** Style: 'short' (M/D/YY), 'medium', 'long', 'full' */
  style?: 'short' | 'medium' | 'long' | 'full';
  /** Include time component */
  includeTime?: boolean;
}
```

**Examples:**

```typescript
const { formatDate } = useFormatters();

formatDate(new Date(2024, 0, 15))
// US: "1/15/24"
// DE: "15.1.24"

formatDate(new Date(2024, 0, 15), { style: 'long', includeTime: true })
// US: "January 15, 2024, 2:30 PM"
// DE: "15. Januar 2024, 14:30"
```

#### formatNumber

Formats numbers with locale-aware separators:

```typescript
function formatNumber(
  value: number,
  options?: NumberFormatOptions
): string
```

**Options:**

```typescript
interface NumberFormatOptions {
  style?: 'decimal' | 'percent';
  minimumFractionDigits?: number;
  maximumFractionDigits?: number;
}
```

**Examples:**

```typescript
const { formatNumber } = useFormatters();

formatNumber(1234.5)
// US: "1,234.5"
// DE: "1.234,5"

formatNumber(0.85, { style: 'percent', maximumFractionDigits: 0 })
// US: "85%"
// DE: "85 %"
```

#### formatBytes

Formats bytes to human-readable data size:

```typescript
function formatBytes(bytes: number, decimals?: number): string
```

**Examples:**

```typescript
const { formatBytes } = useFormatters();

formatBytes(0)           // "0 B"
formatBytes(1024)        // "1.00 KB"
formatBytes(1048576)     // "1.00 MB"
formatBytes(2621440)     // "2.50 MB"
formatBytes(1073741824)  // "1.00 GB"
```

**Notes:**
- Uses 1024 base (1 KB = 1024 B)
- Default 2 decimal places
- Returns '-' for invalid input

#### formatDuration

Formats duration in seconds to compact time format:

```typescript
function formatDuration(seconds: number): string
```

**Examples:**

```typescript
const { formatDuration } = useFormatters();

formatDuration(45)       // "45s"
formatDuration(125)      // "2m 5s"
formatDuration(3665)     // "1h 1m 5s"
formatDuration(90015)    // "25h 0m 15s"
```

#### formatRelativeTime

Formats dates as relative time (e.g., "5 minutes ago"):

```typescript
function formatRelativeTime(
  date: Date | string | number,
  options?: RelativeTimeOptions
): string
```

**Options:**

```typescript
interface RelativeTimeOptions {
  /** Style: 'long' (5 minutes ago), 'short' (5 min. ago), 'narrow' (5m) */
  style?: 'long' | 'short' | 'narrow';
  /** Numeric: 'always' or 'auto' (auto uses "yesterday" instead of "1 day ago") */
  numeric?: 'always' | 'auto';
}
```

**Examples:**

```typescript
const { formatRelativeTime } = useFormatters();

const fiveMinutesAgo = new Date(Date.now() - 5 * 60000);
formatRelativeTime(fiveMinutesAgo)
// "5 minutes ago" or "5 دقیقه پیش" (Persian)

formatRelativeTime(fiveMinutesAgo, { style: 'short' })
// "5 min. ago"

formatRelativeTime(new Date(Date.now() - 24 * 3600000), { numeric: 'auto' })
// "yesterday" (instead of "1 day ago")
```

#### formatBandwidth

Formats network bandwidth in bits per second:

```typescript
function formatBandwidth(bitsPerSecond: number): string
```

**Examples:**

```typescript
const { formatBandwidth } = useFormatters();

formatBandwidth(0)           // "0 bps"
formatBandwidth(1000)        // "1 kbps"
formatBandwidth(1000000)     // "1 Mbps"
formatBandwidth(5250000)     // "5.25 Mbps"
formatBandwidth(1000000000)  // "1 Gbps"
```

**Notes:**
- Uses 1000 base (1 Kbps = 1000 bps) — per networking convention
- Units: bps, Kbps, Mbps, Gbps, Tbps

## How to Add New Translations

### Step 1: Add Keys to JSON Files

Add your new translation keys to the appropriate namespace file:

**English (`libs/core/i18n/src/locales/en/firewall.json`):**

```json
{
  "firewall": {
    "rules": {
      "add_rule": "Add Rule",
      "delete_rule": "Delete Rule",
      "rule_added_success": "Rule added successfully"
    }
  }
}
```

**Persian (`libs/core/i18n/src/locales/fa/firewall.json`):**

```json
{
  "firewall": {
    "rules": {
      "add_rule": "افزودن قانون",
      "delete_rule": "حذف قانون",
      "rule_added_success": "قانون با موفقیت افزوده شد"
    }
  }
}
```

### Step 2: Use in Components

```typescript
import { useTranslation } from '@nasnet/core/i18n';

function FirewallRules() {
  const { t } = useTranslation('firewall');

  return (
    <>
      <h1>{t('firewall.rules.add_rule')}</h1>
      <button>{t('firewall.rules.delete_rule')}</button>
      <Alert>{t('firewall.rules.rule_added_success')}</Alert>
    </>
  );
}
```

### Step 3: Interpolation (Variables in Translations)

For dynamic content:

**JSON:**

```json
{
  "messages": {
    "device_connected": "Device {{name}} connected successfully",
    "errors_count": "Found {{count}} error(s)"
  }
}
```

**Component:**

```typescript
function DeviceAlert({ name, errorCount }) {
  const { t } = useTranslation('common');

  return (
    <div>
      <p>{t('messages.device_connected', { name })}</p>
      <p>{t('messages.errors_count', { count: errorCount })}</p>
    </div>
  );
}
```

### Step 4: Pluralization

i18next supports pluralization with special keys:

**JSON:**

```json
{
  "items": {
    "count": "Found {{count}} item",
    "count_plural": "Found {{count}} items"
  }
}
```

**Component:**

```typescript
const { t } = useTranslation();
t('items.count', { count: 5 })  // "Found 5 items"
t('items.count', { count: 1 })  // "Found 1 item"
```

## How to Add a New Language

### Step 1: Register the Language

Edit `libs/core/i18n/src/i18n.ts`:

```typescript
// Add to supported languages
export const supportedLanguages = ['en', 'fa', 'ar'] as const;

// Add to language names (in native script)
export const languageNames: Record<SupportedLanguage, string> = {
  en: 'English',
  fa: 'فارسی',
  ar: 'العربية',  // Arabic
};

// Add to RTL languages if applicable
export const rtlLanguages: readonly SupportedLanguage[] = ['fa', 'ar'];

// Add to i18next config
.init({
  supportedLngs: supportedLanguages,  // Updated automatically
  // ... rest of config
});
```

### Step 2: Create Translation Files

Create translation files for all namespaces:

```
libs/core/i18n/src/locales/ar/
├── common.json
├── validation.json
├── errors.json
├── dashboard.json
├── network.json
├── vpn.json
├── wifi.json
├── firewall.json
├── router.json
├── services.json
└── diagnostics.json
```

Start with the English files as a template and translate to the new language.

### Step 3: Add Language Switcher

Create a language selector component:

```typescript
import { useTranslation } from '@nasnet/core/i18n';

function LanguageSwitcher() {
  const { i18n } = useTranslation();

  return (
    <select
      value={i18n.language}
      onChange={(e) => i18n.changeLanguage(e.target.value)}
    >
      <option value="en">English</option>
      <option value="fa">فارسی</option>
      <option value="ar">العربية</option>
    </select>
  );
}
```

### Step 4: Verify RTL Support (if applicable)

If the new language is RTL:

1. Add to `rtlLanguages` array in `i18n.ts`
2. Test that `DirectionProvider` correctly sets `dir="rtl"`
3. Ensure CSS handles RTL layout adjustments

### Step 5: Handle Backend Translation Loading

Ensure your backend serves the new language files at:

```
/locales/{{lng}}/{{ns}}.json
```

For production:
- `/locales/ar/common.json`
- `/locales/ar/validation.json`
- etc.

---

## Best Practices

### 1. **Use Namespaces Effectively**

- Keep related translations in the same namespace
- Use feature namespaces for domain-specific terms
- Don't over-fragment — balance between organization and file count

### 2. **Translation Key Naming**

Use dot notation for hierarchy:

```typescript
// Good
t('firewall.rules.filter.add_rule')
t('network.interfaces.status.connected')

// Avoid
t('add_rule_firewall_filter')  // Unclear hierarchy
t('firewall_add_rule')          // Wrong direction
```

### 3. **Avoid Hardcoding Text**

```typescript
// Bad
return <h1>Dashboard</h1>;

// Good
const { t } = useTranslation();
return <h1>{t('header.navigation.dashboard')}</h1>;
```

### 4. **Format Data, Not Strings**

Use formatters for dates, numbers, etc.:

```typescript
// Bad
return <p>Size: {bytes.toFixed(2)} MB</p>;

// Good
const { formatBytes } = useFormatters();
return <p>Size: {formatBytes(bytes)}</p>;
```

### 5. **Test with RTL Languages**

Always test layout and component styling with RTL languages enabled to catch mirroring issues.

---

## Integration with Forms

See `libs/core/docs/sub-libraries/forms.md` for integration with form validation messages and i18n error mapping.

---

## References

- **Documentation:** `Docs/architecture/implementation-patterns/17-localization-patterns.md`
- **i18next Docs:** https://www.i18next.com/
- **Browser Intl API:** https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl
