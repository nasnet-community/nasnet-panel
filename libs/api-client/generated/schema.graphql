schema {
  query: Query
  mutation: Mutation
  subscription: Subscription
}

"""
Requires authentication to access this field.
Optionally requires a specific role or permission.
"""
directive @auth(
  """
  Required role or permission level (e.g., 'admin', 'operator', 'viewer')
  """
  requires: String
) on FIELD_DEFINITION | OBJECT

directive @cache(
  """Maximum age in seconds"""
  maxAge: Int!
  """Cache scope (PRIVATE for user-specific, PUBLIC for shared)"""
  scope: CacheScope
) on FIELD_DEFINITION

directive @capability(
  """List of required capability identifiers"""
  requires: [String!]!
) on FIELD_DEFINITION | OBJECT

directive @migrateFrom(
  """The old field/type name this replaces"""
  field: String!
  """Version when migration should be complete"""
  removeInVersion: String
) on FIELD_DEFINITION | INPUT_FIELD_DEFINITION | OBJECT

"""Maps field to MikroTik RouterOS API path and command"""
directive @mikrotik(
  """RouterOS command (print, add, set, remove) - defaults to contextual"""
  cmd: String
  """Field name in RouterOS response if different from GraphQL field"""
  field: String
  """RouterOS API path (e.g., '/ip/address', '/interface/ethernet')"""
  path: String!
) on FIELD_DEFINITION | OBJECT

"""Maps field to OpenWrt ubus call"""
directive @openwrt(
  """Field name in ubus response if different from GraphQL field"""
  field: String
  """Method to call (list, call, etc.)"""
  method: String
  """Ubus namespace and method (e.g., 'network.interface', 'system.board')"""
  ubus: String!
) on FIELD_DEFINITION | OBJECT

directive @realtime(
  """Update interval in milliseconds"""
  interval: Int
  """Topic/channel name for pub/sub"""
  topic: String
) on FIELD_DEFINITION

"""
Marks field as containing sensitive data (passwords, tokens, keys).
Values are redacted in logs and error responses.
"""
directive @sensitive on ARGUMENT_DEFINITION | FIELD_DEFINITION | INPUT_FIELD_DEFINITION

directive @validate(
  """Predefined format validation (EMAIL, URL, UUID, IPV4, IPV6, MAC, CIDR)"""
  format: ValidateFormat
  """Maximum value for numeric types"""
  max: Int
  """Maximum length for string types"""
  maxLength: Int
  """Minimum value for numeric types"""
  min: Int
  """Minimum length for string types"""
  minLength: Int
  """Regular expression pattern for string validation"""
  pattern: String
) on ARGUMENT_DEFINITION | FIELD_DEFINITION | INPUT_FIELD_DEFINITION

"""Maps field to VyOS configuration path"""
directive @vyos(
  """Field name in VyOS response if different from GraphQL field"""
  field: String
  """VyOS configuration path (e.g., 'interfaces ethernet eth0')"""
  path: String!
) on FIELD_DEFINITION | OBJECT

input AddBridgePortInput {
  frameTypes: FrameTypes
  ingressFiltering: Boolean
  interfaceId: ID!
  pvid: Int @validate(min: 1, max: 4094)
}

type AddChangeSetItemPayload {
  """The updated change set"""
  changeSet: ChangeSet
  """Errors that occurred"""
  errors: [MutationError!]
  """The added item ID"""
  itemId: ID
}

"""
AddDependencyInput contains parameters for creating a dependency relationship.
"""
input AddDependencyInput {
  autoStart: Boolean!
  dependencyType: DependencyType!
  fromInstanceId: ID!
  healthTimeoutSeconds: Int!
  toInstanceId: ID!
}

"""
Input for manually adding a new router with full credentials and protocol preference.
This is the primary input type for the addRouter mutation.
"""
input AddRouterInput {
  """
  Router hostname or IP address.
  Can be an IPv4 address (e.g., '192.168.88.1'), IPv6 address, or hostname (e.g., 'router.local').
  Hostnames will trigger DNS resolution with caching.
  """
  host: String! @validate(minLength: 1, maxLength: 253)
  """
  User-friendly display name for the router.
  If not provided, a name will be generated from the host.
  """
  name: String @validate(maxLength: 128)
  """
  Password for authentication.
  This value is encrypted before storage and never logged.
  """
  password: String! @sensitive
  """
  Connection port. If not specified, defaults to protocol-specific port:
  - REST: 443 (or 80 for HTTP)
  - API: 8728
  - API_SSL: 8729
  - SSH: 22
  - Telnet: 23
  """
  port: Int @validate(min: 1, max: 65535)
  """
  Protocol preference for connection.
  Defaults to AUTO which tries protocols in recommended order.
  """
  protocolPreference: ProtocolPreference
  """
  Username for authentication.
  For MikroTik routers, this is typically 'admin' or a custom user.
  """
  username: String! @validate(minLength: 1, maxLength: 64)
}

"""
Payload returned from the addRouter mutation.
Contains either the created router or validation/connection errors.
"""
type AddRouterPayload {
  """Connection test result from initial connection attempt"""
  connectionResult: ConnectionTestResult
  """General errors that occurred during creation"""
  errors: [MutationError!]
  """The newly created router (null if errors occurred)"""
  router: Router
  """Field-level validation errors for retry"""
  validationErrors: [ValidationError!]
}

"""
Aggregated view of an address list with entry statistics.
Address lists group IP addresses for use in firewall rules.
"""
type AddressList {
  """Number of dynamic entries (added by firewall actions)"""
  dynamicCount: Int!
  """Paginated entries in this list"""
  entries(after: String, first: Int): AddressListEntryConnection!
  """Total number of entries in this list"""
  entryCount: Int!
  """List name (unique identifier)"""
  name: String!
  """Firewall rules that reference this list"""
  referencingRules: [FirewallRule!]!
  """Number of firewall rules referencing this list"""
  referencingRulesCount: Int!
}

"""
Single entry in an address list.
Represents an IP address, CIDR subnet, or IP range that belongs to a named list.
"""
type AddressListEntry implements Node {
  """IP address, CIDR subnet, or IP range"""
  address: String! @mikrotik(path: "/ip/firewall/address-list", field: "address")
  """Optional description"""
  comment: String @validate(maxLength: 200) @mikrotik(path: "/ip/firewall/address-list", field: "comment")
  """When this entry was created"""
  creationTime: DateTime @mikrotik(path: "/ip/firewall/address-list", field: "creation-time")
  """Whether this entry is disabled"""
  disabled: Boolean! @mikrotik(path: "/ip/firewall/address-list", field: "disabled")
  """Whether this entry was added dynamically by a firewall action"""
  dynamic: Boolean! @mikrotik(path: "/ip/firewall/address-list", field: "dynamic")
  """MikroTik internal ID"""
  id: ID! @mikrotik(path: "/ip/firewall/address-list", field: ".id")
  """Name of the address list this entry belongs to"""
  list: String! @mikrotik(path: "/ip/firewall/address-list", field: "list")
  """Optional timeout after which entry is removed"""
  timeout: String @mikrotik(path: "/ip/firewall/address-list", field: "timeout")
}

"""
Connection type for paginated address list entries.
Follows Relay pagination specification.
"""
type AddressListEntryConnection implements Connection {
  edges: [AddressListEntryEdge!]!
  pageInfo: PageInfo!
  totalCount: Int
}

"""Edge type for address list entry connections."""
type AddressListEntryEdge implements Edge {
  cursor: String!
  node: AddressListEntry!
}

"""Resource affected by a configuration change"""
type AffectedResource {
  """Resource ID"""
  id: ID!
  """How the resource will be affected (modified, disabled, removed)"""
  impact: ResourceImpact!
  """Resource name or description"""
  name: String!
  """Resource type (ip-address, dhcp-server, firewall-rule, etc.)"""
  type: String!
}

"""Individual alert instance triggered when rule conditions are met"""
type Alert implements Node {
  """When alert was acknowledged"""
  acknowledgedAt: DateTime
  """User who acknowledged the alert"""
  acknowledgedBy: String
  """Event data and context information"""
  data: JSON
  """Delivery status per channel"""
  deliveryStatus: JSON
  """Device ID that triggered this alert"""
  deviceId: ID
  """Escalation tracking for this alert (NAS-18.9)"""
  escalation: AlertEscalation
  """Event type that triggered this alert"""
  eventType: String!
  """Globally unique identifier"""
  id: ID!
  """Detailed alert message"""
  message: String!
  """Alert rule that triggered this alert"""
  rule: AlertRule!
  """Alert severity level"""
  severity: AlertSeverity!
  """Reason for suppression (e.g., "throttled", "storm_detected")"""
  suppressReason: String
  """
  Number of alerts suppressed by throttling (if this alert is part of a throttle group)
  """
  suppressedCount: Int
  """Alert title/summary"""
  title: String!
  """When alert was triggered"""
  triggeredAt: DateTime!
  """Last update timestamp"""
  updatedAt: DateTime!
}

"""Alert action types for subscriptions"""
enum AlertAction {
  """Alert was acknowledged"""
  ACKNOWLEDGED
  """Alert was created/triggered"""
  CREATED
  """Alert was resolved"""
  RESOLVED
}

"""Template variable input"""
input AlertAlertTemplateVariableInput {
  """Default value"""
  defaultValue: String
  """Description"""
  description: String
  """Display label"""
  label: String!
  """Variable name"""
  name: String!
  """Options for enum types"""
  options: [String!]
  """Whether required"""
  required: Boolean!
  """Variable type"""
  type: AlertTemplateVariableType!
}

"""Condition for event matching in alert rules"""
type AlertCondition {
  """Field name to evaluate"""
  field: String!
  """Comparison operator"""
  operator: ConditionOperator!
  """Value to compare against"""
  value: String!
}

"""Alert condition input"""
input AlertConditionInput {
  """Field name to evaluate"""
  field: String!
  """Comparison operator"""
  operator: ConditionOperator!
  """Value to compare against"""
  value: String!
}

"""Paginated alert connection"""
type AlertConnection implements Connection {
  """Alert edges"""
  edges: [AlertEdge!]!
  """Pagination information"""
  pageInfo: PageInfo!
  """Total count of alerts"""
  totalCount: Int!
}

"""Alert edge for pagination"""
type AlertEdge implements Edge {
  """Pagination cursor"""
  cursor: String!
  """Alert node"""
  node: Alert!
}

"""Alert escalation tracking record (NAS-18.9)"""
type AlertEscalation implements Node {
  """Alert being tracked for escalation"""
  alertId: ID!
  """Record creation timestamp"""
  createdAt: DateTime!
  """Current escalation level (0 = initial)"""
  currentLevel: Int!
  """Globally unique identifier"""
  id: ID!
  """Maximum escalation level"""
  maxLevel: Int!
  """When next escalation level should trigger"""
  nextEscalationAt: DateTime
  """When escalation was resolved"""
  resolvedAt: DateTime
  """Reason for resolution"""
  resolvedBy: String
  """Alert rule with escalation configuration"""
  ruleId: ID!
  """Escalation status"""
  status: EscalationStatus!
  """Last update timestamp"""
  updatedAt: DateTime!
}

"""Alert event for real-time subscriptions"""
type AlertEvent {
  """Type of action that occurred"""
  action: AlertAction!
  """The alert that changed"""
  alert: Alert!
}

"""Alert mutation payload"""
type AlertPayload {
  """Modified alert"""
  alert: Alert
  """Errors encountered during mutation"""
  errors: [MutationError!]
}

"""Alert rule defines conditions that trigger notifications when met"""
type AlertRule implements Node {
  """Alerts triggered by this rule"""
  alerts(
    """Filter by acknowledged status"""
    acknowledged: Boolean
    """Limit number of results"""
    limit: Int = 50
  ): [Alert!]!
  """Notification channels to use"""
  channels: [String!]!
  """Array of conditions for event matching"""
  conditions: [AlertCondition!]!
  """Record creation timestamp"""
  createdAt: DateTime!
  """Optional description of what this rule monitors"""
  description: String
  """Optional device ID filter - rule only applies to this device"""
  deviceId: ID
  """Whether this alert rule is enabled"""
  enabled: Boolean!
  """Escalation configuration for unacknowledged alerts (NAS-18.9)"""
  escalation: EscalationConfig
  """
  Event type to match (e.g., 'router.offline', 'interface.down', 'cpu.high')
  """
  eventType: String!
  """Globally unique identifier"""
  id: ID!
  """Human-readable alert rule name"""
  name: String!
  """Quiet hours configuration for non-critical alerts"""
  quietHours: QuietHoursConfig
  """Alert severity level"""
  severity: AlertSeverity!
  """Throttle configuration to prevent alert spam"""
  throttle: ThrottleConfig
  """Last update timestamp"""
  updatedAt: DateTime!
}

"""Variable input for alert rule templates"""
input AlertRuleAlertTemplateVariableInput {
  """Default value"""
  defaultValue: String
  """Description"""
  description: String
  """Display label"""
  label: String!
  """Maximum value"""
  max: Int
  """Minimum value"""
  min: Int
  """Variable name"""
  name: String!
  """Whether required"""
  required: Boolean!
  """Variable type"""
  type: AlertRuleTemplateVariableType!
  """Unit label"""
  unit: String
}

"""Alert rule mutation payload"""
type AlertRulePayload {
  """Created/updated alert rule"""
  alertRule: AlertRule
  """Errors encountered during mutation"""
  errors: [MutationError!]
}

"""
Alert rule template for quick rule creation
Pre-configured templates with variables for common alert scenarios
"""
type AlertRuleTemplate implements Node {
  """Template category"""
  category: AlertRuleTemplateCategory!
  """Default notification channels"""
  channels: [String!]!
  """Pre-configured conditions"""
  conditions: [AlertCondition!]!
  """Record creation timestamp"""
  createdAt: DateTime!
  """Template description"""
  description: String!
  """Event type this template monitors"""
  eventType: String!
  """Globally unique identifier"""
  id: ID!
  """Whether this is a built-in template"""
  isBuiltIn: Boolean!
  """Template name"""
  name: String!
  """Alert severity level"""
  severity: AlertSeverity!
  """Throttle configuration"""
  throttle: ThrottleConfig
  """Last update timestamp"""
  updatedAt: DateTime!
  """Template variables for customization"""
  variables: [AlertRuleTemplateVariable!]!
  """Template version"""
  version: String!
}

"""Alert rule template categories"""
enum AlertRuleTemplateCategory {
  """Custom user-defined templates"""
  CUSTOM
  """DHCP and IP address management"""
  DHCP
  """Network connectivity and interface monitoring"""
  NETWORK
  """Resource usage (CPU, memory, disk)"""
  RESOURCES
  """Security and firewall events"""
  SECURITY
  """System events and maintenance"""
  SYSTEM
  """VPN and tunnel monitoring"""
  VPN
}

"""Alert rule template mutation payload"""
type AlertRuleTemplatePayload {
  """Errors encountered during mutation"""
  errors: [MutationError!]
  """Created/updated template"""
  template: AlertRuleTemplate
}

"""Preview result for alert rule template"""
type AlertRuleTemplatePreview {
  """Resolved conditions with variable substitution"""
  resolvedConditions: [AlertCondition!]!
  """The template being previewed"""
  template: AlertRuleTemplate!
  """Validation information"""
  validationInfo: TemplateValidationInfo!
}

"""Variable definition for alert rule templates"""
type AlertRuleTemplateVariable {
  """Default value"""
  defaultValue: String
  """Variable description"""
  description: String
  """Display label"""
  label: String!
  """Maximum value (for INTEGER, DURATION, PERCENTAGE)"""
  max: Int
  """Minimum value (for INTEGER, DURATION, PERCENTAGE)"""
  min: Int
  """Variable name (used for substitution)"""
  name: String!
  """Whether this variable is required"""
  required: Boolean!
  """Variable type"""
  type: AlertRuleTemplateVariableType!
  """Unit label (e.g., "seconds", "percent", "MB")"""
  unit: String
}

"""Variable types for alert rule templates"""
enum AlertRuleTemplateVariableType {
  """Duration in seconds"""
  DURATION
  """Integer value"""
  INTEGER
  """Percentage (0-100)"""
  PERCENTAGE
  """String value"""
  STRING
}

"""Alert severity levels"""
enum AlertSeverity {
  """Critical - requires immediate attention"""
  CRITICAL
  """Info - informational only"""
  INFO
  """Warning - attention needed soon"""
  WARNING
}

"""
Alert notification template
Templates define message format for different event types and channels
"""
type AlertTemplate implements Node {
  """Body template with Go template syntax"""
  bodyTemplate: String!
  """Notification channel"""
  channel: NotificationChannel!
  """Record creation timestamp"""
  createdAt: DateTime!
  """Template description"""
  description: String!
  """Event type this template applies to"""
  eventType: String!
  """Globally unique identifier"""
  id: ID!
  """Whether this is a built-in template"""
  isBuiltIn: Boolean!
  """Whether this is a system default template"""
  isDefault: Boolean!
  """Channel-specific metadata"""
  metadata: JSON
  """Template name"""
  name: String!
  """Subject/title template"""
  subjectTemplate: String
  """Tags for categorization"""
  tags: [String!]!
  """Last update timestamp"""
  updatedAt: DateTime!
  """Template variables"""
  variables: [AlertTemplateVariable!]!
}

"""Alert template mutation payload"""
type AlertTemplatePayload {
  """Errors encountered during mutation"""
  errors: [MutationError!]
  """Created/updated template"""
  template: AlertTemplate
}

"""Template variable definition"""
type AlertTemplateVariable {
  """Default value"""
  defaultValue: String
  """Variable description"""
  description: String
  """Display label"""
  label: String!
  """Variable name (used in template as {{.Name}})"""
  name: String!
  """Options for enum-type variables"""
  options: [String!]
  """Whether this variable is required"""
  required: Boolean!
  """Variable type"""
  type: AlertTemplateVariableType!
}

"""Template variable types for notification templates"""
enum AlertTemplateVariableType {
  """Boolean value"""
  BOOLEAN
  """Interface name"""
  INTERFACE
  """IP address"""
  IPADDRESS
  """Numeric value"""
  NUMBER
  """String value"""
  STRING
  """Timestamp value"""
  TIMESTAMP
}

"""Input for applying an alert template"""
input ApplyAlertTemplateInput {
  """Alert rule configuration"""
  ruleConfig: CreateAlertRuleInput!
  """Template ID to apply"""
  templateId: ID!
  """Variables for template substitution"""
  variables: JSON!
}

type ApplyChangeSetPayload {
  """Change set ID"""
  changeSetId: ID!
  """Errors that occurred"""
  errors: [MutationError!]
  """Current status"""
  status: ChangeSetStatus!
}

"""Result of applying configuration"""
type ApplyConfigPayload {
  """Path to generated config file"""
  configPath: String
  """Error messages (if failed)"""
  errors: [String!]!
  """Updated service instance (if successful)"""
  instance: ServiceInstance
  """Whether the operation succeeded"""
  success: Boolean!
}

"""Result of applying a fix"""
type ApplyFixPayload {
  """Errors that occurred"""
  errors: [MutationError!]
  """User-friendly message"""
  message: String!
  """Fix application status"""
  status: FixApplicationStatus!
  """Whether fix was applied successfully"""
  success: Boolean!
}

type ApplyResourcePayload {
  """Errors that occurred"""
  errors: [MutationError!]
  """Operation ID for progress tracking"""
  operationId: ID!
  """The applied resource"""
  resource: Resource
}

"""Input for applying service configuration"""
input ApplyServiceConfigInput {
  """Configuration to apply (as JSON)"""
  config: JSON!
  """Service instance ID"""
  instanceID: ID!
  """Router ID"""
  routerID: ID!
}

"""
Input for applying a validated service import.
Actually creates/updates the service instance.
"""
input ApplyServiceImportInput {
  """Conflict resolution strategy"""
  conflictResolution: ConflictResolution!
  """Device MAC addresses to filter routing rules (optional)"""
  deviceFilter: [String!]
  """Service export package (JSON)"""
  package: JSON!
  """User-provided values for redacted fields"""
  redactedFieldValues: JSON!
  """Router ID to import into"""
  routerID: ID!
}

"""Payload for apply service import mutation."""
type ApplyServiceImportPayload {
  """Mutation errors"""
  errors: [MutationError!]
  """Created or updated service instance (null if failed)"""
  instance: ServiceInstance
  """Whether the operation succeeded"""
  success: Boolean!
}

type ArchiveResourcePayload {
  """Errors that occurred"""
  errors: [MutationError!]
  """Whether archive was successful"""
  success: Boolean!
}

"""Input for assigning device routing."""
input AssignDeviceRoutingInput {
  """Device ID to route"""
  deviceID: String! @validate(minLength: 1, maxLength: 100)
  """Device IP address (optional)"""
  deviceIP: String
  """Device hostname (optional)"""
  deviceName: String @validate(maxLength: 255)
  """Service instance ID to route through"""
  instanceID: ID!
  """Virtual interface ID to route through"""
  interfaceID: ID!
  """Device MAC address"""
  macAddress: String! @validate(pattern: "^([0-9A-Fa-f]{2}[:-]){5}([0-9A-Fa-f]{2})$")
  """Router ID"""
  routerID: ID!
  """Routing mark"""
  routingMark: String! @validate(minLength: 1, maxLength: 255)
  """Routing mode"""
  routingMode: RoutingMode!
}

"""Authentication error codes"""
enum AuthErrorCode {
  """Insufficient permissions"""
  INSUFFICIENT_ROLE
  """Invalid username or password"""
  INVALID_CREDENTIALS
  """Password does not meet requirements"""
  PASSWORD_POLICY_VIOLATION
  """Too many login attempts"""
  RATE_LIMITED
  """Session has expired"""
  SESSION_EXPIRED
  """Token has expired"""
  TOKEN_EXPIRED
  """Token is invalid or malformed"""
  TOKEN_INVALID
}

"""Authentication payload returned on successful login"""
type AuthPayload {
  """Token expiration timestamp"""
  expiresAt: DateTime!
  """JWT access token"""
  token: String!
  """Authenticated user"""
  user: User!
}

"""Authentication test status"""
type AuthStatus {
  """Error message (if authentication failed)"""
  error: String
  """Error code mapped to ErrorCodes (A5xx)"""
  errorCode: String
  """Whether authentication succeeded"""
  success: Boolean!
  """Whether authentication was tested"""
  tested: Boolean!
}

"""
Available service that can be installed from the Feature Marketplace.
Represents a downloadable network service with metadata from the manifest.
"""
type AvailableService {
  """Supported architectures"""
  architectures: [String!]!
  """Service author"""
  author: String!
  """Service category (VPN, Privacy, DNS, Messaging)"""
  category: String!
  """Configuration schema (JSON Schema)"""
  configSchema: JSON
  """Default configuration (JSON)"""
  defaultConfig: JSON
  """Service description"""
  description: String!
  """Docker image name"""
  dockerImage: String!
  """Docker image tag"""
  dockerTag: String!
  """Homepage URL"""
  homepage: String
  """Icon filename or URL"""
  icon: String
  """Unique service identifier (e.g., 'tor', 'sing-box', 'xray')"""
  id: ID!
  """License"""
  license: String!
  """Minimum RouterOS version required"""
  minRouterOSVersion: String
  """Display name"""
  name: String!
  """Required disk space in MB"""
  requiredDiskMB: Int!
  """Required memory in MB"""
  requiredMemoryMB: Int!
  """Required packages"""
  requiredPackages: [String!]!
  """Required ports"""
  requiredPorts: [Int!]!
  """Tags for filtering and search"""
  tags: [String!]!
  """Service version"""
  version: String!
}

"""Bandwidth string with unit (e.g., "10M", "1G", "100k")"""
scalar Bandwidth

"""A bandwidth data point"""
type BandwidthDataPoint {
  """Bytes in during this period"""
  bytesIn: Size!
  """Bytes out during this period"""
  bytesOut: Size!
  """Period duration in seconds"""
  periodSeconds: Int!
  """Timestamp"""
  timestamp: DateTime!
}

"""Actions available for batch interface operations"""
enum BatchInterfaceAction {
  DISABLE
  ENABLE
  UPDATE
}

"""Input for batch interface operations"""
input BatchInterfaceInput {
  """Action to perform"""
  action: BatchInterfaceAction!
  """Optional input for UPDATE action"""
  input: UpdateInterfaceInput
  """Interface IDs to operate on"""
  interfaceIds: [ID!]!
}

"""Payload returned by batchInterfaceOperation mutation"""
type BatchInterfacePayload {
  """General errors that occurred"""
  errors: [MutationError!]
  """Interfaces that failed with reasons"""
  failed: [InterfaceOperationError!]!
  """Interfaces that were successfully updated"""
  succeeded: [Interface!]!
}

"""
Binary verification information for a service instance.
Contains hashes and verification status for security auditing.
"""
type BinaryVerification {
  """SHA256 hash of the original downloaded archive (from checksums.txt)"""
  archiveHash: String
  """SHA256 hash of the extracted binary (computed at runtime)"""
  binaryHash: String
  """URL where checksums.txt was fetched from"""
  checksumsURL: String
  """Whether binary verification is enabled for this instance"""
  enabled: Boolean!
  """GPG key ID that signed the checksums file"""
  gpgKeyID: String
  """Whether GPG signature verification was performed and passed"""
  gpgVerified: Boolean!
  """Verification status (valid, invalid, pending, not_verified)"""
  status: VerificationStatus!
  """Timestamp when binary was last verified"""
  verifiedAt: DateTime
}

"""BootSequenceEvent represents a real-time boot sequence event."""
type BootSequenceEvent {
  errorMessage: String
  failureCount: Int
  id: ID!
  instanceIds: [String!]!
  layer: Int
  successCount: Int
  timestamp: DateTime!
  type: String!
}

"""
BootSequenceProgress represents the current state of the boot sequence.
"""
type BootSequenceProgress {
  currentLayer: Int
  failedInstances: [String!]!
  inProgress: Boolean!
  remainingInstances: [String!]!
  startedInstances: [String!]!
  totalLayers: Int
}

type Bridge implements Node {
  comment: String @mikrotik(path: "/interface/bridge", field: "comment")
  dependentDhcpServers: [DhcpServer!]!
  dependentRoutes: [Route!]!
  disabled: Boolean! @mikrotik(path: "/interface/bridge", field: "disabled")
  id: ID!
  ipAddresses: [IpAddress!]!
  macAddress: MAC @mikrotik(path: "/interface/bridge", field: "mac-address")
  mtu: Int @validate(min: 68, max: 65535) @mikrotik(path: "/interface/bridge", field: "mtu")
  name: String!
  ports: [BridgePort!]!
  priority: Int @validate(min: 0, max: 61440) @mikrotik(path: "/interface/bridge", field: "priority")
  protocol: StpProtocol! @mikrotik(path: "/interface/bridge", field: "protocol")
  pvid: Int @validate(min: 1, max: 4094) @mikrotik(path: "/interface/bridge", field: "pvid")
  running: Boolean!
  stpStatus: BridgeStpStatus
  vlanFiltering: Boolean! @mikrotik(path: "/interface/bridge", field: "vlan-filtering")
  vlans: [BridgeVlan!]!
}

type BridgeMutationResult {
  bridge: Bridge
  errors: [MutationError!]
  """Unique operation ID for undo within 10-second window"""
  operationId: ID
  """Previous state for undo functionality"""
  previousState: JSON
  success: Boolean!
}

type BridgePort implements Node {
  bridge: Bridge!
  edge: Boolean! @mikrotik(path: "/interface/bridge/port", field: "edge")
  frameTypes: FrameTypes! @mikrotik(path: "/interface/bridge/port", field: "frame-types")
  id: ID!
  ingressFiltering: Boolean! @mikrotik(path: "/interface/bridge/port", field: "ingress-filtering")
  interface: Interface!
  pathCost: Int!
  pvid: Int! @validate(min: 1, max: 4094) @mikrotik(path: "/interface/bridge/port", field: "pvid")
  role: StpPortRole!
  state: StpPortState!
  taggedVlans: [Int!]!
  untaggedVlans: [Int!]!
}

"""Frame types that can be admitted on a bridge port"""
enum BridgePortFrameTypes {
  """Accept all frames (tagged and untagged)"""
  ADMIT_ALL
  """Accept only untagged and priority-tagged frames"""
  ADMIT_ONLY_UNTAGGED_AND_PRIORITY_TAGGED
  """Accept only VLAN-tagged frames"""
  ADMIT_ONLY_VLAN_TAGGED
}

type BridgePortMutationResult {
  errors: [MutationError!]
  operationId: ID
  port: BridgePort
  previousState: JSON
  success: Boolean!
}

"""VLAN configuration for a bridge port (trunk/access port setup)"""
type BridgePortVlanConfig {
  """Frame types allowed on this port"""
  frameTypes: BridgePortFrameTypes!
  """Port mode (trunk or access)"""
  mode: PortMode!
  """Bridge port ID"""
  portId: ID!
  """Port VLAN ID (PVID) for untagged traffic"""
  pvid: Int! @validate(min: 1, max: 4094)
  """Tagged VLANs allowed on this port (trunk mode)"""
  taggedVlans: [Int!]! @validate(min: 1, max: 4094)
  """Untagged VLANs on this port (typically just PVID)"""
  untaggedVlans: [Int!]! @validate(min: 1, max: 4094)
}

"""Input for configuring bridge port VLAN settings"""
input BridgePortVlanInput {
  """Frame types allowed on this port"""
  frameTypes: BridgePortFrameTypes!
  """Port mode (trunk or access)"""
  mode: PortMode!
  """Port VLAN ID (PVID) for untagged traffic"""
  pvid: Int! @validate(min: 1, max: 4094)
  """Tagged VLANs (for trunk ports)"""
  taggedVlans: [Int!] @validate(min: 1, max: 4094)
}

"""Bridge resource (part of LANNetwork)"""
type BridgeResource implements Node & Resource {
  category: ResourceCategory!
  configuration: JSON!
  deployment: DeploymentState
  id: ID!
  metadata: ResourceMetadata!
  """Bridge name"""
  name: String!
  platform: PlatformInfo
  """Ports in this bridge"""
  ports: [String!]!
  """Protocol mode (rstp, stp, none)"""
  protocolMode: String
  relationships: ResourceRelationships
  runtime: RuntimeState
  scopedId: String!
  telemetry: TelemetryData
  type: String!
  validation: ValidationResult
}

"""
Bridge status for service instance network setup.
Combines interface and gateway status for health monitoring.
"""
type BridgeStatus {
  """Any errors encountered"""
  errors: [String!]
  """Whether the gateway (if any) is running"""
  gatewayRunning: Boolean!
  """The virtual interface"""
  interface: VirtualInterface
  """Whether the interface is ready for traffic"""
  isReady: Boolean!
}

type BridgeStpStatus {
  lastTopologyChange: DateTime
  rootBridge: Boolean!
  rootBridgeId: String
  rootPathCost: Int!
  rootPort: String
  topologyChangeCount: Int!
}

type BridgeVlan {
  bridge: Bridge!
  taggedPorts: [BridgePort!]!
  untaggedPorts: [BridgePort!]!
  uuid: ID!
  vlanId: Int! @validate(min: 1, max: 4094)
}

type BridgeVlanMutationResult {
  errors: [MutationError!]
  success: Boolean!
  vlan: BridgeVlan
}

"""
Input for bulk address import.
Used with bulkCreateAddressListEntries mutation.
"""
input BulkAddressInput {
  """IP address, CIDR notation, or IP range"""
  address: String!
  """Optional description"""
  comment: String @validate(maxLength: 200)
  """Optional timeout"""
  timeout: String @validate(pattern: "^\\d+[smhdw]$")
}

"""Bulk alert mutation payload"""
type BulkAlertPayload {
  """Number of alerts acknowledged"""
  acknowledgedCount: Int!
  """Errors encountered during mutation"""
  errors: [MutationError!]
}

"""Input for bulk device routing assignment."""
input BulkAssignRoutingInput {
  """List of device routing assignments"""
  assignments: [SingleDeviceRoutingInput!]!
  """Router ID"""
  routerID: ID!
}

"""Details of a single failed entry in bulk import."""
type BulkCreateError {
  """The address that failed"""
  address: String!
  """Index in the input array"""
  index: Int!
  """Error message"""
  message: String!
}

"""
Result of bulk address list entry creation.
Includes success count, failure count, and error details.
"""
type BulkCreateResult {
  """Details of failed entries"""
  errors: [BulkCreateError!]!
  """Number of entries that failed"""
  failedCount: Int!
  """Number of entries successfully created"""
  successCount: Int!
}

"""Failed routing assignment in bulk operation."""
type BulkRoutingFailure {
  """Device ID that failed"""
  deviceID: String!
  """Error message"""
  errorMessage: String!
  """Device MAC address"""
  macAddress: String!
}

"""Result of bulk routing assignment operation."""
type BulkRoutingResult {
  """Number of failed assignments"""
  failureCount: Int!
  """Failed assignments with error messages"""
  failures: [BulkRoutingFailure!]!
  """Number of successful assignments"""
  successCount: Int!
  """Successfully assigned routings"""
  successes: [DeviceRouting!]!
}

"""CIDR notation for network address (e.g., "192.168.1.0/24")"""
scalar CIDR

"""CPU utilization metrics"""
type CPUMetrics {
  """Number of CPU cores"""
  cores: Int!
  """CPU frequency in MHz (optional)"""
  frequency: Float
  """Per-core usage percentages (one per core)"""
  perCore: [Float!]!
  """Overall CPU usage percentage (0-100)"""
  usage: Float!
}

enum CacheScope {
  PRIVATE
  PUBLIC
}

type CancelChangeSetPayload {
  """The cancelled change set"""
  changeSet: ChangeSet
  """Errors that occurred"""
  errors: [MutationError!]
  """Whether cancel was successful"""
  success: Boolean!
}

type CancelScanPayload {
  """Errors that occurred"""
  errors: [MutationError!]
  """The cancelled scan task"""
  task: ScanTask
}

"""
Feature capability categories detected on routers.
Used to determine what features are available on a specific router.
"""
enum Capability {
  """Container/Docker support"""
  CONTAINER
  """Dude monitoring support"""
  DUDE
  """Firewall features"""
  FIREWALL
  """Hotspot features"""
  HOTSPOT
  """IPv6 support"""
  IPV6
  """MPLS support"""
  MPLS
  """Advanced routing features"""
  ROUTING
  """User Manager features"""
  USER_MANAGER
  """Virtual Interface Factory support"""
  VIF
  """WireGuard VPN support"""
  WIREGUARD
  """Wireless/WiFi support"""
  WIRELESS
  """ZeroTier support"""
  ZEROTIER
}

"""Single capability with its support level and guidance"""
type CapabilityEntry {
  """Capability category"""
  capability: Capability!
  """Human-readable description of support"""
  description: String
  """Actionable message if feature unavailable"""
  guidance: String
  """Support level"""
  level: CapabilityLevel!
}

"""
Capability support level for a feature.
Determines how the feature appears in the UI.
"""
enum CapabilityLevel {
  """Full RouterOS native support"""
  ADVANCED
  """Limited support (show with warnings)"""
  BASIC
  """Complete support including container-based features"""
  FULL
  """Feature not supported (hide in UI)"""
  NONE
}

"""
A single hop in a multi-hop routing chain, referencing one VirtualInterface.
"""
type ChainHop implements Node {
  """Whether this hop is currently healthy"""
  healthy: Boolean!
  """Hop ID (ULID)"""
  id: ID!
  """Virtual interface for this hop"""
  interface: VirtualInterface!
  """Whether kill switch is active for this hop"""
  killSwitchActive: Boolean!
  """Latency for this hop in milliseconds (-1 if unreachable)"""
  latencyMs: Float
  """1-based position in the chain (1 = first hop, 2 = second, etc.)"""
  order: Int!
  """MikroTik routing mark (e.g., chain-abc123-hop1)"""
  routingMark: String!
}

"""Input for a single hop in a chain."""
input ChainHopInput {
  """Virtual interface ID for this hop"""
  interfaceId: ID!
  """1-based position in the chain"""
  order: Int! @validate(min: 1, max: 5)
}

"""An entry in the change log"""
type ChangeLogEntry {
  """Type of change"""
  changeType: ChangeType!
  """Changed fields"""
  changedFields: [String!]!
  """Brief description of the change"""
  summary: String
  """Change timestamp"""
  timestamp: DateTime!
  """User who made the change"""
  user: String!
}

"""Type of operation to perform on a resource"""
enum ChangeOperation {
  """Create a new resource"""
  CREATE
  """Delete an existing resource"""
  DELETE
  """Update an existing resource"""
  UPDATE
}

"""A change set representing an atomic multi-resource operation"""
type ChangeSet {
  """Apply started timestamp"""
  applyStartedAt: DateTime
  """Completed timestamp"""
  completedAt: DateTime
  """Created timestamp"""
  createdAt: DateTime!
  """User who created the change set"""
  createdBy: String
  """Optional description"""
  description: String
  """Error information (if failed)"""
  error: ChangeSetError
  """Unique identifier (ULID)"""
  id: ID!
  """Items in this change set"""
  items: [ChangeSetItem!]!
  """Human-readable name"""
  name: String!
  """Rollback plan"""
  rollbackPlan: [RollbackStep!]!
  """Router ID this change set applies to"""
  routerId: ID!
  """Source wizard/feature"""
  source: String
  """Current status"""
  status: ChangeSetStatus!
  """Validation result"""
  validation: ChangeSetValidationResult
  """Version for optimistic concurrency"""
  version: Int!
}

"""Conflict between change set items"""
type ChangeSetConflict {
  """Description of the conflict"""
  description: String!
  """Whether conflict is with existing resource"""
  isExternalConflict: Boolean!
  """First conflicting item ID"""
  itemId1: ID!
  """Second conflicting item ID or resource UUID"""
  itemId2OrResourceUuid: ID!
  """Suggested resolution"""
  resolution: String
}

"""Detailed error for failed change sets"""
type ChangeSetError {
  """Error code"""
  code: String
  """Item ID that caused the failure"""
  failedItemId: ID!
  """Items that failed rollback"""
  failedRollbackItemIds: [ID!]!
  """Error message"""
  message: String!
  """Items applied before failure"""
  partiallyAppliedItemIds: [ID!]!
  """Whether manual intervention is required"""
  requiresManualIntervention: Boolean!
}

"""Individual item within a change set"""
type ChangeSetItem {
  """Apply completed timestamp"""
  applyCompletedAt: DateTime
  """Order in which this item will be applied"""
  applyOrder: Int!
  """Apply started timestamp"""
  applyStartedAt: DateTime
  """New/updated configuration"""
  configuration: JSON!
  """Item IDs this depends on"""
  dependencies: [ID!]!
  """Optional description"""
  description: String
  """Error message if failed"""
  error: String
  """Unique identifier for this item"""
  id: ID!
  """User-friendly name"""
  name: String!
  """Operation to perform"""
  operation: ChangeOperation!
  """Previous state (for rollback)"""
  previousState: JSON
  """Resource category"""
  resourceCategory: ResourceCategory!
  """Resource type identifier"""
  resourceType: String!
  """Existing resource UUID (null for create operations)"""
  resourceUuid: ID
  """Current status"""
  status: ChangeSetItemStatus!
}

"""Input for adding an item to a change set"""
input ChangeSetItemInput {
  """Configuration"""
  configuration: JSON!
  """Item IDs this depends on"""
  dependencies: [ID!]
  """Optional description"""
  description: String
  """User-friendly name"""
  name: String!
  """Operation to perform"""
  operation: ChangeOperation!
  """Previous state (for rollback on update/delete)"""
  previousState: JSON
  """Resource category"""
  resourceCategory: ResourceCategory!
  """Resource type identifier"""
  resourceType: String!
  """Existing resource UUID (for update/delete)"""
  resourceUuid: ID
}

"""Status of individual items within a change set"""
enum ChangeSetItemStatus {
  """Successfully applied"""
  APPLIED
  """Currently being applied"""
  APPLYING
  """Application failed"""
  FAILED
  """Waiting to be applied"""
  PENDING
  """Rollback failed - manual intervention needed"""
  ROLLBACK_FAILED
  """Successfully rolled back"""
  ROLLED_BACK
  """Skipped due to dependency failure"""
  SKIPPED
}

"""Progress event for real-time updates during apply"""
type ChangeSetProgressEvent {
  """Number of items applied"""
  appliedCount: Int!
  """Change set ID"""
  changeSetId: ID!
  """Currently processing item"""
  currentItem: CurrentItemInfo
  """Error if failed"""
  error: ChangeSetError
  """Estimated time remaining in milliseconds"""
  estimatedRemainingMs: Int
  """Progress percentage (0-100)"""
  progressPercent: Float!
  """Current status"""
  status: ChangeSetStatus!
  """Timestamp of this event"""
  timestamp: DateTime!
  """Total number of items"""
  totalCount: Int!
}

"""Change set lifecycle status"""
enum ChangeSetStatus {
  """Applying resources in dependency order"""
  APPLYING
  """User cancelled the operation"""
  CANCELLED
  """All resources applied successfully"""
  COMPLETED
  """Initial state - adding items, not yet validated"""
  DRAFT
  """Apply failed, may have partial application"""
  FAILED
  """Rollback partially failed - manual intervention needed"""
  PARTIAL_FAILURE
  """All items validated, ready to apply"""
  READY
  """Rollback completed successfully"""
  ROLLED_BACK
  """Rolling back applied changes"""
  ROLLING_BACK
  """Running validation on all items"""
  VALIDATING
}

"""Change set status change event"""
type ChangeSetStatusEvent {
  """Change set ID"""
  changeSetId: ID!
  """Error if failed"""
  error: ChangeSetError
  """New status"""
  newStatus: ChangeSetStatus!
  """Previous status"""
  previousStatus: ChangeSetStatus!
  """Timestamp"""
  timestamp: DateTime!
}

"""Summary of a change set for list displays"""
type ChangeSetSummary {
  """Created timestamp"""
  createdAt: DateTime!
  """Has validation errors"""
  hasErrors: Boolean!
  """Has validation warnings"""
  hasWarnings: Boolean!
  """Change set ID"""
  id: ID!
  """Name"""
  name: String!
  """Operation counts"""
  operationCounts: OperationCounts!
  """Current status"""
  status: ChangeSetStatus!
  """Total items"""
  totalItems: Int!
}

"""Validation error for a change set item"""
type ChangeSetValidationError {
  """Error code"""
  code: String
  """Field path within the item configuration"""
  field: String!
  """Item ID with validation error"""
  itemId: ID!
  """Error message"""
  message: String!
  """Severity level"""
  severity: ValidationSeverity!
}

"""Validation result for a change set"""
type ChangeSetValidationResult {
  """Whether the change set can be applied"""
  canApply: Boolean!
  """Circular dependencies (if any)"""
  circularDependencies: [[ID!]!]
  """Detected conflicts"""
  conflicts: [ChangeSetConflict!]!
  """Validation errors (blocking)"""
  errors: [ChangeSetValidationError!]!
  """Missing dependencies"""
  missingDependencies: [MissingDependency!]!
  """Validation warnings (non-blocking)"""
  warnings: [ChangeSetValidationError!]!
}

"""Type of change for resource events"""
enum ChangeType {
  CREATE
  DELETE
  UPDATE
}

"""Payload for channel configuration mutations"""
type ChannelConfigPayload {
  """The created/updated configuration"""
  config: NotificationChannelConfig
  """Validation or mutation errors"""
  errors: [MutationError!]
}

"""Type of notification channel"""
enum ChannelType {
  EMAIL
  PUSHOVER
  SLACK
  TELEGRAM
  WEBHOOK
}

"""Input for checking port availability."""
input CheckPortAvailabilityInput {
  """Port number to check"""
  port: Int! @validate(min: 1, max: 65535)
  """Protocol to check"""
  protocol: PortProtocol!
  """Router ID to check"""
  routerID: ID!
}

"""Event emitted when circuit breaker state changes"""
type CircuitBreakerEvent {
  """Consecutive failures that triggered the change"""
  consecutiveFailures: Int!
  """New state"""
  newState: CircuitBreakerState!
  """Previous state"""
  previousState: CircuitBreakerState!
  """Router ID"""
  routerId: ID!
  """When the state changed"""
  timestamp: DateTime!
}

"""Circuit breaker state"""
enum CircuitBreakerState {
  """Circuit is closed (normal operation)"""
  CLOSED
  """Circuit is half-open (testing recovery)"""
  HALF_OPEN
  """Circuit is open (blocking requests)"""
  OPEN
}

"""Circuit breaker status for a router"""
type CircuitBreakerStatus {
  """Seconds until auto-retry (when circuit is open)"""
  cooldownRemainingSeconds: Int
  """Number of consecutive failures"""
  failureCount: Int!
  """Failure threshold before circuit opens"""
  failureThreshold: Int!
  """When the last failure occurred"""
  lastFailureAt: DateTime
  """When the last success occurred"""
  lastSuccessAt: DateTime
  """Router ID"""
  routerId: ID!
  """Current circuit breaker state"""
  state: CircuitBreakerState!
}

"""Input for cleaning up orphaned ports."""
input CleanupOrphanedPortsInput {
  """Router ID to cleanup (if not provided, cleans all routers)"""
  routerID: ID
}

"""A composite resource with all related sub-resources"""
type CompositeResource {
  """All child/related resources"""
  children: [Resource!]!
  """Flattened relationship graph"""
  relationships: [ResourceRelationshipEdge!]!
  """The root resource"""
  root: Resource!
}

"""Condition comparison operators"""
enum ConditionOperator {
  """String contains"""
  CONTAINS
  """Exact match"""
  EQUALS
  """Numeric greater than"""
  GREATER_THAN
  """Numeric less than"""
  LESS_THAN
  """Not equal"""
  NOT_EQUALS
  """Regular expression match"""
  REGEX
}

"""Status of a configuration apply operation"""
enum ConfigApplyStatus {
  APPLYING
  COMPLETED
  FAILED
  PENDING
  ROLLED_BACK
  VALIDATING
  VERIFYING
}

"""Configuration field type for dynamic form generation"""
enum ConfigFieldType {
  """Email input"""
  EMAIL
  """IP address input"""
  IP
  """Multi-select dropdown"""
  MULTI_SELECT
  """Number input"""
  NUMBER
  """Password input (masked)"""
  PASSWORD
  """Port number input"""
  PORT
  """Single-select dropdown"""
  SELECT
  """Single-line text input"""
  TEXT
  """Multi-line text area"""
  TEXT_AREA
  """Array of text inputs"""
  TEXT_ARRAY
  """Boolean toggle/checkbox"""
  TOGGLE
  """URL input"""
  URL
}

"""Preview of RouterOS configuration commands"""
type ConfigPreview {
  """Resources that will be affected"""
  affectedResources: [AffectedResource!]
  """RouterOS commands to be executed"""
  commands: [String!]!
  """Warnings about the configuration changes"""
  warnings: [String!]
}

"""Progress information for configuration apply operations"""
type ConfigProgress {
  """Current step number"""
  currentStep: Int
  """Human-readable progress message"""
  message: String!
  """Unique operation identifier"""
  operationId: ID!
  """Completion percentage (0-100)"""
  percentage: Int!
  """Current status of the operation"""
  status: ConfigApplyStatus!
  """Timestamp of this progress update"""
  timestamp: DateTime!
  """Total number of steps"""
  totalSteps: Int
}

"""Configuration schema for a service type"""
type ConfigSchema {
  """Configuration fields"""
  fields: [ConfigSchemaField!]!
  """Service type identifier"""
  serviceType: String!
  """Schema version"""
  version: String!
}

"""Configuration field definition for a service"""
type ConfigSchemaField {
  """Default value (as JSON)"""
  defaultValue: JSON
  """Field description/help text"""
  description: String
  """Field label (display name)"""
  label: String!
  """Maximum value (for NUMBER/PORT types)"""
  max: Int
  """Minimum value (for NUMBER/PORT types)"""
  min: Int
  """Field name (internal identifier)"""
  name: String!
  """Options for SELECT/MULTI_SELECT types"""
  options: [String!]
  """Placeholder text"""
  placeholder: String
  """Whether the field is required"""
  required: Boolean!
  """Whether the field contains sensitive data"""
  sensitive: Boolean!
  """Field type for UI rendering"""
  type: ConfigFieldType!
  """Validation function name"""
  validateFunc: String
}

"""Validation error for a configuration field"""
type ConfigValidationError {
  """Field name"""
  field: String!
  """Error message"""
  message: String!
}

"""Service configuration validation result"""
type ConfigValidationResult {
  """List of validation errors (empty if valid)"""
  errors: [ConfigValidationError!]!
  """Whether the configuration is valid"""
  valid: Boolean!
}

"""Input for configuring external storage."""
input ConfigureExternalStorageInput {
  """Whether to enable external storage (default: true)"""
  enabled: Boolean
  """Absolute path to external storage mount point"""
  path: String! @validate(minLength: 1, maxLength: 255)
}

"""Payload for configureExternalStorage mutation."""
type ConfigureExternalStoragePayload {
  """Storage configuration after update"""
  config: StorageConfig
  """Mutation errors"""
  errors: [MutationError!]
  """Storage info for configured path"""
  storageInfo: StorageInfo
}

"""Input for configuring health check settings"""
input ConfigureHealthCheckInput {
  """Whether to enable auto-restart on failure"""
  autoRestart: Boolean
  """Consecutive failures before marking unhealthy (1-10)"""
  failureThreshold: Int
  """Instance ID to configure"""
  instanceID: ID!
  """Health check interval in seconds (10-300)"""
  intervalSeconds: Int
}

"""Severity level for confirmation dialogs"""
enum ConfirmationSeverity {
  """Critical operation requiring explicit confirmation"""
  CRITICAL
  """Standard operation with brief confirmation"""
  STANDARD
}

"""
Conflict resolution strategy for service import.
Determines what happens when an imported service name already exists.
"""
enum ConflictResolution {
  """Overwrite existing instance configuration"""
  OVERWRITE
  """Create new instance with renamed name"""
  RENAME
  """Skip import, leave existing instance unchanged"""
  SKIP
}

"""Types of resource conflicts"""
enum ConflictType {
  """Configuration incompatibility"""
  CONFIGURATION
  """Interface conflict"""
  INTERFACE
  """IP address conflict"""
  IP_ADDRESS
  """Name collision"""
  NAME
  """Port number conflict"""
  PORT
  """Route overlap"""
  ROUTE
}

type ConnectRouterPayload {
  """Errors that occurred during connection"""
  errors: [MutationError!]
  """The router that was connected"""
  router: Router
}

"""Connection interface for paginated results (Relay pagination)"""
interface Connection {
  """Pagination information"""
  pageInfo: PageInfo!
  """Total count of items (if available)"""
  totalCount: Int
}

"""Record of a single protocol connection attempt"""
type ConnectionAttempt {
  """When the attempt ended"""
  endedAt: DateTime!
  """Error category for classification"""
  errorCategory: ErrorCategory
  """Error code if failed"""
  errorCode: String
  """Error message if failed"""
  errorMessage: String
  """Protocol that was attempted"""
  protocol: Protocol!
  """When the attempt started"""
  startedAt: DateTime!
  """Whether the attempt succeeded"""
  success: Boolean!
}

"""Detailed connection status for a router"""
type ConnectionDetails {
  """Current circuit breaker state"""
  circuitBreakerState: CircuitBreakerState!
  """When the connection was established"""
  connectedAt: DateTime
  """Reason for disconnection"""
  disconnectReason: DisconnectReason
  """When the last disconnection occurred"""
  disconnectedAt: DateTime
  """Consecutive failed health checks"""
  healthChecksFailed: Int!
  """Consecutive passed health checks"""
  healthChecksPassed: Int!
  """Whether the current protocol is considered legacy/insecure"""
  isLegacyProtocol: Boolean!
  """Most recent error message"""
  lastError: String
  """When the last error occurred"""
  lastErrorTime: DateTime
  """When the last health check was performed"""
  lastHealthCheck: DateTime
  """When the next reconnection attempt will be made"""
  nextReconnectAt: DateTime
  """User's preferred protocol (if set)"""
  preferredProtocol: Protocol
  """Protocol currently in use"""
  protocol: Protocol
  """Number of reconnection attempts made"""
  reconnectAttempts: Int!
  """Security warning if using insecure protocol (e.g., Telnet)"""
  securityWarning: String
  """Current connection state"""
  state: ConnectionStatus!
  """Recommendation for upgrading to a more secure protocol"""
  upgradeRecommendation: String
  """Connection uptime duration"""
  uptime: Duration
  """Router version (if connected)"""
  version: String
}

"""
Detailed error information for connection failures.
Used to provide actionable feedback to the user.
"""
type ConnectionError {
  """Error code for programmatic handling"""
  code: ConnectionErrorCode!
  """Human-readable error message"""
  message: String!
  """Protocol that failed (if specific to a protocol)"""
  protocol: Protocol
  """Whether the error is likely transient and retryable"""
  retryable: Boolean!
  """Suggested user action to resolve the error"""
  suggestedAction: String
  """Timeout in milliseconds (if timeout error)"""
  timeoutMs: Int
}

"""
Error codes for connection failures.
Each code has specific meaning and recovery suggestions.
"""
enum ConnectionErrorCode {
  """Authentication failed - invalid username or password"""
  AUTH_FAILED
  """Connection refused - port is closed or blocked"""
  CONNECTION_REFUSED
  """DNS resolution failed for hostname"""
  DNS_FAILED
  """Router with same host/port already exists"""
  DUPLICATE_ROUTER
  """Network unreachable - cannot reach the host"""
  NETWORK_UNREACHABLE
  """Router responded but is not a MikroTik device"""
  NOT_MIKROTIK
  """No compatible protocol found after trying all options"""
  PROTOCOL_MISMATCH
  """Connection or response timed out"""
  TIMEOUT
  """TLS/SSL handshake failed"""
  TLS_ERROR
  """Unknown or unexpected error"""
  UNKNOWN
}

"""Connection manager statistics"""
type ConnectionStats {
  """Number of connected routers"""
  connected: Int!
  """Number of connecting routers"""
  connecting: Int!
  """Number of disconnected routers"""
  disconnected: Int!
  """Number of routers in error state"""
  error: Int!
  """Number of reconnecting routers"""
  reconnecting: Int!
  """Total number of connections"""
  totalConnections: Int!
}

"""Router connection status"""
enum ConnectionStatus {
  """Actively connected and responsive"""
  CONNECTED
  """Connection attempt in progress"""
  CONNECTING
  """Not connected"""
  DISCONNECTED
  """Connection failed with error"""
  ERROR
}

"""
Result of a connection test attempt, including protocol detection results.
"""
type ConnectionTestResult {
  """Architecture of the router (arm, arm64, x86, etc.)"""
  architecture: String
  """Router board name (if connection succeeded)"""
  boardName: String
  """Error details if connection failed"""
  error: ConnectionError
  """Protocol that was successfully used"""
  protocolUsed: Protocol
  """List of protocols that were attempted"""
  protocolsAttempted: [Protocol!]!
  """Response time in milliseconds"""
  responseTimeMs: Int
  """Router model detected (if connection succeeded)"""
  routerModel: String
  """RouterOS version detected (if connection succeeded)"""
  routerVersion: String
  """Whether the connection was successful"""
  success: Boolean!
  """Whether the router supports containers"""
  supportsContainers: Boolean
  """Uptime of the router (if connection succeeded)"""
  uptime: Duration
}

"""Container-specific capability information"""
type ContainerInfo {
  """Whether container feature is enabled in system settings"""
  enabled: Boolean!
  """Maximum number of containers supported"""
  maxContainers: Int
  """Whether container package is installed"""
  packageInstalled: Boolean!
  """Whether a container registry is configured"""
  registryConfigured: Boolean!
  """Available storage for container images in bytes"""
  storageAvailable: Size!
  """Whether network namespace is supported"""
  supportsNetworkNamespace: Boolean!
}

"""
Input for creating a new address list entry.
List will be created if it doesn't exist.
"""
input CreateAddressListEntryInput {
  """
  IP address, CIDR notation (e.g., 192.168.1.0/24), or IP range (e.g., 192.168.1.1-192.168.1.100)
  """
  address: String! @validate(minLength: 7, maxLength: 100)
  """Optional description"""
  comment: String @validate(maxLength: 200)
  """Target list name (will create if doesn't exist)"""
  list: String! @validate(minLength: 1, maxLength: 64, pattern: "^[a-zA-Z0-9_-]+$")
  """Optional timeout (e.g., "1d", "12h", "30m")"""
  timeout: String @validate(pattern: "^\\d+[smhdw]$")
}

"""Input for creating an alert rule"""
input CreateAlertRuleInput {
  """Notification channels"""
  channels: [String!]!
  """Array of conditions"""
  conditions: [AlertConditionInput!]
  """Optional description"""
  description: String
  """Optional device ID filter"""
  deviceId: ID
  """Whether rule is enabled (default: true)"""
  enabled: Boolean = true
  """Escalation configuration (NAS-18.9)"""
  escalation: EscalationConfigInput
  """Event type to match"""
  eventType: String!
  """Human-readable alert rule name"""
  name: String!
  """Quiet hours configuration"""
  quietHours: QuietHoursConfigInput
  """Alert severity level"""
  severity: AlertSeverity!
  """Throttle configuration"""
  throttle: ThrottleConfigInput
}

input CreateBridgeInput {
  comment: String
  mtu: Int @validate(min: 68, max: 65535)
  name: String! @validate(minLength: 1, maxLength: 100, pattern: "^[a-zA-Z][a-zA-Z0-9_-]*$")
  priority: Int @validate(min: 0, max: 61440)
  protocol: StpProtocol
  pvid: Int @validate(min: 1, max: 4094)
  vlanFiltering: Boolean
}

input CreateBridgeVlanInput {
  taggedPortIds: [ID!]
  untaggedPortIds: [ID!]
  vlanId: Int! @validate(min: 1, max: 4094)
}

"""Input for creating a new change set"""
input CreateChangeSetInput {
  """Optional description"""
  description: String
  """Human-readable name"""
  name: String!
  """Router to apply changes to"""
  routerId: ID!
  """Source wizard/feature"""
  source: String
}

type CreateChangeSetPayload {
  """The created change set"""
  changeSet: ChangeSet
  """Errors that occurred"""
  errors: [MutationError!]
}

"""Input for creating a NAT rule."""
input CreateNatRuleInput {
  """NAT action"""
  action: NatAction!
  """NAT chain (srcnat or dstnat)"""
  chain: NatChain!
  """Optional comment"""
  comment: String @validate(maxLength: 255)
  """Whether rule is disabled"""
  disabled: Boolean
  """Destination address or CIDR"""
  dstAddress: String
  """Destination port (1-65535)"""
  dstPort: String
  """Incoming interface"""
  inInterface: String
  """Outgoing interface"""
  outInterface: String
  """Protocol (TCP, UDP)"""
  protocol: TransportProtocol
  """Source address or CIDR"""
  srcAddress: String
  """Source port or port range"""
  srcPort: String
  """Target address for NAT"""
  toAddresses: String
  """Target port(s) for NAT"""
  toPorts: String
}

"""Input for creating a new notification channel configuration"""
input CreateNotificationChannelConfigInput {
  """Type of notification channel"""
  channelType: ChannelType!
  """
  Full configuration including sensitive fields
  For Pushover: {"userKey": "...", "apiToken": "...", "device": "...", "baseURL": "..."}
  For Email: {"host": "...", "port": 587, "from": "...", "username": "...", "password": "...", "tlsMode": "..."}
  """
  config: JSON!
  """Optional description"""
  description: String
  """Whether this should be the default configuration"""
  isDefault: Boolean
  """Human-readable name"""
  name: String!
}

"""Input for creating a new port mirror configuration"""
input CreatePortMirrorInput {
  """User comment"""
  comment: String @validate(maxLength: 255)
  """Destination interface ID for mirrored traffic"""
  destinationInterfaceId: ID!
  """Direction of traffic to mirror (default: BOTH)"""
  direction: MirrorDirection
  """Descriptive name for the mirror configuration"""
  name: String! @validate(minLength: 1, maxLength: 100, pattern: "^[a-zA-Z0-9_-]+$")
  """Source interface IDs to mirror (must be bridge members)"""
  sourceInterfaceIds: [ID!]! @validate(minLength: 1)
}

"""Input for creating a new resource"""
input CreateResourceInput {
  """Resource category"""
  category: ResourceCategory!
  """Initial configuration"""
  configuration: JSON!
  """Resource description"""
  description: String
  """User-defined relationships"""
  relationships: ResourceRelationshipsInput
  """Router to create resource on"""
  routerId: ID!
  """Initial tags"""
  tags: [String!]
  """Resource type (e.g., 'vpn.wireguard.client')"""
  type: String!
}

type CreateResourcePayload {
  """Errors that occurred"""
  errors: [MutationError!]
  """The created resource"""
  resource: Resource
}

"""Input for creating a new router connection"""
input CreateRouterInput {
  """Router hostname or IP address"""
  host: String! @validate(minLength: 1, maxLength: 255)
  """User-friendly display name"""
  name: String! @validate(minLength: 1, maxLength: 64)
  """Password for authentication"""
  password: String! @validate(minLength: 1, maxLength: 128)
  """Router platform type"""
  platform: RouterPlatform
  """Connection port (default: 8728 for MikroTik API)"""
  port: Int @validate(min: 1, max: 65535)
  """Username for authentication"""
  username: String! @validate(minLength: 1, maxLength: 64)
}

type CreateRouterPayload {
  """Errors that occurred during creation"""
  errors: [MutationError!]
  """The created router"""
  router: Router
}

"""Input for creating or updating a multi-hop routing chain."""
input CreateRoutingChainInput {
  """Target device identifier"""
  deviceId: ID!
  """Device IP address (required if routing_mode=IP)"""
  deviceIp: String
  """Device MAC address (required if routing_mode=MAC)"""
  deviceMac: String
  """Human-readable device name"""
  deviceName: String
  """Ordered list of hops (2-5 hops required)"""
  hops: [ChainHopInput!]!
  """Whether to enable kill switch"""
  killSwitchEnabled: Boolean
  """Kill switch behavior mode"""
  killSwitchMode: KillSwitchMode
  """Routing mode (MAC or IP matching)"""
  routingMode: RoutingMode!
}

"""Input for creating a new routing schedule."""
input CreateScheduleInput {
  """Days of week (0=Sunday, 6=Saturday)"""
  days: [Int!]!
  """Whether schedule is enabled (default: true)"""
  enabled: Boolean
  """End time in HH:MM format (24-hour)"""
  endTime: String! @validate(pattern: "^([0-1][0-9]|2[0-3]):[0-5][0-9]$")
  """Device routing ID to schedule"""
  routingID: ID!
  """Start time in HH:MM format (24-hour)"""
  startTime: String! @validate(pattern: "^([0-1][0-9]|2[0-3]):[0-5][0-9]$")
  """IANA timezone identifier"""
  timezone: String! @validate(minLength: 1, maxLength: 64)
}

"""Input for creating a webhook"""
input CreateWebhookInput {
  """Authentication type (default: NONE)"""
  authType: WebhookAuthType = NONE
  """Bearer token for Bearer auth"""
  bearerToken: String
  """Custom template body (required if template is CUSTOM)"""
  customTemplate: String
  """Optional description"""
  description: String
  """Whether webhook is enabled (default: true)"""
  enabled: Boolean = true
  """Custom HTTP headers (as JSON object)"""
  headers: JSON
  """Maximum retry attempts (default: 3)"""
  maxRetries: Int = 3
  """HTTP method (default: POST)"""
  method: String = "POST"
  """Human-readable webhook name"""
  name: String!
  """Password for Basic auth"""
  password: String
  """Whether to retry failed deliveries (default: true)"""
  retryEnabled: Boolean = true
  """Signing secret for HMAC signature (optional)"""
  signingSecret: String
  """Template type for webhook payload (default: GENERIC)"""
  template: WebhookTemplate = GENERIC
  """Timeout in seconds (default: 10)"""
  timeoutSeconds: Int = 10
  """Webhook URL endpoint"""
  url: String!
  """Username for Basic auth"""
  username: String
}

"""Error codes specific to credential operations."""
enum CredentialErrorCode {
  """Authentication failed with new credentials"""
  AUTH_FAILED
  """Connection was refused"""
  CONNECTION_REFUSED
  """Credentials not found for router"""
  CREDENTIALS_NOT_FOUND
  """Decryption failed (key may have rotated)"""
  DECRYPTION_FAILED
  """Encryption failed"""
  ENCRYPTION_FAILED
  """Invalid input provided"""
  INVALID_INPUT
  """Router not found"""
  ROUTER_NOT_FOUND
  """Connection timed out when testing credentials"""
  TIMEOUT
}

"""Result of testing a single router's credentials."""
type CredentialTestResult {
  """Error message if test failed"""
  error: String
  """Response time in milliseconds (if successful)"""
  responseTimeMs: Int
  """Router ID that was tested"""
  routerId: ID!
  """Router name for display"""
  routerName: String!
  """Connection status"""
  status: CredentialTestStatus!
  """Whether the test was successful"""
  success: Boolean!
}

"""Status of a credential test."""
enum CredentialTestStatus {
  """Authentication failed"""
  AUTH_FAILED
  """Connection was refused"""
  CONNECTION_REFUSED
  """Unknown error occurred"""
  ERROR
  """Network unreachable"""
  NETWORK_ERROR
  """No credentials stored for this router"""
  NO_CREDENTIALS
  """Credentials are valid and connection succeeded"""
  SUCCESS
  """Connection timed out"""
  TIMEOUT
}

"""Result of updating router credentials."""
type CredentialUpdatePayload {
  """Updated credential info (without password)"""
  credentials: RouterCredentials
  """Error code if update failed"""
  errorCode: CredentialErrorCode
  """Errors that occurred during update"""
  errors: [MutationError!]
  """Human-readable message about the operation"""
  message: String!
  """Whether the update was successful"""
  success: Boolean!
}

"""
Input for updating router credentials.
Both username and password must be provided.
"""
input CredentialsInput {
  """Password for router authentication"""
  password: String! @validate(minLength: 1, maxLength: 128) @sensitive
  """Username for router authentication"""
  username: String! @validate(minLength: 1, maxLength: 64) @sensitive
}

"""Current item information in progress event"""
type CurrentItemInfo {
  id: ID!
  name: String!
  operation: ChangeOperation!
  status: ChangeSetItemStatus!
}

"""DHCP Server resource"""
type DHCPServerResource implements Node & Resource {
  """Number of active leases"""
  activeLeases: Int
  """Address pool name"""
  addressPool: String!
  category: ResourceCategory!
  configuration: JSON!
  deployment: DeploymentState
  id: ID!
  """Interface serving DHCP"""
  interface: String!
  """Lease time"""
  leaseTime: Duration!
  metadata: ResourceMetadata!
  """Server name"""
  name: String!
  platform: PlatformInfo
  relationships: ResourceRelationships
  runtime: RuntimeState
  scopedId: String!
  telemetry: TelemetryData
  type: String!
  validation: ValidationResult
}

"""Daily statistics"""
type DailyStats {
  """Date (UTC)"""
  date: DateTime!
  """Error count"""
  errorCount: Int!
  """Peak throughput in (bytes/sec)"""
  peakThroughputIn: Size!
  """Peak throughput out (bytes/sec)"""
  peakThroughputOut: Size!
  """Total bytes in"""
  totalBytesIn: Size!
  """Total bytes out"""
  totalBytesOut: Size!
  """Uptime percentage (0-100)"""
  uptimePercent: Float!
}

"""ISO 8601 datetime string (e.g., "2024-01-15T10:30:00Z")"""
scalar DateTime

type DeleteChangeSetPayload {
  """Errors that occurred"""
  errors: [MutationError!]
  """Whether deletion was successful"""
  success: Boolean!
}

"""Input for deleting a service instance."""
input DeleteInstanceInput {
  """Instance ID to delete"""
  instanceID: ID!
  """Router ID"""
  routerID: ID!
}

"""Delete operation payload"""
type DeletePayload {
  """ID of deleted item"""
  deletedId: ID
  """Errors encountered during deletion"""
  errors: [MutationError!]
  """Whether deletion was successful"""
  success: Boolean!
}

type DeleteResourcePayload {
  """ID of deleted resource"""
  deletedId: ID
  """Errors that occurred"""
  errors: [MutationError!]
  """Whether deletion was successful"""
  success: Boolean!
}

"""Result of a delete operation"""
type DeleteResult {
  """Errors that occurred during deletion"""
  errors: [MutationError!]
  """Success or error message"""
  message: String
  """Whether the deletion succeeded"""
  success: Boolean!
}

type DeleteRouterPayload {
  """ID of the deleted router"""
  deletedRouterId: ID
  """Errors that occurred during deletion"""
  errors: [MutationError!]
  """Whether deletion was successful"""
  success: Boolean!
}

"""
DependencyGraph represents the full dependency graph for visualization.
"""
type DependencyGraph {
  edges: [DependencyGraphEdge!]!
  nodes: [DependencyGraphNode!]!
}

"""
DependencyGraphEdge represents a dependency relationship edge in the graph.
"""
type DependencyGraphEdge {
  autoStart: Boolean!
  dependencyType: DependencyType!
  fromInstanceId: ID!
  healthTimeoutSeconds: Int!
  toInstanceId: ID!
}

"""DependencyGraphNode represents a service instance node in the graph."""
type DependencyGraphNode {
  featureId: String!
  instanceId: ID!
  instanceName: String!
  status: String!
}

"""Status of a required dependency"""
type DependencyStatus {
  """Whether the dependency is active"""
  isActive: Boolean!
  """Why this dependency is required"""
  reason: String!
  """Dependency resource type"""
  resourceType: String!
  """Dependency resource UUID"""
  resourceUuid: ID!
  """Current state of the dependency"""
  state: ResourceLifecycleState!
}

"""DependencyType defines the strength of the dependency relationship."""
enum DependencyType {
  """
  OPTIONAL: Soft dependency - dependent can start even if this dependency is unavailable
  """
  OPTIONAL
  """
  REQUIRES: Hard dependency - dependent cannot start without this dependency
  """
  REQUIRES
}

"""
Layer 3: What's actually on router after Apply-Confirm.
Includes router-generated fields like IDs and computed values.
"""
type DeploymentState {
  """When the resource was applied"""
  appliedAt: DateTime!
  """User who applied the resource"""
  appliedBy: String
  """Apply operation ID for audit trail"""
  applyOperationId: ID
  """Detected drift from configuration"""
  drift: DriftInfo
  """Router-generated fields (public key, computed values, etc.)"""
  generatedFields: JSON
  """Whether deployment matches configuration (no drift)"""
  isInSync: Boolean!
  """Router-generated resource ID (e.g., '*1A' in MikroTik)"""
  routerResourceId: String
  """Version number on router"""
  routerVersion: Int
}

type DeprecateResourcePayload {
  """Errors that occurred"""
  errors: [MutationError!]
  """The deprecated resource"""
  resource: Resource
}

"""Device (router) for querying resource metrics"""
type Device {
  """Device identifier"""
  id: ID!
  """Current resource utilization metrics"""
  resourceMetrics: ResourceMetrics!
}

"""
Device routing assignment.
Maps a client device to a service instance via Policy-Based Routing (PBR).
"""
type DeviceRouting {
  """Whether the assignment is active"""
  active: Boolean!
  """When the assignment was created"""
  createdAt: DateTime!
  """Device identifier"""
  deviceID: String!
  """Device IP address (optional)"""
  deviceIP: String
  """Device hostname (optional)"""
  deviceName: String
  """Whether this routing has any active schedules"""
  hasSchedules: Boolean!
  """Routing assignment ID (ULID)"""
  id: ID!
  """Service instance ID"""
  instanceID: ID!
  """Virtual interface ID"""
  interfaceID: ID!
  """Timestamp when kill switch was last activated"""
  killSwitchActivatedAt: DateTime
  """Whether kill switch is currently blocking traffic"""
  killSwitchActive: Boolean!
  """Whether kill switch is enabled for this routing"""
  killSwitchEnabled: Boolean!
  """Fallback interface ID when kill_switch_mode=FALLBACK_SERVICE"""
  killSwitchFallbackInterfaceID: String
  """Kill switch behavior mode"""
  killSwitchMode: KillSwitchMode!
  """RouterOS filter rule ID for kill switch (for O(1) cleanup)"""
  killSwitchRuleID: String
  """Device MAC address"""
  macAddress: String!
  """RouterOS mangle rule ID (for O(1) removal)"""
  mangleRuleID: String!
  """Routing mark"""
  routingMark: String!
  """Routing mode (MAC-based or IP-based)"""
  routingMode: RoutingMode!
  """All schedules for this device routing"""
  schedules: [RoutingSchedule!]!
  """Last update timestamp"""
  updatedAt: DateTime!
}

"""Device routing change event for subscriptions."""
type DeviceRoutingEvent {
  """
  Event type (assigned, removed, updated, kill_switch_activated, kill_switch_deactivated)
  """
  eventType: String!
  """Event ID"""
  id: ID!
  """Router ID"""
  routerID: ID!
  """Device routing (null if removed)"""
  routing: DeviceRouting
  """Timestamp"""
  timestamp: DateTime!
}

"""
Complete device routing matrix.
Provides all data needed for the device-to-service routing UI.
"""
type DeviceRoutingMatrix {
  """Discovered network devices"""
  devices: [NetworkDevice!]!
  """Active virtual interfaces available for routing"""
  interfaces: [VirtualInterfaceInfo!]!
  """Current routing assignments"""
  routings: [DeviceRouting!]!
  """Summary statistics"""
  summary: DeviceRoutingMatrixStats!
}

"""Summary statistics for device routing matrix."""
type DeviceRoutingMatrixStats {
  """Active virtual interfaces"""
  activeInterfaces: Int!
  """Active routing assignments"""
  activeRoutings: Int!
  """Devices discovered via ARP only"""
  arpOnlyDevices: Int!
  """Devices discovered via DHCP"""
  dhcpDevices: Int!
  """Devices with routing assignments"""
  routedDevices: Int!
  """Total discovered devices"""
  totalDevices: Int!
  """Devices without routing assignments"""
  unroutedDevices: Int!
}

"""
Per-device traffic breakdown for a service instance.
Shows which devices are consuming bandwidth through this service.
"""
type DeviceTrafficBreakdown {
  """Device identifier (MAC or IP)"""
  deviceID: String!
  """Device hostname (if available)"""
  deviceName: String
  """Bytes downloaded by this device"""
  downloadBytes: Int!
  """Device IP address"""
  ipAddress: String
  """Device MAC address"""
  macAddress: String
  """Percentage of total service traffic"""
  percentOfTotal: Float!
  """Total bytes (upload + download)"""
  totalBytes: Int!
  """Bytes uploaded by this device"""
  uploadBytes: Int!
}

"""DHCP client configuration for dynamic WAN IP"""
type DhcpClient implements Node {
  """Add default route from DHCP"""
  addDefaultRoute: Boolean! @mikrotik(path: "/ip/dhcp-client", field: "add-default-route")
  """Assigned IP address"""
  address: IPv4 @mikrotik(path: "/ip/dhcp-client", field: "address")
  """User comment"""
  comment: String @mikrotik(path: "/ip/dhcp-client", field: "comment")
  """DHCP server address"""
  dhcpServer: IPv4 @mikrotik(path: "/ip/dhcp-client", field: "dhcp-server")
  """Whether DHCP client is disabled"""
  disabled: Boolean! @mikrotik(path: "/ip/dhcp-client", field: "disabled")
  """Lease expiry time"""
  expiresAfter: Duration @mikrotik(path: "/ip/dhcp-client", field: "expires-after")
  """Gateway from DHCP"""
  gateway: IPv4 @mikrotik(path: "/ip/dhcp-client", field: "gateway")
  """Unique identifier"""
  id: ID!
  """Interface name"""
  interface: String! @mikrotik(path: "/ip/dhcp-client", field: "interface")
  """Current DHCP status"""
  status: String! @mikrotik(path: "/ip/dhcp-client", field: "status")
  """Use DNS servers from DHCP"""
  usePeerDNS: Boolean! @mikrotik(path: "/ip/dhcp-client", field: "use-peer-dns")
  """Use NTP servers from DHCP"""
  usePeerNTP: Boolean! @mikrotik(path: "/ip/dhcp-client", field: "use-peer-ntp")
}

"""Input for creating/updating DHCP client"""
input DhcpClientInput {
  """Add default route (default: true)"""
  addDefaultRoute: Boolean
  """User comment"""
  comment: String @validate(maxLength: 255)
  """Interface to enable DHCP client on"""
  interface: String! @validate(minLength: 1, maxLength: 100)
  """Use peer DNS (default: true)"""
  usePeerDNS: Boolean
  """Use peer NTP (default: true)"""
  usePeerNTP: Boolean
}

"""DHCP server (minimal type for dependencies)"""
type DhcpServer {
  """Whether the DHCP server is disabled"""
  disabled: Boolean!
  """DHCP server ID"""
  id: ID!
  """Interface the DHCP server is bound to"""
  interface: Interface!
  """DHCP server name"""
  name: String!
}

"""Comprehensive diagnostic report for a router"""
type DiagnosticReport {
  """Authentication test status"""
  authStatus: AuthStatus!
  """Whether the router is reachable on the network"""
  networkReachable: Boolean!
  """Status of each checked port"""
  portStatus: [PortStatus!]!
  """Raw text report for clipboard/export"""
  rawReport: String!
  """Router ID being diagnosed"""
  routerId: ID!
  """Actionable suggestions based on diagnostic results"""
  suggestions: [DiagnosticSuggestion!]!
  """When the diagnostic was run"""
  timestamp: DateTime!
  """TLS certificate status (if TLS ports were checked)"""
  tlsStatus: TLSStatus
}

"""
Result of a single diagnostic test.
Represents the outcome of a health check or connectivity test.
"""
type DiagnosticResult implements Node {
  """Timestamp when test was executed"""
  createdAt: DateTime!
  """Detailed information about the test result"""
  details: String
  """Test execution duration in milliseconds"""
  durationMs: Int!
  """Error message if test failed"""
  errorMessage: String
  """Result ID (ULID)"""
  id: ID!
  """Instance ID this diagnostic belongs to"""
  instanceID: ID!
  """Short message describing the result"""
  message: String!
  """Additional test-specific metadata (JSON)"""
  metadata: JSON
  """ULID for grouping tests run together"""
  runGroupID: String
  """Test result status"""
  status: DiagnosticStatus!
  """Test name (e.g., 'tor_socks5', 'process_health')"""
  testName: String!
}

"""Diagnostic test status."""
enum DiagnosticStatus {
  """Test failed"""
  FAIL
  """Test passed successfully"""
  PASS
  """Test was skipped"""
  SKIPPED
  """Test completed with warnings"""
  WARNING
}

"""Actionable diagnostic suggestion"""
type DiagnosticSuggestion {
  """Recommended action to resolve the issue"""
  action: String!
  """Detailed description of the issue"""
  description: String!
  """Link to relevant documentation"""
  docsUrl: String
  """Severity level of the issue"""
  severity: SuggestionSeverity!
  """Short title describing the issue"""
  title: String!
}

"""
Complete diagnostic suite for a service type.
Defines all available tests for a service.
"""
type DiagnosticSuite {
  """Service name (e.g., 'tor', 'singbox', 'adguard')"""
  serviceName: String!
  """Available diagnostic tests"""
  tests: [DiagnosticTest!]!
}

"""
A single diagnostic test definition.
Describes a test that can be run against a service.
"""
type DiagnosticTest {
  """Test category (health, connectivity, dns, http, socks5)"""
  category: String!
  """Human-readable description"""
  description: String!
  """Unique test identifier"""
  name: String!
}

"""
Real-time diagnostic progress event for subscriptions.
Emitted as each test completes during a diagnostic run.
"""
type DiagnosticsProgress {
  """Completed tests count"""
  completedTests: Int!
  """Instance ID"""
  instanceID: ID!
  """Progress (0-100)"""
  progress: Int!
  """Test result that just completed"""
  result: DiagnosticResult!
  """Run group ID"""
  runGroupID: String!
  """Timestamp"""
  timestamp: DateTime!
  """Total tests count"""
  totalTests: Int!
}

"""Email digest configuration (NAS-18.11)"""
type DigestConfig {
  """Whether critical alerts bypass digest mode and send immediately"""
  bypassCritical: Boolean!
  """Whether digest mode is enabled"""
  enabled: Boolean!
  """Digest interval in minutes (e.g., 60 for hourly, 1440 for daily)"""
  intervalMinutes: Int!
  """Whether to send digest even when no alerts occurred during the period"""
  sendEmptyDigest: Boolean!
  """
  Time of day for daily delivery in HH:MM format (optional, for daily digests)
  """
  time: String
}

"""Email digest configuration input (NAS-18.11)"""
input DigestConfigInput {
  """
  Whether critical alerts bypass digest mode and send immediately (default: true)
  """
  bypassCritical: Boolean = true
  """Whether digest mode is enabled"""
  enabled: Boolean!
  """Digest interval in minutes (e.g., 60 for hourly, 1440 for daily)"""
  intervalMinutes: Int!
  """
  Whether to send digest even when no alerts occurred during the period (default: false)
  """
  sendEmptyDigest: Boolean = false
  """
  Time of day for daily delivery in HH:MM format (optional, for daily digests)
  """
  time: String
}

"""Digest summary (NAS-18.11)"""
type DigestSummary {
  """Number of alerts included in the digest"""
  alertCount: Int!
  """Channel ID this digest was sent to"""
  channelId: String!
  """When the digest was delivered"""
  deliveredAt: DateTime!
  """Globally unique identifier"""
  id: ID!
  """Time period covered by the digest (e.g., "Last hour", "Last 24 hours")"""
  period: String!
}

"""Reason for router disconnection"""
enum DisconnectReason {
  """Authentication failed"""
  AUTH_FAILURE
  """Circuit breaker is open"""
  CIRCUIT_OPEN
  """User manually disconnected"""
  MANUAL
  """Network failure"""
  NETWORK_FAILURE
  """Application shutting down"""
  SHUTDOWN
  """Connection timed out"""
  TIMEOUT
  """Unknown reason"""
  UNKNOWN
}

type DisconnectRouterPayload {
  """Errors that occurred during disconnection"""
  errors: [MutationError!]
  """The router that was disconnected"""
  router: Router
}

"""
A device discovered during a network scan.
Only confirmed MikroTik devices are returned (confidence >= 40).
"""
type DiscoveredDevice {
  """Confidence score for RouterOS detection (40-100)"""
  confidence: Int!
  """Device type classification"""
  deviceType: String!
  """Hostname (if reverse DNS resolves)"""
  hostname: String
  """IP address of the discovered device"""
  ip: String!
  """Open ports found on the device"""
  ports: [Int!]!
  """RouterOS-specific information (version, board, architecture)"""
  routerOSInfo: RouterOSInfo
  """Detected services (mikrotik-api, mikrotik-winbox, mikrotik-rest, etc.)"""
  services: [String!]!
  """Device vendor (always 'MikroTik' for returned results)"""
  vendor: String
}

"""Complete benchmark result comparing all configured DNS servers"""
type DnsBenchmarkResult {
  """Fastest server"""
  fastestServer: DnsBenchmarkServerResult
  """Results for each tested server, sorted by response time"""
  serverResults: [DnsBenchmarkServerResult!]!
  """Test hostname used for benchmarking"""
  testHostname: String!
  """When the benchmark was executed"""
  timestamp: DateTime!
  """Total benchmark execution time in milliseconds"""
  totalTimeMs: Int!
}

"""Benchmark result for a single DNS server"""
type DnsBenchmarkServerResult {
  """Error message (if server failed)"""
  error: String
  """Response time in milliseconds (-1 if unreachable)"""
  responseTimeMs: Int!
  """DNS server IP address"""
  server: String!
  """Server status (Fastest, Good, Slow, Unreachable)"""
  status: DnsServerStatus!
  """Whether the server responded successfully"""
  success: Boolean!
}

"""DNS cache statistics for monitoring cache usage"""
type DnsCacheStats {
  """Maximum cache size in bytes"""
  cacheMaxBytes: Size!
  """Cache usage percentage (0-100)"""
  cacheUsagePercent: Float!
  """Cache size used in bytes"""
  cacheUsedBytes: Size!
  """Cache hit rate percentage (0-100)"""
  hitRatePercent: Float
  """When the statistics were collected"""
  timestamp: DateTime!
  """Most queried domains (top 10)"""
  topDomains: [DnsTopDomain!]!
  """Total number of entries in the DNS cache"""
  totalEntries: Int!
}

"""Input for DNS lookup operation"""
input DnsLookupInput {
  """Device/router ID to run lookup from"""
  deviceId: String!
  """Hostname or IP address to look up"""
  hostname: String!
  """DNS record type to query"""
  recordType: DnsRecordType!
  """DNS server to use (defaults to router's configured DNS)"""
  server: String
  """Query timeout in seconds (default: 5)"""
  timeout: Int
}

"""Result of a DNS lookup operation"""
type DnsLookupResult {
  """Whether response was authoritative"""
  authoritative: Boolean!
  """Error message (if query failed)"""
  error: String
  """Hostname that was queried"""
  hostname: String!
  """Query time in milliseconds"""
  queryTime: Int!
  """Record type that was queried"""
  recordType: DnsRecordType!
  """Resolved records"""
  records: [DnsRecord!]!
  """DNS server used"""
  server: String!
  """Query status"""
  status: DnsLookupStatus!
  """When the query was executed"""
  timestamp: DateTime!
}

"""DNS lookup status codes"""
enum DnsLookupStatus {
  """Network error occurred"""
  NETWORK_ERROR
  """Domain does not exist (NXDOMAIN)"""
  NXDOMAIN
  """Query refused by server"""
  REFUSED
  """DNS server failure (SERVFAIL)"""
  SERVFAIL
  """Query completed successfully"""
  SUCCESS
  """Query timed out"""
  TIMEOUT
}

"""Single DNS record"""
type DnsRecord {
  """Record data (IP, hostname, text, etc.)"""
  data: String!
  """Record name (query hostname)"""
  name: String!
  """Port (for SRV records)"""
  port: Int
  """Priority (for MX/SRV records)"""
  priority: Int
  """Time to live in seconds"""
  ttl: Int!
  """Record type"""
  type: DnsRecordType!
  """Weight (for SRV records)"""
  weight: Int
}

"""DNS record types supported"""
enum DnsRecordType {
  """IPv4 address record"""
  A
  """IPv6 address record"""
  AAAA
  """Canonical name record"""
  CNAME
  """Mail exchange record"""
  MX
  """Name server record"""
  NS
  """Pointer record (reverse DNS)"""
  PTR
  """Start of authority record"""
  SOA
  """Service record"""
  SRV
  """Text record"""
  TXT
}

"""DNS server configuration"""
type DnsServer {
  """Server IP address"""
  address: String!
  """Whether this is the primary DNS server"""
  isPrimary: Boolean!
  """Whether this is the secondary DNS server"""
  isSecondary: Boolean!
}

"""Status classification for DNS servers in benchmark"""
enum DnsServerStatus {
  """Fastest responding server"""
  FASTEST
  """Server responded in acceptable time (<100ms)"""
  GOOD
  """Server responded slowly (>100ms)"""
  SLOW
  """Server did not respond"""
  UNREACHABLE
}

"""Collection of DNS servers"""
type DnsServers {
  """Primary DNS server address"""
  primary: String!
  """Secondary DNS server address (if configured)"""
  secondary: String
  """All configured DNS servers"""
  servers: [DnsServer!]!
}

"""A frequently queried domain in the DNS cache"""
type DnsTopDomain {
  """Domain name"""
  domain: String!
  """Last query time"""
  lastQueried: DateTime
  """Number of queries for this domain"""
  queryCount: Int!
}

"""Actions to resolve drift"""
enum DriftAction {
  """Update configuration to match router"""
  ACCEPT
  """Re-apply configuration to router"""
  REAPPLY
  """Manual review required"""
  REVIEW
}

"""A field that has drifted from configuration"""
type DriftField {
  """Actual value (from router)"""
  actual: JSON
  """Expected value (from configuration)"""
  expected: JSON
  """Field path"""
  path: String!
}

"""Information about configuration drift"""
type DriftInfo {
  """When drift was detected"""
  detectedAt: DateTime!
  """Fields that have drifted"""
  driftedFields: [DriftField!]!
  """Suggested action to resolve drift"""
  suggestedAction: DriftAction!
}

"""Duration string in RouterOS format (e.g., "1d2h3m4s", "30s", "5m")"""
scalar Duration

"""Edge interface for connection edges"""
interface Edge {
  """Cursor for pagination"""
  cursor: String!
}

"""Email notification configuration"""
type EmailConfig {
  """Whether email notifications are enabled"""
  enabled: Boolean!
  """Email sender address"""
  fromAddress: String
  """Email sender display name"""
  fromName: String
  """SMTP server hostname"""
  host: String
  """SMTP server port"""
  port: Int
  """Skip TLS certificate verification (use with caution)"""
  skipVerify: Boolean
  """Array of recipient email addresses"""
  toAddresses: [String!]!
  """Whether to use TLS/SSL"""
  useTLS: Boolean
  """SMTP username for authentication"""
  username: String
}

"""Email notification configuration input"""
input EmailConfigInput {
  """Whether email notifications are enabled"""
  enabled: Boolean!
  """Email sender address"""
  fromAddress: String
  """Email sender display name"""
  fromName: String
  """SMTP server hostname"""
  host: String
  """SMTP password for authentication"""
  password: String
  """SMTP server port"""
  port: Int
  """Skip TLS certificate verification (use with caution)"""
  skipVerify: Boolean
  """Array of recipient email addresses"""
  toAddresses: [String!]!
  """Whether to use TLS/SSL"""
  useTLS: Boolean
  """SMTP username for authentication"""
  username: String
}

"""Category of connection error for classification"""
enum ErrorCategory {
  """Authentication failed"""
  AUTH_FAILED
  """Network unreachable or DNS failure"""
  NETWORK_ERROR
  """Protocol-level error"""
  PROTOCOL_ERROR
  """Connection actively refused"""
  REFUSED
  """Connection or response timeout"""
  TIMEOUT
  """TLS/SSL certificate or handshake error"""
  TLS_ERROR
}

"""
Rich error extensions for detailed error diagnostics.
Included in GraphQL error responses under the 'extensions' key.
"""
type ErrorExtensions {
  """
  Error category (validation, protocol, network, auth, resource, internal)
  """
  category: String!
  """Error code for programmatic handling (e.g., 'V400', 'R200')"""
  code: String!
  """Link to relevant documentation"""
  docsUrl: String
  """Field path that caused the error (e.g., 'input.listenPort')"""
  field: String
  """Whether the error is recoverable (can be retried)"""
  recoverable: Boolean!
  """Request correlation ID for support and debugging"""
  requestId: String!
  """User-friendly suggestion for fixing the error"""
  suggestedFix: String
  """Additional troubleshooting steps for complex errors"""
  troubleshootingSteps: [String!]
  """The invalid value (redacted in production for sensitive fields)"""
  value: JSON
}

"""Escalation configuration for unacknowledged alerts (NAS-18.9)"""
type EscalationConfig {
  """Additional notification channels to add during escalation"""
  additionalChannels: [String!]!
  """Whether escalation is enabled"""
  enabled: Boolean!
  """Delay in seconds before first escalation"""
  escalationDelay: Int!
  """Maximum number of escalation levels"""
  maxEscalations: Int!
  """Per-level delay intervals in seconds"""
  repeatIntervals: [Int!]!
  """Whether alert must be acknowledged to stop escalation"""
  requireAck: Boolean!
}

"""Escalation configuration input (NAS-18.9)"""
input EscalationConfigInput {
  """Additional notification channels to add during escalation"""
  additionalChannels: [String!] = []
  """Whether escalation is enabled (default: false)"""
  enabled: Boolean = false
  """Delay in seconds before first escalation (default: 900 = 15min)"""
  escalationDelay: Int = 900
  """Maximum number of escalation levels (default: 3)"""
  maxEscalations: Int = 3
  """Per-level delay intervals in seconds (default: [900, 1800, 3600])"""
  repeatIntervals: [Int!] = []
  """Whether alert must be acknowledged to stop escalation (default: true)"""
  requireAck: Boolean = true
}

"""Escalation status (NAS-18.9)"""
enum EscalationStatus {
  """Maximum escalation level reached"""
  MAX_REACHED
  """Escalation is pending/in progress"""
  PENDING
  """Escalation was resolved (alert acknowledged)"""
  RESOLVED
}

"""Input for exporting services as a template"""
input ExportAsTemplateInput {
  """Template category"""
  category: ServiceTemplateCategory!
  """Template description"""
  description: String!
  """Instance IDs to export"""
  instanceIDs: [ID!]!
  """Template name"""
  name: String!
  """Router ID"""
  routerID: ID!
  """Template scope"""
  scope: TemplateScope!
}

"""Options for exporting router configuration."""
input ExportConfigInput {
  """
  User-provided encryption key for credential export (required if includeCredentials is true)
  """
  encryptionKey: String @sensitive
  """Whether to include credentials (requires encryptionKey if true)"""
  includeCredentials: Boolean
  """Router ID to export configuration from"""
  routerId: ID!
}

"""Result of exporting router configuration."""
type ExportConfigPayload {
  """Exported configuration data (JSON format)"""
  config: JSON
  """Errors that occurred during export"""
  errors: [MutationError!]
  """Security warning message about credential handling"""
  securityWarning: String
  """Whether the export was successful"""
  success: Boolean!
}

"""Input for exporting a service configuration."""
input ExportServiceConfigInput {
  """Whether to include device routing rules"""
  includeRoutingRules: Boolean!
  """Instance ID to export"""
  instanceID: ID!
  """Whether to redact sensitive fields (passwords, API keys, etc.)"""
  redactSecrets: Boolean!
  """Router ID"""
  routerID: ID!
}

"""Payload for export service configuration mutation."""
type ExportServiceConfigPayload {
  """Download URL for JSON file (15-minute expiry)"""
  downloadURL: String
  """Mutation errors"""
  errors: [MutationError!]
  """Exported service package (null if failed)"""
  package: ServiceExportPackage
  """Whether the operation succeeded"""
  success: Boolean!
}

"""Information about a feature in the compatibility matrix"""
type FeatureCompatibilityInfo {
  """Feature dependencies"""
  dependsOn: [String!]!
  """Feature identifier"""
  featureId: String!
  """Maximum RouterOS version supported (if any)"""
  maxVersion: String
  """Minimum RouterOS version required"""
  minVersion: String!
  """Minimum version for CHR (if different)"""
  minVersionCHR: String
  """Human-readable feature name"""
  name: String!
  """Required packages"""
  requiredPackages: [String!]!
  """URL to MikroTik documentation"""
  upgradeUrl: String
}

"""Input for checking feature compatibility"""
input FeatureCompatibilityInput {
  """Feature identifier to check"""
  featureId: String!
  """Whether to check for CHR-specific requirements"""
  isCHR: Boolean
}

"""Feature deployment state"""
type FeatureDeployment {
  appliedAt: DateTime!
  appliedBy: String
  """Assigned IP address"""
  assignedIP: IPv4
  """Assigned ports"""
  assignedPorts: [Port!]
  """Container ID (if containerized)"""
  containerId: String
  """Container image used"""
  containerImage: String
  drift: DriftInfo
  isInSync: Boolean!
  routerResourceId: String
  routerVersion: Int
}

"""Marketplace Feature resource (Tor, AdGuard, sing-box, etc.)"""
type FeatureResource implements Node & Resource {
  category: ResourceCategory!
  configuration: JSON
  deployment: DeploymentState
  featureDeployment: FeatureDeployment
  """Feature identifier"""
  featureId: String!
  featureRuntime: FeatureRuntime
  id: ID!
  metadata: ResourceMetadata!
  """Feature name"""
  name: String!
  platform: PlatformInfo
  relationships: ResourceRelationships
  runtime: RuntimeState
  scopedId: String!
  telemetry: TelemetryData
  type: String!
  validation: ValidationResult
  """Feature version"""
  version: String!
  """Virtual interface assigned"""
  virtualInterface: String
}

"""Feature runtime state"""
type FeatureRuntime {
  """Container status"""
  containerStatus: String
  """CPU usage percentage"""
  cpuUsagePercent: Float
  errorMessage: String
  health: RuntimeHealth!
  isRunning: Boolean!
  lastUpdated: DateTime!
  """Memory usage"""
  memoryUsage: Size
  """Devices routed through this feature"""
  routedDevices: Int
}

"""
Per-feature storage usage breakdown.
Shows how much space each feature is consuming and where data is stored.
"""
type FeatureStorageUsage {
  """Binary size in bytes (serialized uint64)"""
  binarySize: String!
  """Config files size in bytes (serialized uint64)"""
  configSize: String!
  """Runtime data size in bytes (serialized uint64)"""
  dataSize: String!
  """Feature identifier (e.g., 'tor', 'sing-box')"""
  featureId: ID!
  """Human-readable feature name"""
  featureName: String!
  """Number of instances of this feature"""
  instanceCount: Int!
  """Primary storage location ('flash' or 'external')"""
  location: String!
  """Log files size in bytes (serialized uint64)"""
  logsSize: String!
  """Total size across all components in bytes (serialized uint64)"""
  totalSize: String!
}

"""Feature support information based on RouterOS version"""
type FeatureSupport {
  """Feature identifier (e.g., 'rest_api', 'container', 'wireguard')"""
  featureId: String!
  """Capability level (none, basic, advanced, full)"""
  level: CapabilityLevel!
  """Missing packages (if any)"""
  missingPackages: [String!]
  """Human-readable feature name"""
  name: String!
  """Reason why the feature is not supported (if applicable)"""
  reason: String
  """Required packages that need to be installed"""
  requiredPackages: [String!]
  """Minimum RouterOS version required for this feature"""
  requiredVersion: String
  """Whether the feature is supported on this router"""
  supported: Boolean!
  """URL to MikroTik documentation for upgrade guidance"""
  upgradeUrl: String
}

"""
Firewall rule placeholder type.
TODO: Expand with full filter/NAT/mangle rule types in future stories.
"""
type FirewallRule implements Node {
  """Rule action (accept, drop, reject, etc.)"""
  action: String!
  """Rule chain (input, forward, output, prerouting, postrouting, etc.)"""
  chain: String!
  """Optional comment"""
  comment: String
  """Whether rule is disabled"""
  disabled: Boolean!
  """Destination address list reference"""
  dstAddressList: String
  """Rule ID"""
  id: ID!
  """Source address list reference"""
  srcAddressList: String
  """Rule type (filter, nat, mangle)"""
  type: String!
}

"""
Firewall rule reference type (lightweight for dependency tracking).
For full firewall rule management, see FirewallRule type in firewall.graphql.
"""
type FirewallRuleReference {
  """Rule action"""
  action: String!
  """Rule chain"""
  chain: String!
  """Whether the rule is disabled"""
  disabled: Boolean!
  """Firewall rule ID"""
  id: ID!
  """Input interface filter"""
  inInterface: String
  """Output interface filter"""
  outInterface: String
}

"""Firewall Rule resource"""
type FirewallRuleResource implements Node & Resource {
  """Rule action (accept, drop, reject)"""
  action: String!
  category: ResourceCategory!
  """Rule chain (input, forward, output)"""
  chain: String!
  """Rule comment"""
  comment: String
  configuration: JSON!
  deployment: DeploymentState
  """Destination address/network"""
  dstAddress: String
  """Destination port(s)"""
  dstPort: String
  """Whether rule is enabled"""
  enabled: Boolean!
  """Hit counter"""
  hitCount: Int
  id: ID!
  metadata: ResourceMetadata!
  platform: PlatformInfo
  """Protocol (tcp, udp, icmp, etc.)"""
  protocol: String
  relationships: ResourceRelationships
  runtime: RuntimeState
  scopedId: String!
  """Source address/network"""
  srcAddress: String
  """Source port(s)"""
  srcPort: String
  telemetry: TelemetryData
  type: String!
  validation: ValidationResult
}

"""Firewall table types."""
enum FirewallTable {
  """Packet filtering"""
  FILTER
  """Packet marking and modification"""
  MANGLE
  """Network address translation"""
  NAT
  """Raw packet processing"""
  RAW
}

"""
Firewall template with pre-configured rule sets.
Templates allow quick application of common firewall configurations.
"""
type FirewallTemplate {
  """Category for organization"""
  category: TemplateCategory!
  """Complexity level indicator"""
  complexity: TemplateComplexity!
  """When this template was created (null for built-in)"""
  createdAt: DateTime
  """Detailed description of what this template does"""
  description: String!
  """Unique template identifier"""
  id: ID!
  """Whether this is a built-in template"""
  isBuiltIn: Boolean!
  """Human-readable template name"""
  name: String!
  """Total number of rules in this template"""
  ruleCount: Int!
  """Rules that will be created"""
  rules: [TemplateRule!]!
  """When this template was last modified (null for built-in)"""
  updatedAt: DateTime
  """Variables that can be customized before applying"""
  variables: [FirewallTemplateVariable!]!
  """Template version for compatibility tracking"""
  version: String!
}

"""Result of template application."""
type FirewallTemplateResult {
  """Number of rules successfully applied"""
  appliedRulesCount: Int!
  """Errors encountered during application"""
  errors: [String!]
  """Rollback ID for undo (valid for 5 minutes)"""
  rollbackId: ID!
  """Whether application succeeded"""
  success: Boolean!
}

"""
Variable definition for template customization.
Variables allow parameterization of templates for different network configurations.
"""
type FirewallTemplateVariable {
  """Default value if not specified"""
  defaultValue: String
  """Description to help users understand the variable"""
  description: String
  """Human-readable label for UI"""
  label: String!
  """Variable name (used in rule properties)"""
  name: String!
  """Available options (populated from router for INTERFACE type)"""
  options: [String!]
  """Whether this variable is required"""
  required: Boolean!
  """Variable type for validation"""
  type: VariableType!
}

"""Input for defining a template variable."""
input FirewallTemplateVariableInput {
  """Default value"""
  defaultValue: String
  """Description"""
  description: String @validate(maxLength: 200)
  """Label for UI"""
  label: String! @validate(minLength: 1, maxLength: 100)
  """Variable name"""
  name: String! @validate(minLength: 1, maxLength: 50, pattern: "^[A-Z_]+$")
  """Whether required"""
  required: Boolean!
  """Variable type"""
  type: VariableType!
}

"""Status of a fix application"""
enum FixApplicationStatus {
  """Fix was applied successfully"""
  APPLIED
  """Fix is being applied"""
  APPLYING
  """Fix is available but not yet applied"""
  AVAILABLE
  """Fix application failed"""
  FAILED
  """Fix was applied but issue persists"""
  ISSUE_PERSISTS
}

"""Confidence level for a fix suggestion"""
enum FixConfidence {
  """High confidence this fix will resolve the issue"""
  HIGH
  """Low confidence, worth trying as last resort"""
  LOW
  """Medium confidence, may resolve the issue"""
  MEDIUM
}

"""Result of flushing the DNS cache"""
type FlushDnsCacheResult {
  """Cache statistics after flushing"""
  afterStats: DnsCacheStats!
  """Cache statistics before flushing"""
  beforeStats: DnsCacheStats!
  """Number of entries removed from the cache"""
  entriesRemoved: Int!
  """User-friendly message"""
  message: String!
  """Whether the cache was flushed successfully"""
  success: Boolean!
  """When the flush was executed"""
  timestamp: DateTime!
}

enum FrameTypes {
  ADMIT_ALL
  ADMIT_ONLY_UNTAGGED_AND_PRIORITY
  ADMIT_ONLY_VLAN_TAGGED
}

"""
Gateway monitoring information for SOCKS-to-TUN gateway instances.
Provides visibility into hev-socks5-tunnel processes.
"""
type GatewayInfo {
  """Error message if in ERROR state"""
  errorMessage: String
  """Last health check timestamp"""
  lastHealthCheck: DateTime
  """Process ID of gateway"""
  pid: Int
  """Current gateway state"""
  state: GatewayState!
  """TUN interface name (e.g., tun-tor-usa)"""
  tunName: String
  """Uptime duration in seconds"""
  uptime: Int
}

"""Result of checking gateway reachability"""
type GatewayReachabilityResult {
  """Interface through which gateway is reachable (null if unreachable)"""
  interface: String
  """Ping latency in milliseconds (null if unreachable)"""
  latency: Int
  """Human-readable message about reachability"""
  message: String!
  """Whether the gateway is reachable"""
  reachable: Boolean!
}

"""Gateway process state for monitoring"""
enum GatewayState {
  """Gateway encountered an error"""
  ERROR
  """Service does not need a gateway"""
  NOT_NEEDED
  """Gateway is running normally"""
  RUNNING
  """Gateway is stopped"""
  STOPPED
}

"""Gateway runtime status."""
enum GatewayStatus {
  """Gateway process failed to start"""
  FAILED
  """Gateway process is running"""
  RUNNING
  """Gateway process is starting"""
  STARTING
  """Gateway process is stopped"""
  STOPPED
}

"""Gateway type for virtual interface routing."""
enum GatewayType {
  """HEV SOCKS5 tunnel gateway"""
  HEV_SOCKS5_TUNNEL
  """No gateway, direct routing"""
  NONE
}

"""Input for generating a QR code for service config."""
input GenerateConfigQRInput {
  """QR code image size in pixels (default 256)"""
  imageSize: Int
  """Whether to include routing rules"""
  includeRoutingRules: Boolean!
  """Instance ID to generate QR code for"""
  instanceID: ID!
  """Whether to redact sensitive fields"""
  redactSecrets: Boolean!
  """Router ID"""
  routerID: ID!
}

"""Payload for generate config QR mutation."""
type GenerateConfigQRPayload {
  """QR code data size in bytes (before encoding)"""
  dataSize: Int
  """Download URL for PNG file (15-minute expiry)"""
  downloadURL: String
  """Mutation errors"""
  errors: [MutationError!]
  """Base64-encoded PNG image data"""
  imageDataBase64: String
  """PNG image size in bytes"""
  imageSize: Int
  """Whether the operation succeeded"""
  success: Boolean!
}

"""Hardware information detected from router"""
type HardwareInfo {
  """CPU architecture (arm, arm64, x86_64, etc.)"""
  architecture: String!
  """Available storage in bytes"""
  availableStorage: Size!
  """Board name"""
  boardName: String
  """Number of CPU cores"""
  cpuCount: Int!
  """Whether LTE/cellular hardware is present"""
  hasLTEModule: Boolean!
  """Whether wireless hardware is present"""
  hasWirelessChip: Boolean!
  """Router model name"""
  model: String
  """Total RAM in bytes"""
  totalMemory: Size!
}

"""Health check result for a router"""
type HealthCheckResult {
  """When the check was performed"""
  checkedAt: DateTime!
  """Error message if unhealthy"""
  error: String
  """Whether the router is healthy"""
  healthy: Boolean!
  """Response time in milliseconds"""
  responseTimeMs: Int
  """Router ID"""
  routerId: ID!
}

"""Health check status"""
enum HealthCheckStatus {
  """Health check is disabled"""
  DISABLED
  """Target is reachable (healthy)"""
  HEALTHY
  """Target is unreachable (unhealthy)"""
  UNHEALTHY
  """Health check is starting"""
  UNKNOWN
}

"""Connection status from health probe checks"""
enum HealthConnectionState {
  CONNECTED
  CONNECTING
  FAILED
}

"""Overall system health status"""
type HealthStatus {
  """Last health check timestamp"""
  checkedAt: DateTime!
  """Connected router count"""
  connectedRouters: Int!
  """Service status"""
  status: ServiceStatus!
  """Server uptime"""
  uptime: Duration
  """Service version"""
  version: String!
}

"""A single probe result within a hop"""
type HopProbe {
  """ICMP error code if probe failed"""
  icmpCode: String
  """Latency in milliseconds (null for timeout)"""
  latencyMs: Float
  """Probe number (1-3 typically)"""
  probeNumber: Int!
  """Whether the probe succeeded"""
  success: Boolean!
}

"""Status of a single hop in a traceroute"""
enum HopStatus {
  """Access prohibited (firewall/ACL)"""
  PROHIBITED
  """Hop responded successfully"""
  SUCCESS
  """Hop did not respond (timeout)"""
  TIMEOUT
  """Destination unreachable at this hop"""
  UNREACHABLE
}

"""Hourly statistics"""
type HourlyStats {
  """Error count"""
  errorCount: Int!
  """Hour start timestamp"""
  hour: DateTime!
  """Total bytes in"""
  totalBytesIn: Size!
  """Total bytes out"""
  totalBytesOut: Size!
  """Uptime percentage (0-100)"""
  uptimePercent: Float!
}

"""
IPv4 address string (e.g., "192.168.1.1")
Validated format: XXX.XXX.XXX.XXX where XXX is 0-255
"""
scalar IPv4

"""IPv6 address string (e.g., "2001:0db8:85a3:0000:0000:8a2e:0370:7334")"""
scalar IPv6

"""ISP contact information"""
type ISPInfo {
  """ISP name"""
  name: String!
  """ISP support phone number"""
  phone: String
  """ISP support website URL"""
  url: String
}

"""
Analysis of template application impact.
Provides estimates and warnings before applying.
"""
type ImpactAnalysis {
  """Chains that will be affected"""
  affectedChains: [String!]!
  """Estimated time to apply (seconds)"""
  estimatedApplyTime: Int!
  """Number of new rules that will be created"""
  newRulesCount: Int!
  """Warnings about potential issues"""
  warnings: [String!]!
}

"""
Input for importing a service configuration.
Performs validation only, does not apply changes.
"""
input ImportServiceConfigInput {
  """Conflict resolution strategy (required if conflicts exist)"""
  conflictResolution: ConflictResolution
  """Device MAC addresses to filter routing rules (optional)"""
  deviceFilter: [String!]
  """Dry-run mode (validate only, don't create instance)"""
  dryRun: Boolean
  """Service export package (JSON)"""
  package: JSON!
  """User-provided values for redacted fields (map of field name to value)"""
  redactedFieldValues: JSON
  """Router ID to import into"""
  routerID: ID!
}

"""
Payload for import service configuration mutation.
Returns validation results without applying changes.
"""
type ImportServiceConfigPayload {
  """Mutation errors"""
  errors: [MutationError!]
  """Whether validation succeeded"""
  valid: Boolean!
  """Validation result"""
  validationResult: ImportValidationResult!
}

"""Input for importing a template"""
input ImportServiceTemplateInput {
  """Router ID"""
  routerID: ID!
  """Template JSON data"""
  templateData: JSON!
}

"""Validation error for service import."""
type ImportValidationError {
  """Error code (V400, V403, S600, S602)"""
  code: String!
  """Field name (if applicable)"""
  field: String
  """Human-readable error message"""
  message: String!
  """
  Validation stage (schema, syntax, cross-resource, dependency, conflict, capability, dry-run)
  """
  stage: String!
}

"""
Validation result for service import.
Contains errors, warnings, and redacted field prompts.
"""
type ImportValidationResult {
  """Conflicting service instances (if any)"""
  conflictingInstances: [ServiceInstance!]
  """Validation errors (blocking)"""
  errors: [ImportValidationError!]!
  """List of fields that were redacted and need user input"""
  redactedFields: [String!]
  """Whether user input is required to proceed"""
  requiresUserInput: Boolean!
  """Whether the import package passed validation"""
  valid: Boolean!
  """Validation warnings (non-blocking)"""
  warnings: [ImportValidationWarning!]!
}

"""Validation warning for service import."""
type ImportValidationWarning {
  """Warning message"""
  message: String!
  """Validation stage"""
  stage: String!
}

"""Installation progress event."""
type InstallProgress {
  """Bytes downloaded"""
  bytesDownloaded: Int!
  """Error message if failed"""
  errorMessage: String
  """Feature ID"""
  featureID: String!
  """Instance ID"""
  instanceID: ID!
  """Download progress percentage (0-100)"""
  percent: Float!
  """Current status (downloading, verifying, completed, failed)"""
  status: String!
  """Total bytes to download"""
  totalBytes: Int!
}

"""Input for installing a new service instance."""
input InstallServiceInput {
  """IP address to bind the service to (optional)"""
  bindIP: String
  """Service-specific configuration (JSON)"""
  config: JSON
  """Feature ID to install (e.g., 'tor', 'sing-box')"""
  featureID: String! @validate(pattern: "^[a-z0-9_-]+$")
  """Human-readable instance name"""
  instanceName: String! @validate(minLength: 1, maxLength: 255)
  """Router ID to install the service on"""
  routerID: ID!
  """VLAN ID for network isolation (optional)"""
  vlanID: Int @validate(min: 1, max: 4094)
}

"""Input for installing a service template"""
input InstallServiceTemplateInput {
  """Dry run (preview only, don't actually install)"""
  dryRun: Boolean
  """Router ID"""
  routerID: ID!
  """Template ID to install"""
  templateID: ID!
  """Variable values"""
  variables: JSON!
}

"""Health status enumeration for service instances"""
enum InstanceHealthState {
  CHECKING
  HEALTHY
  UNHEALTHY
  UNKNOWN
}

"""
Resource usage details for a single service instance.
Combines instance metadata with current resource usage.
"""
type InstanceResourceUsage {
  """Feature ID"""
  featureID: String!
  """Instance ID"""
  instanceID: ID!
  """Instance name"""
  instanceName: String!
  """Resource requirements from manifest"""
  requirements: ResourceRequirements
  """Current resource usage"""
  usage: ResourceUsage!
}

"""Instance status change event."""
type InstanceStatusChanged {
  """Instance ID"""
  instanceID: ID!
  """New status"""
  newStatus: ServiceInstanceStatus!
  """Previous status"""
  previousStatus: ServiceInstanceStatus!
  """Timestamp of the change"""
  timestamp: DateTime!
}

"""Integer range for filtering"""
input IntRange {
  """Maximum value (inclusive)"""
  max: Int
  """Minimum value (inclusive)"""
  min: Int
}

"""A network interface on a router"""
type Interface implements Node {
  """User comment"""
  comment: String @mikrotik(path: "/interface", field: "comment")
  """Whether the interface is enabled"""
  enabled: Boolean! @mikrotik(path: "/interface", field: "disabled")
  """Unique interface identifier"""
  id: ID!
  """IP address assigned to this interface"""
  ip: IPv4 @mikrotik(path: "/ip/address", field: "address")
  """Last time this interface was seen/queried"""
  lastSeen: DateTime
  """Connected device information from LLDP"""
  linkPartner: String
  """Link speed (e.g., 1Gbps, 100Mbps)"""
  linkSpeed: String @mikrotik(path: "/interface/ethernet", field: "rate")
  """MAC address"""
  macAddress: MAC @mikrotik(path: "/interface", field: "mac-address")
  """MTU setting"""
  mtu: Int @mikrotik(path: "/interface", field: "mtu")
  """Interface name (e.g., ether1, wlan1)"""
  name: String! @mikrotik(path: "/interface", field: "name")
  """Whether the interface is running (link up)"""
  running: Boolean! @mikrotik(path: "/interface", field: "running")
  """RX bytes"""
  rxBytes: Size @mikrotik(path: "/interface", field: "rx-byte")
  """Current receive rate in bytes per second"""
  rxRate: Size @mikrotik(path: "/interface", field: "rx-bits-per-second")
  """Operational status of the interface"""
  status: InterfaceStatus!
  """TX bytes"""
  txBytes: Size @mikrotik(path: "/interface", field: "tx-byte")
  """Current transmit rate in bytes per second"""
  txRate: Size @mikrotik(path: "/interface", field: "tx-bits-per-second")
  """Interface type"""
  type: InterfaceType! @mikrotik(path: "/interface", field: "type")
  """Services using this interface (bridge, VPN, etc.)"""
  usedBy: [String!]
}

type InterfaceConnection implements Connection {
  edges: [InterfaceEdge!]!
  pageInfo: PageInfo!
  totalCount: Int
}

type InterfaceEdge implements Edge {
  cursor: String!
  node: Interface!
}

"""Error information for a single interface operation in a batch"""
type InterfaceOperationError {
  """Error message describing why the operation failed"""
  error: String!
  """Interface ID that failed"""
  interfaceId: ID!
  """Interface name"""
  interfaceName: String!
}

"""Interface traffic statistics"""
type InterfaceStats {
  """Total bytes received"""
  rxBytes: Size!
  """Receive drops"""
  rxDrops: Int!
  """Receive errors"""
  rxErrors: Int!
  """Total packets received"""
  rxPackets: Size!
  """Total bytes transmitted"""
  txBytes: Size!
  """Transmission drops"""
  txDrops: Int!
  """Transmission errors"""
  txErrors: Int!
  """Total packets transmitted"""
  txPackets: Size!
}

"""Historical interface statistics with time-series data"""
type InterfaceStatsHistory {
  """Time-series data points"""
  dataPoints: [StatsDataPoint!]!
  """End of the time range"""
  endTime: DateTime!
  """Interface ID"""
  interfaceId: ID!
  """Aggregation interval (e.g., 5m, 1h)"""
  interval: Duration!
  """Start of the time range"""
  startTime: DateTime!
}

"""Operational status of a network interface"""
enum InterfaceStatus {
  """Interface is disabled"""
  DISABLED
  """Interface is down"""
  DOWN
  """Status unknown or error"""
  UNKNOWN
  """Interface is up and running"""
  UP
}

"""Event emitted when an interface status changes"""
type InterfaceStatusEvent {
  """Interface ID"""
  interfaceId: ID!
  """Interface name"""
  interfaceName: String!
  """Previous status"""
  previousStatus: InterfaceStatus!
  """New status"""
  status: InterfaceStatus!
  """Event timestamp"""
  timestamp: DateTime!
}

type InterfaceTrafficEvent {
  """Interface ID"""
  interfaceId: ID!
  """Interface name"""
  interfaceName: String!
  """RX rate in bytes per second"""
  rxRate: Size!
  """Total RX bytes"""
  rxTotal: Size!
  """Timestamp"""
  timestamp: DateTime!
  """TX rate in bytes per second"""
  txRate: Size!
  """Total TX bytes"""
  txTotal: Size!
}

"""Types of network interfaces"""
enum InterfaceType {
  BONDING
  BRIDGE
  ETHERNET
  LOOPBACK
  OTHER
  PPP
  TUNNEL
  VIRTUAL
  VLAN
  WIRELESS
}

"""An IP address assigned to an interface"""
type IpAddress implements Node {
  """IP address with CIDR notation (e.g., 192.168.10.1/24)"""
  address: String! @validate(format: CIDR) @mikrotik(path: "/ip/address", field: "address")
  """Broadcast address (calculated from address and netmask)"""
  broadcast: String
  """User comment"""
  comment: String @validate(maxLength: 255) @mikrotik(path: "/ip/address", field: "comment")
  """Whether this IP is disabled"""
  disabled: Boolean! @mikrotik(path: "/ip/address", field: "disabled")
  """Whether this IP was dynamically assigned (via DHCP client)"""
  dynamic: Boolean! @mikrotik(path: "/ip/address", field: "dynamic")
  """Unique IP address identifier"""
  id: ID!
  """Interface this IP is assigned to"""
  interface: Interface! @mikrotik(path: "/ip/address", field: "interface")
  """Whether this IP is invalid (conflicting or error state)"""
  invalid: Boolean! @mikrotik(path: "/ip/address", field: "invalid")
  """Network address (calculated from address and netmask)"""
  network: String
}

"""Event emitted when an IP address changes"""
type IpAddressChangeEvent {
  """Type of change (CREATED, UPDATED, DELETED)"""
  changeType: ChangeType!
  """The IP address that changed"""
  ipAddress: IpAddress
  """IP address ID (for deletions)"""
  ipAddressId: ID!
  """Timestamp of the change"""
  timestamp: DateTime!
}

"""Result of an IP address deletion with dependency checking"""
type IpAddressDeleteResult {
  """Errors that occurred during deletion"""
  errors: [MutationError!]
  """Impact analysis for this IP address deletion"""
  impactAnalysis: IpAddressImpactAnalysis
  """Success or error message"""
  message: String
  """Whether the deletion succeeded"""
  success: Boolean!
}

"""Dependencies for an IP address"""
type IpAddressDependencies {
  """DHCP servers using this IP as gateway"""
  dhcpServers: [DhcpServer!]!
  """Firewall rules referencing this IP"""
  firewallRules: [FirewallRuleReference!]!
  """Whether the IP has any dependencies"""
  hasDependencies: Boolean!
  """IP address ID"""
  ipAddressId: ID!
  """NAT rules referencing this IP"""
  natRules: [NatRuleReference!]!
  """Static routes using this IP"""
  routes: [Route!]!
}

"""Analysis of the impact of deleting an IP address"""
type IpAddressImpactAnalysis {
  """Number of active connections using this IP"""
  activeConnections: Int!
  """Whether the IP can be safely deleted"""
  canDelete: Boolean!
  """List of consequences of deleting this IP"""
  consequences: [String!]!
  """Human-readable impact message"""
  message: String!
  """Severity of the deletion"""
  severity: ConfirmationSeverity!
  """Whether this IP is used as a gateway by DHCP servers"""
  usedByDhcpServers: [DhcpServer!]!
  """Whether this IP is referenced in firewall rules"""
  usedInFirewallRules: [FirewallRuleReference!]!
  """Whether this IP is used in NAT rules"""
  usedInNatRules: [NatRuleReference!]!
}

"""Input for creating or updating an IP address"""
input IpAddressInput {
  """IP address with CIDR notation (e.g., 192.168.10.1/24)"""
  address: String! @validate(format: CIDR)
  """User comment"""
  comment: String @validate(maxLength: 255)
  """Whether this IP is disabled"""
  disabled: Boolean
  """Interface ID to assign this IP to"""
  interfaceId: ID!
}

"""Result of an IP address mutation (create, update)"""
type IpAddressMutationResult {
  """Errors that occurred during the operation"""
  errors: [MutationError!]
  """The created or updated IP address (if successful)"""
  ipAddress: IpAddress
  """Configuration preview (RouterOS commands)"""
  preview: ConfigPreview
  """Whether the operation succeeded"""
  success: Boolean!
}

"""Details about an IP address conflict"""
type IpConflict {
  """Conflicting IP address"""
  address: String!
  """Type of conflict"""
  conflictType: IpConflictType!
  """Explanation of the conflict"""
  explanation: String!
  """Conflicting IP address ID"""
  id: ID!
  """Interface where conflict exists"""
  interface: Interface!
}

"""Result of checking IP address conflicts"""
type IpConflictResult {
  """List of conflicting IP addresses"""
  conflicts: [IpConflict!]!
  """Whether the IP conflicts with existing assignments"""
  hasConflict: Boolean!
  """Human-readable message"""
  message: String!
}

"""Type of IP address conflict"""
enum IpConflictType {
  """IP is the broadcast address of another subnet"""
  BROADCAST
  """Exact IP address match on different interface"""
  EXACT
  """IP is the network address of another subnet"""
  NETWORK
  """IP addresses are in overlapping subnets"""
  SUBNET_OVERLAP
}

"""IPsec profile for GRE tunnel encryption"""
type IpsecProfile {
  """User comment"""
  comment: String @mikrotik(path: "/interface/ipsec/profile", field: "comment")
  """IPsec profile ID"""
  id: ID!
  """Profile name"""
  name: String! @mikrotik(path: "/interface/ipsec/profile", field: "name")
}

"""Severity level of an isolation violation."""
enum IsolationSeverity {
  """Critical error that blocks instance start"""
  ERROR
  """Informational message"""
  INFO
  """Warning that is logged but allows instance start"""
  WARNING
}

"""
Complete isolation status for a service instance.
Includes violations and resource limits.
"""
type IsolationStatus {
  """Timestamp of the last isolation verification check"""
  lastVerified: DateTime
  """Resource limits applied to the instance"""
  resourceLimits: ResourceLimits
  """List of isolation violations (empty if all checks passed)"""
  violations: [IsolationViolation!]!
}

"""
An isolation violation detected during pre-start checks.
Represents a failure in one of the 4 isolation layers.
"""
type IsolationViolation {
  """
  Which isolation layer failed (IP Binding, Directory, Port Registry, Process Binding)
  """
  layer: String!
  """Human-readable description of the violation"""
  message: String!
  """Severity level of the violation"""
  severity: IsolationSeverity!
  """Timestamp when the violation was detected"""
  timestamp: DateTime!
}

"""Arbitrary JSON data for flexible configuration"""
scalar JSON

"""Job status for async traceroute execution"""
enum JobStatus {
  """Job was cancelled by user"""
  CANCELLED
  """Job completed successfully"""
  COMPLETE
  """Job encountered an error"""
  ERROR
  """Job is currently running"""
  RUNNING
  """Job has been created"""
  STARTED
}

"""Kill switch behavior when any hop in a chain fails."""
enum KillSwitchMode {
  """Allow direct internet access (no VPN)"""
  ALLOW_DIRECT
  """Block all traffic from the device"""
  BLOCK_ALL
  """Fall back to a specified service"""
  FALLBACK_SERVICE
}

"""
Kill switch status information for monitoring.
Provides visibility into kill switch state and activation history.
"""
type KillSwitchStatus {
  """Number of times kill switch has been activated"""
  activationCount: Int!
  """Whether kill switch is currently active (blocking traffic)"""
  active: Boolean!
  """Whether kill switch is enabled"""
  enabled: Boolean!
  """Fallback interface ID (if mode=FALLBACK_SERVICE)"""
  fallbackInterfaceID: String
  """Timestamp when kill switch was last activated"""
  lastActivatedAt: DateTime
  """
  Reason for most recent activation (service_down, health_check_failed, etc.)
  """
  lastActivationReason: String
  """Timestamp when kill switch was last deactivated"""
  lastDeactivatedAt: DateTime
  """Kill switch behavior mode"""
  mode: KillSwitchMode!
}

"""Single knock port in sequence."""
type KnockPort {
  """Position in sequence (1-based)"""
  order: Int!
  """Port number (1-65535)"""
  port: Int!
  """Protocol for this knock port"""
  protocol: KnockProtocol!
}

"""Input for knock port."""
input KnockPortInput {
  """Order in sequence"""
  order: Int! @validate(min: 1)
  """Port number"""
  port: Int! @validate(min: 1, max: 65535)
  """Protocol"""
  protocol: KnockProtocol!
}

"""Protocol for knock port."""
enum KnockProtocol {
  """Both TCP and UDP"""
  BOTH
  """TCP only"""
  TCP
  """UDP only"""
  UDP
}

"""Status of knock attempt."""
enum KnockStatus {
  """Wrong port order"""
  FAILED
  """Some ports hit, sequence incomplete"""
  PARTIAL
  """All ports hit correctly, access granted"""
  SUCCESS
  """Time between knocks exceeded"""
  TIMEOUT
}

"""
LAN Network composite resource - groups bridge, DHCP, firewall, routing
"""
type LANNetwork implements Node & Resource {
  """Bridge interface"""
  bridge: BridgeResource
  category: ResourceCategory!
  config: LANNetworkConfig!
  configuration: JSON
  deployment: DeploymentState
  """DHCP server configuration"""
  dhcpServer: DHCPServerResource
  """Firewall rules for this LAN"""
  firewallRules: [FirewallRuleResource!]!
  id: ID!
  lanDeployment: LANNetworkDeployment
  lanRuntime: LANNetworkRuntime
  metadata: ResourceMetadata!
  platform: PlatformInfo
  relationships: ResourceRelationships
  """Static routes"""
  routes: [RouteResource!]!
  runtime: RuntimeState
  scopedId: String!
  telemetry: TelemetryData
  type: String!
  validation: ValidationResult
}

"""LAN Network configuration"""
type LANNetworkConfig {
  """Enable DHCP server"""
  dhcpEnabled: Boolean!
  """DHCP lease time"""
  dhcpLeaseTime: Duration
  """DHCP pool end"""
  dhcpPoolEnd: IPv4
  """DHCP pool start"""
  dhcpPoolStart: IPv4
  """DNS servers for DHCP"""
  dnsServers: [IPv4!]
  """Enable NAT masquerading"""
  enableNat: Boolean!
  """Interfaces to include in bridge"""
  interfaces: [String!]!
  """IP address for the LAN"""
  ipAddress: IPv4!
  """Network name"""
  name: String!
  """Subnet mask in CIDR notation"""
  subnetMask: Int! @validate(min: 1, max: 32)
  """VLAN ID (optional)"""
  vlanId: Int @validate(min: 1, max: 4094)
}

"""LAN Network deployment state"""
type LANNetworkDeployment {
  appliedAt: DateTime!
  appliedBy: String
  """Bridge interface ID on router"""
  bridgeId: String
  """DHCP server ID on router"""
  dhcpServerId: String
  drift: DriftInfo
  """IP address ID on router"""
  ipAddressId: String
  isInSync: Boolean!
  routerResourceId: String
  routerVersion: Int
}

"""LAN Network runtime state"""
type LANNetworkRuntime {
  """Number of active clients"""
  activeClients: Int!
  """Active DHCP leases"""
  dhcpLeases: Int!
  errorMessage: String
  health: RuntimeHealth!
  isRunning: Boolean!
  lastUpdated: DateTime!
  """Total traffic in"""
  totalBytesIn: Size!
  """Total traffic out"""
  totalBytesOut: Size!
}

"""
A single log entry from a service instance.
Represents one line of stdout/stderr output with parsed metadata.
"""
type LogEntry {
  """Log severity level"""
  level: LogLevel!
  """Log message"""
  message: String!
  """Additional parsed metadata (JSON)"""
  metadata: JSON
  """Original raw log line"""
  rawLine: String!
  """Service source (e.g., 'tor', 'singbox', 'adguard')"""
  source: String!
  """Timestamp when the log was generated"""
  timestamp: DateTime!
}

"""Log level for service log entries."""
enum LogLevel {
  """Debug-level log"""
  DEBUG
  """Error log"""
  ERROR
  """Informational log"""
  INFO
  """Unknown/unparsed log level"""
  UNKNOWN
  """Warning log"""
  WARN
}

"""LTE/cellular modem configuration"""
type LteModem implements Node {
  """APN (Access Point Name)"""
  apn: String! @mikrotik(path: "/interface/lte", field: "apn")
  """User comment"""
  comment: String @mikrotik(path: "/interface/lte", field: "comment")
  """Unique identifier"""
  id: ID!
  """LTE interface name"""
  name: String! @mikrotik(path: "/interface/lte", field: "name")
  """Network type (LTE, 3G, etc.)"""
  networkType: String @mikrotik(path: "/interface/lte", field: "current-cellid")
  """Operator name"""
  operator: String @mikrotik(path: "/interface/lte", field: "current-operator")
  """PIN code configured"""
  pinConfigured: Boolean!
  """Connection status"""
  running: Boolean! @mikrotik(path: "/interface/lte", field: "running")
  """Signal strength (RSSI in dBm)"""
  signalStrength: Int @mikrotik(path: "/interface/lte", field: "rssi")
}

"""Input for configuring LTE modem"""
input LteModemInput {
  """APN (Access Point Name)"""
  apn: String! @validate(minLength: 1, maxLength: 100)
  """User comment"""
  comment: String @validate(maxLength: 255)
  """LTE interface name"""
  name: String! @validate(minLength: 1, maxLength: 100)
  """PIN code (optional, for SIM card)"""
  pin: String @validate(minLength: 4, maxLength: 8, pattern: "^[0-9]+$")
}

"""MAC address string (e.g., "00:1A:2B:3C:4D:5E" or "00-1A-2B-3C-4D-5E")"""
scalar MAC

"""Memory utilization metrics"""
type MemoryMetrics {
  """Memory usage percentage (0-100)"""
  percentage: Float!
  """Total memory in bytes"""
  total: Float!
  """Used memory in bytes"""
  used: Float!
}

"""Direction of traffic to mirror"""
enum MirrorDirection {
  """Mirror both ingress and egress traffic"""
  BOTH
  """Mirror only egress (outgoing) traffic"""
  EGRESS
  """Mirror only ingress (incoming) traffic"""
  INGRESS
}

"""Missing dependency information"""
type MissingDependency {
  """Item ID with missing dependency"""
  itemId: ID!
  """Missing resource ID"""
  missingResourceId: ID!
  """Missing resource type"""
  missingResourceType: String!
}

"""MTU guidance for tunnel configuration"""
type MtuGuidance {
  """Human-readable explanation of the overhead"""
  explanation: String!
  """Protocol overhead in bytes"""
  overhead: Int!
  """Recommended MTU based on base MTU (typically 1500)"""
  recommendedMtu: Int!
  """Tunnel type this guidance applies to"""
  tunnelType: TunnelType!
}

type Mutation {
  """Acknowledge a single alert"""
  acknowledgeAlert(
    """Alert ID"""
    alertId: ID!
  ): AlertPayload!
  """Acknowledge multiple alerts"""
  acknowledgeAlerts(
    """Array of alert IDs"""
    alertIds: [ID!]!
  ): BulkAlertPayload!
  """Add a port to a bridge"""
  addBridgePort(bridgeId: ID!, input: AddBridgePortInput!): BridgePortMutationResult!
  """Add an item to a change set"""
  addChangeSetItem(changeSetId: ID!, input: ChangeSetItemInput!): AddChangeSetItemPayload!
  """
  Add a new dependency relationship between service instances.
  Pre-validates that the relationship won't create a cycle.
  """
  addDependency(input: AddDependencyInput!): ServiceDependency!
  """
  Add a new router by entering its IP address and credentials.
  
  This mutation will:
  1. Validate input fields (host format, port range, etc.)
  2. Check for duplicate routers (same host/port)
  3. Resolve hostname to IP if necessary (with DNS caching)
  4. Test connection using protocol preference (or auto-detect)
  5. Store router with encrypted credentials on success
  6. Emit RouterAddedEvent for real-time updates
  
  Returns validation errors if input is invalid, or connection errors
  if the router cannot be reached or authenticated.
  """
  addRouter(input: AddRouterInput!): AddRouterPayload!
  """Apply an alert rule template to create a rule"""
  applyAlertRuleTemplate(
    """Optional customizations"""
    customizations: CreateAlertRuleInput
    """Template ID"""
    templateId: ID!
    """Variables for substitution"""
    variables: JSON!
  ): AlertRulePayload!
  """Apply an alert template to create an alert rule"""
  applyAlertTemplate(
    """Template application input"""
    input: ApplyAlertTemplateInput!
  ): AlertRulePayload!
  """Apply a change set atomically to the router"""
  applyChangeSet(changeSetId: ID!): ApplyChangeSetPayload!
  """
  Apply a firewall template to the router.
  Creates all rules defined in the template with variable substitution.
  Returns a rollback ID for undo within 5 minutes.
  """
  applyFirewallTemplate(routerId: ID!, templateId: ID!, variables: JSON!): FirewallTemplateResult!
  """
  Apply resource to router (transitions VALID -> APPLYING -> ACTIVE/ERROR)
  Follows Apply-Confirm-Merge pattern.
  """
  applyResource(id: ID!, routerId: ID!): ApplyResourcePayload!
  """
  Apply configuration to a service instance.
  Validates, generates config file, and persists to database.
  """
  applyServiceConfig(input: ApplyServiceConfigInput!): ApplyConfigPayload!
  """
  Apply a validated service import package.
  Creates or updates service instance based on conflict resolution strategy.
  Applies routing rules if included.
  """
  applyServiceImport(input: ApplyServiceImportInput!): ApplyServiceImportPayload!
  """Apply a suggested fix for a failed diagnostic step"""
  applyTroubleshootFix(
    """Issue code to fix"""
    issueCode: String!
    """Session ID"""
    sessionId: ID!
  ): ApplyFixPayload!
  """Archive a resource (transitions DEPRECATED -> ARCHIVED)"""
  archiveResource(id: ID!, routerId: ID!): ArchiveResourcePayload!
  """
  Assign a device to route through a specific service instance.
  Creates a MikroTik mangle rule for Policy-Based Routing (PBR).
  """
  assignDeviceRouting(input: AssignDeviceRoutingInput!): DeviceRouting!
  """
  Start an automatic gateway scan.
  Scans common gateway IPs (192.168.0-255.1) to find MikroTik routers.
  This is useful when the user doesn't know which subnet to scan.
  
  Only returns verified MikroTik RouterOS devices (confidence >= 40).
  """
  autoScanGateways: ScanNetworkPayload!
  """Batch operation on multiple interfaces"""
  batchInterfaceOperation(input: BatchInterfaceInput!, routerId: ID!): BatchInterfacePayload!
  """
  Assign multiple devices to routing in a single operation.
  Each assignment is processed independently (partial success allowed).
  """
  bulkAssignRouting(input: BulkAssignRoutingInput!): BulkRoutingResult!
  """
  Bulk create address list entries.
  Processes entries in batches and returns success/failure counts.
  Continues on error - does not stop at first failure.
  """
  bulkCreateAddressListEntries(entries: [BulkAddressInput!]!, listName: String!, routerId: ID!): BulkCreateResult!
  """Cancel an in-progress change set application"""
  cancelChangeSet(changeSetId: ID!): CancelChangeSetPayload!
  """
  Cancel a running scan.
  The scan will stop within 1 second and partial results are preserved.
  """
  cancelScan(taskId: ID!): CancelScanPayload!
  """Cancel a running traceroute job."""
  cancelTraceroute(
    """Job ID to cancel"""
    jobId: ID!
  ): Boolean!
  """Cancel a troubleshooting session"""
  cancelTroubleshoot(sessionId: ID!): TroubleshootSession!
  """Change the current user's password"""
  changePassword(
    """Current password for verification"""
    currentPassword: String! @sensitive
    """New password (must meet policy requirements)"""
    newPassword: String! @sensitive
  ): Boolean! @auth
  """
  Manually trigger update check for all instances.
  Queries GitHub Releases API for new versions.
  """
  checkForUpdates(
    """Router ID"""
    routerID: ID!
  ): Int!
  """Perform immediate health check on a router"""
  checkRouterHealth(
    """Router ID"""
    routerId: ID!
  ): HealthCheckResult!
  """
  Clean up orphaned port allocations.
  Removes allocations for service instances that no longer exist.
  """
  cleanupOrphanedPorts(input: CleanupOrphanedPortsInput!): OrphanCleanupPayload!
  """
  Clean up orphaned VLAN allocations for a router.
  
  Finds allocations referencing missing or deleting instances and marks them
  as RELEASED. Returns the count of cleaned allocations.
  
  This mutation is automatically called during system startup reconciliation
  via InstanceManager.Reconcile(). Manual invocation is useful for:
  - Recovering from crashes or unclean shutdowns
  - Debugging allocation issues
  - Forcing cleanup outside of normal reconciliation
  
  Example:
  ```
  mutation {
    cleanupOrphanedVLANs(routerID: "router-123")
  }
  ```
  
  Returns: Number of allocations cleaned up
  """
  cleanupOrphanedVLANs(
    """Router ID to clean up orphans for"""
    routerID: String!
  ): Int!
  """Configure VLAN settings on a bridge port (trunk/access)"""
  configureBridgePortVlan(
    """VLAN configuration"""
    input: BridgePortVlanInput!
    """Bridge port ID"""
    portId: ID!
    """Router ID"""
    routerId: ID!
  ): VlanMutationResult! @capability(requires: ["interface"])
  """Configure DHCP client on a WAN interface"""
  configureDhcpWAN(
    """DHCP configuration"""
    input: DhcpClientInput!
    """Router ID"""
    routerId: ID!
  ): WANMutationResult! @capability(requires: ["interface"])
  """
  Configure external storage path for service binaries.
  Validates path exists and is writable, then persists to settings.
  Future installations will use external storage for binaries.
  """
  configureExternalStorage(input: ConfigureExternalStorageInput!): ConfigureExternalStoragePayload!
  """
  Configure health check settings for a service instance
  Allows adjusting check interval, failure threshold, and auto-restart behavior
  """
  configureHealthCheck(input: ConfigureHealthCheckInput!): ServiceInstanceHealth!
  """Configure LTE modem"""
  configureLteWAN(
    """LTE configuration"""
    input: LteModemInput!
    """Router ID"""
    routerId: ID!
  ): WANMutationResult! @capability(requires: ["interface"])
  """Configure PPPoE client on a WAN interface"""
  configurePppoeWAN(
    """PPPoE configuration"""
    input: PppoeClientInput!
    """Router ID"""
    routerId: ID!
  ): WANMutationResult! @capability(requires: ["interface"])
  """Configure static IP on a WAN interface"""
  configureStaticWAN(
    """Static IP configuration"""
    input: StaticIPInput!
    """Router ID"""
    routerId: ID!
  ): WANMutationResult! @capability(requires: ["interface"])
  """Configure update schedule and auto-apply policy for an instance."""
  configureUpdateSchedule(input: UpdateCheckScheduleInput!): ServiceInstance!
  """Configure health check for WAN interface"""
  configureWANHealthCheck(
    """Health check configuration"""
    input: WANHealthCheckInput!
    """Router ID"""
    routerId: ID!
    """WAN interface ID"""
    wanInterfaceId: ID!
  ): WANMutationResult! @capability(requires: ["interface"])
  """Connect to a router"""
  connectRouter(id: ID!): ConnectRouterPayload!
  """
  Create a new address list entry.
  If the list doesn't exist, it will be created automatically.
  """
  createAddressListEntry(input: CreateAddressListEntryInput!, routerId: ID!): AddressListEntry!
  """Create a new alert rule"""
  createAlertRule(
    """Alert rule input"""
    input: CreateAlertRuleInput!
  ): AlertRulePayload!
  """Create a new bridge"""
  createBridge(input: CreateBridgeInput!, routerId: ID!): BridgeMutationResult!
  """Create a bridge VLAN entry"""
  createBridgeVlan(bridgeId: ID!, input: CreateBridgeVlanInput!): BridgeVlanMutationResult!
  """Create a new change set"""
  createChangeSet(input: CreateChangeSetInput!): CreateChangeSetPayload!
  """Assign a new IP address to an interface"""
  createIpAddress(
    """IP address input"""
    input: IpAddressInput!
    """Router ID"""
    routerId: ID!
  ): IpAddressMutationResult! @capability(requires: ["interface"])
  """
  Create a masquerade rule for internet sharing.
  Convenience mutation for common srcnat masquerade setup.
  """
  createMasqueradeRule(comment: String, outInterface: String!, routerId: ID!, srcAddress: String): NatRule!
  """Create a NAT rule."""
  createNatRule(input: CreateNatRuleInput!, routerId: ID!): NatRule!
  """
  Create a new notification channel configuration (validates before saving)
  """
  createNotificationChannelConfig(
    """Configuration input"""
    input: CreateNotificationChannelConfigInput!
  ): ChannelConfigPayload!
  """
  Create a port forward (creates both NAT and filter rules).
  Simplified wizard for common use case of exposing internal service.
  """
  createPortForward(input: PortForwardInput!, routerId: ID!): PortForward!
  """
  Create a new port knock sequence.
  Generates firewall rules on the router.
  """
  createPortKnockSequence(input: PortKnockSequenceInput!, routerId: ID!): PortKnockSequence!
  """Create a new port mirror configuration"""
  createPortMirror(
    """Port mirror configuration"""
    input: CreatePortMirrorInput!
    """Router ID"""
    routerId: ID!
  ): PortMirrorMutationResult! @capability(requires: ["interface"])
  """Create a new resource (starts in DRAFT state)"""
  createResource(input: CreateResourceInput!): CreateResourcePayload!
  """Create a new static route"""
  createRoute(
    """Route input data"""
    input: RouteInput!
    """Router ID"""
    routerId: ID!
  ): RouteMutationResult! @capability(requires: ["routing"])
  """Add a new router to manage"""
  createRouter(input: CreateRouterInput!): CreateRouterPayload!
  """
  Create a multi-hop routing chain for a device.
  Removes any existing single-hop routing for the device.
  Creates sequential MikroTik mangle rules with Policy-Based Routing (PBR).
  """
  createRoutingChain(
    """Chain configuration"""
    input: CreateRoutingChainInput!
    """Router ID"""
    routerID: ID!
  ): RoutingChainMutationResult!
  """
  Create a new routing schedule.
  Validates time format, timezone, and days. Triggers immediate schedule evaluation.
  """
  createSchedule(
    """Schedule input"""
    input: CreateScheduleInput!
    """Router ID"""
    routerID: ID!
  ): RoutingSchedule!
  """Create a new tunnel interface"""
  createTunnel(
    """Tunnel configuration"""
    input: TunnelInput!
    """Router ID"""
    routerId: ID!
  ): TunnelMutationResult! @capability(requires: ["interface"])
  """Create a new VLAN interface"""
  createVlan(
    """VLAN input data"""
    input: VlanInput!
    """Router ID"""
    routerId: ID!
  ): VlanMutationResult! @capability(requires: ["interface"])
  """Create a new webhook"""
  createWebhook(
    """Webhook input"""
    input: CreateWebhookInput!
  ): WebhookPayload!
  """
  Delete an address list entry by ID.
  Returns true if successful, false otherwise.
  """
  deleteAddressListEntry(id: ID!, routerId: ID!): Boolean!
  """Delete an alert rule"""
  deleteAlertRule(
    """Alert rule ID"""
    id: ID!
  ): DeletePayload!
  """Delete a custom alert template"""
  deleteAlertTemplate(
    """Template ID"""
    id: ID!
  ): DeletePayload!
  """Delete a bridge"""
  deleteBridge(uuid: ID!): DeleteResult!
  """Delete a bridge VLAN entry"""
  deleteBridgeVlan(uuid: ID!): DeleteResult!
  """Delete a change set (only if not applying)"""
  deleteChangeSet(changeSetId: ID!): DeleteChangeSetPayload!
  """Delete a custom alert rule template (built-ins cannot be deleted)"""
  deleteCustomAlertRuleTemplate(
    """Template ID"""
    id: ID!
  ): DeletePayload!
  """
  Delete a custom firewall template.
  Only custom templates can be deleted (not built-in).
  """
  deleteFirewallTemplate(id: ID!): Boolean!
  """Delete a service instance and clean up resources."""
  deleteInstance(input: DeleteInstanceInput!): ServiceInstancePayload!
  """Remove an IP address from an interface"""
  deleteIpAddress(
    """IP address ID to delete"""
    id: ID!
    """Router ID"""
    routerId: ID!
  ): IpAddressDeleteResult! @capability(requires: ["interface"])
  """Delete a NAT rule."""
  deleteNatRule(id: ID!, routerId: ID!): Boolean!
  """Delete a notification channel configuration (soft delete)"""
  deleteNotificationChannelConfig(
    """Configuration ID"""
    id: ID!
  ): DeletePayload!
  """Delete a port forward (removes both NAT and filter rules)."""
  deletePortForward(id: ID!, routerId: ID!): Boolean!
  """
  Delete port knock sequence.
  Removes all associated firewall rules.
  """
  deletePortKnockSequence(id: ID!, routerId: ID!): Boolean!
  """Delete a port mirror configuration"""
  deletePortMirror(
    """Port mirror ID to delete"""
    id: ID!
    """Router ID"""
    routerId: ID!
  ): DeleteResult! @capability(requires: ["interface"])
  """Delete a resource permanently"""
  deleteResource(id: ID!, routerId: ID!): DeleteResourcePayload!
  """Delete a route with impact analysis"""
  deleteRoute(
    """Route ID to delete"""
    id: ID!
    """Router ID"""
    routerId: ID!
  ): RouteDeleteResult! @capability(requires: ["routing"])
  """Remove a router"""
  deleteRouter(id: ID!): DeleteRouterPayload!
  """
  Delete a routing schedule.
  Triggers immediate schedule evaluation to ensure routing state is correct.
  """
  deleteSchedule(
    """Router ID"""
    routerID: ID!
    """Schedule ID to delete"""
    scheduleID: ID!
  ): Boolean!
  """
  Delete a user-created service template.
  Built-in templates cannot be deleted.
  """
  deleteServiceTemplate(
    """Router ID"""
    routerID: ID!
    """Template ID"""
    templateID: ID!
  ): Boolean!
  """Delete a tunnel interface"""
  deleteTunnel(
    """Tunnel ID to delete"""
    id: ID!
    """Router ID"""
    routerId: ID!
  ): TunnelMutationResult! @capability(requires: ["interface"])
  """Delete a VLAN interface"""
  deleteVlan(
    """VLAN ID to delete"""
    id: ID!
  ): DeleteResult! @capability(requires: ["interface"])
  """Delete WAN configuration (revert to unconfigured)"""
  deleteWANConfiguration(
    """Router ID"""
    routerId: ID!
    """WAN interface ID"""
    wanInterfaceId: ID!
  ): DeleteResult! @capability(requires: ["interface"])
  """Delete a webhook"""
  deleteWebhook(
    """Webhook ID"""
    id: ID!
  ): DeletePayload!
  """Deprecate a resource (transitions -> DEPRECATED)"""
  deprecateResource(id: ID!, routerId: ID!): DeprecateResourcePayload!
  """Disable an interface"""
  disableInterface(interfaceId: ID!, routerId: ID!): UpdateInterfacePayload!
  """Disable a port mirror configuration"""
  disablePortMirror(
    """Port mirror ID"""
    id: ID!
    """Router ID"""
    routerId: ID!
  ): PortMirrorMutationResult! @capability(requires: ["interface"])
  """Disconnect from a router"""
  disconnectRouter(id: ID!): DisconnectRouterPayload!
  """Enable an interface"""
  enableInterface(interfaceId: ID!, routerId: ID!): UpdateInterfacePayload!
  """Enable a port mirror configuration"""
  enablePortMirror(
    """Port mirror ID"""
    id: ID!
    """Router ID"""
    routerId: ID!
  ): PortMirrorMutationResult! @capability(requires: ["interface"])
  """Export an alert rule template as JSON"""
  exportAlertRuleTemplate(
    """Template ID"""
    id: ID!
  ): String!
  """
  Export existing service instances as a reusable template.
  Creates a new user template from running services.
  """
  exportAsTemplate(input: ExportAsTemplateInput!): ServiceTemplate!
  """
  Export router configuration with optional credential handling.
  Credentials are excluded by default for security.
  If includeCredentials is true, an encryptionKey must be provided.
  """
  exportRouterConfig(input: ExportConfigInput!): ExportConfigPayload! @auth
  """
  Export a service configuration as a JSON package.
  Returns a download URL with 15-minute expiry.
  Supports secret redaction and routing rule inclusion.
  """
  exportServiceConfig(input: ExportServiceConfigInput!): ExportServiceConfigPayload!
  """
  Flush the DNS cache on the router.
  Clears all cached DNS entries and returns before/after statistics.
  """
  flushDnsCache(
    """Device/router ID"""
    deviceId: String!
  ): FlushDnsCacheResult!
  """
  Generate a QR code for service configuration sharing.
  Returns base64-encoded PNG image (256x256 by default).
  Enforces 2KB size limit for QR code data.
  """
  generateConfigQR(input: GenerateConfigQRInput!): GenerateConfigQRPayload!
  """Import an alert rule template from JSON"""
  importAlertRuleTemplate(
    """JSON template string"""
    json: String!
  ): AlertRuleTemplatePayload!
  """
  Import a service configuration package (validation only).
  Performs 7-stage validation pipeline without making changes.
  Returns validation results and conflicts.
  """
  importServiceConfig(input: ImportServiceConfigInput!): ImportServiceConfigPayload!
  """Import a service template from JSON."""
  importServiceTemplate(input: ImportServiceTemplateInput!): ServiceTemplate!
  """
  Install a new service instance on a router.
  Downloads the binary, verifies checksum, and creates the instance.
  """
  installService(input: InstallServiceInput!): ServiceInstancePayload!
  """
  Install a service template on a router.
  Creates one or more service instances based on the template.
  """
  installServiceTemplate(input: InstallServiceTemplateInput!): TemplateInstallResult!
  """Authenticate and receive a JWT token"""
  login(
    """Password"""
    password: String! @sensitive
    """Username"""
    username: String!
  ): AuthPayload!
  """Invalidate current session and clear tokens"""
  logout: Boolean! @auth
  """
  Preview how a notification template will render with sample data
  Used for template customization - renders subject and body with validation
  Requires authentication
  """
  previewNotificationTemplate(
    """Template preview input"""
    input: PreviewNotificationTemplateInput!
  ): NotificationTemplatePreview! @auth
  """Manually trigger reconnection to a router"""
  reconnectRouter(
    """Router ID"""
    routerId: ID!
  ): ReconnectRouterPayload!
  """Force refresh router capabilities (invalidates cache)"""
  refreshCapabilities(routerId: ID!): RefreshCapabilitiesPayload!
  """Remove a port from a bridge"""
  removeBridgePort(portId: ID!): DeleteResult!
  """Remove an item from a change set"""
  removeChangeSetItem(changeSetId: ID!, itemId: ID!): RemoveChangeSetItemPayload!
  """Remove an existing dependency relationship."""
  removeDependency(input: RemoveDependencyInput!): Boolean!
  """
  Remove a device routing assignment.
  Deletes the MikroTik mangle rule and database record.
  """
  removeDeviceRouting(
    """Device ID to unroute"""
    deviceID: String!
    """Router ID"""
    routerID: ID!
  ): Boolean!
  """
  Remove a routing chain and all its mangle/route/filter rules from the router.
  """
  removeRoutingChain(
    """Chain ID to remove"""
    chainID: ID!
    """Router ID"""
    routerID: ID!
  ): RoutingChainMutationResult!
  """
  Reset alert notification template to system default (deletes custom template)
  Used for notification template customization per channel
  Requires authentication
  """
  resetAlertTemplate(
    """Notification channel to reset template for"""
    channel: NotificationChannel!
    """Event type to reset template for"""
    eventType: String!
  ): DeletePayload! @auth
  """
  Manually reset the circuit breaker for a router.
  This allows immediate reconnection attempts even if the circuit is open.
  Use with caution as it bypasses the backoff protection.
  """
  resetCircuitBreaker(routerId: ID!): CircuitBreakerStatus!
  """
  Reset external storage configuration to use flash only.
  Optionally migrates existing binaries back to flash.
  """
  resetExternalStorage(input: ResetExternalStorageInput): ResetExternalStoragePayload!
  """
  Remove traffic quota from a service instance.
  Removes tracking mangle rules and quota configuration.
  """
  resetTrafficQuota(
    """Instance ID"""
    instanceID: ID!
    """Router ID"""
    routerID: ID!
  ): TrafficQuotaPayload!
  """Restart a service instance."""
  restartInstance(input: RestartInstanceInput!): ServiceInstancePayload!
  """
  Manually trigger binary reverification for an instance.
  Checks if the binary hash matches the stored hash from install-time.
  """
  reverifyInstance(
    """Instance ID to reverify"""
    instanceID: ID!
    """Router ID"""
    routerID: ID!
  ): ReverifyPayload!
  """Revoke all sessions for a user (admin only)"""
  revokeAllSessions(
    """User ID to revoke sessions for"""
    userId: ID!
  ): Boolean! @auth(requires: "admin")
  """Revoke a specific session"""
  revokeSession(
    """Session ID to revoke"""
    sessionId: ID!
  ): Boolean! @auth
  """Force rollback of a failed change set"""
  rollbackChangeSet(changeSetId: ID!): RollbackChangeSetPayload!
  """
  Rollback a previously applied template.
  Removes all template rules and restores previous state.
  Only works within 5 minutes of application.
  """
  rollbackFirewallTemplate(rollbackId: ID!, routerId: ID!): Boolean!
  """
  Rollback an instance to its backed-up version.
  Only works if a backup exists (has_backup=true).
  """
  rollbackInstance(
    """Instance ID to rollback"""
    instanceID: ID!
    """Router ID"""
    routerID: ID!
  ): UpdateResult!
  """
  Run comprehensive diagnostics on a router connection.
  Performs network reachability check, port scanning, TLS validation,
  and authentication testing. Rate limited to 1 request per 10 seconds per router.
  """
  runDiagnostics(routerId: ID!): DiagnosticReport!
  """
  Perform DNS lookup (synchronous request-response).
  Queries the specified DNS server for the hostname and record type.
  Uses RouterOS native DNS lookup for A/AAAA records when possible,
  falls back to Go resolver for other record types.
  """
  runDnsLookup(
    """DNS lookup parameters"""
    input: DnsLookupInput!
  ): DnsLookupResult!
  """
  Manually run diagnostics on a service instance.
  Executes health checks and connectivity tests.
  """
  runServiceDiagnostics(input: RunDiagnosticsInput!): RunDiagnosticsPayload!
  """
  Start a traceroute from the router to the target.
  Returns a job ID for subscription tracking.
  """
  runTraceroute(
    """Device/router ID to run traceroute from"""
    deviceId: ID!
    """Traceroute parameters"""
    input: TracerouteInput!
  ): TracerouteJob!
  """Run a specific diagnostic step in a session"""
  runTroubleshootStep(
    """Session ID"""
    sessionId: ID!
    """Step to run"""
    stepType: TroubleshootStepType!
  ): RunTroubleshootStepPayload!
  """Save a custom alert template"""
  saveAlertTemplate(
    """Template input"""
    input: SaveAlertTemplateInput!
  ): AlertTemplatePayload!
  """Save a custom alert rule template"""
  saveCustomAlertRuleTemplate(
    """Template input"""
    input: SaveAlertRuleTemplateInput!
  ): AlertRuleTemplatePayload!
  """
  Save a custom firewall template.
  Template is stored locally in IndexedDB (frontend operation).
  """
  saveFirewallTemplate(input: SaveTemplateInput!): FirewallTemplate!
  """
  Start a network scan for MikroTik routers.
  Returns a task ID that can be used to track progress via subscription or polling.
  
  Supported subnet formats:
  - CIDR: "192.168.88.0/24" (scans 254 usable IPs)
  - Range: "192.168.1.1-192.168.1.100" (scans specified range)
  - Single IP: "192.168.88.1" (scans one IP)
  
  Performance: /24 scan completes in 1-2 seconds with 20 concurrent workers.
  """
  scanNetwork(input: ScanNetworkInput!): ScanNetworkPayload!
  """
  Manually trigger storage detection scan.
  Useful for detecting newly mounted storage without restart.
  """
  scanStorage: ScanStoragePayload!
  """
  Enable or update kill switch for a device routing.
  Creates MikroTik filter rules to block traffic when service is unhealthy.
  """
  setKillSwitch(input: SetKillSwitchInput!): DeviceRouting!
  """Set preferred protocol for a router"""
  setPreferredProtocol(
    """Preferred protocol"""
    protocol: Protocol!
    """Router ID"""
    routerId: ID!
  ): SetPreferredProtocolPayload!
  """
  Set resource limits for a service instance.
  Applies cgroups v2 memory limits to the running process.
  """
  setResourceLimits(input: SetResourceLimitsInput!): ResourceLimitsPayload!
  """
  Set or update traffic quota for a service instance.
  Creates mangle rules to track traffic and enforces limits.
  """
  setTrafficQuota(input: SetTrafficQuotaInput!): TrafficQuotaPayload!
  """Start a service instance."""
  startInstance(input: StartInstanceInput!): ServiceInstancePayload!
  """
  Start a new troubleshooting session for a router.
  Automatically detects network configuration and begins diagnostics.
  """
  startTroubleshoot(routerId: ID!): StartTroubleshootPayload!
  """Stop a service instance."""
  stopInstance(input: StopInstanceInput!): ServiceInstancePayload!
  """
  Test all router credentials in parallel.
  Returns aggregate results with per-router status.
  """
  testAllCredentials: TestAllCredentialsPayload! @auth
  """Test a notification channel"""
  testNotificationChannel(
    """Channel type (email, telegram, pushover, webhook)"""
    channel: String!
    """Channel configuration"""
    config: JSON!
  ): TestNotificationPayload!
  """
  Test port knock sequence.
  Creates temporary rules with short timeout for verification.
  """
  testPortKnockSequence(id: ID!, routerId: ID!): TestPortKnockResult!
  """Test connection to a router"""
  testRouterConnection(id: ID!): TestConnectionPayload!
  """
  Test connection to a router without adding it.
  Useful for validating credentials before committing.
  """
  testRouterCredentials(input: AddRouterInput!): ConnectionTestResult!
  """Test tunnel connectivity and path MTU"""
  testTunnel(
    """Tunnel ID to test"""
    id: ID!
    """Router ID"""
    routerId: ID!
  ): TunnelTestResult! @capability(requires: ["interface"])
  """Test a webhook by sending a sample payload"""
  testWebhook(
    """Webhook ID to test"""
    id: ID!
  ): WebhookTestPayload!
  """Toggle alert rule enabled/disabled status"""
  toggleAlertRule(
    """Alert rule ID"""
    id: ID!
  ): AlertRulePayload!
  """
  Toggle port knock sequence enabled/disabled.
  Enables or disables firewall rules.
  """
  togglePortKnockSequence(enabled: Boolean!, id: ID!, routerId: ID!): PortKnockSequence!
  """
  Manually trigger the boot sequence for auto-start instances.
  Useful for testing or re-running boot sequence after failures.
  """
  triggerBootSequence: Boolean!
  """Trigger digest delivery immediately for a channel (NAS-18.11)"""
  triggerDigestNow(
    """Channel ID to trigger digest for"""
    channelId: ID!
  ): DigestSummary!
  """Undo a bridge operation (within 10-second window)"""
  undoBridgeOperation(operationId: ID!): BridgeMutationResult!
  """Update an existing alert rule"""
  updateAlertRule(
    """Alert rule ID"""
    id: ID!
    """Update input"""
    input: UpdateAlertRuleInput!
  ): AlertRulePayload!
  """
  Update all instances that have critical updates available.
  Returns number of instances updated.
  """
  updateAllInstances(
    """Minimum severity to update (default: CRITICAL)"""
    minSeverity: UpdateSeverity
    """Router ID"""
    routerID: ID!
  ): Int!
  """Update an existing bridge"""
  updateBridge(input: UpdateBridgeInput!, uuid: ID!): BridgeMutationResult!
  """Update bridge port settings"""
  updateBridgePort(input: UpdateBridgePortInput!, portId: ID!): BridgePortMutationResult!
  """Update an item in a change set"""
  updateChangeSetItem(changeSetId: ID!, input: UpdateChangeSetItemInput!, itemId: ID!): UpdateChangeSetItemPayload!
  """
  Apply an available update to a service instance.
  Uses atomic 6-phase update with rollback on failure.
  """
  updateInstance(
    """Instance ID to update"""
    instanceID: ID!
    """Router ID"""
    routerID: ID!
  ): UpdateResult!
  """Update interface settings (MTU, comment, ARP mode)"""
  updateInterface(input: UpdateInterfaceInput!, interfaceId: ID!, routerId: ID!): UpdateInterfacePayload!
  """Update an existing IP address"""
  updateIpAddress(
    """IP address ID"""
    id: ID!
    """Updated IP address data"""
    input: IpAddressInput!
    """Router ID"""
    routerId: ID!
  ): IpAddressMutationResult! @capability(requires: ["interface"])
  """Update an existing NAT rule."""
  updateNatRule(id: ID!, input: CreateNatRuleInput!, routerId: ID!): NatRule!
  """Update an existing notification channel configuration"""
  updateNotificationChannelConfig(
    """Configuration ID"""
    id: ID!
    """Update input"""
    input: UpdateNotificationChannelConfigInput!
  ): ChannelConfigPayload!
  """
  Update existing port knock sequence.
  Regenerates firewall rules.
  """
  updatePortKnockSequence(id: ID!, input: PortKnockSequenceInput!, routerId: ID!): PortKnockSequence!
  """Update an existing port mirror configuration"""
  updatePortMirror(
    """Port mirror ID"""
    id: ID!
    """Updated configuration"""
    input: UpdatePortMirrorInput!
    """Router ID"""
    routerId: ID!
  ): PortMirrorMutationResult! @capability(requires: ["interface"])
  """Update resource configuration (transitions to DRAFT -> VALIDATING)"""
  updateResource(id: ID!, input: UpdateResourceInput!, routerId: ID!): UpdateResourcePayload!
  """Update an existing route"""
  updateRoute(
    """Route ID"""
    id: ID!
    """Updated route data"""
    input: RouteInput!
    """Router ID"""
    routerId: ID!
  ): RouteMutationResult! @capability(requires: ["routing"])
  """Update router settings"""
  updateRouter(id: ID!, input: UpdateRouterInput!): UpdateRouterPayload!
  """
  Update router credentials.
  Tests the new credentials before saving.
  Old credentials are preserved if the test fails.
  """
  updateRouterCredentials(input: CredentialsInput!, routerId: ID!): CredentialUpdatePayload! @auth
  """
  Update an existing routing chain (replaces all hops).
  Removes the old chain and creates a new one with updated configuration.
  """
  updateRoutingChain(
    """Chain ID to update"""
    chainID: ID!
    """New chain configuration"""
    input: CreateRoutingChainInput!
    """Router ID"""
    routerID: ID!
  ): RoutingChainMutationResult!
  """
  Update an existing routing schedule.
  Triggers immediate schedule evaluation.
  """
  updateSchedule(
    """Schedule input"""
    input: UpdateScheduleInput!
    """Router ID"""
    routerID: ID!
    """Schedule ID to update"""
    scheduleID: ID!
  ): RoutingSchedule!
  """Update an existing tunnel interface"""
  updateTunnel(
    """Tunnel ID"""
    id: ID!
    """Updated tunnel configuration"""
    input: TunnelInput!
    """Router ID"""
    routerId: ID!
  ): TunnelMutationResult! @capability(requires: ["interface"])
  """
  Update VLAN pool configuration.
  
  Changes the allocatable VLAN range. The new configuration is persisted to
  GlobalSettings and will be used for all future allocations.
  
  Validation:
  - poolStart must be >= 1 (minimum valid VLAN ID)
  - poolEnd must be <= 4094 (maximum valid VLAN ID per IEEE 802.1Q)
  - poolStart must be <= poolEnd
  - No existing allocations can fall outside the new range
  
  Example:
  ```
  mutation {
    updateVLANPoolConfig(poolStart: 200, poolEnd: 299) {
      routerID
      totalVLANs
      poolStart
      poolEnd
    }
  }
  ```
  
  Note: Changing pool config may require application restart to take effect
  for all service instances.
  
  Returns: Updated pool status with new configuration
  """
  updateVLANPoolConfig(
    """Last VLAN ID in the pool (1-4094)"""
    poolEnd: Int!
    """First VLAN ID in the pool (1-4094)"""
    poolStart: Int!
  ): VLANPoolStatus!
  """Update an existing VLAN interface"""
  updateVlan(
    """VLAN ID"""
    id: ID!
    """Updated VLAN data"""
    input: VlanInput!
  ): VlanMutationResult! @capability(requires: ["interface"])
  """Update an existing webhook"""
  updateWebhook(
    """Webhook ID"""
    id: ID!
    """Update input"""
    input: UpdateWebhookInput!
  ): WebhookPayload!
  """Validate a change set (all items)"""
  validateChangeSet(changeSetId: ID!): ValidateChangeSetPayload!
  """
  Validate resource configuration (transitions DRAFT -> VALIDATING -> VALID/ERROR)
  """
  validateResource(id: ID!, routerId: ID!): ValidateResourcePayload!
  """
  Validate service configuration without applying it.
  Returns validation errors if any.
  """
  validateServiceConfig(input: ValidateServiceConfigInput!): ConfigValidationResult!
  """Verify a fix by re-running the diagnostic step"""
  verifyTroubleshootFix(
    """Session ID"""
    sessionId: ID!
    """Step to verify"""
    stepType: TroubleshootStepType!
  ): RunTroubleshootStepPayload!
}

"""Standard error type for mutations"""
type MutationError {
  """Error code for programmatic handling"""
  code: String!
  """Field that caused the error (if applicable)"""
  field: String
  """Human-readable error message"""
  message: String!
}

"""NAT action types for firewall NAT rules."""
enum NatAction {
  """Accept packet"""
  ACCEPT
  """Drop packet"""
  DROP
  """Destination NAT (port forwarding)"""
  DST_NAT
  """Jump to different chain"""
  JUMP
  """Log packet"""
  LOG
  """Masquerade (dynamic source NAT)"""
  MASQUERADE
  """Network mapping"""
  NETMAP
  """Pass through without action"""
  PASSTHROUGH
  """Redirect to different port"""
  REDIRECT
  """Return to parent chain"""
  RETURN
  """Use same IP"""
  SAME
  """Source NAT (static mapping)"""
  SRC_NAT
}

"""NAT chain types (srcnat for source NAT, dstnat for destination NAT)."""
enum NatChain {
  """Destination NAT (incoming traffic)"""
  DSTNAT
  """Source NAT (outgoing traffic)"""
  SRCNAT
}

"""
NAT rule configuration for network address translation.
Handles both source NAT (masquerade) and destination NAT (port forwarding).
"""
type NatRule implements Node {
  """NAT action"""
  action: NatAction! @mikrotik(path: "/ip/firewall/nat", field: "action")
  """Bytes processed by this rule"""
  bytes: Int! @mikrotik(path: "/ip/firewall/nat", field: "bytes")
  """NAT chain (srcnat or dstnat)"""
  chain: NatChain! @mikrotik(path: "/ip/firewall/nat", field: "chain")
  """Optional comment"""
  comment: String @mikrotik(path: "/ip/firewall/nat", field: "comment")
  """Whether rule is disabled"""
  disabled: Boolean! @mikrotik(path: "/ip/firewall/nat", field: "disabled")
  """Destination address or CIDR"""
  dstAddress: String @mikrotik(path: "/ip/firewall/nat", field: "dst-address")
  """Destination port or port range"""
  dstPort: String @mikrotik(path: "/ip/firewall/nat", field: "dst-port")
  """MikroTik internal ID"""
  id: ID! @mikrotik(path: "/ip/firewall/nat", field: ".id")
  """Incoming interface"""
  inInterface: String @mikrotik(path: "/ip/firewall/nat", field: "in-interface")
  """Outgoing interface"""
  outInterface: String @mikrotik(path: "/ip/firewall/nat", field: "out-interface")
  """Packets processed by this rule"""
  packets: Int! @mikrotik(path: "/ip/firewall/nat", field: "packets")
  """Rule position in chain"""
  position: Int!
  """Protocol (TCP, UDP)"""
  protocol: TransportProtocol @mikrotik(path: "/ip/firewall/nat", field: "protocol")
  """Source address or CIDR"""
  srcAddress: String @mikrotik(path: "/ip/firewall/nat", field: "src-address")
  """Source port or port range"""
  srcPort: String @mikrotik(path: "/ip/firewall/nat", field: "src-port")
  """Target address for NAT"""
  toAddresses: String @mikrotik(path: "/ip/firewall/nat", field: "to-addresses")
  """Target port(s) for NAT"""
  toPorts: String @mikrotik(path: "/ip/firewall/nat", field: "to-ports")
}

"""
NAT rule reference type (lightweight for dependency tracking).
For full NAT rule management, see NatRule type in firewall.graphql.
"""
type NatRuleReference {
  """Action (masquerade, dst-nat, src-nat)"""
  action: String!
  """Rule chain (srcnat, dstnat)"""
  chain: String!
  """Whether the rule is disabled"""
  disabled: Boolean!
  """Destination address"""
  dstAddress: String
  """NAT rule ID"""
  id: ID!
  """Source address"""
  srcAddress: String
  """To address (for dst-nat)"""
  toAddress: String
}

"""Network configuration detection result"""
type NetworkConfigDetection {
  """Detected default gateway IP"""
  gateway: String
  """Detected ISP information"""
  ispInfo: ISPInfo
  """Detected WAN interface name"""
  wanInterface: String!
}

"""
Network device discovered via DHCP and ARP.
Represents a client device on the network that can be routed through service instances.
"""
type NetworkDevice {
  """Whether the device is currently active"""
  active: Boolean!
  """Whether device has an ARP entry"""
  arpEntry: Boolean!
  """Device identifier (generated from MAC address)"""
  deviceID: ID!
  """Whether device has a DHCP lease"""
  dhcpLease: Boolean!
  """Hostname from DHCP (optional)"""
  hostname: String
  """IP address of the device (optional, may change)"""
  ipAddress: String
  """Whether device has a routing assignment"""
  isRouted: Boolean!
  """MAC address of the device"""
  macAddress: String!
  """Current routing mark (if routed)"""
  routingMark: String
  """Source of device discovery (dhcp, arp, or both)"""
  source: String!
}

"""Relay Node interface for global object identification"""
interface Node {
  """Globally unique identifier"""
  id: ID!
}

"""Notification channel types"""
enum NotificationChannel {
  """Email notifications"""
  EMAIL
  """In-app notifications"""
  INAPP
  """Ntfy.sh notifications"""
  NTFY
  """Pushover notifications"""
  PUSHOVER
  """Telegram notifications"""
  TELEGRAM
  """Webhook notifications"""
  WEBHOOK
}

"""Notification channel configuration with encrypted credentials"""
type NotificationChannelConfig {
  """Type of notification channel"""
  channelType: ChannelType!
  """
  Masked configuration (sensitive fields redacted)
  For Pushover: {"device": "iphone", "baseURL": "...", "userKey": "******", "apiToken": "******"}
  For Email: {"host": "smtp.gmail.com", "port": 587, "from": "...", "password": "******"}
  """
  configMasked: JSON!
  """When this configuration was created"""
  createdAt: DateTime!
  """User ID who created this configuration"""
  createdBy: String
  """Optional description"""
  description: String
  """Whether this configuration is enabled"""
  enabled: Boolean!
  """Unique configuration ID"""
  id: ID!
  """Whether this is the default configuration for this channel type"""
  isDefault: Boolean!
  """Human-readable name for this configuration"""
  name: String!
  """When this configuration was last updated"""
  updatedAt: DateTime!
  """User ID who last updated this configuration"""
  updatedBy: String
}

"""Notification delivery log entry"""
type NotificationLog implements Node {
  """Alert that triggered this notification"""
  alertId: ID!
  """When delivery was attempted"""
  attemptedAt: DateTime!
  """Notification channel type (email, telegram, pushover, webhook)"""
  channel: String!
  """When delivery was completed (success or final failure)"""
  completedAt: DateTime
  """Error message if delivery failed"""
  errorMessage: String
  """Globally unique identifier"""
  id: ID!
  """Request payload sent"""
  requestPayload: JSON
  """Response body received"""
  responseBody: String
  """Response time in milliseconds"""
  responseTimeMs: Int
  """Number of retry attempts"""
  retryCount: Int!
  """Delivery status"""
  status: NotificationStatus!
  """HTTP status code (for webhooks)"""
  statusCode: Int
  """Webhook ID (if channel is webhook)"""
  webhookId: ID
}

"""Notification delivery status"""
enum NotificationStatus {
  """Delivery failed"""
  FAILED
  """Delivery pending"""
  PENDING
  """Retrying after failure"""
  RETRYING
  """Successfully delivered"""
  SUCCESS
}

"""
Notification template preview result
Simplified preview output for template customization
"""
type NotificationTemplatePreview {
  """Rendered body content"""
  body: String!
  """Validation errors (empty array if valid)"""
  errors: [String!]!
  """Rendered subject line (empty if channel doesn't use subjects)"""
  subject: String
}

"""Ntfy.sh notification configuration input"""
input NtfyChannelInput {
  """Whether ntfy notifications are enabled"""
  enabled: Boolean!
  """Optional password for authentication"""
  password: String
  """Message priority (1-5, default: 3)"""
  priority: Int
  """Ntfy server URL (e.g., https://ntfy.sh or self-hosted)"""
  serverUrl: String!
  """Optional tags for categorization"""
  tags: [String!]
  """Topic to publish to"""
  topic: String!
  """Optional username for authentication"""
  username: String
}

"""Operation counts by type"""
type OperationCounts {
  create: Int!
  delete: Int!
  update: Int!
}

"""Payload for orphan cleanup mutation."""
type OrphanCleanupPayload {
  """Number of orphaned allocations cleaned up"""
  cleanedCount: Int!
  """List of allocation IDs that were deleted"""
  deletedAllocationIDs: [ID!]!
  """Mutation errors"""
  errors: [MutationError!]
}

"""
Orphaned port allocation that references a non-existent service instance.
"""
type OrphanedPort {
  """Port allocation record"""
  allocation: PortAllocation!
  """Reason why this allocation is orphaned"""
  reason: String!
}

"""Information about pagination in a connection"""
type PageInfo {
  """Cursor for the last edge"""
  endCursor: String
  """When paginating forwards, are there more items?"""
  hasNextPage: Boolean!
  """When paginating backwards, are there more items?"""
  hasPreviousPage: Boolean!
  """Cursor for the first edge"""
  startCursor: String
}

"""Standard pagination input arguments"""
input PaginationInput {
  """Cursor to fetch items after"""
  after: String
  """Cursor to fetch items before"""
  before: String
  """Number of items to fetch"""
  first: Int
  """Number of items to fetch from the end"""
  last: Int
}

"""Platform capabilities for a resource type"""
type PlatformCapabilities {
  """Capability-specific details"""
  details: JSON
  """Whether this resource type is supported"""
  isSupported: Boolean!
  """Capability level"""
  level: CapabilityLevel!
  """Minimum platform version required"""
  minVersion: String
  """Required packages"""
  requiredPackages: [String!]
}

"""A platform-specific feature"""
type PlatformFeature {
  """Feature description"""
  description: String
  """Whether feature is enabled"""
  enabled: Boolean!
  """Feature identifier"""
  id: String!
  """Feature name"""
  name: String!
}

"""
Layer 8: Platform-specific capabilities and field mappings.
From platform adapter (MikroTik, OpenWrt, VyOS).
"""
type PlatformInfo {
  """Platform-specific capabilities for this resource type"""
  capabilities: PlatformCapabilities!
  """Current platform"""
  current: RouterPlatform!
  """Platform-specific features available"""
  features: [PlatformFeature!]
  """Field mappings between GraphQL and platform-native names"""
  fieldMappings: JSON
  """Platform-specific limitations or constraints"""
  limitations: [PlatformLimitation!]
}

"""A platform-specific limitation"""
type PlatformLimitation {
  """Affected fields"""
  affectedFields: [String!]
  """Limitation identifier"""
  code: String!
  """Human-readable description"""
  description: String!
  """Workaround if available"""
  workaround: String
}

"""TCP/UDP port number (1-65535)"""
scalar Port

"""
A port allocation record tracking which ports are in use by service instances.
Prevents port conflicts and enables centralized port management.
"""
type PortAllocation implements Node {
  """Allocation timestamp"""
  allocatedAt: DateTime!
  """ULID primary key"""
  id: ID!
  """Service instance ID that owns this allocation"""
  instanceID: String!
  """Optional notes about this port allocation"""
  notes: String
  """Port number (1-65535)"""
  port: Int!
  """Transport protocol (TCP or UDP)"""
  protocol: PortProtocol!
  """The router where this port is allocated"""
  router: Router
  """Router ID where this port is allocated"""
  routerID: String!
  """The service instance that owns this port allocation"""
  serviceInstance: ServiceInstance
  """Service type (e.g., 'tor', 'xray-core', 'adguard-home')"""
  serviceType: String!
}

"""Port availability check result."""
type PortAvailability {
  """Whether the port is available for allocation"""
  available: Boolean!
  """Port number checked"""
  port: Int!
  """Protocol checked"""
  protocol: PortProtocol!
  """Reason why port is unavailable (if applicable)"""
  reason: String
}

"""
Port forward configuration (high-level view).
Represents both the NAT rule and corresponding filter rule.
"""
type PortForward implements Node {
  """External port"""
  externalPort: Int!
  """ID of the associated filter rule (if created)"""
  filterRuleId: ID
  """Unique identifier"""
  id: ID!
  """Internal target IP"""
  internalIP: String!
  """Internal target port"""
  internalPort: Int!
  """Optional name/description"""
  name: String
  """ID of the associated NAT rule"""
  natRuleId: ID!
  """Protocol (TCP, UDP)"""
  protocol: TransportProtocol!
  """Current status"""
  status: PortForwardStatus!
}

"""
Input for creating a port forward (simplified wizard).
Creates both NAT and filter rules automatically.
"""
input PortForwardInput {
  """External port (1-65535)"""
  externalPort: Int! @validate(min: 1, max: 65535)
  """Internal target IP address"""
  internalIP: String!
  """Internal target port (defaults to external port if not specified)"""
  internalPort: Int @validate(min: 1, max: 65535)
  """Optional name/description for this port forward"""
  name: String @validate(minLength: 1, maxLength: 100)
  """Protocol (TCP, UDP)"""
  protocol: TransportProtocol!
  """WAN interface name (optional, auto-detected if not specified)"""
  wanInterface: String
}

"""Status of a port forward configuration."""
enum PortForwardStatus {
  """Port forward is active and working"""
  ACTIVE
  """Port forward is disabled"""
  DISABLED
  """Port forward has errors or misconfiguration"""
  ERROR
  """Port forward is partially configured (missing rules)"""
  INCOMPLETE
}

"""Port knock attempt log entry."""
type PortKnockAttempt implements Node {
  """Attempt ID"""
  id: ID!
  """Ports hit in order"""
  portsHit: [Int!]!
  """Progress indicator (e.g., "2/4")"""
  progress: String!
  """Protected service port"""
  protectedPort: Int!
  """Sequence ID"""
  sequenceId: ID!
  """Sequence name"""
  sequenceName: String!
  """Source IP address"""
  sourceIP: String!
  """Attempt status"""
  status: KnockStatus!
  """Attempt timestamp"""
  timestamp: DateTime!
}

"""Connection type for paginated knock attempts."""
type PortKnockAttemptConnection implements Connection {
  edges: [PortKnockAttemptEdge!]!
  pageInfo: PageInfo!
  totalCount: Int
}

"""Edge type for knock attempt connections."""
type PortKnockAttemptEdge implements Edge {
  cursor: String!
  node: PortKnockAttempt!
}

"""Filters for knock attempt log."""
input PortKnockLogFilters {
  """End date"""
  endDate: DateTime
  """Filter by sequence ID"""
  sequenceId: ID
  """Filter by source IP"""
  sourceIP: String
  """Start date"""
  startDate: DateTime
  """Filter by status"""
  status: KnockStatus
}

"""
Port knocking sequence configuration.
Implements stage-based address list progression for hiding services.
"""
type PortKnockSequence implements Node {
  """Access timeout after successful knock"""
  accessTimeout: String!
  """When sequence was created"""
  createdAt: DateTime!
  """Whether sequence is enabled"""
  enabled: Boolean!
  """Generated firewall rule IDs"""
  generatedRuleIds: [ID!]!
  """Unique sequence identifier"""
  id: ID!
  """Ordered list of knock ports (2-8 ports)"""
  knockPorts: [KnockPort!]!
  """Max time between knocks"""
  knockTimeout: String!
  """Sequence name (alphanumeric, underscores, hyphens)"""
  name: String!
  """Protected service port"""
  protectedPort: Int!
  """Protected service protocol"""
  protectedProtocol: TransportProtocol!
  """Successful knocks in last 24h"""
  recentAccessCount: Int!
  """Router ID"""
  routerId: ID!
  """When sequence was last updated"""
  updatedAt: DateTime!
}

"""Input for creating/updating port knock sequence."""
input PortKnockSequenceInput {
  """Access timeout (e.g., "5m", "1h")"""
  accessTimeout: String! @validate(pattern: "^\\d+[smhd]$")
  """Whether enabled"""
  enabled: Boolean
  """Ordered knock ports (2-8)"""
  knockPorts: [KnockPortInput!]!
  """Knock timeout (e.g., "15s", "30s")"""
  knockTimeout: String! @validate(pattern: "^\\d+[smhd]$")
  """Sequence name"""
  name: String! @validate(minLength: 1, maxLength: 32, pattern: "^[a-zA-Z0-9_-]+$")
  """Protected service port"""
  protectedPort: Int! @validate(min: 1, max: 65535)
  """Protected service protocol"""
  protectedProtocol: TransportProtocol!
}

"""Port mapping specification"""
type PortMapping {
  """Host port (0 = auto-allocate)"""
  external: Int!
  """Container port"""
  internal: Int!
  """Protocol (tcp/udp)"""
  protocol: String!
  """Purpose description"""
  purpose: String
}

"""A port mirror configuration for traffic monitoring and analysis"""
type PortMirror implements Node {
  """User comment"""
  comment: String @validate(maxLength: 255)
  """Destination interface where mirrored traffic is sent"""
  destinationInterface: Interface! @mikrotik(path: "/interface/bridge/port", field: "mirror-target")
  """Direction of traffic to mirror"""
  direction: MirrorDirection!
  """Whether the mirror is enabled"""
  enabled: Boolean!
  """Unique port mirror identifier"""
  id: ID!
  """Descriptive name for the mirror configuration"""
  name: String! @validate(minLength: 1, maxLength: 100, pattern: "^[a-zA-Z0-9_-]+$")
  """Source interfaces being mirrored"""
  sourceInterfaces: [Interface!]! @mikrotik(path: "/interface/bridge/port", field: "interface")
  """Statistics for the destination interface"""
  statistics: PortMirrorStats
}

"""Result of a port mirror mutation (create, update)"""
type PortMirrorMutationResult {
  """Errors that occurred during the operation"""
  errors: [MutationError!]
  """The created or updated port mirror (if successful)"""
  portMirror: PortMirror
  """Configuration preview (RouterOS commands)"""
  preview: ConfigPreview
  """Whether the operation succeeded"""
  success: Boolean!
}

"""Statistics for a port mirror destination interface"""
type PortMirrorStats {
  """Destination interface current load"""
  destinationLoad: Float!
  """Whether the destination is saturated (dropping packets)"""
  isSaturated: Boolean!
  """Total mirrored bytes"""
  mirroredBytes: Size!
  """Total mirrored packets"""
  mirroredPackets: Size!
}

"""Port mode for VLAN configuration"""
enum PortMode {
  """Access port (single VLAN, untagged)"""
  ACCESS
  """Trunk port (carries multiple VLANs with tagging)"""
  TRUNK
}

"""Transport protocol for port allocations."""
enum PortProtocol {
  """TCP protocol"""
  TCP
  """UDP protocol"""
  UDP
}

"""Port range string (e.g., "80", "80-443", "80,443,8080")"""
scalar PortRange

"""Status of a single port check"""
type PortStatus {
  """Error message (if port is closed)"""
  error: String
  """Whether the port is open and accepting connections"""
  open: Boolean!
  """Port number checked"""
  port: Int!
  """Response time in milliseconds (if port is open)"""
  responseTimeMs: Int
  """Service name (API, API-SSL, SSH, Telnet, HTTP, HTTPS)"""
  service: String!
}

"""PPPoE client configuration for dial-up WAN"""
type PppoeClient implements Node {
  """Add default route"""
  addDefaultRoute: Boolean! @mikrotik(path: "/interface/pppoe-client", field: "add-default-route")
  """User comment"""
  comment: String @mikrotik(path: "/interface/pppoe-client", field: "comment")
  """Whether PPPoE is disabled"""
  disabled: Boolean! @mikrotik(path: "/interface/pppoe-client", field: "disabled")
  """Unique identifier"""
  id: ID!
  """Underlying interface (ethernet/bridge)"""
  interface: String! @mikrotik(path: "/interface/pppoe-client", field: "interface")
  """MRU setting"""
  mru: Int @mikrotik(path: "/interface/pppoe-client", field: "mru")
  """MTU setting"""
  mtu: Int @mikrotik(path: "/interface/pppoe-client", field: "mtu")
  """PPPoE interface name"""
  name: String! @mikrotik(path: "/interface/pppoe-client", field: "name")
  """Current connection status"""
  running: Boolean! @mikrotik(path: "/interface/pppoe-client", field: "running")
  """Service name (optional)"""
  serviceName: String @mikrotik(path: "/interface/pppoe-client", field: "service-name")
  """Use peer DNS"""
  usePeerDNS: Boolean! @mikrotik(path: "/interface/pppoe-client", field: "use-peer-dns")
  """Username for authentication"""
  username: String! @mikrotik(path: "/interface/pppoe-client", field: "user")
}

"""Input for creating/updating PPPoE client"""
input PppoeClientInput {
  """Add default route (default: true)"""
  addDefaultRoute: Boolean
  """User comment"""
  comment: String @validate(maxLength: 255)
  """Physical interface (ether1, bridge, etc.)"""
  interface: String! @validate(minLength: 1, maxLength: 100)
  """MRU (default: auto)"""
  mru: Int @validate(min: 576, max: 1500)
  """MTU (default: auto)"""
  mtu: Int @validate(min: 576, max: 1500)
  """PPPoE interface name"""
  name: String! @validate(minLength: 1, maxLength: 100, pattern: "^[a-zA-Z0-9_-]+$")
  """Password for ISP authentication"""
  password: String! @validate(minLength: 1, maxLength: 128)
  """Service name (optional, ISP-specific)"""
  serviceName: String @validate(maxLength: 100)
  """Use peer DNS (default: true)"""
  usePeerDNS: Boolean
  """Username for ISP authentication"""
  username: String! @validate(minLength: 1, maxLength: 128)
}

"""
Input for previewing a notification template
Simpler input for template customization workflow
"""
input PreviewNotificationTemplateInput {
  """Body template with Go template syntax"""
  bodyTemplate: String!
  """Notification channel"""
  channel: NotificationChannel!
  """Event type for sample data generation"""
  eventType: String!
  """Subject template (optional, not all channels use subjects)"""
  subjectTemplate: String
}

"""Protocol used for router communication"""
enum Protocol {
  """Binary API protocol (port 8728)"""
  API
  """TLS-encrypted binary API (port 8729)"""
  API_SSL
  """REST API protocol (RouterOS 7.1+)"""
  REST
  """SSH protocol (port 22)"""
  SSH
  """Telnet protocol (port 23)"""
  TELNET
}

"""
User preference for which protocol to use when connecting to a router.
AUTO will try protocols in the recommended fallback order.
"""
enum ProtocolPreference {
  """Force Binary API protocol (port 8728)"""
  API
  """Force TLS-encrypted binary API (port 8729)"""
  API_SSL
  """
  Automatically detect best protocol (REST -> API -> API_SSL -> SSH -> Telnet)
  """
  AUTO
  """Force REST API protocol (RouterOS 7.1+)"""
  REST
  """Force SSH protocol (port 22)"""
  SSH
  """Force Telnet protocol (port 23, insecure - use only as last resort)"""
  TELNET
}

"""Pushover API usage statistics"""
type PushoverUsage {
  """Monthly message limit"""
  limit: Int!
  """Number of messages remaining this month"""
  remaining: Int!
  """When the usage counter resets"""
  resetAt: DateTime!
  """Number of messages used this month"""
  used: Int!
}

type Query {
  """
  Get entries for a specific address list with cursor-based pagination.
  Supports infinite scrolling for large lists (10,000+ entries).
  """
  addressListEntries(after: String, first: Int, listName: String!, routerId: ID!): AddressListEntryConnection!
  """
  Get all address lists with aggregated statistics.
  Returns a list of address lists with entry counts and referencing rule counts.
  """
  addressLists(routerId: ID!): [AddressList!]!
  """Get alert escalations with optional filtering (NAS-18.9)"""
  alertEscalations(
    """Pagination limit"""
    limit: Int = 50
    """Pagination offset"""
    offset: Int = 0
    """Filter by escalation status"""
    status: EscalationStatus
  ): [AlertEscalation!]!
  """Get a single alert rule by ID"""
  alertRule(
    """Alert rule ID"""
    id: ID!
  ): AlertRule
  """Get a single alert rule template by ID"""
  alertRuleTemplate(
    """Template ID"""
    id: ID!
  ): AlertRuleTemplate
  """Get alert rule templates, optionally filtered by category"""
  alertRuleTemplates(
    """Filter by category"""
    category: AlertRuleTemplateCategory
  ): [AlertRuleTemplate!]!
  """
  Get throttle status for alert rules
  Returns throttle information for all rules or a specific rule
  """
  alertRuleThrottleStatus(
    """Optional rule ID to filter by specific rule"""
    ruleId: ID
  ): [ThrottleStatus!]!
  """Get all alert rules, optionally filtered by device"""
  alertRules(
    """Filter by device ID"""
    deviceId: ID
  ): [AlertRule!]!
  """
  Get current storm detection status
  Shows if alert storm is detected and which rules are contributing
  """
  alertStormStatus: StormStatus!
  """Get a single alert template by ID"""
  alertTemplate(
    """Template ID"""
    id: ID!
  ): AlertTemplate
  """Get all alert templates, optionally filtered by event type or channel"""
  alertTemplates(
    """Filter by notification channel"""
    channel: NotificationChannel
    """Filter by event type"""
    eventType: String
  ): [AlertTemplate!]!
  """Get alerts with filtering and pagination"""
  alerts(
    """Filter by acknowledged status"""
    acknowledged: Boolean
    """Filter by device ID"""
    deviceId: ID
    """Pagination limit"""
    limit: Int = 50
    """Pagination offset"""
    offset: Int = 0
    """Filter by severity"""
    severity: AlertSeverity
  ): AlertConnection!
  """
  Get available diagnostic tests for a service type.
  Returns the diagnostic suite definition.
  """
  availableDiagnostics(
    """Service name (e.g., 'tor', 'singbox', 'adguard')"""
    serviceName: String!
  ): DiagnosticSuite!
  """
  Get interfaces available to add to a bridge (not already in any bridge)
  """
  availableInterfacesForBridge(routerId: ID!): [Interface!]!
  """List all available services from the Feature Marketplace."""
  availableServices(
    """Filter by architecture"""
    architecture: String
    """Filter by category"""
    category: String
  ): [AvailableService!]!
  """
  Get available updates for all instances on a router.
  Returns instances that have updates available.
  """
  availableUpdates(
    """Router ID"""
    routerID: ID!
  ): [UpdateInfo!]!
  """Get the current boot sequence progress (if running)."""
  bootSequenceProgress: BootSequenceProgress
  """Get a single bridge by UUID"""
  bridge(uuid: ID!): Bridge
  """Get bridge ports"""
  bridgePorts(bridgeId: ID!): [BridgePort!]!
  """
  Get bridge status for a service instance.
  Includes interface and gateway health status.
  """
  bridgeStatus(
    """Instance ID"""
    instanceID: ID!
    """Router ID"""
    routerID: ID!
  ): BridgeStatus!
  """Get bridge VLANs"""
  bridgeVlans(bridgeId: ID!): [BridgeVlan!]!
  """List all bridges on a router"""
  bridges(routerId: ID!): [Bridge!]!
  """Get a change set by ID"""
  changeSet(
    """Change set ID"""
    id: ID!
    """Router the change set belongs to"""
    routerId: ID!
  ): ChangeSet
  """List change sets for a router"""
  changeSets(
    """Include completed/failed (default: false)"""
    includeCompleted: Boolean = false
    """Router to query"""
    routerId: ID!
    """Filter by status"""
    status: ChangeSetStatus
  ): [ChangeSetSummary!]!
  """Check if a gateway address is reachable from the router"""
  checkGatewayReachability(
    """Gateway IP address to check"""
    gateway: IPv4!
    """Router ID"""
    routerId: ID!
  ): GatewayReachabilityResult! @capability(requires: ["routing"])
  """Check if an IP address conflicts with existing assignments"""
  checkIpConflict(
    """IP address to check (CIDR notation)"""
    address: String!
    """Exclude this IP ID from conflict check (for updates)"""
    excludeId: ID
    """Interface ID (optional, for scoped check)"""
    interfaceId: ID
    """Router ID"""
    routerId: ID!
  ): IpConflictResult! @capability(requires: ["interface"])
  """Check if a VLAN ID is available on a parent interface"""
  checkVlanIdAvailable(
    """Parent interface ID"""
    parentInterface: ID!
    """Router ID"""
    routerId: ID!
    """VLAN ID to check"""
    vlanId: Int!
  ): Boolean! @capability(requires: ["interface"])
  """
  Get circuit breaker status for a router.
  Shows current state, failure counts, and cooldown timing.
  """
  circuitBreakerStatus(routerId: ID!): CircuitBreakerStatus!
  """Get common event types"""
  commonEventTypes: [String!]!
  """Get the compatibility matrix for all known features"""
  compatibilityMatrix: [FeatureCompatibilityInfo!]!
  """Get composite resource with all related sub-resources"""
  compositeResource(
    """Resource ID (ULID)"""
    id: ID!
    """Router the resource belongs to"""
    routerId: ID!
  ): CompositeResource
  """
  Get recent connection attempts for a router.
  Returns the most recent attempts, ordered newest first.
  """
  connectionAttempts(
    """Maximum number of attempts to return (default: 10)"""
    limit: Int = 10
    """Router ID to get attempts for"""
    routerId: ID!
  ): [ConnectionAttempt!]!
  """Get detailed connection status for a router"""
  connectionDetails(routerId: ID!): ConnectionDetails
  """Get connection manager statistics"""
  connectionStats: ConnectionStats!
  """Get the default configuration for a specific channel type"""
  defaultNotificationChannelConfig(
    """Channel type"""
    channelType: ChannelType!
  ): NotificationChannelConfig
  """Get the full dependency graph for a router (for visualization)."""
  dependencyGraph(routerId: ID!): DependencyGraph!
  """Detect default gateway from DHCP client or static route"""
  detectGateway(routerId: ID!): String
  """Detect ISP information from WAN IP"""
  detectISP(routerId: ID!): ISPInfo
  """
  Detect orphaned port allocations (allocated to non-existent instances).
  """
  detectOrphanedPorts(
    """Router ID to check (if not provided, checks all routers)"""
    routerID: ID
  ): [OrphanedPort!]!
  """
  Detect orphaned VLAN allocations for a router.
  
  An allocation is orphaned if:
  - Its ServiceInstance no longer exists
  - Its ServiceInstance is in "deleting" status
  
  This is a diagnostic query - use cleanupOrphanedVLANs mutation to actually remove them.
  
  Example:
  ```
  query {
    detectOrphanedVLANs(routerID: "router-123") {
      id
      vlanID
      instanceID
      serviceType
      allocatedAt
    }
  }
  ```
  """
  detectOrphanedVLANs(
    """Router ID to check for orphans"""
    routerID: String!
  ): [VLANAllocation!]!
  """Detect WAN interface from default route"""
  detectWanInterface(routerId: ID!): String!
  """Get a device by ID for resource metrics"""
  device(id: ID!): Device
  """Get a specific device routing assignment."""
  deviceRouting(
    """Router ID"""
    routerID: ID!
    """Device routing ID"""
    routingID: ID!
  ): DeviceRouting
  """
  Get the complete device routing matrix for a router.
  Includes discovered devices, available interfaces, and current routings.
  """
  deviceRoutingMatrix(
    """Router ID"""
    routerID: ID!
  ): DeviceRoutingMatrix!
  """Get all device routing assignments for a router."""
  deviceRoutings(
    """Router ID"""
    routerID: ID!
  ): [DeviceRouting!]!
  """
  Get diagnostic history for a service instance.
  Returns past diagnostic results grouped by run_group_id.
  """
  diagnosticHistory(
    """Instance ID"""
    instanceID: ID!
    """Maximum number of run groups to return (default 10)"""
    limit: Int
    """Router ID"""
    routerID: ID!
  ): [StartupDiagnostics!]!
  """Get digest delivery history for a channel (NAS-18.11)"""
  digestHistory(
    """Channel ID to get history for"""
    channelId: ID!
    """Limit number of results (default: 10)"""
    limit: Int = 10
  ): [DigestSummary!]!
  """Get the number of alerts in the digest queue for a channel (NAS-18.11)"""
  digestQueueCount(
    """Channel ID to check queue for"""
    channelId: ID!
  ): Int!
  """
  Run DNS server benchmark against all configured DNS servers.
  Tests each server with a well-known hostname (google.com) and returns
  response times sorted from fastest to slowest.
  """
  dnsBenchmark(
    """Device/router ID"""
    deviceId: String!
  ): DnsBenchmarkResult!
  """
  Get DNS cache statistics including entries, size, hit rate, and top domains.
  """
  dnsCacheStats(
    """Device/router ID"""
    deviceId: String!
  ): DnsCacheStats!
  """
  Get configured DNS servers for a device.
  Returns primary and secondary DNS servers configured on the router.
  """
  dnsServers(
    """Device/router ID"""
    deviceId: String!
  ): DnsServers!
  """
  Get gateway status for a service instance.
  Returns gateway state for SOCKS-to-TUN gateways.
  """
  gatewayStatus(
    """Instance ID"""
    instanceID: ID!
  ): GatewayInfo!
  """Get system health status"""
  health: HealthStatus!
  """
  Get current configuration for a service instance.
  Returns the persisted configuration from the database.
  """
  instanceConfig(
    """Service instance ID"""
    instanceID: ID!
    """Router ID"""
    routerID: ID!
  ): JSON!
  """
  Get current health status for a service instance
  Returns null if instance not found or health monitoring not enabled
  """
  instanceHealth(
    """Service instance ID"""
    instanceID: ID!
    """Router ID"""
    routerID: ID!
  ): ServiceInstanceHealth
  """
  Get isolation status for a specific service instance.
  Returns complete isolation check results and resource limits.
  """
  instanceIsolation(
    """Instance ID"""
    instanceID: ID!
    """Router ID"""
    routerID: ID!
  ): IsolationStatus!
  """
  Get update information for a specific instance.
  Returns null if no update available.
  """
  instanceUpdateInfo(
    """Instance ID"""
    instanceID: ID!
    """Router ID"""
    routerID: ID!
  ): UpdateInfo
  """
  Get verification status for all instances on a router.
  Returns only instances with verification enabled.
  """
  instanceVerificationStatus(
    """Router ID"""
    routerID: ID!
  ): [BinaryVerification!]!
  """Get a network interface by ID"""
  interface(
    """Interface ID"""
    id: ID!
    """Router to query"""
    routerId: ID!
  ): Interface @capability(requires: ["interface"])
  """Get historical interface statistics for bandwidth analysis"""
  interfaceStatsHistory(
    """Interface ID"""
    interfaceId: ID!
    """Aggregation interval (default: 5m)"""
    interval: Duration = "5m"
    """Router ID"""
    routerId: ID!
    """Time range for the query"""
    timeRange: StatsTimeRangeInput!
  ): InterfaceStatsHistory! @capability(requires: ["interface"])
  """List interfaces on a router"""
  interfaces(
    """Pagination parameters"""
    pagination: PaginationInput
    """Router to query"""
    routerId: ID!
    """Filter by interface type"""
    type: InterfaceType
  ): InterfaceConnection! @capability(requires: ["interface"])
  """Get a specific IP address by ID"""
  ipAddress(
    """IP address ID"""
    id: ID!
    """Router ID"""
    routerId: ID!
  ): IpAddress @capability(requires: ["interface"])
  """Get dependencies for an IP address (DHCP servers, routes, etc.)"""
  ipAddressDependencies(
    """IP address ID"""
    id: ID!
    """Router ID"""
    routerId: ID!
  ): IpAddressDependencies! @capability(requires: ["interface"])
  """Get all IP addresses on a router with optional filtering"""
  ipAddresses(
    """Optional: filter by interface ID"""
    interfaceId: ID
    """Router ID to query"""
    routerId: ID!
  ): [IpAddress!]! @capability(requires: ["interface"])
  """Get available IPsec profiles for GRE tunnel encryption"""
  ipsecProfiles(
    """Router ID to query"""
    routerId: ID!
  ): [IpsecProfile!]! @capability(requires: ["interface"])
  """Check if a feature is supported on a specific router"""
  isFeatureSupported(
    """Feature identifier"""
    featureId: String!
    """Router to check"""
    routerId: ID!
  ): FeatureSupport!
  """Check if a specific port is available for allocation."""
  isPortAvailable(input: CheckPortAvailabilityInput!): PortAvailability!
  """
  Get kill switch status for a specific device routing.
  Returns current kill switch configuration and state.
  """
  killSwitchStatus(
    """Device ID"""
    deviceID: String!
    """Router ID"""
    routerID: ID!
  ): KillSwitchStatus!
  """Get current authenticated user"""
  me: User @auth
  """Get all active sessions for the current user"""
  mySessions: [Session!]! @auth
  """Get NAT rules, optionally filtered by chain."""
  natRules(chain: NatChain, routerId: ID!): [NatRule!]!
  """Fetch any node by its global ID"""
  node(id: ID!): Node
  """Get a specific notification channel configuration by ID"""
  notificationChannelConfig(
    """Configuration ID"""
    id: ID!
  ): NotificationChannelConfig
  """
  List all notification channel configurations (optionally filtered by type)
  """
  notificationChannelConfigs(
    """Filter by channel type"""
    channelType: ChannelType
  ): [NotificationChannelConfig!]!
  """Get notification delivery logs"""
  notificationLogs(
    """Filter by alert ID"""
    alertId: ID
    """Filter by channel type"""
    channel: String
    """Pagination limit"""
    limit: Int = 50
    """Pagination offset"""
    offset: Int = 0
    """Filter by webhook ID"""
    webhookId: ID
  ): [NotificationLog!]!
  """
  List all port allocations, optionally filtered by router, protocol, or service type.
  """
  portAllocations(
    """Filter by protocol"""
    protocol: PortProtocol
    """Filter by router ID"""
    routerID: ID
    """Filter by service type"""
    serviceType: String
  ): [PortAllocation!]!
  """Get all port forwards (high-level view)."""
  portForwards(routerId: ID!): [PortForward!]!
  """Get port knock attempt log with filtering."""
  portKnockLog(after: String, filters: PortKnockLogFilters, first: Int, routerId: ID!): PortKnockAttemptConnection!
  """Get single port knock sequence by ID."""
  portKnockSequence(id: ID!, routerId: ID!): PortKnockSequence
  """Get all port knock sequences for a router."""
  portKnockSequences(routerId: ID!): [PortKnockSequence!]!
  """Get a specific port mirror by ID"""
  portMirror(
    """Port mirror ID"""
    id: ID!
    """Router ID"""
    routerId: ID!
  ): PortMirror @capability(requires: ["interface"])
  """Get all port mirror configurations on a router"""
  portMirrors(
    """Router ID to query"""
    routerId: ID!
  ): [PortMirror!]! @capability(requires: ["interface"])
  """Preview an alert rule template with variable substitution"""
  previewAlertRuleTemplate(
    """Template ID"""
    templateId: ID!
    """Variables for substitution"""
    variables: JSON!
  ): AlertRuleTemplatePreview!
  """Preview an alert template with variables"""
  previewAlertTemplate(
    """Template ID"""
    templateId: ID!
    """Variables for substitution"""
    variables: JSON!
  ): TemplatePreviewPayload!
  """Get Pushover API usage statistics"""
  pushoverUsage: PushoverUsage
  """Get a resource by ID"""
  resource(
    """Resource ID (ULID)"""
    id: ID!
    """Specific layers to fetch (default: all)"""
    layers: [ResourceLayer!]
    """Router the resource belongs to"""
    routerId: ID!
  ): Resource
  """List resources for a router"""
  resources(
    """Filter by category"""
    category: ResourceCategory
    """Pagination parameters"""
    pagination: PaginationInput
    """Router to query"""
    routerId: ID!
    """Filter by lifecycle state"""
    state: ResourceLifecycleState
    """Filter by type"""
    type: String
  ): ResourceConnection!
  """Get a specific route by ID"""
  route(
    """Route ID"""
    id: ID!
    """Router ID"""
    routerId: ID!
  ): Route @capability(requires: ["routing"])
  """
  Look up which route will be used for a destination IP.
  Supports optional source address for policy routing testing.
  """
  routeLookup(destination: IPv4!, routerId: ID!, source: IPv4): RouteLookupResult!
  """Get a router by ID"""
  router(id: ID!): Router
  """Get router capabilities by router ID"""
  routerCapabilities(routerId: ID!): RouterCapabilities
  """Get credential information for a router (password is never returned)"""
  routerCredentials(routerId: ID!): RouterCredentials @auth
  """Get health check result for a router"""
  routerHealth(routerId: ID!): HealthCheckResult
  """List all managed routers"""
  routers(
    """Pagination parameters"""
    pagination: PaginationInput
    """Filter by connection status"""
    status: ConnectionStatus
  ): RouterConnection!
  """Get all routes on a router with optional filtering"""
  routes(
    """Router ID to query"""
    routerId: ID!
    """Filter by routing table name (main, vpn, etc.)"""
    table: String
    """Filter by route type (STATIC, CONNECTED, DYNAMIC, etc.)"""
    type: RouteType
  ): [Route!]! @capability(requires: ["routing"])
  """Get the routing chain for a specific device, if any."""
  routingChain(
    """Device ID"""
    deviceID: ID!
    """Router ID"""
    routerID: ID!
  ): RoutingChain
  """List all routing chains for a router."""
  routingChains(
    """Router ID"""
    routerID: ID!
  ): [RoutingChain!]!
  """Get a specific routing schedule by ID."""
  routingSchedule(
    """Router ID"""
    routerID: ID!
    """Schedule ID"""
    scheduleID: ID!
  ): RoutingSchedule
  """
  Get all schedules for a device routing.
  Returns schedules ordered by start time.
  """
  routingSchedules(
    """Router ID"""
    routerID: ID!
    """Device routing ID"""
    routingID: ID!
  ): [RoutingSchedule!]!
  """
  Get firewall rules that reference a specific address list.
  Includes filter, NAT, and mangle rules.
  """
  rulesReferencingAddressList(listName: String!, routerId: ID!): [FirewallRule!]!
  """Get scan history (recent scans)"""
  scanHistory(
    """Maximum number of results to return"""
    limit: Int = 10
  ): [ScanTask!]!
  """Get the status of a scan task by ID"""
  scanStatus(taskId: ID!): ScanTask
  """Search alert templates"""
  searchAlertTemplates(
    """Search query"""
    query: String!
  ): [AlertTemplate!]!
  """
  Get alerts for a specific service instance
  Filters alerts by source_type='service' and source_id=instanceId
  """
  serviceAlerts(
    """Filter by acknowledged status"""
    acknowledged: Boolean
    """Service instance ID to filter alerts for"""
    instanceId: ID!
    """Pagination limit"""
    limit: Int = 50
    """Pagination offset"""
    offset: Int = 0
    """Filter by severity"""
    severity: AlertSeverity
  ): AlertConnection!
  """
  Get configuration schema for a service type.
  Returns field definitions for dynamic form generation.
  """
  serviceConfigSchema(
    """Service type (e.g., 'tor', 'sing-box', 'xray')"""
    serviceType: String!
  ): ConfigSchema!
  """Get all dependencies of a service instance (services it depends on)."""
  serviceDependencies(instanceId: ID!): [ServiceDependency!]!
  """Get all dependents of a service instance (services that depend on it)."""
  serviceDependents(instanceId: ID!): [ServiceDependency!]!
  """
  Get per-device traffic breakdown for a service instance.
  Shows which devices are using bandwidth through this service.
  """
  serviceDeviceBreakdown(
    """Instance ID"""
    instanceID: ID!
    """Router ID"""
    routerID: ID!
  ): [DeviceTrafficBreakdown!]!
  """Get a specific service instance."""
  serviceInstance(
    """Instance ID"""
    instanceID: ID!
    """Router ID"""
    routerID: ID!
  ): ServiceInstance
  """List all service instances for a router."""
  serviceInstances(
    """Filter by feature ID"""
    featureID: String
    """Router ID"""
    routerID: ID!
    """Filter by status"""
    status: ServiceInstanceStatus
  ): [ServiceInstance!]!
  """
  Get recent log entries for a service instance.
  Returns the last N lines from the log file.
  """
  serviceLogFile(
    """Instance ID"""
    instanceID: ID!
    """Maximum number of lines to return (default 100)"""
    maxLines: Int
    """Router ID"""
    routerID: ID!
  ): ServiceLogFile!
  """Get a specific service template by ID."""
  serviceTemplate(
    """Template ID"""
    id: ID!
  ): ServiceTemplate
  """
  List all service templates (built-in + user-created).
  Optionally filter by category and/or scope.
  """
  serviceTemplates(
    """Filter by category"""
    category: ServiceTemplateCategory
    """Router ID (null for built-in only)"""
    routerID: ID
    """Filter by scope"""
    scope: TemplateScope
  ): [ServiceTemplate!]!
  """
  Get traffic statistics for a service instance.
  Includes current totals, historical data, and per-device breakdown.
  """
  serviceTrafficStats(
    """Time range for history (hours, default 24)"""
    historyHours: Int
    """Instance ID"""
    instanceID: ID!
    """Router ID"""
    routerID: ID!
  ): ServiceTrafficStats!
  """
  Get current external storage configuration.
  Returns enabled state and configured path.
  """
  storageConfig: StorageConfig!
  """
  List all detected storage locations (flash and external).
  Scans known RouterOS mount points and returns availability.
  """
  storageInfo: [StorageInfo!]!
  """
  Get comprehensive storage usage breakdown.
  Shows flash vs external usage and per-feature breakdown.
  """
  storageUsage(
    """Router ID to query storage for (optional, defaults to current router)"""
    routerId: ID
  ): StorageUsage!
  """Get all features supported by a router"""
  supportedFeatures(routerId: ID!): [FeatureSupport!]!
  """Get system-wide resource overview"""
  systemResources(
    """Router ID"""
    routerID: ID!
  ): SystemResources!
  """Get a troubleshooting session by ID"""
  troubleshootSession(id: ID!): TroubleshootSession
  """Get a specific tunnel by ID"""
  tunnel(
    """Tunnel ID"""
    id: ID!
    """Router ID"""
    routerId: ID!
  ): Tunnel @capability(requires: ["interface"])
  """Get all tunnels on a router with optional filtering by type"""
  tunnels(
    """Router ID to query"""
    routerId: ID!
    """Optional: filter by tunnel type"""
    type: TunnelType
  ): [Tunnel!]! @capability(requires: ["interface"])
  """
  Get list of features affected by storage disconnection.
  Returns features marked as unavailable due to missing storage.
  """
  unavailableFeatures(
    """Router ID to query (optional, defaults to current router)"""
    routerId: ID
  ): [ServiceInstance!]!
  """Get features not supported by a router with upgrade guidance"""
  unsupportedFeatures(routerId: ID!): [FeatureSupport!]!
  """Get upgrade recommendation for a specific feature on a router"""
  upgradeRecommendation(
    """Feature to enable"""
    featureId: String!
    """Router to check"""
    routerId: ID!
  ): UpgradeRecommendation
  """Get all upgrade recommendations for a router"""
  upgradeRecommendations(routerId: ID!): [UpgradeRecommendation!]!
  """Get current API version"""
  version: String!
  """Get a specific virtual interface for a service instance."""
  virtualInterface(
    """Instance ID"""
    instanceID: ID!
    """Router ID"""
    routerID: ID!
  ): VirtualInterface
  """List all virtual interfaces for a router."""
  virtualInterfaces(
    """Router ID"""
    routerID: ID!
  ): [VirtualInterface!]!
  """Get a specific VLAN by ID"""
  vlan(
    """VLAN ID"""
    id: ID!
  ): Vlan @capability(requires: ["interface"])
  """
  List all VLAN allocations with optional filtering.
  
  Examples:
  - vlanAllocations(routerID: "router-123") - All allocations for a router
  - vlanAllocations(status: ALLOCATED) - All active allocations across all routers
  - vlanAllocations(routerID: "router-123", status: ALLOCATED) - Active allocations for a router
  """
  vlanAllocations(
    """Filter by router ID"""
    routerID: String
    """Filter by allocation status"""
    status: VLANAllocationStatus
  ): [VLANAllocation!]!
  """Get dependencies for a VLAN (IP addresses, DHCP, routes, etc.)"""
  vlanDependencies(
    """VLAN ID"""
    id: ID!
  ): VlanDependencies @capability(requires: ["interface"])
  """
  Get VLAN pool status for a router.
  
  Returns utilization metrics and warning flags. Useful for monitoring
  pool capacity and planning when to expand the pool or clean up unused instances.
  
  Example:
  ```
  query {
    vlanPoolStatus(routerID: "router-123") {
      totalVLANs
      allocatedVLANs
      availableVLANs
      utilization
      shouldWarn
    }
  }
  ```
  """
  vlanPoolStatus(
    """Router ID to check pool status for"""
    routerID: String!
  ): VLANPoolStatus!
  """Get VLAN topology for a bridge"""
  vlanTopology(
    """Bridge ID"""
    bridgeId: ID!
    """Router ID"""
    routerId: ID!
  ): VlanTopology @capability(requires: ["interface"])
  """Get all VLANs on a router with optional filtering"""
  vlans(
    """Optional filters"""
    filter: VlanFilter
    """Router ID to query"""
    routerId: ID!
  ): [Vlan!]! @capability(requires: ["interface"])
  """Get connection history for a WAN interface"""
  wanConnectionHistory(
    """Pagination"""
    pagination: PaginationInput
    """Router ID"""
    routerId: ID!
    """WAN interface ID"""
    wanInterfaceId: ID!
  ): WANConnectionEventConnection! @capability(requires: ["interface"])
  """Get a specific WAN interface by ID"""
  wanInterface(
    """WAN interface ID"""
    id: ID!
    """Router ID"""
    routerId: ID!
  ): WANInterface @capability(requires: ["interface"])
  """Get all WAN interfaces on a router"""
  wanInterfaces(
    """Router ID"""
    routerId: ID!
  ): [WANInterface!]! @capability(requires: ["interface"])
  """Get a single webhook by ID"""
  webhook(
    """Webhook ID"""
    id: ID!
  ): Webhook
  """Get all webhooks"""
  webhooks: [Webhook!]!
}

"""Quiet hours configuration"""
type QuietHoursConfig {
  """Whether critical alerts bypass quiet hours"""
  bypassCritical: Boolean!
  """
  Days of week when quiet hours apply (0=Sunday, 1=Monday, 2=Tuesday, 3=Wednesday, 4=Thursday, 5=Friday, 6=Saturday). Empty array means all days.
  """
  daysOfWeek: [Int!]!
  """End time in HH:MM format"""
  endTime: String!
  """Start time in HH:MM format"""
  startTime: String!
  """Timezone (IANA timezone database name)"""
  timezone: String!
}

"""Quiet hours configuration input"""
input QuietHoursConfigInput {
  """Whether critical alerts bypass quiet hours (default: true)"""
  bypassCritical: Boolean = true
  """
  Days of week when quiet hours apply (0=Sunday, 1=Monday, 2=Tuesday, 3=Wednesday, 4=Thursday, 5=Friday, 6=Saturday). Empty array means all days.
  """
  daysOfWeek: [Int!] = []
  """End time in HH:MM format"""
  endTime: String!
  """Start time in HH:MM format"""
  startTime: String!
  """Timezone (default: UTC)"""
  timezone: String = "UTC"
}

"""Action to take when traffic quota is reached."""
enum QuotaAction {
  """Send alert notification to user"""
  ALERT
  """Log a warning but continue allowing traffic"""
  LOG_ONLY
  """Stop the service instance to prevent further traffic"""
  STOP_SERVICE
  """Throttle bandwidth to a lower speed"""
  THROTTLE
}

"""Quota period for traffic limits."""
enum QuotaPeriod {
  """Reset daily at midnight"""
  DAILY
  """Reset monthly on the 1st at midnight"""
  MONTHLY
  """Reset weekly on Sunday at midnight"""
  WEEKLY
}

type ReconnectRouterPayload {
  """Updated connection details"""
  connectionDetails: ConnectionDetails
  """Errors that occurred"""
  errors: [MutationError!]
  """Whether reconnection was initiated"""
  initiated: Boolean!
  """The router being reconnected"""
  router: Router
  """Rate limit wait time if rate limited"""
  waitTimeMs: Int
}

"""Payload for refreshCapabilities mutation"""
type RefreshCapabilitiesPayload {
  """Updated capabilities after refresh"""
  capabilities: RouterCapabilities
  """Errors during refresh"""
  errors: [MutationError!]
}

type RemoveChangeSetItemPayload {
  """The updated change set"""
  changeSet: ChangeSet
  """Errors that occurred"""
  errors: [MutationError!]
}

"""
RemoveDependencyInput contains parameters for removing a dependency relationship.
"""
input RemoveDependencyInput {
  dependencyId: ID!
}

"""Input for resetting external storage configuration."""
input ResetExternalStorageInput {
  """Whether to move existing binaries back to flash (default: false)"""
  migrateToFlash: Boolean
}

"""Payload for resetExternalStorage mutation."""
type ResetExternalStoragePayload {
  """Mutation errors"""
  errors: [MutationError!]
  """Number of features migrated to flash (if requested)"""
  featuresMigrated: Int!
  """Whether reset was successful"""
  success: Boolean!
}

"""
Universal State v2 Resource Interface.
Every managed resource implements this interface with 8 layers:
1. configuration - User's desired config (mutable by user)
2. validation - Pre-flight check results (computed by backend)
3. deployment - What's on router (after Apply-Confirm)
4. runtime - Live operational state (polled/streamed)
5. telemetry - Time-series metrics (historical)
6. metadata - Lifecycle info, tags, ownership
7. relationships - Dependencies (embedded + explicit)
8. platform - Capabilities and field mappings
"""
interface Resource {
  """Resource category"""
  category: ResourceCategory!
  """
  Layer 1: CONFIGURATION - User's desired config
  Mutable by user. Validated by Zod on client, GraphQL on server.
  Implementations can provide strongly-typed configs.
  """
  configuration: JSON
  """
  Layer 3: DEPLOYMENT - What's actually on router
  Written after Apply-Confirm. Includes router-generated fields.
  Implementations can provide strongly-typed deployment states.
  """
  deployment: DeploymentState
  """
  Globally unique identifier (ULID) - also serves as Node.id for Relay compatibility
  """
  id: ID!
  """
  Layer 6: METADATA - Resource lifecycle info
  System-managed. Includes tags, version, ownership.
  """
  metadata: ResourceMetadata!
  """
  Layer 8: PLATFORM - Capabilities and field mappings
  From platform adapter. Router-specific behavior.
  """
  platform: PlatformInfo
  """
  Layer 7: RELATIONSHIPS - Dependencies
  Embedded in config (user-defined) + explicit table (system-discovered).
  """
  relationships: ResourceRelationships
  """
  Layer 4: RUNTIME - Live operational state
  Polled/streamed from router. Read-only.
  Implementations can provide strongly-typed runtime states.
  """
  runtime: RuntimeState
  """Scoped identifier for readability (e.g., 'vpn.wg.client:usa-vpn:a1b2')"""
  scopedId: String!
  """
  Layer 5: TELEMETRY - Time-series metrics
  Historical data collected over time. Read-only.
  """
  telemetry: TelemetryData
  """Resource type identifier (e.g., 'vpn.wireguard.client')"""
  type: String!
  """
  Layer 2: VALIDATION - Pre-flight check results
  Computed by backend. Updated on every configuration change.
  """
  validation: ValidationResult
}

"""Categories of managed resources"""
enum ResourceCategory {
  """Application-level: Port Forwarding, Game Rules"""
  APPLICATION
  """Marketplace features: Tor, AdGuard, sing-box"""
  FEATURE
  """System infrastructure: Certificates, NTP, DDNS"""
  INFRASTRUCTURE
  """Network topology: WAN Links, LAN Networks, VLANs"""
  NETWORK
  """Community extensions: Third-party plugins"""
  PLUGIN
  """VPN connectivity: WireGuard, OpenVPN, IPsec"""
  VPN
}

"""Conflict with another resource"""
type ResourceConflict {
  """The conflicting resource"""
  conflictingResource: Resource
  """Conflicting resource UUID (if resource is not loaded)"""
  conflictingResourceUuid: ID!
  """Description of the conflict"""
  description: String!
  """Suggested resolution"""
  resolution: String
  """Type of conflict"""
  type: ConflictType!
}

type ResourceConnection implements Connection {
  edges: [ResourceEdge!]!
  pageInfo: PageInfo!
  totalCount: Int
}

type ResourceEdge implements Edge {
  cursor: String!
  node: Resource!
}

"""Resource usage estimate"""
type ResourceEstimate {
  """Disk space needed in MB"""
  diskSpaceMB: Int!
  """Number of network ports"""
  networkPorts: Int!
  """Total CPU shares"""
  totalCPUShares: Int!
  """Total estimated memory in MB"""
  totalMemoryMB: Int!
  """Number of VLANs required"""
  vlansRequired: Int!
}

"""Impact level for affected resources"""
enum ResourceImpact {
  """Connections will be dropped"""
  CONNECTION_DROP
  """Resource will be disabled"""
  DISABLED
  """Resource will be modified"""
  MODIFIED
  """Resource will be removed"""
  REMOVED
}

"""Selectable resource layers for optimized fetching"""
enum ResourceLayer {
  CONFIGURATION
  DEPLOYMENT
  METADATA
  PLATFORM
  RELATIONSHIPS
  RUNTIME
  TELEMETRY
  VALIDATION
}

"""Resource lifecycle states for state machine"""
enum ResourceLifecycleState {
  """Successfully applied and running"""
  ACTIVE
  """Being applied to router"""
  APPLYING
  """Final state, no longer active"""
  ARCHIVED
  """Running but with issues"""
  DEGRADED
  """Marked for removal"""
  DEPRECATED
  """Initial creation, not yet validated"""
  DRAFT
  """Failed state (validation or apply)"""
  ERROR
  """Passed validation, ready to apply"""
  VALID
  """Backend validation in progress"""
  VALIDATING
}

"""Resource limits applied to a service instance via cgroups v2."""
type ResourceLimits {
  """Whether resource limits are currently applied (cgroups available)"""
  applied: Boolean!
  """CPU usage percentage (0-100)"""
  cpuPercent: Int
  """Memory limit in megabytes (minimum 16MB)"""
  memoryMB: Int!
}

"""Payload for resource limits mutation."""
type ResourceLimitsPayload {
  """Mutation errors"""
  errors: [MutationError!]
  """Updated resource limits (null if operation failed)"""
  resourceLimits: ResourceLimits
  """Whether the operation succeeded"""
  success: Boolean!
}

"""
Layer 6: Resource lifecycle info, tags, ownership.
System-managed with some user-editable fields.
"""
type ResourceMetadata {
  """Resource creation timestamp"""
  createdAt: DateTime!
  """User who created the resource"""
  createdBy: String!
  """Resource description"""
  description: String
  """Whether resource is marked as favorite"""
  isFavorite: Boolean!
  """Whether resource is pinned"""
  isPinned: Boolean!
  """Custom user notes"""
  notes: String
  """Audit trail of recent changes"""
  recentChanges: [ChangeLogEntry!]
  """Current lifecycle state"""
  state: ResourceLifecycleState!
  """User-defined tags for organization"""
  tags: [String!]!
  """Last update timestamp"""
  updatedAt: DateTime!
  """User who last updated the resource"""
  updatedBy: String
  """Optimistic locking version"""
  version: Int!
}

"""Real-time resource utilization metrics for a device"""
type ResourceMetrics {
  """CPU utilization metrics"""
  cpu: CPUMetrics!
  """Memory utilization metrics"""
  memory: MemoryMetrics!
  """Storage utilization metrics"""
  storage: StorageMetrics!
  """Temperature in Celsius (null if not supported)"""
  temperature: Float
  """Timestamp when metrics were collected"""
  timestamp: DateTime!
}

"""Reference to another resource"""
type ResourceReference {
  """Resource category"""
  category: ResourceCategory!
  """Resource scoped ID"""
  id: String!
  """Current lifecycle state"""
  state: ResourceLifecycleState!
  """Resource type"""
  type: String!
  """Resource UUID"""
  uuid: ID!
}

"""Edge in the resource relationship graph"""
type ResourceRelationshipEdge {
  """Source resource ID"""
  from: ID!
  """Target resource ID"""
  to: ID!
  """Relationship type"""
  type: ResourceRelationshipType!
}

"""Types of relationships between resources"""
enum ResourceRelationshipType {
  """Custom relationship"""
  CUSTOM
  """Child depends on parent"""
  DEPENDS_ON
  """Resources are in the same group"""
  GROUP
  """Parent-child hierarchy"""
  PARENT_CHILD
  """Traffic routes via this resource"""
  ROUTES_VIA
}

"""
Layer 7: Dependencies and relationships between resources.
Combines user-defined relationships and system-discovered dependencies.
"""
type ResourceRelationships {
  """Child resources (for hierarchical resources)"""
  children: [ResourceReference!]!
  """Custom relationships"""
  custom: JSON
  """Resources that depend on this resource"""
  dependents: [ResourceReference!]!
  """Resources this resource depends on"""
  dependsOn: [ResourceReference!]!
  """Parent resource (for hierarchical resources)"""
  parent: ResourceReference
  """Resources that route traffic via this resource"""
  routedBy: [ResourceReference!]!
  """Resource this routes traffic via"""
  routesVia: ResourceReference
}

"""Input for resource relationships"""
input ResourceRelationshipsInput {
  """Custom relationship data"""
  custom: JSON
  """Resources this resource depends on (IDs)"""
  dependsOn: [ID!]
  """Parent resource ID (for hierarchical resources)"""
  parent: ID
  """Resources that route traffic via this resource (ID)"""
  routesVia: ID
}

"""
Resource requirements for a service feature (from manifest).
Defines the minimum and recommended resources for a service.
"""
type ResourceRequirements {
  """CPU weight (priority) for scheduling (0-100)"""
  cpuWeight: Int!
  """Minimum RAM required in megabytes"""
  minRAM: Int!
  """Recommended RAM for optimal performance in megabytes"""
  recommendedRAM: Int!
}

"""Runtime update event for a resource"""
type ResourceRuntimeEvent {
  """Resource ID (ULID)"""
  id: ID!
  """Updated runtime state"""
  runtime: RuntimeState!
  """Timestamp of update"""
  timestamp: DateTime!
  """Resource type"""
  type: String!
}

"""Lifecycle state change event"""
type ResourceStateEvent {
  """Error message if state is ERROR"""
  errorMessage: String
  """Resource ID (ULID)"""
  id: ID!
  """New state"""
  newState: ResourceLifecycleState!
  """Previous state"""
  previousState: ResourceLifecycleState!
  """Timestamp of change"""
  timestamp: DateTime!
  """Resource type"""
  type: String!
}

"""Resource status indicating health of resource usage."""
enum ResourceStatus {
  """Resource usage is critical (>90%)"""
  CRITICAL
  """Resource usage is within acceptable limits (<70%)"""
  OK
  """Resource usage is high (70-90%)"""
  WARNING
}

"""Event emitted when a router resource is updated"""
type ResourceUpdatedEvent {
  """Type of change (create, update, delete)"""
  changeType: ChangeType!
  """Fields that were changed"""
  changedFields: [String!]!
  """Unique resource identifier"""
  resourceId: ID!
  """Type of resource (interface, firewall-rule, dhcp-lease, etc.)"""
  resourceType: String!
  """Router this resource belongs to"""
  routerId: ID!
  """Timestamp of the update"""
  timestamp: DateTime!
  """New version number after update"""
  version: Int!
}

"""
Current resource usage for a service instance.
Provides real-time memory usage statistics.
"""
type ResourceUsage {
  """Current memory usage in megabytes"""
  currentMB: Int!
  """Memory limit in megabytes"""
  limitMB: Int!
  """Resource status (ok, warning, critical)"""
  status: ResourceStatus!
  """Usage as a percentage of the limit (0-100)"""
  usagePercent: Float!
}

"""Input for restarting a service instance."""
input RestartInstanceInput {
  """Instance ID to restart"""
  instanceID: ID!
  """Router ID"""
  routerID: ID!
}

"""Payload for reverification mutation."""
type ReverifyPayload {
  """Current binary hash"""
  currentHash: String
  """Error message if verification failed"""
  errorMessage: String
  """Mutation errors"""
  errors: [MutationError!]
  """Expected binary hash (from install-time)"""
  expectedHash: String
  """Instance ID that was reverified"""
  instanceID: ID!
  """Whether reverification passed"""
  success: Boolean!
}

type RollbackChangeSetPayload {
  """The rolled back change set"""
  changeSet: ChangeSet
  """Errors that occurred"""
  errors: [MutationError!]
  """Items that failed to rollback"""
  failedItems: [ID!]
  """Whether rollback was successful"""
  success: Boolean!
}

"""Rollback operation type"""
enum RollbackOperation {
  """Delete a created resource"""
  DELETE
  """Restore a deleted resource"""
  RESTORE
  """Revert an updated resource"""
  REVERT
}

"""Rollback step for recovery"""
type RollbackStep {
  """Error message if failed"""
  error: String
  """Item ID being rolled back"""
  itemId: ID!
  """Rollback operation"""
  operation: RollbackOperation!
  """Resource UUID on router"""
  resourceUuid: ID
  """State to restore"""
  restoreState: JSON
  """Order in rollback sequence"""
  rollbackOrder: Int!
  """Whether rollback succeeded"""
  success: Boolean!
}

"""Route type for static and dynamic routing"""
type Route implements Node {
  """Whether the route is active"""
  active: Boolean!
  """User comment"""
  comment: String @validate(maxLength: 255) @mikrotik(path: "/ip/route", field: "comment")
  """Destination network in CIDR notation"""
  destination: CIDR! @mikrotik(path: "/ip/route", field: "dst-address")
  """Whether the route is disabled"""
  disabled: Boolean @mikrotik(path: "/ip/route", field: "disabled")
  """Route distance/metric (1-255)"""
  distance: Int! @validate(min: 1, max: 255) @mikrotik(path: "/ip/route", field: "distance")
  """Gateway address"""
  gateway: IPv4 @mikrotik(path: "/ip/route", field: "gateway")
  """Route ID"""
  id: ID!
  """Interface used for this route"""
  interface: String @mikrotik(path: "/ip/route", field: "interface")
  """Routing mark for policy routing"""
  routingMark: String @mikrotik(path: "/ip/route", field: "routing-mark")
  """Routing table name (main, vpn, etc.)"""
  routingTable: String @mikrotik(path: "/ip/route", field: "routing-table")
  """Route scope"""
  scope: RouteScope!
  """Route type (static, connected, dynamic, BGP, OSPF)"""
  type: RouteType!
}

"""Result of a route deletion with impact analysis"""
type RouteDeleteResult {
  """Impact analysis for this route deletion"""
  impactAnalysis: RouteImpactAnalysis!
  """Success or error message"""
  message: String
  """Whether the deletion succeeded"""
  success: Boolean!
}

"""Analysis of the impact of deleting a route"""
type RouteImpactAnalysis {
  """Description of affected traffic"""
  affectedTraffic: String!
  """List of consequences of deleting this route"""
  consequences: [String!]!
  """Whether this is the default route (0.0.0.0/0)"""
  isDefaultRoute: Boolean!
  """Human-readable message about the impact"""
  message: String!
  """
  Severity of the deletion (CRITICAL for default route, STANDARD for others)
  """
  severity: ConfirmationSeverity!
}

"""Input for creating or updating a route"""
input RouteInput {
  """User comment"""
  comment: String @validate(maxLength: 255)
  """Destination network in CIDR notation"""
  destination: CIDR!
  """Route distance/metric (1-255, default: 1)"""
  distance: Int @validate(min: 1, max: 255)
  """Gateway address (optional if interface is provided)"""
  gateway: IPv4
  """Interface used for this route (optional if gateway is provided)"""
  interface: String
  """Routing mark for policy routing"""
  routingMark: String
  """Routing table name (default: main)"""
  routingTable: String
}

"""A candidate route that matches the destination"""
type RouteLookupCandidate {
  """Administrative distance"""
  distance: Int!
  """Prefix length (24 for /24, 8 for /8)"""
  prefixLength: Int!
  """The route object"""
  route: Route!
  """Whether this route was selected"""
  selected: Boolean!
  """Reason for selection or non-selection"""
  selectionReason: String
}

"""Result of a route lookup operation"""
type RouteLookupResult {
  """All candidate routes that match destination"""
  candidateRoutes: [RouteLookupCandidate!]!
  """Destination IP that was looked up"""
  destination: String!
  """Administrative distance of selected route"""
  distance: Int
  """Human-readable explanation of route selection"""
  explanation: String!
  """Gateway IP for the selected route"""
  gateway: String
  """Outgoing interface for the selected route"""
  interface: String
  """Whether this is the default route (0.0.0.0/0)"""
  isDefaultRoute: Boolean!
  """The selected route (null if no route found)"""
  matchedRoute: Route
  """Route type (STATIC, CONNECTED, DYNAMIC, BGP, OSPF)"""
  routeType: RouteType!
  """VPN tunnel info if route goes through VPN"""
  vpnTunnel: VPNTunnelInfo
}

"""Result of a route mutation (create, update)"""
type RouteMutationResult {
  """Success or error message"""
  message: String
  """The created or updated route (if successful)"""
  route: Route
  """Whether the operation succeeded"""
  success: Boolean!
}

"""Route resource"""
type RouteResource implements Node & Resource {
  """Whether route is active"""
  active: Boolean!
  category: ResourceCategory!
  configuration: JSON!
  deployment: DeploymentState
  """Route distance/metric"""
  distance: Int
  """Destination network"""
  dstAddress: CIDR!
  """Gateway address"""
  gateway: IPv4
  id: ID!
  """Outgoing interface"""
  interface: String
  metadata: ResourceMetadata!
  platform: PlatformInfo
  relationships: ResourceRelationships
  runtime: RuntimeState
  scopedId: String!
  telemetry: TelemetryData
  type: String!
  validation: ValidationResult
}

"""Route scope"""
enum RouteScope {
  """Global route (forwarded between interfaces)"""
  GLOBAL
  """Host-local route"""
  HOST
  """Link-local route (not forwarded)"""
  LINK
}

"""Route type classification"""
enum RouteType {
  """BGP route"""
  BGP
  """Connected route (directly connected network)"""
  CONNECTED
  """Dynamic route (learned via routing protocol)"""
  DYNAMIC
  """OSPF route"""
  OSPF
  """Static route (manually configured)"""
  STATIC
}

"""A managed router device"""
type Router implements Node {
  """Detected router capabilities (requires connection)"""
  capabilities: RouterCapabilities
  """When the router was added to NasNet"""
  createdAt: DateTime!
  """Router hostname or IP address"""
  host: String!
  """Unique router identifier"""
  id: ID!
  """Last successful connection time"""
  lastConnected: DateTime
  """Router model"""
  model: String @mikrotik(path: "/system/routerboard", field: "model")
  """User-friendly display name"""
  name: String!
  """Router platform type"""
  platform: RouterPlatform!
  """Connection port"""
  port: Int!
  """Current connection status"""
  status: ConnectionStatus!
  """Last update timestamp"""
  updatedAt: DateTime!
  """System uptime"""
  uptime: Duration @mikrotik(path: "/system/resource", field: "uptime")
  """RouterOS version (if connected)"""
  version: String @mikrotik(path: "/system/resource", field: "version")
}

"""Event emitted when a new router is added."""
type RouterAddedEvent {
  """User who added the router (if authenticated)"""
  addedBy: String
  """Protocol used for initial connection"""
  protocolUsed: Protocol!
  """The newly added router"""
  router: Router!
  """Timestamp of addition"""
  timestamp: DateTime!
}

"""Complete router capabilities detected from system inspection"""
type RouterCapabilities {
  """Capability entries with support levels"""
  capabilities: [CapabilityEntry!]!
  """Container-specific capabilities"""
  container: ContainerInfo!
  """When capabilities were detected"""
  detectedAt: DateTime!
  """When cache expires (24h TTL)"""
  expiresAt: DateTime!
  """Hardware information"""
  hardware: HardwareInfo!
  """Whether cache is stale and refresh is in progress"""
  isRefreshing: Boolean!
  """Parsed RouterOS version with comparison helpers"""
  routerOSVersion: RouterOSVersion!
  """Software information"""
  software: SoftwareInfo!
  """Features supported by this router's version and configuration"""
  supportedFeatures: [FeatureSupport!]!
  """Features not supported by this router (with upgrade guidance)"""
  unsupportedFeatures: [FeatureSupport!]!
  """VIF requirements check"""
  vifRequirements: VIFRequirements!
}

type RouterConnection implements Connection {
  edges: [RouterEdge!]!
  pageInfo: PageInfo!
  totalCount: Int
}

"""
Router credential information (non-sensitive).
Password is never included - only metadata about credentials.
"""
type RouterCredentials {
  """When credentials were first created"""
  createdAt: DateTime!
  """Encryption algorithm used (always 'AES-256-GCM')"""
  encryptionStatus: String!
  """Whether a password is stored"""
  hasPassword: Boolean!
  """Encryption key version (for rotation tracking)"""
  keyVersion: Int!
  """When credentials were last updated"""
  lastUpdated: DateTime!
  """Router ID these credentials belong to"""
  routerId: ID!
  """Username for router authentication"""
  username: String!
}

type RouterEdge implements Edge {
  cursor: String!
  node: Router!
}

"""Information about a discovered RouterOS device"""
type RouterOSInfo {
  """CPU architecture (e.g., 'arm', 'x86', 'mips')"""
  architecture: String
  """Router board name (e.g., 'hAP ac3', 'CCR2004-1G-12S+2XS')"""
  boardName: String
  """Platform identifier"""
  platform: String
  """RouterOS version string (e.g., '7.12', '6.49.8')"""
  version: String
}

"""Parsed RouterOS version with semantic versioning"""
type RouterOSVersion {
  """Version channel (stable, beta, rc, long-term)"""
  channel: String
  """Check if version is at least the given version (e.g., '7.1')"""
  isAtLeast(version: String!): Boolean!
  """Whether this is a Cloud Hosted Router (CHR)"""
  isCHR: Boolean!
  """Major version number"""
  major: Int!
  """Minor version number"""
  minor: Int!
  """Patch version number"""
  patch: Int!
  """Full version string (e.g., '7.13.2')"""
  raw: String!
  """Check if this version supports a specific feature"""
  supportsFeature(featureId: String!): Boolean!
}

"""Supported router platforms"""
enum RouterPlatform {
  """Generic/Unknown"""
  GENERIC
  """MikroTik RouterOS"""
  MIKROTIK
  """OpenWrt"""
  OPENWRT
  """VyOS"""
  VYOS
}

type RouterStatusEvent {
  """New status"""
  newStatus: ConnectionStatus!
  """Previous status"""
  previousStatus: ConnectionStatus!
  """The router whose status changed"""
  router: Router!
  """Timestamp of the change"""
  timestamp: DateTime!
}

"""
A multi-hop routing chain that routes device traffic through multiple services sequentially.
Example: Device -> VPN -> Tor -> Internet for layered privacy.
"""
type RoutingChain implements Node {
  """Whether this chain is currently active"""
  active: Boolean!
  """Chain creation timestamp"""
  createdAt: DateTime!
  """Target device identifier"""
  deviceId: ID!
  """Device IP address (when routing_mode=IP)"""
  deviceIp: String
  """Device MAC address (when routing_mode=MAC)"""
  deviceMac: String
  """Human-readable device name"""
  deviceName: String
  """Ordered list of service hops in this chain"""
  hops: [ChainHop!]!
  """Chain ID (ULID)"""
  id: ID!
  """Timestamp when kill switch was last activated"""
  killSwitchActivatedAt: DateTime
  """Whether kill switch is currently blocking traffic"""
  killSwitchActive: Boolean!
  """Whether kill switch is enabled for this chain"""
  killSwitchEnabled: Boolean!
  """Kill switch behavior mode"""
  killSwitchMode: KillSwitchMode!
  """Routing mode (MAC or IP matching)"""
  routingMode: RoutingMode!
  """Total latency across all hops in milliseconds"""
  totalLatencyMs: Float
  """Last update timestamp"""
  updatedAt: DateTime!
}

"""Result of a routing chain mutation."""
type RoutingChainMutationResult {
  """The created or updated chain (null if failed)"""
  chain: RoutingChain
  """Mutation errors"""
  errors: [MutationError!]
  """Human-readable message"""
  message: String
  """Whether the operation succeeded"""
  success: Boolean!
}

"""Routing mode for device routing assignments."""
enum RoutingMode {
  """IP address-based routing (less reliable due to DHCP changes)"""
  IP
  """MAC address-based routing (default, more reliable)"""
  MAC
}

"""
A single routing rule for device-to-service routing.
Represents a MikroTik firewall mangle rule.
"""
type RoutingRule {
  """Action (e.g., 'mark-routing')"""
  action: String!
  """Mangle chain (e.g., 'prerouting')"""
  chain: String!
  """Comment for rule identification"""
  comment: String
  """Destination address"""
  dstAddress: String
  """New routing mark to set"""
  newRoutingMark: String
  """Protocol (tcp, udp, icmp, etc.)"""
  protocol: String
  """Routing mark to match"""
  routingMark: String
  """Source address (MAC or IP)"""
  srcAddress: String
}

"""
Time-based schedule for activating/deactivating device routing rules.
Enables features like parental controls, time-based VPN routing, etc.
"""
type RoutingSchedule implements Node {
  """When the schedule was created"""
  createdAt: DateTime!
  """Days of week when schedule is active (0=Sunday, 6=Saturday)"""
  days: [Int!]!
  """Whether this schedule is enabled"""
  enabled: Boolean!
  """End time in HH:MM format (24-hour)"""
  endTime: String!
  """Schedule ID (ULID)"""
  id: ID!
  """Whether the schedule window is currently active (computed field)"""
  isActive: Boolean!
  """Timestamp when routing was last activated by this schedule"""
  lastActivated: DateTime
  """Timestamp when routing was last deactivated by this schedule"""
  lastDeactivated: DateTime
  """Device routing ID this schedule controls"""
  routingID: ID!
  """Start time in HH:MM format (24-hour)"""
  startTime: String!
  """IANA timezone identifier (e.g., 'America/New_York', 'UTC')"""
  timezone: String!
  """Last update timestamp"""
  updatedAt: DateTime!
}

"""Input for running diagnostics on a service instance."""
input RunDiagnosticsInput {
  """Instance ID to run diagnostics on"""
  instanceID: ID!
  """Router ID"""
  routerID: ID!
  """Specific test names to run (empty = run all tests)"""
  testNames: [String!]
}

"""Payload for run diagnostics mutation."""
type RunDiagnosticsPayload {
  """Mutation errors"""
  errors: [MutationError!]
  """Diagnostic results"""
  results: [DiagnosticResult!]
  """Run group ID linking these results together"""
  runGroupID: String
  """Whether the operation succeeded"""
  success: Boolean!
}

"""Result of running a diagnostic step"""
type RunTroubleshootStepPayload {
  """Errors that occurred"""
  errors: [MutationError!]
  """Updated step with result"""
  step: TroubleshootStep!
}

"""Runtime health status"""
enum RuntimeHealth {
  """Resource is running but degraded"""
  DEGRADED
  """Resource has failed"""
  FAILED
  """Resource is healthy and operating normally"""
  HEALTHY
  """Health status unknown"""
  UNKNOWN
  """Resource is running but with warnings"""
  WARNING
}

"""Resource-specific runtime metrics"""
type RuntimeMetrics {
  """Bytes received"""
  bytesIn: Size
  """Bytes transmitted"""
  bytesOut: Size
  """Resource-specific custom metrics"""
  custom: JSON
  """Drops count"""
  drops: Int
  """Error count"""
  errors: Int
  """Packets received"""
  packetsIn: Int
  """Packets transmitted"""
  packetsOut: Int
  """Current throughput in (bytes/sec)"""
  throughputIn: Size
  """Current throughput out (bytes/sec)"""
  throughputOut: Size
}

"""
Layer 4: Live operational state polled/streamed from router.
Updated via polling (5-60s interval) or WebSocket push.
"""
type RuntimeState {
  """Current peers/connections (for VPN, etc.)"""
  activeConnections: Int
  """Error message if resource is unhealthy"""
  errorMessage: String
  """Health status of the resource"""
  health: RuntimeHealth!
  """Whether the resource is currently running/active"""
  isRunning: Boolean!
  """Time since last successful operation"""
  lastSuccessfulOperation: DateTime
  """Last time runtime was updated"""
  lastUpdated: DateTime!
  """Resource-specific runtime metrics"""
  metrics: RuntimeMetrics
  """Resource uptime"""
  uptime: Duration
}

"""Input for saving custom alert rule template"""
input SaveAlertRuleTemplateInput {
  """Template category"""
  category: AlertRuleTemplateCategory!
  """Notification channels"""
  channels: [String!]!
  """Alert conditions"""
  conditions: [AlertConditionInput!]!
  """Template description"""
  description: String!
  """Event type"""
  eventType: String!
  """Template name"""
  name: String!
  """Alert severity"""
  severity: AlertSeverity!
  """Throttle configuration"""
  throttle: ThrottleConfigInput
  """Template variables"""
  variables: [AlertRuleAlertTemplateVariableInput!]
}

"""Input for saving a custom alert template"""
input SaveAlertTemplateInput {
  """Body template"""
  bodyTemplate: String!
  """Notification channel"""
  channel: NotificationChannel!
  """Template description"""
  description: String!
  """Event type"""
  eventType: String!
  """Metadata"""
  metadata: JSON
  """Template name"""
  name: String!
  """Subject template"""
  subjectTemplate: String
  """Tags"""
  tags: [String!]
  """Template variables"""
  variables: [AlertAlertTemplateVariableInput!]!
}

"""Input for saving a custom template."""
input SaveTemplateInput {
  """Category"""
  category: TemplateCategory!
  """Template description"""
  description: String! @validate(minLength: 1, maxLength: 500)
  """Template name"""
  name: String! @validate(minLength: 1, maxLength: 100)
  """Rule definitions"""
  rules: [TemplateRuleInput!]!
  """Variable definitions"""
  variables: [FirewallTemplateVariableInput!]!
}

"""Input for starting a network scan"""
input ScanNetworkInput {
  """
  Target subnet in CIDR notation (e.g., '192.168.88.0/24') or IP range (e.g., '192.168.1.1-192.168.1.100')
  """
  subnet: String! @validate(minLength: 7, maxLength: 43)
}

type ScanNetworkPayload {
  """Errors that occurred"""
  errors: [MutationError!]
  """The created scan task"""
  task: ScanTask
}

"""Real-time progress event for scan subscriptions"""
type ScanProgressEvent {
  """IP address currently being scanned"""
  currentIP: String
  """Number of MikroTik devices found so far"""
  devicesFound: Int!
  """Current progress percentage (0-100)"""
  progress: Int!
  """Current scan status"""
  status: ScanStatus!
  """Task ID this event belongs to"""
  taskId: ID!
  """Timestamp of this progress update"""
  timestamp: DateTime!
}

"""Status of a network scan operation"""
enum ScanStatus {
  """Scan was cancelled by user"""
  CANCELLED
  """Scan completed successfully"""
  COMPLETED
  """Scan failed with an error"""
  FAILED
  """Scan is queued and waiting to start"""
  PENDING
  """Scan is actively running"""
  RUNNING
}

"""Payload for scanStorage mutation."""
type ScanStoragePayload {
  """Mutation errors"""
  errors: [MutationError!]
  """Number of new storage locations detected"""
  newStorageCount: Int!
  """Detected storage locations"""
  storageInfo: [StorageInfo!]!
}

"""
A network scan task that tracks scan progress and results.
Scans are asynchronous - start with mutation, poll/subscribe for progress.
"""
type ScanTask {
  """When the scan completed (null if still running)"""
  endTime: DateTime
  """Error message if scan failed"""
  error: String
  """Unique task identifier"""
  id: ID!
  """Scan progress percentage (0-100)"""
  progress: Int!
  """Discovered devices (populated as scan progresses)"""
  results: [DiscoveredDevice!]!
  """Number of IPs scanned so far"""
  scannedIPs: Int
  """When the scan was started"""
  startTime: DateTime!
  """Current scan status"""
  status: ScanStatus!
  """Target subnet (CIDR notation, IP range, or gateway scan indicator)"""
  subnet: String!
  """Total IPs to scan (for progress calculation)"""
  totalIPs: Int
}

"""
Schedule event for subscriptions.
Emitted when schedules are created, updated, deleted, or when activation state changes.
"""
type ScheduleEvent {
  """Event type (created, updated, deleted, activated, deactivated)"""
  eventType: String!
  """Event ID"""
  id: ID!
  """Routing ID (for deleted schedules)"""
  routingID: ID
  """Schedule that changed"""
  schedule: RoutingSchedule
  """Timestamp"""
  timestamp: DateTime!
}

"""
Service configuration sharing event for subscriptions.
Emitted when configs are exported, imported, or QR codes generated.
"""
type ServiceConfigSharedEvent {
  """Event type (exported, imported, qr_generated)"""
  eventType: String!
  """Event ID"""
  id: ID!
  """Instance ID"""
  instanceID: ID!
  """Router ID"""
  routerID: ID!
  """Service name"""
  serviceName: String!
  """Service type"""
  serviceType: String!
  """Timestamp"""
  timestamp: DateTime!
  """User who performed the action"""
  userID: String
}

"""
ServiceDependency represents a dependency relationship between two service instances.
Example: A VPN-over-Tor instance depends on a Tor instance being running.
"""
type ServiceDependency {
  autoStart: Boolean!
  createdAt: DateTime!
  dependencyType: DependencyType!
  fromInstance: ServiceInstance!
  healthTimeoutSeconds: Int!
  id: ID!
  toInstance: ServiceInstance!
  updatedAt: DateTime!
}

"""
Export package containing service configuration.
Used for sharing service configs via JSON or QR code.
"""
type ServiceExportPackage {
  """Binary version"""
  binaryVersion: String!
  """Service configuration (JSON)"""
  config: JSON!
  """Timestamp when the export was created"""
  exportedAt: DateTime!
  """User who exported this configuration"""
  exportedByUserID: String
  """Whether secrets are included (not redacted)"""
  includesSecrets: Boolean!
  """Optional routing rules for device routing"""
  routingRules: [RoutingRule!]
  """Schema version (e.g., "1.0")"""
  schemaVersion: String!
  """Service instance name"""
  serviceName: String!
  """Service type identifier (e.g., 'tor', 'mtproxy')"""
  serviceType: String!
}

"""
Service instance running on a router.
Represents an installed and potentially running service instance.
"""
type ServiceInstance implements Node {
  """SHA256 checksum of the binary"""
  binaryChecksum: String
  """Path to the service binary"""
  binaryPath: String
  """Version of the service binary"""
  binaryVersion: String
  """IP address to bind the service to"""
  bindIP: String
  """Service-specific configuration (JSON)"""
  config: JSON
  """When the instance was created"""
  createdAt: DateTime!
  """Feature identifier (e.g., 'tor', 'sing-box')"""
  featureID: String!
  """Instance ID (ULID)"""
  id: ID!
  """Human-readable instance name"""
  instanceName: String!
  """Ports used by this service instance"""
  ports: [Int!]!
  """The router this instance belongs to"""
  router: Router
  """Router ID this instance belongs to"""
  routerID: String!
  """Current lifecycle status"""
  status: ServiceInstanceStatus!
  """Last update timestamp"""
  updatedAt: DateTime!
  """Binary verification information (null if verification not enabled)"""
  verification: BinaryVerification
  """VLAN ID for network isolation"""
  vlanID: Int
}

"""
Comprehensive health status for a service instance
Combines process liveness, connection status, and latency metrics
"""
type ServiceInstanceHealth {
  """Connection status from TCP/HTTP health probe"""
  connectionStatus: HealthConnectionState!
  """Number of consecutive health check failures"""
  consecutiveFails: Int!
  """
  Timestamp of when the instance was last healthy (null if never healthy)
  """
  lastHealthy: DateTime
  """
  Health probe round-trip latency in milliseconds (null if probe hasn't run)
  """
  latencyMs: Int
  """Whether the service process is alive (PID check)"""
  processAlive: Boolean!
  """Current health state of the instance"""
  status: InstanceHealthState!
  """Instance uptime in seconds (null if not running)"""
  uptimeSeconds: Int
}

"""Health check configuration for a service instance"""
type ServiceInstanceHealthConfig {
  """Whether to auto-restart on health check failure (default: true)"""
  autoRestart: Boolean!
  """Consecutive failures before marking unhealthy (1-10, default: 3)"""
  failureThreshold: Int!
  """Health check interval in seconds (10-300, default: 30)"""
  intervalSeconds: Int!
}

"""Payload for service instance mutations."""
type ServiceInstancePayload {
  """Mutation errors"""
  errors: [MutationError!]
  """The service instance (null if operation failed)"""
  instance: ServiceInstance
}

"""Service instance lifecycle status."""
enum ServiceInstanceStatus {
  """Instance is being deleted"""
  DELETING
  """Operation failed"""
  FAILED
  """Binary installed, ready to start"""
  INSTALLED
  """Binary is being downloaded and installed"""
  INSTALLING
  """Process is running"""
  RUNNING
  """Process is starting"""
  STARTING
  """Process is stopped"""
  STOPPED
  """Process is stopping"""
  STOPPING
}

"""
Service log file with metadata.
Represents captured logs from a service instance.
"""
type ServiceLogFile {
  """Timestamp when log file was created"""
  createdAt: DateTime!
  """Recent log entries (last N lines)"""
  entries: [LogEntry!]!
  """Log file path on router filesystem"""
  filePath: String!
  """Instance ID"""
  instanceID: ID!
  """Timestamp when log file was last updated"""
  lastUpdated: DateTime!
  """Number of log lines available"""
  lineCount: Int!
  """Service name"""
  serviceName: String!
  """Current log file size in bytes"""
  sizeBytes: Int!
}

"""Service result from template installation"""
type ServiceResult {
  """Creation timestamp"""
  createdAt: DateTime!
  """Error message if failed"""
  errorMessage: String
  """Created instance ID"""
  instanceID: String
  """Service name from template"""
  serviceName: String!
  """Status (success/failed/skipped)"""
  status: String!
}

"""Service specification within a template"""
type ServiceSpec {
  """Service-specific configuration overrides"""
  configOverrides: JSON
  """CPU shares"""
  cpuShares: Int
  """Service dependencies (references other services in template)"""
  dependsOn: [String!]
  """Memory limit in MB"""
  memoryLimitMB: Int
  """Instance name template (supports variables)"""
  name: String!
  """Port mappings"""
  portMappings: [PortMapping!]
  """Whether this service needs Virtual Interface Factory"""
  requiresBridge: Boolean
  """Service type (feature ID like 'tor', 'xray-core')"""
  serviceType: String!
  """VLAN ID (null = auto-allocate)"""
  vlanID: Int
}

"""Service operational status"""
enum ServiceStatus {
  """Service is operational with degraded performance"""
  DEGRADED
  """Service is fully operational"""
  HEALTHY
  """Service is not operational"""
  UNHEALTHY
}

"""Service template"""
type ServiceTemplate implements Node {
  """Template author"""
  author: String
  """Template category"""
  category: ServiceTemplateCategory!
  """Configuration variables"""
  configVariables: [TemplateVariable!]!
  """Creation timestamp"""
  createdAt: DateTime!
  """Detailed description"""
  description: String!
  """Documentation"""
  documentation: String
  """Resource estimates"""
  estimatedResources: ResourceEstimate
  """Usage examples"""
  examples: [String!]
  """Template ID (ULID)"""
  id: ID!
  """Whether this is a built-in template"""
  isBuiltIn: Boolean!
  """Template name"""
  name: String!
  """Prerequisites"""
  prerequisites: [String!]
  """Router ID (null for built-in templates)"""
  routerID: String
  """Deployment scope"""
  scope: TemplateScope!
  """Services to deploy"""
  services: [ServiceSpec!]!
  """Routing suggestions"""
  suggestedRouting: [SuggestedRoutingRule!]
  """Search tags"""
  tags: [String!]
  """Last update timestamp"""
  updatedAt: DateTime!
  """Template version"""
  version: String!
}

"""Service template category enum"""
enum ServiceTemplateCategory {
  ANTI_CENSORSHIP
  GAMING
  MESSAGING
  NETWORKING
  PRIVACY
  SECURITY
}

"""
Traffic statistics for a service instance.
Tracks uploaded/downloaded bytes with historical data retention.
"""
type ServiceTrafficStats {
  """Download bytes in current period (day/week/month)"""
  currentPeriodDownload: Int!
  """Upload bytes in current period (day/week/month)"""
  currentPeriodUpload: Int!
  """Per-device breakdown (if available)"""
  deviceBreakdown: [DeviceTrafficBreakdown!]!
  """Historical data points for chart visualization"""
  history: [TrafficDataPoint!]!
  """Instance ID"""
  instanceID: ID!
  """Timestamp of last statistics update"""
  lastUpdated: DateTime!
  """Traffic quota configuration (if set)"""
  quota: TrafficQuota
  """Total bytes downloaded (received)"""
  totalDownloadBytes: Int!
  """Total bytes uploaded (transmitted)"""
  totalUploadBytes: Int!
}

"""Active user session"""
type Session {
  """Session creation time"""
  createdAt: DateTime!
  """Session ULID"""
  id: ID!
  """Client IP address"""
  ipAddress: String
  """Whether this is the current session"""
  isCurrent: Boolean!
  """Last activity time"""
  lastActivity: DateTime!
  """Client user agent"""
  userAgent: String
}

"""Input for setting kill switch on a device routing."""
input SetKillSwitchInput {
  """Device ID whose routing should have kill switch"""
  deviceID: String! @validate(minLength: 1, maxLength: 100)
  """Whether to enable kill switch"""
  enabled: Boolean!
  """Fallback interface ID (required if mode=FALLBACK_SERVICE)"""
  fallbackInterfaceID: String
  """Kill switch behavior mode"""
  mode: KillSwitchMode!
  """Router ID"""
  routerID: ID!
}

type SetPreferredProtocolPayload {
  """Updated connection details"""
  connectionDetails: ConnectionDetails
  """Errors that occurred"""
  errors: [MutationError!]
  """The updated router"""
  router: Router
}

"""Input for setting resource limits on a service instance."""
input SetResourceLimitsInput {
  """CPU weight for scheduling (0-100, optional)"""
  cpuWeight: Int @validate(min: 0, max: 100)
  """Instance ID"""
  instanceID: ID!
  """Memory limit in megabytes (minimum 16MB)"""
  memoryMB: Int! @validate(min: 16)
  """Router ID"""
  routerID: ID!
}

"""Input for setting a traffic quota on a service instance."""
input SetTrafficQuotaInput {
  """Action to take when quota is reached"""
  action: QuotaAction!
  """Instance ID to set quota on"""
  instanceID: ID!
  """Maximum bytes allowed per period (0 = unlimited)"""
  limitBytes: Int! @validate(min: 0)
  """Quota period"""
  period: QuotaPeriod!
  """Router ID"""
  routerID: ID!
  """Warning threshold percentage (0-100, default 80)"""
  warningThreshold: Int @validate(min: 0, max: 100)
}

"""Single device routing assignment for bulk operations."""
input SingleDeviceRoutingInput {
  """Device ID"""
  deviceID: String!
  """Device IP (optional)"""
  deviceIP: String
  """Device name (optional)"""
  deviceName: String
  """Instance ID"""
  instanceID: ID!
  """Interface ID"""
  interfaceID: ID!
  """Device MAC address"""
  macAddress: String!
  """Routing mark"""
  routingMark: String!
  """Routing mode"""
  routingMode: RoutingMode!
}

"""Size in bytes with optional unit (e.g., "1024", "1k", "1M", "1G")"""
scalar Size

"""Software information detected from router"""
type SoftwareInfo {
  """List of installed packages"""
  installedPackages: [String!]!
  """License level (0-6)"""
  licenseLevel: Int!
  """Update channel (stable, testing, development)"""
  updateChannel: String
  """RouterOS version string"""
  version: String!
  """Parsed major version number"""
  versionMajor: Int!
  """Parsed minor version number"""
  versionMinor: Int!
  """Parsed patch version number"""
  versionPatch: Int
}

"""Input for starting a service instance."""
input StartInstanceInput {
  """Instance ID to start"""
  instanceID: ID!
  """Router ID"""
  routerID: ID!
}

"""Result of starting a troubleshooting session"""
type StartTroubleshootPayload {
  """Errors that occurred"""
  errors: [MutationError!]
  """The created session"""
  session: TroubleshootSession
}

"""
Startup diagnostic results collected during instance boot.
Automatically run when a service starts.
"""
type StartupDiagnostics {
  """Number of tests that failed"""
  failedCount: Int!
  """Instance ID"""
  instanceID: ID!
  """Overall health status (pass if all tests passed)"""
  overallStatus: DiagnosticStatus!
  """Number of tests that passed"""
  passedCount: Int!
  """Test results"""
  results: [DiagnosticResult!]!
  """Run group ID linking these results together"""
  runGroupID: String!
  """Timestamp when diagnostics were run"""
  timestamp: DateTime!
  """Total number of tests run"""
  totalTests: Int!
  """Number of tests with warnings"""
  warningCount: Int!
}

"""Static IP WAN configuration"""
type StaticIPConfig implements Node {
  """Static IP address with CIDR"""
  address: CIDR! @mikrotik(path: "/ip/address", field: "address")
  """User comment"""
  comment: String
  """Gateway IP address"""
  gateway: IPv4! @mikrotik(path: "/ip/route", field: "gateway")
  """Unique identifier"""
  id: ID!
  """Interface name"""
  interface: String!
  """Primary DNS server"""
  primaryDNS: IPv4
  """Secondary DNS server"""
  secondaryDNS: IPv4
}

"""Input for configuring static IP WAN"""
input StaticIPInput {
  """Static IP address with CIDR (e.g., 203.0.113.5/30)"""
  address: CIDR!
  """User comment"""
  comment: String @validate(maxLength: 255)
  """Gateway IP address"""
  gateway: IPv4!
  """Interface to configure"""
  interface: String! @validate(minLength: 1, maxLength: 100)
  """Primary DNS server"""
  primaryDNS: IPv4
  """Secondary DNS server"""
  secondaryDNS: IPv4
}

"""A single data point in interface statistics history"""
type StatsDataPoint {
  """Receive rate in bytes per second"""
  rxBytesPerSec: Float!
  """Receive errors in this interval"""
  rxErrors: Int!
  """Receive rate in packets per second"""
  rxPacketsPerSec: Float!
  """Timestamp of the data point"""
  timestamp: DateTime!
  """Transmit rate in bytes per second"""
  txBytesPerSec: Float!
  """Transmission errors in this interval"""
  txErrors: Int!
  """Transmit rate in packets per second"""
  txPacketsPerSec: Float!
}

"""Input for specifying a time range"""
input StatsTimeRangeInput {
  """End of the time range"""
  end: DateTime!
  """Start of the time range"""
  start: DateTime!
}

"""Input for stopping a service instance."""
input StopInstanceInput {
  """Instance ID to stop"""
  instanceID: ID!
  """Router ID"""
  routerID: ID!
}

"""
Storage breakdown for a specific location (flash or external).
Shows what types of data are stored and capacity metrics.
"""
type StorageBreakdown {
  """Available free space in bytes (serialized uint64)"""
  availableBytes: String!
  """
  Human-readable description of contents (e.g., 'Configs, DB' or 'Binaries, data')
  """
  contents: String!
  """Storage location type"""
  locationType: StorageLocationType!
  """Space threshold status"""
  thresholdStatus: StorageThresholdStatus!
  """Total capacity in bytes (serialized uint64)"""
  totalBytes: String!
  """Usage percentage (0-100)"""
  usagePercent: Float!
  """Used space in bytes (serialized uint64)"""
  usedBytes: String!
}

"""
Storage configuration state.
Represents the current external storage configuration.
"""
type StorageConfig {
  """Whether external storage is enabled and configured"""
  enabled: Boolean!
  """Whether configured storage is currently available"""
  isAvailable: Boolean!
  """Configured external storage path (null if not configured)"""
  path: String
  """Storage info for configured path (null if not mounted)"""
  storageInfo: StorageInfo
  """When the configuration was last updated"""
  updatedAt: DateTime!
}

"""
Information about a storage location (flash or external).
Represents a detected mount point with capacity and filesystem information.
"""
type StorageInfo {
  """Available free space in bytes (serialized uint64)"""
  availableBytes: String!
  """Filesystem type (e.g., 'ext4', 'vfat', 'ntfs')"""
  filesystem: String!
  """Storage location type"""
  locationType: StorageLocationType!
  """Whether the storage is currently mounted and accessible"""
  mounted: Boolean!
  """Absolute path to the mount point (e.g., '/data', '/usb1', '/disk1')"""
  path: String!
  """Total capacity in bytes (serialized uint64)"""
  totalBytes: String!
  """Usage percentage (0-100, calculated from used/total)"""
  usagePercent: Float!
  """Used space in bytes (serialized uint64)"""
  usedBytes: String!
}

"""Type of storage location."""
enum StorageLocationType {
  """External USB/disk storage (large, removable)"""
  EXTERNAL
  """Internal flash memory (limited, persistent)"""
  FLASH
  """Unknown storage type"""
  UNKNOWN
}

"""Storage utilization metrics"""
type StorageMetrics {
  """Storage usage percentage (0-100)"""
  percentage: Float!
  """Total storage in bytes"""
  total: Float!
  """Used storage in bytes"""
  used: Float!
}

"""Union type for storage mount/unmount events."""
union StorageMountEvent = StorageMountedEvent | StorageUnmountedEvent

"""Event emitted when storage is mounted or becomes available."""
type StorageMountedEvent {
  """Number of features restored (if reconnection)"""
  featuresRestored: Int!
  """Storage path that was mounted"""
  path: String!
  """Storage information"""
  storageInfo: StorageInfo!
  """Timestamp of the event"""
  timestamp: DateTime!
}

"""Event emitted when storage space crosses a threshold."""
type StorageSpaceEvent {
  """Available bytes remaining (serialized uint64)"""
  availableBytes: String!
  """Storage path"""
  path: String!
  """Previous threshold status"""
  previousStatus: StorageThresholdStatus!
  """Current threshold status"""
  status: StorageThresholdStatus!
  """Timestamp of the event"""
  timestamp: DateTime!
  """Current usage percentage"""
  usagePercent: Float!
}

"""
Storage space threshold status.
Used to trigger warnings and prevent installations when space is low.
"""
enum StorageThresholdStatus {
  """Critical space warning (90-94%)"""
  CRITICAL
  """Full - installations blocked (95%+)"""
  FULL
  """Low space warning (80-89%)"""
  LOW
  """Normal usage (<80%)"""
  NORMAL
}

"""Event emitted when storage is unmounted or becomes unavailable."""
type StorageUnmountedEvent {
  """List of affected feature IDs"""
  affectedFeatureIds: [String!]!
  """Number of features affected (stopped)"""
  featuresAffected: Int!
  """Storage path that was unmounted"""
  path: String!
  """Timestamp of the event"""
  timestamp: DateTime!
}

"""
Comprehensive storage usage breakdown across flash and external locations.
Shows how storage is allocated across configs, binaries, data, and per-feature.
"""
type StorageUsage {
  """Timestamp when usage was calculated"""
  calculatedAt: DateTime!
  """External storage usage breakdown (null if not configured)"""
  external: StorageBreakdown
  """Per-feature storage usage details"""
  features: [FeatureStorageUsage!]!
  """Flash memory usage breakdown"""
  flash: StorageBreakdown!
  """
  Total available capacity across all locations in bytes (serialized uint64)
  """
  totalCapacityBytes: String!
  """Total storage usage across all locations in bytes (serialized uint64)"""
  totalUsedBytes: String!
}

"""Alert rule contribution to storm detection"""
type StormRuleContribution {
  """Number of alerts from this rule in current window"""
  alertCount: Int!
  """Percentage of total alerts"""
  percentage: Float!
  """Alert rule ID"""
  ruleId: ID!
  """Alert rule name"""
  ruleName: String!
}

"""
Storm detection status
Shows if alert storm is detected and current metrics
"""
type StormStatus {
  """Number of alerts in current window"""
  alertCount: Int!
  """Whether storm is currently detected"""
  isStormDetected: Boolean!
  """When storm detection started"""
  stormStartedAt: DateTime
  """Storm detection threshold"""
  threshold: Int!
  """Top alert rules contributing to the storm"""
  topRules: [StormRuleContribution!]!
  """When current window ends"""
  windowEnd: DateTime!
  """Window duration in seconds"""
  windowSeconds: Int!
  """When current window started"""
  windowStart: DateTime!
}

enum StpPortRole {
  ALTERNATE
  BACKUP
  DESIGNATED
  DISABLED
  ROOT
}

enum StpPortState {
  BLOCKING
  DISABLED
  FORWARDING
  LEARNING
  LISTENING
}

enum StpProtocol {
  MSTP
  NONE
  RSTP
  STP
}

type Subscription {
  """Subscribe to alert events for real-time updates"""
  alertEvents(
    """Filter by device ID"""
    deviceId: ID
  ): AlertEvent!
  """
  Subscribe to boot sequence events for real-time progress updates.
  Emits events during system boot when auto-start instances are being started.
  """
  bootSequenceEvents: BootSequenceEvent!
  """Subscribe to bridge port changes"""
  bridgePortsChanged(bridgeId: ID!): [BridgePort!]!
  """Subscribe to STP status changes for a bridge"""
  bridgeStpStatusChanged(bridgeId: ID!): BridgeStpStatus!
  """Subscribe to change set application progress"""
  changeSetProgress(
    """Change set ID"""
    changeSetId: ID!
  ): ChangeSetProgressEvent!
  """Subscribe to change set status changes"""
  changeSetStatusChanged(
    """Router to subscribe to"""
    routerId: ID!
  ): ChangeSetStatusEvent!
  """Subscribe to circuit breaker state changes"""
  circuitBreakerChanged(
    """Router ID to monitor"""
    routerId: ID!
  ): CircuitBreakerEvent!
  """
  Subscribe to circuit breaker state changes for a router.
  Emits an event whenever the circuit breaker transitions between states.
  """
  circuitBreakerStateChanged(
    """Router ID to monitor (optional, all routers if not specified)"""
    routerId: ID
  ): CircuitBreakerStatus!
  """Subscribe to configuration apply progress"""
  configApplyProgress(operationId: ID!): ConfigProgress!
  """Subscribe to connection health updates"""
  connectionHealth(
    """Router ID to monitor (optional, all routers if not specified)"""
    routerId: ID
  ): HealthCheckResult!
  """
  Subscribe to device routing changes for a router.
  Emits events when devices are assigned, removed, or updated.
  """
  deviceRoutingChanged(
    """Router ID to subscribe to"""
    routerID: ID!
  ): DeviceRoutingEvent!
  """
  Subscribe to diagnostic progress updates.
  Emits events as each test completes during a diagnostic run.
  """
  diagnosticsProgress(
    """Instance ID to monitor"""
    instanceID: ID!
    """Router ID to subscribe to"""
    routerID: ID!
  ): DiagnosticsProgress!
  """
  Subscribe to installation progress events for a router.
  Emits progress updates during binary download and installation.
  """
  installProgress(
    """Router ID to subscribe to"""
    routerID: ID!
  ): InstallProgress!
  """
  Real-time health status changes for a service instance
  Streams updates when health state transitions (HEALTHY  UNHEALTHY)
  """
  instanceHealthChanged(
    """
    Optional instance ID to filter specific instance (null = all instances on router)
    """
    instanceID: ID
    """Router ID to filter events"""
    routerID: ID!
  ): ServiceInstanceHealth!
  """
  Subscribe to instance status changes for a router.
  Emits events when any instance changes state.
  """
  instanceStatusChanged(
    """Router ID to subscribe to"""
    routerID: ID!
  ): InstanceStatusChanged!
  """Subscribe to real-time interface statistics updates"""
  interfaceStatsUpdated(
    """Interface ID to monitor"""
    interfaceId: ID!
    """Polling interval (default: 5s, minimum: 1s)"""
    interval: Duration = "5s"
    """Router ID to monitor"""
    routerId: ID!
  ): InterfaceStats! @capability(requires: ["interface"])
  """Subscribe to interface status changes for real-time updates"""
  interfaceStatusChanged(
    """
    Optional interface ID to filter events (if not provided, all interfaces)
    """
    interfaceId: ID
    """Router ID to monitor"""
    routerId: ID!
  ): InterfaceStatusEvent!
  """Subscribe to interface traffic updates"""
  interfaceTraffic(interfaceId: ID, routerId: ID!): InterfaceTrafficEvent! @realtime(interval: 1000)
  """Subscribe to IP address changes (create, update, delete)"""
  ipAddressChanged(
    """Router ID to monitor"""
    routerId: ID!
  ): IpAddressChangeEvent! @capability(requires: ["interface"])
  """
  Subscribe to kill switch state changes for a router.
  Emits events when kill switch is activated, deactivated, or configuration changes.
  """
  killSwitchChanged(
    """Router ID to subscribe to"""
    routerID: ID!
  ): DeviceRoutingEvent!
  """Subscribe to port mirror status changes"""
  portMirrorChanged(
    """Router ID to monitor"""
    routerId: ID!
  ): PortMirror! @capability(requires: ["interface"])
  """Subscribe to real-time resource metrics updates"""
  resourceMetrics(
    """Device ID to monitor"""
    deviceId: ID!
  ): ResourceMetrics! @realtime(interval: 2000)
  """Subscribe to resource runtime updates"""
  resourceRuntime(
    """Resource ID (ULID)"""
    id: ID!
    """Router the resource belongs to"""
    routerId: ID!
  ): ResourceRuntimeEvent! @realtime(interval: 5000)
  """Subscribe to resource lifecycle state changes"""
  resourceStateChanged(
    """Resource ID (optional - subscribe to all if not provided)"""
    id: ID
    """Router to subscribe to"""
    routerId: ID!
  ): ResourceStateEvent!
  """Subscribe to resource updates (create, update, delete)"""
  resourceUpdated(resourceId: ID): ResourceUpdatedEvent!
  """
  Subscribe to resource usage changes for a specific instance.
  Emits updates when memory usage changes significantly or crosses thresholds.
  """
  resourceUsageChanged(
    """Instance ID to monitor"""
    instanceID: ID!
    """Router ID to subscribe to"""
    routerID: ID!
  ): ResourceUsage!
  """
  Subscribe to router addition events.
  Emits when a new router is successfully added to the system.
  """
  routerAdded: RouterAddedEvent!
  """Subscribe to router status changes"""
  routerStatusChanged(routerId: ID): RouterStatusEvent!
  """
  Real-time updates when any routing chain changes (create, update, remove, kill switch).
  """
  routingChainChanged(
    """Router ID to subscribe to"""
    routerID: ID!
  ): RoutingChain!
  """
  Subscribe to real-time scan progress updates.
  Emits events every 5% progress or every 2 seconds, whichever is sooner.
  """
  scanProgress(taskId: ID!): ScanProgressEvent!
  """
  Subscribe to schedule changes for a router.
  Emits events when schedules are created, updated, deleted, or when activation state changes.
  """
  scheduleChanged(
    """Router ID to subscribe to"""
    routerID: ID!
  ): ScheduleEvent!
  """
  Subscribe to service configuration sharing events.
  Emits events when configs are exported, imported, or QR codes generated.
  """
  serviceConfigShared(
    """Router ID to subscribe to"""
    routerID: ID!
  ): ServiceConfigSharedEvent!
  """
  Subscribe to real-time log stream for a service instance.
  Emits new log entries as they are generated.
  """
  serviceLogs(
    """Instance ID to monitor"""
    instanceID: ID!
    """Optional log level filter"""
    levelFilter: LogLevel
    """Router ID to subscribe to"""
    routerID: ID!
  ): LogEntry!
  """
  Subscribe to traffic statistics updates for a service instance.
  Emits updates every 10 seconds with current traffic totals and deltas.
  """
  serviceTrafficUpdated(
    """Instance ID to monitor"""
    instanceID: ID!
    """Router ID to subscribe to"""
    routerID: ID!
  ): TrafficStatsEvent!
  """
  Subscribe to storage mount/unmount events.
  Emits when external storage becomes available or unavailable.
  """
  storageMountChanged(
    """Optional path filter (if not provided, all storage events)"""
    path: String
  ): StorageMountEvent!
  """
  Subscribe to storage space threshold events.
  Emits when storage usage crosses 80%, 90%, or 95% thresholds.
  """
  storageSpaceChanged(
    """Optional path filter (if not provided, all storage events)"""
    path: String
  ): StorageSpaceEvent!
  """
  Subscribe to template installation progress.
  Emits progress updates during installation.
  """
  templateInstallProgress(
    """Router ID"""
    routerID: ID!
  ): TemplateInstallProgress!
  """
  Subscribe to traceroute progress updates.
  Emits an event for each hop discovered and when traceroute completes.
  """
  tracerouteProgress(
    """Job ID to monitor"""
    jobId: ID!
  ): TracerouteProgressEvent!
  """
  Subscribe to troubleshooting session progress.
  Emits events as steps are executed, fixes are applied, and results are updated.
  """
  troubleshootProgress(sessionId: ID!): TroubleshootSession!
  """Subscribe to tunnel status changes (create, update, delete)"""
  tunnelChanged(
    """Router ID to monitor"""
    routerId: ID!
  ): Tunnel! @capability(requires: ["interface"])
  """
  Subscribe to update progress for a router.
  Emits progress updates during atomic update process.
  """
  updateProgress(
    """Router ID to subscribe to"""
    routerID: ID!
  ): UpdateProgress!
  """
  Subscribe to binary verification events for a router.
  Emits events when binaries are verified, verification fails, or integrity checks fail.
  """
  verificationEvents(
    """Router ID to subscribe to"""
    routerID: ID!
  ): VerificationEvent!
  """Subscribe to VLAN interface changes (create, update, delete)"""
  vlanChanged(
    """Router ID to monitor"""
    routerId: ID!
  ): Vlan! @capability(requires: ["interface"])
  """Subscribe to WAN health check updates"""
  wanHealthChanged(
    """Router ID"""
    routerId: ID!
    """WAN interface ID"""
    wanInterfaceId: ID!
  ): WANHealthStatus! @capability(requires: ["interface"])
  """Subscribe to WAN status changes"""
  wanStatusChanged(
    """Router ID"""
    routerId: ID!
    """Optional WAN interface ID filter"""
    wanInterfaceId: ID
  ): WANInterface! @capability(requires: ["interface"])
}

"""Routing suggestion for a template"""
type SuggestedRoutingRule {
  """Rule description"""
  description: String!
  """Destination port filter"""
  destinationPort: Int
  """Device name pattern (e.g., 'all', 'phone-*')"""
  devicePattern: String!
  """Protocol filter"""
  protocol: String
  """Target service name from template"""
  targetService: String!
}

"""Severity level for diagnostic suggestions"""
enum SuggestionSeverity {
  """Critical issue blocking connectivity"""
  CRITICAL
  """Error that needs to be addressed"""
  ERROR
  """Informational message, no action required"""
  INFO
  """Warning that may affect functionality"""
  WARNING
}

"""
System-wide resource overview for a router.
Shows total resources, available resources, and per-instance allocations.
"""
type SystemResources {
  """Total allocated RAM across all instances in megabytes"""
  allocatedRAM: Int!
  """Available (unallocated) RAM in megabytes"""
  availableRAM: Int!
  """Per-instance resource usage details"""
  instances: [InstanceResourceUsage!]!
  """Total RAM available on the router in megabytes"""
  totalRAM: Int!
}

"""TLS certificate status for secure connections"""
type TLSStatus {
  """Error message (if certificate is invalid)"""
  error: String
  """Certificate expiration date"""
  expiresAt: DateTime
  """Certificate issuer"""
  issuer: String
  """Certificate subject"""
  subject: String
  """Whether the certificate is valid"""
  valid: Boolean!
}

"""
Layer 5: Time-series metrics and historical data.
Collected over time for analytics and trending.
"""
type TelemetryData {
  """Bandwidth history (last 24h)"""
  bandwidthHistory: [BandwidthDataPoint!]
  """Daily statistics"""
  dailyStats: [DailyStats!]
  """First data point timestamp"""
  dataStartedAt: DateTime
  """Hourly statistics"""
  hourlyStats: [HourlyStats!]
  """Last data point timestamp"""
  lastUpdatedAt: DateTime
  """Data retention period"""
  retentionDays: Int!
  """Uptime history (availability)"""
  uptimeHistory: [UptimeDataPoint!]
}

"""Template categories for organization."""
enum TemplateCategory {
  """Basic security rules"""
  BASIC
  """User-created custom templates"""
  CUSTOM
  """Gaming-optimized rules"""
  GAMING
  """Guest network access"""
  GUEST
  """Home network configurations"""
  HOME
  """IoT device isolation"""
  IOT
}

"""Template complexity levels."""
enum TemplateComplexity {
  """Advanced templates with many rules"""
  ADVANCED
  """Moderate complexity"""
  MODERATE
  """Simple templates with few rules"""
  SIMPLE
}

"""Detected conflict between template and existing configuration."""
type TemplateConflict {
  """Existing rule ID that conflicts (if applicable)"""
  existingRuleId: ID
  """Human-readable conflict description"""
  message: String!
  """Proposed template rule that conflicts"""
  proposedRule: TemplateRule!
  """Type of conflict"""
  type: TemplateConflictType!
}

"""Conflict types between template and existing configuration."""
enum TemplateConflictType {
  """Chain configuration conflicts"""
  CHAIN_CONFLICT
  """Duplicate rule already exists"""
  DUPLICATE_RULE
  """IP address range overlaps"""
  IP_OVERLAP
  """Position conflict in chain"""
  POSITION_CONFLICT
}

"""Template installation progress"""
type TemplateInstallProgress {
  """Installation completion time"""
  completedAt: DateTime
  """Current service being installed"""
  currentService: String
  """Error message if failed"""
  errorMessage: String
  """Number of services installed"""
  installedCount: Int!
  """Individual service results"""
  serviceResults: [ServiceResult!]!
  """Installation start time"""
  startedAt: DateTime!
  """Installation status"""
  status: TemplateInstallationStatus!
  """Template ID being installed"""
  templateID: ID!
  """Total number of services"""
  totalServices: Int!
}

"""Template installation result"""
type TemplateInstallResult {
  """Errors encountered"""
  errors: [String!]
  """Created instance IDs"""
  instanceIDs: [ID!]!
  """Installation progress"""
  progress: TemplateInstallProgress
  """Map of service names to instance IDs"""
  serviceMapping: JSON!
  """Whether installation was successful"""
  success: Boolean!
}

"""Template installation status"""
enum TemplateInstallationStatus {
  COMPLETED
  FAILED
  IN_PROGRESS
  PARTIAL
  PENDING
}

"""Template preview result"""
type TemplatePreview {
  """Rendered body after variable substitution"""
  renderedBody: String!
  """Rendered subject after variable substitution"""
  renderedSubject: String!
  """The template that was previewed"""
  template: AlertTemplate!
  """Validation information"""
  validationInfo: TemplateValidationInfo!
  """Variables used in preview"""
  variables: JSON!
}

"""Template preview payload"""
type TemplatePreviewPayload {
  """Errors encountered during preview"""
  errors: [MutationError!]
  """Preview result"""
  preview: TemplatePreview
}

"""
Result of template preview operation.
Shows what will happen when template is applied.
"""
type TemplatePreviewResult {
  """Detected conflicts with existing rules"""
  conflicts: [TemplateConflict!]!
  """Impact analysis"""
  impactAnalysis: ImpactAnalysis!
  """Rules with variables resolved"""
  resolvedRules: [TemplateRule!]!
  """The template being previewed"""
  template: FirewallTemplate!
}

"""
Template rule definition.
Represents a firewall rule that will be created when template is applied.
"""
type TemplateRule {
  """Action to perform"""
  action: String!
  """Chain name"""
  chain: String!
  """Optional comment (can include template metadata)"""
  comment: String
  """Position in the chain (null = append to end)"""
  position: Int
  """
  Rule properties as JSON (can include variable references like {{LAN_INTERFACE}})
  """
  properties: JSON!
  """Firewall table (filter, nat, mangle, raw)"""
  table: FirewallTable!
}

"""Input for defining a template rule."""
input TemplateRuleInput {
  """Action"""
  action: String! @validate(minLength: 1, maxLength: 50)
  """Chain name"""
  chain: String! @validate(minLength: 1, maxLength: 50)
  """Comment"""
  comment: String @validate(maxLength: 200)
  """Position"""
  position: Int
  """Rule properties as JSON"""
  properties: JSON!
  """Firewall table"""
  table: FirewallTable!
}

"""Template deployment scope"""
enum TemplateScope {
  """Chained services (e.g., Tor -> Xray)"""
  CHAIN
  """Multiple independent services"""
  MULTIPLE
  """Single service instance"""
  SINGLE
}

"""Template validation information"""
type TemplateValidationInfo {
  """Whether the template is valid with provided variables"""
  isValid: Boolean!
  """Missing required variables"""
  missingVariables: [String!]!
  """Validation warnings"""
  warnings: [String!]!
}

"""Configuration variable for a template"""
type TemplateVariable {
  """Default value (can be null)"""
  default: JSON
  """Human-readable description"""
  description: String!
  """Allowed values for enum types"""
  enumValues: [JSON!]
  """Display label for UI"""
  label: String!
  """Maximum value for number types"""
  maxValue: Float
  """Minimum value for number types"""
  minValue: Float
  """Variable name (e.g., 'TOR_NAME')"""
  name: String!
  """Whether the variable is required"""
  required: Boolean!
  """Variable type"""
  type: TemplateVariableType!
  """Regex pattern for validation"""
  validationPattern: String
}

"""Template variable type"""
enum TemplateVariableType {
  BOOLEAN
  ENUM
  IP
  NUMBER
  PORT
  STRING
}

"""Result of testing all router credentials."""
type TestAllCredentialsPayload {
  """Number of failed credential tests"""
  failureCount: Int!
  """Per-router test results"""
  results: [CredentialTestResult!]!
  """Number of successful credential tests"""
  successCount: Int!
  """Total number of routers tested"""
  totalRouters: Int!
}

type TestConnectionPayload {
  """Error message if connection failed"""
  error: String
  """Response time in milliseconds"""
  responseTimeMs: Int
  """Whether the connection test succeeded"""
  success: Boolean!
  """Router version if connection succeeded"""
  version: String
}

"""Test notification payload"""
type TestNotificationPayload {
  """Errors encountered during test"""
  errors: [MutationError!]
  """Test result message"""
  message: String
  """Whether test was successful"""
  success: Boolean!
}

"""Result of test port knock operation."""
type TestPortKnockResult {
  """Message"""
  message: String!
  """Whether test rules were created successfully"""
  success: Boolean!
  """Test instructions for user"""
  testInstructions: String!
  """Test rule IDs (will auto-expire)"""
  testRuleIds: [ID!]!
}

"""Throttle configuration to prevent alert spam"""
type ThrottleConfig {
  """Optional field to group alerts by"""
  groupByField: String
  """Maximum number of alerts allowed"""
  maxAlerts: Int!
  """Time period in seconds"""
  periodSeconds: Int!
}

"""Throttle configuration input"""
input ThrottleConfigInput {
  """Optional field to group alerts by"""
  groupByField: String
  """Maximum number of alerts allowed"""
  maxAlerts: Int!
  """Time period in seconds"""
  periodSeconds: Int!
}

"""Throttle status for a specific group (when groupByField is used)"""
type ThrottleGroupStatus {
  """Group identifier (value of groupByField)"""
  groupKey: String!
  """Whether this group is currently throttled"""
  isThrottled: Boolean!
  """Number of alerts suppressed for this group"""
  suppressedCount: Int!
  """When the throttle window for this group ends"""
  windowEnd: DateTime!
  """When the throttle window for this group started"""
  windowStart: DateTime!
}

"""
Throttle status for an alert rule
Shows current throttling state and suppressed alert counts
"""
type ThrottleStatus {
  """Throttle groups (if groupByField is configured)"""
  groups: [ThrottleGroupStatus!]!
  """Whether the rule is currently throttled"""
  isThrottled: Boolean!
  """Alert rule ID"""
  ruleId: ID!
  """Number of alerts suppressed in current throttle window"""
  suppressedCount: Int!
  """When the current throttle window ends"""
  windowEnd: DateTime
  """When the current throttle window started"""
  windowStart: DateTime
}

"""Edge connecting nodes in a topology"""
type TopologyEdge {
  """Additional edge data"""
  data: JSON
  """Edge ID"""
  id: ID!
  """Edge label (optional)"""
  label: String
  """Source node ID"""
  source: ID!
  """Edge styling"""
  style: TopologyEdgeStyle
  """Target node ID"""
  target: ID!
}

"""Styling for topology edges"""
type TopologyEdgeStyle {
  """Stroke color (CSS color)"""
  stroke: String
  """Stroke dash array (for dashed lines)"""
  strokeDasharray: String
  """Stroke width in pixels"""
  strokeWidth: Float
}

"""Node in a VLAN network topology diagram"""
type TopologyNode {
  """Additional node data"""
  data: JSON
  """Node ID"""
  id: ID!
  """Display label"""
  label: String!
  """Node position in the diagram"""
  position: TopologyPosition!
  """Node styling"""
  style: TopologyNodeStyle
  """Sub-label (optional)"""
  sublabel: String
  """Node type (bridge, vlan, port)"""
  type: TopologyNodeType!
}

"""Styling for topology nodes"""
type TopologyNodeStyle {
  """Fill color (CSS color)"""
  fill: String
  """Stroke color (CSS color)"""
  stroke: String
  """Stroke width in pixels"""
  strokeWidth: Float
}

"""Type of topology node"""
enum TopologyNodeType {
  """Bridge interface"""
  BRIDGE
  """Physical port"""
  PORT
  """VLAN interface"""
  VLAN
}

"""Position of a node in the topology"""
type TopologyPosition {
  """X coordinate"""
  x: Float!
  """Y coordinate"""
  y: Float!
}

"""Event type for traceroute progress updates"""
enum TracerouteEventType {
  """Traceroute was cancelled"""
  CANCELLED
  """Traceroute completed"""
  COMPLETE
  """Traceroute encountered an error"""
  ERROR
  """A new hop was discovered"""
  HOP_DISCOVERED
}

"""A single hop in the traceroute path"""
type TracerouteHop {
  """IP address of the hop (null for timeout)"""
  address: String
  """Average latency across successful probes"""
  avgLatencyMs: Float
  """Hop number (1-based)"""
  hopNumber: Int!
  """Reverse DNS hostname (if available)"""
  hostname: String
  """Packet loss percentage for this hop (0-100)"""
  packetLoss: Float!
  """Individual probe results for this hop"""
  probes: [HopProbe!]!
  """Status of this hop"""
  status: HopStatus!
}

"""Input parameters for starting a traceroute"""
input TracerouteInput {
  """Maximum number of hops (default: 30, max: 64)"""
  maxHops: Int = 30
  """Number of probes per hop (default: 3)"""
  probeCount: Int = 3
  """Protocol to use for probes (default: ICMP)"""
  protocol: TracerouteProtocol = ICMP
  """Target hostname or IP address"""
  target: String!
  """Timeout per hop in milliseconds (default: 3000)"""
  timeout: Int = 3000
}

"""Traceroute job reference for subscription tracking"""
type TracerouteJob {
  """Unique job identifier"""
  jobId: ID!
  """Current job status"""
  status: JobStatus!
}

"""Progress event emitted during traceroute execution"""
type TracerouteProgressEvent {
  """Error message (for ERROR events)"""
  error: String
  """Type of event"""
  eventType: TracerouteEventType!
  """Newly discovered hop (for HOP_DISCOVERED events)"""
  hop: TracerouteHop
  """Job identifier"""
  jobId: ID!
  """Final result (for COMPLETE events)"""
  result: TracerouteResult
}

"""Protocol to use for traceroute probes"""
enum TracerouteProtocol {
  """ICMP echo request (default)"""
  ICMP
  """TCP SYN probes"""
  TCP
  """UDP probes"""
  UDP
}

"""Complete traceroute result"""
type TracerouteResult {
  """Whether traceroute completed"""
  completed: Boolean!
  """When the traceroute completed (if finished)"""
  completedAt: DateTime
  """Discovered hops in order"""
  hops: [TracerouteHop!]!
  """Maximum hops configured"""
  maxHops: Int!
  """Protocol used for probes"""
  protocol: TracerouteProtocol!
  """Whether destination was reached"""
  reachedDestination: Boolean!
  """When the traceroute started"""
  startedAt: DateTime!
  """Target hostname or IP address"""
  target: String!
  """Resolved target IP address"""
  targetIp: String!
  """Total time from start to completion (ms)"""
  totalTimeMs: Float!
}

"""
A single traffic data point for time-series visualization.
Represents traffic volume at a specific timestamp.
"""
type TrafficDataPoint {
  """Bytes downloaded in this interval"""
  downloadBytes: Int!
  """Timestamp of this data point"""
  timestamp: DateTime!
  """Total bytes (upload + download)"""
  totalBytes: Int!
  """Bytes uploaded in this interval"""
  uploadBytes: Int!
}

"""
Traffic quota configuration for a service instance.
Allows setting bandwidth limits with automated warnings and actions.
"""
type TrafficQuota {
  """Action to take when quota is reached"""
  action: QuotaAction!
  """Bytes consumed in current period"""
  consumedBytes: Int!
  """Timestamp when quota was created"""
  createdAt: DateTime!
  """Quota ID"""
  id: ID!
  """Instance ID this quota applies to"""
  instanceID: ID!
  """Maximum bytes allowed per period (0 = unlimited)"""
  limitBytes: Int!
  """Whether quota limit has been reached"""
  limitReached: Boolean!
  """Quota period (daily, weekly, monthly)"""
  period: QuotaPeriod!
  """When the current period will reset"""
  periodEndsAt: DateTime!
  """When the current period started"""
  periodStartedAt: DateTime!
  """Remaining bytes in current period"""
  remainingBytes: Int!
  """Timestamp when quota was last updated"""
  updatedAt: DateTime!
  """Usage percentage (0-100)"""
  usagePercent: Float!
  """Warning threshold percentage (0-100, triggers warning alert)"""
  warningThreshold: Int!
  """Whether warning threshold has been exceeded"""
  warningTriggered: Boolean!
}

"""Payload for traffic quota mutation."""
type TrafficQuotaPayload {
  """Mutation errors"""
  errors: [MutationError!]
  """Updated or created quota (null if failed)"""
  quota: TrafficQuota
  """Whether the operation succeeded"""
  success: Boolean!
}

"""
Traffic statistics update event for subscriptions.
Emitted when traffic stats are updated (every 10 seconds).
"""
type TrafficStatsEvent {
  """Download bytes since last update"""
  deltaDownloadBytes: Int!
  """Upload bytes since last update"""
  deltaUploadBytes: Int!
  """Instance ID"""
  instanceID: ID!
  """Whether quota limit was reached"""
  quotaLimitReached: Boolean!
  """Whether quota warning was triggered"""
  quotaWarning: Boolean!
  """Router ID"""
  routerID: ID!
  """Timestamp of this update"""
  timestamp: DateTime!
  """Total bytes downloaded"""
  totalDownloadBytes: Int!
  """Total bytes uploaded"""
  totalUploadBytes: Int!
}

"""Transport protocol enum for network traffic."""
enum TransportProtocol {
  TCP
  UDP
}

"""Suggested fix for a failed diagnostic step"""
type TroubleshootFixSuggestion {
  """RouterOS command that will be executed"""
  command: String
  """Confidence level for this fix"""
  confidence: FixConfidence!
  """Detailed explanation of what will be fixed"""
  explanation: String!
  """Whether this is a manual fix (requires user action)"""
  isManualFix: Boolean!
  """Unique issue code (e.g., WAN_DISABLED, NO_DEFAULT_ROUTE)"""
  issueCode: String!
  """Manual steps if this cannot be automated"""
  manualSteps: [String!]
  """Whether user confirmation is required before applying"""
  requiresConfirmation: Boolean!
  """Rollback command if fix needs to be reverted"""
  rollbackCommand: String
  """User-friendly fix title"""
  title: String!
}

"""Complete troubleshooting session"""
type TroubleshootSession {
  """Fixes that have been applied"""
  appliedFixes: [String!]!
  """When the session completed"""
  completedAt: DateTime
  """Current step index (0-based)"""
  currentStepIndex: Int!
  """Detected default gateway IP"""
  gateway: String
  """Unique session identifier"""
  id: ID!
  """Detected ISP information"""
  ispInfo: ISPInfo
  """Router being diagnosed"""
  routerId: ID!
  """When the session started"""
  startedAt: DateTime!
  """Overall session status"""
  status: TroubleshootSessionStatus!
  """All diagnostic steps"""
  steps: [TroubleshootStep!]!
  """Detected WAN interface name"""
  wanInterface: String
}

"""Overall status of a troubleshooting session"""
enum TroubleshootSessionStatus {
  """Applying a fix"""
  APPLYING_FIX
  """Waiting for user decision on fix"""
  AWAITING_FIX_DECISION
  """Session was cancelled"""
  CANCELLED
  """Session completed"""
  COMPLETED
  """Session created but not started"""
  IDLE
  """Detecting network configuration"""
  INITIALIZING
  """Running diagnostic steps"""
  RUNNING
  """Verifying fix worked"""
  VERIFYING_FIX
}

"""A single step in the troubleshooting wizard"""
type TroubleshootStep {
  """When the step completed"""
  completedAt: DateTime
  """Step description"""
  description: String!
  """Suggested fix if step failed"""
  fix: TroubleshootFixSuggestion
  """Step type/ID"""
  id: TroubleshootStepType!
  """Step display name"""
  name: String!
  """Result of executing this step"""
  result: TroubleshootStepResult
  """When the step started"""
  startedAt: DateTime
  """Current status of this step"""
  status: TroubleshootStepStatus!
}

"""Result of a single diagnostic step"""
type TroubleshootStepResult {
  """Technical details for debugging"""
  details: String
  """Execution time in milliseconds"""
  executionTimeMs: Int!
  """Detected error code"""
  issueCode: String
  """User-friendly message about the result"""
  message: String!
  """Whether the check passed"""
  success: Boolean!
  """Target that was checked (IP, interface name, etc.)"""
  target: String
}

"""Status of a diagnostic step"""
enum TroubleshootStepStatus {
  """Step failed"""
  FAILED
  """Step completed successfully"""
  PASSED
  """Step not yet started"""
  PENDING
  """Step currently executing"""
  RUNNING
  """Step skipped"""
  SKIPPED
}

"""Diagnostic step identifier for internet troubleshooting"""
enum TroubleshootStepType {
  """Test DNS resolution"""
  DNS
  """Ping default gateway"""
  GATEWAY
  """Ping external internet server"""
  INTERNET
  """Verify NAT/masquerade rules"""
  NAT
  """Check WAN interface status"""
  WAN
}

"""A network tunnel interface for connecting remote networks"""
type Tunnel implements Node {
  """User comment"""
  comment: String @validate(maxLength: 255) @mikrotik(path: "/interface/{type}", field: "comment")
  """Whether the tunnel is disabled"""
  disabled: Boolean @mikrotik(path: "/interface/{type}", field: "disabled")
  """Unique tunnel identifier"""
  id: ID!
  """IPsec profile name (GRE tunnels only)"""
  ipsecProfile: String @mikrotik(path: "/interface/gre", field: "ipsec-profile")
  """Local endpoint IP address"""
  localAddress: String! @validate(format: IPV4) @mikrotik(path: "/interface/{type}", field: "local-address")
  """MTU setting for the tunnel interface"""
  mtu: Int @validate(min: 68, max: 65535) @mikrotik(path: "/interface/{type}", field: "mtu")
  """Tunnel interface name"""
  name: String! @validate(minLength: 1, maxLength: 100, pattern: "^[a-zA-Z0-9_-]+$") @mikrotik(path: "/interface/{type}", field: "name")
  """VXLAN port (default 4789)"""
  port: Int @validate(min: 1, max: 65535) @mikrotik(path: "/interface/vxlan", field: "port")
  """Remote endpoint IP address"""
  remoteAddress: String! @validate(format: IPV4) @mikrotik(path: "/interface/{type}", field: "remote-address")
  """Traffic statistics for this tunnel"""
  statistics: InterfaceStats
  """Operational status of the tunnel"""
  status: InterfaceStatus!
  """Tunnel ID (EoIP tunnels only, must be unique per remote address pair)"""
  tunnelId: Int @validate(min: 0, max: 65535) @mikrotik(path: "/interface/eoip", field: "tunnel-id")
  """Tunnel protocol type"""
  type: TunnelType!
  """VXLAN Network Identifier (VXLAN tunnels only)"""
  vni: Int @validate(min: 1, max: 16777215) @mikrotik(path: "/interface/vxlan", field: "vni")
  """VTEP peer addresses (VXLAN tunnels only)"""
  vtepPeers: [String!] @mikrotik(path: "/interface/vxlan/vteps", field: "remote-ip")
}

"""Input for creating or updating a tunnel"""
input TunnelInput {
  """User comment"""
  comment: String @validate(maxLength: 255)
  """IPsec profile name (GRE tunnels only)"""
  ipsecProfile: String
  """Local endpoint IP address"""
  localAddress: String! @validate(format: IPV4)
  """MTU setting (optional, default calculated based on tunnel type)"""
  mtu: Int @validate(min: 68, max: 65535)
  """Tunnel interface name (alphanumeric, hyphens, underscores)"""
  name: String! @validate(minLength: 1, maxLength: 100, pattern: "^[a-zA-Z0-9_-]+$")
  """VXLAN port (default 4789)"""
  port: Int @validate(min: 1, max: 65535)
  """Remote endpoint IP address"""
  remoteAddress: String! @validate(format: IPV4)
  """Tunnel ID (EoIP tunnels only, 0-65535)"""
  tunnelId: Int @validate(min: 0, max: 65535)
  """Tunnel protocol type"""
  type: TunnelType!
  """VXLAN Network Identifier (VXLAN tunnels only, 1-16777215)"""
  vni: Int @validate(min: 1, max: 16777215)
  """VTEP peer addresses (VXLAN tunnels only)"""
  vtepPeers: [String!]
}

"""Result of a tunnel mutation (create, update)"""
type TunnelMutationResult {
  """Errors that occurred during the operation"""
  errors: [String!]!
  """MTU guidance for the tunnel type"""
  mtuGuidance: MtuGuidance
  """Configuration preview (RouterOS commands)"""
  preview: String
  """Whether the operation succeeded"""
  success: Boolean!
  """The created or updated tunnel (if successful)"""
  tunnel: Tunnel
}

"""Status of a VPN tunnel"""
enum TunnelStatus {
  """Tunnel is connected and active"""
  CONNECTED
  """Tunnel is attempting to connect"""
  CONNECTING
  """Tunnel is disconnected"""
  DISCONNECTED
}

"""Result of a tunnel connectivity test"""
type TunnelTestResult {
  """Average ping latency in milliseconds (null if unreachable)"""
  latency: Float
  """Path MTU discovered (null if not tested)"""
  mtuPath: Int
  """Whether the remote endpoint is reachable"""
  reachable: Boolean!
  """Suggestions for common connectivity issues"""
  suggestions: [String!]!
  """Throughput in Mbps (null if iperf not available)"""
  throughput: Float
}

"""Network tunnel types supported by MikroTik RouterOS"""
enum TunnelType {
  """Ethernet over IP - Layer 2 tunnel for bridge extension"""
  EOIP
  """Generic Routing Encapsulation (RFC 2784) - L3 with optional IPsec"""
  GRE
  """IP-in-IP tunnel (RFC 2003) - Basic L3 encapsulation"""
  IPIP
  """Layer 2 Tunneling Protocol (future support)"""
  L2TP
  """Secure Socket Tunneling Protocol (future support)"""
  SSTP
  """Virtual eXtensible LAN (RFC 7348) - L2 overlay network"""
  VXLAN
}

"""
ULID (Universally Unique Lexicographically Sortable Identifier)
A 26-character string that is time-sortable and globally unique.
Example: "01ARZ3NDEKTSV4RRFFQ69G5FAV"
"""
scalar ULID

"""Input for updating an alert rule"""
input UpdateAlertRuleInput {
  """Notification channels"""
  channels: [String!]
  """Array of conditions"""
  conditions: [AlertConditionInput!]
  """Optional description"""
  description: String
  """Optional device ID filter"""
  deviceId: ID
  """Whether rule is enabled"""
  enabled: Boolean
  """Escalation configuration (NAS-18.9)"""
  escalation: EscalationConfigInput
  """Event type to match"""
  eventType: String
  """Human-readable alert rule name"""
  name: String
  """Quiet hours configuration"""
  quietHours: QuietHoursConfigInput
  """Alert severity level"""
  severity: AlertSeverity
  """Throttle configuration"""
  throttle: ThrottleConfigInput
}

input UpdateBridgeInput {
  comment: String
  disabled: Boolean
  mtu: Int @validate(min: 68, max: 65535)
  priority: Int @validate(min: 0, max: 61440)
  protocol: StpProtocol
  pvid: Int @validate(min: 1, max: 4094)
  vlanFiltering: Boolean
}

input UpdateBridgePortInput {
  edge: Boolean
  frameTypes: FrameTypes
  ingressFiltering: Boolean
  pathCost: Int @validate(min: 1, max: 65535)
  pvid: Int @validate(min: 1, max: 4094)
  taggedVlans: [Int!]
  untaggedVlans: [Int!]
}

"""Input for updating an item in a change set"""
input UpdateChangeSetItemInput {
  """Updated configuration"""
  configuration: JSON
  """Updated dependencies"""
  dependencies: [ID!]
  """Updated description"""
  description: String
  """Updated name"""
  name: String
}

type UpdateChangeSetItemPayload {
  """The updated change set"""
  changeSet: ChangeSet
  """Errors that occurred"""
  errors: [MutationError!]
}

"""Input for configuring update check schedule for an instance."""
input UpdateCheckScheduleInput {
  """Minimum severity to auto-apply (CRITICAL, MAJOR, MINOR, PATCH, MANUAL)"""
  autoApplyThreshold: String!
  """Update check schedule (e.g., '6h', '12h', '24h', 'manual')"""
  checkSchedule: String!
  """Instance ID"""
  instanceID: ID!
  """Router ID"""
  routerID: ID!
}

"""Available update information for a service instance."""
type UpdateInfo {
  """Target architecture"""
  architecture: String!
  """Available update version"""
  availableVersion: String!
  """Checksum URL for verification"""
  checksumURL: String
  """Current installed version"""
  currentVersion: String!
  """Download URL for the new binary"""
  downloadURL: String!
  """Feature ID"""
  featureID: String!
  """Instance ID"""
  instanceID: ID!
  """When the update was published"""
  publishedAt: DateTime!
  """Release notes/changelog"""
  releaseNotes: String!
  """Update severity"""
  severity: UpdateSeverity!
  """Binary size in bytes"""
  sizeBytes: Int!
}

"""Input for updating interface settings"""
input UpdateInterfaceInput {
  """Interface comment"""
  comment: String @validate(maxLength: 255)
  """Enable or disable the interface"""
  enabled: Boolean
  """MTU size (68-9000 bytes)"""
  mtu: Int @validate(min: 68, max: 9000)
}

"""
Payload returned by updateInterface, enableInterface, and disableInterface mutations
"""
type UpdateInterfacePayload {
  """Errors that occurred during the operation"""
  errors: [MutationError!]
  """Updated interface"""
  interface: Interface
}

"""Input for updating an existing notification channel configuration"""
input UpdateNotificationChannelConfigInput {
  """New configuration (optional, replaces entire config if provided)"""
  config: JSON
  """New description (optional)"""
  description: String
  """Enable/disable configuration (optional)"""
  enabled: Boolean
  """Set as default (optional)"""
  isDefault: Boolean
  """New name (optional)"""
  name: String
}

"""Input for updating an existing port mirror configuration"""
input UpdatePortMirrorInput {
  """Updated comment"""
  comment: String @validate(maxLength: 255)
  """Updated destination interface ID"""
  destinationInterfaceId: ID
  """Updated direction of traffic to mirror"""
  direction: MirrorDirection
  """Updated name"""
  name: String @validate(minLength: 1, maxLength: 100, pattern: "^[a-zA-Z0-9_-]+$")
  """Updated source interface IDs (must be bridge members)"""
  sourceInterfaceIds: [ID!] @validate(minLength: 1)
}

"""Update progress during atomic update process."""
type UpdateProgress {
  """Feature ID"""
  featureID: String!
  """Current version"""
  fromVersion: String!
  """Instance ID"""
  instanceID: ID!
  """Current stage message"""
  message: String!
  """Progress percentage (0-100)"""
  progress: Int!
  """Current stage"""
  stage: UpdateStage!
  """Timestamp"""
  timestamp: DateTime!
  """Target version"""
  toVersion: String!
}

"""Input for updating resource configuration"""
input UpdateResourceInput {
  """Updated configuration (partial or full)"""
  configuration: JSON
  """Updated description"""
  description: String
  """Updated relationships"""
  relationships: ResourceRelationshipsInput
  """Updated tags"""
  tags: [String!]
}

type UpdateResourcePayload {
  """Errors that occurred"""
  errors: [MutationError!]
  """The updated resource"""
  resource: Resource
}

"""Update result after completion or failure."""
type UpdateResult {
  """Update stages completed"""
  completedStages: [UpdateStage!]!
  """Total duration in milliseconds"""
  durationMs: Int!
  """Error message (if failed)"""
  errorMessage: String
  """Stage where failure occurred (if failed)"""
  failedStage: UpdateStage
  """Instance ID"""
  instanceID: ID!
  """Whether rollback occurred"""
  rolledBack: Boolean!
  """Whether the update succeeded"""
  success: Boolean!
  """Timestamp"""
  timestamp: DateTime!
  """Version updated to (if successful)"""
  version: String
}

"""Input for updating router settings"""
input UpdateRouterInput {
  """Updated hostname or IP address"""
  host: String @validate(minLength: 1, maxLength: 255)
  """Updated display name"""
  name: String @validate(minLength: 1, maxLength: 64)
  """Updated password"""
  password: String @validate(minLength: 1, maxLength: 128)
  """Updated connection port"""
  port: Int @validate(min: 1, max: 65535)
  """Updated username"""
  username: String @validate(minLength: 1, maxLength: 64)
}

type UpdateRouterPayload {
  """Errors that occurred during update"""
  errors: [MutationError!]
  """The updated router"""
  router: Router
}

"""Input for updating an existing routing schedule."""
input UpdateScheduleInput {
  """Days of week (0=Sunday, 6=Saturday)"""
  days: [Int!]
  """Whether schedule is enabled"""
  enabled: Boolean
  """End time in HH:MM format (24-hour)"""
  endTime: String @validate(pattern: "^([0-1][0-9]|2[0-3]):[0-5][0-9]$")
  """Start time in HH:MM format (24-hour)"""
  startTime: String @validate(pattern: "^([0-1][0-9]|2[0-3]):[0-5][0-9]$")
  """IANA timezone identifier"""
  timezone: String @validate(minLength: 1, maxLength: 64)
}

"""Update severity classification for available updates."""
enum UpdateSeverity {
  """Critical security fix - auto-apply recommended"""
  CRITICAL
  """Major version with breaking changes"""
  MAJOR
  """Minor version with new features"""
  MINOR
  """Patch version with bug fixes"""
  PATCH
}

"""Update stage during atomic update process."""
enum UpdateStage {
  """Backing up current binary"""
  BACKUP
  """Finalizing update"""
  COMMIT
  """Running config migrations"""
  MIGRATION
  """Restoring from backup"""
  ROLLBACK
  """Downloading and verifying new binary"""
  STAGING
  """Swapping binaries"""
  SWAP
  """Validating new version"""
  VALIDATION
}

"""Input for updating a webhook"""
input UpdateWebhookInput {
  """Authentication type"""
  authType: WebhookAuthType
  """Bearer token for Bearer auth (only set if provided)"""
  bearerToken: String
  """Custom template body"""
  customTemplate: String
  """Optional description"""
  description: String
  """Whether webhook is enabled"""
  enabled: Boolean
  """Custom HTTP headers (as JSON object)"""
  headers: JSON
  """Maximum retry attempts"""
  maxRetries: Int
  """HTTP method"""
  method: String
  """Human-readable webhook name"""
  name: String
  """Password for Basic auth (only set if provided)"""
  password: String
  """Whether to retry failed deliveries"""
  retryEnabled: Boolean
  """Signing secret for HMAC signature (only set if provided)"""
  signingSecret: String
  """Template type for webhook payload"""
  template: WebhookTemplate
  """Timeout in seconds"""
  timeoutSeconds: Int
  """Webhook URL endpoint"""
  url: String
  """Username for Basic auth"""
  username: String
}

"""Impact assessment for an upgrade"""
type UpgradeImpact {
  """Whether configuration backup is recommended before upgrade"""
  backupRecommended: Boolean!
  """Potential breaking changes to be aware of"""
  breakingChanges: [String!]!
  """Estimated downtime description"""
  estimatedDowntime: String
  """Whether reboot is required"""
  requiresReboot: Boolean!
}

"""Priority level for upgrade recommendations"""
enum UpgradePriority {
  """Security-related, should upgrade immediately"""
  CRITICAL
  """Highly recommended for stability/features"""
  HIGH
  """Nice to have, optional"""
  LOW
  """Recommended but not urgent"""
  MEDIUM
}

"""Upgrade recommendation for enabling a feature"""
type UpgradeRecommendation {
  """Current RouterOS version"""
  currentVersion: String!
  """URL to MikroTik upgrade documentation"""
  documentationUrl: String
  """Feature that requires upgrade"""
  featureId: String!
  """Human-readable feature name"""
  featureName: String!
  """Estimated impact on router operation"""
  impact: UpgradeImpact!
  """Whether this is a major version upgrade (e.g., 6.x to 7.x)"""
  isMajorUpgrade: Boolean!
  """Priority level (critical, high, medium, low)"""
  priority: UpgradePriority!
  """Minimum required version for this feature"""
  requiredVersion: String!
  """Steps to complete the upgrade"""
  steps: [UpgradeStep!]!
  """Warnings or important notes about this upgrade"""
  warnings: [String!]!
}

"""Single step in an upgrade process"""
type UpgradeStep {
  """RouterOS command to execute (if applicable)"""
  command: String
  """Detailed instructions"""
  description: String!
  """Whether this step is optional"""
  optional: Boolean!
  """Step number (1-based)"""
  step: Int!
  """Step title"""
  title: String!
}

"""An uptime data point"""
type UptimeDataPoint {
  """Whether resource was up during this period"""
  isUp: Boolean!
  """Period duration in seconds"""
  periodSeconds: Int!
  """Timestamp"""
  timestamp: DateTime!
}

"""User account in NasNetConnect"""
type User implements Node {
  """Account creation timestamp"""
  createdAt: DateTime!
  """Display name"""
  displayName: String
  """Email address (if provided)"""
  email: String
  """User ULID"""
  id: ID!
  """Last successful login"""
  lastLoginAt: DateTime
  """User role for authorization"""
  role: UserRole!
  """Unique username"""
  username: String!
}

"""User roles for authorization"""
enum UserRole {
  """Full administrative access"""
  ADMIN
  """Can view and modify but not delete or manage users"""
  OPERATOR
  """Read-only access"""
  VIEWER
}

"""Single step in VIF enablement guidance"""
type VIFGuidanceStep {
  """Whether this requirement is already met"""
  completed: Boolean!
  """Detailed instruction"""
  description: String!
  """RouterOS command to execute (if applicable)"""
  routerCommand: String
  """Step number (1-based)"""
  step: Int!
  """Short title for the step"""
  title: String!
}

"""VIF (Virtual Interface Factory) requirements check result"""
type VIFRequirements {
  """Whether container feature is enabled"""
  containerEnabled: Boolean!
  """Whether container package is installed"""
  containerPackage: Boolean!
  """Step-by-step guidance for enabling VIF"""
  guidanceSteps: [VIFGuidanceStep!]!
  """Whether all VIF requirements are satisfied"""
  met: Boolean!
  """Human-readable reasons why VIF is not available"""
  missingReasons: [String!]!
  """Whether network namespace is supported"""
  networkNamespace: Boolean!
  """Whether RouterOS version is sufficient (7.13+)"""
  routerOSVersion: Boolean!
  """Whether there's sufficient storage (>100MB)"""
  sufficientStorage: Boolean!
}

"""
VLANAllocation represents an automatic VLAN allocation for a service instance.

Each allocation reserves a VLAN ID from the pool and generates a corresponding
subnet (e.g., 10.8.100.0/24) for network isolation. Allocations are automatically
created when service instances are provisioned and released when deleted.

The system prevents conflicts with existing router VLANs through automatic
detection via VlanService composition.
"""
type VLANAllocation implements Node {
  """Timestamp when VLAN was allocated"""
  allocatedAt: DateTime!
  """Unique allocation ID (ULID)"""
  id: ID!
  """Service instance ID that owns this VLAN"""
  instanceID: String!
  """Timestamp when VLAN was released (null if still allocated)"""
  releasedAt: DateTime
  """Router this VLAN belongs to"""
  router: Router!
  """Router ID this VLAN allocation belongs to"""
  routerID: String!
  """Service instance that owns this VLAN"""
  serviceInstance: ServiceInstance!
  """Service type (e.g., 'tor', 'xray', 'singbox')"""
  serviceType: String!
  """Allocation lifecycle status"""
  status: VLANAllocationStatus!
  """Auto-generated subnet for this VLAN (e.g., '10.99.100.0/24')"""
  subnet: String
  """VLAN ID (IEEE 802.1Q range: 1-4094)"""
  vlanID: Int!
}

"""
VLANAllocationStatus represents the lifecycle state of a VLAN allocation.
"""
enum VLANAllocationStatus {
  """VLAN is currently allocated and in use"""
  ALLOCATED
  """VLAN has been released and is available for reuse"""
  RELEASED
  """VLAN is being released (transitional state)"""
  RELEASING
}

"""
VLANPoolStatus represents the current state of the VLAN pool for a router.

Provides utilization metrics and warnings when the pool is approaching exhaustion.
Useful for capacity planning and monitoring.
"""
type VLANPoolStatus {
  """Number of currently allocated VLANs"""
  allocatedVLANs: Int!
  """Number of available VLANs remaining"""
  availableVLANs: Int!
  """Pool configuration (end VLAN ID)"""
  poolEnd: Int!
  """Pool configuration (start VLAN ID)"""
  poolStart: Int!
  """Router ID this pool status applies to"""
  routerID: String!
  """Warning flag if utilization > 80%"""
  shouldWarn: Boolean!
  """Total number of VLANs in the pool (e.g., 100 for range 100-199)"""
  totalVLANs: Int!
  """Utilization percentage (0.0 - 100.0)"""
  utilization: Float!
}

"""VPN tunnel information for routes through VPN"""
type VPNTunnelInfo {
  """Tunnel name"""
  name: String!
  """Remote endpoint address"""
  remoteAddress: String
  """Current tunnel connection status"""
  status: TunnelStatus!
  """Tunnel type (wireguard, ipsec, ovpn, l2tp, gre, eoip)"""
  type: String!
}

type ValidateChangeSetPayload {
  """The validated change set"""
  changeSet: ChangeSet
  """Errors that occurred"""
  errors: [MutationError!]
  """Validation result"""
  validation: ChangeSetValidationResult
}

"""Predefined validation formats for common data types"""
enum ValidateFormat {
  CIDR
  EMAIL
  FQDN
  HOSTNAME
  IPV4
  IPV6
  MAC
  URL
  UUID
}

type ValidateResourcePayload {
  """Errors that occurred"""
  errors: [MutationError!]
  """The validated resource"""
  resource: Resource
  """Validation result"""
  validation: ValidationResult
}

"""Input for validating service configuration"""
input ValidateServiceConfigInput {
  """Configuration to validate (as JSON)"""
  config: JSON!
  """Service instance ID"""
  instanceID: ID!
  """Router ID"""
  routerID: ID!
}

"""Field-level validation error with suggestions for fixing."""
type ValidationError {
  """Error code for the validation failure"""
  code: String!
  """Field path that failed validation (e.g., 'input.host', 'input.port')"""
  field: String!
  """Human-readable error message"""
  message: String!
  """The invalid value (redacted for sensitive fields)"""
  providedValue: String
  """Suggestion for fixing the validation error"""
  suggestion: String
}

"""A validation issue (error or warning)"""
type ValidationIssue {
  """Error code for programmatic handling"""
  code: String!
  """Link to documentation"""
  docsUrl: String
  """Field path that caused the issue (e.g., 'configuration.listenPort')"""
  field: String
  """Human-readable message"""
  message: String!
  """Severity level"""
  severity: ValidationSeverity!
  """Suggested fix"""
  suggestedFix: String
}

"""
Layer 2: Validation result from 7-stage backend validation pipeline.
Computed on every configuration change.
"""
type ValidationResult {
  """Whether the resource can be applied"""
  canApply: Boolean!
  """Resource conflicts detected"""
  conflicts: [ResourceConflict!]!
  """Validation errors (blocking)"""
  errors: [ValidationIssue!]!
  """Required dependencies that must be active"""
  requiredDependencies: [DependencyStatus!]!
  """Current validation stage"""
  stage: ValidationStage!
  """When validation was performed"""
  validatedAt: DateTime!
  """Duration of validation in milliseconds"""
  validationDurationMs: Int!
  """Validation warnings (non-blocking)"""
  warnings: [ValidationIssue!]!
}

"""Validation issue severity"""
enum ValidationSeverity {
  """Blocks apply, must be fixed"""
  ERROR
  """Informational notice"""
  INFO
  """Does not block, but recommended to address"""
  WARNING
}

"""Validation pipeline stages"""
enum ValidationStage {
  """All stages complete"""
  COMPLETE
  """Conflict detection (port/IP/route conflicts)"""
  CONFLICT
  """Dependency validation (required resources exist)"""
  DEPENDENCY
  """Platform validation (capability checks)"""
  PLATFORM
  """Quota validation (resource limits)"""
  QUOTA
  """Schema validation (Zod/GraphQL)"""
  SCHEMA
  """Semantic validation (business rules)"""
  SEMANTIC
  """Pre-flight simulation"""
  SIMULATION
}

"""Variable types for template parameters."""
enum VariableType {
  """Interface name (autocomplete from router)"""
  INTERFACE
  """IP address"""
  IP
  """Port number"""
  PORT
  """Free-form string"""
  STRING
  """Subnet in CIDR notation"""
  SUBNET
  """VLAN ID"""
  VLAN_ID
}

"""Verification event for subscriptions."""
type VerificationEvent {
  """Actual hash (for failures)"""
  actualHash: String
  """Archive hash"""
  archiveHash: String
  """Binary hash"""
  binaryHash: String
  """Event type (verified, verification_failed, integrity_failed)"""
  eventType: String!
  """Expected hash (for failures)"""
  expectedHash: String
  """Failure reason (for failures)"""
  failureReason: String
  """Feature ID"""
  featureID: String!
  """GPG key ID"""
  gpgKeyID: String
  """GPG verified"""
  gpgVerified: Boolean!
  """Instance ID"""
  instanceID: ID!
  """Router ID"""
  routerID: ID!
  """Suggested action (for failures)"""
  suggestedAction: String
  """Timestamp"""
  timestamp: DateTime!
}

"""Binary verification status."""
enum VerificationStatus {
  """Binary failed verification (hash mismatch)"""
  INVALID
  """Verification not performed (disabled or missing data)"""
  NOT_VERIFIED
  """Verification in progress"""
  PENDING
  """Binary passed verification"""
  VALID
}

"""
Virtual network interface for service instance isolation.
Each service instance gets its own VLAN interface with routing mark.
"""
type VirtualInterface {
  """When the interface was created"""
  createdAt: DateTime!
  """Gateway runtime status"""
  gatewayStatus: GatewayStatus!
  """Gateway type (tunnel, direct, etc.)"""
  gatewayType: GatewayType!
  """Interface ID (ULID)"""
  id: ID!
  """Service instance ID this interface belongs to"""
  instanceId: ID!
  """IP address assigned to this interface"""
  ipAddress: String!
  """Interface name (e.g., vlan100)"""
  name: String!
  """Routing mark for policy routing"""
  routingMark: String!
  """Interface lifecycle status"""
  status: VirtualInterfaceStatus!
  """Tunnel interface name (for HEV tunnel)"""
  tunName: String
  """Last update timestamp"""
  updatedAt: DateTime!
  """VLAN ID for network isolation"""
  vlanId: Int!
}

"""
Virtual interface information for routing matrix.
Simplified view of VirtualInterface for device routing selection.
"""
type VirtualInterfaceInfo {
  """Gateway status"""
  gatewayStatus: String!
  """Gateway type"""
  gatewayType: String!
  """Interface ID"""
  id: ID!
  """Service instance ID"""
  instanceID: ID!
  """Service instance name"""
  instanceName: String!
  """Interface name (e.g., vlan100)"""
  interfaceName: String!
  """IP address"""
  ipAddress: String!
  """Routing mark for PBR"""
  routingMark: String!
  """Interface status"""
  status: String!
  """VLAN ID"""
  vlanID: Int!
}

"""Virtual interface lifecycle status."""
enum VirtualInterfaceStatus {
  """Interface is active and ready"""
  ACTIVE
  """Interface is being created"""
  CREATING
  """Interface creation/operation failed"""
  ERROR
  """Interface is being removed"""
  REMOVING
}

"""
A VLAN (Virtual LAN) interface for network segmentation using 802.1Q tagging
"""
type Vlan implements Node {
  """User comment"""
  comment: String @mikrotik(path: "/interface/vlan", field: "comment")
  """Whether the VLAN interface is disabled"""
  disabled: Boolean! @mikrotik(path: "/interface/vlan", field: "disabled")
  """Unique VLAN identifier"""
  id: ID!
  """Parent interface (bridge or physical interface)"""
  interface: Interface! @mikrotik(path: "/interface/vlan", field: "interface")
  """IP addresses assigned to this VLAN"""
  ipAddresses: [IpAddress!]!
  """MAC address of the VLAN interface"""
  macAddress: MAC @mikrotik(path: "/interface/vlan", field: "mac-address")
  """MTU setting (optional, inherits from parent if not set)"""
  mtu: Int @validate(min: 68, max: 65535) @mikrotik(path: "/interface/vlan", field: "mtu")
  """VLAN interface name (e.g., vlan10, vlan-guest)"""
  name: String! @validate(minLength: 1, maxLength: 100) @mikrotik(path: "/interface/vlan", field: "name")
  """Whether the VLAN interface is running (link up)"""
  running: Boolean! @mikrotik(path: "/interface/vlan", field: "running")
  """Traffic statistics for this VLAN"""
  statistics: InterfaceStats
  """802.1Q VLAN ID (1-4094)"""
  vlanId: Int! @validate(min: 1, max: 4094) @mikrotik(path: "/interface/vlan", field: "vlan-id")
}

"""Resources that depend on a VLAN interface"""
type VlanDependencies {
  """Number of active connections on this VLAN"""
  activeConnections: Int!
  """DHCP servers using this VLAN"""
  dhcpServers: [DhcpServer!]!
  """Firewall rules referencing this VLAN"""
  firewallRules: [FirewallRuleReference!]!
  """Whether the VLAN has any dependencies"""
  hasDependencies: Boolean!
  """IP addresses assigned to this VLAN"""
  ipAddresses: [IpAddress!]!
  """Routes using this VLAN interface"""
  routes: [Route!]!
  """VLAN interface ID"""
  vlanId: ID!
}

"""Filter options for querying VLANs"""
input VlanFilter {
  """Filter by name containing this string"""
  nameContains: String
  """Filter by parent interface ID"""
  parentInterface: ID
  """Filter by VLAN ID range"""
  vlanIdRange: IntRange
}

"""Input for creating a new VLAN interface"""
input VlanInput {
  """User comment"""
  comment: String @validate(maxLength: 255)
  """Parent interface ID (bridge or physical interface)"""
  interface: ID!
  """MTU setting (optional, inherits from parent if not set)"""
  mtu: Int @validate(min: 68, max: 65535)
  """VLAN interface name (alphanumeric, hyphens, underscores)"""
  name: String! @validate(minLength: 1, maxLength: 100, pattern: "^[a-zA-Z0-9_-]+$")
  """802.1Q VLAN ID (1-4094)"""
  vlanId: Int! @validate(min: 1, max: 4094)
}

"""Result of a VLAN mutation (create, update)"""
type VlanMutationResult {
  """Errors that occurred during the operation"""
  errors: [MutationError!]
  """Configuration preview (RouterOS commands that will be executed)"""
  preview: ConfigPreview
  """Whether the operation succeeded"""
  success: Boolean!
  """The created or updated VLAN (if successful)"""
  vlan: Vlan
}

"""VLAN topology data (nodes and edges)"""
type VlanTopology {
  """Topology edges (connections)"""
  edges: [TopologyEdge!]!
  """Topology nodes (bridges, VLANs, ports)"""
  nodes: [TopologyNode!]!
}

"""WAN connection history entry"""
type WANConnectionEvent {
  """Connection duration (for disconnect events)"""
  duration: Duration
  """Event type"""
  eventType: WANEventType!
  """Gateway IP"""
  gateway: IPv4
  """Event ID"""
  id: ID!
  """Public IP at the time (if applicable)"""
  publicIP: IPv4
  """Reason/error message (if applicable)"""
  reason: String
  """Event timestamp"""
  timestamp: DateTime!
  """WAN interface ID"""
  wanInterfaceId: ID!
}

"""Connection history pagination"""
type WANConnectionEventConnection implements Connection {
  edges: [WANConnectionEventEdge!]!
  pageInfo: PageInfo!
  totalCount: Int
}

type WANConnectionEventEdge implements Edge {
  cursor: String!
  node: WANConnectionEvent!
}

"""WAN connection type classification"""
enum WANConnectionType {
  """DHCP client (dynamic IP)"""
  DHCP
  """LTE/cellular connection"""
  LTE
  """Not configured"""
  NONE
  """PPPoE dial-up connection"""
  PPPOE
  """Static IP configuration"""
  STATIC
}

"""WAN event types for history tracking"""
enum WANEventType {
  """Authentication failed"""
  AUTH_FAILED
  """Connection established"""
  CONNECTED
  """Connection lost"""
  DISCONNECTED
  """Gateway changed"""
  GATEWAY_CHANGED
  """Health check failed"""
  HEALTH_FAILED
  """Health check recovered"""
  HEALTH_RECOVERED
  """IP address changed"""
  IP_CHANGED
}

"""Input for configuring WAN health check"""
input WANHealthCheckInput {
  """Enable health check"""
  enabled: Boolean!
  """Check interval in seconds"""
  interval: Int! @validate(min: 5, max: 300)
  """Target host to ping (IP or hostname)"""
  target: String! @validate(minLength: 1, maxLength: 255)
}

"""WAN health check status"""
type WANHealthStatus {
  """Whether health check is enabled"""
  enabled: Boolean!
  """Consecutive failed checks"""
  failureCount: Int!
  """Check interval"""
  interval: Duration!
  """Last check timestamp"""
  lastCheck: DateTime!
  """Current latency (if reachable)"""
  latency: Int
  """Packet loss percentage (0-100)"""
  packetLoss: Int!
  """Overall health status"""
  status: HealthCheckStatus!
  """Consecutive successful checks"""
  successCount: Int!
  """Target host being monitored"""
  target: String!
}

"""WAN interface status with connection details"""
type WANInterface implements Node {
  """DHCP client configuration (if type is DHCP)"""
  dhcpClient: DhcpClient
  """Gateway IP address"""
  gateway: IPv4
  """Health check status"""
  health: WANHealthStatus
  """Unique identifier"""
  id: ID!
  """Underlying network interface"""
  interface: Interface! @mikrotik(path: "/interface", field: "name")
  """Whether this is the default route"""
  isDefaultRoute: Boolean!
  """Last connection time"""
  lastConnected: DateTime
  """LTE modem configuration (if type is LTE)"""
  lteModem: LteModem
  """PPPoE client configuration (if type is PPPOE)"""
  pppoeClient: PppoeClient
  """Primary DNS server"""
  primaryDNS: IPv4
  """Public IP address (if connected)"""
  publicIP: IPv4 @mikrotik(path: "/ip/address", field: "address")
  """Secondary DNS server"""
  secondaryDNS: IPv4
  """Static IP configuration (if type is STATIC)"""
  staticConfig: StaticIPConfig
  """Traffic statistics"""
  statistics: InterfaceStats
  """Current connection status"""
  status: WANStatus!
  """WAN connection type"""
  type: WANConnectionType!
  """Connection uptime"""
  uptime: Duration
}

"""WAN Link resource for internet connectivity"""
type WANLink implements Node & Resource {
  category: ResourceCategory!
  configuration: JSON
  """Connection type (static, dhcp, pppoe)"""
  connectionType: WANConnectionType!
  deployment: DeploymentState
  """Failover priority (lower = higher priority)"""
  failoverPriority: Int
  id: ID!
  """Interface name"""
  interface: String!
  """Whether this is the primary WAN"""
  isPrimary: Boolean!
  metadata: ResourceMetadata!
  platform: PlatformInfo
  relationships: ResourceRelationships
  runtime: RuntimeState
  scopedId: String!
  telemetry: TelemetryData
  type: String!
  validation: ValidationResult
  wanRuntime: WANLinkRuntime
}

"""WAN Link runtime state"""
type WANLinkRuntime {
  """Current IP address"""
  currentIP: IPv4
  """DNS servers received"""
  dnsServers: [IPv4!]
  """Current downlink speed (bytes/sec)"""
  downlinkSpeed: Size
  errorMessage: String
  """Gateway address"""
  gateway: IPv4
  health: RuntimeHealth!
  isRunning: Boolean!
  """Last connection change"""
  lastStateChange: DateTime
  lastUpdated: DateTime!
  """Public IP (may differ due to NAT)"""
  publicIP: IPv4
  """Current uplink speed (bytes/sec)"""
  uplinkSpeed: Size
  """Total uptime"""
  uptime: Duration
}

"""Result of WAN configuration mutation"""
type WANMutationResult {
  """Errors that occurred"""
  errors: [MutationError!]
  """Configuration preview (RouterOS commands)"""
  preview: ConfigPreview
  """Whether the operation succeeded"""
  success: Boolean!
  """The configured WAN interface"""
  wanInterface: WANInterface
}

"""WAN connection status"""
enum WANStatus {
  """Connected and online"""
  CONNECTED
  """Connecting/authenticating"""
  CONNECTING
  """Disabled"""
  DISABLED
  """Disconnected"""
  DISCONNECTED
  """Connection failed"""
  ERROR
}

"""Webhook notification configuration"""
type Webhook implements Node {
  """Authentication type"""
  authType: WebhookAuthType!
  """Bearer token (masked, only shown on creation)"""
  bearerToken: String
  """Record creation timestamp"""
  createdAt: DateTime!
  """Custom template body (for CUSTOM template type)"""
  customTemplate: String
  """Delivery statistics"""
  deliveryStats: WebhookDeliveryStats
  """Optional description"""
  description: String
  """Whether this webhook is enabled"""
  enabled: Boolean!
  """Custom HTTP headers (as JSON object)"""
  headers: JSON
  """Globally unique identifier"""
  id: ID!
  """Last successful delivery timestamp"""
  lastDeliveredAt: DateTime
  """Maximum retry attempts (default: 3)"""
  maxRetries: Int!
  """HTTP method (default: POST)"""
  method: String!
  """Human-readable webhook name"""
  name: String!
  """Whether to retry failed deliveries"""
  retryEnabled: Boolean!
  """
  Signing secret (masked with ******, never returned in plaintext except on creation)
  """
  signingSecretMasked: String
  """Template type for webhook payload"""
  template: WebhookTemplate!
  """Timeout in seconds (default: 10)"""
  timeoutSeconds: Int!
  """Last update timestamp"""
  updatedAt: DateTime!
  """Webhook URL endpoint"""
  url: String!
  """Username for Basic auth"""
  username: String
}

"""Webhook authentication types"""
enum WebhookAuthType {
  """HTTP Basic authentication"""
  BASIC
  """Bearer token authentication"""
  BEARER
  """No authentication required"""
  NONE
}

"""Webhook delivery statistics"""
type WebhookDeliveryStats {
  """Average response time in milliseconds"""
  avgResponseTimeMs: Int
  """Failed deliveries"""
  failureCount: Int!
  """Successful deliveries"""
  successCount: Int!
  """Success rate (0-100)"""
  successRate: Float!
  """Total deliveries attempted"""
  totalAttempts: Int!
}

"""Webhook mutation payload"""
type WebhookPayload {
  """Errors encountered during mutation"""
  errors: [MutationError!]
  """Signing secret (only returned on creation, one-time show)"""
  signingSecret: String
  """Created/updated webhook"""
  webhook: Webhook
}

"""Webhook template types for predefined formats"""
enum WebhookTemplate {
  """Custom template with user-defined format"""
  CUSTOM
  """Discord webhook format"""
  DISCORD
  """Generic JSON format"""
  GENERIC
  """Slack incoming webhook format"""
  SLACK
  """Microsoft Teams webhook format"""
  TEAMS
}

"""Webhook test mutation payload"""
type WebhookTestPayload {
  """Errors encountered during test"""
  errors: [MutationError!]
  """Test result"""
  result: WebhookTestResult
}

"""Result of testing a webhook"""
type WebhookTestResult {
  """Error message if test failed"""
  errorMessage: String
  """Response body from webhook endpoint"""
  responseBody: String
  """Response time in milliseconds"""
  responseTimeMs: Int
  """HTTP status code received"""
  statusCode: Int
  """Whether the test was successful"""
  success: Boolean!
}

"""WireGuard VPN Client resource implementing 8-layer model"""
type WireGuardClient implements Node & Resource {
  category: ResourceCategory!
  config: WireGuardClientConfig!
  configuration: JSON
  deployment: DeploymentState
  id: ID!
  metadata: ResourceMetadata!
  platform: PlatformInfo
  relationships: ResourceRelationships
  runtime: RuntimeState
  scopedId: String!
  telemetry: TelemetryData
  type: String!
  validation: ValidationResult
  wireguardDeployment: WireGuardDeployment
  wireguardRuntime: WireGuardRuntime
}

"""WireGuard client configuration"""
type WireGuardClientConfig {
  """Allowed IPs (CIDR notation)"""
  allowedIPs: [CIDR!]!
  """DNS servers to use"""
  dnsServers: [IPv4!]
  """Enable kill switch"""
  killSwitch: Boolean
  """Listen port (0 for auto)"""
  listenPort: Port
  """User-friendly name"""
  name: String!
  """Peer endpoint (IP:port)"""
  peerEndpoint: String!
  """Peer public key"""
  peerPublicKey: String!
  """Persistent keepalive interval"""
  persistentKeepalive: Duration
  """WireGuard private key"""
  privateKey: String! @sensitive
  """WAN interface to use"""
  wanInterface: ID
}

"""WireGuard deployment state (router-generated)"""
type WireGuardDeployment {
  appliedAt: DateTime!
  appliedBy: String
  drift: DriftInfo
  """Assigned interface name"""
  interfaceName: String
  isInSync: Boolean!
  """Generated public key"""
  publicKey: String
  routerResourceId: String
  routerVersion: Int
}

"""WireGuard runtime state"""
type WireGuardRuntime {
  """Current active peers count"""
  activePeers: Int!
  """Bytes transferred in"""
  bytesIn: Size!
  """Bytes transferred out"""
  bytesOut: Size!
  """Current endpoint (may differ from configured)"""
  currentEndpoint: String
  errorMessage: String
  health: RuntimeHealth!
  """Whether connected to peer"""
  isConnected: Boolean!
  isRunning: Boolean!
  """Last handshake time"""
  lastHandshake: DateTime
  lastUpdated: DateTime!
}