import { mergeMultipleConfigs, mergeRouterConfigs } from "./ConfigGeneratorUtil";
import { ScriptAndScheduler, OneTimeScript, SchedulerGenerator } from "./ScriptSchedule";

import type { RouterConfig } from "../generator";
export const CheckCGNAT = (
    wanInterfaceName: string = "ether1",
): RouterConfig => {
    const cgnatScriptContent: RouterConfig = {
        "": [
            "",
            "# Configuration Variables",
            `:local wanInterfaceName "${wanInterfaceName}";`,
            `:local connectivityCheckUrl "http://detectportal.firefox.com/success.txt";`,
            `:local publicIpCheckUrl "http://api.ipify.org";`,
            `:local logPrefix "[CGNAT-Check-OneTime] ";`,
            "",
            `:log info ($logPrefix . "ONE-TIME SCRIPT STARTED. WAN Interface: " . $wanInterfaceName);`,
            "",
            "# Global variables for status",
            `:global globalInternetStatus "Unknown";`,
            `:global globalCgnatStatus "Unknown";`,
            `:global globalWanIp "Unknown";`,
            `:global globalPublicIp "Unknown";`,
            "",
            "# Step 1: Check Internet Connectivity",
            `:local internetUp false;`,
            `:do {`,
            `    /tool fetch url=$connectivityCheckUrl mode=http keep-result=no;`,
            `    :set internetUp true;`,
            `    :log info ($logPrefix . "Internet connectivity check successful. Status: UP");`,
            `    :set globalInternetStatus "UP";`,
            `} on-error={`,
            `    :log warning ($logPrefix . "Internet connectivity check failed. Status: DOWN");`,
            `    :set globalInternetStatus "DOWN";`,
            `    :set globalCgnatStatus "Undetermined (Internet Down)";`,
            `    :set globalWanIp "Undetermined (Internet Down)";`,
            `    :set globalPublicIp "Undetermined (Internet Down)";`,
            `    :log info ($logPrefix . "Script will complete and self-destruct due to internet down.");`,
            `}`,
            "",
            "# Step 2: If Internet is UP, proceed with CGNAT detection",
            `:if ($internetUp) do={`,
            `    :log info ($logPrefix . "Internet is UP. Proceeding with CGNAT detection.");`,
            "",
            `    # Get Local WAN IP Address - improved method`,
            `    :local localWanIp "";`,
            `    :local wanAddresses [/ip address find interface=$wanInterfaceName disabled=no];`,
            `    `,
            `    :if ([:len $wanAddresses] > 0) do={`,
            `        :local localWanIpWithMask [/ip address get [:pick $wanAddresses 0] address];`,
            `        :local slashPos [:find $localWanIpWithMask "/"];`,
            `        :if ($slashPos > 0) do={`,
            `            :set localWanIp [:pick $localWanIpWithMask 0 $slashPos];`,
            `        } else={`,
            `            :set localWanIp $localWanIpWithMask;`,
            `        }`,
            `        :log info ($logPrefix . "Local WAN IP on " . $wanInterfaceName . ": " . $localWanIp);`,
            `        :set globalWanIp $localWanIp;`,
            `    } else={`,
            `        :log warning ($logPrefix . "Could not retrieve IP address for interface " . $wanInterfaceName);`,
            `        :set globalWanIp "Error: Not Found";`,
            `        :set globalCgnatStatus "Undetermined (WAN IP Error)";`,
            `        :set globalPublicIp "Undetermined (WAN IP Error)";`,
            `        :log info ($logPrefix . "Script will complete and self-destruct due to WAN IP error.");`,
            `    }`,
            "",
            `    # Continue with CGNAT detection only if we have WAN IP`,
            `    :if ([:len $localWanIp] > 0 && $localWanIp != "Error: Not Found") do={`,
            `        # Check if Local WAN IP is in RFC 6598 CGNAT range (100.64.0.0/10)`,
            `        :local isRfc6598 false;`,
            `        :local firstOctet [:tonum [:pick $localWanIp 0 [:find $localWanIp "."]]];`,
            `        :local tempIp [:pick $localWanIp ([:find $localWanIp "."] + 1) [:len $localWanIp]];`,
            `        :local secondOctet [:tonum [:pick $tempIp 0 [:find $tempIp "."]]];`,
            "",
            `        :if ($firstOctet = 100 && $secondOctet >= 64 && $secondOctet <= 127) do={`,
            `            :set isRfc6598 true;`,
            `            :log info ($logPrefix . "Local WAN IP is in RFC 6598 range (100.64.0.0/10).");`,
            `        } else={`,
            `            :log info ($logPrefix . "Local WAN IP is NOT in RFC 6598 range.");`,
            `        }`,
            "",
            `        # Fetch Actual Public IP Address - corrected method`,
            `        :local actualPublicIp "";`,
            `        :local publicIpFetchError false;`,
            `        :do {`,
            `            :local fetchResult [/tool fetch url=$publicIpCheckUrl mode=http as-value output=user];`,
            `            :if (($fetchResult->"status") = "finished") do={`,
            `                :set actualPublicIp ($fetchResult->"data");`,
            `                # Clean up any trailing whitespace or newlines`,
            `                :while ([:len $actualPublicIp] > 0 && ([:pick $actualPublicIp ([:len $actualPublicIp] - 1)] = "\\n" || [:pick $actualPublicIp ([:len $actualPublicIp] - 1)] = "\\r" || [:pick $actualPublicIp ([:len $actualPublicIp] - 1)] = " ")) do={`,
            `                    :set actualPublicIp [:pick $actualPublicIp 0 ([:len $actualPublicIp] - 1)];`,
            `                }`,
            `                # Validate IP format (basic check)`,
            `                :local dotCount 0;`,
            `                :local charPos 0;`,
            `                :while ($charPos < [:len $actualPublicIp]) do={`,
            `                    :if ([:pick $actualPublicIp $charPos ($charPos + 1)] = ".") do={`,
            `                        :set dotCount ($dotCount + 1);`,
            `                    }`,
            `                    :set charPos ($charPos + 1);`,
            `                }`,
            `                :if ($dotCount = 3 && [:len $actualPublicIp] >= 7 && [:len $actualPublicIp] <= 15) do={`,
            `                    :log info ($logPrefix . "Successfully fetched actual public IP: " . $actualPublicIp);`,
            `                    :set globalPublicIp $actualPublicIp;`,
            `                } else={`,
            `                    :log warning ($logPrefix . "Fetched public IP does not look like a valid IP address: " . $actualPublicIp);`,
            `                    :set actualPublicIp "";`,
            `                    :set publicIpFetchError true;`,
            `                    :set globalPublicIp "Error: Invalid Format";`,
            `                }`,
            `            } else={`,
            `                :log warning ($logPrefix . "Fetching public IP failed. Status: " . ($fetchResult->"status"));`,
            `                :set publicIpFetchError true;`,
            `                :set globalPublicIp "Error: Fetch Failed";`,
            `            }`,
            `        } on-error={`,
            `            :log warning ($logPrefix . "Error during public IP fetch command execution.");`,
            `            :set publicIpFetchError true;`,
            `            :set globalPublicIp "Error: Command Execution";`,
            `        }`,
            "",
            `        # Determine CGNAT Status`,
            `        :if ($publicIpFetchError) do={`,
            `            :log warning ($logPrefix . "CGNAT status undetermined due to public IP fetch error.");`,
            `            :set globalCgnatStatus "Undetermined (Public IP Fetch Error)";`,
            `            :if ($isRfc6598) do={`,
            `                :log info ($logPrefix . "However, WAN IP is in RFC6598 range, strongly suggesting CGNAT.");`,
            `                :set globalCgnatStatus "Likely CGNAT (RFC6598, Public IP Fetch Error)";`,
            `            }`,
            `        } else={`,
            `            :if ([:len $localWanIp] > 0 && [:len $actualPublicIp] > 0) do={`,
            `                :if ($localWanIp = $actualPublicIp) do={`,
            `                    :log info ($logPrefix . "Local WAN IP matches actual public IP. No NAT detected upstream.");`,
            `                    :set globalCgnatStatus "No NAT/CGNAT (IPs Match)";`,
            `                } else={`,
            `                    :log warning ($logPrefix . "Local WAN IP MISMATCHES actual public IP. NAT detected upstream.");`,
            `                    :if ($isRfc6598) do={`,
            `                        :set globalCgnatStatus "CGNAT (RFC6598 & IP Mismatch)";`,
            `                    } else={`,
            `                        :set globalCgnatStatus "NAT Detected (IP Mismatch, Not RFC6598)";`,
            `                    }`,
            `                }`,
            `            } else={`,
            `                :log warning ($logPrefix . "CGNAT status undetermined (missing local or public IP for comparison).");`,
            `                :set globalCgnatStatus "Undetermined (IP Data Missing)";`,
            `            }`,
            `        }`,
            `    }`,
            `}`,
            "",
            "# Final Results Summary",
            `:log info ($logPrefix . "=== FINAL RESULTS ===");`,
            `:log info ($logPrefix . "Internet Status: " . $globalInternetStatus);`,
            `:log info ($logPrefix . "CGNAT Status: " . $globalCgnatStatus);`,
            `:log info ($logPrefix . "WAN IP: " . $globalWanIp);`,
            `:log info ($logPrefix . "Public IP: " . $globalPublicIp);`,
            `:log info ($logPrefix . "=== ONE-TIME SCRIPT COMPLETED ===");`,
            "",
            "# Script will now self-destruct (scheduler removal handled automatically)",
        ],
    };

    return ScriptAndScheduler({
        ScriptContent: cgnatScriptContent,
        Name: "CGNAT-Check",
        interval: "1d",
        startTime: "00:00:00",
    });
};

export const InitLetsEncrypt = (): RouterConfig => {
    // Create the Let's Encrypt certificate acquisition script content as RouterConfig
    const letsEncryptScriptContent: RouterConfig = {
        "": [
            ":delay 120s",
            "# MikroTik RouterOS Initial Let's Encrypt Certificate Acquisition Script",
            "# Version 2.2 - Enhanced diagnostics based on community troubleshooting",
            "",
            `:log info "--- Starting Initial Let's Encrypt Certificate Acquisition Script ---";`,
            "",
            "# --- Module 1: Comprehensive Internet and DNS Connectivity Check ---",
            `:local pingTarget1 "1.1.1.1";`,
            `:local pingTarget2 "8.8.8.8";`,
            `:local pingCount 3;`,
            `:local dnsTestHost "www.mikrotik.com";`,
            "",
            `:log info "Connectivity Check: Testing internet connectivity...";`,
            `:local ping1Result [/ping $pingTarget1 count=$pingCount];`,
            `:local ping2Result [/ping $pingTarget2 count=$pingCount];`,
            "",
            `:if ($ping1Result = 0 && $ping2Result = 0) do={`,
            `    :log error "Connectivity Check: No internet connectivity. Both ping tests failed.";`,
            `    :log info "--- Initial Let's Encrypt Script Finished (Error) ---";`,
            `} else={`,
            `    :log info ("Connectivity Check: Internet OK. Ping results: " . $pingTarget1 . "=" . $ping1Result . ", " . $pingTarget2 . "=" . $ping2Result);`,
            "",
            `    # DNS Resolution Test`,
            `    :log info "DNS Check: Testing DNS resolution...";`,
            `    :local dnsWorking false;`,
            `    :do {`,
            `        :local resolvedIp [:resolve $dnsTestHost];`,
            `        :if ([:len $resolvedIp] > 0) do={`,
            `            :set $dnsWorking true;`,
            `            :log info ("DNS Check: DNS resolution working. " . $dnsTestHost . " resolved to " . $resolvedIp);`,
            `        }`,
            `    } on-error={`,
            `        :log error ("DNS Check: DNS resolution failed for " . $dnsTestHost);`,
            `    }`,
            "",
            `    :if (!$dnsWorking) do={`,
            `        :log error "DNS Check: DNS resolution not working. Let's Encrypt will likely fail.";`,
            `        :log info "--- Initial Let's Encrypt Script Finished (Error) ---";`,
            `    } else={`,
            "",
            `        # --- Module 2: Enable MikroTik Cloud and Obtain DNS Name ---`,
            `        :log info "Cloud DNS: Enabling IP Cloud DDNS service.";`,
            `        /ip cloud set ddns-enabled=yes;`,
            "",
            `        :local cloudDnsName "";`,
            `        :local attemptCount 0;`,
            `        :local maxAttempts 10;`,
            "",
            `        :while ($cloudDnsName = "" && $attemptCount < $maxAttempts) do={`,
            `            :if ($attemptCount = 0) do={`,
            `                :log info "Cloud DNS: Forcing initial IP Cloud update.";`,
            `                /ip cloud force-update;`,
            `            }`,
            `            :delay 15s;`,
            `            :set $cloudDnsName [/ip cloud get dns-name];`,
            `            :set $attemptCount ($attemptCount + 1);`,
            `            :if ($cloudDnsName != "") do={`,
            `                :log info ("Cloud DNS: Obtained DNS name: " . $cloudDnsName);`,
            `            } else={`,
            `                :log warning ("Cloud DNS: DNS name not yet available. Attempt: " . $attemptCount . "/" . $maxAttempts);`,
            `            }`,
            `        }`,
            "",
            `        :if ($cloudDnsName = "") do={`,
            `            :log error ("Cloud DNS: Failed to obtain DNS name after " . $maxAttempts . " attempts. Cannot proceed.");`,
            `            :log error "Cloud DNS: Ensure your router has internet access and can reach MikroTik cloud services.";`,
            `            :log info "--- Initial Let's Encrypt Script Finished (Error) ---";`,
            `        } else={`,
            "",
            `            # --- Module 3: Verify DNS Resolution of Our Domain ---`,
            `            :log info ("DNS Verification: Testing if " . $cloudDnsName . " resolves to our public IP...");`,
            `            :local ourPublicIp "";`,
            `            :local dnsResolvesToUs false;`,
            "",
            `            # Get our public IP`,
            `            :do {`,
            `                :local fetchResult [/tool fetch url="http://api.ipify.org" mode=http as-value output=user];`,
            `                :if (($fetchResult->"status") = "finished") do={`,
            `                    :set $ourPublicIp ($fetchResult->"data");`,
            `                    # Clean up whitespace`,
            `                    :while ([:len $ourPublicIp] > 0 && ([:pick $ourPublicIp ([:len $ourPublicIp] - 1)] = "\\n" || [:pick $ourPublicIp ([:len $ourPublicIp] - 1)] = "\\r" || [:pick $ourPublicIp ([:len $ourPublicIp] - 1)] = " ")) do={`,
            `                        :set $ourPublicIp [:pick $ourPublicIp 0 ([:len $ourPublicIp] - 1)];`,
            `                    }`,
            `                    :log info ("DNS Verification: Our public IP is " . $ourPublicIp);`,
            `                }`,
            `            } on-error={`,
            `                :log warning "DNS Verification: Could not determine our public IP.";`,
            `            }`,
            "",
            `            # Check if our domain resolves to our IP`,
            `            :if ([:len $ourPublicIp] > 0) do={`,
            `                :do {`,
            `                    :local resolvedIp [:resolve $cloudDnsName];`,
            `                    :if ($resolvedIp = $ourPublicIp) do={`,
            `                        :set $dnsResolvesToUs true;`,
            `                        :log info ("DNS Verification: SUCCESS - " . $cloudDnsName . " resolves to our IP " . $ourPublicIp);`,
            `                    } else={`,
            `                        :log warning ("DNS Verification: MISMATCH - " . $cloudDnsName . " resolves to " . $resolvedIp . " but our public IP is " . $ourPublicIp);`,
            `                        :log warning "DNS Verification: This may cause Let's Encrypt to fail. Wait for DNS propagation or check cloud DDNS.";`,
            `                    }`,
            `                } on-error={`,
            `                    :log warning ("DNS Verification: Could not resolve " . $cloudDnsName . ". DNS may not be propagated yet.");`,
            `                }`,
            `            }`,
            "",
            `            # --- Module 4: Prepare for ACME Challenge ---`,
            `            :local leFirewallComment "LE-Initial-Cert-HTTP-Challenge";`,
            `            :local certRequestSuccessful false;`,
            `            :local wwwServiceWasDisabled false;`,
            "",
            `            # Check current firewall rules for port 80`,
            `            :log info "Firewall Check: Analyzing current firewall rules for port 80...";`,
            `            :local existingPort80Rules [/ip firewall filter find where chain="input" and protocol="tcp" and dst-port=80];`,
            `            :if ([:len $existingPort80Rules] > 0) do={`,
            `                :log info ("Firewall Check: Found " . [:len $existingPort80Rules] . " existing rule(s) for port 80.");`,
            `                :foreach ruleId in=$existingPort80Rules do={`,
            `                    :local ruleAction [/ip firewall filter get $ruleId action];`,
            `                    :local ruleComment [/ip firewall filter get $ruleId comment];`,
            `                    :log info ("Firewall Check: Rule action=" . $ruleAction . ", comment=" . $ruleComment);`,
            `                }`,
            `            } else={`,
            `                :log warning "Firewall Check: No existing rules found for port 80. Adding temporary rule.";`,
            `            }`,
            "",
            `            # Check and enable www service`,
            `            :local wwwService [/ip service find name="www"];`,
            `            :if ([:len $wwwService] > 0) do={`,
            `                :local wwwPort [/ip service get $wwwService port];`,
            `                :if ([/ip service get $wwwService disabled]) do={`,
            `                    :set $wwwServiceWasDisabled true;`,
            `                    :log info ("Service Check: Enabling www service on port " . $wwwPort . " for ACME challenge.");`,
            `                    /ip service enable $wwwService;`,
            `                } else={`,
            `                    :log info ("Service Check: www service already enabled on port " . $wwwPort . ".");`,
            `                }`,
            `            } else={`,
            `                :log error "Service Check: www service not found. This is required for ACME challenge.";`,
            `                :log info "--- Initial Let's Encrypt Script Finished (Error) ---";`,
            `            }`,
            "",
            `            # Add firewall rule with enhanced error handling`,
            `            :log info "Firewall Setup: Adding firewall rule for ACME challenge on port 80.";`,
            `            :local firewallRuleAdded false;`,
            `            :do {`,
            `                # Try to add rule at the beginning, but handle case where no rules exist`,
            `                :local existingRules [/ip firewall filter find];`,
            `                :if ([:len $existingRules] > 0) do={`,
            `                    /ip firewall filter add action=accept chain=input protocol=tcp dst-port=80 comment=$leFirewallComment place-before=0;`,
            `                } else={`,
            `                    /ip firewall filter add action=accept chain=input protocol=tcp dst-port=80 comment=$leFirewallComment;`,
            `                }`,
            `                :set $firewallRuleAdded true;`,
            `                :log info "Firewall Setup: Firewall rule added successfully.";`,
            `            } on-error={`,
            `                # Fallback: add rule without place-before if there's an issue`,
            `                :log warning "Firewall Setup: Failed to add rule with place-before, trying without position.";`,
            `                :do {`,
            `                    /ip firewall filter add action=accept chain=input protocol=tcp dst-port=80 comment=$leFirewallComment;`,
            `                    :set $firewallRuleAdded true;`,
            `                    :log info "Firewall Setup: Firewall rule added successfully (fallback method).";`,
            `                } on-error={`,
            `                    :log error "Firewall Setup: Failed to add firewall rule. ACME challenge will likely fail.";`,
            `                }`,
            `            }`,
            "",
            `            # Wait for services to be ready`,
            `            :log info "Setup Complete: Waiting 10 seconds for services to be ready...";`,
            `            :delay 10s;`,
            "",
            `            # --- Module 5: Request Certificate with Enhanced Logging ---`,
            `            :if ($firewallRuleAdded) do={`,
            `                :log info ("Certificate Request: Initiating Let's Encrypt certificate request for " . $cloudDnsName);`,
            `                :log info "Certificate Request: This may take 60-120 seconds. Please wait...";`,
            `                `,
            `                :local certificateRequestError false;`,
            `                :local requestStartTime [/system clock get time];`,
            `                `,
            `                :do {`,
            `                    /certificate enable-ssl-certificate dns-name=$cloudDnsName;`,
            `                    :log info "Certificate Request: Command executed successfully.";`,
            `                } on-error={`,
            `                    :log error "Certificate Request: Failed to execute certificate request command.";`,
            `                    :log error "Certificate Request: Common causes:";`,
            `                    :log error "Certificate Request: 1. Port 80 not accessible from internet";`,
            `                    :log error "Certificate Request: 2. DNS not pointing to this router";`,
            `                    :log error "Certificate Request: 3. Rate limiting (too many attempts)";`,
            `                    :log error "Certificate Request: 4. ISP blocking port 80";`,
            `                    :set $certificateRequestError true;`,
            `                }`,
            "",
            `                # Extended wait and verification with progress updates`,
            `                :if (!$certificateRequestError) do={`,
            `                    :log info "Certificate Request: Waiting for certificate issuance (up to 120 seconds)...";`,
            `                    :local totalWaitTime 0;`,
            `                    :local maxWaitTime 120;`,
            `                    :local checkInterval 15;`,
            `                    :local certificateFound false;`,
            `                    `,
            `                    :while ($totalWaitTime < $maxWaitTime && !$certificateFound) do={`,
            `                        :delay ($checkInterval . "s");`,
            `                        :set $totalWaitTime ($totalWaitTime + $checkInterval);`,
            `                        `,
            `                        :local newCertEntry [/certificate find common-name=$cloudDnsName];`,
            `                        :if ([:len $newCertEntry] > 0) do={`,
            `                            :set $certificateFound true;`,
            `                            :log info ("Certificate Verification: Certificate found after " . $totalWaitTime . " seconds!");`,
            `                        } else={`,
            `                            :log info ("Certificate Verification: Still waiting... (" . $totalWaitTime . "/" . $maxWaitTime . " seconds)");`,
            `                        }`,
            `                    }`,
            `                    `,
            `                    :if (!$certificateFound) do={`,
            `                        :log error ("Certificate Verification: Certificate not found after " . $maxWaitTime . " seconds.");`,
            `                        :log error "Certificate Verification: The request may have failed or is taking longer than expected.";`,
            `                    }`,
            `                }`,
            `            } else={`,
            `                :log error "Certificate Request: Skipping certificate request due to firewall setup failure.";`,
            `                :set $certificateRequestError true;`,
            `            }`,
            "",
            `            # --- Module 6: Cleanup and Restore Security ---`,
            `            :log info "Cleanup: Removing temporary firewall rule.";`,
            `            :do {`,
            `                /ip firewall filter remove [find comment=$leFirewallComment];`,
            `                :log info "Cleanup: Firewall rule removed successfully.";`,
            `            } on-error={`,
            `                :log warning "Cleanup: Could not remove firewall rule (may not exist).";`,
            `            }`,
            "",
            `            # Restore www service to previous state if it was disabled`,
            `            :if ($wwwServiceWasDisabled) do={`,
            `                :log info "Cleanup: Restoring www service to disabled state.";`,
            `                /ip service disable [find name="www"];`,
            `            }`,
            "",
            `            # --- Module 7: Final Verification and Service Application ---`,
            `            :if (!$certificateRequestError) do={`,
            `                :log info ("Certificate Verification: Performing final verification for " . $cloudDnsName);`,
            `                :local newCertEntry [/certificate find common-name=$cloudDnsName];`,
            "",
            `                :if ([:len $newCertEntry] > 0) do={`,
            `                    :local newCertId [:pick $newCertEntry 0];`,
            `                    :local newCertName [/certificate get $newCertId name];`,
            `                    :local newCertTrusted [/certificate get $newCertId trusted];`,
            `                    :local newCertExpiry [/certificate get $newCertId expires-after];`,
            `                    `,
            `                    :if ($newCertTrusted) do={`,
            `                        :log info ("Certificate Verification: SUCCESS! Certificate: " . $newCertName);`,
            `                        :log info ("Certificate Verification: Common Name: " . $cloudDnsName);`,
            `                        :log info ("Certificate Verification: Expires: " . $newCertExpiry);`,
            `                        :set $certRequestSuccessful true;`,
            "",
            `                        # Apply to www-ssl service (WebFig) if it exists`,
            `                        :local wwwSslService [/ip service find name="www-ssl"];`,
            `                        :if ([:len $wwwSslService] > 0) do={`,
            `                            /ip service set $wwwSslService certificate=$newCertName;`,
            `                            :log info ("Certificate Application: Applied certificate " . $newCertName . " to www-ssl service.");`,
            `                        } else={`,
            `                            :log info "Certificate Application: www-ssl service not found (may be disabled).";`,
            `                        }`,
            "",
            `                        # Apply to api-ssl service if it exists`,
            `                        :local apiSslService [/ip service find name="api-ssl"];`,
            `                        :if ([:len $apiSslService] > 0) do={`,
            `                            /ip service set $apiSslService certificate=$newCertName;`,
            `                            :log info ("Certificate Application: Applied certificate " . $newCertName . " to api-ssl service.");`,
            `                        } else={`,
            `                            :log info "Certificate Application: api-ssl service not found (may be disabled).";`,
            `                        }`,
            `                    } else={`,
            `                        :log error ("Certificate Verification: Certificate " . $newCertName . " was created but is not trusted.");`,
            `                        :log error "Certificate Verification: Check certificate validity and CA chain.";`,
            `                    }`,
            "",
            `                } else={`,
            `                    :log error ("Certificate Verification: No certificate found for " . $cloudDnsName);`,
            `                    :log error "Certificate Verification: The Let's Encrypt request likely failed.";`,
            `                    `,
            `                    # Check for any existing certificates for debugging`,
            `                    :local allCerts [/certificate find];`,
            `                    :log info ("Certificate Verification: Total certificates in system: " . [:len $allCerts]);`,
            `                    :foreach certId in=$allCerts do={`,
            `                        :local certName [/certificate get $certId name];`,
            `                        :local certCN [/certificate get $certId common-name];`,
            `                        :local certTrusted [/certificate get $certId trusted];`,
            `                        :log info ("Certificate Verification: Found cert: " . $certName . ", CN: " . $certCN . ", trusted: " . $certTrusted);`,
            `                    }`,
            `                }`,
            `            }`,
            "",
            `            # Final status report`,
            `            :if ($certRequestSuccessful) do={`,
            `                :log info "=== CERTIFICATE ACQUISITION SUCCESSFUL ===";`,
            `                :log info ("Domain: " . $cloudDnsName);`,
            `                :log info "Status: Certificate issued and applied to services";`,
            `                :log info "Next: Certificate will auto-renew before expiry";`,
            `                :log info "=== Initial Let's Encrypt Script Finished Successfully ===";`,
            `            } else={`,
            `                :log error "=== CERTIFICATE ACQUISITION FAILED ===";`,
            `                :log error "Troubleshooting steps:";`,
            `                :log error "1. Verify port 80 is accessible from internet";`,
            `                :log error "2. Check if DNS points to your router's public IP";`,
            `                :log error "3. Ensure no ISP blocking of port 80";`,
            `                :log error "4. Wait 1 hour if rate limited, then retry";`,
            `                :log error "5. Check MikroTik cloud DDNS is working";`,
            `                :log error "=== Initial Let's Encrypt Script Finished With Errors ===";`,
            `            }`,
            `        }`,
            `    }`,
            `}`,
            "",
            "# Script will now self-destruct (scheduler removal handled automatically)",
        ],
    };

    // Use OneTimeScript to create a one-time script and scheduler
    return OneTimeScript({
        ScriptContent: letsEncryptScriptContent,
        name: "Init-LetsEncrypt",
        startTime: "startup",
    });
};

export const RenewalLetsEncrypt = (
    certNameToRenew: string = "MikroTik-LE-Cert",
    daysBeforeExpiryToRenew: number = 30,
): RouterConfig => {
    // Create the Let's Encrypt certificate renewal script content as RouterConfig
    const renewalScriptContent: RouterConfig = {
        "": [
            "# MikroTik RouterOS Automated Let's Encrypt Certificate Renewal Script",
            "# Version 2.0 - Based on successful community practices",
            "",
            `:log info "--- Starting Automated Let's Encrypt Certificate Renewal Script ---";`,
            "",
            "# --- Configuration ---",
            `:local certNameToRenew "${certNameToRenew}";`,
            `:local daysBeforeExpiryToRenew ${daysBeforeExpiryToRenew};`,
            "",
            "# --- Module 0: Verify Internet Connectivity ---",
            `:local pingTarget "1.1.1.1";`,
            `:local pingCount 3;`,
            `:local pingResult [/ping $pingTarget count=$pingCount];`,
            "",
            `:if ($pingResult = 0) do={`,
            `    :log error "Internet Check: No connectivity to $pingTarget. Exiting script.";`,
            `    :log info "--- Renewal Script Finished (Error) ---";`,
            `} else={`,
            `    :log info "Internet Check: Connectivity to $pingTarget confirmed.";`,
            "",
            `    # --- Module 1: Check Certificate Expiry and Need for Renewal ---`,
            `    :local cloudDnsName [/ip cloud get dns-name];`,
            `    :if ($cloudDnsName = "") do={`,
            `        :log error "Renewal Check: MikroTik Cloud DNS name not found. Ensure IP Cloud is enabled and working.";`,
            `        :log info "--- Renewal Script Finished (Error) ---";`,
            `    } else={`,
            `        :local certIdToRenew "";`,
            `        :local certEntry [/certificate find name=$certNameToRenew];`,
            "",
            `        :if ([:len $certEntry] > 0) do={`,
            `            :set certIdToRenew [:pick $certEntry 0];`,
            `        } else={`,
            `            # If primary named cert not found, look for an auto-generated one for the same common name`,
            `            :set certEntry [/certificate find common-name=$cloudDnsName];`,
            `            :if ([:len $certEntry] > 0) do={`,
            `                :set certIdToRenew [:pick $certEntry 0];`,
            `                :local foundAutoGenName [/certificate get $certIdToRenew name];`,
            `                :log warning "Renewal Check: Certificate '$certNameToRenew' not found. Using existing auto-generated cert '$foundAutoGenName' for CN '$cloudDnsName'.";`,
            `                :set certNameToRenew $foundAutoGenName;`,
            `            } else={`,
            `                :log error "Renewal Check: No certificate found for CN '$cloudDnsName' (neither '$certNameToRenew' nor auto-generated). Run initial acquisition script or check CN.";`,
            `                :log info "--- Renewal Script Finished (Error) ---";`,
            `            }`,
            `        }`,
            "",
            `        :if ($certIdToRenew != "") do={`,
            `            :local expiresAfterStr [/certificate get $certIdToRenew expires-after];`,
            `            :local currentTime [/system clock get time];`,
            `            :local currentDate [/system clock get date];`,
            "",
            `            # Simple expiry calculation - estimate days remaining (simplified)`,
            `            :local daysToExpire 90;`,
            `            :do {`,
            `                # Try to calculate actual days to expiry - simplified estimation`,
            `                :local monthStr [:pick $expiresAfterStr 0 3];`,
            `                # Basic month comparison logic would go here`,
            `                # For now, use simple heuristic based on "expires-after" field`,
            `                :if ([:find $expiresAfterStr "day"] >= 0) do={`,
            `                    :local dayPos [:find $expiresAfterStr "day"];`,
            `                    :local spacePos [:find $expiresAfterStr " " 0];`,
            `                    :if ($spacePos >= 0 && $spacePos < $dayPos) do={`,
            `                        :local dayNumStr [:pick $expiresAfterStr 0 $spacePos];`,
            `                        :set daysToExpire [:tonum $dayNumStr];`,
            `                    }`,
            `                }`,
            `            } on-error={`,
            `                :log warning "Renewal Check: Could not calculate exact expiry date. Using default estimate of 90 days.";`,
            `                :set daysToExpire 90;`,
            `            }`,
            "",
            `            :log info "Renewal Check: Certificate '$certNameToRenew' (CN: $cloudDnsName) expires on $expiresAfterStr (estimated $daysToExpire days remaining).";`,
            "",
            `            :local needsRenewal false;`,
            `            :if ($daysToExpire < $daysBeforeExpiryToRenew) do={`,
            `                :log warning "Renewal Check: Certificate needs renewal. Expires in $daysToExpire days (threshold: $daysBeforeExpiryToRenew days).";`,
            `                :set needsRenewal true;`,
            `            } else={`,
            `                :log info "Renewal Check: Certificate is still valid for $daysToExpire days. No renewal needed.";`,
            `                :log info "--- Renewal Script Finished (No Action Needed) ---";`,
            `            }`,
            "",
            `            # --- Module 2: Performing the Renewal (if needed) ---`,
            `            :if ($needsRenewal) do={`,
            `                :local leFirewallComment "LE-Renewal-Cert-HTTP-Challenge";`,
            `                :local renewalCertRequestSuccessful false;`,
            `                :local wwwServiceWasDisabled false;`,
            "",
            `                # Enable www service if disabled`,
            `                :local wwwService [/ip service find name="www"];`,
            `                :if ([:len $wwwService] > 0) do={`,
            `                    :if ([/ip service get $wwwService disabled]) do={`,
            `                        :set wwwServiceWasDisabled true;`,
            `                        :log info "Certificate Renewal: Enabling www service for ACME challenge.";`,
            `                        /ip service enable $wwwService;`,
            `                    }`,
            `                } else={`,
            `                    :log warning "Certificate Renewal: www service not found.";`,
            `                }`,
            "",
            `                :log info "Certificate Renewal: Removing old certificate '$certNameToRenew' to ensure clean renewal.";`,
            `                /certificate remove $certIdToRenew;`,
            `                :delay 5s;`,
            "",
            `                :log info "Certificate Renewal: Adding firewall rule for ACME challenge on port 80.";`,
            `                :do {`,
            `                    # Try to add rule at the beginning, but handle case where no rules exist`,
            `                    :local existingRules [/ip firewall filter find];`,
            `                    :if ([:len $existingRules] > 0) do={`,
            `                        /ip firewall filter add action=accept chain=input protocol=tcp dst-port=80 comment=$leFirewallComment place-before=0;`,
            `                    } else={`,
            `                        /ip firewall filter add action=accept chain=input protocol=tcp dst-port=80 comment=$leFirewallComment;`,
            `                    }`,
            `                    :log info "Certificate Renewal: Firewall rule added successfully.";`,
            `                } on-error={`,
            `                    # Fallback: add rule without place-before if there's an issue`,
            `                    :log warning "Certificate Renewal: Failed to add rule with place-before, trying without position.";`,
            `                    :do {`,
            `                        /ip firewall filter add action=accept chain=input protocol=tcp dst-port=80 comment=$leFirewallComment;`,
            `                        :log info "Certificate Renewal: Firewall rule added successfully (fallback method).";`,
            `                    } on-error={`,
            `                        :log error "Certificate Renewal: Failed to add firewall rule. ACME challenge may fail.";`,
            `                        :set $certificateRequestError true;`,
            `                    }`,
            `                }`,
            "",
            `                # Small delay to ensure services are ready`,
            `                :delay 5s;`,
            "",
            `                :log info "Certificate Renewal: Initiating Let's Encrypt certificate request for $cloudDnsName.";`,
            `                :local certificateRequestError false;`,
            `                :do {`,
            `                    /certificate enable-ssl-certificate dns-name=$cloudDnsName;`,
            `                    :log info "Certificate Renewal: Command executed successfully.";`,
            `                } on-error={`,
            `                    :log error "Certificate Renewal: Failed to execute certificate request.";`,
            `                    :set certificateRequestError true;`,
            `                }`,
            "",
            `                # Wait for certificate issuance with verification loop`,
            `                :if (!$certificateRequestError) do={`,
            `                    :log info "Certificate Renewal: Waiting 90 seconds for certificate issuance...";`,
            `                    :delay 90s;`,
            `                    `,
            `                    # Check multiple times if certificate is ready`,
            `                    :local certCheckAttempts 0;`,
            `                    :local maxCertCheckAttempts 6;`,
            `                    :local certificateFound false;`,
            `                    `,
            `                    :while ($certCheckAttempts < $maxCertCheckAttempts && !$certificateFound) do={`,
            `                        :local newAutoGenCertInfo [/certificate find common-name=$cloudDnsName];`,
            `                        :if ([:len $newAutoGenCertInfo] > 0) do={`,
            `                            :set certificateFound true;`,
            `                            :log info "Certificate Renewal: Certificate found on attempt " . ($certCheckAttempts + 1);`,
            `                        } else={`,
            `                            :set certCheckAttempts ($certCheckAttempts + 1);`,
            `                            :if ($certCheckAttempts < $maxCertCheckAttempts) do={`,
            `                                :log info "Certificate Renewal: Certificate not ready yet, waiting 10 more seconds (attempt " . $certCheckAttempts . "/" . $maxCertCheckAttempts . ")";`,
            `                                :delay 10s;`,
            `                            }`,
            `                        }`,
            `                    }`,
            `                }`,
            "",
            `                # Cleanup first`,
            `                :log info "Certificate Renewal: Cleaning up - removing firewall rule.";`,
            `                /ip firewall filter remove [find comment=$leFirewallComment];`,
            "",
            `                # Restore www service if it was disabled`,
            `                :if ($wwwServiceWasDisabled) do={`,
            `                    :log info "Certificate Renewal: Restoring www service to disabled state.";`,
            `                    /ip service disable [find name="www"];`,
            `                }`,
            "",
            `                # Process the new certificate`,
            `                :if (!$certificateRequestError) do={`,
            `                    :log info "Certificate Renewal: Verifying newly issued certificate for $cloudDnsName.";`,
            `                    :local newAutoGenCertInfo [/certificate find common-name=$cloudDnsName];`,
            "",
            `                    :if ([:len $newAutoGenCertInfo] > 0) do={`,
            `                        :local newAutoGenCertId [:pick $newAutoGenCertInfo 0];`,
            `                        :local newAutoGenCertName [/certificate get $newAutoGenCertId name];`,
            `                        :local newCertTrusted [/certificate get $newAutoGenCertId trusted];`,
            "",
            `                        :if ($newCertTrusted) do={`,
            `                            :log info "Certificate Renewal: New auto-generated certificate found: $newAutoGenCertName.";`,
            `                            /certificate set $newAutoGenCertId name="${certNameToRenew}";`,
            `                            :log info "Certificate Renewal: Renamed $newAutoGenCertName to '${certNameToRenew}'.";`,
            `                            :set renewalCertRequestSuccessful true;`,
            "",
            `                            # Apply to services`,
            `                            :local wwwSslService [/ip service find name="www-ssl"];`,
            `                            :if ([:len $wwwSslService] > 0) do={`,
            `                                /ip service set $wwwSslService certificate="${certNameToRenew}";`,
            `                                :log info "Certificate Renewal: Applied new certificate '${certNameToRenew}' to www-ssl service.";`,
            `                            }`,
            `                            :local apiSslService [/ip service find name="api-ssl"];`,
            `                            :if ([:len $apiSslService] > 0) do={`,
            `                                /ip service set $apiSslService certificate="${certNameToRenew}";`,
            `                                :log info "Certificate Renewal: Applied new certificate '${certNameToRenew}' to api-ssl service.";`,
            `                            }`,
            `                        } else={`,
            `                            :log error "Certificate Renewal: New certificate $newAutoGenCertName was created but is not trusted.";`,
            `                        }`,
            `                    } else={`,
            `                        :log error "Certificate Renewal: Failed to find newly issued auto-generated certificate for $cloudDnsName.";`,
            `                    }`,
            `                }`,
            "",
            `                :if ($renewalCertRequestSuccessful) do={`,
            `                    :log info "--- Renewal Script Finished Successfully ---";`,
            `                } else={`,
            `                    :log error "--- Renewal Script Finished With Errors ---";`,
            `                    :log error "Common causes: 1) Port 80 not accessible from internet, 2) DNS not pointing to this router, 3) Firewall blocking ACME, 4) ISP blocking port 80";`,
            `                }`,
            `            }`,
            `        }`,
            `    }`,
            `}`,
            "",
            "# Script will now self-destruct (scheduler removal handled automatically)",
        ],
    };

    return ScriptAndScheduler({
        ScriptContent: renewalScriptContent,
        Name: "Renewal-LetsEncrypt",
        interval: "1d",
        startTime: "03:00:00",
    });
};

export const LetsEncrypt = (
    certNameToRenew: string = "MikroTik-LE-Cert",
    daysBeforeExpiryToRenew: number = 30,
    _renewalStartTime: string = "03:00:00",
): RouterConfig => {
    // Get the initial Let's Encrypt script (one-time)
    const initScript = InitLetsEncrypt();

    // Get the renewal script with scheduler (uses the renewalStartTime parameter)
    const renewalScript = RenewalLetsEncrypt(
        certNameToRenew,
        daysBeforeExpiryToRenew,
    );

    // Merge all configurations using mergeMultipleConfigs
    const config = mergeMultipleConfigs(initScript, renewalScript);

    // Add comprehensive comments at the beginning
    const comments = [
        // "# Complete Let's Encrypt Certificate Management Setup",
        // "# ================================================",
        "",
        // "# This configuration includes:",
        // "# 1. Initial certificate acquisition (one-time script + scheduler)",
        // "# 2. Certificate renewal script with daily scheduler",
        // "",
        // `# Certificate Configuration:`,
        // `# - Certificate Name: ${certNameToRenew}`,
        // `# - Renewal Threshold: ${daysBeforeExpiryToRenew} days before expiry`,
        // `# - Daily Check Time: ${renewalStartTime}`,
        // "",
        // "# Scripts Created:",
        // "# - Init-LetsEncrypt: One-time initial certificate acquisition (self-removing)",
        // "# - Renewal-LetsEncrypt: Daily Let's Encrypt renewal checks",
        // "",
        // "# Schedulers Created:",
        // "# - Init-LetsEncrypt: Runs initial script once at startup (self-removing)",
        // "# - Renewal-LetsEncrypt: Daily renewal checks at 03:00:00",
        // "",
        // "# Usage:",
        // "# 1. Initial setup runs automatically at startup",
        // "# 2. Daily renewal checks run automatically",
        // "# 3. Manual renewal: /system script run Renewal-LetsEncrypt",
        // "",
    ];

    // Add comments to the beginning
    if (!config[""]) {
        config[""] = [];
    }
    config[""] = [...comments, ...config[""]];

    return config;
};

export const PublicCert = (): RouterConfig => {
    // Create the Public Certificate Update script content as RouterConfig
    // const publicCertScriptContent: RouterConfig = {
    //     "": [
    //         ":delay 100s;",
    //         "# MikroTik RouterOS Public Certificate Authority Update Script",
    //         "# Version 1.0 - ONE TIME EXECUTION",
    //         "",
    //         ':log info "--- Starting Public Certificate Authority Update Script ---";',
    //         "",
    //         "# --- Configuration Variables ---",
    //         ':global logPrefix "CertUpdate:";',
    //         ':global pingTarget1 "1.1.1.1";',
    //         ':global pingTarget2 "8.8.8.8";',
    //         ":global pingCount 3;",
    //         ':global dnsTestHost "www.mikrotik.com";',
    //         "",
    //         ':global cacertFile "cacert.pem";',
    //         ':global cacertUrl "https://curl.se/ca/cacert.pem";',
    //         ':global importedCaCertName "cacert-bundle-public";',
    //         "",
    //         ':global googleCertFile "roots-goog.pem";',
    //         ':global googleCertUrl "https://pki.goog/roots.pem";',
    //         ':global importedGoogCertName "google-roots-public";',
    //         "",
    //         ":global downloadDelaySec 10;",
    //         ":global importDelaySec 5;",
    //         "",
    //         "# Set to 'yes' to validate server certs during fetch, 'no' otherwise.",
    //         "# 'no' is safer for initial runs if router's CA store is very old.",
    //         "# --- End Configuration Variables ---",
    //         "",
    //         ':log info "$logPrefix Script started.";',
    //         "",
    //         "# 1. Internet Connectivity Check (Ping)",
    //         ':log info "$logPrefix Performing Internet connectivity check...";',
    //         ":local ping1Received [/ping $pingTarget1 count=$pingCount];",
    //         ":local ping2Received [/ping $pingTarget2 count=$pingCount];",
    //         "",
    //         ":if ($ping1Received = 0 && $ping2Received = 0) do={",
    //         '    :log error "$logPrefix Internet connectivity check failed (both $pingTarget1 and $pingTarget2 unreachable). Exiting.";',
    //         "} else={",
    //         '    :log info "$logPrefix Internet connectivity check successful.";',
    //         "",
    //         "    # 2. DNS Resolution Check",
    //         '    :log info "$logPrefix Performing DNS resolution check...";',
    //         '    :local resolvedIp "";',
    //         "    :do {",
    //         "        :set $resolvedIp [:resolve $dnsTestHost];",
    //         "    } on-error={",
    //         '        :log error "$logPrefix DNS resolution test failed for $dnsTestHost. Exiting.";',
    //         "    }",
    //         "    :if ([:len $resolvedIp] = 0) do={",
    //         '        :log error "$logPrefix DNS resolution test failed for $dnsTestHost. Exiting.";',
    //         "    } else={",
    //         '        :log info "$logPrefix DNS resolution test successful for $dnsTestHost (resolved to $resolvedIp).";',
    //         "",
    //         "        # 3. Download cacert.pem",
    //         '        :log info "$logPrefix Attempting to download $cacertFile from $cacertUrl...";',
    //         "        :do {",
    //         "            /tool fetch url=$cacertUrl dst-path=$cacertFile mode=http  ;",
    //         "            :delay 2s;",
    //         "            :if ([:len [/file find name=$cacertFile]] > 0) do={",
    //         '                :log info "$logPrefix Successfully downloaded $cacertFile.";',
    //         "            } else={",
    //         '                :log error "$logPrefix Failed to download $cacertFile (file not found after fetch). Exiting.";',
    //         "            }",
    //         "        } on-error={",
    //         '            :log error "$logPrefix Error during fetch of $cacertFile. Exiting.";',
    //         "        }",
    //         '        :log info "$logPrefix Waiting $downloadDelaySec seconds after downloading $cacertFile...";',
    //         "        :delay $downloadDelaySec;",
    //         "",
    //         "        # 4. Download roots-goog.pem",
    //         '        :log info "$logPrefix Attempting to download $googleCertFile from $googleCertUrl...";',
    //         "        :do {",
    //         "            /tool fetch url=$googleCertUrl dst-path=$googleCertFile mode=http  ;",
    //         "            :delay 2s;",
    //         "            :if ([:len [/file find name=$googleCertFile]] > 0) do={",
    //         '                :log info "$logPrefix Successfully downloaded $googleCertFile.";',
    //         "            } else={",
    //         '                :log error "$logPrefix Failed to download $googleCertFile (file not found after fetch). Exiting.";',
    //         "            }",
    //         "        } on-error={",
    //         '            :log error "$logPrefix Error during fetch of $googleCertFile. Exiting.";',
    //         "        }",
    //         '        :log info "$logPrefix Waiting $downloadDelaySec seconds after downloading $googleCertFile...";',
    //         "        :delay $downloadDelaySec;",
    //         "",
    //         "        # 5. Import cacert.pem",
    //         '        :log info "$logPrefix Processing $cacertFile for import as $importedCaCertName...";',
    //         "        :if ([:len [/file find name=$cacertFile]] > 0) do={",
    //         '            :log info "$logPrefix Found $cacertFile. Attempting to import as $importedCaCertName.";',
    //         "            # Remove existing certificate with the target name, if any",
    //         "            :local existingCaCert [/certificate find name=$importedCaCertName];",
    //         "            :if ([:len $existingCaCert] > 0) do={",
    //         "                /certificate remove $existingCaCert;",
    //         '                :log info "$logPrefix Removed existing certificate(s) named $importedCaCertName.";',
    //         "            }",
    //         "            # Import the new certificate",
    //         '            /certificate import file-name=$cacertFile name=$importedCaCertName passphrase="" trusted=yes;',
    //         "            :delay 2s;",
    //         "            # Verify import",
    //         "            :if ([:len [/certificate find name=$importedCaCertName trusted=yes]] > 0) do={",
    //         '                :log info "$logPrefix Successfully imported $cacertFile as $importedCaCertName.";',
    //         "            } else={",
    //         '                :log error "$logPrefix Failed to import $cacertFile as $importedCaCertName, or it was not marked trusted.";',
    //         "            }",
    //         "        } else={",
    //         '            :log error "$logPrefix $cacertFile not found. Skipping import.";',
    //         "        }",
    //         '        :log info "$logPrefix Waiting $importDelaySec seconds after importing $cacertFile...";',
    //         "        :delay $importDelaySec;",
    //         "",
    //         "        # 6. Import roots-goog.pem",
    //         '        :log info "$logPrefix Processing $googleCertFile for import as $importedGoogCertName...";',
    //         "        :if ([:len [/file find name=$googleCertFile]] > 0) do={",
    //         '            :log info "$logPrefix Found $googleCertFile. Attempting to import as $importedGoogCertName.";',
    //         "            # Remove existing certificate with the target name, if any",
    //         "            :local existingGoogCert [/certificate find name=$importedGoogCertName];",
    //         "            :if ([:len $existingGoogCert] > 0) do={",
    //         "                /certificate remove $existingGoogCert;",
    //         '                :log info "$logPrefix Removed existing certificate(s) named $importedGoogCertName.";',
    //         "            }",
    //         "            # Import the new certificate",
    //         '            /certificate import file-name=$googleCertFile name=$importedGoogCertName trusted=yes passphrase="";',
    //         "            :delay 2s;",
    //         "            # Verify import",
    //         "            :if ([:len [/certificate find name=$importedGoogCertName trusted=yes]] > 0) do={",
    //         '                :log info "$logPrefix Successfully imported $googleCertFile as $importedGoogCertName.";',
    //         "            } else={",
    //         '                :log error "$logPrefix Failed to import $googleCertFile as $importedGoogCertName, or it was not marked trusted.";',
    //         "            }",
    //         "        } else={",
    //         '            :log error "$logPrefix $googleCertFile not found. Skipping import.";',
    //         "        }",
    //         '        :log info "$logPrefix Waiting $importDelaySec seconds after importing $googleCertFile...";',
    //         "        :delay $importDelaySec;",
    //         "",
    //         "        # 7. Post-Operation Cleanup",
    //         '        :log info "$logPrefix Performing post-operation cleanup...";',
    //         "        :if ([:len [/file find name=$cacertFile]] > 0) do={",
    //         "            /file remove $cacertFile;",
    //         '            :log info "$logPrefix Removed temporary file $cacertFile.";',
    //         "        }",
    //         "        :if ([:len [/file find name=$googleCertFile]] > 0) do={",
    //         "            /file remove $googleCertFile;",
    //         '            :log info "$logPrefix Removed temporary file $googleCertFile.";',
    //         "        }",
    //         "",
    //         '        :log info "$logPrefix Certificate update process completed.";',
    //         "    }",
    //         "}",
    //         "",
    //         "# Script will now self-destruct (scheduler removal handled automatically)",
    //     ],
    // };

    // Create the Public Certificate Update script content 2 with retry mechanisms as RouterConfig
    // This version processes Google certificates FIRST, then cacert
    // const publicCertScriptContent2: RouterConfig = {
    //     "": [
    //         ":delay 30s",
    //         "# MikroTik RouterOS Public Certificate Authority Update Script",
    //         "# Version 1.0 - ONE TIME EXECUTION",
    //         ':log info "--- Starting Public Certificate Authority Update Script ---";',
    //         "# --- Configuration Variables ---",
    //         ':global logPrefix "CertUpdate:";',
    //         ':global googleCertFile "roots-goog.pem";',
    //         ':global googleCertUrl "https://pki.goog/roots.pem";',
    //         ':global importedGoogCertName "google-roots-public";',
    //         ':global cacertFile "cacert.pem";',
    //         ':global cacertUrl "https://curl.se/ca/cacert.pem";',
    //         ':global importedCaCertName "cacert-bundle-public";',
    //         ":global downloadDelaySec 10;",
    //         ":global importDelaySec 5;",
    //         ":global maxRetries 3;",
    //         ":global retryDelaySec 30;",
    //         "# --- End Configuration Variables ---",
    //         ':log info "$logPrefix Script started.";',
    //         "",
    //         "# 1. Download roots-goog.pem with retry mechanism",
    //         ':log info "$logPrefix Attempting to download $googleCertFile from $googleCertUrl...";',
    //         ":local retryCount 0;",
    //         ":local downloadSuccess false;",
    //         ":while ($retryCount < $maxRetries && $downloadSuccess = false) do={",
    //         "    :set retryCount ($retryCount + 1);",
    //         '    :log info "$logPrefix Download attempt $retryCount of $maxRetries for $googleCertFile...";',
    //         "    ",
    //         "    :do {",
    //         "        /tool fetch url=$googleCertUrl dst-path=$googleCertFile;",
    //         "        :delay 2s;",
    //         "        :if ([:len [/file find name=$googleCertFile]] > 0) do={",
    //         '            :log info "$logPrefix Successfully downloaded $googleCertFile on attempt $retryCount.";',
    //         "            :set downloadSuccess true;",
    //         "        } else={",
    //         '            :log warning "$logPrefix Download attempt $retryCount failed - file not found after fetch.";',
    //         "            :if ($retryCount < $maxRetries) do={",
    //         '                :log info "$logPrefix Waiting $retryDelaySec seconds before retry...";',
    //         "                :delay $retryDelaySec;",
    //         "            }",
    //         "        }",
    //         "    } on-error={",
    //         '        :log warning "$logPrefix Download attempt $retryCount failed with error.";',
    //         "        :if ($retryCount < $maxRetries) do={",
    //         '            :log info "$logPrefix Waiting $retryDelaySec seconds before retry...";',
    //         "            :delay $retryDelaySec;",
    //         "        }",
    //         "    }",
    //         "}",
    //         ":if ($downloadSuccess = false) do={",
    //         '    :log error "$logPrefix Failed to download $googleCertFile after $maxRetries attempts. Exiting.";',
    //         "} else={",
    //         '    :log info "$logPrefix Waiting $downloadDelaySec seconds after downloading $googleCertFile...";',
    //         "    :delay $downloadDelaySec;",
    //         "}",
    //         "",
    //         "# 2. Download cacert.pem with retry mechanism",
    //         ":if ($downloadSuccess = true) do={",
    //         '    :log info "$logPrefix Attempting to download $cacertFile from $cacertUrl...";',
    //         "    :set retryCount 0;",
    //         "    :set downloadSuccess false;",
    //         "    :while ($retryCount < $maxRetries && $downloadSuccess = false) do={",
    //         "        :set retryCount ($retryCount + 1);",
    //         '        :log info "$logPrefix Download attempt $retryCount of $maxRetries for $cacertFile...";',
    //         "        ",
    //         "        :do {",
    //         "            /tool fetch url=$cacertUrl dst-path=$cacertFile;",
    //         "            :delay 2s;",
    //         "            :if ([:len [/file find name=$cacertFile]] > 0) do={",
    //         '                :log info "$logPrefix Successfully downloaded $cacertFile on attempt $retryCount.";',
    //         "                :set downloadSuccess true;",
    //         "            } else={",
    //         '                :log warning "$logPrefix Download attempt $retryCount failed - file not found after fetch.";',
    //         "                :if ($retryCount < $maxRetries) do={",
    //         '                    :log info "$logPrefix Waiting $retryDelaySec seconds before retry...";',
    //         "                    :delay $retryDelaySec;",
    //         "                }",
    //         "            }",
    //         "        } on-error={",
    //         '            :log warning "$logPrefix Download attempt $retryCount failed with error.";',
    //         "            :if ($retryCount < $maxRetries) do={",
    //         '                :log info "$logPrefix Waiting $retryDelaySec seconds before retry...";',
    //         "                :delay $retryDelaySec;",
    //         "            }",
    //         "        }",
    //         "    }",
    //         "    :if ($downloadSuccess = false) do={",
    //         '        :log error "$logPrefix Failed to download $cacertFile after $maxRetries attempts. Continuing with available files...";',
    //         "    } else={",
    //         '        :log info "$logPrefix Waiting $downloadDelaySec seconds after downloading $cacertFile...";',
    //         "        :delay $downloadDelaySec;",
    //         "    }",
    //         "}",
    //         "",
    //         "# 3. Import roots-goog.pem with retry mechanism",
    //         ':log info "$logPrefix Processing $googleCertFile for import as $importedGoogCertName...";',
    //         ":if ([:len [/file find name=$googleCertFile]] > 0) do={",
    //         '    :log info "$logPrefix Found $googleCertFile. Attempting to import as $importedGoogCertName.";',
    //         "    ",
    //         "    # Remove existing certificate with the target name, if any",
    //         "    :local existingGoogCert [/certificate find name=$importedGoogCertName];",
    //         "    :if ([:len $existingGoogCert] > 0) do={",
    //         "        /certificate remove $existingGoogCert;",
    //         '        :log info "$logPrefix Removed existing certificate(s) named $importedGoogCertName.";',
    //         "    }",
    //         "    ",
    //         "    # Import with retry mechanism",
    //         "    :set retryCount 0;",
    //         "    :local importSuccess false;",
    //         "    :while ($retryCount < $maxRetries && $importSuccess = false) do={",
    //         "        :set retryCount ($retryCount + 1);",
    //         '        :log info "$logPrefix Import attempt $retryCount of $maxRetries for $googleCertFile...";',
    //         "        ",
    //         "        :do {",
    //         '            /certificate import file-name=$googleCertFile name=$importedGoogCertName trusted=yes passphrase="";',
    //         "            :delay 2s;",
    //         "            # Verify import",
    //         "            :if ([:len [/certificate find name=$importedGoogCertName trusted=yes]] > 0) do={",
    //         '                :log info "$logPrefix Successfully imported $googleCertFile as $importedGoogCertName on attempt $retryCount.";',
    //         "                :set importSuccess true;",
    //         "            } else={",
    //         '                :log warning "$logPrefix Import attempt $retryCount failed - certificate not found or not trusted.";',
    //         "                :if ($retryCount < $maxRetries) do={",
    //         "                    :delay 5s;",
    //         "                }",
    //         "            }",
    //         "        } on-error={",
    //         '            :log warning "$logPrefix Import attempt $retryCount failed with error.";',
    //         "            :if ($retryCount < $maxRetries) do={",
    //         "                :delay 5s;",
    //         "            }",
    //         "        }",
    //         "    }",
    //         "    :if ($importSuccess = false) do={",
    //         '        :log error "$logPrefix Failed to import $googleCertFile after $maxRetries attempts.";',
    //         "    }",
    //         "} else={",
    //         '    :log error "$logPrefix $googleCertFile not found. Skipping import.";',
    //         "}",
    //         ':log info "$logPrefix Waiting $importDelaySec seconds after importing $googleCertFile...";',
    //         ":delay $importDelaySec;",
    //         "",
    //         "# 4. Import cacert.pem with retry mechanism",
    //         ':log info "$logPrefix Processing $cacertFile for import as $importedCaCertName...";',
    //         ":if ([:len [/file find name=$cacertFile]] > 0) do={",
    //         '    :log info "$logPrefix Found $cacertFile. Attempting to import as $importedCaCertName.";',
    //         "    ",
    //         "    # Remove existing certificate with the target name, if any",
    //         "    :local existingCaCert [/certificate find name=$importedCaCertName];",
    //         "    :if ([:len $existingCaCert] > 0) do={",
    //         "        /certificate remove $existingCaCert;",
    //         '        :log info "$logPrefix Removed existing certificate(s) named $importedCaCertName.";',
    //         "    }",
    //         "    ",
    //         "    # Import with retry mechanism",
    //         "    :set retryCount 0;",
    //         "    :local importSuccess false;",
    //         "    :while ($retryCount < $maxRetries && $importSuccess = false) do={",
    //         "        :set retryCount ($retryCount + 1);",
    //         '        :log info "$logPrefix Import attempt $retryCount of $maxRetries for $cacertFile...";',
    //         "        ",
    //         "        :do {",
    //         '            /certificate import file-name=$cacertFile name=$importedCaCertName passphrase="" trusted=yes;',
    //         "            :delay 2s;",
    //         "            # Verify import",
    //         "            :if ([:len [/certificate find name=$importedCaCertName trusted=yes]] > 0) do={",
    //         '                :log info "$logPrefix Successfully imported $cacertFile as $importedCaCertName on attempt $retryCount.";',
    //         "                :set importSuccess true;",
    //         "            } else={",
    //         '                :log warning "$logPrefix Import attempt $retryCount failed - certificate not found or not trusted.";',
    //         "                :if ($retryCount < $maxRetries) do={",
    //         "                    :delay 5s;",
    //         "                }",
    //         "            }",
    //         "        } on-error={",
    //         '            :log warning "$logPrefix Import attempt $retryCount failed with error.";',
    //         "            :if ($retryCount < $maxRetries) do={",
    //         "                :delay 5s;",
    //         "            }",
    //         "        }",
    //         "    }",
    //         "    :if ($importSuccess = false) do={",
    //         '        :log error "$logPrefix Failed to import $cacertFile after $maxRetries attempts.";',
    //         "    }",
    //         "} else={",
    //         '    :log error "$logPrefix $cacertFile not found. Skipping import.";',
    //         "}",
    //         ':log info "$logPrefix Waiting $importDelaySec seconds after importing $cacertFile...";',
    //         ":delay $importDelaySec;",
    //         "",
    //         "# 5. Post-Operation Cleanup",
    //         ':log info "$logPrefix Performing post-operation cleanup...";',
    //         ":if ([:len [/file find name=$googleCertFile]] > 0) do={",
    //         "    /file remove $googleCertFile;",
    //         '    :log info "$logPrefix Removed temporary file $googleCertFile.";',
    //         "}",
    //         ":if ([:len [/file find name=$cacertFile]] > 0) do={",
    //         "    /file remove $cacertFile;",
    //         '    :log info "$logPrefix Removed temporary file $cacertFile.";',
    //         "}",
    //         ':log info "$logPrefix Certificate update process completed.";',
    //         "",
    //         "# Script will now self-destruct (scheduler removal handled automatically)",
    //         "/system scheduler",
    //         "remove [find name=Public-Cert-Update];",
    //     ],
    // };

    const publicCertScriptContent2: RouterConfig = {
        "": [
            ":delay 30s",
            "# MikroTik RouterOS Public Certificate Authority Update Script",
            "# Version 1.6 - ONE TIME EXECUTION",
            "# Fixed: Handles corrupted downloads and re-downloads if import fails",
            ':log info "========================================";',
            ':log info "CERTIFICATE UPDATE SCRIPT v1.6 STARTING";',
            ':log info "========================================";',
            ':log info ("Script initialized at: " . [/system clock get time] . " on " . [/system clock get date]);',
            "",
            "# --- Configuration Variables ---",
            ':global logPrefix "CertUpdate:";',
            "",
            "# Certificate 1: Google Roots",
            ':global googleCertFile "roots-goog.pem";',
            ':global googleCertUrl "https://pki.goog/roots.pem";',
            ':global importedGoogCertName "google-roots-public";',
            "",
            "# Certificate 2: CA Bundle",
            ':global cacertFile "cacert.pem";',
            ':global cacertUrl "https://curl.se/ca/cacert.pem";',
            ':global importedCaCertName "cacert-bundle-public";',
            "",
            "# Certificate 3: NASnet Community Bundle",
            ':global nasnetCertFile "certificate-bundle.pem";',
            ':global nasnetCertUrl "https://github.com/nasnet-community/certs/releases/download/latest/certificate-bundle.pem";',
            ':global importedNasnetCertName "certificate-bundle-public";',
            "",
            "# Timing Variables (in seconds)",
            ":global downloadRetryDelaySec 5;",
            ":global importRetryDelaySec 5;",
            ":global postDownloadDelaySec 5;",
            ":global postImportDelaySec 5;",
            ":global betweenCertDelaySec 5;",
            ":global verifyDelaySec 3;",
            ":global cleanupDelaySec 2;",
            ":global maxImportRetriesBeforeRedownload 5;",
            "",
            "# Statistics Variables",
            ":global totalDownloads 0;",
            ":global totalImports 0;",
            ":global totalRetries 0;",
            ":global successfulCerts 0;",
            "",
            "# --- End Configuration Variables ---",
            "",
            ':log info "$logPrefix Configuration loaded successfully";',
            ':log info "$logPrefix Certificates to process: 3 (Google Roots, CA Bundle, NASnet Community Bundle)";',
            ':log info ("$logPrefix Timing: Download retry: " . $downloadRetryDelaySec . "s | Import retry: " . $importRetryDelaySec . "s");',
            ':log info ("$logPrefix Max import attempts before re-download: " . $maxImportRetriesBeforeRedownload);',
            "",
            "# Log initial system status",
            ':log info "----------------------------------------";',
            ':log info "$logPrefix INITIAL SYSTEM CHECK";',
            ':log info "----------------------------------------";',
            ":local freeMemory [/system resource get free-memory];",
            ":local cpuLoad [/system resource get cpu-load];",
            ":local uptime [/system resource get uptime];",
            ':log info ("SYSTEM STATUS: Free Memory: " . ($freeMemory/1048576) . "MB | CPU Load: " . $cpuLoad . "% | Uptime: " . $uptime);',
            "",
            "# Check for existing certificates",
            ':log info "----------------------------------------";',
            ':log info "$logPrefix CHECKING EXISTING CERTIFICATES";',
            ':log info "----------------------------------------";',
            ":local existingCount 0;",
            ":if ([:len [/certificate find name=$importedGoogCertName]] > 0) do={",
            '    :log warning "$logPrefix Found existing: $importedGoogCertName (will be replaced)";',
            "    :set existingCount ($existingCount + 1);",
            "}",
            ":if ([:len [/certificate find name=$importedCaCertName]] > 0) do={",
            '    :log warning "$logPrefix Found existing: $importedCaCertName (will be replaced)";',
            "    :set existingCount ($existingCount + 1);",
            "}",
            ":if ([:len [/certificate find name=$importedNasnetCertName]] > 0) do={",
            '    :log warning "$logPrefix Found existing: $importedNasnetCertName (will be replaced)";',
            "    :set existingCount ($existingCount + 1);",
            "}",
            "",
            ":if ($existingCount = 0) do={",
            '    :log info "$logPrefix No existing certificates found - clean installation";',
            "} else={",
            '    :log info ("$logPrefix Found " . $existingCount . " existing certificate(s) to replace");',
            "}",
            "",
            ':log info "----------------------------------------";',
            ':log info "$logPrefix STARTING CERTIFICATE PROCESSING";',
            ':log info "----------------------------------------";',
            "",
            "# ==========================================",
            "# CERTIFICATE 1: GOOGLE ROOTS",
            "# ==========================================",
            ':log info "========================================";',
            ':log info "$logPrefix CERTIFICATE 1/2: GOOGLE ROOTS";',
            ':log info "========================================";',
            "",
            ":local cert1Success false;",
            ":local downloadAttempts 0;",
            "",
            ":while ($cert1Success = false) do={",
            "    :set downloadAttempts ($downloadAttempts + 1);",
            '    :log info ("$logPrefix [PROCESS] Starting attempt " . $downloadAttempts . " for Google Roots certificate");',
            "    ",
            "    # Download Google Roots",
            '    :log info "$logPrefix [DOWNLOAD] Starting download phase for Google Roots";',
            '    :log info "$logPrefix [DOWNLOAD] URL: $googleCertUrl";',
            '    :log info "$logPrefix [DOWNLOAD] Target file: $googleCertFile";',
            "    ",
            "    # Clean up any existing file before download",
            "    :if ([:len [/file find name=$googleCertFile]] > 0) do={",
            "        /file remove $googleCertFile;",
            '        :log info "$logPrefix [CLEANUP] Removed existing file before download";',
            "        :delay $cleanupDelaySec;",
            "    }",
            "    ",
            "    :local downloadRetryCount 0;",
            "    :local downloadSuccess false;",
            "    ",
            "    :while ($downloadSuccess = false) do={",
            "        :set downloadRetryCount ($downloadRetryCount + 1);",
            "        :set totalRetries ($totalRetries + 1);",
            '        :log info ("$logPrefix [DOWNLOAD] Attempt " . $downloadRetryCount . " for " . $googleCertFile . "...");',
            "        ",
            "        :do {",
            "            /tool fetch url=$googleCertUrl dst-path=$googleCertFile check-certificate=no ;",
            "            :delay $verifyDelaySec;",
            "            ",
            "            :if ([:len [/file find name=$googleCertFile]] > 0) do={",
            "                :local fileSize [/file get $googleCertFile size];",
            "                :if ($fileSize > 1024) do={",
            '                    :log info ("$logPrefix [DOWNLOAD SUCCESS] " . $googleCertFile . " downloaded (Size: " . ($fileSize/1024) . "KB)");',
            "                    :set downloadSuccess true;",
            "                    :set totalDownloads ($totalDownloads + 1);",
            "                } else={",
            '                    :log error ("$logPrefix [DOWNLOAD WARNING] File size too small: " . $fileSize . " bytes");',
            "                    /file remove $googleCertFile;",
            "                    :delay $cleanupDelaySec;",
            '                    :log warning ("$logPrefix [DOWNLOAD] Retrying in " . $downloadRetryDelaySec . " seconds...");',
            "                    :delay $downloadRetryDelaySec;",
            "                }",
            "            } else={",
            '                :log error ("$logPrefix [DOWNLOAD FAILED] Attempt " . $downloadRetryCount . " - File not found after fetch");',
            '                :log warning ("$logPrefix [DOWNLOAD] Retrying in " . $downloadRetryDelaySec . " seconds...");',
            "                :delay $downloadRetryDelaySec;",
            "            }",
            "        } on-error={",
            '            :log error ("$logPrefix [DOWNLOAD ERROR] Attempt " . $downloadRetryCount . " - Network/system error");',
            '            :log warning ("$logPrefix [DOWNLOAD] Retrying in " . $downloadRetryDelaySec . " seconds...");',
            "            :delay $downloadRetryDelaySec;",
            "        }",
            "    }",
            "    ",
            '    :log info ("$logPrefix [TRANSITION] Download complete, waiting " . $postDownloadDelaySec . " seconds before import...");',
            "    :delay $postDownloadDelaySec;",
            "    ",
            "    # Import Google Roots",
            '    :log info "$logPrefix [IMPORT] Starting import phase for Google Roots";',
            "    ",
            "    :if ([:len [/file find name=$googleCertFile]] > 0) do={",
            "        :local fileSize [/file get $googleCertFile size];",
            '        :log info ("$logPrefix [IMPORT] File verified: " . $googleCertFile . " (" . ($fileSize/1024) . "KB)");',
            "        ",
            "        :local existingCert [/certificate find name=$importedGoogCertName];",
            "        :if ([:len $existingCert] > 0) do={",
            "            /certificate remove $existingCert;",
            '            :log warning "$logPrefix [IMPORT CLEANUP] Removed existing certificate: $importedGoogCertName";',
            "        }",
            "        ",
            "        :local importRetryCount 0;",
            "        :local importSuccess false;",
            "        ",
            "        :while (($importSuccess = false) && ($importRetryCount < $maxImportRetriesBeforeRedownload)) do={",
            "            :set importRetryCount ($importRetryCount + 1);",
            "            :set totalRetries ($totalRetries + 1);",
            '            :log info ("$logPrefix [IMPORT] Attempt " . $importRetryCount . "/" . $maxImportRetriesBeforeRedownload . " for " . $importedGoogCertName . "...");',
            "            ",
            "            :do {",
            '                /certificate import file-name=$googleCertFile name=$importedGoogCertName passphrase="" trusted=yes;',
            "                :delay $verifyDelaySec;",
            "                ",
            "                :local certCount [:len [/certificate find name=$importedGoogCertName trusted=yes]];",
            "                :if ($certCount > 0) do={",
            '                    :log info "$logPrefix [IMPORT SUCCESS] Certificate installed: $importedGoogCertName";',
            '                    :log info ("$logPrefix [IMPORT] Certificates in bundle: " . $certCount);',
            "                    :set importSuccess true;",
            "                    :set totalImports ($totalImports + 1);",
            "                    :set successfulCerts ($successfulCerts + 1);",
            "                    :set cert1Success true;",
            "                } else={",
            '                    :log error ("$logPrefix [IMPORT FAILED] Attempt " . $importRetryCount . " - Certificate not trusted");',
            '                    :log warning ("$logPrefix [IMPORT] Retrying in " . $importRetryDelaySec . " seconds...");',
            "                    :delay $importRetryDelaySec;",
            "                }",
            "            } on-error={",
            '                :log error ("$logPrefix [IMPORT ERROR] Attempt " . $importRetryCount . " - Import operation failed");',
            '                :log warning ("$logPrefix [IMPORT] Retrying in " . $importRetryDelaySec . " seconds...");',
            "                :delay $importRetryDelaySec;",
            "            }",
            "        }",
            "        ",
            "        :if ($importSuccess = true) do={",
            '            :log info "$logPrefix [CLEANUP] Removing temporary file: $googleCertFile";',
            "            /file remove $googleCertFile;",
            "            :delay $cleanupDelaySec;",
            "        } else={",
            '            :log error "$logPrefix [IMPORT FAILED] Max import attempts reached, will re-download";',
            "            /file remove $googleCertFile;",
            "            :delay $cleanupDelaySec;",
            "        }",
            "    }",
            "}",
            "",
            ':log info "$logPrefix [COMPLETE] Certificate 1 processed successfully";',
            ':log info ("$logPrefix [COMPLETE] Waiting " . $betweenCertDelaySec . " seconds before next certificate...");',
            ":delay $betweenCertDelaySec;",
            "",
            "# ==========================================",
            "# CERTIFICATE 2: CA BUNDLE",
            "# ==========================================",
            ':log info "========================================";',
            ':log info "$logPrefix CERTIFICATE 2/2: CA BUNDLE";',
            ':log info "========================================";',
            "",
            ":local cert2Success false;",
            ":set downloadAttempts 0;",
            "",
            ":while ($cert2Success = false) do={",
            "    :set downloadAttempts ($downloadAttempts + 1);",
            '    :log info ("$logPrefix [PROCESS] Starting attempt " . $downloadAttempts . " for CA Bundle certificate");',
            "    ",
            "    # Download CA Bundle",
            '    :log info "$logPrefix [DOWNLOAD] Starting download phase for CA Bundle";',
            '    :log info "$logPrefix [DOWNLOAD] URL: $cacertUrl";',
            '    :log info "$logPrefix [DOWNLOAD] Target file: $cacertFile";',
            "    ",
            "    # Clean up any existing file before download",
            "    :if ([:len [/file find name=$cacertFile]] > 0) do={",
            "        /file remove $cacertFile;",
            '        :log info "$logPrefix [CLEANUP] Removed existing file before download";',
            "        :delay $cleanupDelaySec;",
            "    }",
            "    ",
            "    :local downloadRetryCount 0;",
            "    :local downloadSuccess false;",
            "    ",
            "    :while ($downloadSuccess = false) do={",
            "        :set downloadRetryCount ($downloadRetryCount + 1);",
            "        :set totalRetries ($totalRetries + 1);",
            '        :log info ("$logPrefix [DOWNLOAD] Attempt " . $downloadRetryCount . " for " . $cacertFile . "...");',
            "        ",
            "        :do {",
            "            /tool fetch url=$cacertUrl dst-path=$cacertFile check-certificate=no ;",
            "            :delay $verifyDelaySec;",
            "            ",
            "            :if ([:len [/file find name=$cacertFile]] > 0) do={",
            "                :local fileSize [/file get $cacertFile size];",
            "                :if ($fileSize > 1024) do={",
            '                    :log info ("$logPrefix [DOWNLOAD SUCCESS] " . $cacertFile . " downloaded (Size: " . ($fileSize/1024) . "KB)");',
            "                    :set downloadSuccess true;",
            "                    :set totalDownloads ($totalDownloads + 1);",
            "                } else={",
            '                    :log error ("$logPrefix [DOWNLOAD WARNING] File size too small: " . $fileSize . " bytes");',
            "                    /file remove $cacertFile;",
            "                    :delay $cleanupDelaySec;",
            '                    :log warning ("$logPrefix [DOWNLOAD] Retrying in " . $downloadRetryDelaySec . " seconds...");',
            "                    :delay $downloadRetryDelaySec;",
            "                }",
            "            } else={",
            '                :log error ("$logPrefix [DOWNLOAD FAILED] Attempt " . $downloadRetryCount . " - File not found after fetch");',
            '                :log warning ("$logPrefix [DOWNLOAD] Retrying in " . $downloadRetryDelaySec . " seconds...");',
            "                :delay $downloadRetryDelaySec;",
            "            }",
            "        } on-error={",
            '            :log error ("$logPrefix [DOWNLOAD ERROR] Attempt " . $downloadRetryCount . " - Network/system error");',
            '            :log warning ("$logPrefix [DOWNLOAD] Retrying in " . $downloadRetryDelaySec . " seconds...");',
            "            :delay $downloadRetryDelaySec;",
            "        }",
            "    }",
            "    ",
            '    :log info ("$logPrefix [TRANSITION] Download complete, waiting " . $postDownloadDelaySec . " seconds before import...");',
            "    :delay $postDownloadDelaySec;",
            "    ",
            "    # Import CA Bundle",
            '    :log info "$logPrefix [IMPORT] Starting import phase for CA Bundle";',
            "    ",
            "    :if ([:len [/file find name=$cacertFile]] > 0) do={",
            "        :local fileSize [/file get $cacertFile size];",
            '        :log info ("$logPrefix [IMPORT] File verified: " . $cacertFile . " (" . ($fileSize/1024) . "KB)");',
            "        ",
            "        :local existingCert [/certificate find name=$importedCaCertName];",
            "        :if ([:len $existingCert] > 0) do={",
            "            /certificate remove $existingCert;",
            '            :log warning "$logPrefix [IMPORT CLEANUP] Removed existing certificate: $importedCaCertName";',
            "        }",
            "        ",
            "        :local importRetryCount 0;",
            "        :local importSuccess false;",
            "        ",
            "        :while (($importSuccess = false) && ($importRetryCount < $maxImportRetriesBeforeRedownload)) do={",
            "            :set importRetryCount ($importRetryCount + 1);",
            "            :set totalRetries ($totalRetries + 1);",
            '            :log info ("$logPrefix [IMPORT] Attempt " . $importRetryCount . "/" . $maxImportRetriesBeforeRedownload . " for " . $importedCaCertName . "...");',
            "            ",
            "            :do {",
            '                /certificate import file-name=$cacertFile name=$importedCaCertName passphrase="" trusted=yes;',
            "                :delay $verifyDelaySec;",
            "                ",
            "                :local certCount [:len [/certificate find name=$importedCaCertName trusted=yes]];",
            "                :if ($certCount > 0) do={",
            '                    :log info "$logPrefix [IMPORT SUCCESS] Certificate installed: $importedCaCertName";',
            '                    :log info ("$logPrefix [IMPORT] Certificates in bundle: " . $certCount);',
            "                    :set importSuccess true;",
            "                    :set totalImports ($totalImports + 1);",
            "                    :set successfulCerts ($successfulCerts + 1);",
            "                    :set cert2Success true;",
            "                } else={",
            '                    :log error ("$logPrefix [IMPORT FAILED] Attempt " . $importRetryCount . " - Certificate not trusted");',
            '                    :log warning ("$logPrefix [IMPORT] Retrying in " . $importRetryDelaySec . " seconds...");',
            "                    :delay $importRetryDelaySec;",
            "                }",
            "            } on-error={",
            '                :log error ("$logPrefix [IMPORT ERROR] Attempt " . $importRetryCount . " - Import operation failed");',
            '                :log warning ("$logPrefix [IMPORT] Retrying in " . $importRetryDelaySec . " seconds...");',
            "                :delay $importRetryDelaySec;",
            "            }",
            "        }",
            "        ",
            "        :if ($importSuccess = true) do={",
            '            :log info "$logPrefix [CLEANUP] Removing temporary file: $cacertFile";',
            "            /file remove $cacertFile;",
            "            :delay $cleanupDelaySec;",
            "        } else={",
            '            :log error "$logPrefix [IMPORT FAILED] Max import attempts reached, will re-download";',
            "            /file remove $cacertFile;",
            "            :delay $cleanupDelaySec;",
            "        }",
            "    }",
            "}",
            "",
            ':log info "$logPrefix [COMPLETE] Certificate 2 processed successfully";',
            ':log info ("$logPrefix [COMPLETE] Waiting " . $betweenCertDelaySec . " seconds before next certificate...");',
            ":delay $betweenCertDelaySec;",
            "",
            "# ==========================================",
            "# CERTIFICATE 3: NASNET COMMUNITY BUNDLE",
            "# ==========================================",
            ':log info "========================================";',
            ':log info "$logPrefix CERTIFICATE 3/3: NASNET COMMUNITY BUNDLE";',
            ':log info "========================================";',
            "",
            ":local cert3Success false;",
            ":set downloadAttempts 0;",
            "",
            ":while ($cert3Success = false) do={",
            "    :set downloadAttempts ($downloadAttempts + 1);",
            '    :log info ("$logPrefix [PROCESS] Starting attempt " . $downloadAttempts . " for NASnet Community Bundle certificate");',
            "    ",
            "    # Download NASnet Community Bundle",
            '    :log info "$logPrefix [DOWNLOAD] Starting download phase for NASnet Community Bundle";',
            '    :log info "$logPrefix [DOWNLOAD] URL: $nasnetCertUrl";',
            '    :log info "$logPrefix [DOWNLOAD] Target file: $nasnetCertFile";',
            "    ",
            "    # Clean up any existing file before download",
            "    :if ([:len [/file find name=$nasnetCertFile]] > 0) do={",
            "        /file remove $nasnetCertFile;",
            '        :log info "$logPrefix [CLEANUP] Removed existing file before download";',
            "        :delay $cleanupDelaySec;",
            "    }",
            "    ",
            "    :local downloadRetryCount 0;",
            "    :local downloadSuccess false;",
            "    ",
            "    :while ($downloadSuccess = false) do={",
            "        :set downloadRetryCount ($downloadRetryCount + 1);",
            "        :set totalRetries ($totalRetries + 1);",
            '        :log info ("$logPrefix [DOWNLOAD] Attempt " . $downloadRetryCount . " for " . $nasnetCertFile . "...");',
            "        ",
            "        :do {",
            "            /tool fetch url=$nasnetCertUrl dst-path=$nasnetCertFile check-certificate=no http-max-redirect-count=10 ;",
            "            :delay $verifyDelaySec;",
            "            ",
            "            :if ([:len [/file find name=$nasnetCertFile]] > 0) do={",
            "                :local fileSize [/file get $nasnetCertFile size];",
            "                :if ($fileSize > 1024) do={",
            '                    :log info ("$logPrefix [DOWNLOAD SUCCESS] " . $nasnetCertFile . " downloaded (Size: " . ($fileSize/1024) . "KB)");',
            "                    :set downloadSuccess true;",
            "                    :set totalDownloads ($totalDownloads + 1);",
            "                } else={",
            '                    :log error ("$logPrefix [DOWNLOAD WARNING] File size too small: " . $fileSize . " bytes");',
            "                    /file remove $nasnetCertFile;",
            "                    :delay $cleanupDelaySec;",
            '                    :log warning ("$logPrefix [DOWNLOAD] Retrying in " . $downloadRetryDelaySec . " seconds...");',
            "                    :delay $downloadRetryDelaySec;",
            "                }",
            "            } else={",
            '                :log error ("$logPrefix [DOWNLOAD FAILED] Attempt " . $downloadRetryCount . " - File not found after fetch");',
            '                :log warning ("$logPrefix [DOWNLOAD] Retrying in " . $downloadRetryDelaySec . " seconds...");',
            "                :delay $downloadRetryDelaySec;",
            "            }",
            "        } on-error={",
            '            :log error ("$logPrefix [DOWNLOAD ERROR] Attempt " . $downloadRetryCount . " - Network/system error");',
            '            :log warning ("$logPrefix [DOWNLOAD] Retrying in " . $downloadRetryDelaySec . " seconds...");',
            "            :delay $downloadRetryDelaySec;",
            "        }",
            "    }",
            "    ",
            '    :log info ("$logPrefix [TRANSITION] Download complete, waiting " . $postDownloadDelaySec . " seconds before import...");',
            "    :delay $postDownloadDelaySec;",
            "    ",
            "    # Import NASnet Community Bundle",
            '    :log info "$logPrefix [IMPORT] Starting import phase for NASnet Community Bundle";',
            "    ",
            "    :if ([:len [/file find name=$nasnetCertFile]] > 0) do={",
            "        :local fileSize [/file get $nasnetCertFile size];",
            '        :log info ("$logPrefix [IMPORT] File verified: " . $nasnetCertFile . " (" . ($fileSize/1024) . "KB)");',
            "        ",
            "        :local existingCert [/certificate find name=$importedNasnetCertName];",
            "        :if ([:len $existingCert] > 0) do={",
            "            /certificate remove $existingCert;",
            '            :log warning "$logPrefix [IMPORT CLEANUP] Removed existing certificate: $importedNasnetCertName";',
            "        }",
            "        ",
            "        :local importRetryCount 0;",
            "        :local importSuccess false;",
            "        ",
            "        :while (($importSuccess = false) && ($importRetryCount < $maxImportRetriesBeforeRedownload)) do={",
            "            :set importRetryCount ($importRetryCount + 1);",
            "            :set totalRetries ($totalRetries + 1);",
            '            :log info ("$logPrefix [IMPORT] Attempt " . $importRetryCount . "/" . $maxImportRetriesBeforeRedownload . " for " . $importedNasnetCertName . "...");',
            "            ",
            "            :do {",
            '                /certificate import file-name=$nasnetCertFile name=$importedNasnetCertName passphrase="" trusted=yes;',
            "                :delay $verifyDelaySec;",
            "                ",
            "                :local certCount [:len [/certificate find name=$importedNasnetCertName trusted=yes]];",
            "                :if ($certCount > 0) do={",
            '                    :log info "$logPrefix [IMPORT SUCCESS] Certificate installed: $importedNasnetCertName";',
            '                    :log info ("$logPrefix [IMPORT] Certificates in bundle: " . $certCount);',
            "                    :set importSuccess true;",
            "                    :set totalImports ($totalImports + 1);",
            "                    :set successfulCerts ($successfulCerts + 1);",
            "                    :set cert3Success true;",
            "                } else={",
            '                    :log error ("$logPrefix [IMPORT FAILED] Attempt " . $importRetryCount . " - Certificate not trusted");',
            '                    :log warning ("$logPrefix [IMPORT] Retrying in " . $importRetryDelaySec . " seconds...");',
            "                    :delay $importRetryDelaySec;",
            "                }",
            "            } on-error={",
            '                :log error ("$logPrefix [IMPORT ERROR] Attempt " . $importRetryCount . " - Import operation failed");',
            '                :log warning ("$logPrefix [IMPORT] Retrying in " . $importRetryDelaySec . " seconds...");',
            "                :delay $importRetryDelaySec;",
            "            }",
            "        }",
            "        ",
            "        :if ($importSuccess = true) do={",
            '            :log info "$logPrefix [CLEANUP] Removing temporary file: $nasnetCertFile";',
            "            /file remove $nasnetCertFile;",
            "            :delay $cleanupDelaySec;",
            "        } else={",
            '            :log error "$logPrefix [IMPORT FAILED] Max import attempts reached, will re-download";',
            "            /file remove $nasnetCertFile;",
            "            :delay $cleanupDelaySec;",
            "        }",
            "    }",
            "}",
            "",
            ':log info "$logPrefix [COMPLETE] Certificate 3 processed successfully";',
            ':log info ("$logPrefix [COMPLETE] Waiting " . $betweenCertDelaySec . " seconds before final verification...");',
            ":delay $betweenCertDelaySec;",
            "",
            "",
            "# ==========================================",
            "# FINAL VERIFICATION",
            "# ==========================================",
            ':log info "========================================";',
            ':log info "$logPrefix FINAL VERIFICATION";',
            ':log info "========================================";',
            "",
            ":local verifiedCount 0;",
            ":if ([:len [/certificate find name=$importedGoogCertName trusted=yes]] > 0) do={",
            '    :log info "$logPrefix [VERIFIED] $importedGoogCertName is installed and trusted";',
            "    :set verifiedCount ($verifiedCount + 1);",
            "} else={",
            '    :log error "$logPrefix [MISSING] $importedGoogCertName not found or not trusted";',
            "}",
            "",
            ":if ([:len [/certificate find name=$importedCaCertName trusted=yes]] > 0) do={",
            '    :log info "$logPrefix [VERIFIED] $importedCaCertName is installed and trusted";',
            "    :set verifiedCount ($verifiedCount + 1);",
            "} else={",
            '    :log error "$logPrefix [MISSING] $importedCaCertName not found or not trusted";',
            "}",
            "",
            ":if ([:len [/certificate find name=$importedNasnetCertName trusted=yes]] > 0) do={",
            '    :log info "$logPrefix [VERIFIED] $importedNasnetCertName is installed and trusted";',
            "    :set verifiedCount ($verifiedCount + 1);",
            "} else={",
            '    :log error "$logPrefix [MISSING] $importedNasnetCertName not found or not trusted";',
            "}",
            "",
            "",
            "",
            "# Final Status Report",
            ':log info "========================================";',
            ':log info "$logPrefix FINAL STATUS REPORT";',
            ':log info "========================================";',
            ':log info ("$logPrefix Script completed at: " . [/system clock get time] . " on " . [/system clock get date]);',
            ':log info ("$logPrefix Certificates processed: " . $successfulCerts . "/3");',
            ':log info ("$logPrefix Certificates verified: " . $verifiedCount . "/3");',
            ':log info ("$logPrefix Total downloads: " . $totalDownloads);',
            ':log info ("$logPrefix Total imports: " . $totalImports);',
            ':log info ("$logPrefix Total retry attempts: " . $totalRetries);',
            "",
            ":if ($verifiedCount = 3) do={",
            '    :log info "$logPrefix [RESULT: SUCCESS] All certificates installed and verified!";',
            "} else={",
            '    :log error ("$logPrefix [RESULT: WARNING] Only " . $verifiedCount . "/3 certificates verified");',
            "}",
            "",
            "# Log final system status",
            ':log info "----------------------------------------";',
            ":set freeMemory [/system resource get free-memory];",
            ":set cpuLoad [/system resource get cpu-load];",
            ":set uptime [/system resource get uptime];",
            ':log info ("SYSTEM STATUS: Free Memory: " . ($freeMemory/1048576) . "MB | CPU Load: " . $cpuLoad . "% | Uptime: " . $uptime);',
            ':log info "========================================";',
            ':log info "$logPrefix CERTIFICATE UPDATE COMPLETE";',
            ':log info "========================================";',
            "",
            "# Self-destruct scheduler entry",
            "/system scheduler remove [find name=Public-Cert-Update];",
        ],
    };

    // Use OneTimeScript to create a one-time script and scheduler
    const mainScript = OneTimeScript({
        ScriptContent: publicCertScriptContent2,
        name: "Public-Cert-Update",
        startTime: "startup",
    });

    // Create CRL download scheduler
    const crlDownloadContent: RouterConfig = {
        "": [
            ":delay 120s",
            "/certificate crl download"
        ]
    };

    const crlScheduler = SchedulerGenerator({
        Name: "CRL-Download-Startup",
        content: crlDownloadContent,
        startTime: "startup",
    });

    return mergeRouterConfigs(mainScript, crlScheduler);
};

export const PrivateCert = (
    keySize: number = 2048,
    daysValid: number = 3650,
): RouterConfig => {
    const privateCertScriptContent: RouterConfig = {
        "": [
            `:delay 30s`,
            "# MikroTik RouterOS Private CA and Server Certificate Setup Script",
            "# Version 3.0 - Enhanced error logging and diagnostics",
            "# Based on MikroTik documentation best practices with comprehensive error handling",
            "",
            "# Enhanced logging configuration",
            `:log info "=== PRIVATE CERTIFICATE SETUP STARTED ===";`,
            `:log info "Script Version: 3.0 - Enhanced Error Logging";`,
            `:log info "Timestamp: [/system clock get date] [/system clock get time]";`,
            `:log info "Router Identity: [/system identity get name]";`,
            "",
            "# Configuration Variables with validation",
            `:global "ROUTER_IDENTITY" [/system identity get name];`,
            `:if ([:len $"ROUTER_IDENTITY"] = 0) do={`,
            `    :log error "CRITICAL: Router identity is empty or not set";`,
            `    :put "ERROR: Router identity is empty. Please set router identity first.";`,
            `    :error "Router identity validation failed";`,
            `}`,
            `:global "CN_CA_NAME" ($"ROUTER_IDENTITY" . "-CA");`,
            `:global KEYSIZE ${keySize};`,
            `:global DAYSVALID ${daysValid};`,
            "",
            `:log info "Configuration validated successfully:";`,
            `:log info ("Router Identity: " . $"ROUTER_IDENTITY");`,
            `:log info ("CA Name: " . $"CN_CA_NAME");`,
            `:log info ("Key Size: " . $KEYSIZE . " bits");`,
            `:log info ("Validity Period: " . $DAYSVALID . " days");`,
            "",
            `:put ">>> Starting Enhanced CA/Server Certificate Setup...";`,
            `:put ("Router: " . $"ROUTER_IDENTITY");`,
            `:put ("CA Name: " . $"CN_CA_NAME");`,
            "",
            "# Step 1.1: Create Certificate Authority (CA)",
            `:put "--> Creating CA Template...";`,
            `:log info "STEP 1.1: Creating CA Certificate Template";`,
            `:do {`,
            `    # Check if CA template already exists`,
            `    :local existingCA [/certificate find name="CA-Template"];`,
            `    :if ([:len $existingCA] > 0) do={`,
            `        :log warning "CA-Template already exists, removing old template";`,
            `        :put "WARNING: Removing existing CA-Template";`,
            `        /certificate remove CA-Template;`,
            `        :delay 2s;`,
            `    }`,
            `    `,
            `    :log info ("Creating CA template with: CN=" . ($"ROUTER_IDENTITY" . "-CA") . ", KeySize=" . $KEYSIZE . ", Days=" . $DAYSVALID);`,
            `    /certificate add name=CA-Template common-name=($"ROUTER_IDENTITY". "-CA") \\`,
            `        key-usage=crl-sign,key-cert-sign days-valid=$DAYSVALID key-size=$KEYSIZE;`,
            `    :log info "CA template created successfully";`,
            `    :put " CA template created successfully";`,
            `} on-error={`,
            `    :local errorMsg "Failed to create CA template";`,
            `    :log error ($errorMsg . " - Check system resources and certificate limits");`,
            `    :put ("ERROR: " . $errorMsg);`,
            `    :put "Possible causes: Insufficient memory, invalid parameters, or system overload";`,
            `    :error $errorMsg;`,
            `}`,
            "",
            `:put ("--> Signing CA Certificate (". $"CN_CA_NAME". ")...");`,
            `:log info "STEP 1.2: Signing CA Certificate";`,
            `:do {`,
            `    # Use localhost for CRL host`,
            `    :local crlHost "127.0.0.1";`,
            `    `,
            `    :log info ("Signing CA certificate: " . $"CN_CA_NAME" . " with CRL host: " . $crlHost);`,
            `    /certificate sign CA-Template name=$"CN_CA_NAME" ca-crl-host=$crlHost;`,
            `    :log info "CA certificate signing initiated, waiting for completion...";`,
            `    :delay 5s;`,
            `    `,
            `    # Verify CA certificate was created`,
            `    :local caCert [/certificate find name=$"CN_CA_NAME"];`,
            `    :if ([:len $caCert] = 0) do={`,
            `        :log error "CRITICAL: CA certificate was not created after signing";`,
            `        :error "CA certificate creation failed";`,
            `    }`,
            `    `,
            `    /certificate set [find name=$"CN_CA_NAME"] trusted=yes;`,
            `    :log info ("CA Certificate '" . $"CN_CA_NAME" . "' created and set as trusted");`,
            `    :put (" CA Certificate '" . $"CN_CA_NAME" . "' created and trusted");`,
            `} on-error={`,
            `    :local errorMsg "Failed to sign or trust CA certificate";`,
            `    :log error ($errorMsg . " - Check certificate template and system status");`,
            `    :put ("ERROR: " . $errorMsg);`,
            `    :put "Possible causes: Template missing, insufficient resources, or signing failure";`,
            `    :put "Check: /certificate print detail where name=CA-Template";`,
            `    :error $errorMsg;`,
            `}`,
            "",
            "# Step 1.3: Create Server Certificate",
            `:put "--> Creating Server Certificate Template...";`,
            `:log info "STEP 1.3: Creating Server Certificate Template";`,
            `:do {`,
            `    :local serverCertCN ("Server@". $"CN_CA_NAME");`,
            `    `,
            `    # Check if server template already exists`,
            `    :local existingServer [/certificate find name="Server-Template"];`,
            `    :if ([:len $existingServer] > 0) do={`,
            `        :log warning "Server-Template already exists, removing old template";`,
            `        :put "WARNING: Removing existing Server-Template";`,
            `        /certificate remove Server-Template;`,
            `        :delay 2s;`,
            `    }`,
            `    `,
            `    :log info ("Creating server certificate template with CN: " . $serverCertCN);`,
            `    :log info "Using key-usage: digital-signature,key-encipherment,tls-server (for VPN compatibility)";`,
            `    :log info "No SAN configured for maximum compatibility with all VPN protocols";`,
            `    `,
            `    # Create server certificate without SAN for maximum compatibility`,
            `    /certificate add name=Server-Template common-name=$serverCertCN \\`,
            `        key-usage=digital-signature,key-encipherment,tls-server days-valid=$DAYSVALID key-size=$KEYSIZE;`,
            `    :log info "Server certificate template created successfully without SAN";`,
            `    :put " Server certificate template created successfully";`,
            `} on-error={`,
            `    :local errorMsg "Failed to create server certificate template";`,
            `    :log error ($errorMsg . " - Check CA certificate and system resources");`,
            `    :put ("ERROR: " . $errorMsg);`,
            `    :put "Possible causes: CA not ready, invalid parameters, or resource limits";`,
            `    :error $errorMsg;`,
            `}`,
            "",
            `:put ("--> Signing Server Certificate (Server@". $"CN_CA_NAME". ")...");`,
            `:log info "STEP 1.4: Signing Server Certificate";`,
            `:do {`,
            `    :local serverCertName ("Server@". $"CN_CA_NAME");`,
            `    `,
            `    # Verify CA certificate exists before signing`,
            `    :local caCert [/certificate find name=$"CN_CA_NAME"];`,
            `    :if ([:len $caCert] = 0) do={`,
            `        :log error "CRITICAL: CA certificate not found, cannot sign server certificate";`,
            `        :error "CA certificate missing";`,
            `    }`,
            `    `,
            `    # Check if server certificate already exists`,
            `    :local existingServerCert [/certificate find name=$serverCertName];`,
            `    :if ([:len $existingServerCert] > 0) do={`,
            `        :log warning ("Server certificate '" . $serverCertName . "' already exists, removing");`,
            `        :put ("WARNING: Removing existing " . $serverCertName);`,
            `        /certificate remove $existingServerCert;`,
            `        :delay 2s;`,
            `    }`,
            `    `,
            `    :log info ("Signing server certificate: " . $serverCertName . " with CA: " . $"CN_CA_NAME");`,
            `    /certificate sign Server-Template ca=$"CN_CA_NAME" name=$serverCertName;`,
            `    :log info "Server certificate signing initiated, waiting for completion...";`,
            `    :delay 5s;`,
            `    `,
            `    # Verify server certificate was created`,
            `    :local newServerCert [/certificate find name=$serverCertName];`,
            `    :if ([:len $newServerCert] = 0) do={`,
            `        :log error "CRITICAL: Server certificate was not created after signing";`,
            `        :error "Server certificate creation failed";`,
            `    }`,
            `    `,
            `    /certificate set [find name=$serverCertName] trusted=yes;`,
            `    :log info ("Server Certificate '" . $serverCertName . "' created and set as trusted");`,
            `    :put (" Server Certificate '" . $serverCertName . "' created and trusted");`,
            `} on-error={`,
            `    :local errorMsg "Failed to sign or trust server certificate";`,
            `    :log error ($errorMsg . " - Check CA certificate and server template");`,
            `    :put ("ERROR: " . $errorMsg);`,
            `    :put "Possible causes: CA missing, template invalid, or signing process failure";`,
            `    :put "Check: /certificate print detail where name=Server-Template";`,
            `    :error $errorMsg;`,
            `}`,
            "",
            "# Step 1.5: Create Client Certificate Template (Generic)",
            `:put "--> Creating Generic Client Certificate Template...";`,
            `:log info "STEP 1.5: Creating Generic Client Certificate Template";`,
            `:do {`,
            `    # Check if client template already exists`,
            `    :local existingClient [/certificate find name="Client-Template"];`,
            `    :if ([:len $existingClient] > 0) do={`,
            `        :log warning "Client-Template already exists, removing old template";`,
            `        :put "WARNING: Removing existing Client-Template";`,
            `        /certificate remove Client-Template;`,
            `        :delay 2s;`,
            `    }`,
            `    `,
            `    :log info "Creating generic client certificate template with CN: Client-Template";`,
            `    :log info "Using key-usage: tls-client (for VPN client authentication)";`,
            `    `,
            `    /certificate add name=Client-Template common-name="Client-Template" \\`,
            `        key-usage=tls-client days-valid=$DAYSVALID key-size=$KEYSIZE;`,
            `    :log info "Generic client certificate template created successfully";`,
            `    :put " Generic Client Certificate Template 'Client-Template' created";`,
            `} on-error={`,
            `    :local errorMsg "Failed to create client certificate template";`,
            `    :log error ($errorMsg . " - Check system resources and parameters");`,
            `    :put ("ERROR: " . $errorMsg);`,
            `    :put "Possible causes: Resource limits, invalid parameters, or system overload";`,
            `    :error $errorMsg;`,
            `}`,
            "",
            `:put ("--> Signing Generic Client Certificate (Client@". $"CN_CA_NAME". ")...");`,
            `:log info "STEP 1.6: Signing Generic Client Certificate";`,
            `:do {`,
            `    :local clientCertName ("Client@". $"CN_CA_NAME");`,
            `    `,
            `    # Verify CA certificate exists before signing`,
            `    :local caCert [/certificate find name=$"CN_CA_NAME"];`,
            `    :if ([:len $caCert] = 0) do={`,
            `        :log error "CRITICAL: CA certificate not found, cannot sign client certificate";`,
            `        :error "CA certificate missing for client signing";`,
            `    }`,
            `    `,
            `    # Check if client certificate already exists`,
            `    :local existingClientCert [/certificate find name=$clientCertName];`,
            `    :if ([:len $existingClientCert] > 0) do={`,
            `        :log warning ("Client certificate '" . $clientCertName . "' already exists, removing");`,
            `        :put ("WARNING: Removing existing " . $clientCertName);`,
            `        /certificate remove $existingClientCert;`,
            `        :delay 2s;`,
            `    }`,
            `    `,
            `    :log info ("Signing client certificate: " . $clientCertName . " with CA: " . $"CN_CA_NAME");`,
            `    /certificate sign Client-Template ca=$"CN_CA_NAME" name=$clientCertName;`,
            `    :log info "Client certificate signing initiated, waiting for completion...";`,
            `    :delay 5s;`,
            `    `,
            `    # Verify client certificate was created`,
            `    :local newClientCert [/certificate find name=$clientCertName];`,
            `    :if ([:len $newClientCert] = 0) do={`,
            `        :log error "CRITICAL: Client certificate was not created after signing";`,
            `        :error "Client certificate creation failed";`,
            `    }`,
            `    `,
            `    /certificate set [find name=$clientCertName] trusted=yes;`,
            `    :log info ("Generic Client Certificate '" . $clientCertName . "' created and set as trusted");`,
            `    :put (" Generic Client Certificate '" . $clientCertName . "' created and trusted");`,
            `} on-error={`,
            `    :local errorMsg "Failed to sign or trust client certificate";`,
            `    :log error ($errorMsg . " - Check CA certificate and client template");`,
            `    :put ("ERROR: " . $errorMsg);`,
            `    :put "Possible causes: CA missing, template invalid, or signing process failure";`,
            `    :put "Check: /certificate print detail where name=Client-Template";`,
            `    :error $errorMsg;`,
            `}`,
            "",
            "# Certificate Setup Summary and Verification",
            `:log info "STEP 2: Final Verification and Summary";`,
            `:put "=== Private Certificate Setup Summary ===";`,
            `:log info "=== PRIVATE CERTIFICATE SETUP COMPLETED ===";`,
            "",
            "# Verify all certificates were created successfully",
            `:local caCertExists [/certificate find name=$"CN_CA_NAME"];`,
            `:local serverCertExists [/certificate find name=("Server@" . $"CN_CA_NAME")];`,
            `:local clientCertExists [/certificate find name=("Client@" . $"CN_CA_NAME")];`,
            "",
            `:if ([:len $caCertExists] > 0) do={`,
            `    :local caCertTrusted [/certificate get [:pick $caCertExists 0] trusted];`,
            `    :local caCertExpiry [/certificate get [:pick $caCertExists 0] expires-after];`,
            `    :put (" CA Certificate: " . $"CN_CA_NAME" . " (Trusted: " . $caCertTrusted . ", Expires: " . $caCertExpiry . ")");`,
            `    :log info ("CA Certificate verified: " . $"CN_CA_NAME" . " - Trusted: " . $caCertTrusted);`,
            `} else={`,
            `    :put (" CA Certificate: " . $"CN_CA_NAME" . " - NOT FOUND!");`,
            `    :log error ("CRITICAL: CA Certificate not found: " . $"CN_CA_NAME");`,
            `}`,
            "",
            `:if ([:len $serverCertExists] > 0) do={`,
            `    :local serverCertTrusted [/certificate get [:pick $serverCertExists 0] trusted];`,
            `    :local serverCertExpiry [/certificate get [:pick $serverCertExists 0] expires-after];`,
            `    :put (" Server Certificate: Server@" . $"CN_CA_NAME" . " (Trusted: " . $serverCertTrusted . ", Expires: " . $serverCertExpiry . ")");`,
            `    :log info ("Server Certificate verified: Server@" . $"CN_CA_NAME" . " - Trusted: " . $serverCertTrusted);`,
            `} else={`,
            `    :put (" Server Certificate: Server@" . $"CN_CA_NAME" . " - NOT FOUND!");`,
            `    :log error ("CRITICAL: Server Certificate not found: Server@" . $"CN_CA_NAME");`,
            `}`,
            "",
            `:if ([:len $clientCertExists] > 0) do={`,
            `    :local clientCertTrusted [/certificate get [:pick $clientCertExists 0] trusted];`,
            `    :local clientCertExpiry [/certificate get [:pick $clientCertExists 0] expires-after];`,
            `    :put (" Client Certificate: Client@" . $"CN_CA_NAME" . " (Trusted: " . $clientCertTrusted . ", Expires: " . $clientCertExpiry . ")");`,
            `    :log info ("Client Certificate verified: Client@" . $"CN_CA_NAME" . " - Trusted: " . $clientCertTrusted);`,
            `} else={`,
            `    :put (" Client Certificate: Client@" . $"CN_CA_NAME" . " - NOT FOUND!");`,
            `    :log error ("CRITICAL: Client Certificate not found: Client@" . $"CN_CA_NAME");`,
            `}`,
            "",
            `:put ("Configuration: Key Size=" . $KEYSIZE . " bits, Validity=" . $DAYSVALID . " days");`,
            `:put "=== Setup Complete ===";`,
            `:put "";`,
            `:put " NEXT STEPS:";`,
            `:put "1. Certificates created but not applied to services";`,
            `:put "2. Run AddCert() function to apply certificates to VPN services";`,
            `:put "3. Or apply manually:";`,
            `:put ("   /ip service set www-ssl certificate=Server@" . $"CN_CA_NAME");`,
            `:put ("   /ip service set api-ssl certificate=Server@" . $"CN_CA_NAME");`,
            `:put ("   /interface sstp-server server set certificate=Server@" . $"CN_CA_NAME");`,
            `:put "";`,
            `:put " TROUBLESHOOTING:";`,
            `:put "- Check logs: /log print where topics~error";`,
            `:put "- View certificates: /certificate print detail";`,
            `:put ("- Check certificate status: /certificate print where name~" . $"ROUTER_IDENTITY");`,
            "",
            `:log info "Certificate creation summary:";`,
            `:log info ("Total certificates expected: 3 (CA + Server + Client)");`,
            `:log info ("CA found: " . ([:len $caCertExists] > 0));`,
            `:log info ("Server found: " . ([:len $serverCertExists] > 0));`,
            `:log info ("Client found: " . ([:len $clientCertExists] > 0));`,
            `:log info "=== PRIVATE CERTIFICATE SETUP SCRIPT COMPLETED ===";`,
            "",
            "# Script will now self-destruct (scheduler removal handled automatically)",
        ],
    };

    // Use OneTimeScript to create a one-time script and scheduler
    return OneTimeScript({
        ScriptContent: privateCertScriptContent,
        name: "Private-Cert-Setup",
        startTime: "startup",
    });
};

export const ExportCert = (
    certPassword: string = "client-cert-password",
): RouterConfig => {
    // Create the Client Certificate Export script content as RouterConfig
    const exportCertScriptContent: RouterConfig = {
        "": [
            ":delay 150s;",
            "# MikroTik RouterOS Certificate Export Script",
            "# Version 4.0 - Enhanced export for PrivateCert certificates with comprehensive error logging",
            "# Exports certificates generated by PrivateCert function",
            "",
            "# Enhanced logging configuration",
            `:log info "=== CERTIFICATE EXPORT STARTED ===";`,
            `:log info "Script Version: 4.0 - Enhanced Export for PrivateCert";`,
            `:log info "Timestamp: [/system clock get date] [/system clock get time]";`,
            `:log info "Router Identity: [/system identity get name]";`,
            "",
            "# Configuration Variables with validation",
            `:global "ROUTER_IDENTITY" [/system identity get name];`,
            `:if ([:len $"ROUTER_IDENTITY"] = 0) do={`,
            `    :log error "CRITICAL: Router identity is empty or not set";`,
            `    :put " ERROR: Router identity not found";`,
            `    :error "Cannot proceed without router identity";`,
            `}`,
            `:global "CN_CA_NAME" ($"ROUTER_IDENTITY" . "-CA");`,
            `:global "CERT_PASSWORD" "${certPassword}";`,
            "",
            `:put ">>> Starting Certificate Export Process...";`,
            `:log info "EXPORT: Starting certificate export process";`,
            `:put ("Router Identity: " . $"ROUTER_IDENTITY");`,
            `:put ("CA Name: " . $"CN_CA_NAME");`,
            `:put ("Export Password: " . $"CERT_PASSWORD");`,
            "",
            "# Step 1: Pre-flight checks - Verify PrivateCert certificates exist",
            `:log info "STEP 1: Pre-flight certificate verification";`,
            `:put " Checking PrivateCert certificate availability...";`,
            `:local caCertExists false;`,
            `:local serverCertExists false;`,
            `:local clientCertExists false;`,
            "",
            "# Check CA Certificate",
            `:do {`,
            `    :local caFind [/certificate find name=$"CN_CA_NAME" authority=yes trusted=yes];`,
            `    :if ([:len $caFind] > 0) do={`,
            `        :set caCertExists true;`,
            `        :log info (" CA Certificate found: " . $"CN_CA_NAME");`,
            `        :put (" CA Certificate found: " . $"CN_CA_NAME");`,
            `    } else={`,
            `        :log warning (" CA Certificate not found or not trusted: " . $"CN_CA_NAME");`,
            `        :put (" CA Certificate not found or not trusted: " . $"CN_CA_NAME");`,
            `        :put "   Run PrivateCert setup first";`,
            `    }`,
            `} on-error={`,
            `    :log error "Failed to check CA certificate existence";`,
            `    :put " Failed to check CA certificate";`,
            `}`,
            "",
            "# Check Server Certificate",
            `:do {`,
            `    :local serverCertName ("Server@" . $"CN_CA_NAME");`,
            `    :local serverFind [/certificate find name=$serverCertName trusted=yes];`,
            `    :if ([:len $serverFind] > 0) do={`,
            `        :set serverCertExists true;`,
            `        :log info (" Server Certificate found: " . $serverCertName);`,
            `        :put (" Server Certificate found: " . $serverCertName);`,
            `    } else={`,
            `        :log warning (" Server Certificate not found or not trusted: " . $serverCertName);`,
            `        :put (" Server Certificate not found or not trusted: " . $serverCertName);`,
            `        :put "   Run PrivateCert setup first";`,
            `    }`,
            `} on-error={`,
            `    :log error "Failed to check Server certificate existence";`,
            `    :put " Failed to check Server certificate";`,
            `}`,
            "",
            "# Check Client Certificate",
            `:do {`,
            `    :local clientCertName ("Client@" . $"CN_CA_NAME");`,
            `    :local clientFind [/certificate find name=$clientCertName trusted=yes];`,
            `    :if ([:len $clientFind] > 0) do={`,
            `        :set clientCertExists true;`,
            `        :log info (" Client Certificate found: " . $clientCertName);`,
            `        :put (" Client Certificate found: " . $clientCertName);`,
            `    } else={`,
            `        :log warning (" Client Certificate not found or not trusted: " . $clientCertName);`,
            `        :put (" Client Certificate not found or not trusted: " . $clientCertName);`,
            `        :put "   Run PrivateCert setup first";`,
            `    }`,
            `} on-error={`,
            `    :log error "Failed to check Client certificate existence";`,
            `    :put " Failed to check Client certificate";`,
            `}`,
            "",
            "# Abort if no certificates found",
            `:if (!$caCertExists && !$serverCertExists && !$clientCertExists) do={`,
            `    :log error "CRITICAL: No PrivateCert certificates found";`,
            `    :put " CRITICAL: No PrivateCert certificates found";`,
            `    :put "   Please run PrivateCert setup first";`,
            `    :error "No certificates available for export";`,
            `}`,
            "",
            "# Step 2: Export CA Certificate (PEM format for client trust)",
            `:if ($caCertExists) do={`,
            `    :put "--> Exporting CA Certificate (PEM format)...";`,
            `    :log info "STEP 2.1: Exporting CA Certificate";`,
            `    :do {`,
            `        /certificate export-certificate [find name=$"CN_CA_NAME"] \\`,
            `            export-passphrase="" \\`,
            `            file-name="ca_certificate" \\`,
            `            type=pem;`,
            `        :local exportedFile "ca_certificate.crt";`,
            `        :put (" CA Certificate exported: " . $exportedFile);`,
            `        :log info ("CA Certificate exported successfully: " . $exportedFile);`,
            `        :put "   Install this file in client's trusted root certificates";`,
            `    } on-error={`,
            `        :log error ("Failed to export CA certificate: " . $"CN_CA_NAME");`,
            `        :put (" Failed to export CA certificate: " . $"CN_CA_NAME");`,
            `    }`,
            `} else={`,
            `    :put " Skipping CA certificate export (not found)";`,
            `    :log warning "CA certificate export skipped - certificate not found";`,
            `}`,
            "",
            "# Step 3: Export Client Certificate with Private Key (multiple formats)",
            `:if ($clientCertExists) do={`,
            `    :local clientCertName ("Client@" . $"CN_CA_NAME");`,
            `    `,
            `    # Export as PKCS12 (.p12) for Windows/mobile clients`,
            `    :put "--> Exporting Client Certificate as PKCS12 (.p12)...";`,
            `    :log info "STEP 2.2: Exporting Client Certificate as PKCS12";`,
            `    :do {`,
            `        /certificate export-certificate [find name=$clientCertName] \\`,
            `            export-passphrase=$"CERT_PASSWORD" \\`,
            `            file-name="client_certificate" \\`,
            `            type=pkcs12;`,
            `        :local exportedFile "client_certificate.p12";`,
            `        :put (" Client Certificate (PKCS12) exported: " . $exportedFile);`,
            `        :log info ("Client Certificate PKCS12 exported successfully: " . $exportedFile);`,
            `        :put ("   Password: " . $"CERT_PASSWORD");`,
            `        :put "   For Windows/mobile VPN clients";`,
            `    } on-error={`,
            `        :log error "Failed to export client certificate as PKCS12";`,
            `        :put " Failed to export client certificate as PKCS12";`,
            `    }`,
            `    `,
            `    # Export as PEM for OpenVPN and other clients`,
            `    :put "--> Exporting Client Certificate as PEM (.crt/.key)...";`,
            `    :log info "STEP 2.3: Exporting Client Certificate as PEM";`,
            `    :do {`,
            `        /certificate export-certificate [find name=$clientCertName] \\`,
            `            export-passphrase=$"CERT_PASSWORD" \\`,
            `            file-name="client_bundle" \\`,
            `            type=pem;`,
            `        :put " Client Certificate (PEM) exported: client_bundle.crt and client_bundle.key";`,
            `        :log info "Client Certificate PEM exported successfully: client_bundle.crt and client_bundle.key";`,
            `        :put ("   Private key password: " . $"CERT_PASSWORD");`,
            `        :put "   For OpenVPN and Linux clients";`,
            `    } on-error={`,
            `        :log error "Failed to export client certificate as PEM";`,
            `        :put " Failed to export client certificate as PEM";`,
            `    }`,
            `} else={`,
            `    :put " Skipping Client certificate export (not found)";`,
            `    :log warning "Client certificate export skipped - certificate not found";`,
            `}`,
            "",
            "# Step 4: Export Server Certificate (PEM format for reference)",
            `:if ($serverCertExists) do={`,
            `    :put "--> Exporting Server Certificate (PEM format)...";`,
            `    :log info "STEP 2.4: Exporting Server Certificate";`,
            `    :do {`,
            `        :local serverCertName ("Server@" . $"CN_CA_NAME");`,
            `        /certificate export-certificate [find name=$serverCertName] \\`,
            `            export-passphrase="" \\`,
            `            file-name="server_certificate" \\`,
            `            type=pem;`,
            `        :put " Server Certificate exported: server_certificate.crt";`,
            `        :log info "Server Certificate exported successfully: server_certificate.crt";`,
            `        :put "   This is for reference/backup purposes";`,
            `    } on-error={`,
            `        :log error "Failed to export server certificate";`,
            `        :put " Failed to export server certificate";`,
            `    }`,
            `} else={`,
            `    :put " Skipping Server certificate export (not found)";`,
            `    :log warning "Server certificate export skipped - certificate not found";`,
            `}`,
            "",
            "# Step 5: Export Summary and Instructions",
            `:put "";`,
            `:put " === CERTIFICATE EXPORT SUMMARY ===";`,
            `:if ($caCertExists) do={`,
            `    :put " CA Certificate: ca_certificate.crt";`,
            `}`,
            `:if ($clientCertExists) do={`,
            `    :put " Client Certificate (PKCS12): client_certificate.p12";`,
            `    :put " Client Certificate (PEM): client_bundle.crt + client_bundle.key";`,
            `    :put ("   Password for both formats: " . $"CERT_PASSWORD");`,
            `}`,
            `:if ($serverCertExists) do={`,
            `    :put " Server Certificate: server_certificate.crt";`,
            `}`,
            `:put "";`,
            `:put " DOWNLOAD INSTRUCTIONS:";`,
            `:put "1. Go to Files menu in WinBox/WebFig";`,
            `:put "2. Download the exported certificate files";`,
            `:put "3. Use /file print to verify files are present";`,
            `:put "";`,
            `:put " CLIENT SETUP BY VPN TYPE:";`,
            `:put "";`,
            `:put " Windows/Mobile SSTP/IKEv2:";`,
            `:put "   Install ca_certificate.crt in Trusted Root";`,
            `:put "   Install client_certificate.p12 in Personal";`,
            `:put ("   PKCS12 password: " . $"CERT_PASSWORD");`,
            `:put "";`,
            `:put " OpenVPN (Linux/Windows):";`,
            `:put "   ca ca_certificate.crt";`,
            `:put "   cert client_bundle.crt";`,
            `:put "   key client_bundle.key";`,
            `:put ("   Key password: " . $"CERT_PASSWORD");`,
            `:put "";`,
            `:put " SSTP (Windows):";`,
            `:put "   Install ca_certificate.crt in Trusted Root";`,
            `:put "   Client certificate optional for SSTP";`,
            `:put "";`,
            `:put " TROUBLESHOOTING:";`,
            `:put "- List exported files: /file print where name~cert";`,
            `:put "- View certificate details: /certificate print detail";`,
            `:put ("- Check certificate status: /certificate print where name~" . $"ROUTER_IDENTITY");`,
            `:put "- Check export logs: /log print where topics~error";`,
            "",
            `:log info "=== CERTIFICATE EXPORT COMPLETED ===";`,
            `:put "=== Certificate Export Process Complete ===";`,
        ],
    };

    

    // Use OneTimeScript to create the script
    return OneTimeScript({
        ScriptContent: exportCertScriptContent,
        name: `Export-Client-Cert`,
        startTime: "startup",
    });
};

export const AddCert = (
    targetCertificateName: string = "auto-detect",
): RouterConfig => {
    // Create the VPN Certificate Assignment script content as RouterConfig
    const addCertScriptContent: RouterConfig = {
        "": [
            ":delay 100s;",
            "# MikroTik RouterOS Smart VPN Certificate Assignment Script",
            "# Version 2.0 - Auto-detects PrivateCert generated certificates",
            "",
            "# --- Configuration ---",
            `:global targetCertificateName "${targetCertificateName}";`,
            `:global "ROUTER_IDENTITY" [/system identity get name];`,
            `:global "CN_CA_NAME" ($"ROUTER_IDENTITY" . "-CA");`,
            "",
            `:log info "Smart VPN Certificate Assignment Script: Starting.";`,
            "",
            "# --- Step 1: Always check for PrivateCert certificates first ---",
            `:local serverCertName "";`,
            `:local caCertName "";`,
            `:local usePrivateCerts false;`,
            `:local forcePrivateCerts false;`,
            "",
            `:log info "Checking for PrivateCert generated certificates...";`,
            ``,
            `# Check for CA certificate`,
            `:local caCertEntry "";`,
            `:do {`,
            `    :set caCertEntry [/certificate find name=$"CN_CA_NAME" authority=yes];`,
            `} on-error={`,
            `    :log warning "Error searching for CA certificate.";`,
            `}`,
            `:if ([:len $caCertEntry] > 0) do={`,
            `    :set caCertName $"CN_CA_NAME";`,
            `    :log info ("Found CA certificate: " . $caCertName);`,
            `    `,
            `    # Check for server certificate`,
            `    :local expectedServerName ("Server@" . $"CN_CA_NAME");`,
            `    :local serverCertEntry "";`,
            `    :do {`,
            `        :set serverCertEntry [/certificate find name=$expectedServerName];`,
            `    } on-error={`,
            `        :log warning "Error searching for server certificate.";`,
            `    }`,
            `    :if ([:len $serverCertEntry] > 0) do={`,
            `        :set serverCertName $expectedServerName;`,
            `        :set usePrivateCerts true;`,
            `        :set forcePrivateCerts true;`,
            `        :log info ("Found server certificate: " . $serverCertName);`,
            `        :log info "PrivateCert certificates detected - will force replace any existing certificates on VPN services.";`,
            `    } else={`,
            `        :log warning ("Expected server certificate '" . $expectedServerName . "' not found.");`,
            `        :log info "Available certificates:";`,
            `        :local allCerts [/certificate find];`,
            `        :foreach certId in=$allCerts do={`,
            `            :local certName [/certificate get $certId name];`,
            `            :local certCN [/certificate get $certId common-name];`,
            `            :local certTrusted [/certificate get $certId trusted];`,
            `            :log info ("  - " . $certName . " (CN: " . $certCN . ", Trusted: " . $certTrusted . ")");`,
            `        }`,
            `    }`,
            `} else={`,
            `    :log info ("CA certificate '" . $"CN_CA_NAME" . "' not found.");`,
            `    :log info "Available certificates:";`,
            `    :local allCerts [/certificate find];`,
            `    :foreach certId in=$allCerts do={`,
            `        :local certName [/certificate get $certId name];`,
            `        :local certCN [/certificate get $certId common-name];`,
            `        :local certTrusted [/certificate get $certId trusted];`,
            `        :log info ("  - " . $certName . " (CN: " . $certCN . ", Trusted: " . $certTrusted . ")");`,
            `    }`,
            `}`,
            ``,
            `# --- Step 2: Fallback certificate selection if no PrivateCert found ---`,
            `:if (!$usePrivateCerts) do={`,
            `    :if ($targetCertificateName = "auto-detect") do={`,
            `        :log info "No PrivateCert certificates found. Looking for any suitable server certificates...";`,
            `        # Look for any trusted certificate that could be used for servers`,
            `        :local suitableCerts "";`,
            `        :do {`,
            `            :set suitableCerts [/certificate find trusted=yes key-usage~"tls-server"];`,
            `        } on-error={`,
            `            :log warning "Error searching for suitable certificates.";`,
            `        }`,
            `        :if ([:len $suitableCerts] > 0) do={`,
            `            :local firstSuitableCert [:pick $suitableCerts 0];`,
            `            :set serverCertName [/certificate get $firstSuitableCert name];`,
            `            :log info ("Found suitable server certificate: " . $serverCertName);`,
            `        } else={`,
            `            :log error "No suitable certificates found.";`,
            `            :log error "SOLUTION: Run PrivateCert setup first to create certificates.";`,
            `            :log error "  Command: /system script run Private-Cert-Setup";`,
            `            :log error "  Or use AllCert() function to create all certificate components.";`,
            `            :log info "Available certificates:";`,
            `            :local allCerts [/certificate find];`,
            `            :if ([:len $allCerts] = 0) do={`,
            `                :log info "  No certificates found in system.";`,
            `            } else={`,
            `                :foreach certId in=$allCerts do={`,
            `                    :local certName [/certificate get $certId name];`,
            `                    :local certCN [/certificate get $certId common-name];`,
            `                    :local certTrusted [/certificate get $certId trusted];`,
            `                    :log info ("  - " . $certName . " (CN: " . $certCN . ", Trusted: " . $certTrusted . ")");`,
            `                }`,
            `            }`,
            `        }`,
            `    } else={`,
            `        :log info ("Manual mode: Using specified certificate '" . $targetCertificateName . "'");`,
            `        :set serverCertName $targetCertificateName;`,
            `    }`,
            `}`,
            "",
            "# --- Step 2: Validate selected certificate ---",
            `:if ([:len $serverCertName] = 0) do={`,
            `    :log error "No certificate selected for assignment.";`,
            `    :log error "SOLUTION: Run PrivateCert setup first or use AllCert() function.";`,
            `    :log error "  For PrivateCert: /system script run Private-Cert-Setup";`,
            `    :log error "  For complete setup: Use AllCert() function in config generator";`,
            `} else={`,
            `    :local certExists false;`,
            `    :do {`,
            `        :local certFound [/certificate find where name=$serverCertName];`,
            `        :if ([:len $certFound] > 0) do={`,
            `            :set certExists true;`,
            `            :log info ("Certificate '" . $serverCertName . "' found in system.");`,
            `        } else={`,
            `            :log warning ("Certificate '" . $serverCertName . "' not found by name search.");`,
            `        }`,
            `    } on-error={`,
            `        :log warning "Error checking certificate existence. Trying alternative method.";`,
            `        # Alternative check using count-only`,
            `        :do {`,
            `            :local certCount [/certificate find count-only where name=$serverCertName];`,
            `            :if ([:typeof $certCount] = "num" && $certCount > 0) do={`,
            `                :set certExists true;`,
            `                :log info ("Certificate '" . $serverCertName . "' found via count method.");`,
            `            }`,
            `        } on-error={`,
            `            :log error "Both certificate check methods failed.";`,
            `        }`,
            `    }`,
            `    :if (!$certExists) do={`,
            `        :log error ("Certificate '" . $serverCertName . "' not found in /certificate.");`,
            `        :log error "This means the PrivateCert setup has not been completed successfully.";`,
            `        :log error "SOLUTION:";`,
            `        :log error "  1. Run PrivateCert setup: /system script run Private-Cert-Setup";`,
            `        :log error "  2. Wait for certificate creation (may take 30-60 seconds)";`,
            `        :log error "  3. Check certificate creation: /certificate print";`,
            `        :log error "  4. Then re-run this script: /system script run Add-VPN-Cert";`,
            `        :log info "Current certificates in system:";`,
            `        :local allCerts [/certificate find];`,
            `        :if ([:len $allCerts] = 0) do={`,
            `            :log info "  No certificates found - PrivateCert setup definitely needed.";`,
            `        } else={`,
            `            :foreach certId in=$allCerts do={`,
            `                :local certName [/certificate get $certId name];`,
            `                :local certCN [/certificate get $certId common-name];`,
            `                :local certTrusted [/certificate get $certId trusted];`,
            `                :log info ("  - " . $certName . " (CN: " . $certCN . ", Trusted: " . $certTrusted . ")");`,
            `            }`,
            `        }`,
            `    } else={`,
            `        :local certTrusted false;`,
            `        :local certFlags "";`,
            `        :do {`,
            `            :local certFound [/certificate find where name=$serverCertName];`,
            `            :if ([:len $certFound] > 0) do={`,
            `                :local certId [:pick $certFound 0];`,
            `                :set certTrusted [/certificate get $certId trusted];`,
            `                # Get certificate details for debugging`,
            `                :local certCN [/certificate get $certId common-name];`,
            `                :local certKA [/certificate get $certId ka];`,
            `                :local certPrivateKey [/certificate get $certId private-key];`,
            `                :log info ("Certificate details: CN='" . $certCN . "', Trusted=" . $certTrusted . ", Private-Key=" . $certPrivateKey . ", KA=" . $certKA);`,
            `            }`,
            `        } on-error={`,
            `            :log warning "Error checking certificate trust status and details.";`,
            `        }`,
            `        :if (!$certTrusted) do={`,
            `            :log warning ("Certificate '" . $serverCertName . "' is not trusted. Attempting to set as trusted...");`,
            `            :do {`,
            `                :local certFound [/certificate find where name=$serverCertName];`,
            `                :if ([:len $certFound] > 0) do={`,
            `                    /certificate set [:pick $certFound 0] trusted=yes;`,
            `                    :log info ("Certificate '" . $serverCertName . "' has been set as trusted.");`,
            `                    :set certTrusted true;`,
            `                }`,
            `            } on-error={`,
            `                :log error ("Failed to set certificate '" . $serverCertName . "' as trusted.");`,
            `            }`,
            `        }`,
            `        :log info ("Using certificate: " . $serverCertName);`,
            "",
            `        # --- Step 3: Apply to VPN Services ---`,
            `        `,
            `        # --- IKEv2 VPN Server ---`,
            `        :log info "Checking IKEv2 server status...";`,
            `        :local ikev2PeerExists false;`,
            `        :do {`,
            `            :local peerCount [/ip ipsec peer find count-only where exchange-mode=ike2 passive=yes];`,
            `            :if ([:typeof $peerCount] = "num" && $peerCount > 0) do={`,
            `                :set ikev2PeerExists true;`,
            `            }`,
            `        } on-error={`,
            `            :log info "IPsec subsystem not available or error checking IKEv2 peers.";`,
            `        }`,
            "",
            `        :if ($ikev2PeerExists) do={`,
            `            :log info "IKEv2 server (passive peer with exchange-mode=ike2) detected as enabled.";`,
            `            :local identitiesUpdated 0;`,
            `            /ip ipsec identity`,
            `            # Iterate over identities that are using certificates`,
            `            :foreach id in=[find where certificate!="none" and certificate!=""] do={`,
            `                :local currentCertName [/ip ipsec identity get $id certificate];`,
            `                :local peerName [/ip ipsec identity get $id peer];`,
            `                # Verify this identity's peer is indeed an active IKEv2 listener`,
            `                :local isIkev2Peer false;`,
            `                :do {`,
            `                    :local matchingPeerCount [/ip ipsec peer find count-only where name=$peerName exchange-mode=ike2 passive=yes];`,
            `                    :if ([:typeof $matchingPeerCount] = "num" && $matchingPeerCount > 0) do={`,
            `                        :set isIkev2Peer true;`,
            `                    }`,
            `                } on-error={`,
            `                    :log warning ("Error checking IKEv2 peer '" . $peerName . "'");`,
            `                }`,
            "",
            `                :if ($isIkev2Peer) do={`,
            `                    :local needsUpdate false;`,
            `                    :if ($forcePrivateCerts) do={`,
            `                        # Force update to PrivateCert if current cert is not PrivateCert`,
            `                        :if ($currentCertName != $serverCertName) do={`,
            `                            :set needsUpdate true;`,
            `                            :log info ("IKEv2: Forcing replacement of '" . $currentCertName . "' with PrivateCert '" . $serverCertName . "' on identity '" . $id . "'.");`,
            `                        }`,
            `                    } else={`,
            `                        # Normal update logic`,
            `                        :if ($currentCertName != $serverCertName) do={`,
            `                            :set needsUpdate true;`,
            `                        }`,
            `                    }`,
            `                    `,
            `                    :if ($needsUpdate) do={`,
            `                        set $id certificate=$serverCertName;`,
            `                        :log info ("IKEv2: Assigned certificate '" . $serverCertName . "' to identity number '" . $id . "' (peer '" . $peerName . "').");`,
            `                        :set identitiesUpdated ($identitiesUpdated + 1);`,
            `                    } else={`,
            `                        :log info ("IKEv2: Identity number '" . $id . "' (peer '" . $peerName . "') already uses '" . $serverCertName . "'.");`,
            `                    }`,
            `                }`,
            `            }`,
            `            :if ($identitiesUpdated = 0) do={`,
            `                :local hasCertIdentities false;`,
            `                :do {`,
            `                    :local certIdentities [/ip ipsec identity find where certificate!="none" and certificate!=""];`,
            `                    :if ([:len $certIdentities] > 0) do={`,
            `                        :set hasCertIdentities true;`,
            `                    }`,
            `                } on-error={`,
            `                    :log warning "Error checking certificate-based identities.";`,
            `                }`,
            `                :if ($hasCertIdentities) do={`,
            `                     :log info ("IKEv2: All relevant certificate-based identities already use '" . $serverCertName . "' or no updates were needed.");`,
            `                } else={`,
            `                     :log warning "IKEv2: No certificate-based identities found that are linked to an active IKEv2 peer.";`,
            `                }`,
            `            }`,
            `        } else={`,
            `            :log info "IKEv2 server (passive peer with exchange-mode=ike2) not found or not enabled.";`,
            `        }`,
            "",
            `        # --- SSTP VPN Server ---`,
            `        :log info "Checking SSTP server status...";`,
            `        :local sstpEnabled false;`,
            `        :local sstpAvailable false;`,
            `        :local currentSstpCert "";`,
            `        :local sstpPort 4443;`,
            `        `,
            `        # Check if sstp-server configuration path exists to prevent errors if the package is disabled or not installed`,
            `        :do {`,
            `            # Check if SSTP server interface exists`,
            `            :local sstpServers [/interface sstp-server find];`,
            `            :if ([:len $sstpServers] > 0) do={`,
            `                :set sstpAvailable true;`,
            `                :log info "SSTP server interface found.";`,
            `            } else={`,
            `                :log info "SSTP server interface not found - checking server configuration.";`,
            `            }`,
            `            `,
            `            # Check SSTP server configuration`,
            `            :set sstpEnabled [/interface sstp-server server get enabled];`,
            `            :set currentSstpCert [/interface sstp-server server get certificate];`,
            `            :set sstpPort [/interface sstp-server server get port];`,
            `            :log info ("SSTP server enabled: " . $sstpEnabled);`,
            `            :log info ("SSTP server port: " . $sstpPort);`,
            `            :log info ("SSTP current certificate: " . $currentSstpCert);`,
            `            :set sstpAvailable true;`,
            `        } on-error={`,
            `            :log info "SSTP server subsystem not available or not configured.";`,
            `        }`,
            "",
            `        :if ($sstpAvailable) do={`,
            `            :if ($sstpEnabled) do={`,
            `                :log info "SSTP server detected as enabled.";`,
            `                :local needsUpdate false;`,
            `                :local updateReason "";`,
            `                `,
            `                # Check if certificate assignment is needed`,
            `                :if ([:len $currentSstpCert] = 0 || $currentSstpCert = "none") do={`,
            `                    :set needsUpdate true;`,
            `                    :set updateReason "No certificate assigned";`,
            `                    :log warning "SSTP: No certificate currently assigned to SSTP server.";`,
            `                } else={`,
            `                    :if ($forcePrivateCerts) do={`,
            `                        # Force update to PrivateCert if current cert is not PrivateCert`,
            `                        :if ($currentSstpCert != $serverCertName) do={`,
            `                            :set needsUpdate true;`,
            `                            :set updateReason ("Forcing replacement of '" . $currentSstpCert . "' with PrivateCert");`,
            `                            :log info ("SSTP: " . $updateReason . " '" . $serverCertName . "'.");`,
            `                        }`,
            `                    } else={`,
            `                        # Normal update logic`,
            `                        :if ($currentSstpCert != $serverCertName) do={`,
            `                            :set needsUpdate true;`,
            `                            :set updateReason ("Updating from '" . $currentSstpCert . "' to '" . $serverCertName . "'");`,
            `                        }`,
            `                    }`,
            `                }`,
            `                `,
            `                :if ($needsUpdate) do={`,
            `                    :log info ("SSTP: Certificate update needed - " . $updateReason);`,
            `                    # Verify the certificate exists before assignment`,
            `                    :local certFound [/certificate find where name=$serverCertName];`,
            `                    :if ([:len $certFound] > 0) do={`,
            `                        # Apply certificate with enhanced error handling`,
            `                        :do {`,
            `                            # Clear current certificate first`,
            `                            /interface sstp-server server set certificate=none;`,
            `                            :delay 2s;`,
            `                            # Assign new certificate`,
            `                            /interface sstp-server server set certificate=$serverCertName;`,
            `                            :delay 1s;`,
            `                            # Verify assignment`,
            `                            :local verifyAssignment [/interface sstp-server server get certificate];`,
            `                            :if ($verifyAssignment = $serverCertName) do={`,
            `                                :log info ("SSTP: Successfully assigned certificate '" . $serverCertName . "'.");`,
            `                                :log info ("SSTP: Server ready on port " . $sstpPort . " with certificate.");`,
            `                            } else={`,
            `                                :log error ("SSTP: Certificate assignment verification failed. Expected '" . $serverCertName . "', got '" . $verifyAssignment . "'.");`,
            `                            }`,
            `                        } on-error={`,
            `                            :log error ("SSTP: Failed to assign certificate '" . $serverCertName . "'. Check certificate validity.");`,
            `                        }`,
            `                    } else={`,
            `                        :log error ("SSTP: Cannot assign certificate '" . $serverCertName . "' - certificate not found in system.");`,
            `                    }`,
            `                } else={`,
            `                    :log info ("SSTP: Server already uses certificate '" . $serverCertName . "'.");`,
            `                }`,
            `            } else={`,
            `                :log warning "SSTP server is available but not enabled.";`,
            `                :log info "To enable SSTP server: /interface sstp-server server set enabled=yes";`,
            `                :if ([:len $currentSstpCert] = 0 || $currentSstpCert = "none") do={`,
            `                    :log info ("SSTP: Would assign certificate '" . $serverCertName . "' when enabled.");`,
            `                }`,
            `            }`,
            `        } else={`,
            `            :log info "SSTP server subsystem not available or not configured.";`,
            `        }`,
            "",
            `        # --- OpenVPN Server ---`,
            `        :log info "Checking OpenVPN server status...";`,
            `        :local ovpnServersUpdated 0;`,
            `        :local enabledOvpnInstances 0;`,
            `        /interface ovpn-server server`,
            `        :foreach i in=[find] do={`,
            `            :local ovpnServerName [get $i name];`,
            `            :if ([get $i disabled] = false) do={`,
            `                :set enabledOvpnInstances ($enabledOvpnInstances + 1);`,
            `                :log info ("OpenVPN server instance '" . $ovpnServerName . "' detected as enabled.");`,
            `                :local currentOvpnCert [get $i certificate];`,
            `                :local needsUpdate false;`,
            `                :if ($forcePrivateCerts) do={`,
            `                    # Force update to PrivateCert if current cert is not PrivateCert`,
            `                    :if ($currentOvpnCert != $serverCertName) do={`,
            `                        :set needsUpdate true;`,
            `                        :log info ("OpenVPN: Forcing replacement of '" . $currentOvpnCert . "' with PrivateCert '" . $serverCertName . "' on instance '" . $ovpnServerName . "'.");`,
            `                    }`,
            `                } else={`,
            `                    # Normal update logic`,
            `                    :if ($currentOvpnCert != $serverCertName) do={`,
            `                        :set needsUpdate true;`,
            `                    }`,
            `                }`,
            `                `,
            `                :if ($needsUpdate) do={`,
            `                    set $i certificate=$serverCertName;`,
            `                    :log info ("OpenVPN: Assigned certificate '" . $serverCertName . "' to server instance '" . $ovpnServerName . "'.");`,
            `                    :set ovpnServersUpdated ($ovpnServersUpdated + 1);`,
            `                } else={`,
            `                    :log info ("OpenVPN: Server instance '" . $ovpnServerName . "' already uses certificate '" . $serverCertName . "'.");`,
            `                }`,
            `            } else={`,
            `                :log info ("OpenVPN server instance '" . $ovpnServerName . "' is disabled.");`,
            `            }`,
            `        }`,
            "",
            `        :local ovpnInstanceCount 0;`,
            `        :do {`,
            `            :local ovpnInstances [/interface ovpn-server server find];`,
            `            :set ovpnInstanceCount [:len $ovpnInstances];`,
            `        } on-error={`,
            `            :log info "OpenVPN: Server subsystem not available.";`,
            `        }`,
            `        :if ($ovpnInstanceCount = 0) do={`,
            `            :log info "OpenVPN: No OVPN server instances configured.";`,
            `        } else {`,
            `            :if ($enabledOvpnInstances = 0) do={`,
            `                :log info "OpenVPN: No enabled server instances found.";`,
            `            } else {`,
            `                :if ($ovpnServersUpdated = 0) do={`,
            `                    :log info "OpenVPN: All enabled server instances already use the target certificate or no updates were needed.";`,
            `                }`,
            `            }`,
            `        }`,
            `        `,
            `        # --- Summary ---`,
            `        :log info "=== Certificate Assignment Summary ===";`,
            `        :log info ("Certificate used: " . $serverCertName);`,
            `        :if ($usePrivateCerts) do={`,
            `            :log info ("CA Certificate: " . $caCertName);`,
            `            :log info "Source: PrivateCert generated certificates (forced replacement)";`,
            `            :log info "Action: All VPN services updated to use PrivateCert certificates";`,
            `        } else={`,
            `            :if ($targetCertificateName = "auto-detect") do={`,
            `                :log info "Source: Auto-selected suitable certificate";`,
            `            } else={`,
            `                :log info "Source: Manual certificate selection";`,
            `            }`,
            `            :log info "Action: VPN services updated with the selected certificate";`,
            `        }`,
            `        :log info "=== Assignment Complete ===";`,
            `    }`,
            `}`,
            `:log info "Smart VPN Certificate Assignment Script: Finished.";`,
            "",
            "# Script will now self-destruct (scheduler removal handled automatically)",
        ],
    };

    // Use OneTimeScript to create a one-time script and scheduler
    return OneTimeScript({
        ScriptContent: addCertScriptContent,
        name: "Add-VPN-Cert",
        startTime: "startup",
    });
};

export interface AllCertConfig {
    // CGNAT Check parameters
    wanInterfaceName?: string;

    // Let's Encrypt parameters
    certNameToRenew?: string;
    daysBeforeExpiryToRenew?: number;
    renewalStartTime?: string;

    // Private Certificate parameters
    keySize?: number;
    daysValid?: number;

    // Export Certificate parameters
    certPassword?: string;

    // Public Certificate parameters
    checkServerCert?: boolean;

    // Add Certificate parameters
    targetCertificateName?: string;
}

export const AllCert = (config: AllCertConfig = {}): RouterConfig => {
    // Set default values
    const {
        wanInterfaceName = "ether1",
        certNameToRenew = "MikroTik-LE-Cert",
        daysBeforeExpiryToRenew = 30,
        renewalStartTime = "03:00:00",
        keySize = 2048,
        daysValid = 3650,
        certPassword = "client-cert-password",
        checkServerCert = false,
        targetCertificateName = "auto-detect",
    } = config;

    // Generate all certificate configurations
    const cgnatCheck = CheckCGNAT(wanInterfaceName);
    const initLetsEncrypt = InitLetsEncrypt();
    const renewalLetsEncrypt = RenewalLetsEncrypt(
        certNameToRenew,
        daysBeforeExpiryToRenew,
    );
    const letsEncrypt = LetsEncrypt(
        certNameToRenew,
        daysBeforeExpiryToRenew,
        renewalStartTime,
    );
    const privateCert = PrivateCert(keySize, daysValid);
    const exportCert = ExportCert(certPassword);
    const publicCert = PublicCert();
    const addCert = AddCert(targetCertificateName);

    // Merge all configurations using mergeMultipleConfigs
    const mergedConfig = mergeMultipleConfigs(
        cgnatCheck,
        initLetsEncrypt,
        renewalLetsEncrypt,
        letsEncrypt,
        privateCert,
        exportCert,
        publicCert,
        addCert,
    );

    // Add comprehensive comments at the beginning
    const comments = [
        "# Complete Certificate Management Configuration Bundle with OpenVPN",
        "# ================================================================",
        "",
        "# This configuration includes ALL certificate management functions:",
        "# 1. CGNAT Detection and Monitoring",
        "# 2. Let's Encrypt Certificate Management (Initial + Renewal)",
        "# 3. Private CA and Certificate Setup",
        "# 4. Certificate Export for VPN Users",
        "# 5. Public Certificate Authority Updates",
        "# 6. VPN Certificate Assignment",
        "# 7. OpenVPN Client Configuration Export with DDNS Integration",
        "",
        `# Configuration Parameters:`,
        `# - WAN Interface: ${wanInterfaceName}`,
        `# - Let's Encrypt Certificate: ${certNameToRenew}`,
        `# - Renewal Threshold: ${daysBeforeExpiryToRenew} days`,
        `# - Renewal Time: ${renewalStartTime}`,
        `# - Certificate Key Size: ${keySize} bits`,
        `# - Certificate Validity: ${daysValid} days`,
        `# - Certificate Password: ${certPassword}`,
        `# - Public Cert Validation: ${checkServerCert ? "Enabled" : "Disabled"}`,
        `# - Certificate Assignment: ${targetCertificateName}`,
        "",
        "# Scripts and Schedulers Created:",
        "# - CGNAT-Check: CGNAT detection with daily monitoring",
        "# - Init-LetsEncrypt: One-time Let's Encrypt initialization",
        "# - Renewal-LetsEncrypt: Daily Let's Encrypt renewal checks",
        "# - Private-Cert-Setup: One-time private CA setup",
        "# - Export-Client-Cert: One-time certificate export for users",
        "# - Public-Cert-Update: One-time public CA update",
        "# - Add-VPN-Cert: One-time VPN certificate assignment",
        "# - Export-OpenVPN-Config: One-time OpenVPN client configuration export",
        "",
        "# Usage:",
        "# 1. All scripts run automatically based on their schedules",
        "# 2. One-time scripts execute at startup and self-remove",
        "# 3. Recurring scripts run daily for monitoring and renewal",
        "# 4. Manual execution: /system script run [script-name]",
        "# 5. Download OpenVPN files: Files menu in WinBox/WebFig",
        "",
    ];

    // Add comments to the beginning
    if (!mergedConfig[""]) {
        mergedConfig[""] = [];
    }
    mergedConfig[""] = [...comments, ...mergedConfig[""]];

    return mergedConfig;
};

export const DiagnosticLetsEncrypt = (): RouterConfig => {
    // Create an enhanced diagnostic script based on successful forum solutions
    const diagnosticScriptContent: RouterConfig = {
        "": [
            "# MikroTik RouterOS Enhanced Let's Encrypt Diagnostic Script",
            "# Version 2.0 - Based on successful community solutions",
            "# Reference: https://forum.mikrotik.com/viewtopic.php?t=189289",
            "",
            `:log info "=== Enhanced Let's Encrypt Diagnostic Script Started ===";`,
            "",
            "# --- CRITICAL DNS PROPAGATION TEST ---",
            `:local cloudDnsName [/ip cloud get dns-name];`,
            `:if ([:len $cloudDnsName] > 0) do={`,
            `    :log info "CRITICAL TEST: DNS propagation verification...";`,
            `    :local cloudPublicAddress [/ip cloud get public-address];`,
            `    :local ourPublicIp $cloudPublicAddress;`,
            `    :if ([:len $ourPublicIp] = 0) do={`,
            `        :do {`,
            `            :local fetchResult [/tool fetch url="http://api.ipify.org" mode=http as-value output=user];`,
            `            :if (($fetchResult->"status") = "finished") do={`,
            `                :set ourPublicIp ($fetchResult->"data");`,
            `                :while ([:len $ourPublicIp] > 0 && [:pick $ourPublicIp ([:len $ourPublicIp] - 1)] = "\\n") do={`,
            `                    :set ourPublicIp [:pick $ourPublicIp 0 ([:len $ourPublicIp] - 1)];`,
            `                }`,
            `            }`,
            `        } on-error={`,
            `            :log warning " Cannot determine public IP via external service";`,
            `        }`,
            `    }`,
            `    `,
            `    :if ([:len $ourPublicIp] > 0) do={`,
            `        :do {`,
            `            :local resolvedIp [:resolve $cloudDnsName];`,
            `            :if ($resolvedIp = $ourPublicIp) do={`,
            `                :log info (" DNS Propagation: PERFECT - " . $cloudDnsName . " correctly points to " . $ourPublicIp);`,
            `            } else={`,
            `                :log error (" DNS Propagation: CRITICAL FAILURE");`,
            `                :log error ("  Domain: " . $cloudDnsName);`,
            `                :log error ("  Resolves to: " . $resolvedIp);`,
            `                :log error ("  Should resolve to: " . $ourPublicIp);`,
            `                :log error ("  This WILL cause Let's Encrypt to fail!");`,
            `                :log error ("  SOLUTION: Wait 1-24 hours for DNS propagation");`,
            `            }`,
            `        } on-error={`,
            `            :log error (" DNS Propagation: Cannot resolve " . $cloudDnsName);`,
            `            :log error "  This WILL cause Let's Encrypt to fail!";`,
            `        }`,
            `    }`,
            `} else={`,
            `    :log error " No cloud DNS name - enable with: /ip cloud set ddns-enabled=yes";`,
            `}`,
            "",
            "# --- Internet Connectivity Test ---",
            `:log info "Internet connectivity check...";`,
            `:local ping1 [/ping 1.1.1.1 count=3];`,
            `:local ping2 [/ping 8.8.8.8 count=3];`,
            `:if ($ping1 > 0 || $ping2 > 0) do={`,
            `    :log info " Internet connectivity: OK";`,
            `} else={`,
            `    :log error " Internet connectivity: FAILED";`,
            `}`,
            "",
            "# --- Port 80 and Service Check ---",
            `:log info "Checking www service and port 80...";`,
            `:local wwwService [/ip service find name="www"];`,
            `:if ([:len $wwwService] > 0) do={`,
            `    :local wwwPort [/ip service get $wwwService port];`,
            `    :if ($wwwPort = 80) do={`,
            `        :log info " WWW Service: Port 80 configured correctly";`,
            `    } else={`,
            `        :log error (" WWW Service: Port is " . $wwwPort . " instead of 80");`,
            `    }`,
            `} else={`,
            `    :log error " WWW Service: NOT FOUND";`,
            `}`,
            "",
            "# --- FINAL RECOMMENDATIONS ---",
            `:log info "=== BASED ON SUCCESSFUL COMMUNITY SOLUTIONS ===";`,
            `:log info "If you still get 'failed to update ssl certificate':";`,
            `:log info "1. MOST COMMON: DNS not propagated - wait 24 hours";`,
            `:log info "2. Port 80 blocked by ISP - contact ISP";`,
            `:log info "3. Behind NAT - forward port 80 to this router";`,
            `:log info "4. CGNAT - contact ISP for real IP";`,
            `:log info "5. Rate limited - wait 1 hour before retry";`,
            `:log info "";`,
            `:log info "TRY THE SIMPLE RENEWAL SCRIPT:";`,
            `:log info "Use SimpleLetsEncryptRenewal() function for a working solution";`,
            `:log info "=== Enhanced Diagnostic Completed ==="`,
        ],
    };

    return ScriptAndScheduler({
        ScriptContent: diagnosticScriptContent,
        Name: "LE-Enhanced-Diagnostic",
        interval: "1w",
        startTime: "startup",
    });
};

export const SimpleLetsEncryptRenewal = (
    dnsName: string = "auto-detect",
): RouterConfig => {
    // Create a simplified renewal script based on successful community solutions
    const simpleRenewalContent: RouterConfig = {
        "": [
            "# Simple Let's Encrypt Renewal - Based on ColinSlater's working solution",
            "# Reference: https://forum.mikrotik.com/viewtopic.php?t=189289",
            "",
            `:log info "=== Simple Let's Encrypt Renewal Started ===";`,
            "",
            "# Auto-detect DNS name if not specified",
            `:local dnsNameToUse "${dnsName}";`,
            `:if ($dnsNameToUse = "auto-detect") do={`,
            `    :set dnsNameToUse [/ip cloud get dns-name];`,
            `    :if ([:len $dnsNameToUse] = 0) do={`,
            `        :log error "No DNS name available. Enable cloud DDNS first.";`,
            `        :error "No DNS name";`,
            `    }`,
            `}`,
            `:log info ("Using DNS name: " . $dnsNameToUse);`,
            "",
            "# Step 1: Enable www service",
            `:log info "Enabling www service...";`,
            `/ip service enable [find name="www"];`,
            `:delay 3s;`,
            "",
            "# Step 2: Remove old certificate",
            `:log info "Removing old certificate...";`,
            `:local oldCert [/certificate find common-name=$dnsNameToUse];`,
            `:if ([:len $oldCert] > 0) do={`,
            `    /certificate remove $oldCert;`,
            `    :log info "Old certificate removed";`,
            `}`,
            `:delay 5s;`,
            "",
            "# Step 3: Request new certificate",
            `:log info "Requesting new certificate (this takes 60-90 seconds)...";`,
            `:do {`,
            `    /certificate enable-ssl-certificate dns-name=$dnsNameToUse;`,
            `    :delay 90s;`,
            `    `,
            `    # Get the new certificate name`,
            `    :local newCert [/certificate find common-name=$dnsNameToUse];`,
            `    :if ([:len $newCert] > 0) do={`,
            `        :local certName [/certificate get [:pick $newCert 0] name];`,
            `        :log info ("SUCCESS: Certificate created: " . $certName);`,
            `        `,
            `        # Apply to SSTP server`,
            `        /interface sstp-server server set certificate=$certName;`,
            `        :log info "Applied to SSTP server";`,
            `        `,
            `        # Apply to other services`,
            `        /ip service set www-ssl certificate=$certName;`,
            `        /ip service set api-ssl certificate=$certName;`,
            `        :log info "Applied to SSL services";`,
            `    } else={`,
            `        :log error "Certificate creation failed";`,
            `    }`,
            `} on-error={`,
            `    :log error "Certificate request failed - check diagnostic script results";`,
            `}`,
            "",
            "# Step 4: Disable www service for security",
            `:log info "Disabling www service...";`,
            `/ip service disable [find name="www"];`,
            "",
            `:log info "=== Simple Let's Encrypt Renewal Completed ===";`,
        ],
    };

    return ScriptAndScheduler({
        ScriptContent: simpleRenewalContent,
        Name: "Simple-LE-Renewal",
        interval: "1w",
        startTime: "04:00:00",
    });
};

export const DiagnosticLetsEncryptAdvanced = (): RouterConfig => {
    // Create an advanced diagnostic script based on successful forum solutions
    const advancedDiagnosticContent: RouterConfig = {
        "": [
            "# MikroTik RouterOS Advanced Let's Encrypt Diagnostic Script",
            "# Version 2.0 - Based on successful community solutions",
            "# Reference: https://forum.mikrotik.com/viewtopic.php?t=189289",
            "",
            `:log info "=== Advanced Let's Encrypt Diagnostic Script Started ===";`,
            "",
            "# --- Test 1: Internet Connectivity (Enhanced) ---",
            `:log info "Test 1: Enhanced internet connectivity check...";`,
            `:local ping1 [/ping 1.1.1.1 count=5];`,
            `:local ping2 [/ping 8.8.8.8 count=5];`,
            `:local ping3 [/ping 1.0.0.1 count=5];`,
            `:if ($ping1 > 2 || $ping2 > 2 || $ping3 > 2) do={`,
            `    :log info " Internet connectivity: GOOD - Multiple successful pings";`,
            `} else={`,
            `    :log error " Internet connectivity: POOR/FAILED - Insufficient successful pings";`,
            `    :log error "  This will cause Let's Encrypt to fail. Check internet connection.";`,
            `}`,
            "",
            "# --- Test 2: DNS Resolution (Multiple Tests) ---",
            `:log info "Test 2: Comprehensive DNS resolution testing...";`,
            `:local dnsWorking 0;`,
            `:local dnsTests {"www.mikrotik.com"; "google.com"; "letsencrypt.org"};`,
            `:foreach testDomain in=$dnsTests do={`,
            `    :do {`,
            `        :local resolved [:resolve $testDomain];`,
            `        :if ([:len $resolved] > 0) do={`,
            `            :log info (" DNS test: " . $testDomain . " resolves to " . $resolved);`,
            `            :set dnsWorking ($dnsWorking + 1);`,
            `        } else={`,
            `            :log error (" DNS test: " . $testDomain . " failed to resolve");`,
            `        }`,
            `    } on-error={`,
            `        :log error (" DNS test: " . $testDomain . " resolution error");`,
            `    }`,
            `}`,
            `:if ($dnsWorking >= 2) do={`,
            `    :log info (" DNS Resolution: GOOD - " . $dnsWorking . "/3 tests passed");`,
            `} else={`,
            `    :log error (" DNS Resolution: FAILED - Only " . $dnsWorking . "/3 tests passed");`,
            `}`,
            "",
            "# --- Test 3: Cloud DDNS Detailed Analysis ---",
            `:log info "Test 3: Detailed MikroTik Cloud DDNS analysis...";`,
            `:local cloudEnabled [/ip cloud get ddns-enabled];`,
            `:local cloudDnsName [/ip cloud get dns-name];`,
            `:local cloudStatus [/ip cloud get status];`,
            `:local cloudPublicAddress [/ip cloud get public-address];`,
            `:log info ("Cloud DDNS enabled: " . $cloudEnabled);`,
            `:log info ("Cloud status: " . $cloudStatus);`,
            `:log info ("Cloud public address: " . $cloudPublicAddress);`,
            `:log info ("Cloud DNS name: " . $cloudDnsName);`,
            `:if ($cloudEnabled && [:len $cloudDnsName] > 0 && $cloudStatus = "updated") do={`,
            `    :log info " Cloud DDNS: EXCELLENT - Fully operational";`,
            `} else={`,
            `    :log error " Cloud DDNS: ISSUES DETECTED";`,
            `    :if (!$cloudEnabled) do={`,
            `        :log error "  - Cloud DDNS is disabled. Enable with: /ip cloud set ddns-enabled=yes";`,
            `    }`,
            `    :if ([:len $cloudDnsName] = 0) do={`,
            `        :log error "  - No DNS name assigned. May need time or manual force-update.";`,
            `    }`,
            `    :if ($cloudStatus != "updated") do={`,
            `        :log error ("  - Cloud status is '" . $cloudStatus . "' instead of 'updated'");`,
            `    }`,
            `}`,
            "",
            "# --- Test 4: Critical DNS Propagation Test ---",
            `:if ([:len $cloudDnsName] > 0) do={`,
            `    :log info "Test 4: CRITICAL - DNS propagation verification...";`,
            `    :local ourPublicIp $cloudPublicAddress;`,
            `    :if ([:len $ourPublicIp] = 0) do={`,
            `        :do {`,
            `            :local fetchResult [/tool fetch url="http://api.ipify.org" mode=http as-value output=user];`,
            `            :if (($fetchResult->"status") = "finished") do={`,
            `                :set ourPublicIp ($fetchResult->"data");`,
            `                :while ([:len $ourPublicIp] > 0 && [:pick $ourPublicIp ([:len $ourPublicIp] - 1)] = "\\n") do={`,
            `                    :set ourPublicIp [:pick $ourPublicIp 0 ([:len $ourPublicIp] - 1)];`,
            `                }`,
            `            }`,
            `        } on-error={`,
            `            :log warning " Cannot determine public IP via external service";`,
            `        }`,
            `    }`,
            `    `,
            `    :if ([:len $ourPublicIp] > 0) do={`,
            `        :do {`,
            `            :local resolvedIp [:resolve $cloudDnsName];`,
            `            :if ($resolvedIp = $ourPublicIp) do={`,
            `                :log info (" DNS Propagation: PERFECT - " . $cloudDnsName . " correctly points to " . $ourPublicIp);`,
            `            } else={`,
            `                :log error (" DNS Propagation: CRITICAL FAILURE");`,
            `                :log error ("  Domain: " . $cloudDnsName);`,
            `                :log error ("  Resolves to: " . $resolvedIp);`,
            `                :log error ("  Should resolve to: " . $ourPublicIp);`,
            `                :log error ("  This WILL cause Let's Encrypt to fail!");`,
            `                :log error ("  Wait 1-24 hours for DNS propagation or check cloud DDNS.");`,
            `            }`,
            `        } on-error={`,
            `            :log error (" DNS Propagation: Cannot resolve " . $cloudDnsName);`,
            `            :log error "  This WILL cause Let's Encrypt to fail!";`,
            `        }`,
            `    } else={`,
            `        :log warning " Cannot verify DNS propagation - no public IP available";`,
            `    }`,
            `} else={`,
            `    :log error " Skipping DNS propagation test - no cloud DNS name available";`,
            `}`,
            "",
            "# --- Test 5: Port 80 Accessibility Test ---",
            `:log info "Test 5: Port 80 service and accessibility analysis...";`,
            `:local wwwService [/ip service find name="www"];`,
            `:if ([:len $wwwService] > 0) do={`,
            `    :local wwwDisabled [/ip service get $wwwService disabled];`,
            `    :local wwwPort [/ip service get $wwwService port];`,
            `    :local wwwAddress [/ip service get $wwwService address];`,
            `    :log info ("WWW Service port: " . $wwwPort);`,
            `    :log info ("WWW Service address restriction: " . $wwwAddress);`,
            `    :if (!$wwwDisabled) do={`,
            `        :log info " WWW Service: Currently enabled";`,
            `        :if ($wwwAddress != "0.0.0.0/0") do={`,
            `            :log warning (" WWW Service: Address restricted to " . $wwwAddress);`,
            `            :log warning "  This may prevent Let's Encrypt validation. Consider 0.0.0.0/0 during cert request.";`,
            `        }`,
            `    } else={`,
            `        :log info " WWW Service: Currently disabled (will be enabled during cert request)";`,
            `    }`,
            `    :if ($wwwPort != 80) do={`,
            `        :log error (" WWW Service: Port is " . $wwwPort . " instead of 80");`,
            `        :log error "  Let's Encrypt requires port 80. Change with: /ip service set www port=80";`,
            `    }`,
            `} else={`,
            `    :log error " WWW Service: NOT FOUND - This is required for ACME challenge";`,
            `}`,
            "",
            "# --- Test 6: Firewall Analysis (Enhanced) ---",
            `:log info "Test 6: Comprehensive firewall analysis for port 80...";`,
            `:local inputRules [/ip firewall filter find where chain="input"];`,
            `:local port80Rules [/ip firewall filter find where chain="input" and protocol="tcp" and dst-port=80];`,
            `:log info ("Total input chain rules: " . [:len $inputRules]);`,
            `:log info ("Port 80 specific rules: " . [:len $port80Rules]);`,
            `:if ([:len $port80Rules] > 0) do={`,
            `    :local acceptRules 0;`,
            `    :local dropRules 0;`,
            `    :local rulePosition 0;`,
            `    :foreach rule in=$inputRules do={`,
            `        :local ruleProto [/ip firewall filter get $rule protocol];`,
            `        :local ruleDstPort [/ip firewall filter get $rule dst-port];`,
            `        :local ruleAction [/ip firewall filter get $rule action];`,
            `        :if ($ruleProto = "tcp" && $ruleDstPort = 80) do={`,
            `            :local ruleComment [/ip firewall filter get $rule comment];`,
            `            :log info ("  Rule #" . $rulePosition . ": action=" . $ruleAction . ", comment=" . $ruleComment);`,
            `            :if ($ruleAction = "accept") do={`,
            `                :set acceptRules ($acceptRules + 1);`,
            `            }`,
            `            :if ($ruleAction = "drop" || $ruleAction = "reject") do={`,
            `                :set dropRules ($dropRules + 1);`,
            `            }`,
            `        }`,
            `        :set rulePosition ($rulePosition + 1);`,
            `    }`,
            `    :if ($acceptRules > 0) do={`,
            `        :log info (" Firewall: " . $acceptRules . " accept rule(s) found for port 80");`,
            `    } else={`,
            `        :log warning (" Firewall: No accept rules for port 80 (will add temporary during cert request)");`,
            `    }`,
            `    :if ($dropRules > 0) do={`,
            `        :log warning (" Firewall: " . $dropRules . " drop/reject rule(s) found - check rule order");`,
            `    }`,
            `} else={`,
            `    :log info " Firewall: No specific port 80 rules (will add temporary during cert request)";`,
            `}`,
            "",
            "# --- Test 7: Previous Certificate Analysis ---",
            `:log info "Test 7: Previous certificate analysis...";`,
            `:local allCerts [/certificate find];`,
            `:local leCerts [/certificate find where name~"letsencrypt"];`,
            `:local expiredCerts [/certificate find where expires-after~"expired"];`,
            `:log info ("Total certificates: " . [:len $allCerts]);`,
            `:log info ("Let's Encrypt certificates: " . [:len $leCerts]);`,
            `:log info ("Expired certificates: " . [:len $expiredCerts]);`,
            `:if ([:len $leCerts] > 0) do={`,
            `    :foreach cert in=$leCerts do={`,
            `        :local certName [/certificate get $cert name];`,
            `        :local certCN [/certificate get $cert common-name];`,
            `        :local certTrusted [/certificate get $cert trusted];`,
            `        :local certExpiry [/certificate get $cert expires-after];`,
            `        :log info ("  LE Cert: " . $certName . " (CN: " . $certCN . ", Trusted: " . $certTrusted . ", Expires: " . $certExpiry . ")");`,
            `        :if ($certCN = $cloudDnsName) do={`,
            `            :log warning (" Found existing certificate for " . $cloudDnsName . " - may need removal before renewal");`,
            `        }`,
            `    }`,
            `}`,
            "",
            "# --- Test 8: ISP and Network Analysis ---",
            `:log info "Test 8: ISP and network configuration analysis...";`,
            `:local wanInterfaces [/interface find where type="ether" and running];`,
            `:if ([:len $wanInterfaces] > 0) do={`,
            `    :foreach wanIf in=$wanInterfaces do={`,
            `        :local ifName [/interface get $wanIf name];`,
            `        :local wanAddresses [/ip address find interface=$ifName];`,
            `        :if ([:len $wanAddresses] > 0) do={`,
            `            :local wanIP [/ip address get [:pick $wanAddresses 0] address];`,
            `            :local wanIPOnly [:pick $wanIP 0 [:find $wanIP "/"]];`,
            `            :log info ("Interface " . $ifName . " IP: " . $wanIPOnly);`,
            `            # Check for CGNAT/private IP ranges`,
            `            :local firstOctet [:tonum [:pick $wanIPOnly 0 [:find $wanIPOnly "."]]];`,
            `            :if ($firstOctet = 10 || $firstOctet = 172 || $firstOctet = 192) do={`,
            `                :log warning (" Interface " . $ifName . " has private IP - router is behind NAT");`,
            `                :log warning "  Ensure port 80 is forwarded from public IP to this router";`,
            `            }`,
            `            :if ($firstOctet = 100) do={`,
            `                :local tempIP [:pick $wanIPOnly ([:find $wanIPOnly "."] + 1) [:len $wanIPOnly]];`,
            `                :local secondOctet [:tonum [:pick $tempIP 0 [:find $tempIP "."]]];`,
            `                :if ($secondOctet >= 64 && $secondOctet <= 127) do={`,
            `                    :log error (" Interface " . $ifName . " has CGNAT IP (100.64.x.x)");`,
            `                    :log error "  CGNAT prevents Let's Encrypt. Contact ISP or use different method.";`,
            `                }`,
            `            }`,
            `        }`,
            `    }`,
            `}`,
            "",
            "# --- Test 9: Rate Limiting and Timing Analysis ---",
            `:log info "Test 9: Rate limiting and timing guidance...";`,
            `:log info "Let's Encrypt rate limits (per domain):";`,
            `:log info "  - 50 certificates per registered domain per week";`,
            `:log info "  - 5 failed validations per account per hostname per hour";`,
            `:log info "  - 300 pending authorizations per account";`,
            `:log info "Rate limit recommendations:";`,
            `:log info "  - If you get rate limited, wait 1 hour before retry";`,
            `:log info "  - Use staging server for testing: acme-staging-v02.api.letsencrypt.org";`,
            `:log info "  - Don't retry failed requests immediately";`,
            "",
            "# --- FINAL DIAGNOSIS AND RECOMMENDATIONS ---",
            `:log info "=== FINAL DIAGNOSIS AND RECOMMENDATIONS ===";`,
            `:log info "Based on community solutions from MikroTik forums:";`,
            `:log info "";`,
            `:log info "CRITICAL SUCCESS FACTORS:";`,
            `:log info "1. DNS PROPAGATION: Your domain MUST resolve to your public IP";`,
            `:log info "2. PORT 80 ACCESS: Must be accessible from internet (check ISP/firewall)";`,
            `:log info "3. NO CGNAT: Router must have real public IP or proper port forwarding";`,
            `:log info "4. TIMING: Allow 60-90 seconds for certificate generation";`,
            `:log info "";`,
            `:log info "COMMON SOLUTIONS:";`,
            `:log info "1. Enable Cloud DDNS: /ip cloud set ddns-enabled=yes";`,
            `:log info "2. Force DNS update: /ip cloud force-update";`,
            `:log info "3. Wait for DNS propagation (up to 24 hours)";`,
            `:log info "4. Check ISP doesn't block port 80";`,
            `:log info "5. If behind router, forward port 80 to MikroTik";`,
            `:log info "6. Remove old certificates before renewal";`,
            `:log info "7. Use proper delays in renewal scripts (60-90s)";`,
            `:log info "";`,
            `:log info "NEXT STEPS:";`,
            `:log info "- Fix any issues marked with  above";`,
            `:log info "- Wait for DNS propagation if needed";`,
            `:log info "- Try certificate request manually first";`,
            `:log info "- Use simplified renewal script based on working community solutions";`,
            `:log info "=== Advanced Let's Encrypt Diagnostic Completed ===";`,
            "",
            "# Script will now self-destruct (scheduler removal handled automatically)",
        ],
    };

    return ScriptAndScheduler({
        ScriptContent: advancedDiagnosticContent,
        Name: "LE-Advanced-Diagnostic",
        interval: "1w",
        startTime: "05:00:00",
    });
};
