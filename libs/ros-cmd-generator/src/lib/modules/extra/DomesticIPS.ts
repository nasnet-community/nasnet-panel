import type { RouterConfig } from "@nas-net/ros-cmd-generator";
import { ScriptAndScheduler, OneTimeScript } from "@nas-net/ros-cmd-generator";
import type { FrequencyValue } from "@nas-net/star-context";


const generateUUID = (): string => {
    return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(
        /[xy]/g,
        function (c) {
            const r = (Math.random() * 16) | 0;
            const v = c === "x" ? r : (r & 0x3) | 0x8;
            return v.toString(16);
        },
    );
};

export const DomesticIPsScript: string[] = [
        "# ==============================================================================",
        "#  MikroTik Dynamic Address List Updater - With Source Routing",
        "# ==============================================================================",
        "# ==============================================================================",
        "# CONFIGURATION SECTION",
        "# ==============================================================================",
        "# API Configuration",
        ':local baseURL "https://s4i.co/irip"',
        ':local listName "DOMAddList"',
        ':local logPrefix "SecureListUpdate"',
        "",
        "# User Tracking Configuration",
        "# Leave empty to disable tracking",
    `:local userId "{{USER_ID}}"`,
        "",
        "# ========== SOURCE ROUTING CONFIGURATION ==========",
        "# Specify source address for all HTTP/HTTPS requests",
        "# This forces all fetch operations through the interface with this IP",
        ':local sourceAddress "192.168.39.12"',
        "# ==================================================",
        "",
        "# Pagination Configuration",
        ":local pageSize 1000",
        ":local maxPages 50",
        ":local batchSize 50",
        "",
        "# Retry Configuration",
        ":local maxRetries 10",
        "",
        "# ==============================================================================",
        "# HELPER FUNCTIONS",
        "# ==============================================================================",
        "",
        "# Function: Clean line endings",
        ":global cleanLine do={",
        "    :local line $1",
        '    :if ([:len $line] = 0) do={ :return "" }',
        "    # Remove CR",
        '    :if ([:pick $line ([:len $line] - 1)] = "\\r") do={',
        "        :set line [:pick $line 0 ([:len $line] - 1)]",
        "    }",
        "    # Trim leading spaces",
        '    :while (([:len $line] > 0) and ([:pick $line 0 1] = " ")) do={',
        "        :set line [:pick $line 1 [:len $line]]",
        "    }",
        "    # Trim trailing spaces",
        '    :while (([:len $line] > 0) and ([:pick $line ([:len $line] - 1)] = " ")) do={',
        "        :set line [:pick $line 0 ([:len $line] - 1)]",
        "    }",
        "    :return $line",
        "}",
        "",
        "# Function: Validate address",
        ":global validateAddr do={",
        "    :local addr $1",
        "    :local valid false",
        "    # Check for CIDR",
        '    :if ([:find $addr "/"] > 0) do={',
        '        :local slashPos [:find $addr "/"]',
        "        :local ipPart [:pick $addr 0 $slashPos]",
        "        :local maskPart [:pick $addr ($slashPos + 1) [:len $addr]]",
        "        :do {",
        "            [:toip $ipPart]",
        "            :local maskNum [:tonum $maskPart]",
        "            :if (($maskNum >= 0) and ($maskNum <= 32)) do={",
        "                :set valid true",
        "            }",
        "        } on-error={}",
        "    } else={",
        "        # Plain IP",
        "        :do {",
        "            [:toip $addr]",
        "            :set valid true",
        "        } on-error={}",
        "    }",
        "    :return $valid",
        "}",
        "",
        "# Function: Build URL with parameters",
        ":global buildURL do={",
        "    :local base $1",
        "    :local format $2",
        "    :local limit $3",
        "    :local offset $4",
        "    :local user $5",
        "    # Start with base URL and required parameters",
        '    :local url "$base\\?format=$format&limit=$limit&offset=$offset"',
        "    # Add user_id if provided",
        "    :if ([:len $user] > 0) do={",
        '        :set url "$url&user_id=$user"',
        "    }",
        "    :return $url",
        "}",
        "",
        "# ==============================================================================",
        "# MAIN SCRIPT",
        "# ==============================================================================",
        "",
        ':log info "$logPrefix: ========================================"',
        ':log info "$logPrefix: Starting Dynamic Address List Import"',
        ':log info "$logPrefix: Using source address: $sourceAddress"',
        "",
        "# Verify source address exists",
        ":local sourceValid false",
        ":do {",
        '    :local testIP [/ip address find where address~"^$sourceAddress/"]',
        "    :if ([:len $testIP] > 0) do={",
        "        :set sourceValid true",
        '        :log info "$logPrefix: Source address $sourceAddress verified"',
        "    }",
        "} on-error={}",
        "",
        ":if ($sourceValid = false) do={",
        '    :log warning "$logPrefix: Source address $sourceAddress not found on any interface!"',
        '    :log warning "$logPrefix: Proceeding with default routing..."',
        "}",
        "",
        "# Log user tracking status",
        ":if ([:len $userId] > 0) do={",
        '    :log info "$logPrefix: User tracking enabled: $userId"',
        "} else={",
        '    :log info "$logPrefix: User tracking disabled (no user_id configured)"',
        "}",
        "",
        ":local startTime [/system clock get time]",
        "",
        "# Clear existing list",
        ':log info "$logPrefix: Clearing existing entries..."',
        "/ip firewall address-list remove [find list=$listName]",
        "",
        "# Initialize counters",
        ":local totalAdded 0",
        ":local totalInvalid 0",
        ':local failedPages [:toarray ""]',
        ":local currentOffset 0",
        ":local pageNum 0",
        ":local hasMore true",
        "",
        "# ==============================================================================",
        "# MAIN PROCESSING LOOP",
        "# ==============================================================================",
        "",
        ":while (($pageNum < $maxPages) and ($hasMore = true)) do={",
        "    # Progress reporting",
        "    :if (($pageNum % 5) = 0) do={",
        '        :log info "$logPrefix: Processing pages $pageNum-$($pageNum + 4)... Total: $totalAdded"',
        "    }",
        "    ",
        "    # Build URL with user_id parameter",
        '    :local pageURL [$buildURL $baseURL "addresses" $pageSize $currentOffset $userId]',
        "    ",
        "    # Log the URL for first page (for debugging)",
        "    :if ($pageNum = 0) do={",
        '        :log info "$logPrefix: First request URL: $pageURL"',
        '        :log info "$logPrefix: Routing through: $sourceAddress"',
        "    }",
        "    ",
        "    # Fetch with retry logic",
        "    :local attempt 0",
        "    :local fetchSuccess false",
        '    :local pageContent ""',
        "    ",
        "    # Retry loop",
        "    :while (($attempt < $maxRetries) and ($fetchSuccess = false)) do={",
        "        :set attempt ($attempt + 1)",
        '        :log info "$logPrefix: Fetching page $pageNum (attempt $attempt/$maxRetries)..."',
        "        ",
        "        :do {",
        "            # Fetch command with source address",
        "            :local fetchResult",
        "            :if ($sourceValid = true) do={",
        "                # Use source address if valid",
        "                :set fetchResult [/tool fetch url=$pageURL \\",
        "                    mode=https \\",
        "                    check-certificate=no \\",
        "                    output=user \\",
        "                    src-address=$sourceAddress \\",
        "                    http-max-redirect-count=10 \\",
        "                    as-value]",
        "            } else={",
        "                # Fall back to default routing",
        "                :set fetchResult [/tool fetch url=$pageURL \\",
        "                    mode=https \\",
        "                    check-certificate=no \\",
        "                    output=user \\",
        "                    http-max-redirect-count=10 \\",
        "                    as-value]",
        "            }",
        "            ",
        '            :if (($fetchResult->"status") = "finished") do={',
        '                :set pageContent ($fetchResult->"data")',
        "                :set fetchSuccess true",
        '                :log info "$logPrefix: Page $pageNum fetched successfully"',
        "                ",
        "                # Check response headers if available (for debugging)",
        "                :if ($pageNum = 0) do={",
        '                    :log info "$logPrefix: First page fetched, checking for pagination headers..."',
        "                }",
        "            }",
        "        } on-error={",
        "            :if ($attempt < $maxRetries) do={",
        "                # Calculate delay",
        "                :local delayTime 5",
        "                :if ($attempt = 2) do={ :set delayTime 10 }",
        "                :if ($attempt = 3) do={ :set delayTime 10 }",
        "                :if ($attempt = 4) do={ :set delayTime 10 }",
        "                :if ($attempt = 5) do={ :set delayTime 10 }",
        '                :log warning "$logPrefix: Page $pageNum failed, retry in $delayTime seconds..."',
        '                :delay ($delayTime . "s")',
        "            } else={",
        '                :log error "$logPrefix: Page $pageNum failed after all attempts"',
        "            }",
        "        }",
        "    }",
        "    ",
        "    # Process page if successful",
        "    :if ($fetchSuccess = true) do={",
        "        :if ([:len $pageContent] < 100) do={",
        "            :set hasMore false",
        '            :log info "$logPrefix: End of data reached"',
        "        } else={",
        "            # Process content",
        '            :local batchCmd "/ip firewall address-list\\r\\n"',
        "            :local batchCount 0",
        "            :local lastEnd 0",
        "            :local contentSize [:len $pageContent]",
        "            ",
        "            :while ($lastEnd < $contentSize) do={",
        "                # Find line end",
        '                :local lineEnd [:find $pageContent "\\n" $lastEnd]',
        '                :if ([:typeof $lineEnd] = "nil") do={ ',
        "                    :set lineEnd $contentSize ",
        "                }",
        "                ",
        "                # Extract line",
        "                :local line [:pick $pageContent $lastEnd $lineEnd]",
        "                :set lastEnd ($lineEnd + 1)",
        "                ",
        "                # Clean line",
        "                :set line [$cleanLine $line]",
        "                ",
        "                # Skip empty lines and comments",
        "                :if ([:len $line] > 0) do={",
        '                    :if ([:pick $line 0 1] != "#") do={',
        "                        # Validate address",
        "                        :if ([$validateAddr $line] = true) do={",
        '                            :set batchCmd ($batchCmd . "add list=$listName address=$line comment=\\"$logPrefix-p$pageNum\\"\\r\\n")',
        "                            :set batchCount ($batchCount + 1)",
        "                            ",
        "                            # Execute batch when full",
        "                            :if ($batchCount >= $batchSize) do={",
        "                                :do {",
        "                                    [:parse $batchCmd]",
        "                                    :set totalAdded ($totalAdded + $batchCount)",
        "                                } on-error={",
        '                                    :log error "$logPrefix: Batch add failed on page $pageNum"',
        "                                }",
        "                                ",
        '                                :set batchCmd "/ip firewall address-list\\r\\n"',
        "                                :set batchCount 0",
        "                            }",
        "                        } else={",
        "                            :set totalInvalid ($totalInvalid + 1)",
        "                        }",
        "                    }",
        "                }",
        "            }",
        "            ",
        "            # Execute remaining batch",
        "            :if ($batchCount > 0) do={",
        "                :do {",
        "                    [:parse $batchCmd]",
        "                    :set totalAdded ($totalAdded + $batchCount)",
        "                } on-error={",
        '                    :log error "$logPrefix: Final batch failed on page $pageNum"',
        "                }",
        "            }",
        "            ",
        '            :log info "$logPrefix: Page $pageNum complete"',
        "        }",
        "    } else={",
        "        # Track failed page",
        "        :set failedPages ($failedPages, $pageNum)",
        '        :log error "$logPrefix: Page $pageNum will be retried later"',
        "    }",
        "    ",
        "    # Next page",
        "    :set currentOffset ($currentOffset + $pageSize)",
        "    :set pageNum ($pageNum + 1)",
        "    ",
        "    # Small delay between pages",
        "    :delay 10ms",
        "}",
        "",
        "# ==============================================================================",
        "# RETRY FAILED PAGES WITH EXTENDED TIMEOUTS",
        "# ==============================================================================",
        "",
        ":if ([:len $failedPages] > 0) do={",
        '    :log warning "$logPrefix: Retrying $[:len $failedPages] failed pages..."',
        "    ",
        "    :foreach failPage in=$failedPages do={",
        "        :delay 5s",
        "        ",
        '        :log info "$logPrefix: Retrying page $failPage with extended timeout..."',
        "        ",
        "        :local retryOffset ($failPage * $pageSize)",
        '        :local retryURL [$buildURL $baseURL "addresses" $pageSize $retryOffset $userId]',
        "        ",
        "        # Retry with manual timeout handling",
        "        :local retryCount 0",
        "        :local retrySuccess false",
        "        ",
        "        :while (($retryCount < 3) and ($retrySuccess = false)) do={",
        "            :set retryCount ($retryCount + 1)",
        "            ",
        '            :log info "$logPrefix: Page $failPage retry attempt $retryCount/3..."',
        "            ",
        "            # Use system scheduler to handle timeout",
        "            :local fetchStarted false",
        '            :local fetchData ""',
        "            ",
        "            :do {",
        "                # Try fetch with source address",
        "                :local fetchResult",
        "                :if ($sourceValid = true) do={",
        "                    # Use source address if valid",
        "                    :set fetchResult [/tool fetch url=$retryURL \\",
        "                        mode=https \\",
        "                        check-certificate=no \\",
        "                        output=user \\",
        "                        src-address=$sourceAddress \\",
        "                        http-max-redirect-count=10 \\",
        "                        as-value]",
        "                } else={",
        "                    # Fall back to default routing",
        "                    :set fetchResult [/tool fetch url=$retryURL \\",
        "                        mode=https \\",
        "                        check-certificate=no \\",
        "                        output=user \\",
        "                        http-max-redirect-count=10 \\",
        "                        as-value]",
        "                }",
        "                ",
        '                :if (($fetchResult->"status") = "finished") do={',
        '                    :set fetchData ($fetchResult->"data")',
        "                    :set fetchStarted true",
        "                }",
        "            } on-error={",
        '                :log error "$logPrefix: Page $failPage retry $retryCount failed"',
        "                :delay 10s",
        "            }",
        "            ",
        "            :if ($fetchStarted = true) do={",
        "                # Process the recovered page with batch processing like main loop",
        '                :local batchCmd "/ip firewall address-list\\r\\n"',
        "                :local batchCount 0",
        "                :local addedCount 0",
        "                :local invalidCount 0",
        "                :local lastEnd 0",
        "                :local contentSize [:len $fetchData]",
        "                ",
        "                :while ($lastEnd < $contentSize) do={",
        '                    :local lineEnd [:find $fetchData "\\n" $lastEnd]',
        '                    :if ([:typeof $lineEnd] = "nil") do={',
        "                        :set lineEnd $contentSize",
        "                    }",
        "                    ",
        "                    :local line [:pick $fetchData $lastEnd $lineEnd]",
        "                    :set lastEnd ($lineEnd + 1)",
        "                    ",
        "                    # Clean line",
        "                    :set line [$cleanLine $line]",
        "                    ",
        "                    # Skip empty lines and comments",
        "                    :if ([:len $line] > 0) do={",
        '                        :if ([:pick $line 0 1] != "#") do={',
        "                            # Validate address using the validation function",
        "                            :if ([$validateAddr $line] = true) do={",
        '                                :set batchCmd ($batchCmd . "add list=$listName address=$line comment=\\"$logPrefix-retry-p$failPage\\"\\r\\n")',
        "                                :set batchCount ($batchCount + 1)",
        "                                ",
        "                                # Execute batch when full",
        "                                :if ($batchCount >= $batchSize) do={",
        "                                    :do {",
        "                                        [:parse $batchCmd]",
        "                                        :set addedCount ($addedCount + $batchCount)",
        "                                    } on-error={",
        '                                        :log error "$logPrefix: Batch add failed on retry page $failPage"',
        "                                    }",
        '                                    :set batchCmd "/ip firewall address-list\\r\\n"',
        "                                    :set batchCount 0",
        "                                }",
        "                            } else={",
        "                                :set invalidCount ($invalidCount + 1)",
        "                            }",
        "                        }",
        "                    }",
        "                }",
        "                ",
        "                # Execute remaining batch",
        "                :if ($batchCount > 0) do={",
        "                    :do {",
        "                        [:parse $batchCmd]",
        "                        :set addedCount ($addedCount + $batchCount)",
        "                    } on-error={",
        '                        :log error "$logPrefix: Final batch failed on retry page $failPage"',
        "                    }",
        "                }",
        "                ",
        "                :set totalAdded ($totalAdded + $addedCount)",
        "                :set totalInvalid ($totalInvalid + $invalidCount)",
        "                :set retrySuccess true",
        '                :log info "$logPrefix: Page $failPage recovered: $addedCount entries added, $invalidCount invalid skipped"',
        "            }",
        "        }",
        "        ",
        "        :if ($retrySuccess = false) do={",
        '            :log error "$logPrefix: Page $failPage could not be recovered after 3 attempts"',
        "        }",
        "    }",
        "}",
        "",
        "# ==============================================================================",
        "# FINAL SUMMARY",
        "# ==============================================================================",
        "",
        ":local endTime [/system clock get time]",
        ":local finalCount [:len [/ip firewall address-list find list=$listName]]",
        "",
        ':log info "$logPrefix: ========================================"',
        ':log info "$logPrefix: IMPORT COMPLETE!"',
        ':log info "$logPrefix: Pages processed: $pageNum"',
        ':log info "$logPrefix: Failed pages: $[:len $failedPages]"',
        ':log info "$logPrefix: Valid entries added: $totalAdded"',
        ':log info "$logPrefix: Invalid entries skipped: $totalInvalid"',
        ':log info "$logPrefix: Actual firewall count: $finalCount"',
        ':log info "$logPrefix: Processing time: $startTime to $endTime"',
        "",
        "# Routing summary",
        ":if ($sourceValid = true) do={",
        '    :log info "$logPrefix: Source address used: $sourceAddress"',
        "} else={",
        '    :log info "$logPrefix: Default routing used (source address not found)"',
        "}",
        "",
        "# User tracking summary",
        ":if ([:len $userId] > 0) do={",
        '    :log info "$logPrefix: User ID: $userId"',
        "}",
        "",
        "# Success evaluation",
        ":if ($finalCount >= 40000) do={",
        '    :log info "$logPrefix: SUCCESS: All entries imported!"',
        "} else={",
        "    :if ($finalCount >= 38000) do={",
        '        :log info "$logPrefix: SUCCESS: Most entries imported ($finalCount/40000)"',
        "    } else={",
        "        :if ($finalCount >= 35000) do={",
        '            :log warning "$logPrefix: PARTIAL: $finalCount entries imported"',
        "        } else={",
        '            :log error "$logPrefix: WARNING: Only $finalCount entries imported"',
        "        }",
        "    }",
        "}",
        "",
        ':log info "$logPrefix: ========================================"',
        "",
        "# Cleanup functions",
        ":set cleanLine",
        ":set validateAddr",
        ":set buildURL",
    ];

export const generateDomesticIPScript = ( time: string, interval: FrequencyValue = "Daily" ): RouterConfig => {
    // Generate a unique UUID for this script instance
    const generatedUserId = generateUUID();

    const scriptCommands = DomesticIPsScript.map(line => 
        line.replace("{{USER_ID}}", generatedUserId)
    );


    // Create the RouterConfig with the script content
    const scriptContent: RouterConfig = {
        "": scriptCommands,
    };

    // Convert FrequencyValue to interval format
    const getIntervalValue = (frequency: FrequencyValue): string => {
        switch (frequency) {
            case "Daily":
                return "1d";
            case "Weekly":
                return "7d";
            case "Monthly":
                return "30d";
            default:
                return "1d";
        }
    };

    // Convert time from "HH:MM" to appropriate format and create scheduled script
    const [hour, minute] = time.split(":");
    const startTime = `${hour}:${minute}:00`;

    return ScriptAndScheduler({
        ScriptContent: scriptContent,
        Name: "DomesticIPUpdate",
        interval: getIntervalValue(interval),
        startTime: startTime,
    });
};

export const generateDomesticIPScriptOneTime = (): RouterConfig => {
    // Generate a unique UUID for this script instance
    const generatedUserId = generateUUID();

    const scriptCommands = [":delay 120s", ...DomesticIPsScript].map(line => 
        line.replace("{{USER_ID}}", generatedUserId)
    );



    // Create the RouterConfig with the script content
    const scriptContent: RouterConfig = {
        "": scriptCommands,
    };

    // Convert time from "HH:MM" to appropriate format


    return OneTimeScript({
        ScriptContent: scriptContent,
        name: "DomesticIPUpdate-OneTime",
        // interval: "00:00:00",
    });
};
