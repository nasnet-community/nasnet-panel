# Drift Detection Feature

Configuration drift occurs when the desired state stored in NasNet's configuration layer differs
from the actual state on the router. This happens when someone changes the router directly via SSH
or the RouterOS web interface, bypassing NasNet.

**Key files:**

- `libs/state/stores/src/drift-detection/useDriftDetection.ts` — core detection hook
- `libs/state/stores/src/drift-detection/useApplyConfirmDrift.ts` — Apply-Confirm-Merge integration
- `libs/state/stores/src/drift-detection/types.ts` — status enums, field types, options
- `libs/state/stores/src/drift-detection/driftUtils.ts` — hash computation, field diffing
- `libs/state/stores/src/drift-detection/reconciliationScheduler.ts` — polling scheduler

**Cross-references:**

- See `../architecture/data-flow.md` for the Universal State v2 8-layer model
- See `change-set-system.md` for applying changes that reconcile drift

---

## Drift Status Values

```typescript
const DriftStatus = {
  SYNCED: 'SYNCED', // Configuration matches router (green)
  DRIFTED: 'DRIFTED', // Configuration differs from router (amber)
  ERROR: 'ERROR', // Unable to determine status (red)
  CHECKING: 'CHECKING', // Check in progress
  PENDING: 'PENDING', // Resource not yet applied, no deployment data
};
```

---

## How Drift Is Detected

The Universal State v2 model stores each resource in 8 layers. Drift detection compares two of them:

- **Layer 3 (Configuration)** — the user's desired state, stored in NasNet's database
- **Layer 4 (Deployment)** — the state that was last applied to the router, including any fields
  generated by RouterOS

The comparison uses:

1. **Hash comparison** (fast path): SHA-based hash of normalized configuration vs. normalized
   deployment. Equal hashes = no drift, skips detailed diff.
2. **Field-level diff** (detail path): When hashes differ, `findDriftedFields` walks the objects and
   identifies exactly which fields changed.

Runtime-only fields are excluded from comparison (they fluctuate without user action):

```typescript
const RUNTIME_ONLY_FIELDS = [
  'bytesIn',
  'bytesOut',
  'packetsIn',
  'packetsOut',
  'txRate',
  'rxRate',
  'lastHandshake',
  'lastSeen',
  'connectedSince',
  'lastConnected',
  'uptime',
  'currentPeers',
  'activeConnections',
  'cpuLoad',
  'memoryUsage',
  'lastUpdated',
  'lastModified',
  'lastAccessed',
  'health',
  'status',
  'isRunning',
  'errorCount',
];
```

---

## Detection Hooks

### `useDriftDetection(input, options?)`

Primary hook for resource-level drift display. Memoized — only recomputes when input data changes.

```typescript
const { hasDrift, status, driftCount, result } = useDriftDetection({
  configuration: resource.configuration, // From Layer 3
  deployment: resource.deployment, // From Layer 4
  resourceType: resource.type, // For priority classification
});

// result.driftedFields contains field-level details
result.driftedFields.forEach((field) => {
  console.log(`${field.path}: was ${field.configValue}, router has ${field.deployValue}`);
});
```

Options:

```typescript
interface DriftDetectionOptions {
  excludeFields?: string[]; // Additional fields to skip
  deepCompare?: boolean; // Include nested objects (default: true)
  staleThreshold?: number; // Max age of deployment layer in ms (default: 30 min)
}
```

### `useQuickDriftCheck(configuration, deployment)`

Lightweight hook for list views — hash-only, no field-level diff. Use when you only need to know IF
drift exists, not WHAT drifted.

```typescript
const { hasDrift, status } = useQuickDriftCheck(resource.configuration, resource.deployment);
```

### `useBatchDriftStatus(resources)`

Check multiple resources at once. Returns a `Map<resourceUuid, DriftStatus>`.

```typescript
const statusMap = useBatchDriftStatus(resources);

resources.forEach((r) => {
  const status = statusMap.get(r.uuid);
  // Render drift indicator per resource
});
```

### `detectDrift(input, options?)` / `detectResourceDrift(resource, options?)`

Pure functions for one-off checks outside of React (e.g., in event handlers or machine actions).

```typescript
const result = detectResourceDrift(resource, { deepCompare: true });
if (result.hasDrift) {
  console.log(`${result.driftedFields.length} fields drifted`);
}
```

---

## DriftResult Structure

```typescript
interface DriftResult {
  hasDrift: boolean;
  status: DriftStatus;
  driftedFields: DriftedField[]; // Empty if no drift
  configurationHash: string; // Hash of config layer
  deploymentHash: string; // Hash of deployment layer
  lastChecked: Date;
  errorMessage?: string; // Set when status = ERROR
  isStale?: boolean; // Deployment older than staleThreshold
}

interface DriftedField {
  path: string; // JSON path, e.g., 'address.ip' or 'peers[0].endpoint'
  configValue: unknown; // What NasNet thinks it should be
  deployValue: unknown; // What the router actually has
  category?: 'network' | 'security' | 'general';
}
```

---

## Reconciliation Polling

`reconciliationScheduler.ts` implements priority-based polling to periodically fetch the actual
router state and update the deployment layer.

### Priority Tiers

| Priority | Interval   | Resource Types                              |
| -------- | ---------- | ------------------------------------------- |
| HIGH     | 5 minutes  | WAN, VPN, authentication                    |
| NORMAL   | 15 minutes | LAN, DHCP, firewall, NAT, routing, wireless |
| LOW      | 60 minutes | Logging, scripts, scheduler, backup, SNMP   |

Priority is determined by resource type prefix:

```typescript
const priority = getResourcePriority('vpn.wireguard'); // HIGH (5 min)
const priority = getResourcePriority('dhcp'); // NORMAL (15 min)
const priority = getResourcePriority('logging'); // LOW (60 min)
```

---

## Apply-Confirm-Merge Pattern

When a configuration change is applied to the router, the Apply-Confirm-Merge flow ensures the
deployment layer stays accurate:

```
1. Apply   — Send new configuration to router via GraphQL mutation
2. Confirm — Verify actual state from router (backend queries RouterOS)
3. Merge   — Store confirmed state in deployment layer (Layer 4)
4. Detect  — Recompute drift (should be SYNCED after successful apply)
```

### `useApplyConfirmDrift(options)`

Wraps any apply mutation to follow this pattern:

```typescript
const { applyWithConfirm, isApplying, lastResult } = useApplyConfirmDrift({
  applyFn: async (resourceUuid, configuration) => {
    const result = await client.mutate({
      mutation: APPLY_RESOURCE,
      variables: { uuid: resourceUuid, configuration },
    });
    return result.data.applyResource; // { success, deployment, resource }
  },
  confirmFn: async (resourceUuid) => {
    // Optional — if backend doesn't auto-confirm
    const result = await client.query({ query: GET_DEPLOYMENT, variables: { uuid: resourceUuid } });
    return result.data.deployment;
  },
  onDriftChange: (uuid, driftResult) => {
    if (driftResult.status === 'DRIFTED') {
      toast.warning('Drift detected after apply — router may not have accepted all changes');
    }
  },
  onApplySuccess: (uuid, result) => {
    toast.success('Configuration applied');
  },
  onApplyError: (uuid, error) => {
    toast.error(`Apply failed: ${error}`);
  },
});

// In your form submit handler:
const handleSave = async (newConfig) => {
  const result = await applyWithConfirm({ ...resource, configuration: newConfig });
  if (!result.success) {
    setFormError(result.error);
  }
};
```

---

## Drift Resolution

When drift is detected, the user can choose one of three actions:

| Action  | Description                                                       |
| ------- | ----------------------------------------------------------------- |
| REAPPLY | Re-send local configuration to router (overwrite router's change) |
| ACCEPT  | Accept router's current state as the new configuration            |
| DISMISS | Ignore this drift instance (it will appear again on next check)   |

### `useDriftResolution(options)`

```typescript
const { reapply, accept, isResolving, error } = useDriftResolution({
  reapplyFn: async (uuid, config) => {
    await client.mutate({ mutation: APPLY_RESOURCE, variables: { uuid, configuration: config } });
  },
  acceptFn: async (uuid, deployment) => {
    await client.mutate({
      mutation: UPDATE_CONFIGURATION,
      variables: { uuid, configuration: deployment.generatedFields },
    });
  },
  onResolved: (uuid, action) => {
    toast.success(`Drift resolved via ${action}`);
  },
});
```

---

## UI Patterns

### Drift Indicator in Lists

For resource list views, use the quick check to show a compact indicator:

```tsx
function ResourceRow({ resource }) {
  const { hasDrift, status } = useQuickDriftCheck(resource.configuration, resource.deployment);

  return (
    <tr>
      <td>{resource.name}</td>
      <td>{hasDrift && <DriftBadge status={status} />}</td>
    </tr>
  );
}
```

Drift badge colors follow semantic tokens:

- SYNCED → no badge (or hidden green checkmark)
- DRIFTED → amber warning badge with field count
- ERROR → red badge with error icon
- PENDING → gray badge ("Not yet applied")
- CHECKING → spinning indicator

### Drift Detail Panel

For resource detail views, use the full `useDriftDetection` to show field-level diff:

```tsx
function ResourceDriftPanel({ resource }) {
  const { hasDrift, result } = useDriftDetection({
    configuration: resource.configuration,
    deployment: resource.deployment,
  });

  if (!hasDrift) return null;

  return (
    <DriftPanel>
      <p>{result.driftedFields.length} fields differ from router</p>
      {result.driftedFields.map((field) => (
        <DriftField
          key={field.path}
          path={field.path}
          expected={field.configValue}
          actual={field.deployValue}
        />
      ))}
      <DriftResolutionActions resource={resource} />
    </DriftPanel>
  );
}
```

### Stale Deployment Warning

When `result.isStale` is true, the deployment layer is older than 30 minutes (the default
threshold). Show a warning:

```tsx
{
  result.isStale && (
    <Alert variant="warning">
      Router state was last checked {formatRelativeTime(resource.deployment.appliedAt)}. Drift data
      may be outdated.
    </Alert>
  );
}
```
