# Internationalization (i18n)

NasNetConnect uses **i18next** with `react-i18next` for internationalization. The setup supports multiple languages with lazy loading, RTL (right-to-left) layout support, and locale-aware formatting. English is bundled at build time; all other languages are loaded on demand via the HTTP backend.

**Source:** `libs/core/i18n/src/`

---

## Supported Languages

```typescript
// libs/core/i18n/src/i18n.ts
export const supportedLanguages = ['en', 'fa'] as const;
export type SupportedLanguage = (typeof supportedLanguages)[number];

export const languageNames: Record<SupportedLanguage, string> = {
  en: 'English',
  fa: 'فارسی',
};
```

Persian (`fa`) is a right-to-left language. The RTL list drives automatic document direction changes:

```typescript
export const rtlLanguages: readonly SupportedLanguage[] = ['fa'];
```

---

## i18next Configuration

The instance is initialized in `libs/core/i18n/src/i18n.ts` and uses three plugins:

| Plugin | Purpose |
|--------|---------|
| `i18next-http-backend` | Lazy-loads translation JSON files from `/locales/{{lng}}/{{ns}}.json` |
| `i18next-browser-languagedetector` | Detects language from `localStorage` then browser `navigator` settings |
| `react-i18next` | React bindings and Suspense support |

### Key configuration

```typescript
i18n.init({
  fallbackLng: 'en',          // English always available as fallback
  supportedLngs: supportedLanguages,

  // Namespaces loaded on app start
  ns: defaultNamespaces,       // ['common', 'validation', 'errors']
  defaultNS: 'common',

  // Language detection
  detection: {
    order: ['localStorage', 'navigator'],
    caches: ['localStorage'],
    lookupLocalStorage: 'nasnet-language',  // storage key
  },

  // HTTP backend for lazy loading
  backend: {
    loadPath: '/locales/{{lng}}/{{ns}}.json',
  },

  interpolation: {
    escapeValue: false,  // React handles escaping
  },

  react: {
    useSuspense: true,   // Suspend while loading language packs
  },

  // Development helpers
  debug: import.meta.env.DEV,
  saveMissing: import.meta.env.DEV,  // console.warn on missing keys
});
```

---

## Namespace Strategy

### Default namespaces (loaded at startup)

| Namespace | Purpose |
|-----------|---------|
| `common` | Global UI strings: navigation, buttons, status labels, table text, dialogs |
| `validation` | Form validation error messages |
| `errors` | API and application error messages |

### Feature namespaces (loaded on demand)

| Namespace | Contents |
|-----------|---------|
| `wizard` | Setup wizard: navigation, step labels |
| `network` | Interfaces, ARP, DHCP, DNS, routes, VLANs |
| `dashboard` | Bandwidth charts, resource gauges, log widgets |
| `vpn` | VPN servers, clients, protocols, connection status |
| `wifi` | Wireless interfaces, client list, security settings |
| `firewall` | Filter rules, NAT, mangle, raw, address lists |
| `services` | Feature marketplace, service management, templates |
| `diagnostics` | Ping, traceroute, DNS lookup, troubleshoot wizard |
| `router` | Router discovery, panel, overview, health checks |

Feature namespaces are loaded automatically by `useTranslation` when a component first uses them. React Suspense handles the loading state via the `I18nProvider`.

---

## Providers

### I18nProvider

Wraps the application with `I18nextProvider` and a Suspense boundary. Place it near the top of the component tree in `main.tsx`.

```tsx
// libs/core/i18n/src/I18nProvider.tsx
import { I18nProvider, DirectionProvider } from '@nasnet/core/i18n';

// In main.tsx
<I18nProvider loadingFallback={<LoadingSpinner />}>
  <DirectionProvider>
    <App />
  </DirectionProvider>
</I18nProvider>
```

Props:

| Prop | Type | Default | Description |
|------|------|---------|-------------|
| `children` | `ReactNode` | required | Components to wrap |
| `loadingFallback` | `ReactNode` | `null` | Shown while language pack loads |

### DirectionProvider

Automatically manages the HTML `dir` and `lang` attributes as the language changes. It also provides a React context so components can read the current direction.

```tsx
// libs/core/i18n/src/DirectionProvider.tsx
export function DirectionProvider({ children }: DirectionProviderProps) {
  const { i18n } = useTranslation();
  const currentLanguage = i18n.language;
  const isRTL = isRTLLanguage(currentLanguage);
  const direction: Direction = isRTL ? 'rtl' : 'ltr';

  useEffect(() => {
    const html = document.documentElement;
    html.dir = direction;        // e.g. "rtl"
    html.lang = currentLanguage; // e.g. "fa"
    html.setAttribute('data-direction', direction);
  }, [direction, currentLanguage]);

  return <DirectionContext.Provider value={{ direction, isRTL }}>
    {children}
  </DirectionContext.Provider>;
}
```

**Must be placed after `I18nProvider`** in the tree — it reads the i18n context.

---

## Hooks

All hooks are exported from `@nasnet/core/i18n`.

### useTranslation

Typed wrapper around `react-i18next`'s `useTranslation`. Accepts a `TranslationNamespace` or array of namespaces.

```tsx
import { useTranslation } from '@nasnet/core/i18n';

// Single namespace
function Dashboard() {
  const { t } = useTranslation('dashboard');
  return <h1>{t('widgets.bandwidth.title')}</h1>;
}

// Multiple namespaces — first namespace is the default
function Form() {
  const { t } = useTranslation(['common', 'validation']);
  return <p>{t('button.save')}</p>;
}
```

For complex interpolations with JSX children, use the `Trans` component:

```tsx
import { Trans } from '@nasnet/core/i18n';

<Trans i18nKey="welcome.message">
  Welcome, <strong>{{ name }}</strong>
</Trans>
```

### useDirection

Returns the current text direction from `DirectionProvider`. Use for direction-aware layout logic.

```tsx
import { useDirection } from '@nasnet/core/i18n';

function ContentLayout() {
  const { direction, isRTL } = useDirection();

  return (
    <div style={{ textAlign: isRTL ? 'right' : 'left' }}>
      Content
    </div>
  );
}
```

### useFormatters

Returns locale-aware formatting functions. Results are memoized and update when the active language changes.

```tsx
import { useFormatters } from '@nasnet/core/i18n';

function StatusDisplay({ lastSeen, bytesTransferred, uptimeSeconds }) {
  const { formatDate, formatBytes, formatDuration, formatRelativeTime, formatBandwidth } = useFormatters();

  return (
    <div>
      <p>Last seen: {formatRelativeTime(lastSeen)}</p>
      <p>Transferred: {formatBytes(bytesTransferred)}</p>
      <p>Uptime: {formatDuration(uptimeSeconds)}</p>
      <p>Updated: {formatDate(new Date(), { includeTime: true })}</p>
    </div>
  );
}
```

Available formatters:

| Function | Input | Example output |
|----------|-------|----------------|
| `formatDate(date, options?)` | `Date \| string \| number` | `"January 15, 2024"` |
| `formatNumber(value, options?)` | `number` | `"1,234.5"` |
| `formatBytes(bytes, decimals?)` | `number` | `"2.50 MB"` |
| `formatDuration(seconds)` | `number` | `"2h 30m 15s"` |
| `formatRelativeTime(date, options?)` | `Date \| string \| number` | `"5 minutes ago"` |
| `formatBandwidth(bitsPerSecond)` | `number` | `"5.25 Mbps"` |

> **Note:** Technical data such as IP addresses, MAC addresses, and port numbers must NOT use locale-specific formatting — they must remain in universal format. Only human-readable quantities (dates, byte sizes, bandwidth) go through `useFormatters`.

---

## Translation Key Organization

Translation files live at `libs/core/i18n/src/locales/{lang}/{namespace}.json`.

### Key naming conventions

Use dot-separated hierarchical keys organized by UI concept:

```json
// common.json
{
  "header": {
    "navigation": {
      "dashboard": "Dashboard",
      "network": "Network"
    }
  },
  "button": {
    "save": "Save",
    "cancel": "Cancel"
  },
  "status": {
    "online": "Online",
    "offline": "Offline"
  }
}
```

### Pluralization

i18next handles pluralization via the `_other` suffix:

```json
{
  "time": {
    "seconds": "{{count}} second",
    "seconds_other": "{{count}} seconds"
  }
}
```

```tsx
t('time.seconds', { count: 1 })  // "1 second"
t('time.seconds', { count: 5 })  // "5 seconds"
```

### Interpolation

Use `{{variable}}` syntax inside translation values:

```json
{
  "time": {
    "ago": "{{time}} ago",
    "in": "in {{time}}"
  }
}
```

---

## Adding a New Language

1. Create a folder at `libs/core/i18n/src/locales/{lang}/`
2. Add a JSON file for each namespace (start with `common.json`, `validation.json`, `errors.json`)
3. Add the language code to `supportedLanguages` in `i18n.ts`
4. Add the language's display name to `languageNames`
5. If RTL, add the code to `rtlLanguages`
6. Copy the English files as a translation template

```typescript
// i18n.ts — add new language
export const supportedLanguages = ['en', 'fa', 'ar'] as const;

export const rtlLanguages: readonly SupportedLanguage[] = ['fa', 'ar'];

export const languageNames: Record<SupportedLanguage, string> = {
  en: 'English',
  fa: 'فارسی',
  ar: 'العربية',
};
```

The HTTP backend will load the new locale files on demand from `/locales/ar/common.json`, etc.

---

## Adding Translations to a Component

```tsx
// 1. Use the correct namespace for the feature
const { t } = useTranslation('network');

// 2. Add keys to the English file first
// libs/core/i18n/src/locales/en/network.json
{
  "interfaces": {
    "title": "Network Interfaces",
    "columns": {
      "name": "Interface Name",
      "status": "Status"
    }
  }
}

// 3. Add keys to the Persian file
// libs/core/i18n/src/locales/fa/network.json
{
  "interfaces": {
    "title": "رابط‌های شبکه",
    "columns": {
      "name": "نام رابط",
      "status": "وضعیت"
    }
  }
}

// 4. Use in component
<h1>{t('interfaces.title')}</h1>
<th>{t('interfaces.columns.name')}</th>
```

In development, missing translation keys are logged to the console:
```
[i18n] Missing translation: network:interfaces.newKey (lang: en)
```

---

## Language Detection

The detection order is:

1. **localStorage** — Key `nasnet-language`. If the user has previously selected a language, this is used.
2. **Browser navigator** — Falls back to the browser's language preference.
3. **Fallback** — English (`en`) if no supported language is detected.

To change the active language programmatically:

```tsx
import { i18n } from '@nasnet/core/i18n';

// Change language (persisted to localStorage automatically)
await i18n.changeLanguage('fa');
```

---

## Utility Functions

```typescript
import { isRTLLanguage, getLanguageDirection } from '@nasnet/core/i18n';

isRTLLanguage('fa')          // true
isRTLLanguage('en')          // false
isRTLLanguage('unknown')     // false

getLanguageDirection('fa')   // 'rtl'
getLanguageDirection('en')   // 'ltr'
```

These are pure functions with no React dependency — safe to use outside components.

---

## See Also

- `Docs/architecture/implementation-patterns/17-localization-patterns.md` — Architecture decisions
- `libs/core/i18n/src/i18n.test.ts` — Unit tests for utility functions
- `libs/core/i18n/src/hooks/useFormatters.test.ts` — Formatter tests
