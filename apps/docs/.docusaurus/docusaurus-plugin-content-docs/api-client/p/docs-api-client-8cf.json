{"version":{"pluginId":"api-client","version":"current","label":"Next","banner":null,"badge":false,"noIndex":false,"className":"docs-version-current","isLast":true,"docsSidebars":{"sidebar":[{"type":"link","href":"/docs/api-client/intro","label":"API Client — Overview","docId":"intro","unlisted":false},{"type":"link","href":"/docs/api-client/apollo-client","label":"Apollo Client","docId":"apollo-client","unlisted":false},{"type":"link","href":"/docs/api-client/axios-http-client","label":"Axios HTTP Client","docId":"axios-http-client","unlisted":false},{"type":"link","href":"/docs/api-client/authentication","label":"Authentication","docId":"authentication","unlisted":false},{"type":"link","href":"/docs/api-client/error-handling","label":"Error Handling","docId":"error-handling","unlisted":false},{"type":"link","href":"/docs/api-client/offline-first","label":"Offline-First Architecture","docId":"offline-first","unlisted":false},{"type":"link","href":"/docs/api-client/universal-state-resource-model","label":"Universal State v2 Resource Model","docId":"universal-state-resource-model","unlisted":false},{"type":"link","href":"/docs/api-client/change-set-pattern","label":"Change Set Pattern","docId":"change-set-pattern","unlisted":false},{"type":"link","href":"/docs/api-client/graphql-schema-contracts","label":"GraphQL Schema Contracts — Scalars and Directives","docId":"graphql-schema-contracts","unlisted":false},{"type":"link","href":"/docs/api-client/tanstack-query-modules","label":"TanStack Query Modules — REST-Only Endpoints","docId":"tanstack-query-modules","unlisted":false},{"type":"link","href":"/docs/api-client/notifications-webhooks","label":"Notifications and Webhooks — Alert Delivery Integration","docId":"notifications-webhooks","unlisted":false},{"type":"link","href":"/docs/api-client/domain-query-hooks","label":"Domain Query Hooks","docId":"domain-query-hooks","unlisted":false},{"type":"link","href":"/docs/api-client/service-lifecycle","label":"Service Lifecycle","docId":"service-lifecycle","unlisted":false},{"type":"link","href":"/docs/api-client/testing-and-codegen","label":"Testing and Code Generation","docId":"testing-and-codegen","unlisted":false},{"type":"link","href":"/docs/api-client/websocket-subscriptions","label":"WebSocket Subscriptions","docId":"websocket-subscriptions","unlisted":false}]},"docs":{"apollo-client":{"id":"apollo-client","title":"Apollo Client","description":"This document covers the complete Apollo Client infrastructure in libs/api-client/core/src/apollo/. The Apollo layer handles all GraphQL communication: queries, mutations, and real-time subscriptions via WebSocket. It provides an intelligent link chain, a carefully tuned normalized cache, offline-first cache persistence, and React provider integration for both production and test environments.","sidebar":"sidebar"},"authentication":{"id":"authentication","title":"Authentication","description":"NasNetConnect uses two parallel authentication systems that operate independently: an Apollo auth link for GraphQL operations and an Axios interceptor for REST API calls. Both systems share the same JWT-first, Basic-fallback priority but differ in credential storage scope — the Apollo link uses per-router sessionStorage keys while the Axios interceptor uses a global localStorage key. Authentication for WebSocket subscriptions is handled separately via connectionParams on every connect/reconnect cycle.","sidebar":"sidebar"},"axios-http-client":{"id":"axios-http-client","title":"Axios HTTP Client","description":"This document covers the Axios-based HTTP client infrastructure in libs/api-client/core/src/. The Axios layer serves two purposes: a general-purpose REST API client for the NasNet backend (/api/v1), and a router proxy client that tunnels RouterOS REST API calls through the Go backend to avoid browser CORS restrictions.","sidebar":"sidebar"},"change-set-pattern":{"id":"change-set-pattern","title":"Change Set Pattern","description":"A Change Set is an ordered, atomic batch of resource operations (creates, updates, and deletes) that must all succeed or all roll back together. Rather than applying individual mutations one at a time and hoping the router ends up in a consistent state, a Change Set lets UI flows compose several operations — create a bridge, add a DHCP server, write three firewall rules — and commit them in a single transactional unit. The libs/api-client/queries/src/change-set/ module provides GraphQL fragments, query hooks, mutation hooks, and real-time subscription hooks that implement every stage of this lifecycle.","sidebar":"sidebar"},"domain-query-hooks":{"id":"domain-query-hooks","title":"Domain Query Hooks","description":"This document is a complete reference for the domain-specific query hooks in libs/api-client/queries/src/. It covers the common conventions that all domains share (router-IP/router-ID parameter, *.graphql.ts document files, queryKeys / queryKey factories), then provides a full inventory table across all domains with hook counts, followed by detailed per-domain sections.","sidebar":"sidebar"},"error-handling":{"id":"error-handling","title":"Error Handling","description":"NasNetConnect's error handling is a multi-layer pipeline that transforms raw protocol errors into structured, user-friendly feedback. The system covers GraphQL errors from Apollo, network-level failures from both Apollo and Axios, component-level error display, and structured error logging with deduplication and batching. The entire pipeline is coordinated by three cooperating modules: the Apollo error link, the error message taxonomy, and the error logging utility — complemented by React hooks that bring structured errors into the component layer.","sidebar":"sidebar"},"graphql-schema-contracts":{"id":"graphql-schema-contracts","title":"GraphQL Schema Contracts — Scalars and Directives","description":"This document covers the custom scalars and GraphQL directives that define the schema contract between the NasNet backend and frontend. Understanding these types and directives is essential for writing type-safe queries and leveraging the code generation pipeline.","sidebar":"sidebar"},"intro":{"id":"intro","title":"API Client — Overview","description":"The libs/api-client library is the single point of entry for all network communication in NasNetConnect. It provides two transport layers — a GraphQL Apollo Client for the main application data model and an Axios HTTP client for REST calls and direct RouterOS access — along with generated TypeScript types, Zod validation schemas, and a rich set of domain query hooks organized by feature area.","sidebar":"sidebar"},"notifications-webhooks":{"id":"notifications-webhooks","title":"Notifications and Webhooks — Alert Delivery Integration","description":"This document covers the webhook management system that integrates with the alerts feature. Webhooks","sidebar":"sidebar"},"offline-first":{"id":"offline-first","title":"Offline-First Architecture","description":"NasNetConnect operates in environments where network connectivity to the MikroTik router is inherently unstable — server rooms, mobile devices, and embedded containers. The offline-first system ensures the UI remains functional and consistent across degraded and fully disconnected states. It is composed of three cooperating modules: cache persistence (Apollo InMemoryCache → IndexedDB via localforage), offline detection (four signal sources converging to a Zustand network store), and an offline mutation queue (FIFO, deduplicated, auto-replaying queue backed by IndexedDB). Together they allow the app to serve cached data immediately on load, detect connectivity changes within seconds, and defer mutations until the connection is restored.","sidebar":"sidebar"},"service-lifecycle":{"id":"service-lifecycle","title":"Service Lifecycle","description":"This document covers the complete lifecycle of a Feature Marketplace service instance — from discovery and installation through boot, health monitoring, configuration, networking/isolation, dependency management, traffic control, logging, updates, rollback, sharing/templates, device routing, scheduling, and system resource budgeting. All hooks live under libs/api-client/queries/src/services/.","sidebar":"sidebar"},"tanstack-query-modules":{"id":"tanstack-query-modules","title":"TanStack Query Modules — REST-Only Endpoints","description":"While the majority of NasNetConnect uses Apollo Client for GraphQL, there are three specialized domains that communicate with REST-only endpoints and require TanStack Query (React Query) instead: batch jobs, OUI/MAC vendor lookups, and connection testing. This document covers each module, their caching strategies, and when to use them.","sidebar":"sidebar"},"testing-and-codegen":{"id":"testing-and-codegen","title":"Testing and Code Generation","description":"This document covers how to test Apollo Client hooks in NasNetConnect, how the graphql-codegen pipeline transforms GraphQL schema and operations into TypeScript types and React hooks, how possibleTypes enables polymorphic type resolution, how Zod schemas integrate with react-hook-form, and the step-by-step process for adding a brand-new domain.","sidebar":"sidebar"},"universal-state-resource-model":{"id":"universal-state-resource-model","title":"Universal State v2 Resource Model","description":"The Universal State v2 model is the core abstraction for every managed object in NasNetConnect.","sidebar":"sidebar"},"websocket-subscriptions":{"id":"websocket-subscriptions","title":"WebSocket Subscriptions","description":"This document covers the real-time subscription layer of @nasnet/api-client: how the WebSocket client is created and configured, how split-link routing directs subscription operations to the WebSocket transport while keeping queries and mutations on HTTP, how authentication is provided per-connection, how the retry/reconnect strategy works, and how connection lifecycle events flow into the Zustand stores and the offline detector.","sidebar":"sidebar"}}}}