{"version":{"pluginId":"frontend","version":"current","label":"Next","banner":null,"badge":false,"noIndex":false,"className":"docs-version-current","isLast":true,"docsSidebars":{"sidebar":[{"type":"link","href":"/docs/frontend/","label":"Documentation Index","docId":"README","unlisted":false},{"type":"link","href":"/docs/frontend/intro","label":"Introduction","docId":"intro","unlisted":false},{"type":"category","label":"architecture","collapsible":true,"collapsed":true,"items":[{"type":"link","href":"/docs/frontend/architecture/build-system","label":"Build System","docId":"architecture/build-system","unlisted":false},{"type":"link","href":"/docs/frontend/architecture/library-dependencies","label":"Monorepo Library Dependency Graph","docId":"architecture/library-dependencies","unlisted":false},{"type":"link","href":"/docs/frontend/architecture/overview","label":"Architecture Overview","docId":"architecture/overview","unlisted":false},{"type":"link","href":"/docs/frontend/architecture/provider-stack","label":"Provider Stack Deep Dive","docId":"architecture/provider-stack","unlisted":false},{"type":"link","href":"/docs/frontend/architecture/routing","label":"Routing — TanStack Router","docId":"architecture/routing","unlisted":false}]},{"type":"category","label":"cross-cutting-features","collapsible":true,"collapsed":true,"items":[{"type":"link","href":"/docs/frontend/cross-cutting-features/alerts-system","label":"Alerts System","docId":"cross-cutting-features/alerts-system","unlisted":false},{"type":"link","href":"/docs/frontend/cross-cutting-features/change-set-system","label":"Change Set System","docId":"cross-cutting-features/change-set-system","unlisted":false},{"type":"link","href":"/docs/frontend/cross-cutting-features/configuration-import","label":"Configuration Import","docId":"cross-cutting-features/configuration-import","unlisted":false},{"type":"link","href":"/docs/frontend/cross-cutting-features/drift-detection-feature","label":"Drift Detection Feature","docId":"cross-cutting-features/drift-detection-feature","unlisted":false},{"type":"link","href":"/docs/frontend/cross-cutting-features/router-connection","label":"Router Connection","docId":"cross-cutting-features/router-connection","unlisted":false},{"type":"link","href":"/docs/frontend/cross-cutting-features/service-marketplace","label":"Service Marketplace","docId":"cross-cutting-features/service-marketplace","unlisted":false},{"type":"link","href":"/docs/frontend/cross-cutting-features/virtual-interface-factory","label":"Virtual Interface Factory (VIF)","docId":"cross-cutting-features/virtual-interface-factory","unlisted":false}]},{"type":"category","label":"data-fetching","collapsible":true,"collapsed":true,"items":[{"type":"link","href":"/docs/frontend/data-fetching/codegen","label":"GraphQL Code Generation","docId":"data-fetching/codegen","unlisted":false},{"type":"link","href":"/docs/frontend/data-fetching/graphql-hooks","label":"GraphQL Hooks","docId":"data-fetching/graphql-hooks","unlisted":false},{"type":"link","href":"/docs/frontend/data-fetching/offline-support","label":"Offline Support","docId":"data-fetching/offline-support","unlisted":false},{"type":"link","href":"/docs/frontend/data-fetching/overview","label":"Data Fetching Overview","docId":"data-fetching/overview","unlisted":false},{"type":"link","href":"/docs/frontend/data-fetching/rest-client","label":"REST Client","docId":"data-fetching/rest-client","unlisted":false}]},{"type":"category","label":"feature-modules","collapsible":true,"collapsed":true,"items":[{"type":"link","href":"/docs/frontend/feature-modules/dashboard","label":"Dashboard Feature","docId":"feature-modules/dashboard","unlisted":false},{"type":"link","href":"/docs/frontend/feature-modules/diagnostics","label":"Diagnostics Feature Module","docId":"feature-modules/diagnostics","unlisted":false},{"type":"link","href":"/docs/frontend/feature-modules/firewall","label":"Firewall Feature","docId":"feature-modules/firewall","unlisted":false},{"type":"link","href":"/docs/frontend/feature-modules/logs","label":"Logs Feature Module","docId":"feature-modules/logs","unlisted":false},{"type":"link","href":"/docs/frontend/feature-modules/network","label":"Network Feature","docId":"feature-modules/network","unlisted":false},{"type":"link","href":"/docs/frontend/feature-modules/services","label":"Services Feature Module","docId":"feature-modules/services","unlisted":false},{"type":"link","href":"/docs/frontend/feature-modules/vpn","label":"VPN Feature","docId":"feature-modules/vpn","unlisted":false},{"type":"link","href":"/docs/frontend/feature-modules/wireless","label":"Wireless Feature Module","docId":"feature-modules/wireless","unlisted":false}]},{"type":"category","label":"forms-validation","collapsible":true,"collapsed":true,"items":[{"type":"link","href":"/docs/frontend/forms-validation/form-utilities","label":"Form Utilities","docId":"forms-validation/form-utilities","unlisted":false},{"type":"link","href":"/docs/frontend/forms-validation/network-validators","label":"Network Validators","docId":"forms-validation/network-validators","unlisted":false},{"type":"link","href":"/docs/frontend/forms-validation/overview","label":"Forms and Validation Overview","docId":"forms-validation/overview","unlisted":false},{"type":"link","href":"/docs/frontend/forms-validation/validation-pipeline","label":"Validation Pipeline","docId":"forms-validation/validation-pipeline","unlisted":false},{"type":"link","href":"/docs/frontend/forms-validation/wizard-forms","label":"Wizard Forms","docId":"forms-validation/wizard-forms","unlisted":false}]},{"type":"category","label":"getting-started","collapsible":true,"collapsed":true,"items":[{"type":"link","href":"/docs/frontend/getting-started/overview","label":"Overview","docId":"getting-started/overview","unlisted":false},{"type":"link","href":"/docs/frontend/getting-started/environment-setup","label":"Environment Setup","docId":"getting-started/environment-setup","unlisted":false},{"type":"link","href":"/docs/frontend/getting-started/project-structure","label":"Project Structure","docId":"getting-started/project-structure","unlisted":false},{"type":"link","href":"/docs/frontend/getting-started/key-commands","label":"Key Commands","docId":"getting-started/key-commands","unlisted":false}]},{"type":"category","label":"i18n-accessibility","collapsible":true,"collapsed":true,"items":[{"type":"link","href":"/docs/frontend/i18n-accessibility/accessibility","label":"Accessibility","docId":"i18n-accessibility/accessibility","unlisted":false},{"type":"link","href":"/docs/frontend/i18n-accessibility/i18n","label":"Internationalization (i18n)","docId":"i18n-accessibility/i18n","unlisted":false}]},{"type":"category","label":"operations","collapsible":true,"collapsed":true,"items":[{"type":"link","href":"/docs/frontend/operations/development-workflow","label":"Development Workflow","docId":"operations/development-workflow","unlisted":false},{"type":"link","href":"/docs/frontend/operations/performance","label":"Performance Guide","docId":"operations/performance","unlisted":false},{"type":"link","href":"/docs/frontend/operations/storybook","label":"Storybook Guide","docId":"operations/storybook","unlisted":false}]},{"type":"category","label":"state-management","collapsible":true,"collapsed":true,"items":[{"type":"link","href":"/docs/frontend/state-management/apollo-client","label":"Apollo Client Configuration","docId":"state-management/apollo-client","unlisted":false},{"type":"link","href":"/docs/frontend/state-management/drift-detection","label":"Drift Detection System","docId":"state-management/drift-detection","unlisted":false},{"type":"link","href":"/docs/frontend/state-management/overview","label":"State Management Overview","docId":"state-management/overview","unlisted":false},{"type":"link","href":"/docs/frontend/state-management/xstate-machines","label":"XState State Machines","docId":"state-management/xstate-machines","unlisted":false},{"type":"link","href":"/docs/frontend/state-management/zustand-stores","label":"Zustand Stores Inventory","docId":"state-management/zustand-stores","unlisted":false}]},{"type":"category","label":"testing","collapsible":true,"collapsed":true,"items":[{"type":"link","href":"/docs/frontend/testing/component-testing","label":"Component Testing","docId":"testing/component-testing","unlisted":false},{"type":"link","href":"/docs/frontend/testing/e2e-testing","label":"E2E Testing","docId":"testing/e2e-testing","unlisted":false},{"type":"link","href":"/docs/frontend/testing/mocking","label":"Mocking Strategy","docId":"testing/mocking","unlisted":false},{"type":"link","href":"/docs/frontend/testing/overview","label":"Testing Overview","docId":"testing/overview","unlisted":false},{"type":"link","href":"/docs/frontend/testing/unit-testing","label":"Unit Testing","docId":"testing/unit-testing","unlisted":false}]},{"type":"category","label":"ui-system","collapsible":true,"collapsed":true,"items":[{"type":"link","href":"/docs/frontend/ui-system/design-tokens","label":"Design Tokens","docId":"ui-system/design-tokens","unlisted":false},{"type":"link","href":"/docs/frontend/ui-system/layouts","label":"Layouts","docId":"ui-system/layouts","unlisted":false},{"type":"link","href":"/docs/frontend/ui-system/overview","label":"UI System Overview","docId":"ui-system/overview","unlisted":false},{"type":"link","href":"/docs/frontend/ui-system/patterns-catalog","label":"Patterns Catalog","docId":"ui-system/patterns-catalog","unlisted":false},{"type":"link","href":"/docs/frontend/ui-system/platform-presenters","label":"Platform Presenters Pattern","docId":"ui-system/platform-presenters","unlisted":false},{"type":"link","href":"/docs/frontend/ui-system/primitives-catalog","label":"Primitives Catalog","docId":"ui-system/primitives-catalog","unlisted":false}]}]},"docs":{"architecture/build-system":{"id":"architecture/build-system","title":"Build System","description":"The apps/connect frontend is built with Vite via the @nx/vite Nx executor. All Vite configuration lives in apps/connect/vite.config.ts.","sidebar":"sidebar"},"architecture/library-dependencies":{"id":"architecture/library-dependencies","title":"Monorepo Library Dependency Graph","description":"NasNetConnect is an Nx monorepo. The apps/connect application depends on a set of shared libraries","sidebar":"sidebar"},"architecture/overview":{"id":"architecture/overview","title":"Architecture Overview","description":"The apps/connect frontend is the React-based management interface for NasNetConnect. It","sidebar":"sidebar"},"architecture/provider-stack":{"id":"architecture/provider-stack","title":"Provider Stack Deep Dive","description":"All React context providers are composed in a single file:","sidebar":"sidebar"},"architecture/routing":{"id":"architecture/routing","title":"Routing — TanStack Router","description":"NasNetConnect uses TanStack Router v1 with file-based routing. Route files live in apps/connect/src/routes/ and the router tree is auto-generated into apps/connect/src/routeTree.gen.ts by the Vite plugin at build time.","sidebar":"sidebar"},"cross-cutting-features/alerts-system":{"id":"cross-cutting-features/alerts-system","title":"Alerts System","description":"The alerts system provides rule-based notifications for router and service events. Users define conditions, choose channels for delivery, configure quiet hours, and receive in-app or external notifications when conditions trigger.","sidebar":"sidebar"},"cross-cutting-features/change-set-system":{"id":"cross-cutting-features/change-set-system","title":"Change Set System","description":"The change set system provides atomic multi-resource operations for router configuration. Instead of applying one resource at a time, you batch multiple changes together, validate them, apply in dependency order, and automatically roll back if anything fails.","sidebar":"sidebar"},"cross-cutting-features/configuration-import":{"id":"cross-cutting-features/configuration-import","title":"Configuration Import","description":"The configuration import feature lets users apply RouterOS script commands (.rsc files) to a router through a guided wizard. It also handles service configuration sharing — exporting a service instance's config as JSON and importing it on another router.","sidebar":"sidebar"},"cross-cutting-features/drift-detection-feature":{"id":"cross-cutting-features/drift-detection-feature","title":"Drift Detection Feature","description":"Configuration drift occurs when the desired state stored in NasNet's configuration layer differs from the actual state on the router. This happens when someone changes the router directly via SSH or the RouterOS web interface, bypassing NasNet.","sidebar":"sidebar"},"cross-cutting-features/router-connection":{"id":"cross-cutting-features/router-connection","title":"Router Connection","description":"The router connection system handles discovering routers on the network, validating credentials, establishing connections, and maintaining them over time with heartbeat monitoring and automatic reconnection.","sidebar":"sidebar"},"cross-cutting-features/service-marketplace":{"id":"cross-cutting-features/service-marketplace","title":"Service Marketplace","description":"The service marketplace is the feature management system for downloadable network services that run on the MikroTik router. Each service (Tor, sing-box, Xray-core, MTProxy, Psiphon, AdGuard Home) is a downloadable binary managed by the NasNet backend.","sidebar":"sidebar"},"cross-cutting-features/virtual-interface-factory":{"id":"cross-cutting-features/virtual-interface-factory","title":"Virtual Interface Factory (VIF)","description":"A Virtual Interface (VIF) is a dedicated network interface created on the MikroTik router for each service instance. It provides complete network isolation: each service gets its own VLAN, IP address, and routing mark, so service traffic is kept separate from LAN, WAN, and other services.","sidebar":"sidebar"},"data-fetching/codegen":{"id":"data-fetching/codegen","title":"GraphQL Code Generation","description":"The project uses @graphql-codegen/cli to generate TypeScript types, Apollo React hooks, and a fragment matcher from the GraphQL schema. Generated files are never edited by hand.","sidebar":"sidebar"},"data-fetching/graphql-hooks":{"id":"data-fetching/graphql-hooks","title":"GraphQL Hooks","description":"All GraphQL operations are wrapped in custom hooks under libs/api-client/queries/src/. Each domain has its own subdirectory. This document provides a comprehensive inventory and shows the standard patterns.","sidebar":"sidebar"},"data-fetching/offline-support":{"id":"data-fetching/offline-support","title":"Offline Support","description":"NasNetConnect runs on a router — network connectivity to the device can disappear at any time. The offline support layer detects disconnection, queues mutations, and replays them automatically when the device is reachable again.","sidebar":"sidebar"},"data-fetching/overview":{"id":"data-fetching/overview","title":"Data Fetching Overview","description":"This document describes how data flows from the React frontend to the MikroTik router and back.","sidebar":"sidebar"},"data-fetching/rest-client":{"id":"data-fetching/rest-client","title":"REST Client","description":"The frontend includes two distinct REST mechanisms. This document describes both.","sidebar":"sidebar"},"feature-modules/dashboard":{"id":"feature-modules/dashboard","title":"Dashboard Feature","description":"The dashboard is the default landing page after login. It displays health summaries and resource","sidebar":"sidebar"},"feature-modules/diagnostics":{"id":"feature-modules/diagnostics","title":"Diagnostics Feature Module","description":"Source: libs/features/diagnostics/src/","sidebar":"sidebar"},"feature-modules/firewall":{"id":"feature-modules/firewall","title":"Firewall Feature","description":"The firewall feature (libs/features/firewall/) provides comprehensive MikroTik","sidebar":"sidebar"},"feature-modules/logs":{"id":"feature-modules/logs","title":"Logs Feature Module","description":"Source: libs/features/logs/src/","sidebar":"sidebar"},"feature-modules/network":{"id":"feature-modules/network","title":"Network Feature","description":"The network feature covers the NetworkDashboard page and the libs/features/network/","sidebar":"sidebar"},"feature-modules/services":{"id":"feature-modules/services","title":"Services Feature Module","description":"Source: libs/features/services/src/","sidebar":"sidebar"},"feature-modules/vpn":{"id":"feature-modules/vpn","title":"VPN Feature","description":"The VPN feature manages all MikroTik VPN tunnels — both outgoing client connections","sidebar":"sidebar"},"feature-modules/wireless":{"id":"feature-modules/wireless","title":"Wireless Feature Module","description":"The wireless feature spans two locations:","sidebar":"sidebar"},"forms-validation/form-utilities":{"id":"forms-validation/form-utilities","title":"Form Utilities","description":"This document covers the core form utility hooks and functions in libs/core/forms/src/.","sidebar":"sidebar"},"forms-validation/network-validators":{"id":"forms-validation/network-validators","title":"Network Validators","description":"File: libs/core/forms/src/network-validators.ts","sidebar":"sidebar"},"forms-validation/overview":{"id":"forms-validation/overview","title":"Forms and Validation Overview","description":"NasNetConnect uses React Hook Form for form state management and Zod for schema-driven validation. These two libraries are integrated through a set of utilities in libs/core/forms/src/.","sidebar":"sidebar"},"forms-validation/validation-pipeline":{"id":"forms-validation/validation-pipeline","title":"Validation Pipeline","description":"The validation pipeline (libs/core/forms/src/validation-pipeline/) orchestrates multi-stage validation that combines local Zod schema checks with backend network-aware checks. The number of stages that run depends on how risky the operation is.","sidebar":"sidebar"},"forms-validation/wizard-forms":{"id":"forms-validation/wizard-forms","title":"Wizard Forms","description":"Multi-step forms in NasNetConnect use useWizardPersistence to manage step navigation, data collection, and state persistence across page reloads.","sidebar":"sidebar"},"getting-started/environment-setup":{"id":"getting-started/environment-setup","title":"Environment Setup","description":"This guide walks you through getting the apps/connect frontend running locally.","sidebar":"sidebar"},"getting-started/key-commands":{"id":"getting-started/key-commands","title":"Key Commands","description":"All commands are run from the monorepo root (NasNet/) unless noted otherwise.","sidebar":"sidebar"},"getting-started/overview":{"id":"getting-started/overview","title":"Overview","description":"What Is NasNetConnect?","sidebar":"sidebar"},"getting-started/project-structure":{"id":"getting-started/project-structure","title":"Project Structure","description":"Monorepo Layout","sidebar":"sidebar"},"i18n-accessibility/accessibility":{"id":"i18n-accessibility/accessibility","title":"Accessibility","description":"NasNetConnect targets WCAG 2.1 Level AAA accessibility compliance. This is a non-negotiable constraint because MikroTik administrators use the UI across diverse environments — phones in server rooms, high-ambient-light conditions, assistive technologies. Every component must meet these requirements before shipping.","sidebar":"sidebar"},"i18n-accessibility/i18n":{"id":"i18n-accessibility/i18n","title":"Internationalization (i18n)","description":"NasNetConnect uses i18next with react-i18next for internationalization. The setup supports multiple languages with lazy loading, RTL (right-to-left) layout support, and locale-aware formatting. English is bundled at build time; all other languages are loaded on demand via the HTTP backend.","sidebar":"sidebar"},"intro":{"id":"intro","title":"Introduction","description":"The Connect app is the main React frontend for NasNet. It provides an adaptive, responsive UI for managing MikroTik routers across mobile, tablet, and desktop platforms.","sidebar":"sidebar"},"operations/development-workflow":{"id":"operations/development-workflow","title":"Development Workflow","description":"Day-to-day guide for developing the apps/connect frontend. Covers environment startup, HMR behaviour, debugging, common development tasks, and the PR process.","sidebar":"sidebar"},"operations/performance":{"id":"operations/performance","title":"Performance Guide","description":"The apps/connect frontend operates under strict resource constraints driven by its deployment environment: a single Docker container running on a MikroTik router with limited CPU, RAM, and flash storage.","sidebar":"sidebar"},"operations/storybook":{"id":"operations/storybook","title":"Storybook Guide","description":"NasNetConnect runs three independent Storybook instances, one per library tier. All use Storybook 10.2.7 (ESM-only) with the @storybook/react-vite framework.","sidebar":"sidebar"},"README":{"id":"README","title":"Documentation Index","description":"This is the master index for all developer documentation for the apps/connect frontend application.","sidebar":"sidebar"},"state-management/apollo-client":{"id":"state-management/apollo-client","title":"Apollo Client Configuration","description":"Source: libs/api-client/core/src/apollo/","sidebar":"sidebar"},"state-management/drift-detection":{"id":"state-management/drift-detection","title":"Drift Detection System","description":"Source: libs/state/stores/src/drift-detection/","sidebar":"sidebar"},"state-management/overview":{"id":"state-management/overview","title":"State Management Overview","description":"The apps/connect frontend uses a four-layer state architecture. Each layer handles a distinct","sidebar":"sidebar"},"state-management/xstate-machines":{"id":"state-management/xstate-machines","title":"XState State Machines","description":"All machines live in libs/state/machines/src/. Import from @nasnet/state/machines.","sidebar":"sidebar"},"state-management/zustand-stores":{"id":"state-management/zustand-stores","title":"Zustand Stores Inventory","description":"All stores live in libs/state/stores/src/. Import from @nasnet/state/stores.","sidebar":"sidebar"},"testing/component-testing":{"id":"testing/component-testing","title":"Component Testing","description":"Component tests verify that React components render correctly and respond to user interactions as expected. They sit at the integration level of the testing pyramid — components are rendered with real logic, connected to mocked network requests via MSW, and exercised through user events.","sidebar":"sidebar"},"testing/e2e-testing":{"id":"testing/e2e-testing","title":"E2E Testing","description":"End-to-end tests verify complete user journeys in a real browser. They sit at the top of the testing pyramid and are used sparingly — only for the most critical workflows where a failure would be catastrophic (router configuration changes, firewall rule management, VPN provisioning).","sidebar":"sidebar"},"testing/mocking":{"id":"testing/mocking","title":"Mocking Strategy","description":"NasNetConnect uses MSW (Mock Service Worker) as the single mocking layer for all network requests — GraphQL and REST alike. MSW intercepts requests at the network level (using a service worker in the browser, and a Node.js interceptor in Vitest). This means tests exercise real Apollo Client logic, real fetch calls, and real response parsing — only the network boundary is replaced with controlled fixtures.","sidebar":"sidebar"},"testing/overview":{"id":"testing/overview","title":"Testing Overview","description":"NasNetConnect uses a Testing Trophy approach — the majority of tests are integration tests that verify real user workflows through the component tree, with a smaller base of unit tests for pure logic and a thin layer of E2E tests for critical user journeys.","sidebar":"sidebar"},"testing/unit-testing":{"id":"testing/unit-testing","title":"Unit Testing","description":"Unit tests cover pure functions, custom hooks, and utilities in isolation. They are the fastest tier — each test runs in milliseconds — and form the base of the testing pyramid. The test runner is Vitest, chosen for its native ESM support and Vite-native speed.","sidebar":"sidebar"},"ui-system/design-tokens":{"id":"ui-system/design-tokens","title":"Design Tokens","description":"NasNetConnect uses a three-tier design token architecture defined in libs/ui/tokens/src/tokens.json and surfaced as CSS custom properties. Tokens flow from raw values (Tier 1) through semantic meaning (Tier 2) to component-specific defaults (Tier 3).","sidebar":"sidebar"},"ui-system/layouts":{"id":"ui-system/layouts","title":"Layouts","description":"The layouts library (libs/ui/layouts/src/) provides the structural scaffolding for the entire","sidebar":"sidebar"},"ui-system/overview":{"id":"ui-system/overview","title":"UI System Overview","description":"The NasNetConnect UI system is built around a strict three-layer component architecture. Each layer has a clear responsibility and defined dependency direction. Components flow downward — domain components compose patterns, patterns compose primitives — never the other way around.","sidebar":"sidebar"},"ui-system/patterns-catalog":{"id":"ui-system/patterns-catalog","title":"Patterns Catalog","description":"Layer 2 of the component architecture. All components are from libs/ui/patterns/src/ and imported via @nasnet/ui/patterns.","sidebar":"sidebar"},"ui-system/platform-presenters":{"id":"ui-system/platform-presenters","title":"Platform Presenters Pattern","description":"NasNetConnect uses a Headless + Platform Presenters architecture as the core responsive design strategy. This is not standard CSS-only responsive design — it is a deliberate component architecture that separates business logic from rendering, then renders entirely different component trees per platform.","sidebar":"sidebar"},"ui-system/primitives-catalog":{"id":"ui-system/primitives-catalog","title":"Primitives Catalog","description":"Layer 1 of the component architecture. All components are from libs/ui/primitives/src/ and imported via @nasnet/ui/primitives.","sidebar":"sidebar"}}}}