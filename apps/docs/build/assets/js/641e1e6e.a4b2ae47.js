"use strict";(globalThis.webpackChunk_nas_net_docs=globalThis.webpackChunk_nas_net_docs||[]).push([[77554],{61293:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>a,contentTitle:()=>l,default:()=>u,frontMatter:()=>o,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"guides/performance-patterns","title":"Performance Patterns","description":"Reference: libs/core/utils/src/hooks/ | libs/core/forms/src/ | Performance Optimization Patterns","source":"@site/../../libs/core/docs/guides/performance-patterns.md","sourceDirName":"guides","slug":"/guides/performance-patterns","permalink":"/docs/core/guides/performance-patterns","draft":false,"unlisted":false,"editUrl":"https://github.com/nasnet-community/nasnet-panel/tree/main/../../libs/core/docs/guides/performance-patterns.md","tags":[],"version":"current","sidebarPosition":13,"frontMatter":{"sidebar_position":13,"title":"Performance Patterns"},"sidebar":"sidebar","previous":{"title":"Accessibility Patterns","permalink":"/docs/core/guides/accessibility-patterns"},"next":{"title":"Security Patterns","permalink":"/docs/core/guides/security-patterns"}}');var r=s(31085),i=s(71184);const o={sidebar_position:13,title:"Performance Patterns"},l="Performance Patterns in NasNetConnect",a={},c=[{value:"Table of Contents",id:"table-of-contents",level:2},{value:"useAutoScroll Hook",id:"useautoscroll-hook",level:2},{value:"Architecture",id:"architecture",level:3},{value:"Performance Optimizations",id:"performance-optimizations",level:3},{value:"requestAnimationFrame for Scroll Events",id:"requestanimationframe-for-scroll-events",level:4},{value:"Passive Event Listeners",id:"passive-event-listeners",level:4},{value:"Key Features",id:"key-features",level:3},{value:"Options",id:"options",level:3},{value:"Return Type",id:"return-type",level:3},{value:"Form Persistence Caching",id:"form-persistence-caching",level:2},{value:"How It Works",id:"how-it-works",level:3},{value:"Debouncing Strategy",id:"debouncing-strategy",level:3},{value:"Excluding Sensitive Fields",id:"excluding-sensitive-fields",level:3},{value:"Auto-Restore on Mount",id:"auto-restore-on-mount",level:3},{value:"Return Methods",id:"return-methods",level:3},{value:"Validation Pipeline Optimization",id:"validation-pipeline-optimization",level:2},{value:"Risk-Based Stage Skipping",id:"risk-based-stage-skipping",level:3},{value:"Async Validation Debouncing",id:"async-validation-debouncing",level:3},{value:"Request Cancellation",id:"request-cancellation",level:3},{value:"Bundle Size Considerations",id:"bundle-size-considerations",level:2},{value:"No React Dependencies in Core",id:"no-react-dependencies-in-core",level:3},{value:"Granular Imports",id:"granular-imports",level:3},{value:"Module Organization",id:"module-organization",level:3},{value:"Memoization Patterns",id:"memoization-patterns",level:2},{value:"Dependency Graph Caching",id:"dependency-graph-caching",level:3},{value:"Well-Known Ports Lookup",id:"well-known-ports-lookup",level:3},{value:"When to Cache vs Compute",id:"when-to-cache-vs-compute",level:3},{value:"Code Examples",id:"code-examples",level:2},{value:"Log Viewer with Performance Optimization",id:"log-viewer-with-performance-optimization",level:3},{value:"Wizard with Form Persistence",id:"wizard-with-form-persistence",level:3},{value:"High-Risk Validation with Async Debounce",id:"high-risk-validation-with-async-debounce",level:3},{value:"Related Guides",id:"related-guides",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"performance-patterns-in-nasnetconnect",children:"Performance Patterns in NasNetConnect"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Reference:"})," ",(0,r.jsx)(n.code,{children:"libs/core/utils/src/hooks/"})," | ",(0,r.jsx)(n.code,{children:"libs/core/forms/src/"})," | Performance Optimization Patterns"]}),"\n",(0,r.jsx)(n.p,{children:"NasNetConnect implements several performance optimization patterns across form handling, data scrolling, and validation pipelines. This guide documents these patterns and their practical applications."}),"\n",(0,r.jsx)(n.h2,{id:"table-of-contents",children:"Table of Contents"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#useautoscroll-hook",children:"useAutoScroll Hook"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#form-persistence-caching",children:"Form Persistence Caching"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#validation-pipeline-optimization",children:"Validation Pipeline Optimization"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#bundle-size-considerations",children:"Bundle Size Considerations"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#memoization-patterns",children:"Memoization Patterns"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#code-examples",children:"Code Examples"})}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"useautoscroll-hook",children:"useAutoScroll Hook"}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"useAutoScroll"})," hook manages automatic scrolling behavior for scrollable containers like log viewers and real-time data streams. It uses performance-optimized techniques to avoid layout thrashing and ensures smooth scrolling."]}),"\n",(0,r.jsx)(n.h3,{id:"architecture",children:"Architecture"}),"\n",(0,r.jsx)(n.p,{children:"The hook implements:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"requestAnimationFrame (rAF)"})," for scroll event handling instead of raw events"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Passive event listeners"})," for improved scroll performance"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Efficient state tracking"})," of bottom position and new entry count"]}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:'import { useAutoScroll } from \'@nasnet/core/utils/hooks\';\n\nfunction LogViewer() {\n  const scrollRef = useRef<HTMLDivElement>(null);\n  const { data: logs } = useSystemLogs();\n  const { isAtBottom, newEntriesCount, scrollToBottom } = useAutoScroll({\n    scrollRef,\n    data: logs || [],\n  });\n\n  return (\n    <div ref={scrollRef} className="overflow-auto h-96">\n      {logs?.map(log => <LogEntry key={log.id} entry={log} />)}\n      {!isAtBottom && newEntriesCount > 0 && (\n        <button onClick={scrollToBottom} className="sticky bottom-0">\n          Scroll to bottom ({newEntriesCount} new)\n        </button>\n      )}\n    </div>\n  );\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"performance-optimizations",children:"Performance Optimizations"}),"\n",(0,r.jsx)(n.h4,{id:"requestanimationframe-for-scroll-events",children:"requestAnimationFrame for Scroll Events"}),"\n",(0,r.jsx)(n.p,{children:"Instead of handling scroll events directly:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"// Bad - fires on every scroll pixel\nelement.addEventListener('scroll', handleScroll);\n\n// Good - batches scroll handling to animation frames\nlet rafId: number | null = null;\n\nconst handleScroll = () => {\n  if (rafId !== null) {\n    cancelAnimationFrame(rafId);\n  }\n  rafId = requestAnimationFrame(() => {\n    const atBottom = checkIsAtBottom();\n    setIsAtBottom(atBottom);\n  });\n};\n\nelement.addEventListener('scroll', handleScroll, { passive: true });\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Benefits:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Scroll events are debounced to 60 FPS (or viewport refresh rate)"}),"\n",(0,r.jsx)(n.li,{children:"Prevents layout thrashing from rapid DOM reads/writes"}),"\n",(0,r.jsx)(n.li,{children:"Previous rAF callback is cancelled if user scrolls again before it fires"}),"\n"]}),"\n",(0,r.jsx)(n.h4,{id:"passive-event-listeners",children:"Passive Event Listeners"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"// Passive: true means the listener won't call preventDefault()\nelement.addEventListener('scroll', handleScroll, { passive: true });\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Impact:"})," Allows browser to optimize scroll performance, knowing it won't be blocked."]}),"\n",(0,r.jsx)(n.h3,{id:"key-features",children:"Key Features"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Auto-scroll to bottom when user is at bottom:"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"// If user is already at the bottom and new data arrives\n// The hook instantly scrolls to bottom\nif (isAtBottom && hasNewEntries) {\n  scrollToBottom('instant');  // Instant scroll on load\n  scrollToBottom('smooth');   // Smooth scroll on updates\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Track new entries when user scrolls up:"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:'// User manually scrolls up (away from bottom)\n// The hook tracks how many new entries arrived\n// Display "5 new entries" button\nif (!isAtBottom && hasNewEntries) {\n  setNewEntriesCount(prev => prev + newCount);\n}\n'})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Manual scroll control:"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:'const { scrollToBottom } = useAutoScroll({ /* ... */ });\n\n// User clicks "Scroll to bottom" button\n<button onClick={scrollToBottom}>Scroll to bottom</button>\n'})}),"\n",(0,r.jsx)(n.h3,{id:"options",children:"Options"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"export interface UseAutoScrollOptions {\n  scrollRef: RefObject<HTMLElement>;        // Ref to scrollable container\n  data: unknown[];                           // Data array to watch\n  enabled?: boolean;                         // Enable/disable (default: true)\n  threshold?: number;                        // Pixels from bottom (default: 100)\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Threshold Explanation:"})}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"threshold"})," option defines how close to the bottom the user must be for auto-scroll to trigger. Default is 100 pixels:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"const distanceFromBottom = scrollHeight - scrollTop - clientHeight;\nconst isAtBottom = distanceFromBottom <= threshold;  // 100px buffer\n"})}),"\n",(0,r.jsx)(n.h3,{id:"return-type",children:"Return Type"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"export interface UseAutoScrollReturn {\n  isAtBottom: boolean;        // User is scrolled to bottom\n  newEntriesCount: number;    // Count of new entries since scroll paused\n  scrollToBottom: () => void; // Scroll to bottom immediately\n}\n"})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"form-persistence-caching",children:"Form Persistence Caching"}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"useFormPersistence"})," hook saves form state to browser storage (sessionStorage by default) for recovery after page reload. This is critical for long wizard flows where users might accidentally refresh or navigate away."]}),"\n",(0,r.jsx)(n.h3,{id:"how-it-works",children:"How It Works"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"import { useFormPersistence } from '@nasnet/core/forms';\n\nfunction WizardStep() {\n  const form = useZodForm({ schema, defaultValues });\n  const { clearPersistence, hasSavedData, restore } = useFormPersistence({\n    form,\n    storageKey: 'wizard-step-1',\n    debounceMs: 1000,  // Save after 1 second of inactivity\n    excludeFields: ['password'],  // Don't save sensitive fields\n  });\n\n  return (\n    <>\n      {hasSavedData() && (\n        <Alert>Restored your previous progress on this step</Alert>\n      )}\n      <form>\n        {/* form fields */}\n      </form>\n      <button onClick={() => {\n        // When wizard completes, clear saved data\n        clearPersistence();\n        navigateNext();\n      }}>\n        Next Step\n      </button>\n    </>\n  );\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"debouncing-strategy",children:"Debouncing Strategy"}),"\n",(0,r.jsxs)(n.p,{children:["Forms are saved with ",(0,r.jsx)(n.strong,{children:"debouncing"})," to avoid excessive storage writes:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"const debounceMs = 1000;  // Default\n\n// User types quickly\nform.watch((values) => {\n  clearTimeout(timeoutRef.current);\n\n  // Wait 1 second after user stops typing\n  timeoutRef.current = setTimeout(() => {\n    storage.setItem(storageKey, JSON.stringify(filtered));\n  }, debounceMs);\n});\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Benefits:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Saves battery life (fewer storage writes)"}),"\n",(0,r.jsx)(n.li,{children:"Reduces UI jank from synchronous storage access"}),"\n",(0,r.jsx)(n.li,{children:"Handles rapid user input efficiently"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"excluding-sensitive-fields",children:"Excluding Sensitive Fields"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"useFormPersistence({\n  form,\n  storageKey: 'form-key',\n  excludeFields: ['password', 'apiKey', 'authToken'],\n});\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Fields in ",(0,r.jsx)(n.code,{children:"excludeFields"})," are never written to storage:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"const filterValues = (values) => {\n  const filtered = { ...values };\n  excludeFields.forEach(field => {\n    delete filtered[field];\n  });\n  return filtered;\n};\n"})}),"\n",(0,r.jsx)(n.h3,{id:"auto-restore-on-mount",children:"Auto-Restore on Mount"}),"\n",(0,r.jsx)(n.p,{children:"Saved form data is automatically restored when the component mounts:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"useEffect(() => {\n  restore();  // Called automatically in useFormPersistence\n}, [restore]);\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Restore only happens once (tracked via ",(0,r.jsx)(n.code,{children:"hasRestoredRef"}),"):"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"const restore = useCallback((): boolean => {\n  if (!storage || hasRestoredRef.current) return false;\n\n  const saved = storage.getItem(storageKey);\n  if (!saved) return false;\n\n  try {\n    const parsed = JSON.parse(saved) as T;\n    form.reset(parsed, { keepDefaultValues: true });\n    hasRestoredRef.current = true;\n    return true;\n  } catch {\n    storage.removeItem(storageKey);  // Clear invalid data\n    return false;\n  }\n}, [form, storageKey, storage]);\n"})}),"\n",(0,r.jsx)(n.h3,{id:"return-methods",children:"Return Methods"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"{\n  clearPersistence: () => void;    // Clear saved data and timeout\n  hasSavedData: () => boolean;     // Check if storage has data\n  restore: () => boolean;          // Restore from storage (called auto)\n}\n"})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"validation-pipeline-optimization",children:"Validation Pipeline Optimization"}),"\n",(0,r.jsx)(n.p,{children:"The validation pipeline optimizes performance by:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Skipping unnecessary stages"})," based on risk level"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Aborting pending validation"})," when new input arrives"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Debouncing async validation"})," to reduce API calls"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"risk-based-stage-skipping",children:"Risk-Based Stage Skipping"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"export const RISK_LEVEL_STAGES: Record<RiskLevel, ValidationStageName[]> = {\n  low: ['schema', 'syntax'],  // Only fast client-side checks\n  medium: ['schema', 'syntax', 'cross-resource', 'dependencies'],\n  high: ['schema', 'syntax', 'cross-resource', 'dependencies', 'network', 'platform', 'dry-run'],\n};\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Low-risk operations"})," (display name, WiFi password) skip 5 backend stages:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"// Changing WiFi password\nconst validation = useValidationPipeline({\n  riskLevel: 'low',  // Only stages 1-2\n  // Skip expensive cross-resource, network, platform, dry-run checks\n});\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"High-risk operations"})," (VPN configuration, firewall rules) run all 7 stages:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"// Configuring VPN endpoint\nconst validation = useValidationPipeline({\n  riskLevel: 'high',  // All stages 1-7\n  // Run full validation suite\n});\n"})}),"\n",(0,r.jsx)(n.h3,{id:"async-validation-debouncing",children:"Async Validation Debouncing"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"export interface UseAsyncValidationOptions<T extends ZodSchema> {\n  schema: T;\n  validateFn: async (value: unknown) => string | null;\n  debounceMs?: number;  // Default: 300ms\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"debounceMs"})," option prevents excessive API calls during rapid input:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"// User types email quickly: a@b.c -> a@b.co -> a@b.com\n// Only the final a@b.com triggers async validation after 300ms pause\n\nconst asyncValidation = useAsyncValidation({\n  schema: z.string().email(),\n  validateFn: checkEmailExists,\n  debounceMs: 500,  // Wait 500ms for user to stop typing\n});\n\n<input onChange={e => asyncValidation.validate(e.target.value)} />\n"})}),"\n",(0,r.jsx)(n.h3,{id:"request-cancellation",children:"Request Cancellation"}),"\n",(0,r.jsx)(n.p,{children:"Previous async validation requests are cancelled if user types again:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"const validate = useCallback(\n  (value: unknown) => {\n    // Cancel previous request\n    abortControllerRef.current?.abort();\n\n    // Start new validation\n    abortControllerRef.current = new AbortController();\n\n    // If request is still pending when new input arrives, abort it\n    const asyncError = await validateFn(value, {\n      signal: abortControllerRef.current.signal\n    });\n  },\n  [/* dependencies */]\n);\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Benefit:"})," Prevents race conditions where slow network requests complete out of order."]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"bundle-size-considerations",children:"Bundle Size Considerations"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"libs/core"})," is designed for minimal bundle impact:"]}),"\n",(0,r.jsx)(n.h3,{id:"no-react-dependencies-in-core",children:"No React Dependencies in Core"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"libs/core/types/"})," and ",(0,r.jsx)(n.code,{children:"libs/core/utils/"})," have zero React dependencies:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"// @nasnet/core/types - Pure TypeScript, no React\nexport interface ValidationError { /* ... */ }\n\n// @nasnet/core/utils - Pure functions, can be used anywhere\nexport function getReducedMotionPreference(): boolean { /* ... */ }\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Benefits:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Can be imported in non-React contexts"}),"\n",(0,r.jsx)(n.li,{children:"Tree-shaking friendly"}),"\n",(0,r.jsx)(n.li,{children:"Smaller bundle when only using utilities"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"granular-imports",children:"Granular Imports"}),"\n",(0,r.jsx)(n.p,{children:"Import specific functions instead of barrel exports:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"// Good - only imports useAutoScroll\nimport { useAutoScroll } from '@nasnet/core/utils/hooks/useAutoScroll';\n\n// Less optimal - could tree-shake unused hooks\nimport { useAutoScroll } from '@nasnet/core/utils';\n\n// Bad - imports entire utils + deps\nimport * as utils from '@nasnet/core/utils';\nconst scroll = utils.useAutoScroll;\n"})}),"\n",(0,r.jsx)(n.h3,{id:"module-organization",children:"Module Organization"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"libs/core/\n\u251c\u2500\u2500 types/\n\u2502   \u251c\u2500\u2500 firewall/\n\u2502   \u2502   \u251c\u2500\u2500 filter-rule.types.ts\n\u2502   \u2502   \u251c\u2500\u2500 nat-rule.types.ts\n\u2502   \u2502   \u2514\u2500\u2500 ...\n\u2502   \u2514\u2500\u2500 resource/\n\u251c\u2500\u2500 utils/\n\u2502   \u251c\u2500\u2500 hooks/\n\u2502   \u2502   \u251c\u2500\u2500 useAutoScroll.ts        (independent)\n\u2502   \u2502   \u251c\u2500\u2500 useReducedMotion.ts     (independent)\n\u2502   \u2502   \u2514\u2500\u2500 ...\n\u2502   \u2514\u2500\u2500 ...\n\u2514\u2500\u2500 forms/\n    \u251c\u2500\u2500 useFormPersistence.ts        (can import types only)\n    \u251c\u2500\u2500 useAsyncValidation.ts        (can import types only)\n    \u2514\u2500\u2500 ...\n"})}),"\n",(0,r.jsx)(n.p,{children:"Each module is independently tree-shakeable."}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"memoization-patterns",children:"Memoization Patterns"}),"\n",(0,r.jsx)(n.h3,{id:"dependency-graph-caching",children:"Dependency Graph Caching"}),"\n",(0,r.jsx)(n.p,{children:"For complex dependency graphs, cache computed results:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"// Don't recompute on every render\nconst dependencyCache = useMemo(\n  () => computeDependencyGraph(resources),\n  [resources]  // Only recompute if resources change\n);\n"})}),"\n",(0,r.jsx)(n.h3,{id:"well-known-ports-lookup",children:"Well-Known Ports Lookup"}),"\n",(0,r.jsx)(n.p,{children:"Port registry uses a Map for O(1) lookups instead of array search:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"// Efficient: O(1) lookup\nconst portMap = new Map(wellKnownPorts.map(p => [p.number, p]));\nconst port = portMap.get(22);  // SSH\n\n// Inefficient: O(n) lookup\nconst port = wellKnownPorts.find(p => p.number === 22);\n"})}),"\n",(0,r.jsx)(n.h3,{id:"when-to-cache-vs-compute",children:"When to Cache vs Compute"}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Scenario"}),(0,r.jsx)(n.th,{children:"Strategy"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Expensive computation, stable inputs"}),(0,r.jsxs)(n.td,{children:[(0,r.jsx)(n.strong,{children:"useMemo"})," to cache result"]})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Frequently accessed, rarely updated"}),(0,r.jsxs)(n.td,{children:[(0,r.jsx)(n.strong,{children:"Map-based lookup"})," or ",(0,r.jsx)(n.strong,{children:"Set"})]})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Simple transformation, frequent changes"}),(0,r.jsxs)(n.td,{children:[(0,r.jsx)(n.strong,{children:"Compute on demand"})," (no cache)"]})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Long operation list, filtering needed"}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Filter once, cache results"})})]})]})]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"code-examples",children:"Code Examples"}),"\n",(0,r.jsx)(n.h3,{id:"log-viewer-with-performance-optimization",children:"Log Viewer with Performance Optimization"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:'import { useAutoScroll } from \'@nasnet/core/utils/hooks\';\nimport { useQuery } from \'@apollo/client\';\n\nfunction LogViewer() {\n  const scrollRef = useRef<HTMLDivElement>(null);\n  const { data, loading, error } = useQuery(GET_SYSTEM_LOGS, {\n    variables: { limit: 1000 },\n    pollInterval: 5000,  // Poll every 5 seconds\n  });\n\n  const { isAtBottom, newEntriesCount, scrollToBottom } = useAutoScroll({\n    scrollRef,\n    data: data?.logs || [],\n    threshold: 100,  // Scroll to bottom if within 100px\n  });\n\n  return (\n    <div className="relative h-96">\n      <div ref={scrollRef} className="overflow-auto h-full">\n        {data?.logs.map(log => (\n          <div key={log.id} className="font-mono text-sm">\n            {log.timestamp} {log.message}\n          </div>\n        ))}\n      </div>\n\n      {!isAtBottom && newEntriesCount > 0 && (\n        <button\n          onClick={scrollToBottom}\n          className="absolute bottom-0 left-0 right-0 bg-primary text-white py-2"\n        >\n          {newEntriesCount} new log entries - Scroll to bottom\n        </button>\n      )}\n    </div>\n  );\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"wizard-with-form-persistence",children:"Wizard with Form Persistence"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"import { useFormPersistence } from '@nasnet/core/forms';\nimport { useZodForm } from '@nasnet/core/forms';\n\nfunction VPNConfigWizard() {\n  const [step, setStep] = useState(1);\n  const form = useZodForm({ schema: vpnConfigSchema });\n  const persistence = useFormPersistence({\n    form,\n    storageKey: `vpn-wizard-step-${step}`,\n    debounceMs: 1000,\n    excludeFields: ['privateKey'],  // Don't save sensitive fields\n  });\n\n  const handleNext = async () => {\n    const isValid = await form.trigger();\n    if (isValid) {\n      setStep(step + 1);\n    }\n  };\n\n  const handleComplete = async () => {\n    const success = await submitWizard(form.getValues());\n    if (success) {\n      // Clear saved data when wizard completes\n      persistence.clearPersistence();\n      navigateToDashboard();\n    }\n  };\n\n  return (\n    <div>\n      {persistence.hasSavedData() && (\n        <Alert variant=\"info\">\n          Restored your previous progress on step {step}\n        </Alert>\n      )}\n\n      <form onSubmit={form.handleSubmit(handleNext)}>\n        {step === 1 && <EndpointStep form={form} />}\n        {step === 2 && <AuthStep form={form} />}\n        {step === 3 && <ReviewStep form={form} />}\n\n        <div className=\"flex justify-between\">\n          <button onClick={() => setStep(step - 1)}>Previous</button>\n          <button\n            onClick={step === 3 ? handleComplete : handleNext}\n          >\n            {step === 3 ? 'Complete' : 'Next'}\n          </button>\n        </div>\n      </form>\n    </div>\n  );\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"high-risk-validation-with-async-debounce",children:"High-Risk Validation with Async Debounce"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:'import { useAsyncValidation } from \'@nasnet/core/forms\';\n\nfunction VLANConfigForm() {\n  const asyncValidation = useAsyncValidation({\n    schema: z.object({\n      vlanId: z.number().min(1).max(4094),\n    }),\n    validateFn: async (vlanId) => {\n      // Check if VLAN is already allocated\n      const isAllocated = await checkVlanAllocation(vlanId);\n      return isAllocated ? \'VLAN is already in use\' : null;\n    },\n    debounceMs: 500,  // Wait for user to stop typing\n  });\n\n  return (\n    <div>\n      <input\n        type="number"\n        placeholder="VLAN ID (1-4094)"\n        onChange={e => {\n          const value = parseInt(e.target.value);\n          asyncValidation.validate(value);\n        }}\n      />\n\n      {asyncValidation.isValidating && <Spinner />}\n      {asyncValidation.error && (\n        <Alert variant="error">{asyncValidation.error}</Alert>\n      )}\n    </div>\n  );\n}\n'})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"related-guides",children:"Related Guides"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Validation Pipeline:"})," See ",(0,r.jsx)(n.code,{children:"libs/core/docs/guides/validation-pipeline.md"})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Form Handling:"})," See ",(0,r.jsx)(n.code,{children:"libs/core/docs/guides/form-patterns.md"})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Bundle Size:"})," See ",(0,r.jsx)(n.code,{children:"Docs/architecture/implementation-patterns/performance-patterns.md"})]}),"\n"]})]})}function u(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},71184:(e,n,s)=>{s.d(n,{R:()=>o,x:()=>l});var t=s(14041);const r={},i=t.createContext(r);function o(e){const n=t.useContext(i);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),t.createElement(i.Provider,{value:n},e.children)}}}]);