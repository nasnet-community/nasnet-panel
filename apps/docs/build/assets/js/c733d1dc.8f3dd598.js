"use strict";(globalThis.webpackChunk_nas_net_docs=globalThis.webpackChunk_nas_net_docs||[]).push([[92141],{71184:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>r});var s=t(14041);const a={},i=s.createContext(a);function o(e){const n=s.useContext(i);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:o(e.components),s.createElement(i.Provider,{value:n},e.children)}},74793:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>r,default:()=>p,frontMatter:()=>o,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"guides/adding-a-machine","title":"Adding a New XState Machine","description":"Step-by-step guide for creating XState v5 machines following NasNet conventions.","source":"@site/../../libs/state/docs/guides/adding-a-machine.md","sourceDirName":"guides","slug":"/guides/adding-a-machine","permalink":"/docs/state/guides/adding-a-machine","draft":false,"unlisted":false,"editUrl":"https://github.com/nasnet-community/nasnet-panel/tree/main/../../libs/state/docs/guides/adding-a-machine.md","tags":[],"version":"current","frontMatter":{},"sidebar":"sidebar","previous":{"title":"Testing Strategy","permalink":"/docs/state/guides/testing"},"next":{"title":"Adding a New Zustand Store","permalink":"/docs/state/guides/adding-a-store"}}');var a=t(31085),i=t(71184);const o={},r="Adding a New XState Machine",c={},l=[{value:"When to Create a Machine",id:"when-to-create-a-machine",level:2},{value:"Step-by-Step Checklist",id:"step-by-step-checklist",level:2},{value:"1. Create File with Standard Naming",id:"1-create-file-with-standard-naming",level:3},{value:"2. Define Types",id:"2-define-types",level:3},{value:"3. Create Machine with setup()",id:"3-create-machine-with-setup",level:3},{value:"4. Create React Hook Wrapper",id:"4-create-react-hook-wrapper",level:3},{value:"5. Create Tests",id:"5-create-tests",level:3},{value:"6. Export from Barrel Index",id:"6-export-from-barrel-index",level:3},{value:"7. Create Component Usage Example",id:"7-create-component-usage-example",level:3},{value:"Best Practices Checklist",id:"best-practices-checklist",level:2},{value:"Storage &amp; Persistence",id:"storage--persistence",level:2},{value:"File Structure",id:"file-structure",level:2},{value:"Quick Template",id:"quick-template",level:2},{value:"Next Steps",id:"next-steps",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",input:"input",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"adding-a-new-xstate-machine",children:"Adding a New XState Machine"})}),"\n",(0,a.jsx)(n.p,{children:"Step-by-step guide for creating XState v5 machines following NasNet conventions."}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Source:"})," Patterns from ",(0,a.jsx)(n.code,{children:"libs/state/machines/src/"})]}),"\n",(0,a.jsx)(n.h2,{id:"when-to-create-a-machine",children:"When to Create a Machine"}),"\n",(0,a.jsx)(n.p,{children:"Create a machine for:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"\u2705 Multi-step workflows (wizards, config pipelines)"}),"\n",(0,a.jsx)(n.li,{children:"\u2705 Complex state transitions with guards"}),"\n",(0,a.jsx)(n.li,{children:"\u2705 Async operations with loading/error states"}),"\n",(0,a.jsx)(n.li,{children:"\u2705 Orchestrating multiple actions across steps"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"Do NOT create a machine for:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"\u274c Simple UI toggles (use Zustand stores)"}),"\n",(0,a.jsx)(n.li,{children:"\u274c Server data (use Apollo Client + GraphQL)"}),"\n",(0,a.jsx)(n.li,{children:"\u274c Form validation (use React Hook Form)"}),"\n",(0,a.jsx)(n.li,{children:"\u274c One-off async operations (use useEffect + useState)"}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"step-by-step-checklist",children:"Step-by-Step Checklist"}),"\n",(0,a.jsx)(n.h3,{id:"1-create-file-with-standard-naming",children:"1. Create File with Standard Naming"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-bash",children:"# Location: libs/state/machines/src/\n# Naming: [workflow]Machine.ts\n\nlibs/state/machines/src/\n\u251c\u2500\u2500 wizardMachine.ts              # Multi-step wizard\n\u251c\u2500\u2500 configPipelineMachine.ts       # Config apply pipeline\n\u251c\u2500\u2500 vpnConnectionMachine.ts        # VPN connection lifecycle\n\u251c\u2500\u2500 changeSetMachine.ts            # Change set operations\n\u251c\u2500\u2500 resourceLifecycleMachine.ts     # Resource state lifecycle\n\u2514\u2500\u2500 hooks/\n    \u2514\u2500\u2500 useWizard.ts              # React hook for machine\n"})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Naming conventions:"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"[workflow]Machine.ts"})," - The machine definition"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"use[Workflow].ts"})," - React hook wrapper"]}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"2-define-types",children:"2. Define Types"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"// libs/state/machines/src/myWorkflowMachine.ts\n\n/**\n * My Workflow Machine\n * Handles [workflow description]\n */\n\nimport { setup } from 'xstate';\n\n// ============================================================================\n// Types\n// ============================================================================\n\n/**\n * Machine context: data that flows through the workflow\n */\nexport interface MyWorkflowContext {\n  // Step 1 data\n  step1Data?: string;\n\n  // Step 2 data\n  step2Data?: Record<string, unknown>;\n\n  // Async operation results\n  result?: unknown;\n  error?: Error;\n\n  // Metadata\n  userId: string;\n  startedAt: number;\n}\n\n/**\n * Machine events: actions that trigger transitions\n */\nexport type MyWorkflowEvent =\n  | { type: 'NEXT' } // Go to next step\n  | { type: 'BACK' } // Go to previous step\n  | { type: 'SKIP' } // Skip optional step\n  | { type: 'SUBMIT'; data: Record<string, unknown> } // Submit with data\n  | { type: 'CANCEL' } // Cancel workflow\n  | { type: 'RETRY' } // Retry after error\n  | { type: 'done.invoke.asyncAction'; output: unknown }; // Async completion\n\n/**\n * Machine configuration\n */\nexport interface MyWorkflowConfig {\n  userId: string;\n  initialData?: Partial<MyWorkflowContext>;\n  onComplete?: (context: MyWorkflowContext) => void;\n  onError?: (error: Error) => void;\n}\n"})}),"\n",(0,a.jsx)(n.h3,{id:"3-create-machine-with-setup",children:"3. Create Machine with setup()"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"// ============================================================================\n// Machine\n// ============================================================================\n\n/**\n * Create MyWorkflow machine\n *\n * States:\n * - step1: First step of workflow\n * - step2: Second step\n * - step3: Review/confirm\n * - submitting: Sending to server\n * - success: Completed successfully\n * - error: Failed with error\n * - cancelled: User cancelled\n */\nexport function createMyWorkflowMachine(config: MyWorkflowConfig) {\n  const { userId, initialData = {}, onComplete, onError } = config;\n\n  return setup({\n    types: {\n      context: {} as MyWorkflowContext,\n      events: {} as MyWorkflowEvent,\n    },\n\n    actors: {\n      // Define async operations\n      submitWorkflow: async (context) => {\n        // Call API\n        const response = await fetch('/api/workflow', {\n          method: 'POST',\n          body: JSON.stringify({\n            step1Data: context.step1Data,\n            step2Data: context.step2Data,\n          }),\n        });\n\n        if (!response.ok) {\n          throw new Error(`API error: ${response.statusText}`);\n        }\n\n        return response.json();\n      },\n    },\n\n    guards: {\n      // Define transition conditions\n      isStep1Valid: (context) => {\n        return context.step1Data && context.step1Data.length > 0;\n      },\n\n      isStep2Valid: (context) => {\n        return context.step2Data && Object.keys(context.step2Data).length > 0;\n      },\n\n      canSkipStep: (context) => {\n        return context.userId === 'admin'; // Only admins can skip\n      },\n    },\n  }).createMachine({\n    id: 'myWorkflow',\n    initial: 'step1',\n\n    context: {\n      userId,\n      startedAt: Date.now(),\n      ...initialData,\n    },\n\n    states: {\n      // ===== STEP 1 =====\n      step1: {\n        on: {\n          NEXT: {\n            guard: 'isStep1Valid', // Must pass validation\n            target: 'step2',\n            actions: (context, event) => {\n              // Update context with step 1 data\n              if (event.type === 'SUBMIT') {\n                return { ...context, step1Data: event.data.input };\n              }\n            },\n          },\n          CANCEL: 'cancelled',\n        },\n      },\n\n      // ===== STEP 2 =====\n      step2: {\n        on: {\n          BACK: 'step1',\n          NEXT: {\n            guard: 'isStep2Valid',\n            target: 'step3',\n            actions: (context, event) => {\n              if (event.type === 'SUBMIT') {\n                return { ...context, step2Data: event.data };\n              }\n            },\n          },\n          SKIP: {\n            guard: 'canSkipStep',\n            target: 'step3',\n          },\n          CANCEL: 'cancelled',\n        },\n      },\n\n      // ===== STEP 3 (REVIEW) =====\n      step3: {\n        on: {\n          BACK: 'step2',\n          SUBMIT: 'submitting',\n          CANCEL: 'cancelled',\n        },\n      },\n\n      // ===== SUBMITTING =====\n      submitting: {\n        invoke: {\n          src: 'submitWorkflow',\n          onDone: {\n            target: 'success',\n            actions: (context, event) => {\n              return { ...context, result: event.output };\n            },\n          },\n          onError: {\n            target: 'error',\n            actions: (context, event) => {\n              return { ...context, error: event.error };\n            },\n          },\n        },\n      },\n\n      // ===== SUCCESS =====\n      success: {\n        type: 'final',\n        entry: (context) => {\n          onComplete?.(context);\n        },\n      },\n\n      // ===== ERROR =====\n      error: {\n        on: {\n          RETRY: 'submitting',\n          CANCEL: 'cancelled',\n        },\n      },\n\n      // ===== CANCELLED =====\n      cancelled: {\n        type: 'final',\n      },\n    },\n  });\n}\n"})}),"\n",(0,a.jsx)(n.h3,{id:"4-create-react-hook-wrapper",children:"4. Create React Hook Wrapper"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"// libs/state/machines/src/hooks/useMyWorkflow.ts\n\nimport { useActorRef, useSelector } from '@xstate/react';\nimport { createMyWorkflowMachine, MyWorkflowConfig } from '../myWorkflowMachine';\n\n/**\n * React hook for MyWorkflow machine\n */\nexport function useMyWorkflow(config: MyWorkflowConfig) {\n  // Create and manage machine\n  const actor = useActorRef(() =>\n    createMyWorkflowMachine(config).provide({\n      // Override actors if needed\n    })\n  );\n\n  // Extract state and context\n  const state = useSelector(actor, (snapshot) => snapshot.value);\n  const context = useSelector(actor, (snapshot) => snapshot.context);\n\n  // Helper functions to check state\n  const isStep = (step: string) => state === step;\n  const canNext = !['submitting', 'success', 'cancelled'].includes(String(state));\n  const canBack = !['step1', 'submitting', 'success', 'cancelled'].includes(String(state));\n  const isError = state === 'error';\n  const isSubmitting = state === 'submitting';\n  const isComplete = state === 'success' || state === 'cancelled';\n\n  // Dispatch events\n  const send = (event: any) => actor.send(event);\n  const next = () => send({ type: 'NEXT' });\n  const back = () => send({ type: 'BACK' });\n  const skip = () => send({ type: 'SKIP' });\n  const submit = (data: Record<string, unknown>) =>\n    send({ type: 'SUBMIT', data });\n  const cancel = () => send({ type: 'CANCEL' });\n  const retry = () => send({ type: 'RETRY' });\n\n  return {\n    // State\n    state,\n    context,\n\n    // Step checks\n    isStep,\n    isStep1: isStep('step1'),\n    isStep2: isStep('step2'),\n    isStep3: isStep('step3'),\n\n    // Flags\n    canNext,\n    canBack,\n    isError,\n    isSubmitting,\n    isComplete,\n\n    // Actions\n    send,\n    next,\n    back,\n    skip,\n    submit,\n    cancel,\n    retry,\n  };\n}\n\nexport type UseMyWorkflowReturn = ReturnType<typeof useMyWorkflow>;\n"})}),"\n",(0,a.jsx)(n.h3,{id:"5-create-tests",children:"5. Create Tests"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"// libs/state/machines/src/myWorkflowMachine.test.ts\n\nimport { createMockActorRef } from '@xstate/react';\nimport { createMyWorkflowMachine } from './myWorkflowMachine';\n\ndescribe('myWorkflowMachine', () => {\n  it('starts in step1', () => {\n    const machine = createMyWorkflowMachine({ userId: 'user-1' });\n    const actor = machine.start();\n\n    expect(actor.getSnapshot().value).toBe('step1');\n  });\n\n  describe('step transitions', () => {\n    it('moves from step1 to step2 with valid data', () => {\n      const machine = createMyWorkflowMachine({ userId: 'user-1' });\n      const actor = machine.start();\n\n      // Submit step 1 data\n      actor.send({\n        type: 'SUBMIT',\n        data: { input: 'valid data' },\n      });\n\n      actor.send({ type: 'NEXT' });\n\n      expect(actor.getSnapshot().value).toBe('step2');\n    });\n\n    it('stays in step1 with invalid data', () => {\n      const machine = createMyWorkflowMachine({ userId: 'user-1' });\n      const actor = machine.start();\n\n      // Try to go next without submitting\n      actor.send({ type: 'NEXT' });\n\n      // Should still be in step1\n      expect(actor.getSnapshot().value).toBe('step1');\n    });\n\n    it('goes back from step2 to step1', () => {\n      const machine = createMyWorkflowMachine({ userId: 'user-1' });\n      const actor = machine.start();\n\n      actor.send({\n        type: 'SUBMIT',\n        data: { input: 'data' },\n      });\n      actor.send({ type: 'NEXT' });\n      actor.send({ type: 'BACK' });\n\n      expect(actor.getSnapshot().value).toBe('step1');\n    });\n  });\n\n  describe('guards', () => {\n    it('allows admin to skip step', () => {\n      const machine = createMyWorkflowMachine({ userId: 'admin' });\n      const actor = machine.start();\n\n      actor.send({ type: 'NEXT' }); // Advance to step2\n      actor.send({ type: 'SKIP' });\n\n      // Should skip to step3\n      expect(actor.getSnapshot().value).toBe('step3');\n    });\n\n    it('prevents non-admin from skipping step', () => {\n      const machine = createMyWorkflowMachine({ userId: 'user-1' });\n      const actor = machine.start();\n\n      actor.send({ type: 'NEXT' });\n      actor.send({ type: 'SKIP' });\n\n      // Should still be in step2\n      expect(actor.getSnapshot().value).toBe('step2');\n    });\n  });\n\n  describe('cancellation', () => {\n    it('cancels workflow at any time', () => {\n      const machine = createMyWorkflowMachine({ userId: 'user-1' });\n      const actor = machine.start();\n\n      actor.send({ type: 'CANCEL' });\n\n      expect(actor.getSnapshot().value).toBe('cancelled');\n    });\n  });\n\n  describe('callbacks', () => {\n    it('calls onComplete when workflow succeeds', async () => {\n      const onComplete = jest.fn();\n      const machine = createMyWorkflowMachine({\n        userId: 'user-1',\n        onComplete,\n      });\n      const actor = machine.start();\n\n      // Complete workflow...\n      actor.send({ type: 'SUBMIT', data: { input: 'data' } });\n      actor.send({ type: 'NEXT' });\n      actor.send({ type: 'NEXT' });\n      actor.send({ type: 'SUBMIT' });\n\n      // Wait for async operation\n      await new Promise((resolve) => setTimeout(resolve, 100));\n\n      expect(onComplete).toHaveBeenCalled();\n    });\n  });\n});\n"})}),"\n",(0,a.jsx)(n.h3,{id:"6-export-from-barrel-index",children:"6. Export from Barrel Index"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"// libs/state/machines/src/index.ts\n\nexport {\n  createMyWorkflowMachine,\n  type MyWorkflowContext,\n  type MyWorkflowEvent,\n  type MyWorkflowConfig,\n} from './myWorkflowMachine';\n\nexport {\n  useMyWorkflow,\n  type UseMyWorkflowReturn,\n} from './hooks/useMyWorkflow';\n"})}),"\n",(0,a.jsx)(n.h3,{id:"7-create-component-usage-example",children:"7. Create Component Usage Example"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"// Example: Using MyWorkflow machine in a component\n\nimport { useMyWorkflow } from '@nasnet/state/machines';\n\nexport function MyWorkflowComponent() {\n  const {\n    state,\n    context,\n    isStep1,\n    isStep2,\n    isStep3,\n    canNext,\n    canBack,\n    isSubmitting,\n    isError,\n    next,\n    back,\n    submit,\n    cancel,\n    retry,\n  } = useMyWorkflow({\n    userId: 'current-user',\n    onComplete: (context) => {\n      console.log('Workflow completed:', context.result);\n    },\n    onError: (error) => {\n      console.error('Workflow error:', error);\n    },\n  });\n\n  return (\n    <div className=\"workflow\">\n      {/* Step 1 */}\n      {isStep1 && (\n        <div>\n          <h2>Step 1: Input</h2>\n          <Step1Form onSubmit={submit} />\n          <button onClick={next} disabled={!canNext}>\n            Next\n          </button>\n          <button onClick={cancel}>Cancel</button>\n        </div>\n      )}\n\n      {/* Step 2 */}\n      {isStep2 && (\n        <div>\n          <h2>Step 2: Configuration</h2>\n          <Step2Form onSubmit={submit} />\n          <button onClick={back} disabled={!canBack}>\n            Back\n          </button>\n          <button onClick={next} disabled={!canNext}>\n            Next\n          </button>\n          <button onClick={cancel}>Cancel</button>\n        </div>\n      )}\n\n      {/* Step 3 */}\n      {isStep3 && (\n        <div>\n          <h2>Step 3: Review</h2>\n          <ReviewSummary context={context} />\n          <button onClick={back} disabled={!canBack}>\n            Back\n          </button>\n          <button onClick={() => submit({})} disabled={isSubmitting}>\n            {isSubmitting ? 'Submitting...' : 'Submit'}\n          </button>\n          <button onClick={cancel} disabled={isSubmitting}>\n            Cancel\n          </button>\n        </div>\n      )}\n\n      {/* Error State */}\n      {isError && (\n        <div className=\"error\">\n          <p>{context.error?.message}</p>\n          <button onClick={retry}>Retry</button>\n          <button onClick={cancel}>Cancel</button>\n        </div>\n      )}\n    </div>\n  );\n}\n"})}),"\n",(0,a.jsx)(n.h2,{id:"best-practices-checklist",children:"Best Practices Checklist"}),"\n",(0,a.jsxs)(n.ul,{className:"contains-task-list",children:["\n",(0,a.jsxs)(n.li,{className:"task-list-item",children:[(0,a.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Machine file named: ",(0,a.jsx)(n.code,{children:"[workflow]Machine.ts"})]}),"\n",(0,a.jsxs)(n.li,{className:"task-list-item",children:[(0,a.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Hook file named: ",(0,a.jsx)(n.code,{children:"use[Workflow].ts"})]}),"\n",(0,a.jsxs)(n.li,{className:"task-list-item",children:[(0,a.jsx)(n.input,{type:"checkbox",disabled:!0})," ","TypeScript interfaces for Context and Events"]}),"\n",(0,a.jsxs)(n.li,{className:"task-list-item",children:[(0,a.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Initial state is first step/logical start"]}),"\n",(0,a.jsxs)(n.li,{className:"task-list-item",children:[(0,a.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Guards validate transitions"]}),"\n",(0,a.jsxs)(n.li,{className:"task-list-item",children:[(0,a.jsx)(n.input,{type:"checkbox",disabled:!0})," ","All states have exit transitions (no dead ends)"]}),"\n",(0,a.jsxs)(n.li,{className:"task-list-item",children:[(0,a.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Final states use ",(0,a.jsx)(n.code,{children:"type: 'final'"})]}),"\n",(0,a.jsxs)(n.li,{className:"task-list-item",children:[(0,a.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Async operations use ",(0,a.jsx)(n.code,{children:"invoke"})]}),"\n",(0,a.jsxs)(n.li,{className:"task-list-item",children:[(0,a.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Error states have retry option"]}),"\n",(0,a.jsxs)(n.li,{className:"task-list-item",children:[(0,a.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Tests cover all paths"]}),"\n",(0,a.jsxs)(n.li,{className:"task-list-item",children:[(0,a.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Exported from ",(0,a.jsx)(n.code,{children:"index.ts"})]}),"\n",(0,a.jsxs)(n.li,{className:"task-list-item",children:[(0,a.jsx)(n.input,{type:"checkbox",disabled:!0})," ","React hook wraps machine for easier use"]}),"\n",(0,a.jsxs)(n.li,{className:"task-list-item",children:[(0,a.jsx)(n.input,{type:"checkbox",disabled:!0})," ","JSDoc comments explaining workflow"]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"storage--persistence",children:"Storage & Persistence"}),"\n",(0,a.jsx)(n.p,{children:"To save/restore machine state:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"import {\n  persistMachineState,\n  restoreMachineState,\n} from '@nasnet/state/machines';\n\n// Save\nconst state = actor.getSnapshot();\npersistMachineState('myWorkflow', 'workflow-123', state);\n\n// Restore\nconst saved = restoreMachineState('myWorkflow', 'workflow-123');\nif (saved) {\n  actor.send({ type: 'RESTORE', state: saved });\n}\n"})}),"\n",(0,a.jsx)(n.h2,{id:"file-structure",children:"File Structure"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"libs/state/machines/src/\n\u251c\u2500\u2500 myWorkflowMachine.ts            // Machine definition\n\u251c\u2500\u2500 hooks/\n\u2502   \u2514\u2500\u2500 useMyWorkflow.ts            // React hook\n\u2514\u2500\u2500 myWorkflowMachine.test.ts        // Tests\n"})}),"\n",(0,a.jsx)(n.h2,{id:"quick-template",children:"Quick Template"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"import { setup } from 'xstate';\n\nexport interface MyMachineContext {\n  // State data\n}\n\nexport type MyMachineEvent = { type: 'NEXT' } | { type: 'BACK' };\n\nexport function createMyMachine() {\n  return setup({\n    types: {\n      context: {} as MyMachineContext,\n      events: {} as MyMachineEvent,\n    },\n  }).createMachine({\n    id: 'myMachine',\n    initial: 'initialState',\n    context: {},\n    states: {\n      initialState: {\n        on: { NEXT: 'nextState' },\n      },\n      nextState: {\n        type: 'final',\n      },\n    },\n  });\n}\n"})}),"\n",(0,a.jsx)(n.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsx)(n.li,{children:"Create machine file with template"}),"\n",(0,a.jsx)(n.li,{children:"Define context and events"}),"\n",(0,a.jsx)(n.li,{children:"Design state machine diagram"}),"\n",(0,a.jsx)(n.li,{children:"Implement states and transitions"}),"\n",(0,a.jsx)(n.li,{children:"Add guards for conditions"}),"\n",(0,a.jsx)(n.li,{children:"Create React hook wrapper"}),"\n",(0,a.jsx)(n.li,{children:"Write comprehensive tests"}),"\n",(0,a.jsx)(n.li,{children:"Export from index"}),"\n",(0,a.jsx)(n.li,{children:"Use in components"}),"\n"]}),"\n",(0,a.jsxs)(n.p,{children:["See ",(0,a.jsx)(n.a,{href:"https://stately.ai/docs/xstate",children:"XState docs"})," for advanced patterns."]})]})}function p(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}}}]);