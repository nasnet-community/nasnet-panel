"use strict";(globalThis.webpackChunk_nas_net_docs=globalThis.webpackChunk_nas_net_docs||[]).push([[76514],{71184:(e,n,s)=>{s.d(n,{R:()=>i,x:()=>a});var o=s(14041);const t={},r=o.createContext(t);function i(e){const n=o.useContext(r);return o.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:i(e.components),o.createElement(r.Provider,{value:n},e.children)}},72559:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>u,frontMatter:()=>i,metadata:()=>o,toc:()=>c});const o=JSON.parse('{"id":"shared-hooks","title":"Shared Hooks Reference","description":"This document covers every reusable hook exported from libs/ui/. For each hook you will find the full TypeScript signature, parameter descriptions, return type, and a usage example drawn directly from the source.","source":"@site/../../libs/ui/docs/shared-hooks.md","sourceDirName":".","slug":"/shared-hooks","permalink":"/docs/ui/shared-hooks","draft":false,"unlisted":false,"editUrl":"https://github.com/nasnet-community/nasnet-panel/tree/main/../../libs/ui/docs/shared-hooks.md","tags":[],"version":"current","frontMatter":{},"sidebar":"sidebar","previous":{"title":"Primitives Reference (Layer 1)","permalink":"/docs/ui/primitives-reference"},"next":{"title":"Design Tokens & Animation System","permalink":"/docs/ui/tokens-and-animation"}}');var t=s(31085),r=s(71184);const i={},a="Shared Hooks Reference",l={},c=[{value:"Platform Hooks",id:"platform-hooks",level:2},{value:"Memoization Hooks",id:"memoization-hooks",level:2},{value:"<code>useMemoizedFilter</code>",id:"usememoizedfilter",level:3},{value:"<code>useMemoizedSort</code>",id:"usememoizedsort",level:3},{value:"<code>useMemoizedFilterSort</code>",id:"usememoizedfiltersort",level:3},{value:"<code>useMemoizedMap</code>",id:"usememoizedmap",level:3},{value:"<code>useMemoizedFind</code>",id:"usememoizedfind",level:3},{value:"<code>useMemoizedGroupBy</code>",id:"usememoizedgroupby",level:3},{value:"<code>useMemoizedReduce</code>",id:"usememoizedreduce",level:3},{value:"<code>useMemoizedUnique</code>",id:"usememoizedunique",level:3},{value:"Stable Callback Hooks",id:"stable-callback-hooks",level:2},{value:"<code>useStableCallback</code>",id:"usestablecallback",level:3},{value:"<code>useStableEventHandler</code>",id:"usestableeventhandler",level:3},{value:"<code>useStableCallbackWithDeps</code>",id:"usestablecallbackwithdeps",level:3},{value:"<code>useDebouncedCallback</code>",id:"usedebouncedcallback",level:3},{value:"<code>useThrottledCallback</code>",id:"usethrottledcallback",level:3},{value:"Toast Hook",id:"toast-hook",level:2},{value:"Signature",id:"signature",level:3},{value:"Return type",id:"return-type",level:3},{value:"Option types",id:"option-types",level:3},{value:"Behaviour notes",id:"behaviour-notes",level:3},{value:"Usage examples",id:"usage-examples",level:3},{value:"Clipboard Hooks",id:"clipboard-hooks",level:2},{value:"<code>useClipboard</code>",id:"useclipboard",level:3},{value:"<code>useBulkCopy</code>",id:"usebulkcopy",level:3},{value:"<code>usePasteImport</code>",id:"usepasteimport",level:3},{value:"useUnsavedChanges",id:"useunsavedchanges",level:2},{value:"Signature",id:"signature-1",level:3},{value:"Options",id:"options",level:3},{value:"Return type",id:"return-type-1",level:3},{value:"Helper function",id:"helper-function",level:3},{value:"Dialog props",id:"dialog-props",level:3},{value:"Usage with React Hook Form",id:"usage-with-react-hook-form",level:3},{value:"Focus Hooks",id:"focus-hooks",level:2},{value:"<code>useFocusRestore</code>",id:"usefocusrestore",level:3},{value:"<code>useFocusManagement</code>",id:"usefocusmanagement",level:3},{value:"Primitive Hooks",id:"primitive-hooks",level:2},{value:"<code>useReducedMotion</code>",id:"usereducedmotion",level:3},{value:"<code>useMediaQuery</code>",id:"usemediaquery",level:3},{value:"Motion Hooks (from layouts)",id:"motion-hooks-from-layouts",level:2},{value:"<code>useAnimationDuration</code>",id:"useanimationduration",level:3},{value:"<code>useMotionConfig</code>",id:"usemotionconfig",level:3},{value:"<code>useMotionClasses</code>",id:"usemotionclasses",level:3},{value:"Hook Composition Patterns",id:"hook-composition-patterns",level:2},{value:"Live search with debounced filter",id:"live-search-with-debounced-filter",level:3},{value:"Stable table action handler",id:"stable-table-action-handler",level:3},{value:"Modal with full accessibility",id:"modal-with-full-accessibility",level:3},{value:"Best practices for hook dependencies",id:"best-practices-for-hook-dependencies",level:3},{value:"Cross-References",id:"cross-references",level:2}];function d(e){const n={code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"shared-hooks-reference",children:"Shared Hooks Reference"})}),"\n",(0,t.jsxs)(n.p,{children:["This document covers every reusable hook exported from ",(0,t.jsx)(n.code,{children:"libs/ui/"}),". For each hook you will find the full TypeScript signature, parameter descriptions, return type, and a usage example drawn directly from the source."]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Import paths at a glance:"})}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Hook group"}),(0,t.jsx)(n.th,{children:"Import from"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Platform hooks"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"@nasnet/ui/layouts"})})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Memoization hooks"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"@nasnet/ui/patterns"})})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Stable callback hooks"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"@nasnet/ui/patterns"})})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Toast hook"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"@nasnet/ui/patterns"})})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Clipboard hooks"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"@nasnet/ui/patterns"})})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Unsaved changes hook"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"@nasnet/ui/patterns"})})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Focus hooks"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"@nasnet/ui/patterns"})})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Primitive hooks"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"@nasnet/ui/primitives"})})]})]})]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"platform-hooks",children:"Platform Hooks"}),"\n",(0,t.jsxs)(n.p,{children:["Platform hooks live in ",(0,t.jsx)(n.code,{children:"libs/ui/layouts/src/responsive-shell/"})," and are exported from ",(0,t.jsx)(n.code,{children:"@nasnet/ui/layouts"}),". They implement the Headless + Platform Presenters architecture (ADR-018) and are the primary mechanism for adaptive rendering across Mobile / Tablet / Desktop viewports."]}),"\n",(0,t.jsxs)(n.p,{children:["The full reference for these hooks \u2014 including breakpoint thresholds, ",(0,t.jsx)(n.code,{children:"PlatformProvider"}),", ",(0,t.jsx)(n.code,{children:"PlatformSwitch"}),", and the ",(0,t.jsx)(n.code,{children:"usePlatformContext"})," API \u2014 is in ",(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"layouts-and-platform.md"})}),". The table below lists every platform hook for quick lookup."]}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Hook"}),(0,t.jsx)(n.th,{children:"Signature"}),(0,t.jsx)(n.th,{children:"Returns"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"usePlatform"})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"(debounceMs?: number): Platform"})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"'mobile' | 'tablet' | 'desktop'"})})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"usePlatformWithBreakpoint"})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"(debounceMs?: number)"})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"{ platform: Platform; breakpoint: Breakpoint }"})})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"useIsMobile"})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"(debounceMs?: number): boolean"})}),(0,t.jsxs)(n.td,{children:[(0,t.jsx)(n.code,{children:"true"})," when viewport < 640 px"]})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"useIsTablet"})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"(debounceMs?: number): boolean"})}),(0,t.jsxs)(n.td,{children:[(0,t.jsx)(n.code,{children:"true"})," when viewport 640\u20131024 px"]})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"useIsDesktop"})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"(debounceMs?: number): boolean"})}),(0,t.jsxs)(n.td,{children:[(0,t.jsx)(n.code,{children:"true"})," when viewport > 1024 px"]})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"useIsTouchPlatform"})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"(debounceMs?: number): boolean"})}),(0,t.jsxs)(n.td,{children:[(0,t.jsx)(n.code,{children:"true"})," on mobile or tablet"]})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"usePlatformConfig<T>"})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"(config: Record<Platform, T>): T"})}),(0,t.jsx)(n.td,{children:"Config value for current platform"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"useBreakpoint"})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"(debounceMs?: number): Breakpoint"})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"'xs' | 'sm' | 'md' | 'lg' | 'xl'"})})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"useViewportWidth"})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"(debounceMs?: number): number"})}),(0,t.jsx)(n.td,{children:"Viewport width in pixels"})]})]})]}),"\n",(0,t.jsx)(n.p,{children:"All platform hooks are debounced (default 100 ms) and SSR-safe."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-tsx",children:"import { usePlatform, usePlatformConfig } from '@nasnet/ui/layouts';\n\n// Switch between presenters\nexport function RouterCard(props: RouterCardProps) {\n  const platform = usePlatform();\n\n  switch (platform) {\n    case 'mobile':  return <RouterCardMobile  {...props} />;\n    case 'tablet':  return <RouterCardTablet  {...props} />;\n    case 'desktop': return <RouterCardDesktop {...props} />;\n  }\n}\n\n// Platform-specific configuration without conditional rendering\nfunction InterfaceGrid() {\n  const layout = usePlatformConfig({\n    mobile:  { columns: 1, gap: 'sm' },\n    tablet:  { columns: 2, gap: 'md' },\n    desktop: { columns: 3, gap: 'lg' },\n  });\n\n  return <Grid columns={layout.columns} gap={layout.gap}>{/*...*/}</Grid>;\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["See ",(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"layouts-and-platform.md"})})," for the full platform hooks guide."]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"memoization-hooks",children:"Memoization Hooks"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Source:"})," ",(0,t.jsx)(n.code,{children:"libs/ui/patterns/src/hooks/useMemoizedFilter.ts"}),"\n",(0,t.jsx)(n.strong,{children:"Import:"})," ",(0,t.jsx)(n.code,{children:"import { useMemoizedFilter, ... } from '@nasnet/ui/patterns';"})]}),"\n",(0,t.jsxs)(n.p,{children:["These eight hooks wrap ",(0,t.jsx)(n.code,{children:"useMemo"})," with a consistent dependency pattern \u2014 ",(0,t.jsx)(n.code,{children:"[items, ...deps]"})," \u2014 so that an array operation only re-runs when the array reference or one of the explicit extra dependencies changes. Always pass stable function references (via ",(0,t.jsx)(n.code,{children:"useCallback"})," or ",(0,t.jsx)(n.code,{children:"useStableCallback"}),") to keep the dependency arrays minimal."]}),"\n",(0,t.jsx)(n.h3,{id:"usememoizedfilter",children:(0,t.jsx)(n.code,{children:"useMemoizedFilter"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"function useMemoizedFilter<T>(\n  items: T[],\n  filterFn: (item: T, index: number, array: T[]) => boolean,\n  deps: DependencyList\n): T[]\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Memoizes ",(0,t.jsx)(n.code,{children:"items.filter(filterFn)"}),". Returns a stable array reference when neither ",(0,t.jsx)(n.code,{children:"items"})," nor any value in ",(0,t.jsx)(n.code,{children:"deps"})," has changed."]}),"\n",(0,t.jsx)(n.p,{children:"When to use: any list that conditionally hides entries based on state that does not change on every render (status filter, search results after debounce, permission checks)."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-tsx",children:"import { useMemoizedFilter } from '@nasnet/ui/patterns';\n\nfunction RouterList({ routers }: { routers: Router[] }) {\n  const onlineRouters = useMemoizedFilter(\n    routers,\n    (r) => r.status === 'online',\n    [] // predicate is pure \u2014 no extra deps needed\n  );\n\n  return <>{onlineRouters.map((r) => <RouterCard key={r.id} router={r} />)}</>;\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"usememoizedsort",children:(0,t.jsx)(n.code,{children:"useMemoizedSort"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"function useMemoizedSort<T>(\n  items: T[],\n  sortFn: (a: T, b: T) => number,\n  deps: DependencyList\n): T[]\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Returns ",(0,t.jsx)(n.code,{children:"[...items].sort(sortFn)"}),". Creates a shallow copy before sorting, so the original array is never mutated."]}),"\n",(0,t.jsxs)(n.p,{children:["When to use: tables and lists where the user selects a sort column. Put ",(0,t.jsx)(n.code,{children:"[sortColumn, sortDirection]"})," in ",(0,t.jsx)(n.code,{children:"deps"}),"."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-tsx",children:"import { useMemoizedSort } from '@nasnet/ui/patterns';\n\nfunction SortedInterfaceList({ interfaces, sortColumn, sortDirection }) {\n  const sorted = useMemoizedSort(\n    interfaces,\n    (a, b) => {\n      const cmp = a[sortColumn] < b[sortColumn] ? -1 : a[sortColumn] > b[sortColumn] ? 1 : 0;\n      return sortDirection === 'asc' ? cmp : -cmp;\n    },\n    [sortColumn, sortDirection]\n  );\n\n  return <InterfaceTable rows={sorted} />;\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"usememoizedfiltersort",children:(0,t.jsx)(n.code,{children:"useMemoizedFilterSort"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"function useMemoizedFilterSort<T>(\n  items: T[],\n  filterFn: ((item: T, index: number, array: T[]) => boolean) | null,\n  sortFn: ((a: T, b: T) => number) | null,\n  deps: DependencyList\n): T[]\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Runs filter then sort in a single memoized pass. Pass ",(0,t.jsx)(n.code,{children:"null"})," for either function to skip that step."]}),"\n",(0,t.jsxs)(n.p,{children:["When to use: data tables that support both filtering and sorting simultaneously. Consolidates two separate ",(0,t.jsx)(n.code,{children:"useMemo"})," calls into one."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-tsx",children:"import { useMemoizedFilterSort } from '@nasnet/ui/patterns';\n\nfunction ServiceList({ services, filter, sortField }) {\n  const displayItems = useMemoizedFilterSort(\n    services,\n    filter ? (s) => s.name.includes(filter) : null, // skip filter if empty\n    (a, b) => a[sortField].localeCompare(b[sortField]),\n    [filter, sortField]\n  );\n\n  return <ServiceTable rows={displayItems} />;\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"usememoizedmap",children:(0,t.jsx)(n.code,{children:"useMemoizedMap"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"function useMemoizedMap<T, U>(\n  items: T[],\n  mapFn: (item: T, index: number, array: T[]) => U,\n  deps: DependencyList\n): U[]\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Memoizes ",(0,t.jsx)(n.code,{children:"items.map(mapFn)"}),". Use when you need a derived array (e.g., formatting display labels) that should not recompute on unrelated state changes."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-tsx",children:"import { useMemoizedMap } from '@nasnet/ui/patterns';\n\nfunction IPAddressList({ interfaces }) {\n  const labels = useMemoizedMap(\n    interfaces,\n    (iface) => `${iface.name} \u2014 ${iface.address}`,\n    []\n  );\n\n  return <ul>{labels.map((l, i) => <li key={i}>{l}</li>)}</ul>;\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"usememoizedfind",children:(0,t.jsx)(n.code,{children:"useMemoizedFind"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"function useMemoizedFind<T>(\n  items: T[],\n  predicate: (item: T, index: number, array: T[]) => boolean,\n  deps: DependencyList\n): T | undefined\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Memoizes ",(0,t.jsx)(n.code,{children:"items.find(predicate)"}),". Returns ",(0,t.jsx)(n.code,{children:"undefined"})," when no item matches."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-tsx",children:"import { useMemoizedFind } from '@nasnet/ui/patterns';\n\nfunction SelectedRouter({ routers, selectedId }) {\n  const selected = useMemoizedFind(\n    routers,\n    (r) => r.id === selectedId,\n    [selectedId]\n  );\n\n  return selected ? <RouterDetail router={selected} /> : <EmptyState />;\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"usememoizedgroupby",children:(0,t.jsx)(n.code,{children:"useMemoizedGroupBy"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"function useMemoizedGroupBy<T, K>(\n  items: T[],\n  keyFn: (item: T) => K,\n  deps: DependencyList\n): Map<K, T[]>\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Builds a ",(0,t.jsx)(n.code,{children:"Map<K, T[]>"})," grouping items by the key returned from ",(0,t.jsx)(n.code,{children:"keyFn"}),". Returns a stable ",(0,t.jsx)(n.code,{children:"Map"})," reference when inputs are unchanged."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-tsx",children:"import { useMemoizedGroupBy } from '@nasnet/ui/patterns';\n\nfunction VPNClientsByStatus({ clients }) {\n  const byStatus = useMemoizedGroupBy(\n    clients,\n    (c) => c.status,\n    []\n  );\n\n  return (\n    <>\n      <Section title=\"Online\">\n        {(byStatus.get('online') ?? []).map((c) => <ClientRow key={c.id} client={c} />)}\n      </Section>\n      <Section title=\"Offline\">\n        {(byStatus.get('offline') ?? []).map((c) => <ClientRow key={c.id} client={c} />)}\n      </Section>\n    </>\n  );\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"usememoizedreduce",children:(0,t.jsx)(n.code,{children:"useMemoizedReduce"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"function useMemoizedReduce<T, U>(\n  items: T[],\n  reducer: (accumulator: U, currentValue: T, index: number, array: T[]) => U,\n  initialValue: U,\n  deps: DependencyList\n): U\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Memoizes ",(0,t.jsx)(n.code,{children:"items.reduce(reducer, initialValue)"}),". Suitable for computing aggregates (totals, counts, combined bandwidth) that would otherwise run on every render."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-tsx",children:"import { useMemoizedReduce } from '@nasnet/ui/patterns';\n\nfunction BandwidthSummary({ interfaces }) {\n  const totalBytes = useMemoizedReduce(\n    interfaces,\n    (sum, iface) => sum + iface.rxBytes + iface.txBytes,\n    0,\n    []\n  );\n\n  return <Stat label=\"Total traffic\" value={formatBytes(totalBytes)} />;\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"usememoizedunique",children:(0,t.jsx)(n.code,{children:"useMemoizedUnique"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"function useMemoizedUnique<T>(\n  items: T[],\n  keyFn: ((item: T) => unknown) | null,\n  deps: DependencyList\n): T[]\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Returns an array with duplicate entries removed. For primitive arrays pass ",(0,t.jsx)(n.code,{children:"null"})," as ",(0,t.jsx)(n.code,{children:"keyFn"}),"; for object arrays provide a key extractor."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-tsx",children:"import { useMemoizedUnique } from '@nasnet/ui/patterns';\n\n// Primitive deduplication\nfunction UniqueStatuses({ logs }) {\n  const statuses = useMemoizedUnique(\n    logs.map((l) => l.status),\n    null,\n    []\n  );\n  // \u2192 ['info', 'warning', 'error']\n\n  return <FilterChips options={statuses} />;\n}\n\n// Object deduplication by id\nfunction UniqueRouters({ events }) {\n  const routers = useMemoizedUnique(\n    events.map((e) => e.router),\n    (r) => r.id,\n    []\n  );\n\n  return <RouterList routers={routers} />;\n}\n"})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"stable-callback-hooks",children:"Stable Callback Hooks"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Source:"})," ",(0,t.jsx)(n.code,{children:"libs/ui/patterns/src/hooks/useStableCallback.ts"}),"\n",(0,t.jsx)(n.strong,{children:"Import:"})," ",(0,t.jsx)(n.code,{children:"import { useStableCallback, ... } from '@nasnet/ui/patterns';"})]}),"\n",(0,t.jsxs)(n.p,{children:["These hooks solve the classic tension between ",(0,t.jsx)(n.code,{children:"useCallback"})," with empty deps (stale closure values) and ",(0,t.jsx)(n.code,{children:"useCallback"})," with all deps (identity changes on every render). They guarantee a stable function reference while always calling the latest version of the callback."]}),"\n",(0,t.jsx)(n.h3,{id:"usestablecallback",children:(0,t.jsx)(n.code,{children:"useStableCallback"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"function useStableCallback<T extends (...args: never[]) => unknown>(\n  callback: T\n): T\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Creates a callback whose identity never changes across renders, but which always invokes the current version of ",(0,t.jsx)(n.code,{children:"callback"}),". Internally stores ",(0,t.jsx)(n.code,{children:"callback"})," in a ",(0,t.jsx)(n.code,{children:"ref"})," and returns a permanent wrapper."]}),"\n",(0,t.jsxs)(n.p,{children:["When to use: event handlers passed to memoized child components (",(0,t.jsx)(n.code,{children:"React.memo"}),") where you want zero re-renders caused by the callback, yet still need access to fresh closure values."]}),"\n",(0,t.jsxs)(n.p,{children:["Comparison with ",(0,t.jsx)(n.code,{children:"useCallback"}),": ",(0,t.jsx)(n.code,{children:"useCallback(fn, [])"})," gives a stable identity but captures stale values; ",(0,t.jsx)(n.code,{children:"useCallback(fn, [dep1, dep2])"})," gives fresh values but triggers downstream re-renders when deps change. ",(0,t.jsx)(n.code,{children:"useStableCallback"})," gives both."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-tsx",children:"import { useStableCallback } from '@nasnet/ui/patterns';\n\nfunction SearchPanel({ onSearch }: { onSearch: (query: string) => void }) {\n  const [debounceMs, setDebounceMs] = useState(300);\n\n  // Identity never changes even when debounceMs changes.\n  // Safe to pass to a memoized child without causing re-renders.\n  const handleSearch = useStableCallback((query: string) => {\n    setTimeout(() => onSearch(query), debounceMs);\n  });\n\n  return <MemoizedInput onSubmit={handleSearch} />;\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"usestableeventhandler",children:(0,t.jsx)(n.code,{children:"useStableEventHandler"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"function useStableEventHandler<E extends { preventDefault: () => void }>(\n  handler: (event: E) => void | Promise<void>\n): (event: E) => void\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Wraps ",(0,t.jsx)(n.code,{children:"handler"})," to call ",(0,t.jsx)(n.code,{children:"event.preventDefault()"})," automatically before delegating to the latest version of ",(0,t.jsx)(n.code,{children:"handler"}),". Returns a permanently stable reference."]}),"\n",(0,t.jsxs)(n.p,{children:["When to use: form ",(0,t.jsx)(n.code,{children:"onSubmit"}),", link ",(0,t.jsx)(n.code,{children:"onClick"}),", and any handler where preventing default browser behavior is always required."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-tsx",children:"import { useStableEventHandler } from '@nasnet/ui/patterns';\n\nfunction LoginForm({ onSubmit }) {\n  const handleSubmit = useStableEventHandler(async (e: React.FormEvent) => {\n    await onSubmit(formData);\n  });\n\n  return <form onSubmit={handleSubmit}>...</form>;\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"usestablecallbackwithdeps",children:(0,t.jsx)(n.code,{children:"useStableCallbackWithDeps"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"function useStableCallbackWithDeps<T extends (...args: never[]) => unknown>(\n  callback: T,\n  deps: DependencyList\n): T\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Middle ground between ",(0,t.jsx)(n.code,{children:"useStableCallback"})," and ",(0,t.jsx)(n.code,{children:"useCallback"}),". The returned function's identity only changes when a value in ",(0,t.jsx)(n.code,{children:"deps"})," changes \u2014 not on every render. Extra non-dep values in the closure are always current because the callback ref is updated on every render."]}),"\n",(0,t.jsx)(n.p,{children:"When to use: when you need a callback to change identity only on specific dependency changes (e.g., when the user switches router context), but you don't want it changing on every other state update."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-tsx",children:"import { useStableCallbackWithDeps } from '@nasnet/ui/patterns';\n\nfunction RouterDataPanel({ routerId }) {\n  const [showAdvanced, setShowAdvanced] = useState(false);\n\n  // Identity changes only when routerId changes.\n  // showAdvanced is always current without being a dep.\n  const fetchData = useStableCallbackWithDeps(\n    () => api.fetchRouter(routerId, { advanced: showAdvanced }),\n    [routerId]\n  );\n\n  useEffect(() => { fetchData(); }, [fetchData]);\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"usedebouncedcallback",children:(0,t.jsx)(n.code,{children:"useDebouncedCallback"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"function useDebouncedCallback<T extends (...args: never[]) => unknown>(\n  callback: T,\n  delay: number\n): T\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Returns a debounced version of ",(0,t.jsx)(n.code,{children:"callback"}),". Calls are coalesced: the underlying callback only runs after ",(0,t.jsx)(n.code,{children:"delay"})," milliseconds have elapsed with no new calls. The timeout is cleared on component unmount. Identity changes when ",(0,t.jsx)(n.code,{children:"delay"})," changes."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-tsx",children:'import { useDebouncedCallback } from \'@nasnet/ui/patterns\';\n\nfunction SearchInput({ onSearch }) {\n  const debouncedSearch = useDebouncedCallback(\n    (query: string) => onSearch(query),\n    300\n  );\n\n  return (\n    <input\n      type="search"\n      onChange={(e) => debouncedSearch(e.target.value)}\n      placeholder="Search..."\n    />\n  );\n}\n'})}),"\n",(0,t.jsx)(n.h3,{id:"usethrottledcallback",children:(0,t.jsx)(n.code,{children:"useThrottledCallback"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"function useThrottledCallback<T extends (...args: never[]) => unknown>(\n  callback: T,\n  delay: number\n): T\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Returns a throttled version of ",(0,t.jsx)(n.code,{children:"callback"}),". The callback runs at most once per ",(0,t.jsx)(n.code,{children:"delay"})," milliseconds. A trailing call is always scheduled so the final invocation is never silently dropped. The timeout is cleared on component unmount."]}),"\n",(0,t.jsxs)(n.p,{children:["Comparison with ",(0,t.jsx)(n.code,{children:"useDebouncedCallback"}),": throttle executes ",(0,t.jsx)(n.em,{children:"at the leading edge"})," and then limits frequency; debounce waits for a ",(0,t.jsx)(n.em,{children:"quiet period"})," before executing."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-tsx",children:"import { useThrottledCallback } from '@nasnet/ui/patterns';\n\nfunction TrafficMonitor({ onScroll }) {\n  const throttledScroll = useThrottledCallback(\n    (scrollY: number) => onScroll(scrollY),\n    100 // at most once every 100 ms\n  );\n\n  useEffect(() => {\n    const handler = () => throttledScroll(window.scrollY);\n    window.addEventListener('scroll', handler);\n    return () => window.removeEventListener('scroll', handler);\n  }, [throttledScroll]);\n}\n"})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"toast-hook",children:"Toast Hook"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Source:"})," ",(0,t.jsx)(n.code,{children:"libs/ui/patterns/src/hooks/useToast.ts"}),"\n",(0,t.jsx)(n.strong,{children:"Import:"})," ",(0,t.jsx)(n.code,{children:"import { useToast } from '@nasnet/ui/patterns';"})]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"useToast"})," bridges the Zustand notification store (",(0,t.jsx)(n.code,{children:"@nasnet/state/stores"}),") and the Sonner toast library. It returns a stable object with methods for every notification type. All method return values are notification IDs (strings) that can be used for later updates or dismissal."]}),"\n",(0,t.jsx)(n.h3,{id:"signature",children:"Signature"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"function useToast(): UseToastReturn\n"})}),"\n",(0,t.jsx)(n.h3,{id:"return-type",children:"Return type"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"interface UseToastReturn {\n  toast(options: GenericToastOptions): string;\n  success(title: string, options?: ToastOptions): string;\n  error(title: string, options?: ToastOptions): string;\n  warning(title: string, options?: ToastOptions): string;\n  info(title: string, options?: ToastOptions): string;\n  progress(title: string, options?: ProgressToastOptions): string;\n  update(id: string, updates: Partial<NotificationInput>): void;\n  dismiss(id: string): void;\n  dismissAll(): void;\n  promise<T>(promise: Promise<T>, messages: PromiseToastMessages<T>): Promise<T>;\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"option-types",children:"Option types"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"interface ToastOptions {\n  message?: string;          // Body text beneath the title\n  duration?: number | null;  // ms before auto-dismiss; null = persistent\n  action?: NotificationAction;\n}\n\ninterface ProgressToastOptions extends ToastOptions {\n  progress?: number;         // Initial progress 0\u2013100\n}\n\ninterface PromiseToastMessages<T> {\n  loading: string;\n  success: string | ((data: T) => string);\n  error: string | ((error: unknown) => string);\n}\n\ninterface GenericToastOptions {\n  title?: string;\n  description?: string;\n  variant?: 'default' | 'destructive';\n  duration?: number | null;\n  action?: NotificationAction;\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"behaviour-notes",children:"Behaviour notes"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"error"})})," is persistent by default (",(0,t.jsx)(n.code,{children:"duration: null"}),"). All other types auto-dismiss."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"progress"})})," never auto-dismisses. Call ",(0,t.jsx)(n.code,{children:"dismiss(id)"})," when the operation completes."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"promise"})})," shows a progress toast while the promise is pending, then replaces it with a success or error toast based on the result. It re-throws on failure so you can still ",(0,t.jsx)(n.code,{children:"catch"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"toast"})})," (generic) maps ",(0,t.jsx)(n.code,{children:"variant: 'destructive'"})," to ",(0,t.jsx)(n.code,{children:"'error'"})," type; everything else becomes ",(0,t.jsx)(n.code,{children:"'info'"}),"."]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"usage-examples",children:"Usage examples"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-tsx",children:"import { useToast } from '@nasnet/ui/patterns';\n\n// Basic usage\nfunction SaveButton() {\n  const { success, error } = useToast();\n\n  const handleSave = async () => {\n    try {\n      await saveConfiguration();\n      success('Configuration saved');\n    } catch (e) {\n      error('Save failed', { message: (e as Error).message });\n    }\n  };\n\n  return <Button onClick={handleSave}>Save</Button>;\n}\n\n// promise() helper\nfunction DeployButton() {\n  const { promise } = useToast();\n\n  const handleDeploy = () => {\n    promise(deployService(), {\n      loading: 'Deploying service...',\n      success: (result) => `Deployed ${result.name} successfully`,\n      error: (e) => `Deploy failed: ${(e as Error).message}`,\n    });\n  };\n\n  return <Button onClick={handleDeploy}>Deploy</Button>;\n}\n\n// progress() with manual updates\nfunction FirmwareUpload() {\n  const { progress, update, dismiss, success } = useToast();\n\n  const handleUpload = async () => {\n    const id = progress('Uploading firmware...', { progress: 0 });\n\n    for (let pct = 0; pct <= 100; pct += 10) {\n      await delay(200);\n      update(id, { progress: pct });\n    }\n\n    dismiss(id);\n    success('Firmware uploaded successfully');\n  };\n\n  return <Button onClick={handleUpload}>Upload</Button>;\n}\n\n// Generic toast (shadcn-compatible API)\nfunction NotifyButton() {\n  const { toast } = useToast();\n\n  return (\n    <Button\n      onClick={() => toast({ title: 'Action taken', description: 'Details here' })}\n    >\n      Notify\n    </Button>\n  );\n}\n"})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"clipboard-hooks",children:"Clipboard Hooks"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Source:"})," ",(0,t.jsx)(n.code,{children:"libs/ui/patterns/src/hooks/useClipboard.ts"}),", ",(0,t.jsx)(n.code,{children:"useBulkCopy.ts"}),", ",(0,t.jsx)(n.code,{children:"usePasteImport.ts"}),"\n",(0,t.jsx)(n.strong,{children:"Import:"})," ",(0,t.jsx)(n.code,{children:"import { useClipboard, useBulkCopy, usePasteImport } from '@nasnet/ui/patterns';"})]}),"\n",(0,t.jsx)(n.h3,{id:"useclipboard",children:(0,t.jsx)(n.code,{children:"useClipboard"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"function useClipboard(options?: UseClipboardOptions): UseClipboardReturn\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Copies a single string to the clipboard. Uses the modern ",(0,t.jsx)(n.code,{children:"navigator.clipboard.writeText"})," API with an ",(0,t.jsx)(n.code,{children:"execCommand"})," fallback for older browsers. Automatically resets the ",(0,t.jsx)(n.code,{children:"copied"})," flag after ",(0,t.jsx)(n.code,{children:"timeout"})," ms."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"interface UseClipboardOptions {\n  timeout?: number;             // ms before 'copied' resets \u2014 default 2000\n  onSuccess?: (value: string) => void;\n  onError?: (error: Error) => void;\n}\n\ninterface UseClipboardReturn {\n  copy(value: string): Promise<boolean>;\n  copied: boolean;\n  error: Error | null;\n  reset(): void;\n  isLoading: boolean;\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["The exported constant ",(0,t.jsx)(n.code,{children:"CLIPBOARD_TIMEOUT_MS = 2000"})," is the default timeout value."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-tsx",children:"import { useClipboard } from '@nasnet/ui/patterns';\nimport { Check, Copy } from 'lucide-react';\n\nfunction CopyIPButton({ ip }: { ip: string }) {\n  const { copy, copied, isLoading } = useClipboard();\n\n  return (\n    <Button\n      variant=\"ghost\"\n      size=\"icon\"\n      onClick={() => copy(ip)}\n      disabled={isLoading}\n      aria-label={copied ? 'Copied' : 'Copy IP address'}\n    >\n      {copied ? <Check className=\"h-4 w-4\" /> : <Copy className=\"h-4 w-4\" />}\n    </Button>\n  );\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"usebulkcopy",children:(0,t.jsx)(n.code,{children:"useBulkCopy"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"function useBulkCopy(options?: UseBulkCopyOptions): UseBulkCopyReturn\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Copies multiple table rows to the clipboard in CSV, JSON, or plain-text format. Builds on ",(0,t.jsx)(n.code,{children:"useClipboard"})," internally."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"type ExportFormat = 'csv' | 'json' | 'text';\n\ninterface UseBulkCopyOptions {\n  defaultFormat?: ExportFormat;    // default 'csv'\n  timeout?: number;                // default 2000\n  csvDelimiter?: string;           // default ','\n  includeHeader?: boolean;         // default true\n  textSeparator?: string;          // default '\\n'\n  jsonIndent?: number;             // default 2\n  onSuccess?: (count: number, format: ExportFormat) => void;\n  onError?: (error: Error) => void;\n}\n\ninterface UseBulkCopyReturn {\n  copyItems<T extends Record<string, unknown>>(\n    items: T[],\n    columns?: (keyof T)[]\n  ): Promise<boolean>;\n  format: ExportFormat;\n  setFormat(format: ExportFormat): void;\n  copied: boolean;\n  copiedCount: number;\n  error: Error | null;\n  reset(): void;\n  isLoading: boolean;\n  supportedFormats: readonly ExportFormat[];\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Exported constants: ",(0,t.jsx)(n.code,{children:"SUPPORTED_FORMATS = ['csv', 'json', 'text']"}),", ",(0,t.jsx)(n.code,{children:"FORMAT_LABELS = { csv: 'CSV', json: 'JSON', text: 'Plain Text' }"}),"."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-tsx",children:"import { useBulkCopy, FORMAT_LABELS, SUPPORTED_FORMATS } from '@nasnet/ui/patterns';\n\nfunction ARPTableActions({ selectedRows }: { selectedRows: ArpEntry[] }) {\n  const { copyItems, format, setFormat, copied, copiedCount } = useBulkCopy({\n    defaultFormat: 'csv',\n    onSuccess: (count, fmt) => console.log(`Copied ${count} rows as ${fmt}`),\n  });\n\n  return (\n    <div className=\"flex gap-2\">\n      <Select value={format} onValueChange={(v) => setFormat(v as ExportFormat)}>\n        {SUPPORTED_FORMATS.map((f) => (\n          <SelectItem key={f} value={f}>{FORMAT_LABELS[f]}</SelectItem>\n        ))}\n      </Select>\n\n      <Button\n        onClick={() => copyItems(selectedRows, ['ip', 'mac', 'interface'])}\n        disabled={selectedRows.length === 0}\n      >\n        {copied ? `Copied ${copiedCount} rows` : 'Copy Selected'}\n      </Button>\n    </div>\n  );\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"usepasteimport",children:(0,t.jsx)(n.code,{children:"usePasteImport"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"function usePasteImport(options?: UsePasteImportOptions): UsePasteImportReturn\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Parses clipboard content pasted into a ",(0,t.jsx)(n.code,{children:"textarea"})," or other element. Supports IP lists, CSV, RouterOS command sequences, and auto-detection. Validates each line and collects structured errors."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"type ImportType = 'ip-list' | 'csv' | 'routeros' | 'auto';\n\ninterface UsePasteImportOptions {\n  type?: ImportType;           // default 'auto'\n  maxItems?: number;           // default 1000\n  csvDelimiter?: string;       // default ','\n  csvColumns?: string[];       // validate expected CSV headers\n  onParsed?: (result: ParseResult) => void;\n  onError?: (error: Error) => void;\n}\n\ninterface UsePasteImportReturn {\n  handlePaste(event: React.ClipboardEvent): void;\n  parseContent(content: string): ParseResult;\n  parseResult: ParseResult | null;\n  clearResult(): void;\n  isParsing: boolean;\n}\n\ninterface ParseResult {\n  success: boolean;\n  type: ImportType;\n  items: ParsedItem[];\n  errors: ValidationError[];\n  totalLines: number;\n  rawContent: string;\n}\n\ninterface ParsedItem {\n  line: number;\n  original: string;\n  value: string | Record<string, string>;\n}\n\ninterface ValidationError {\n  line: number;\n  message: string;\n  content: string;\n}\n"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-tsx",children:'import { usePasteImport } from \'@nasnet/ui/patterns\';\n\nfunction AddressListImport({ onImport }) {\n  const { handlePaste, parseResult, clearResult, isParsing } = usePasteImport({\n    type: \'ip-list\',\n    maxItems: 500,\n    onParsed: (result) => {\n      if (result.success) {\n        onImport(result.items.map((i) => i.value as string));\n      }\n    },\n  });\n\n  return (\n    <div>\n      <textarea\n        onPaste={handlePaste}\n        placeholder="Paste IP addresses here (one per line)"\n        className="w-full h-32 font-mono text-sm"\n      />\n      {isParsing && <Spinner />}\n      {parseResult && !parseResult.success && (\n        <ErrorList errors={parseResult.errors} />\n      )}\n      {parseResult && (\n        <Button variant="ghost" size="sm" onClick={clearResult}>\n          Clear\n        </Button>\n      )}\n    </div>\n  );\n}\n'})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"useunsavedchanges",children:"useUnsavedChanges"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Source:"})," ",(0,t.jsx)(n.code,{children:"libs/ui/patterns/src/hooks/useUnsavedChanges.ts"}),"\n",(0,t.jsx)(n.strong,{children:"Import:"})," ",(0,t.jsx)(n.code,{children:"import { useUnsavedChanges, getUnsavedChangesMessage } from '@nasnet/ui/patterns';"})]}),"\n",(0,t.jsxs)(n.p,{children:["Tracks page-scoped undo history (from ",(0,t.jsx)(n.code,{children:"@nasnet/state/stores"}),") to determine whether the user has unsaved changes. Blocks in-app navigation via TanStack Router and adds a ",(0,t.jsx)(n.code,{children:"beforeunload"})," handler to warn about browser-level navigation."]}),"\n",(0,t.jsx)(n.h3,{id:"signature-1",children:"Signature"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"function useUnsavedChanges(\n  options?: UseUnsavedChangesOptions\n): UseUnsavedChangesReturn\n"})}),"\n",(0,t.jsx)(n.h3,{id:"options",children:"Options"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"interface UseUnsavedChangesOptions {\n  isCritical?: boolean;                          // Shows warning-level dialog styling \u2014 default false\n  message?: string;                              // Custom dialog body text\n  onSave?: () => Promise<boolean> | boolean;     // Return false to keep dialog open on save failure\n  onDiscard?: () => void;\n  enabled?: boolean;                             // Toggle tracking \u2014 default true\n  filter?: (action: { scope: 'page' | 'global' }) => boolean;\n  // default: (action) => action.scope === 'page'\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"return-type-1",children:"Return type"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"interface UseUnsavedChangesReturn {\n  hasUnsavedChanges: boolean;\n  unsavedCount: number;\n  isDialogOpen: boolean;\n  openDialog(): void;\n  closeDialog(): void;\n  confirmSave(): Promise<void>;\n  confirmDiscard(): void;\n  markAsSaved(): void;\n  getBlockerProps(): { condition: boolean; onBlock: () => void };\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"getBlockerProps()"})," returns an object compatible with TanStack Router's ",(0,t.jsx)(n.code,{children:"useBlocker"})," hook. When ",(0,t.jsx)(n.code,{children:"condition"})," is ",(0,t.jsx)(n.code,{children:"true"}),", the router calls ",(0,t.jsx)(n.code,{children:"onBlock"}),", which opens the confirmation dialog."]}),"\n",(0,t.jsx)(n.h3,{id:"helper-function",children:"Helper function"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:'function getUnsavedChangesMessage(count: number, isCritical: boolean): string\n// "You have 3 unsaved changes. Are you sure you want to leave?"\n// "You have 1 critical unsaved change. These changes may affect system stability."\n'})}),"\n",(0,t.jsx)(n.h3,{id:"dialog-props",children:"Dialog props"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"interface UnsavedChangesDialogProps {\n  open: boolean;\n  count?: number;\n  isCritical?: boolean;\n  message?: string;\n  onCancel(): void;\n  onSave?(): void;\n  onDiscard(): void;\n  canSave?: boolean;\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"usage-with-react-hook-form",children:"Usage with React Hook Form"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-tsx",children:"import { useUnsavedChanges } from '@nasnet/ui/patterns';\nimport { useBlocker } from '@tanstack/react-router';\nimport { useForm } from 'react-hook-form';\n\nfunction FirewallRuleEditor() {\n  const form = useForm<RuleFormValues>();\n\n  const {\n    hasUnsavedChanges,\n    isDialogOpen,\n    closeDialog,\n    confirmSave,\n    confirmDiscard,\n    getBlockerProps,\n  } = useUnsavedChanges({\n    onSave: async () => {\n      const valid = await form.trigger();\n      if (!valid) return false; // keep dialog open\n      await form.handleSubmit(saveRule)();\n      return true;\n    },\n    onDiscard: () => form.reset(),\n  });\n\n  useBlocker(getBlockerProps());\n\n  return (\n    <>\n      <Form {...form}>\n        {/* form fields */}\n        {hasUnsavedChanges && (\n          <Badge variant=\"warning\">{unsavedCount} unsaved</Badge>\n        )}\n      </Form>\n\n      <UnsavedChangesDialog\n        open={isDialogOpen}\n        onCancel={closeDialog}\n        onSave={confirmSave}\n        onDiscard={confirmDiscard}\n      />\n    </>\n  );\n}\n"})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"focus-hooks",children:"Focus Hooks"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Source:"})," ",(0,t.jsx)(n.code,{children:"libs/ui/patterns/src/hooks/use-focus-restore.ts"}),"\n",(0,t.jsx)(n.strong,{children:"Import:"})," ",(0,t.jsx)(n.code,{children:"import { useFocusRestore, useFocusManagement } from '@nasnet/ui/patterns';"})]}),"\n",(0,t.jsx)(n.p,{children:"These hooks implement WCAG 2.4.3 (Focus Order) requirements. When a modal or dialog opens, focus should move inside it; when it closes, focus must return to the element that triggered it."}),"\n",(0,t.jsx)(n.h3,{id:"usefocusrestore",children:(0,t.jsx)(n.code,{children:"useFocusRestore"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"function useFocusRestore(options?: UseFocusRestoreOptions): UseFocusRestoreReturn\n"})}),"\n",(0,t.jsx)(n.p,{children:"Stores a reference to the currently focused DOM element and can restore focus to it later. Handles edge cases: element removed from DOM, element no longer focusable, optional fallback element."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"interface UseFocusRestoreOptions {\n  autoSave?: boolean;     // Save trigger on mount \u2014 default false\n  autoRestore?: boolean;  // Restore focus on unmount \u2014 default false\n  fallback?: React.RefObject<HTMLElement> | string;  // CSS selector or ref\n  restoreDelay?: number;  // ms delay before restoring (for close animations) \u2014 default 0\n}\n\ninterface UseFocusRestoreReturn {\n  saveTrigger(): void;\n  restoreFocus(): void;\n  hasSavedTrigger(): boolean;\n  clearTrigger(): void;\n}\n"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-tsx",children:'import { useFocusRestore } from \'@nasnet/ui/patterns\';\n\nfunction ConfirmDialog({ isOpen, onClose, children }) {\n  const { saveTrigger, restoreFocus } = useFocusRestore({\n    restoreDelay: 150, // wait for close animation\n  });\n\n  useEffect(() => {\n    if (isOpen) saveTrigger();\n  }, [isOpen, saveTrigger]);\n\n  const handleClose = () => {\n    onClose();\n    restoreFocus();\n  };\n\n  if (!isOpen) return null;\n\n  return (\n    <div role="dialog" aria-modal="true">\n      {children}\n      <Button onClick={handleClose}>Close</Button>\n    </div>\n  );\n}\n'})}),"\n",(0,t.jsx)(n.h3,{id:"usefocusmanagement",children:(0,t.jsx)(n.code,{children:"useFocusManagement"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"function useFocusManagement(options: UseFocusManagementOptions): UseFocusManagementReturn\n"})}),"\n",(0,t.jsx)(n.p,{children:"Higher-level hook that combines focus restoration, focus trapping (Tab cycling within the dialog), and Escape key handling into a single composable unit."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"interface UseFocusManagementOptions {\n  isOpen: boolean;\n  onClose?: () => void;\n  trapFocus?: boolean;       // default true \u2014 Tab key loops within dialog\n  closeOnEscape?: boolean;   // default true\n}\n\ninterface UseFocusManagementReturn {\n  dialogRef: React.RefObject<HTMLElement>;\n  onOpenChange(open: boolean): void;\n}\n"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-tsx",children:'import { useFocusManagement } from \'@nasnet/ui/patterns\';\n\nfunction AccessibleDialog({ isOpen, onClose, children }) {\n  const { dialogRef, onOpenChange } = useFocusManagement({\n    isOpen,\n    onClose,\n    trapFocus: true,\n    closeOnEscape: true,\n  });\n\n  if (!isOpen) return null;\n\n  return (\n    // Attach dialogRef to the container \u2014 focus trap and Escape handler are automatic\n    <div\n      ref={dialogRef as React.RefObject<HTMLDivElement>}\n      role="dialog"\n      aria-modal="true"\n    >\n      {children}\n      <Button onClick={() => onOpenChange(false)}>Close</Button>\n    </div>\n  );\n}\n'})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"primitive-hooks",children:"Primitive Hooks"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Source:"})," ",(0,t.jsx)(n.code,{children:"libs/ui/primitives/src/hooks/"}),"\n",(0,t.jsx)(n.strong,{children:"Import:"})," ",(0,t.jsx)(n.code,{children:"import { useReducedMotion, useMediaQuery } from '@nasnet/ui/primitives';"})]}),"\n",(0,t.jsxs)(n.p,{children:["These are low-level hooks with no business logic dependencies. Both are SSR-safe (return ",(0,t.jsx)(n.code,{children:"false"})," during server-side rendering to avoid hydration mismatches)."]}),"\n",(0,t.jsxs)(n.p,{children:["Note: ",(0,t.jsx)(n.code,{children:"@nasnet/ui/layouts"})," also exports ",(0,t.jsx)(n.code,{children:"useReducedMotion"})," from its responsive-shell module along with additional motion utilities (",(0,t.jsx)(n.code,{children:"useAnimationDuration"}),", ",(0,t.jsx)(n.code,{children:"useMotionConfig"}),", ",(0,t.jsx)(n.code,{children:"useMotionClasses"}),"). See the Motion Hooks section below and ",(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"tokens-and-animation.md"})})," for details."]}),"\n",(0,t.jsx)(n.h3,{id:"usereducedmotion",children:(0,t.jsx)(n.code,{children:"useReducedMotion"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"function useReducedMotion(): boolean\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Reads the ",(0,t.jsx)(n.code,{children:"(prefers-reduced-motion: reduce)"})," CSS media query. Returns ",(0,t.jsx)(n.code,{children:"true"})," when the user's OS or browser accessibility settings request reduced motion. Subscribes to changes so components respond dynamically if the preference changes while the app is running."]}),"\n",(0,t.jsxs)(n.p,{children:["Required for ",(0,t.jsx)(n.strong,{children:"WCAG 2.1 SC 2.3.3"})," compliance. Any animated component in NasNetConnect must use this hook to disable or minimise motion when the preference is set."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-tsx",children:"import { useReducedMotion } from '@nasnet/ui/primitives';\n\nfunction PulsingIndicator({ status }) {\n  const prefersReducedMotion = useReducedMotion();\n\n  return (\n    <span\n      className={cn(\n        'h-2 w-2 rounded-full',\n        status === 'online' ? 'bg-success' : 'bg-muted',\n        !prefersReducedMotion && status === 'online' && 'animate-pulse'\n      )}\n    />\n  );\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"usemediaquery",children:(0,t.jsx)(n.code,{children:"useMediaQuery"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"function useMediaQuery(query: string): boolean\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Returns ",(0,t.jsx)(n.code,{children:"true"})," when the given CSS media query matches the current environment. Subscribes to changes (e.g., screen rotation, browser resize) and updates the returned boolean reactively."]}),"\n",(0,t.jsxs)(n.p,{children:["Use this hook for one-off media queries. For platform detection, prefer ",(0,t.jsx)(n.code,{children:"usePlatform()"})," from ",(0,t.jsx)(n.code,{children:"@nasnet/ui/layouts"}),"."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-tsx",children:"import { useMediaQuery } from '@nasnet/ui/primitives';\n\nfunction PrintButton() {\n  // Show only in print-capable contexts\n  const canPrint = useMediaQuery('print');\n\n  // Dark mode awareness without the theme provider\n  const prefersDark = useMediaQuery('(prefers-color-scheme: dark)');\n\n  // Touch capability detection\n  const isTouch = useMediaQuery('(hover: none) and (pointer: coarse)');\n\n  return canPrint ? <Button>Print Report</Button> : null;\n}\n"})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"motion-hooks-from-layouts",children:"Motion Hooks (from layouts)"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Source:"})," ",(0,t.jsx)(n.code,{children:"libs/ui/layouts/src/responsive-shell/useReducedMotion.ts"}),"\n",(0,t.jsx)(n.strong,{children:"Import:"})," ",(0,t.jsx)(n.code,{children:"import { useReducedMotion, useAnimationDuration, useMotionConfig, useMotionClasses } from '@nasnet/ui/layouts';"})]}),"\n",(0,t.jsxs)(n.p,{children:["These extend the primitive ",(0,t.jsx)(n.code,{children:"useReducedMotion"})," with utilities tailored to the NasNetConnect design token animation durations. See ",(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"tokens-and-animation.md"})})," for the full motion system reference."]}),"\n",(0,t.jsx)(n.h3,{id:"useanimationduration",children:(0,t.jsx)(n.code,{children:"useAnimationDuration"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"function useAnimationDuration(normalDuration: number, reducedDuration?: number): number\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Returns ",(0,t.jsx)(n.code,{children:"reducedDuration"})," (default ",(0,t.jsx)(n.code,{children:"0"}),") when the user prefers reduced motion, otherwise returns ",(0,t.jsx)(n.code,{children:"normalDuration"}),". Accepts milliseconds."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-tsx",children:"import { useAnimationDuration, ANIMATION_DURATIONS } from '@nasnet/ui/layouts';\n\nfunction CollapsiblePanel({ isOpen, children }) {\n  const duration = useAnimationDuration(ANIMATION_DURATIONS.SIDEBAR); // 200 ms or 0\n\n  return (\n    <div style={{ transitionDuration: `${duration}ms` }} className=\"transition-all overflow-hidden\">\n      {isOpen && children}\n    </div>\n  );\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"usemotionconfig",children:(0,t.jsx)(n.code,{children:"useMotionConfig"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"function useMotionConfig(durationMs?: number): {\n  shouldAnimate: boolean;\n  transition: { duration: number } | { duration: number; ease: string };\n  duration: number;\n  durationSeconds: number;\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Returns a Framer Motion-compatible transition object. When reduced motion is active, ",(0,t.jsx)(n.code,{children:"duration"})," and ",(0,t.jsx)(n.code,{children:"durationSeconds"})," are ",(0,t.jsx)(n.code,{children:"0"})," and ",(0,t.jsx)(n.code,{children:"shouldAnimate"})," is ",(0,t.jsx)(n.code,{children:"false"}),"."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-tsx",children:"import { motion } from 'framer-motion';\nimport { useMotionConfig, ANIMATION_DURATIONS } from '@nasnet/ui/layouts';\n\nfunction AnimatedSidebar({ isCollapsed }) {\n  const { transition, shouldAnimate } = useMotionConfig(ANIMATION_DURATIONS.SIDEBAR);\n\n  return (\n    <motion.div\n      initial={shouldAnimate ? { width: 256 } : false}\n      animate={{ width: isCollapsed ? 64 : 256 }}\n      transition={transition}\n    >\n      Sidebar content\n    </motion.div>\n  );\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"usemotionclasses",children:(0,t.jsx)(n.code,{children:"useMotionClasses"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"function useMotionClasses(): {\n  transitionClass: 'transition-all' | 'transition-none';\n  durationClass: 'duration-200' | 'duration-0';\n  motionClass: string;\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:"Returns Tailwind CSS class strings safe to use on any animated element."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-tsx",children:"import { useMotionClasses } from '@nasnet/ui/layouts';\nimport { cn } from '@nasnet/ui/utils';\n\nfunction FadePanel({ visible, children }) {\n  const { motionClass } = useMotionClasses();\n\n  return (\n    <div className={cn(motionClass, 'opacity-0', visible && 'opacity-100')}>\n      {children}\n    </div>\n  );\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsxs)(n.strong,{children:[(0,t.jsx)(n.code,{children:"ANIMATION_DURATIONS"})," constant:"]})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"const ANIMATION_DURATIONS = {\n  SIDEBAR:  200, // sidebar collapse/expand\n  LAYOUT:   150, // layout/platform transitions\n  DRAWER:   200, // mobile drawer, modal, sheet open/close\n  QUICK:    100, // hover states, micro-interactions\n  DEFAULT:  200, // standard transitions and fades\n  SLOW:     300, // deliberate transitions with visual emphasis\n} as const;\n"})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"hook-composition-patterns",children:"Hook Composition Patterns"}),"\n",(0,t.jsx)(n.h3,{id:"live-search-with-debounced-filter",children:"Live search with debounced filter"}),"\n",(0,t.jsxs)(n.p,{children:["Combining ",(0,t.jsx)(n.code,{children:"useMemoizedFilterSort"})," and ",(0,t.jsx)(n.code,{children:"useDebouncedCallback"})," gives a responsive search box that does not re-filter on every keystroke."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-tsx",children:"import {\n  useMemoizedFilterSort,\n  useDebouncedCallback,\n} from '@nasnet/ui/patterns';\n\nfunction FilterableServiceList({ services }: { services: Service[] }) {\n  const [query, setQuery] = useState('');\n  const [debouncedQuery, setDebouncedQuery] = useState('');\n\n  // Debounce the query that drives the filter\n  const updateDebounced = useDebouncedCallback(setDebouncedQuery, 250);\n\n  const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {\n    setQuery(e.target.value);        // Update input immediately\n    updateDebounced(e.target.value); // Trigger filter after 250 ms quiet period\n  };\n\n  const displayed = useMemoizedFilterSort(\n    services,\n    debouncedQuery\n      ? (s) => s.name.toLowerCase().includes(debouncedQuery.toLowerCase())\n      : null,\n    (a, b) => a.name.localeCompare(b.name),\n    [debouncedQuery] // recompute only when debounced query changes\n  );\n\n  return (\n    <>\n      <input value={query} onChange={handleChange} placeholder=\"Filter services\" />\n      <ServiceTable rows={displayed} />\n    </>\n  );\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"stable-table-action-handler",children:"Stable table action handler"}),"\n",(0,t.jsxs)(n.p,{children:["Stable callbacks prevent ",(0,t.jsx)(n.code,{children:"React.memo"})," tables from re-rendering when a parent re-renders due to unrelated state."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-tsx",children:"import {\n  useStableCallback,\n  useBulkCopy,\n  useToast,\n} from '@nasnet/ui/patterns';\n\nfunction RouterTable({ routers }: { routers: Router[] }) {\n  const { success, error } = useToast();\n  const { copyItems, format, setFormat } = useBulkCopy();\n  const [selectedIds, setSelectedIds] = useState<string[]>([]);\n\n  // Stable \u2014 identity never changes, so MemoizedTable never re-renders for this prop alone\n  const handleRowSelect = useStableCallback((id: string, checked: boolean) => {\n    setSelectedIds((prev) =>\n      checked ? [...prev, id] : prev.filter((x) => x !== id)\n    );\n  });\n\n  const selectedRouters = useMemoizedFilter(\n    routers,\n    (r) => selectedIds.includes(r.id),\n    [selectedIds]\n  );\n\n  const handleCopy = async () => {\n    const ok = await copyItems(selectedRouters, ['name', 'address', 'status']);\n    if (ok) success(`Copied ${selectedRouters.length} routers`);\n    else error('Copy failed');\n  };\n\n  return (\n    <>\n      <MemoizedTable routers={routers} onSelect={handleRowSelect} />\n      <Button onClick={handleCopy} disabled={selectedIds.length === 0}>\n        Export Selected\n      </Button>\n    </>\n  );\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"modal-with-full-accessibility",children:"Modal with full accessibility"}),"\n",(0,t.jsxs)(n.p,{children:["Combining ",(0,t.jsx)(n.code,{children:"useFocusManagement"}),", ",(0,t.jsx)(n.code,{children:"useToast"}),", and ",(0,t.jsx)(n.code,{children:"useUnsavedChanges"})," for a fully accessible configuration modal."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-tsx",children:"import {\n  useFocusManagement,\n  useToast,\n  useUnsavedChanges,\n} from '@nasnet/ui/patterns';\n\nfunction ConfigModal({ isOpen, onClose }) {\n  const { success, error } = useToast();\n\n  const {\n    hasUnsavedChanges,\n    isDialogOpen: isUnsavedDialogOpen,\n    confirmSave,\n    confirmDiscard,\n    closeDialog: closeUnsavedDialog,\n  } = useUnsavedChanges({\n    onSave: async () => {\n      try { await saveConfig(); return true; }\n      catch { error('Save failed'); return false; }\n    },\n    onDiscard: resetConfig,\n  });\n\n  // Attempt to close \u2014 prompt if dirty\n  const handleClose = () => {\n    if (hasUnsavedChanges) {\n      // useUnsavedChanges blocker handles the prompt\n    } else {\n      onClose();\n    }\n  };\n\n  const { dialogRef, onOpenChange } = useFocusManagement({\n    isOpen,\n    onClose: handleClose,\n    trapFocus: true,\n    closeOnEscape: true,\n  });\n\n  if (!isOpen) return null;\n\n  return (\n    <div ref={dialogRef as React.RefObject<HTMLDivElement>} role=\"dialog\" aria-modal=\"true\">\n      {/* config form */}\n      <UnsavedChangesDialog\n        open={isUnsavedDialogOpen}\n        onCancel={closeUnsavedDialog}\n        onSave={confirmSave}\n        onDiscard={confirmDiscard}\n      />\n    </div>\n  );\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"best-practices-for-hook-dependencies",children:"Best practices for hook dependencies"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Pass stable functions to memoization hooks."})," Wrap inline predicate or sort functions in ",(0,t.jsx)(n.code,{children:"useStableCallback"})," so they do not become unintentional dependencies:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-tsx",children:"const isOnline = useStableCallback((r: Router) => r.status === 'online');\nconst online = useMemoizedFilter(routers, isOnline, []);\n// deps array stays empty \u2014 no risk of accidental re-filter\n"})}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsxs)(n.strong,{children:["Keep ",(0,t.jsx)(n.code,{children:"deps"})," minimal and explicit."]})," Only include values that actually change the output of the filter/sort/map function. Avoid spreading entire objects; destructure only the properties you compare."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Co-locate debounce with the state it updates."})," Place ",(0,t.jsx)(n.code,{children:"useDebouncedCallback"})," in the same component that owns the state being debounced. Do not pass a debounced callback down through multiple component layers \u2014 the delay accumulates unpredictably."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsxs)(n.strong,{children:["Use ",(0,t.jsx)(n.code,{children:"useThrottledCallback"})," for continuous events."]})," Scroll, resize, and pointer-move handlers benefit from throttle (leading execution + trailing call). Debounce is better suited for input fields where you want to wait for a pause."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsxs)(n.strong,{children:["Never pass a debounced or throttled callback into a memoization hook's ",(0,t.jsx)(n.code,{children:"deps"})," array."]})," Both ",(0,t.jsx)(n.code,{children:"useDebouncedCallback"})," and ",(0,t.jsx)(n.code,{children:"useThrottledCallback"})," change identity when ",(0,t.jsx)(n.code,{children:"delay"})," changes, which would invalidate the memoized result unexpectedly."]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"cross-references",children:"Cross-References"}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Topic"}),(0,t.jsx)(n.th,{children:"Document"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Platform hooks full guide"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"layouts-and-platform.md"})})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Animation tokens and motion system"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"tokens-and-animation.md"})})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Domain-specific hooks (useResourceCard, etc.)"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"patterns-domain-components.md"})})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Three-layer component architecture"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"Docs/architecture/adrs/017-three-layer-component-architecture.md"})})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Headless + Platform Presenters ADR"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"Docs/architecture/adrs/018-headless-platform-presenters.md"})})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"WCAG AAA accessibility requirements"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"Docs/design/ux-design/8-responsive-design-accessibility.md"})})]})]})]})]})}function u(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}}}]);