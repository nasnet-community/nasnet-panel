"use strict";(globalThis.webpackChunk_nas_net_docs=globalThis.webpackChunk_nas_net_docs||[]).push([[66702],{31712:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>i,default:()=>u,frontMatter:()=>c,metadata:()=>r,toc:()=>a});const r=JSON.parse('{"id":"stores/router","title":"Router Store (useRouterStore)","description":"Deep-dive into router discovery, management, and selection state.","source":"@site/../../libs/state/docs/stores/router.md","sourceDirName":"stores","slug":"/stores/router","permalink":"/docs/state/stores/router","draft":false,"unlisted":false,"editUrl":"https://github.com/nasnet-community/nasnet-panel/tree/main/../../libs/state/docs/stores/router.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"sidebar_position":2,"title":"Router Store (useRouterStore)"},"sidebar":"sidebar","previous":{"title":"Wizard Machine (Multi-Step Flows)","permalink":"/docs/state/machines/wizard"},"next":{"title":"Hooks & Utility Functions","permalink":"/docs/state/stores/hooks-utilities"}}');var s=t(31085),o=t(71184);const c={sidebar_position:2,title:"Router Store (useRouterStore)"},i="Router Store",d={},a=[{value:"State Shape",id:"state-shape",level:2},{value:"Router Interface",id:"router-interface",level:3},{value:"Scan Progress Interface",id:"scan-progress-interface",level:3},{value:"Actions API",id:"actions-api",level:2},{value:"Router CRUD Operations",id:"router-crud-operations",level:3},{value:"Selection Management",id:"selection-management",level:3},{value:"Scan Progress Tracking",id:"scan-progress-tracking",level:3},{value:"Connection Tracking",id:"connection-tracking",level:3},{value:"Configuration Tracking",id:"configuration-tracking",level:3},{value:"Utility",id:"utility",level:3},{value:"Persistence",id:"persistence",level:2},{value:"Common Usage Patterns",id:"common-usage-patterns",level:2},{value:"Router Discovery Flow",id:"router-discovery-flow",level:3},{value:"Router Selection &amp; Connection",id:"router-selection--connection",level:3},{value:"Auto-Reconnect on App Start",id:"auto-reconnect-on-app-start",level:3},{value:"Configuration Import Flow",id:"configuration-import-flow",level:3},{value:"Selectors",id:"selectors",level:2},{value:"Out-of-React Access",id:"out-of-react-access",level:2},{value:"Integration with Connection Store",id:"integration-with-connection-store",level:2},{value:"DevTools Integration",id:"devtools-integration",level:2},{value:"Performance Tips",id:"performance-tips",level:2},{value:"Configuration Check Constants",id:"configuration-check-constants",level:2},{value:"See Also",id:"see-also",level:2}];function l(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,o.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"router-store",children:"Router Store"})}),"\n",(0,s.jsx)(n.p,{children:"Deep-dive into router discovery, management, and selection state."}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Source:"})," ",(0,s.jsx)(n.code,{children:"libs/state/stores/src/router/router.store.ts"})]}),"\n",(0,s.jsx)(n.h2,{id:"state-shape",children:"State Shape"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"interface RouterStore {\n  // Router inventory\n  routers: Record<string, Router>; // All routers indexed by ID\n  selectedRouterId: string | null; // Currently selected router\n  lastConnectedRouterId: string | null; // Last successful connection\n\n  // Discovery progress\n  scanProgress: ScanProgress | null; // Current scan progress (null if not scanning)\n\n  // Configuration tracking\n  configurationCheckedRouters: string[]; // Routers checked for config import\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"router-interface",children:"Router Interface"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"interface Router {\n  id: string; // Unique identifier (UUID)\n  ipAddress: string; // IP address or hostname\n  name: string; // Display name\n  connectionStatus: 'unknown' | 'online' | 'offline' | 'unreachable';\n  discoveryMethod: 'manual' | 'broadcast'; // How router was discovered\n  createdAt: Date; // When router was added\n  lastConnected?: Date; // Last successful connection time\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"scan-progress-interface",children:"Scan Progress Interface"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"interface ScanProgress {\n  totalAddresses: number; // Total addresses being scanned\n  scannedAddresses: number; // Addresses scanned so far\n  discoveredRouters: Router[]; // Routers found during scan\n  isScanning: boolean; // Scan in progress flag\n  error?: string; // Error message (if scan failed)\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"actions-api",children:"Actions API"}),"\n",(0,s.jsx)(n.h3,{id:"router-crud-operations",children:"Router CRUD Operations"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"addRouter(router: Router)"})})," - Add a new router"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"const { addRouter } = useRouterStore();\n\naddRouter({\n  id: crypto.randomUUID(),\n  ipAddress: '192.168.88.1',\n  name: 'Main Router',\n  connectionStatus: 'unknown',\n  discoveryMethod: 'manual',\n  createdAt: new Date(),\n});\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"updateRouter(id: string, updates: Partial<Router>)"})})," - Update router fields"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"const { updateRouter } = useRouterStore();\n\n// Update status after connection attempt\nupdateRouter(routerId, {\n  connectionStatus: 'online',\n  lastConnected: new Date(),\n});\n\n// Update name\nupdateRouter(routerId, { name: 'Backup Router' });\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"removeRouter(id: string)"})})," - Remove router from store"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"const { removeRouter } = useRouterStore();\n\nremoveRouter(routerId);\n// Automatically clears selection if this was the selected router\n// Automatically clears lastConnectedRouterId if this was that router\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"getRouter(id: string): Router | undefined"})})," - Get specific router"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"const { getRouter } = useRouterStore();\n\nconst router = getRouter(routerId);\nif (router) {\n  console.log(`Router ${router.name} is ${router.connectionStatus}`);\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"getAllRouters(): Router[]"})})," - Get all routers as array"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"const { getAllRouters } = useRouterStore();\n\nconst routers = getAllRouters();\nconsole.log(`Found ${routers.length} routers`);\n\n// Sort by name\nconst sorted = routers.sort((a, b) => a.name.localeCompare(b.name));\n"})}),"\n",(0,s.jsx)(n.h3,{id:"selection-management",children:"Selection Management"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"selectRouter(id: string)"})})," - Select router for connection attempt"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"const { selectRouter } = useRouterStore();\n\n// User clicks router in list\nselectRouter(routerId);\n// Now attempting to connect to this router\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"clearSelection()"})})," - Clear current selection"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"const { clearSelection } = useRouterStore();\n\n// After successful connection or when user cancels\nclearSelection();\n"})}),"\n",(0,s.jsx)(n.h3,{id:"scan-progress-tracking",children:"Scan Progress Tracking"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"setScanProgress(progress: ScanProgress | null)"})})," - Update scan progress"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"const { setScanProgress } = useRouterStore();\n\n// Start scan\nsetScanProgress({\n  totalAddresses: 256,\n  scannedAddresses: 0,\n  discoveredRouters: [],\n  isScanning: true,\n});\n\n// Update during scan\nsetScanProgress((prev) => ({\n  ...prev,\n  scannedAddresses: prev.scannedAddresses + 1,\n  discoveredRouters: [...prev.discoveredRouters, newRouter],\n}));\n\n// Complete scan\nsetScanProgress(null);\n"})}),"\n",(0,s.jsx)(n.h3,{id:"connection-tracking",children:"Connection Tracking"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"setLastConnected(id: string)"})})," - Mark router as last successfully connected"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"const { setLastConnected } = useRouterStore();\n\n// After successful authentication\nsetLastConnected(routerId);\n// Automatically updates:\n// - lastConnectedRouterId\n// - router.connectionStatus to 'online'\n// - router.lastConnected to now\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"getLastConnectedRouter(): Router | undefined"})})," - Get the last connected router"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"const { getLastConnectedRouter } = useRouterStore();\n\nconst lastRouter = getLastConnectedRouter();\nif (lastRouter) {\n  console.log(`Last connected to ${lastRouter.name}`);\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"configuration-tracking",children:"Configuration Tracking"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"isConfigurationChecked(routerId: string): boolean"})})," - Check if router has been checked for\nconfig import"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"const { isConfigurationChecked } = useRouterStore();\n\nif (!isConfigurationChecked(routerId)) {\n  // Show configuration import wizard\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"markConfigurationChecked(routerId: string)"})})," - Mark router as checked for configuration"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"const { markConfigurationChecked } = useRouterStore();\n\n// After showing wizard (or user skips)\nmarkConfigurationChecked(routerId);\n// Prevents showing wizard again\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"clearConfigurationChecked(routerId: string)"})})," - Clear configuration check status"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"const { clearConfigurationChecked } = useRouterStore();\n\n// User wants to re-import configuration\nclearConfigurationChecked(routerId);\n"})}),"\n",(0,s.jsx)(n.h3,{id:"utility",children:"Utility"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"clearAll()"})})," - Clear entire store (testing/reset)"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"const { clearAll } = useRouterStore();\n\n// Testing only - resets all state\nclearAll();\n"})}),"\n",(0,s.jsx)(n.h2,{id:"persistence",children:"Persistence"}),"\n",(0,s.jsxs)(n.p,{children:["The router store automatically persists to localStorage under key ",(0,s.jsx)(n.code,{children:"'nasnet-router-store'"}),"."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Persisted fields:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"routers"})," - All discovered/added routers"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"lastConnectedRouterId"})," - For auto-reconnect"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"configurationCheckedRouters"})," - To avoid repeated wizard"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"NOT persisted (session-only):"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"selectedRouterId"})," - Clears on page reload"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"scanProgress"})," - Clears on page reload"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"This ensures routers are remembered across sessions, but transient UI state resets."}),"\n",(0,s.jsx)(n.h2,{id:"common-usage-patterns",children:"Common Usage Patterns"}),"\n",(0,s.jsx)(n.h3,{id:"router-discovery-flow",children:"Router Discovery Flow"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"function DiscoveryComponent() {\n  const { scanProgress, setScanProgress, addRouter } = useRouterStore();\n\n  const startScan = async () => {\n    setScanProgress({\n      totalAddresses: 256,\n      scannedAddresses: 0,\n      discoveredRouters: [],\n      isScanning: true,\n    });\n\n    try {\n      // Scan network\n      for (let i = 1; i <= 256; i++) {\n        const ip = `192.168.1.${i}`;\n\n        // Try to reach router\n        const isRouter = await checkIfRouter(ip);\n\n        setScanProgress((prev) => ({\n          ...prev,\n          scannedAddresses: i,\n          discoveredRouters:\n            isRouter ?\n              [\n                ...prev.discoveredRouters,\n                {\n                  id: crypto.randomUUID(),\n                  ipAddress: ip,\n                  name: `Router ${i}`,\n                  connectionStatus: 'unknown',\n                  discoveryMethod: 'broadcast',\n                  createdAt: new Date(),\n                },\n              ]\n            : prev.discoveredRouters,\n        }));\n      }\n\n      // Add discovered routers to store\n      scanProgress?.discoveredRouters.forEach(addRouter);\n    } finally {\n      setScanProgress(null);\n    }\n  };\n\n  return (\n    <div>\n      {scanProgress && (\n        <ProgressBar\n          current={scanProgress.scannedAddresses}\n          total={scanProgress.totalAddresses}\n          discovered={scanProgress.discoveredRouters.length}\n        />\n      )}\n      <Button\n        onClick={startScan}\n        disabled={scanProgress?.isScanning}\n      >\n        Scan Network\n      </Button>\n    </div>\n  );\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"router-selection--connection",children:"Router Selection & Connection"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"function RouterSelectionPanel() {\n  const routers = useRouterStore((state) => state.getAllRouters());\n  const selectedRouterId = useRouterStore((state) => state.selectedRouterId);\n  const selectRouter = useRouterStore((state) => state.selectRouter);\n  const setLastConnected = useRouterStore((state) => state.setLastConnected);\n\n  const handleConnect = async (routerId: string) => {\n    selectRouter(routerId);\n\n    try {\n      // Attempt connection\n      const result = await connectToRouter(routerId);\n\n      // Mark as connected\n      setLastConnected(routerId);\n\n      // Proceed to dashboard\n      navigate('/dashboard');\n    } catch (error) {\n      console.error('Connection failed:', error);\n      // Show error message\n    }\n  };\n\n  return (\n    <div>\n      {routers.map((router) => (\n        <RouterCard\n          key={router.id}\n          router={router}\n          isSelected={selectedRouterId === router.id}\n          onConnect={() => handleConnect(router.id)}\n        />\n      ))}\n    </div>\n  );\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"auto-reconnect-on-app-start",children:"Auto-Reconnect on App Start"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"function AppInitializer() {\n  const getLastConnectedRouter = useRouterStore((state) => state.getLastConnectedRouter);\n\n  useEffect(() => {\n    const lastRouter = getLastConnectedRouter();\n\n    if (lastRouter) {\n      // Auto-reconnect to last used router\n      reconnectToRouter(lastRouter.id);\n    }\n  }, []);\n\n  return null;\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"configuration-import-flow",children:"Configuration Import Flow"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"function ConfigurationCheck() {\n  const selectedRouterId = useRouterStore((state) => state.selectedRouterId);\n  const isConfigurationChecked = useRouterStore((state) => state.isConfigurationChecked);\n  const markConfigurationChecked = useRouterStore((state) => state.markConfigurationChecked);\n\n  useEffect(() => {\n    if (!selectedRouterId) return;\n\n    // Check if we need to show config wizard\n    if (!isConfigurationChecked(selectedRouterId)) {\n      // Show wizard\n      showConfigWizard(selectedRouterId);\n\n      // Mark as checked\n      markConfigurationChecked(selectedRouterId);\n    }\n  }, [selectedRouterId]);\n\n  return null;\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"selectors",children:"Selectors"}),"\n",(0,s.jsx)(n.p,{children:"Optimized selectors for minimal re-renders:"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Selector"}),(0,s.jsx)(n.th,{children:"Returns"}),(0,s.jsx)(n.th,{children:"Usage"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"selectAllRouters()"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"Router[]"})}),(0,s.jsx)(n.td,{children:"Get all routers"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"selectSelectedRouter()"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"Router | undefined"})}),(0,s.jsx)(n.td,{children:"Get currently selected router"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"selectLastConnectedRouter()"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"Router | undefined"})}),(0,s.jsx)(n.td,{children:"Get last successfully connected router"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"selectRouterCount()"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"number"})}),(0,s.jsx)(n.td,{children:"Get total router count"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"selectScanProgress()"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"ScanProgress | null"})}),(0,s.jsx)(n.td,{children:"Get current scan progress"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"selectIsScanning()"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"boolean"})}),(0,s.jsx)(n.td,{children:"Check if scan in progress"})]})]})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Example:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// \u2705 Good: Only re-renders when routers change\nconst routers = useRouterStore((state) => state.getAllRouters());\n\n// \u2705 Good: Only re-renders when selection changes\nconst selectedRouter = useRouterStore((state) => state.routers[state.selectedRouterId ?? '']);\n\n// \u274c Bad: Re-renders on ANY store change\nconst { routers, selectedRouterId, scanProgress } = useRouterStore();\n"})}),"\n",(0,s.jsx)(n.h2,{id:"out-of-react-access",children:"Out-of-React Access"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// Get current routers without hook\nconst { routers } = useRouterStore.getState();\n\n// Subscribe outside React\nconst unsubscribe = useRouterStore.subscribe(\n  (state) => state.lastConnectedRouterId,\n  (routerId) => {\n    console.log('Last connected router changed:', routerId);\n  }\n);\n\n// Later\nunsubscribe();\n"})}),"\n",(0,s.jsx)(n.h2,{id:"integration-with-connection-store",children:"Integration with Connection Store"}),"\n",(0,s.jsxs)(n.p,{children:["The router store works in conjunction with ",(0,s.jsx)(n.code,{children:"useConnectionStore"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Router Store"}),": Manages router inventory, discovery, selection"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Connection Store"}),": Manages WebSocket connection state, status, latency"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Typical flow:"})}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["User selects router \u2192 ",(0,s.jsx)(n.code,{children:"useRouterStore.selectRouter()"})]}),"\n",(0,s.jsxs)(n.li,{children:["App attempts connection \u2192 ",(0,s.jsx)(n.code,{children:"useConnectionStore.connect()"})]}),"\n",(0,s.jsxs)(n.li,{children:["Connection succeeds \u2192 ",(0,s.jsx)(n.code,{children:"useRouterStore.setLastConnected()"})]}),"\n",(0,s.jsxs)(n.li,{children:["WebSocket status updates \u2192 ",(0,s.jsx)(n.code,{children:"useConnectionStore.setWsStatus()"})]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"devtools-integration",children:"DevTools Integration"}),"\n",(0,s.jsx)(n.p,{children:"In development mode, Redux DevTools shows all router actions:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"Actions:\n- addRouter\n- updateRouter\n- removeRouter\n- selectRouter\n- clearSelection\n- setScanProgress\n- setLastConnected\n- markConfigurationChecked\n- clearConfigurationChecked\n- clearAll\n\nTime-travel debugging: Step through router state changes\n"})}),"\n",(0,s.jsx)(n.h2,{id:"performance-tips",children:"Performance Tips"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Use selectors for specific fields:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// \u2705 Good\nconst routers = useRouterStore((s) => s.getAllRouters());\n\n// \u274c Bad\nconst { routers, selectedRouterId, scanProgress } = useRouterStore();\n"})}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Use out-of-React access for utilities:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// In utility functions\nconst routers = useRouterStore.getState().getAllRouters();\n"})}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Batch related updates:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// \u2705 Good: Single store update\nupdateRouter(id, { connectionStatus: 'online', lastConnected: now });\n\n// \u274c Bad: Multiple separate updates\nupdateRouter(id, { connectionStatus: 'online' });\nupdateRouter(id, { lastConnected: now });\n"})}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"configuration-check-constants",children:"Configuration Check Constants"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// No re-display threshold\nconst CONFIG_CHECK_EXPIRY_MS = 30 * 24 * 60 * 60 * 1000; // 30 days\n"})}),"\n",(0,s.jsx)(n.h2,{id:"see-also",children:"See Also"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"/docs/state/stores/auth",children:"Connection Store"})})," - WebSocket connection state"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"/docs/state/stores/auth",children:"Auth Store"})})," - User authentication and tokens"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"/docs/state/stores/hooks-utilities",children:"Hooks & Utilities"})})," - Auto-reconnect and recovery"]}),"\n"]})]})}function u(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(l,{...e})}):l(e)}},71184:(e,n,t)=>{t.d(n,{R:()=>c,x:()=>i});var r=t(14041);const s={},o=r.createContext(s);function c(e){const n=r.useContext(o);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:c(e.components),r.createElement(o.Provider,{value:n},e.children)}}}]);