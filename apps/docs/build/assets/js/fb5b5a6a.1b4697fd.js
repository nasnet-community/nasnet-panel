"use strict";(globalThis.webpackChunk_nas_net_docs=globalThis.webpackChunk_nas_net_docs||[]).push([[81487],{71184:(e,n,r)=>{r.d(n,{R:()=>s,x:()=>d});var t=r(14041);const a={},i=t.createContext(a);function s(e){const n=t.useContext(i);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:s(e.components),t.createElement(i.Provider,{value:n},e.children)}},84287:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>o,contentTitle:()=>d,default:()=>p,frontMatter:()=>s,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"machines/wizard","title":"Wizard Machine (Multi-Step Flows)","description":"The Wizard Machine provides a reusable pattern for multi-step form wizards with per-step validation, session persistence, and recovery. It\'s ideal for complex setup flows like VPN configuration, device pairing, or service installation.","source":"@site/../../libs/state/docs/machines/wizard.md","sourceDirName":"machines","slug":"/machines/wizard","permalink":"/docs/state/machines/wizard","draft":false,"unlisted":false,"editUrl":"https://github.com/nasnet-community/nasnet-panel/tree/main/../../libs/state/docs/machines/wizard.md","tags":[],"version":"current","frontMatter":{},"sidebar":"sidebar","previous":{"title":"VPN Connection Machine (Feature Example)","permalink":"/docs/state/machines/vpn-connection"},"next":{"title":"Router Store (useRouterStore)","permalink":"/docs/state/stores/router"}}');var a=r(31085),i=r(71184);const s={},d="Wizard Machine (Multi-Step Flows)",o={},l=[{value:"Complete State Chart",id:"complete-state-chart",level:2},{value:"States Reference",id:"states-reference",level:2},{value:"Context",id:"context",level:2},{value:"Events",id:"events",level:2},{value:"Guards",id:"guards",level:2},{value:"Actions",id:"actions",level:2},{value:"Configuration",id:"configuration",level:2},{value:"Usage with <code>useWizard</code> Hook",id:"usage-with-usewizard-hook",level:2},{value:"Hook Return Type",id:"hook-return-type",level:2},{value:"Code Examples",id:"code-examples",level:2},{value:"Multi-step Device Pairing",id:"multi-step-device-pairing",level:3},{value:"Validate Entire Form",id:"validate-entire-form",level:3},{value:"Step-to-Step with Custom Logic",id:"step-to-step-with-custom-logic",level:3},{value:"Session Persistence",id:"session-persistence",level:2},{value:"Auto-Skip on Validation",id:"auto-skip-on-validation",level:2},{value:"Comparing Wizard Versions",id:"comparing-wizard-versions",level:2},{value:"Related Documentation",id:"related-documentation",level:2}];function c(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",mermaid:"mermaid",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,i.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"wizard-machine-multi-step-flows",children:"Wizard Machine (Multi-Step Flows)"})}),"\n",(0,a.jsxs)(n.p,{children:["The ",(0,a.jsx)(n.strong,{children:"Wizard Machine"})," provides a reusable pattern for multi-step form wizards with per-step validation, session persistence, and recovery. It's ideal for complex setup flows like VPN configuration, device pairing, or service installation."]}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Source:"})," ",(0,a.jsx)(n.code,{children:"libs/state/machines/src/wizardMachine.ts"}),"\n",(0,a.jsx)(n.strong,{children:"Hook:"})," ",(0,a.jsx)(n.code,{children:"libs/state/machines/src/hooks/useWizard.ts"})]}),"\n",(0,a.jsx)(n.h2,{id:"complete-state-chart",children:"Complete State Chart"}),"\n",(0,a.jsx)(n.mermaid,{value:"stateDiagram-v2\n    [*] --\x3e STEP\n\n    STEP --\x3e VALIDATING: NEXT\\n(with data)\n    STEP --\x3e STEP: BACK\\nGOTO\\nSET_DATA\n\n    VALIDATING --\x3e STEP: invalid\\n(show errors)\n    VALIDATING --\x3e STEP: valid & not last\\n(increment step)\n    VALIDATING --\x3e SUBMITTING: valid & is last\n\n    SUBMITTING --\x3e COMPLETED: onDone\n    SUBMITTING --\x3e STEP: onError\\n(show form error)\n\n    STEP --\x3e CANCELLED: CANCEL\n\n    COMPLETED --\x3e [*]\n    CANCELLED --\x3e [*]"}),"\n",(0,a.jsx)(n.h2,{id:"states-reference",children:"States Reference"}),"\n",(0,a.jsxs)(n.table,{children:[(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{children:"State"}),(0,a.jsx)(n.th,{children:"Purpose"}),(0,a.jsx)(n.th,{children:"Transitions"})]})}),(0,a.jsxs)(n.tbody,{children:[(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:(0,a.jsx)(n.strong,{children:"step"})}),(0,a.jsx)(n.td,{children:"Active wizard step"}),(0,a.jsx)(n.td,{children:"NEXT \u2192 validating (with step data), BACK \u2192 decrementStep, GOTO \u2192 goToStep (if allowed), SET_DATA (stay), CANCEL \u2192 cancelled, RESTORE"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:(0,a.jsx)(n.strong,{children:"validating"})}),(0,a.jsx)(n.td,{children:"Running step validation"}),(0,a.jsx)(n.td,{children:"onDone (valid & last) \u2192 submitting, onDone (valid & not last) \u2192 step (incrementStep), onDone (invalid) \u2192 step (show errors), onError \u2192 step"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:(0,a.jsx)(n.strong,{children:"submitting"})}),(0,a.jsx)(n.td,{children:"Executing wizard onSubmit"}),(0,a.jsx)(n.td,{children:"onDone \u2192 completed, onError \u2192 step (show form error)"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:(0,a.jsx)(n.strong,{children:"completed"})}),(0,a.jsx)(n.td,{children:"Wizard finished successfully"}),(0,a.jsx)(n.td,{children:"(Terminal - no transitions)"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:(0,a.jsx)(n.strong,{children:"cancelled"})}),(0,a.jsx)(n.td,{children:"Wizard cancelled by user"}),(0,a.jsx)(n.td,{children:"(Terminal - no transitions)"})]})]})]}),"\n",(0,a.jsx)(n.h2,{id:"context",children:"Context"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"interface WizardContext<TData = Record<string, unknown>> {\n  /** Current step number (1-indexed) */\n  currentStep: number;\n\n  /** Total number of steps in the wizard */\n  totalSteps: number;\n\n  /** Collected wizard data (partial until completion) */\n  data: Partial<TData>;\n\n  /** Validation errors by field name */\n  errors: Record<string, string>;\n\n  /** Unique session ID for persistence */\n  sessionId: string;\n\n  /** Whether the wizard can skip to arbitrary steps */\n  canSkip?: boolean;\n}\n"})}),"\n",(0,a.jsx)(n.h2,{id:"events",children:"Events"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"type WizardEvent<TData = Record<string, unknown>> =\n  | { type: 'NEXT'; data?: Partial<TData> }              // Advance with data\n  | { type: 'BACK' }                                      // Go back\n  | { type: 'GOTO'; step: number }                        // Jump to step\n  | { type: 'VALIDATE' }                                  // Manual validation\n  | { type: 'SUBMIT' }                                    // Submit (internal)\n  | { type: 'CANCEL' }                                    // Cancel wizard\n  | { type: 'RESTORE'; savedContext: WizardContext<TData> } // Resume from session\n  | { type: 'SET_DATA'; data: Partial<TData> }           // Update data without advancing\n  | { type: 'CLEAR_ERRORS' };                            // Clear validation errors\n"})}),"\n",(0,a.jsx)(n.h2,{id:"guards",children:"Guards"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"{\n  canGoBack: boolean;       // currentStep > 1\n  canGoForward: boolean;    // currentStep < totalSteps\n  isLastStep: boolean;      // currentStep === totalSteps\n  isNotLastStep: boolean;   // currentStep < totalSteps\n  canGoToStep: boolean;     // targetStep valid and allowed (targetStep <= currentStep or canSkip)\n  validationPassed: boolean; // Validation succeeded\n}\n"})}),"\n",(0,a.jsx)(n.h2,{id:"actions",children:"Actions"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"{\n  incrementStep();          // currentStep++, clear errors\n  decrementStep();          // currentStep--, clear errors\n  goToStep(step);           // currentStep = step, clear errors\n  mergeData(data);          // Merge NEXT/SET_DATA into data\n  setValidationErrors();    // Store validation errors from validation result\n  clearErrors();            // Clear errors object\n  restoreContext();         // Restore saved session (currentStep, data, sessionId)\n}\n"})}),"\n",(0,a.jsx)(n.h2,{id:"configuration",children:"Configuration"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"interface WizardConfig<TData = Record<string, unknown>> {\n  /** Unique machine ID */\n  id: string;\n\n  /** Total number of steps */\n  totalSteps: number;\n\n  /** Step validation function */\n  validateStep: (\n    step: number,\n    data: Partial<TData>\n  ) => Promise<{ valid: boolean; errors?: Record<string, string> }>;\n\n  /** Submit handler called when wizard completes */\n  onSubmit: (data: TData) => Promise<void>;\n\n  /** Initial data for the wizard (optional) */\n  initialData?: Partial<TData>;\n\n  /** Whether to persist wizard state to localStorage @default true */\n  persist?: boolean;\n}\n"})}),"\n",(0,a.jsxs)(n.h2,{id:"usage-with-usewizard-hook",children:["Usage with ",(0,a.jsx)(n.code,{children:"useWizard"})," Hook"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-tsx",children:"import { useWizard } from '@nasnet/state/machines';\n\ninterface VPNSetupData {\n  provider: 'wireguard' | 'openvpn' | 'ikev2';\n  serverAddress: string;\n  serverPort: number;\n  credentials: {\n    username: string;\n    password: string;\n  };\n}\n\nfunction VPNSetupWizard() {\n  const wizard = useWizard<VPNSetupData>(\n    {\n      id: 'vpn-setup',\n      totalSteps: 3,\n      validateStep: async (step, data) => {\n        if (step === 1 && !data.provider) {\n          return {\n            valid: false,\n            errors: { provider: 'Select a VPN provider' },\n          };\n        }\n        if (step === 2 && !data.serverAddress) {\n          return {\n            valid: false,\n            errors: { serverAddress: 'Server address is required' },\n          };\n        }\n        if (step === 3 && (!data.credentials?.username || !data.credentials?.password)) {\n          return {\n            valid: false,\n            errors: { credentials: 'Username and password required' },\n          };\n        }\n        return { valid: true };\n      },\n      onSubmit: async (data) => {\n        await api.createVPNConnection(data);\n      },\n    },\n    {\n      autoPersist: true,\n      autoRestore: false,  // Show restore prompt\n      onComplete: () => {\n        toast.success('VPN configured successfully!');\n        navigate('/vpn');\n      },\n      onCancel: () => {\n        toast.info('VPN setup cancelled');\n      },\n    }\n  );\n\n  // Show resume prompt if session available\n  if (wizard.canRestore) {\n    return (\n      <ResumePrompt\n        age={wizard.savedSessionAge}\n        onResume={wizard.restore}\n        onDiscard={wizard.discardSession}\n      />\n    );\n  }\n\n  // Render steps\n  const renderStep = () => {\n    switch (wizard.currentStep) {\n      case 1:\n        return (\n          <ProviderSelection\n            selected={wizard.data.provider}\n            onSelect={(provider) =>\n              wizard.setData({ provider })\n            }\n            onNext={(provider) =>\n              wizard.next({ provider })\n            }\n          />\n        );\n      case 2:\n        return (\n          <ServerConfig\n            address={wizard.data.serverAddress}\n            port={wizard.data.serverPort}\n            errors={wizard.errors}\n            onNext={(config) => wizard.next(config)}\n          />\n        );\n      case 3:\n        return (\n          <CredentialsForm\n            credentials={wizard.data.credentials}\n            errors={wizard.errors}\n            onNext={(creds) =>\n              wizard.next({ credentials: creds })\n            }\n          />\n        );\n      default:\n        return null;\n    }\n  };\n\n  return (\n    <WizardContainer>\n      <StepIndicator\n        current={wizard.currentStep}\n        total={wizard.totalSteps}\n        progress={wizard.progress}\n      />\n\n      {wizard.isValidating && <LoadingSpinner />}\n      {!wizard.isValidating && renderStep()}\n\n      <WizardNavigation\n        onBack={wizard.back}\n        onNext={() => wizard.next(wizard.data)}\n        onCancel={wizard.cancel}\n        canGoBack={!wizard.isFirstStep && !wizard.isValidating}\n        canGoNext={!wizard.isValidating}\n        canCancel={true}\n      />\n    </WizardContainer>\n  );\n}\n"})}),"\n",(0,a.jsx)(n.h2,{id:"hook-return-type",children:"Hook Return Type"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"interface UseWizardReturn<TData> {\n  // State\n  currentStep: number;\n  totalSteps: number;\n  data: Partial<TData>;\n  errors: Record<string, string>;\n  sessionId: string;\n  progress: number;  // 0-100\n\n  // Status\n  isValidating: boolean;\n  isSubmitting: boolean;\n  isCompleted: boolean;\n  isCancelled: boolean;\n  isFirstStep: boolean;\n  isLastStep: boolean;\n  canRestore: boolean;\n  savedSessionAge: string | null;\n\n  // Actions\n  next: (data?: Partial<TData>) => void;\n  back: () => void;\n  goToStep: (step: number) => void;\n  setData: (data: Partial<TData>) => void;\n  clearErrors: () => void;\n  cancel: () => void;\n  restore: () => void;\n  discardSession: () => void;\n  canAccessStep: (step: number) => boolean;\n}\n"})}),"\n",(0,a.jsx)(n.h2,{id:"code-examples",children:"Code Examples"}),"\n",(0,a.jsx)(n.h3,{id:"multi-step-device-pairing",children:"Multi-step Device Pairing"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"interface DevicePairingData {\n  deviceType: 'router' | 'ap' | 'switch';\n  macAddress: string;\n  friendlyName: string;\n  location: string;\n  vlan: number;\n}\n\nconst pairingWizard = useWizard<DevicePairingData>(\n  {\n    id: 'device-pairing',\n    totalSteps: 4,\n    validateStep: async (step, data) => {\n      const errors: Record<string, string> = {};\n\n      if (step === 1 && !data.deviceType) {\n        errors.deviceType = 'Select device type';\n      }\n      if (step === 2 && !data.macAddress?.match(/^([0-9A-Fa-f]{2}[:]){5}([0-9A-Fa-f]{2})$/)) {\n        errors.macAddress = 'Invalid MAC address format';\n      }\n      if (step === 3 && !data.friendlyName?.trim()) {\n        errors.friendlyName = 'Device name is required';\n      }\n      if (step === 4 && !data.vlan) {\n        errors.vlan = 'VLAN is required';\n      }\n\n      return { valid: Object.keys(errors).length === 0, errors };\n    },\n    onSubmit: async (data) => {\n      await api.pairDevice(data);\n    },\n  },\n  { autoPersist: true }\n);\n"})}),"\n",(0,a.jsx)(n.h3,{id:"validate-entire-form",children:"Validate Entire Form"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-tsx",children:"// Option 1: Validate on each step advance\nwizard.next(stepData);  // Validation happens automatically\n\n// Option 2: Manual validation (for preview)\nconst validateAll = async () => {\n  for (let step = 1; step <= wizard.totalSteps; step++) {\n    const result = await config.validateStep(step, wizard.data);\n    if (!result.valid) {\n      toast.error(`Step ${step} has validation errors`);\n      return false;\n    }\n  }\n  return true;\n};\n"})}),"\n",(0,a.jsx)(n.h3,{id:"step-to-step-with-custom-logic",children:"Step-to-Step with Custom Logic"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-tsx",children:"function ProviderStep() {\n  const wizard = useContext(WizardContext);\n\n  const handleProviderSelect = async (provider: string) => {\n    wizard.setData({ provider });\n\n    // If switching providers, fetch available servers\n    if (provider !== wizard.data.provider) {\n      const servers = await api.getServersForProvider(provider);\n      wizard.setData({ availableServers: servers });\n    }\n\n    wizard.next({ provider });\n  };\n\n  return (\n    <ProviderSelector\n      onSelect={handleProviderSelect}\n      disabled={wizard.isValidating}\n    />\n  );\n}\n"})}),"\n",(0,a.jsx)(n.h2,{id:"session-persistence",children:"Session Persistence"}),"\n",(0,a.jsx)(n.p,{children:"The wizard automatically persists state to localStorage:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"// Storage structure\nlocalStorage['nasnet-machine-vpn-setup'] = JSON.stringify({\n  state: 'step',\n  context: {\n    currentStep: 2,\n    totalSteps: 3,\n    data: { provider: 'wireguard', /* ... */ },\n    errors: {},\n    sessionId: 'uuid-123',\n  },\n  timestamp: 1234567890,\n  machineId: 'vpn-setup',\n});\n"})}),"\n",(0,a.jsx)(n.p,{children:"Session recovery:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-tsx",children:'// Hook detects saved session on mount\nif (wizard.canRestore) {\n  // Show resume prompt\n  return (\n    <ResumePrompt\n      onResume={wizard.restore}    // Resume from step 2\n      onDiscard={wizard.discardSession}  // Start over\n      age={wizard.savedSessionAge}  // "2 hours ago"\n    />\n  );\n}\n'})}),"\n",(0,a.jsx)(n.h2,{id:"auto-skip-on-validation",children:"Auto-Skip on Validation"}),"\n",(0,a.jsx)(n.p,{children:"If all steps are pre-validated, wizard can auto-advance:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"const wizardWithSkip = useWizard(\n  config,\n  {\n    autoPersist: true,\n  }\n);\n\nuseEffect(() => {\n  // Auto-advance if current step is valid\n  if (wizard.data.provider) {\n    wizard.next();\n  }\n}, [wizard.data.provider]);\n"})}),"\n",(0,a.jsx)(n.h2,{id:"comparing-wizard-versions",children:"Comparing Wizard Versions"}),"\n",(0,a.jsx)(n.p,{children:"The library exports two versions:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsxs)(n.strong,{children:["v1 (",(0,a.jsx)(n.code,{children:"createWizardMachine"}),"):"]})," Simpler, direct state management"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsxs)(n.strong,{children:["v2 (",(0,a.jsx)(n.code,{children:"createWizardMachineV2"}),"):"]})," Explicit last-step handling (default export)"]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"Both are identical in behavior; v2 is recommended for clarity."}),"\n",(0,a.jsx)(n.h2,{id:"related-documentation",children:"Related Documentation"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Overview:"})," See ",(0,a.jsx)(n.code,{children:"overview.md"})," for machine catalog and decision tree"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Config Pipeline:"})," See ",(0,a.jsx)(n.code,{children:"config-pipeline.md"})," for single-resource validation flow"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Persistence:"})," See ",(0,a.jsx)(n.code,{children:"persistence.md"})," for session recovery details"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Hooks:"})," ",(0,a.jsx)(n.code,{children:"useWizard"})," exports from ",(0,a.jsx)(n.code,{children:"@nasnet/state/machines"})]}),"\n"]})]})}function p(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(c,{...e})}):c(e)}}}]);