"use strict";(globalThis.webpackChunk_nas_net_docs=globalThis.webpackChunk_nas_net_docs||[]).push([[61896],{71184:(e,n,t)=>{t.d(n,{R:()=>i,x:()=>l});var r=t(14041);const s={},a=r.createContext(s);function i(e){const n=r.useContext(a);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:i(e.components),r.createElement(a.Provider,{value:n},e.children)}},92544:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>l,default:()=>h,frontMatter:()=>i,metadata:()=>r,toc:()=>d});const r=JSON.parse('{"id":"cross-cutting-features/change-set-system","title":"Change Set System","description":"The change set system provides atomic multi-resource operations for router configuration. Instead of applying one resource at a time, you batch multiple changes together, validate them, apply in dependency order, and automatically roll back if anything fails.","source":"@site/../connect/docs/cross-cutting-features/change-set-system.md","sourceDirName":"cross-cutting-features","slug":"/cross-cutting-features/change-set-system","permalink":"/docs/frontend/cross-cutting-features/change-set-system","draft":false,"unlisted":false,"editUrl":"https://github.com/nasnet-community/nasnet-panel/tree/main/../connect/docs/cross-cutting-features/change-set-system.md","tags":[],"version":"current","frontMatter":{},"sidebar":"sidebar","previous":{"title":"Alerts System","permalink":"/docs/frontend/cross-cutting-features/alerts-system"},"next":{"title":"Configuration Import","permalink":"/docs/frontend/cross-cutting-features/configuration-import"}}');var s=t(31085),a=t(71184);const i={},l="Change Set System",c={},d=[{value:"Overview",id:"overview",level:2},{value:"State Machine (XState)",id:"state-machine-xstate",level:2},{value:"Machine Context",id:"machine-context",level:3},{value:"Machine Events",id:"machine-events",level:3},{value:"Usage",id:"usage",level:3},{value:"Zustand Store",id:"zustand-store",level:2},{value:"Store Structure",id:"store-structure",level:3},{value:"Persistence",id:"persistence",level:3},{value:"Key Actions",id:"key-actions",level:3},{value:"Selectors",id:"selectors",level:3},{value:"Dependency Ordering (Topological Sort)",id:"dependency-ordering-topological-sort",level:2},{value:"Rollback Plan",id:"rollback-plan",level:2},{value:"Change Set Statuses",id:"change-set-statuses",level:2},{value:"Progress Events",id:"progress-events",level:2},{value:"Helper Functions",id:"helper-functions",level:2},{value:"Error Handling",id:"error-handling",level:2}];function o(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,a.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"change-set-system",children:"Change Set System"})}),"\n",(0,s.jsx)(n.p,{children:"The change set system provides atomic multi-resource operations for router configuration. Instead of applying one resource at a time, you batch multiple changes together, validate them, apply in dependency order, and automatically roll back if anything fails."}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Key files:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"libs/state/machines/src/changeSetMachine.ts"})," \u2014 XState machine (orchestration)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"libs/state/stores/src/change-set/change-set.store.ts"})," \u2014 Zustand store (data management)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"libs/api-client/queries/src/change-set/"})," \u2014 GraphQL hooks"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Cross-references:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["See ",(0,s.jsx)(n.code,{children:"../state-management/xstate-machines.md"})," for XState patterns"]}),"\n",(0,s.jsxs)(n.li,{children:["See ",(0,s.jsx)(n.code,{children:"../data-fetching/graphql-hooks.md"})," for query patterns"]}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,s.jsxs)(n.p,{children:["A ",(0,s.jsx)(n.strong,{children:"change set"})," is a named collection of resource operations (CREATE, UPDATE, DELETE) that apply together atomically. If step 4 of 6 fails, steps 1-3 are rolled back in reverse order. The UI shows real-time progress during apply."]}),"\n",(0,s.jsx)(n.p,{children:"This is used whenever configuration involves multiple interdependent resources \u2014 e.g., creating a LAN bridge requires a bridge interface, a VLAN, address assignments, and firewall rules in a specific order."}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"state-machine-xstate",children:"State Machine (XState)"}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"createChangeSetMachine"})," factory (from ",(0,s.jsx)(n.code,{children:"changeSetMachine.ts"}),") returns an XState v5 machine with 10 states:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"idle\n  \u2502  LOAD \u2192 loadChangeSet action\n  \u2502  START_VALIDATION\n  \u25bc\nvalidating  \u2500\u2500\u2500\u2500 CANCEL \u2500\u2500\u2192 cancelled\n  \u2502 success (no errors)\n  \u25bc\nready \u2500\u2500\u2500\u2500 APPLY (guard: canApply) \u2500\u2500\u2192 applying\n  \u2502\n  \u251c\u2500\u2500 applying.applyingItem  [invoke: applyCurrentItem]\n  \u2502     \u2502 onDone \u2192 checkingMore\n  \u2502     \u2502 onError \u2192 rollingBack\n  \u2502\n  \u2514\u2500\u2500 applying.checkingMore\n        \u251c\u2500\u2500 [guard: isCancelled] \u2192 cancelled\n        \u251c\u2500\u2500 [guard: hasMoreItems] \u2192 applyingItem (nextItem action)\n        \u2514\u2500\u2500 [guard: noMoreItems] \u2192 completed (final)\n\nrollingBack  [invoke: executeRollback]\n  \u251c\u2500\u2500 [some steps failed] \u2192 partialFailure (final)\n  \u2514\u2500\u2500 [all rolled back]   \u2192 rolledBack (final)\n\nfailed\n  \u251c\u2500\u2500 RETRY \u2192 validating\n  \u251c\u2500\u2500 FORCE_ROLLBACK (guard: hasAppliedItems) \u2192 rollingBack\n  \u2514\u2500\u2500 RESET \u2192 idle\n\npartialFailure (final) \u2014 manual intervention required\ncancelled (final)\n  \u251c\u2500\u2500 FORCE_ROLLBACK \u2192 rollingBack\n  \u2514\u2500\u2500 RESET \u2192 idle\n"})}),"\n",(0,s.jsx)(n.h3,{id:"machine-context",children:"Machine Context"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"interface ChangeSetMachineContext {\n  changeSet: ChangeSet | null;\n  routerId: string | null;\n  validationResult: ChangeSetValidationResult | null;\n  currentItemIndex: number;\n  sortedItems: ChangeSetItem[];      // Topologically sorted\n  appliedItems: ChangeSetItem[];     // Successfully applied so far\n  rollbackPlan: RollbackStep[];      // Grows during apply (prepended, so reverse order)\n  error: ChangeSetError | null;\n  cancelRequested: boolean;\n  applyStartedAt: number | null;\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"machine-events",children:"Machine Events"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Event"}),(0,s.jsx)(n.th,{children:"From States"}),(0,s.jsx)(n.th,{children:"Description"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"LOAD"})}),(0,s.jsx)(n.td,{children:"idle"}),(0,s.jsx)(n.td,{children:"Load a change set and router ID"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"START_VALIDATION"})}),(0,s.jsx)(n.td,{children:"idle"}),(0,s.jsx)(n.td,{children:"Begin validation"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"APPLY"})}),(0,s.jsx)(n.td,{children:"ready"}),(0,s.jsxs)(n.td,{children:["Begin applying (requires ",(0,s.jsx)(n.code,{children:"canApply"})," guard)"]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"CANCEL"})}),(0,s.jsx)(n.td,{children:"validating, ready, applying"}),(0,s.jsx)(n.td,{children:"Cancel (stops at next safe point)"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"RETRY"})}),(0,s.jsx)(n.td,{children:"failed"}),(0,s.jsx)(n.td,{children:"Re-run validation"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"FORCE_ROLLBACK"})}),(0,s.jsx)(n.td,{children:"failed, cancelled"}),(0,s.jsx)(n.td,{children:"Force rollback of already-applied items"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"RESET"})}),(0,s.jsx)(n.td,{children:"ready, failed, cancelled"}),(0,s.jsx)(n.td,{children:"Clear state and return to idle"})]})]})]}),"\n",(0,s.jsx)(n.h3,{id:"usage",children:"Usage"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"import { createChangeSetMachine } from '@nasnet/state/machines';\nimport { useActor } from 'xstate';\n\nconst machine = createChangeSetMachine({\n  validateChangeSet: async (changeSet) => {\n    const result = await client.mutate({ mutation: VALIDATE_CHANGE_SET, variables: { changeSet } });\n    return result.data.validation;\n  },\n  applyItem: async ({ item, routerId }) => {\n    const result = await client.mutate({\n      mutation: APPLY_RESOURCE,\n      variables: { routerId, resourceType: item.resourceType, config: item.configuration },\n    });\n    return { confirmedState: result.data.confirmedState, resourceUuid: result.data.resourceUuid };\n  },\n  rollbackItem: async ({ rollbackStep, routerId }) => {\n    await client.mutate({ mutation: ROLLBACK_RESOURCE, variables: { routerId, ...rollbackStep } });\n  },\n  onComplete: (cs) => toast.success(`Applied ${cs.items.length} changes`),\n  onFailed: (err) => toast.error(err.message),\n});\n\nconst [state, send] = useActor(machine);\n\n// Start flow\nsend({ type: 'LOAD', changeSet, routerId });\nsend({ type: 'START_VALIDATION' });\n\n// After machine reaches 'ready'\nsend({ type: 'APPLY' });\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"zustand-store",children:"Zustand Store"}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"useChangeSetStore"})," (from ",(0,s.jsx)(n.code,{children:"change-set.store.ts"}),") manages data: creating, updating, and querying change sets. The machine handles orchestration; the store handles persistence."]}),"\n",(0,s.jsx)(n.h3,{id:"store-structure",children:"Store Structure"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"interface ChangeSetState {\n  changeSets: Record<string, ChangeSet>;    // All active change sets by ID\n  activeChangeSetId: string | null;          // Currently focused change set\n  applyingChangeSetIds: string[];            // Optimistic UI tracking\n  lastError: string | null;\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"persistence",children:"Persistence"}),"\n",(0,s.jsxs)(n.p,{children:["Only ",(0,s.jsx)(n.code,{children:"DRAFT"})," and ",(0,s.jsx)(n.code,{children:"READY"})," change sets survive page refresh (persisted to ",(0,s.jsx)(n.code,{children:"localStorage"})," under key ",(0,s.jsx)(n.code,{children:"nasnet-change-sets"}),"). Completed, failed, rolled-back, and cancelled change sets are excluded from persistence."]}),"\n",(0,s.jsx)(n.h3,{id:"key-actions",children:"Key Actions"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"const store = useChangeSetStore();\n\n// Create a new change set\nconst id = store.createChangeSet({\n  name: 'Create LAN Network',\n  routerId: 'router-123',\n  source: 'lan-wizard',\n});\n\n// Add items (only works when status is DRAFT)\nstore.addItem(id, {\n  name: 'Bridge Interface',\n  resourceType: 'network.bridge',\n  operation: 'CREATE',\n  configuration: { name: 'bridge-lan', vlan: 100 },\n  dependencies: [],\n});\n\n// Recalculate apply order (called automatically after addItem)\nstore.recalculateApplyOrder(id);\n\n// Lifecycle transitions\nstore.markApplying(id);   // DRAFT \u2192 APPLYING\nstore.markCompleted(id);  // APPLYING \u2192 COMPLETED\nstore.markFailed(id, 'timeout', 'item-xyz'); // APPLYING \u2192 FAILED\nstore.markRolledBack(id); // FAILED \u2192 ROLLED_BACK\n"})}),"\n",(0,s.jsx)(n.h3,{id:"selectors",children:"Selectors"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// Select active change set\nconst activeCs = useChangeSetStore(selectActiveChangeSet);\n\n// Select all change sets for a router\nconst routerCs = useChangeSetStore(createSelectChangeSetsForRouter('router-123'));\n\n// Select draft change sets for a router\nconst drafts = useChangeSetStore(createSelectDraftChangeSets('router-123'));\n\n// Check if any change set is applying\nconst isApplying = useChangeSetStore(selectIsAnyApplying);\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"dependency-ordering-topological-sort",children:"Dependency Ordering (Topological Sort)"}),"\n",(0,s.jsx)(n.p,{children:"Items in a change set may depend on each other. For example, a firewall rule can't be created before the address list it references."}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"sortItemsByDependency"})," function inside ",(0,s.jsx)(n.code,{children:"changeSetMachine.ts"})," uses ",(0,s.jsx)(n.code,{children:"buildDependencyGraph"})," and ",(0,s.jsx)(n.code,{children:"topologicalSort"})," from ",(0,s.jsx)(n.code,{children:"@nasnet/core/utils"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"function sortItemsByDependency(items: ChangeSetItem[]): ChangeSetItem[] {\n  const nodes = buildDependencyGraph(items);\n  const result = topologicalSort(nodes);\n\n  if (!result.success) {\n    // Cycle detected \u2014 validation should have caught this\n    return items; // fall back to original order\n  }\n\n  const itemMap = new Map(items.map((item) => [item.id, item]));\n  return result.sortedIds.map((id) => itemMap.get(id)!).filter(Boolean);\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["If a cycle is detected during validation, ",(0,s.jsx)(n.code,{children:"validationResult.errors"})," will contain a cycle error and ",(0,s.jsx)(n.code,{children:"canApply"})," will be false."]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"rollback-plan",children:"Rollback Plan"}),"\n",(0,s.jsxs)(n.p,{children:["The rollback plan is built as items are applied. Each newly applied item is ",(0,s.jsx)(n.strong,{children:"prepended"})," to the rollback plan (index 0), so the plan is always in reverse apply order:"]}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Apply Order"}),(0,s.jsx)(n.th,{children:"Item"}),(0,s.jsx)(n.th,{children:"Rollback Operation"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"1"}),(0,s.jsx)(n.td,{children:"Create bridge"}),(0,s.jsx)(n.td,{children:"DELETE bridge"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"2"}),(0,s.jsx)(n.td,{children:"Create VLAN"}),(0,s.jsx)(n.td,{children:"DELETE VLAN"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"3 (failed)"}),(0,s.jsx)(n.td,{children:"Create firewall rule"}),(0,s.jsx)(n.td,{children:"(never applied)"})]})]})]}),"\n",(0,s.jsx)(n.p,{children:"Rollback executes in stored order: DELETE VLAN first, then DELETE bridge."}),"\n",(0,s.jsx)(n.p,{children:"Rollback operations by original operation:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"CREATE"})," \u2192 ",(0,s.jsx)(n.code,{children:"DELETE"})]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"UPDATE"})," \u2192 ",(0,s.jsx)(n.code,{children:"REVERT"})," (restore ",(0,s.jsx)(n.code,{children:"previousState"}),")"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"DELETE"})," \u2192 ",(0,s.jsx)(n.code,{children:"RESTORE"})," (restore ",(0,s.jsx)(n.code,{children:"previousState"}),")"]}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"change-set-statuses",children:"Change Set Statuses"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"const ChangeSetStatus = {\n  DRAFT: 'DRAFT',            // Editable, not yet validated\n  READY: 'READY',            // Validated, awaiting user confirmation\n  APPLYING: 'APPLYING',      // Apply in progress (read-only)\n  COMPLETED: 'COMPLETED',    // All items applied successfully\n  FAILED: 'FAILED',          // Apply failed (may have partially applied)\n  ROLLING_BACK: 'ROLLING_BACK',\n  ROLLED_BACK: 'ROLLED_BACK',\n  CANCELLED: 'CANCELLED',\n};\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Only ",(0,s.jsx)(n.code,{children:"DRAFT"})," change sets can have items added, updated, or removed."]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"progress-events",children:"Progress Events"}),"\n",(0,s.jsxs)(n.p,{children:["The machine emits ",(0,s.jsx)(n.code,{children:"ChangeSetProgressEvent"})," via the ",(0,s.jsx)(n.code,{children:"onProgress"})," callback during apply:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"interface ChangeSetProgressEvent {\n  changeSetId: string;\n  status: 'validating' | 'applying' | 'completed' | 'rolling_back' | 'failed';\n  currentItem: { id: string; name: string; index: number } | null;\n  appliedCount: number;\n  totalCount: number;\n  progressPercent: number;\n  error: string | null;\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Use this to drive a progress bar UI. The ",(0,s.jsx)(n.code,{children:"progressPercent"})," is ",(0,s.jsx)(n.code,{children:"(appliedCount / totalCount) * 100"}),"."]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"helper-functions",children:"Helper Functions"}),"\n",(0,s.jsxs)(n.p,{children:["From ",(0,s.jsx)(n.code,{children:"changeSetMachine.ts"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// Check if in an active processing state\nisChangeSetProcessing(state) // true during validating, rollingBack, or applying\n\n// Check if in a terminal state\nisChangeSetFinal(state) // true for completed, rolledBack, failed, partialFailure, cancelled\n\n// Check if cancellation is available\nisChangeSetCancellable(state) // true for validating, ready, applying\n\n// Human-readable description\ngetChangeSetMachineStateDescription(state) // e.g., 'Applying changes...'\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"error-handling",children:"Error Handling"}),"\n",(0,s.jsx)(n.p,{children:"When an item fails:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"interface ChangeSetError {\n  message: string;\n  failedItemId: string;\n  partiallyAppliedItemIds: string[];  // Items that were applied before failure\n  failedRollbackItemIds: string[];    // Items that failed to roll back\n  requiresManualIntervention: boolean; // true if rollback also failed\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["If ",(0,s.jsx)(n.code,{children:"requiresManualIntervention"})," is true, the machine reaches ",(0,s.jsx)(n.code,{children:"partialFailure"})," (a final state). The UI must show the user exactly which resources need manual cleanup, with the ",(0,s.jsx)(n.code,{children:"failedRollbackItemIds"})," list."]})]})}function h(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(o,{...e})}):o(e)}}}]);