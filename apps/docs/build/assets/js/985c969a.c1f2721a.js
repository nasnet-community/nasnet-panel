"use strict";(globalThis.webpackChunk_nas_net_docs=globalThis.webpackChunk_nas_net_docs||[]).push([[979],{71184:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>c});var r=t(14041);const i={},s=r.createContext(i);function o(e){const n=r.useContext(s);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),r.createElement(s.Provider,{value:n},e.children)}},83963:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>c,default:()=>h,frontMatter:()=>o,metadata:()=>r,toc:()=>a});const r=JSON.parse('{"id":"offline-first","title":"Offline-First Architecture","description":"NasNetConnect operates in environments where network connectivity to the MikroTik router is inherently unstable \u2014 server rooms, mobile devices, and embedded containers. The offline-first system ensures the UI remains functional and consistent across degraded and fully disconnected states. It is composed of three cooperating modules: cache persistence (Apollo InMemoryCache \u2192 IndexedDB via localforage), offline detection (four signal sources converging to a Zustand network store), and an offline mutation queue (FIFO, deduplicated, auto-replaying queue backed by IndexedDB). Together they allow the app to serve cached data immediately on load, detect connectivity changes within seconds, and defer mutations until the connection is restored.","source":"@site/../../libs/api-client/docs/offline-first.md","sourceDirName":".","slug":"/offline-first","permalink":"/docs/api-client/offline-first","draft":false,"unlisted":false,"editUrl":"https://github.com/nasnet-community/nasnet-panel/tree/main/../../libs/api-client/docs/offline-first.md","tags":[],"version":"current","sidebarPosition":6,"frontMatter":{"sidebar_position":6,"title":"Offline-First Architecture"},"sidebar":"sidebar","previous":{"title":"Error Handling","permalink":"/docs/api-client/error-handling"},"next":{"title":"Universal State v2 Resource Model","permalink":"/docs/api-client/universal-state-resource-model"}}');var i=t(31085),s=t(71184);const o={sidebar_position:6,title:"Offline-First Architecture"},c="Offline-First Architecture",l={},a=[{value:"Architecture Sequence Diagram",id:"architecture-sequence-diagram",level:2},{value:"Cache Persistence",id:"cache-persistence",level:2},{value:"Purpose",id:"purpose",level:3},{value:"Storage Backend",id:"storage-backend",level:3},{value:"<code>CachePersistConfig</code>",id:"cachepersistconfig",level:3},{value:"<code>initializeCachePersistence(cache, config?)</code>",id:"initializecachepersistencecache-config",level:3},{value:"<code>clearPersistedCache(key?)</code>",id:"clearpersistedcachekey",level:3},{value:"<code>getPersistedCacheSize(key?)</code>",id:"getpersistedcachesizekey",level:3},{value:"Offline Detection",id:"offline-detection",level:2},{value:"Four Signal Sources",id:"four-signal-sources",level:3},{value:"<code>setupOfflineDetector(config?)</code>",id:"setupofflinedetectorconfig",level:3},{value:"Signal-to-Store Mapping",id:"signal-to-store-mapping",level:3},{value:"<code>useOfflineDetector(config?)</code>",id:"useofflinedetectorconfig",level:3},{value:"<code>isOffline()</code> and <code>isDegraded()</code>",id:"isoffline-and-isdegraded",level:3},{value:"Offline Mutation Queue",id:"offline-mutation-queue",level:2},{value:"Purpose",id:"purpose-1",level:3},{value:"<code>QueuedMutation</code>",id:"queuedmutation",level:3},{value:"<code>OfflineQueueConfig</code>",id:"offlinequeueconfig",level:3},{value:"<code>OfflineMutationQueue</code> Class",id:"offlinemutationqueue-class",level:3},{value:"<code>enqueue(mutation, variables, optimisticResponse?)</code>",id:"enqueuemutation-variables-optimisticresponse",level:4},{value:"<code>replayAll(client)</code>",id:"replayallclient",level:4},{value:"Queue Management Methods",id:"queue-management-methods",level:4},{value:"Singleton and Auto-Replay",id:"singleton-and-auto-replay",level:3},{value:"IndexedDB Storage Limitation",id:"indexeddb-storage-limitation",level:3},{value:"Full Integration Example",id:"full-integration-example",level:2},{value:"Custom Events",id:"custom-events",level:2},{value:"<code>network:error</code> Event",id:"networkerror-event",level:3},{value:"<code>ws:connected</code> Event",id:"wsconnected-event",level:3},{value:"<code>ws:closed</code> Event",id:"wsclosed-event",level:3},{value:"<code>ws:error</code> Event",id:"wserror-event",level:3},{value:"Imperative Connectivity API",id:"imperative-connectivity-api",level:2},{value:"<code>isOffline()</code>",id:"isoffline",level:3},{value:"<code>isDegraded()</code>",id:"isdegraded",level:3},{value:"Hook vs. Imperative Setup",id:"hook-vs-imperative-setup",level:2},{value:"<code>useOfflineDetector(config?)</code> \u2014 React Hook (Preferred)",id:"useofflinedetectorconfig--react-hook-preferred",level:3},{value:"<code>setupOfflineDetector(config?)</code> \u2014 Imperative Setup",id:"setupofflinedetectorconfig--imperative-setup",level:3},{value:"Health Check Configuration",id:"health-check-configuration",level:2},{value:"Configuration Options",id:"configuration-options",level:3},{value:"Health Check Behavior",id:"health-check-behavior",level:3},{value:"Tuning for Your Environment",id:"tuning-for-your-environment",level:3},{value:"See Also",id:"see-also",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"offline-first-architecture",children:"Offline-First Architecture"})}),"\n",(0,i.jsxs)(n.p,{children:["NasNetConnect operates in environments where network connectivity to the MikroTik router is inherently unstable \u2014 server rooms, mobile devices, and embedded containers. The offline-first system ensures the UI remains functional and consistent across degraded and fully disconnected states. It is composed of three cooperating modules: ",(0,i.jsx)(n.strong,{children:"cache persistence"})," (Apollo InMemoryCache \u2192 IndexedDB via localforage), ",(0,i.jsx)(n.strong,{children:"offline detection"})," (four signal sources converging to a Zustand network store), and an ",(0,i.jsx)(n.strong,{children:"offline mutation queue"})," (FIFO, deduplicated, auto-replaying queue backed by IndexedDB). Together they allow the app to serve cached data immediately on load, detect connectivity changes within seconds, and defer mutations until the connection is restored."]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"architecture-sequence-diagram",children:"Architecture Sequence Diagram"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"App Boot\n   \u2502\n   \u251c\u2500\u25ba initializeCachePersistence(apolloCache)\n   \u2502         \u2502  IndexedDB \u2192 InMemoryCache restore\n   \u2502         \u25bc\n   \u2502   Apollo serves cached data immediately\n   \u2502\n   \u251c\u2500\u25ba useOfflineDetector() / setupOfflineDetector()\n   \u2502         \u2502\n   \u2502   \u250c\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n   \u2502   \u2502 Signal 1: navigator.online/offline events       \u2502\n   \u2502   \u2502 Signal 2: 'network:error' (from errorLink)      \u2502\n   \u2502   \u2502 Signal 3: 'ws:connected/closed/error' (from ws) \u2502\n   \u2502   \u2502 Signal 4: /api/health polling (every 30s)       \u2502\n   \u2502   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n   \u2502                      \u25bc\n   \u2502           useNetworkStore.setOnline()\n   \u2502           useNetworkStore.setRouterReachable()\n   \u2502           useNetworkStore.setRouterConnected()\n   \u2502\n   \u2514\u2500\u25ba setupAutoReplay(apolloClient)\n             \u2502\n       subscribe to isRouterReachable changes\n             \u2502\n       false \u2192 true? \u2500\u2500\u25ba offlineQueue.replayAll(apolloClient)\n                                    \u2502\n                              sorted by timestamp (FIFO)\n                                    \u2502\n                         for each QueuedMutation:\n                              apolloClient.mutate()\n                                    \u2502\n                              success \u2192 remove from queue\n                              failure \u2192 retryCount++\n                                     \u2192 discard at maxRetries\n\n\nUser makes mutation while offline:\n   \u2514\u2500\u25ba offlineQueue.enqueue(mutation, variables)\n             \u2502  dedup by operationName+variables (last-write-wins)\n             \u2502  persist to IndexedDB\n             \u2514\u2500\u25ba UI shows optimistic response\n"})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"cache-persistence",children:"Cache Persistence"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Source:"})," ",(0,i.jsx)(n.code,{children:"core/src/apollo/apollo-cache-persist.ts"})]}),"\n",(0,i.jsx)(n.h3,{id:"purpose",children:"Purpose"}),"\n",(0,i.jsxs)(n.p,{children:["Apollo's ",(0,i.jsx)(n.code,{children:"InMemoryCache"})," is volatile \u2014 it is cleared on every page reload. Cache persistence writes the serialized cache to IndexedDB on every mutation, making it available to the next page load. On cold start, the app hydrates the cache from IndexedDB before the first React render, so queries return cached data immediately without a loading spinner."]}),"\n",(0,i.jsx)(n.h3,{id:"storage-backend",children:"Storage Backend"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"// core/src/apollo/apollo-cache-persist.ts:44\nfunction configureStorage(): typeof localforage {\n  localforage.config({\n    driver: [localforage.INDEXEDDB, localforage.LOCALSTORAGE],\n    name: 'nasnet-apollo-cache',\n    storeName: 'apollo_cache',\n    description: 'Apollo Client cache persistence for offline support',\n  });\n  return localforage;\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"localforage"})," is used as the IndexedDB abstraction layer. The driver priority list ",(0,i.jsx)(n.code,{children:"[INDEXEDDB, LOCALSTORAGE]"})," means IndexedDB is used when available, with ",(0,i.jsx)(n.code,{children:"localStorage"})," as the fallback for environments that restrict IndexedDB (some private browsing modes). All storage keys are prefixed with the configured ",(0,i.jsx)(n.code,{children:"key"})," option (default: ",(0,i.jsx)(n.code,{children:"nasnet-apollo-cache"}),") to avoid collisions with other IndexedDB databases."]}),"\n",(0,i.jsx)(n.h3,{id:"cachepersistconfig",children:(0,i.jsx)(n.code,{children:"CachePersistConfig"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"export interface CachePersistConfig {\n  maxSize?: number;   // Default: 5MB (5 * 1024 * 1024 bytes)\n  debounce?: number;  // Default: 1000ms \u2014 write debounce to reduce I/O\n  key?: string;       // Default: 'nasnet-apollo-cache' \u2014 storage key prefix\n  debug?: boolean;    // Default: import.meta.env.DEV\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"The 1-second debounce is critical for performance: without it, every real-time subscription update (e.g. bandwidth telemetry at 5-second intervals) would trigger an IndexedDB write. With the debounce, bursts of updates coalesce into a single write."}),"\n",(0,i.jsx)(n.h3,{id:"initializecachepersistencecache-config",children:(0,i.jsx)(n.code,{children:"initializeCachePersistence(cache, config?)"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"export async function initializeCachePersistence(\n  cache: InMemoryCache,\n  config?: CachePersistConfig\n): Promise<void>\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Restores the persisted cache into the provided ",(0,i.jsx)(n.code,{children:"InMemoryCache"})," instance using ",(0,i.jsx)(n.code,{children:"apollo3-cache-persist"}),". Must be awaited before ",(0,i.jsx)(n.code,{children:"ReactDOM.render()"})," to guarantee data is available on the first render cycle."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-tsx",children:"// Usage pattern (apps/connect/src/main.tsx or equivalent)\nimport { apolloCache } from '@nasnet/api-client/core';\nimport { initializeCachePersistence } from '@nasnet/api-client/core';\n\nasync function boot() {\n  await initializeCachePersistence(apolloCache);\n  ReactDOM.createRoot(document.getElementById('root')!).render(<App />);\n}\nboot();\n"})}),"\n",(0,i.jsxs)(n.p,{children:["If persistence fails (e.g., corrupted data), the function catches the error, calls ",(0,i.jsx)(n.code,{children:"clearPersistedCache()"})," to remove the corrupt entry, and continues without throwing \u2014 the app starts with an empty cache rather than crashing."]}),"\n",(0,i.jsxs)(n.p,{children:["SSR is detected via ",(0,i.jsx)(n.code,{children:"typeof window === 'undefined'"})," and the function returns early, making it safe to import in universal rendering setups."]}),"\n",(0,i.jsx)(n.h3,{id:"clearpersistedcachekey",children:(0,i.jsx)(n.code,{children:"clearPersistedCache(key?)"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"export async function clearPersistedCache(key?: string): Promise<void>\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Enumerates all localforage keys matching the prefix pattern ",(0,i.jsx)(n.code,{children:"<key>-*"})," and removes them. Should be called on logout alongside ",(0,i.jsx)(n.code,{children:"apolloClient.clearStore()"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"await clearPersistedCache();\napolloClient.clearStore();\n"})}),"\n",(0,i.jsx)(n.h3,{id:"getpersistedcachesizekey",children:(0,i.jsx)(n.code,{children:"getPersistedCacheSize(key?)"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"export async function getPersistedCacheSize(key?: string): Promise<number>\n"})}),"\n",(0,i.jsx)(n.p,{children:"Returns the total size in bytes of all cache entries. Useful for diagnostics; note that UTF-16 encoding means each stored character counts as 2 bytes."}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"offline-detection",children:"Offline Detection"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Source:"})," ",(0,i.jsx)(n.code,{children:"core/src/apollo/offline-detector.ts"})]}),"\n",(0,i.jsx)(n.h3,{id:"four-signal-sources",children:"Four Signal Sources"}),"\n",(0,i.jsx)(n.p,{children:"The offline detector aggregates signals from four independent sources. This redundancy is necessary because no single source is reliable across all failure modes:"}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Signal"}),(0,i.jsx)(n.th,{children:"Source"}),(0,i.jsx)(n.th,{children:"Limitations"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"navigator.online/offline"})}),(0,i.jsx)(n.td,{children:"Browser events"}),(0,i.jsxs)(n.td,{children:["Unreliable \u2014 can be ",(0,i.jsx)(n.code,{children:"online"})," while the actual router is unreachable"]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"network:error"})}),(0,i.jsxs)(n.td,{children:["Custom DOM event from ",(0,i.jsx)(n.code,{children:"apollo-error-link.ts"})]}),(0,i.jsx)(n.td,{children:"Only fires when a GraphQL request fails"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"ws:connected/closed/error"})}),(0,i.jsxs)(n.td,{children:["Custom DOM events from ",(0,i.jsx)(n.code,{children:"apollo-ws-client.ts"})]}),(0,i.jsx)(n.td,{children:"Only reflects WebSocket state, not HTTP"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsxs)(n.td,{children:[(0,i.jsx)(n.code,{children:"/api/health"})," polling"]}),(0,i.jsxs)(n.td,{children:[(0,i.jsx)(n.code,{children:"fetch()"})," every 30 seconds"]}),(0,i.jsx)(n.td,{children:"Active check; catches all cases but has latency"})]})]})]}),"\n",(0,i.jsxs)(n.p,{children:["Together they distinguish three connectivity states reflected in ",(0,i.jsx)(n.code,{children:"useNetworkStore"}),":"]}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"State"}),(0,i.jsx)(n.th,{children:(0,i.jsx)(n.code,{children:"isOnline"})}),(0,i.jsx)(n.th,{children:(0,i.jsx)(n.code,{children:"isRouterReachable"})}),(0,i.jsx)(n.th,{children:(0,i.jsx)(n.code,{children:"isRouterConnected"})})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Fully connected"}),(0,i.jsx)(n.td,{children:"true"}),(0,i.jsx)(n.td,{children:"true"}),(0,i.jsx)(n.td,{children:"true"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Degraded (browser online, server unreachable)"}),(0,i.jsx)(n.td,{children:"true"}),(0,i.jsx)(n.td,{children:"false"}),(0,i.jsx)(n.td,{children:"false/true"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Offline"}),(0,i.jsx)(n.td,{children:"false"}),(0,i.jsx)(n.td,{children:"false"}),(0,i.jsx)(n.td,{children:"false"})]})]})]}),"\n",(0,i.jsx)(n.h3,{id:"setupofflinedetectorconfig",children:(0,i.jsx)(n.code,{children:"setupOfflineDetector(config?)"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"export function setupOfflineDetector(\n  config?: OfflineDetectorConfig\n): CleanupFunction\n"})}),"\n",(0,i.jsx)(n.p,{children:"Registers all four signal listeners and starts the health check interval. Returns a cleanup function that removes all listeners and clears the interval."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"export interface OfflineDetectorConfig {\n  healthEndpoint?: string;         // Default: '/api/health'\n  healthCheckInterval?: number;    // Default: 30000ms (30 seconds)\n  healthCheckTimeout?: number;     // Default: 5000ms (5 seconds)\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["The health check uses ",(0,i.jsx)(n.code,{children:"AbortController"})," to enforce the timeout:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"// core/src/apollo/offline-detector.ts:130\nconst controller = new AbortController();\nconst timeoutId = setTimeout(() => controller.abort(), healthCheckTimeout);\nconst response = await fetch(healthEndpoint, {\n  method: 'GET',\n  signal: controller.signal,\n  redirect: 'error',\n});\n"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"redirect: 'error'"})," prevents a router redirect to a captive portal from being counted as a successful health check."]}),"\n",(0,i.jsx)(n.h3,{id:"signal-to-store-mapping",children:"Signal-to-Store Mapping"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"// Browser events \u2192 isOnline\nwindow.addEventListener('online',  () => store.setOnline(true) + performHealthCheck())\nwindow.addEventListener('offline', () => store.setOnline(false) + store.setRouterReachable(false))\n\n// Apollo error link event \u2192 isRouterReachable\nwindow.addEventListener('network:error', () => {\n  store.setRouterReachable(false);\n  store.incrementReconnectAttempts();\n})\n\n// WebSocket events \u2192 isRouterConnected\nwindow.addEventListener('ws:connected', () => {\n  store.setRouterConnected(true);\n  store.setRouterReachable(true);\n  store.resetReconnectAttempts();\n})\nwindow.addEventListener('ws:closed', () => store.setRouterConnected(false) + incrementAttempts)\nwindow.addEventListener('ws:error',  () => store.setRouterConnected(false) + incrementAttempts)\n"})}),"\n",(0,i.jsx)(n.p,{children:"When the browser comes back online, an immediate health check fires (before the next scheduled interval) to confirm actual backend reachability."}),"\n",(0,i.jsx)(n.h3,{id:"useofflinedetectorconfig",children:(0,i.jsx)(n.code,{children:"useOfflineDetector(config?)"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"export function useOfflineDetector(config?: OfflineDetectorConfig): void\n"})}),"\n",(0,i.jsxs)(n.p,{children:["React hook that wraps ",(0,i.jsx)(n.code,{children:"setupOfflineDetector"})," in a ",(0,i.jsx)(n.code,{children:"useEffect"})," with proper cleanup on unmount. The ",(0,i.jsx)(n.code,{children:"config"})," dependency is serialized via ",(0,i.jsx)(n.code,{children:"JSON.stringify"})," to produce a stable reference."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-tsx",children:"// Mount once at the app root\nfunction App() {\n  useOfflineDetector();  // starts all listeners + health polling\n  return <Router />;\n}\n"})}),"\n",(0,i.jsxs)(n.h3,{id:"isoffline-and-isdegraded",children:[(0,i.jsx)(n.code,{children:"isOffline()"})," and ",(0,i.jsx)(n.code,{children:"isDegraded()"})]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"export function isOffline(): boolean\n// true if: !state.isOnline || !state.isRouterReachable\n\nexport function isDegraded(): boolean\n// true if: state.isOnline && (!state.isRouterReachable || !state.isRouterConnected)\n"})}),"\n",(0,i.jsxs)(n.p,{children:["These functions read directly from ",(0,i.jsx)(n.code,{children:"useNetworkStore.getState()"})," and can be used outside React components (e.g., in the offline queue's ",(0,i.jsx)(n.code,{children:"setupAutoReplay"}),")."]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"offline-mutation-queue",children:"Offline Mutation Queue"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Source:"})," ",(0,i.jsx)(n.code,{children:"core/src/apollo/offline-queue.ts"})]}),"\n",(0,i.jsx)(n.h3,{id:"purpose-1",children:"Purpose"}),"\n",(0,i.jsx)(n.p,{children:"When a user performs a mutation while offline (or while the router is temporarily unreachable), discarding it would be hostile UX. The queue captures the mutation with its variables and persists it to IndexedDB. When connectivity is restored, the queue replays all pending mutations in the order they were submitted."}),"\n",(0,i.jsx)(n.h3,{id:"queuedmutation",children:(0,i.jsx)(n.code,{children:"QueuedMutation"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"export interface QueuedMutation {\n  id: string;                        // generateId() \u2014 timestamp + random\n  mutation: DocumentNode;\n  variables: Record<string, unknown>;\n  timestamp: Date;                   // Enqueue time \u2014 used for FIFO sort\n  retryCount: number;\n  operationName: string;\n  optimisticResponse?: unknown;      // Passed to apolloClient.mutate()\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"offlinequeueconfig",children:(0,i.jsx)(n.code,{children:"OfflineQueueConfig"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"export interface OfflineQueueConfig {\n  maxQueueSize?: number;  // Default: 50 \u2014 throws when full\n  maxRetries?: number;    // Default: 3 \u2014 discard after 3 failures\n  retryDelay?: number;    // Default: 1000ms \u2014 wait between retries\n  storageKey?: string;    // Default: 'nasnet-offline-queue'\n}\n"})}),"\n",(0,i.jsxs)(n.h3,{id:"offlinemutationqueue-class",children:[(0,i.jsx)(n.code,{children:"OfflineMutationQueue"})," Class"]}),"\n",(0,i.jsx)(n.h4,{id:"enqueuemutation-variables-optimisticresponse",children:(0,i.jsx)(n.code,{children:"enqueue(mutation, variables, optimisticResponse?)"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"async enqueue(\n  mutation: DocumentNode,\n  variables: Record<string, unknown>,\n  optimisticResponse?: unknown\n): Promise<string>  // returns the assigned id\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Checks for a duplicate entry (same ",(0,i.jsx)(n.code,{children:"operationName"})," + same ",(0,i.jsx)(n.code,{children:"JSON.stringify(variables)"}),") and removes it before adding the new entry. This implements ",(0,i.jsx)(n.strong,{children:"last-write-wins"})," conflict resolution: if the user edits the same resource twice while offline, only the latest intent is queued."]}),"\n",(0,i.jsxs)(n.p,{children:["Throws if the queue is at ",(0,i.jsx)(n.code,{children:"maxQueueSize"}),". Persists to IndexedDB after every enqueue."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"// Example: enqueue when offline\nif (isOffline()) {\n  await offlineQueue.enqueue(UPDATE_ROUTER_NAME, { id: routerId, name: newName });\n}\n"})}),"\n",(0,i.jsx)(n.h4,{id:"replayallclient",children:(0,i.jsx)(n.code,{children:"replayAll(client)"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"async replayAll(\n  client: ApolloClient<NormalizedCacheObject>\n): Promise<number>  // returns count of successfully replayed mutations\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Replays mutations in chronological order (sorted by ",(0,i.jsx)(n.code,{children:"timestamp"}),", oldest first):"]}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["Calls ",(0,i.jsx)(n.code,{children:"apolloClient.mutate()"})," with the stored ",(0,i.jsx)(n.code,{children:"mutation"}),", ",(0,i.jsx)(n.code,{children:"variables"}),", and optional ",(0,i.jsx)(n.code,{children:"optimisticResponse"}),"."]}),"\n",(0,i.jsx)(n.li,{children:"On success: removes the entry from queue and IndexedDB."}),"\n",(0,i.jsxs)(n.li,{children:["On failure: increments ",(0,i.jsx)(n.code,{children:"retryCount"}),". If ",(0,i.jsx)(n.code,{children:"retryCount >= maxRetries"}),", discards the entry. Otherwise keeps it for the next replay attempt."]}),"\n",(0,i.jsxs)(n.li,{children:["Waits ",(0,i.jsx)(n.code,{children:"retryDelay"})," ms between attempts."]}),"\n",(0,i.jsxs)(n.li,{children:["Guards against concurrent replays with ",(0,i.jsx)(n.code,{children:"isReplaying"})," flag."]}),"\n"]}),"\n",(0,i.jsx)(n.h4,{id:"queue-management-methods",children:"Queue Management Methods"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"async remove(id: string): Promise<void>\nasync clear(): Promise<void>\nsize(): number\nisEmpty(): boolean\ngetQueue(): ReadonlyArray<QueuedMutation>\n"})}),"\n",(0,i.jsx)(n.h3,{id:"singleton-and-auto-replay",children:"Singleton and Auto-Replay"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"// core/src/apollo/offline-queue.ts:375\nexport const offlineQueue = new OfflineMutationQueue();\n"})}),"\n",(0,i.jsxs)(n.p,{children:["The singleton is the standard entry point. Multiple ",(0,i.jsx)(n.code,{children:"OfflineMutationQueue"})," instances would write to different IndexedDB stores (different ",(0,i.jsx)(n.code,{children:"storageKey"}),") and operate independently."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"export function setupAutoReplay(\n  client: ApolloClient<NormalizedCacheObject>\n): () => void  // returns unsubscribe function\n"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"setupAutoReplay"})," subscribes to the Zustand ",(0,i.jsx)(n.code,{children:"useNetworkStore"})," via ",(0,i.jsx)(n.code,{children:"subscribe()"}),". When ",(0,i.jsx)(n.code,{children:"isRouterReachable"})," transitions from ",(0,i.jsx)(n.code,{children:"false"})," to ",(0,i.jsx)(n.code,{children:"true"}),", it calls ",(0,i.jsx)(n.code,{children:"offlineQueue.replayAll(client)"})," automatically:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"// core/src/apollo/offline-queue.ts:398\nconst unsubscribe = useNetworkStore.subscribe(\n  (state, prevState) => {\n    if (!prevState.isRouterReachable && state.isRouterReachable) {\n      handleOnline();\n    }\n  }\n);\n"})}),"\n",(0,i.jsxs)(n.p,{children:["This creates a clean integration: the offline detector manages ",(0,i.jsx)(n.code,{children:"isRouterReachable"}),", and the auto-replay mechanism reacts to its changes without polling."]}),"\n",(0,i.jsx)(n.h3,{id:"indexeddb-storage-limitation",children:"IndexedDB Storage Limitation"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"DocumentNode"})," (the parsed GraphQL AST) cannot be JSON-serialized to IndexedDB. The queue stores the serialized form as a placeholder:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"// core/src/apollo/offline-queue.ts:192\nconst serialized: SerializedMutation[] = this.queue.map((item) => ({\n  mutationString: '',  // DocumentNode cannot be serialized\n  variables: item.variables,\n  // ...\n}));\n"})}),"\n",(0,i.jsxs)(n.p,{children:["This means the in-memory ",(0,i.jsx)(n.code,{children:"mutation"})," reference (the ",(0,i.jsx)(n.code,{children:"DocumentNode"}),") is the live reference that ",(0,i.jsx)(n.code,{children:"replayAll"})," uses \u2014 it is not reconstructed from IndexedDB. On page reload, ",(0,i.jsx)(n.code,{children:"loadFromStorage"})," restores the metadata (variables, timestamps, retry counts) but sets ",(0,i.jsx)(n.code,{children:"mutation"})," to ",(0,i.jsx)(n.code,{children:"null"}),". The mutation AST must be re-registered by the caller after reload. In practice, the queue is typically used within a single session \u2014 reload events are rare in embedded container deployments."]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"full-integration-example",children:"Full Integration Example"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-tsx",children:"// apps/connect/src/main.tsx\nimport { apolloCache, initializeCachePersistence } from '@nasnet/api-client/core';\nimport { apolloClient } from '@nasnet/api-client/core';\nimport { setupAutoReplay, offlineQueue } from '@nasnet/api-client/core';\nimport { isOffline } from '@nasnet/api-client/core';\n\nasync function boot() {\n  // 1. Restore cache before first render\n  await initializeCachePersistence(apolloCache);\n\n  // 2. Start auto-replay when router becomes reachable\n  const stopAutoReplay = setupAutoReplay(apolloClient);\n\n  ReactDOM.createRoot(document.getElementById('root')!).render(\n    <ApolloProvider client={apolloClient}>\n      <App />\n    </ApolloProvider>\n  );\n\n  // 3. Flush error buffer on unload\n  window.addEventListener('beforeunload', flushErrorBuffer);\n\n  return () => stopAutoReplay();\n}\n\n// apps/connect/src/App.tsx\nfunction App() {\n  // 4. Start offline detection\n  useOfflineDetector();\n\n  return <RouterOutlet />;\n}\n\n// Feature component: enqueue mutation when offline\nfunction RenameRouter({ routerId }: { routerId: string }) {\n  const { mutate, isLoading } = useMutationWithLoading(UPDATE_ROUTER_NAME);\n\n  const handleSave = async (name: string) => {\n    if (isOffline()) {\n      // Queue for later, show optimistic UI\n      await offlineQueue.enqueue(UPDATE_ROUTER_NAME, { id: routerId, name });\n    } else {\n      await mutate({ id: routerId, name });\n    }\n  };\n\n  return <Button onClick={() => handleSave('NewName')} isLoading={isLoading}>Save</Button>;\n}\n"})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"custom-events",children:"Custom Events"}),"\n",(0,i.jsx)(n.p,{children:"The offline-first system coordinates via custom DOM events. Four event types flow through the system:"}),"\n",(0,i.jsxs)(n.h3,{id:"networkerror-event",children:[(0,i.jsx)(n.code,{children:"network:error"})," Event"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Dispatched by:"})," ",(0,i.jsx)(n.code,{children:"core/src/apollo/apollo-error-link.ts"})," when a network error occurs."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Listener:"})," ",(0,i.jsx)(n.code,{children:"setupOfflineDetector()"})," in ",(0,i.jsx)(n.code,{children:"offline-detector.ts"})]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"// Fired whenever Apollo reports a network error\nwindow.addEventListener('network:error', () => {\n  store().setRouterReachable(false);\n  store().incrementReconnectAttempts();\n});\n\n// Manually dispatch (rarely needed outside the error link):\nwindow.dispatchEvent(new CustomEvent('network:error', {\n  detail: { error: new Error('Connection failed') }\n}));\n"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Payload:"})," ",(0,i.jsx)(n.code,{children:"{ detail: { error: Error } }"})]}),"\n",(0,i.jsxs)(n.h3,{id:"wsconnected-event",children:[(0,i.jsx)(n.code,{children:"ws:connected"})," Event"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Dispatched by:"})," ",(0,i.jsx)(n.code,{children:"core/src/apollo/apollo-ws-client.ts"})," when WebSocket connects successfully."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Effect:"})," Sets router as both connected and reachable, resets reconnect attempts."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"window.addEventListener('ws:connected', () => {\n  store().setRouterConnected(true);\n  store().setRouterReachable(true);\n  store().resetReconnectAttempts();\n});\n"})}),"\n",(0,i.jsxs)(n.h3,{id:"wsclosed-event",children:[(0,i.jsx)(n.code,{children:"ws:closed"})," Event"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Dispatched by:"})," ",(0,i.jsx)(n.code,{children:"core/src/apollo/apollo-ws-client.ts"})," when WebSocket closes unexpectedly."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Effect:"})," Marks router as disconnected, increments reconnection attempts."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"window.addEventListener('ws:closed', () => {\n  store().setRouterConnected(false);\n  store().incrementReconnectAttempts();\n});\n"})}),"\n",(0,i.jsxs)(n.h3,{id:"wserror-event",children:[(0,i.jsx)(n.code,{children:"ws:error"})," Event"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Dispatched by:"})," ",(0,i.jsx)(n.code,{children:"core/src/apollo/apollo-ws-client.ts"})," when WebSocket encounters an error."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Effect:"})," Marks router as disconnected, increments reconnection attempts."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"window.addEventListener('ws:error', () => {\n  store().setRouterConnected(false);\n  store().incrementReconnectAttempts();\n});\n"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Payload:"})," ",(0,i.jsx)(n.code,{children:"{ detail: { code?: string, message?: string } }"})]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"imperative-connectivity-api",children:"Imperative Connectivity API"}),"\n",(0,i.jsx)(n.p,{children:"While hooks are the preferred way to use offline detection in React components, the imperative API allows checking connectivity outside the component tree (e.g., in data layer code, event handlers, or utility functions)."}),"\n",(0,i.jsx)(n.h3,{id:"isoffline",children:(0,i.jsx)(n.code,{children:"isOffline()"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"export function isOffline(): boolean\n// true if: !state.isOnline || !state.isRouterReachable\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Returns ",(0,i.jsx)(n.code,{children:"true"})," when the browser is offline (navigator.onLine = false) ",(0,i.jsx)(n.strong,{children:"or"})," the router is unreachable. Used to decide whether to queue mutations or reject operations."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Usage outside React:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"import { isOffline, offlineQueue } from '@nasnet/api-client/core';\n\nasync function submitForm(data) {\n  if (isOffline()) {\n    // Queue for later\n    await offlineQueue.enqueue(UPDATE_ROUTER, { ...data });\n    showToast('Changes will be saved when you're back online');\n  } else {\n    // Execute immediately\n    await apolloClient.mutate({ mutation: UPDATE_ROUTER, variables: data });\n  }\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"isdegraded",children:(0,i.jsx)(n.code,{children:"isDegraded()"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"export function isDegraded(): boolean\n// true if: state.isOnline && (!state.isRouterReachable || !state.isRouterConnected)\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Returns ",(0,i.jsx)(n.code,{children:"true"})," when the browser is online but either:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["The backend router is unreachable, ",(0,i.jsx)(n.strong,{children:"or"})]}),"\n",(0,i.jsx)(n.li,{children:"The WebSocket connection is down (but HTTP may still work)"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:'Used to show a "reconnecting" or "degraded" indicator in the UI while allowing some operations to continue.'}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Usage example:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"function StatusBar() {\n  const state = useNetworkStore();\n\n  if (!state.isOnline) {\n    return <OfflineIndicator />;  // Fully offline\n  }\n\n  if (isDegraded()) {\n    return <DegradedIndicator />;  // Browser online, server/WS unreachable\n  }\n\n  return <OnlineIndicator />;      // Fully connected\n}\n"})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"hook-vs-imperative-setup",children:"Hook vs. Imperative Setup"}),"\n",(0,i.jsxs)(n.h3,{id:"useofflinedetectorconfig--react-hook-preferred",children:[(0,i.jsx)(n.code,{children:"useOfflineDetector(config?)"})," \u2014 React Hook (Preferred)"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"When to use:"})," Component tree initialization, automatic cleanup on unmount."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Characteristics:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Auto-cleanup on component unmount"}),"\n",(0,i.jsxs)(n.li,{children:["Config dependency tracking via ",(0,i.jsx)(n.code,{children:"JSON.stringify"})]}),"\n",(0,i.jsx)(n.li,{children:"Integrates with React lifecycle"}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-tsx",children:"// Mount once at app root\nfunction App() {\n  useOfflineDetector({\n    healthCheckInterval: 15000,  // Custom interval\n  });\n\n  return <Router />;\n}\n// Cleanup automatic on unmount (unlikely in SPA, but correct practice)\n"})}),"\n",(0,i.jsxs)(n.h3,{id:"setupofflinedetectorconfig--imperative-setup",children:[(0,i.jsx)(n.code,{children:"setupOfflineDetector(config?)"})," \u2014 Imperative Setup"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"When to use:"})," Bootstrap code, non-React applications, custom cleanup."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Characteristics:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Manual cleanup via returned function"}),"\n",(0,i.jsx)(n.li,{children:"Can be called outside React"}),"\n",(0,i.jsx)(n.li,{children:"Useful in initialization scripts"}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"// In app bootstrap (before React)\nimport { setupOfflineDetector } from '@nasnet/api-client/core';\n\nconst cleanup = setupOfflineDetector({\n  healthCheckInterval: 30000,\n  healthEndpoint: '/api/health',\n});\n\n// Later, on app shutdown:\ncleanup();\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Comparison table:"})}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Aspect"}),(0,i.jsx)(n.th,{children:(0,i.jsx)(n.code,{children:"useOfflineDetector()"})}),(0,i.jsx)(n.th,{children:(0,i.jsx)(n.code,{children:"setupOfflineDetector()"})})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Where to call"}),(0,i.jsx)(n.td,{children:"Inside React component"}),(0,i.jsx)(n.td,{children:"Bootstrap code, top-level functions"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Cleanup"}),(0,i.jsx)(n.td,{children:"Automatic on unmount"}),(0,i.jsx)(n.td,{children:"Manual via returned function"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Dependencies"}),(0,i.jsxs)(n.td,{children:[(0,i.jsx)(n.code,{children:"config"})," serialized"]}),(0,i.jsx)(n.td,{children:"None (imperative)"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Best for"}),(0,i.jsx)(n.td,{children:"React apps (99% of cases)"}),(0,i.jsx)(n.td,{children:"Non-React code, custom lifecycle"})]})]})]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"health-check-configuration",children:"Health Check Configuration"}),"\n",(0,i.jsxs)(n.p,{children:["The offline detector polls the backend health endpoint at regular intervals to actively detect reachability. This is necessary because browser events (",(0,i.jsx)(n.code,{children:"online"}),", ",(0,i.jsx)(n.code,{children:"offline"}),") and passive error tracking are insufficient \u2014 a host can appear online but be unreachable."]}),"\n",(0,i.jsx)(n.h3,{id:"configuration-options",children:"Configuration Options"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"export interface OfflineDetectorConfig {\n  healthEndpoint?: string;         // Default: '/api/health'\n  healthCheckInterval?: number;    // Default: 30000 (30 seconds)\n  healthCheckTimeout?: number;     // Default: 5000 (5 seconds)\n}\n"})}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Setting"}),(0,i.jsx)(n.th,{children:"Default"}),(0,i.jsx)(n.th,{children:"Purpose"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"healthEndpoint"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"/api/health"})}),(0,i.jsx)(n.td,{children:"Backend endpoint to ping"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"healthCheckInterval"})}),(0,i.jsx)(n.td,{children:"30000 ms"}),(0,i.jsx)(n.td,{children:"How often to poll (30s = reasonable overhead)"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"healthCheckTimeout"})}),(0,i.jsx)(n.td,{children:"5000 ms"}),(0,i.jsx)(n.td,{children:"Max time to wait for health check response"})]})]})]}),"\n",(0,i.jsx)(n.h3,{id:"health-check-behavior",children:"Health Check Behavior"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Source:"})," ",(0,i.jsx)(n.code,{children:"core/src/apollo/offline-detector.ts:124\u2013155"})]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"async function performHealthCheck(): Promise<void> {\n  // Skip if browser reports offline (no point checking)\n  if (!navigator.onLine) {\n    return;\n  }\n\n  const controller = new AbortController();\n  const timeoutId = setTimeout(() => controller.abort(), healthCheckTimeout);\n\n  try {\n    const response = await fetch(healthEndpoint, {\n      method: 'GET',\n      signal: controller.signal,\n      redirect: 'error',  // Reject redirect (captive portals)\n    });\n\n    if (response.ok) {\n      store().setRouterReachable(true);\n      store().recordSuccessfulRequest();\n    } else {\n      store().setRouterReachable(false);\n      store().incrementReconnectAttempts();\n    }\n  } catch {\n    // Network error or timeout\n    store().setRouterReachable(false);\n    store().incrementReconnectAttempts();\n  } finally {\n    clearTimeout(timeoutId);\n  }\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Key details:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"redirect: 'error'"})," prevents captive portal redirects from being counted as success."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"AbortController"})," enforces the timeout; ",(0,i.jsx)(n.code,{children:"setTimeout(...).abort()"})," is more reliable than Promise-based timeouts."]}),"\n",(0,i.jsx)(n.li,{children:"Both response errors (non-ok status) and network errors (throw/timeout) mark the router as unreachable."}),"\n",(0,i.jsx)(n.li,{children:"Immediate health check fires when the browser comes back online before the next scheduled interval."}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"tuning-for-your-environment",children:"Tuning for Your Environment"}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Scenario"}),(0,i.jsx)(n.th,{children:"Config"}),(0,i.jsx)(n.th,{children:"Rationale"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Stable LAN"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"{ healthCheckInterval: 45000 }"})}),(0,i.jsx)(n.td,{children:"Less frequent polling, lower overhead"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Mobile / Unreliable"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"{ healthCheckInterval: 10000, healthCheckTimeout: 3000 }"})}),(0,i.jsx)(n.td,{children:"Fast detection of drops, quick timeout"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Slow backend"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"{ healthCheckTimeout: 10000 }"})}),(0,i.jsx)(n.td,{children:"Higher timeout for slow health check endpoint"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Custom endpoint"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"{ healthEndpoint: '/custom/health' }"})}),(0,i.jsx)(n.td,{children:"Route to your own health check"})]})]})]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"see-also",children:"See Also"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"./intro.md"})," \u2014 Library overview"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"./apollo-client.md"})," \u2014 Apollo cache configuration and type policies"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"./authentication.md"})," \u2014 Auth expiry integration with network error events"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"./error-handling.md"})," \u2014 How ",(0,i.jsx)(n.code,{children:"network:error"})," events feed the offline detector"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"./websocket-subscriptions.md"})," \u2014 WebSocket events that drive connectivity state"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"./universal-state-resource-model.md"})," \u2014 Cache key policies for resource types"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}}}]);