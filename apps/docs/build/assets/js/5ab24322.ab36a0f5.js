"use strict";(globalThis.webpackChunk_nas_net_docs=globalThis.webpackChunk_nas_net_docs||[]).push([[19138],{21236:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>h,frontMatter:()=>c,metadata:()=>s,toc:()=>o});const s=JSON.parse('{"id":"guides/testing","title":"Testing Strategy","description":"Comprehensive testing guide for state management in NasNet.","source":"@site/../../libs/state/docs/guides/testing.md","sourceDirName":"guides","slug":"/guides/testing","permalink":"/docs/state/guides/testing","draft":false,"unlisted":false,"editUrl":"https://github.com/nasnet-community/nasnet-panel/tree/main/../../libs/state/docs/guides/testing.md","tags":[],"version":"current","sidebarPosition":5,"frontMatter":{"sidebar_position":5,"title":"Testing Strategy"},"sidebar":"sidebar","previous":{"title":"Performance","permalink":"/docs/state/performance"},"next":{"title":"Adding a New XState Machine","permalink":"/docs/state/guides/adding-a-machine"}}');var i=n(31085),a=n(71184);const c={sidebar_position:5,title:"Testing Strategy"},r="Testing Zustand & XState",l={},o=[{value:"Overview",id:"overview",level:2},{value:"Test Setup",id:"test-setup",level:2},{value:"Zustand Store Reset Pattern",id:"zustand-store-reset-pattern",level:3},{value:"XState Machine Test Pattern",id:"xstate-machine-test-pattern",level:3},{value:"Testing Zustand Stores",id:"testing-zustand-stores",level:2},{value:"State Mutations",id:"state-mutations",level:3},{value:"Testing Selectors",id:"testing-selectors",level:3},{value:"Testing Persistence/Rehydration",id:"testing-persistencerehydration",level:3},{value:"Testing Async Operations",id:"testing-async-operations",level:3},{value:"Using store.setState() for Setup",id:"using-storesetstate-for-setup",level:3},{value:"Testing XState Machines",id:"testing-xstate-machines",level:2},{value:"Creating Test Actors",id:"creating-test-actors",level:3},{value:"Sending Events and Asserting States",id:"sending-events-and-asserting-states",level:3},{value:"Testing Guards and Actions",id:"testing-guards-and-actions",level:3},{value:"Testing Async Services",id:"testing-async-services",level:3},{value:"Testing Persistence",id:"testing-persistence",level:3},{value:"Mock Patterns",id:"mock-patterns",level:2},{value:"Mocking localStorage",id:"mocking-localstorage",level:3},{value:"Mocking Time",id:"mocking-time",level:3},{value:"Mocking Service Functions",id:"mocking-service-functions",level:3},{value:"Best Practices Checklist",id:"best-practices-checklist",level:2},{value:"Store Testing",id:"store-testing",level:3},{value:"Machine Testing",id:"machine-testing",level:3},{value:"General Testing",id:"general-testing",level:3},{value:"Common Testing Patterns",id:"common-testing-patterns",level:2},{value:"Testing Recovery/Retry",id:"testing-recoveryretry",level:3},{value:"Testing Backoff",id:"testing-backoff",level:3},{value:"Testing State Machines with Multiple Items",id:"testing-state-machines-with-multiple-items",level:3},{value:"Running Tests",id:"running-tests",level:2},{value:"Related Documentation",id:"related-documentation",level:2}];function d(e){const t={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",input:"input",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.header,{children:(0,i.jsx)(t.h1,{id:"testing-zustand--xstate",children:"Testing Zustand & XState"})}),"\n",(0,i.jsx)(t.p,{children:"Comprehensive testing guide for state management in NasNet."}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Source:"})," ",(0,i.jsx)(t.code,{children:"libs/state/stores/src/"})," and ",(0,i.jsx)(t.code,{children:"libs/state/machines/src/"})]}),"\n",(0,i.jsx)(t.h2,{id:"overview",children:"Overview"}),"\n",(0,i.jsx)(t.p,{children:"The state management library has extensive test coverage:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"22 store test files"})," across auth, connection, theme, and utility modules"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"4 major machine test suites"})," (wizard, config pipeline, change set, persistence)"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"800+ total test lines"})," covering state mutations, async operations, persistence, and edge cases"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Vitest framework"})," for fast, native ESM testing"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Zustand stores"})," and ",(0,i.jsx)(t.strong,{children:"XState machines"})," both tested thoroughly"]}),"\n"]}),"\n",(0,i.jsx)(t.h2,{id:"test-setup",children:"Test Setup"}),"\n",(0,i.jsx)(t.h3,{id:"zustand-store-reset-pattern",children:"Zustand Store Reset Pattern"}),"\n",(0,i.jsx)(t.p,{children:"Zustand stores persist to localStorage by default. Every test suite must reset store state:"}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Source:"})," ",(0,i.jsx)(t.code,{children:"libs/state/stores/src/test-setup.ts"})]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-typescript",children:"import { beforeEach, afterEach, vi } from 'vitest';\n\ndescribe('useAuthStore', () => {\n  beforeEach(() => {\n    // Clear localStorage before each test\n    localStorage.clear();\n    // Reset store state to initial values\n    useAuthStore.setState({\n      token: null,\n      tokenExpiry: null,\n      refreshToken: null,\n      user: null,\n      isAuthenticated: false,\n      isRefreshing: false,\n      refreshAttempts: 0,\n      lastActivity: null,\n    });\n  });\n\n  afterEach(() => {\n    vi.useRealTimers();  // Reset fake timers if used\n  });\n});\n"})}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.strong,{children:"Why this matters:"})}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"Store state is global and persistent across tests"}),"\n",(0,i.jsx)(t.li,{children:"localStorage carries over between tests without reset"}),"\n",(0,i.jsx)(t.li,{children:"Fake timers must be restored to prevent test interference"}),"\n",(0,i.jsx)(t.li,{children:"Each test must start with a clean slate"}),"\n"]}),"\n",(0,i.jsx)(t.h3,{id:"xstate-machine-test-pattern",children:"XState Machine Test Pattern"}),"\n",(0,i.jsxs)(t.p,{children:["XState tests use ",(0,i.jsx)(t.code,{children:"createActor"})," to instantiate and control machines:"]}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Source:"})," ",(0,i.jsx)(t.code,{children:"libs/state/machines/src/test-setup.ts"})]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-typescript",children:"import { beforeEach, afterEach, vi } from 'vitest';\n\nbeforeEach(() => {\n  // Mock localStorage for persistence tests\n  localStorage.clear();\n  vi.clearAllMocks();\n});\n\nafterEach(() => {\n  vi.restoreAllMocks();\n});\n"})}),"\n",(0,i.jsx)(t.h2,{id:"testing-zustand-stores",children:"Testing Zustand Stores"}),"\n",(0,i.jsx)(t.h3,{id:"state-mutations",children:"State Mutations"}),"\n",(0,i.jsx)(t.p,{children:"Test that actions properly update state:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-typescript",children:"// Source: libs/state/stores/src/auth/auth.store.test.ts\ndescribe('setAuth', () => {\n  it('should set tokens and mark as authenticated', () => {\n    const { setAuth } = useAuthStore.getState();\n    const user = { id: '1', username: 'test', email: 'test@example.com', permissions: [] };\n    const expiresAt = new Date(Date.now() + 3600 * 1000);\n\n    setAuth('access-token', user, expiresAt, 'refresh-token');\n\n    const state = useAuthStore.getState();\n    expect(state.token).toBe('access-token');\n    expect(state.isAuthenticated).toBe(true);\n    expect(state.user).toEqual(user);\n  });\n\n  it('should reset refresh attempts when setting tokens', () => {\n    useAuthStore.setState({ refreshAttempts: 5 });\n\n    const { setAuth } = useAuthStore.getState();\n    const user = { id: '1', username: 'test', email: 'test@example.com', permissions: [] };\n    setAuth('new-token', user, new Date(Date.now() + 3600000), 'new-refresh');\n\n    expect(useAuthStore.getState().refreshAttempts).toBe(0);\n  });\n});\n"})}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.strong,{children:"Key patterns:"})}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["Use ",(0,i.jsx)(t.code,{children:"useAuthStore.getState()"})," to get current state"]}),"\n",(0,i.jsxs)(t.li,{children:["Call actions through ",(0,i.jsx)(t.code,{children:"getState()"})," actions"]}),"\n",(0,i.jsx)(t.li,{children:"Assert state changes immediately"}),"\n",(0,i.jsx)(t.li,{children:"Test both happy path and side effects"}),"\n"]}),"\n",(0,i.jsx)(t.h3,{id:"testing-selectors",children:"Testing Selectors"}),"\n",(0,i.jsx)(t.p,{children:"Zustand selectors optimize re-renders by selecting specific fields:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-typescript",children:"// Test selector returns correct value\nconst token = useAuthStore((state) => state.token);\nexpect(token).toBe(expectedToken);\n\n// Test combined selector\nconst { token, isAuthenticated } = useAuthStore((state) => ({\n  token: state.token,\n  isAuthenticated: state.isAuthenticated,\n}));\n"})}),"\n",(0,i.jsx)(t.h3,{id:"testing-persistencerehydration",children:"Testing Persistence/Rehydration"}),"\n",(0,i.jsx)(t.p,{children:"Zustand stores persist to localStorage. Test the full cycle:"}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Source:"})," ",(0,i.jsx)(t.code,{children:"libs/state/stores/src/auth/auth.store.test.ts"})]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-typescript",children:"describe('Persistence', () => {\n  it('should persist auth state to localStorage', () => {\n    const { setAuth } = useAuthStore.getState();\n    const user = { id: '1', username: 'test', email: null, permissions: ['admin'] };\n\n    setAuth('access-token', user, new Date(Date.now() + 3600 * 1000), 'refresh-token');\n\n    const stored = localStorage.getItem('auth-storage');\n    expect(stored).toBeTruthy();\n\n    const data = JSON.parse(stored!);\n    expect(data.state.token).toBe('access-token');\n    expect(data.state.user.username).toBe('test');\n  });\n\n  it('should serialize Date objects correctly', () => {\n    const { setAuth } = useAuthStore.getState();\n    const user = { id: '1', username: 'test', email: null, permissions: [] };\n    const expiresAt = new Date('2024-01-01T13:00:00Z');\n\n    setAuth('access-token', user, expiresAt, 'refresh-token');\n\n    const stored = localStorage.getItem('auth-storage');\n    const data = JSON.parse(stored!);\n\n    // Check that Date was serialized as ISO string\n    expect(typeof data.state.tokenExpiry).toBe('string');\n    expect(data.state.tokenExpiry).toContain('2024-01-01');\n  });\n\n  it('should NOT persist temporary state', () => {\n    useAuthStore.setState({ isRefreshing: true });\n\n    const stored = localStorage.getItem('auth-storage');\n    if (stored) {\n      const data = JSON.parse(stored);\n      // isRefreshing should be filtered by partialize function\n      expect(data.state.isRefreshing).toBeUndefined();\n    }\n  });\n});\n"})}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.strong,{children:"Key patterns:"})}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"Test persistence to localStorage (check key and format)"}),"\n",(0,i.jsx)(t.li,{children:"Test date serialization (ISO strings in JSON)"}),"\n",(0,i.jsxs)(t.li,{children:["Test ",(0,i.jsx)(t.code,{children:"partialize"})," function filters sensitive fields"]}),"\n",(0,i.jsx)(t.li,{children:"Verify rehydration format matches store schema"}),"\n"]}),"\n",(0,i.jsx)(t.h3,{id:"testing-async-operations",children:"Testing Async Operations"}),"\n",(0,i.jsxs)(t.p,{children:["Use ",(0,i.jsx)(t.code,{children:"vi.useFakeTimers()"})," for time-dependent tests:"]}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Source:"})," ",(0,i.jsx)(t.code,{children:"libs/state/stores/src/auth/auth.store.test.ts"})]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-typescript",children:"describe('Token Expiry Helpers', () => {\n  beforeEach(() => {\n    vi.useFakeTimers();\n  });\n\n  it('isTokenExpiringSoon should return true within threshold', () => {\n    const now = new Date('2024-01-01T12:00:00Z');\n    vi.setSystemTime(now);\n\n    useAuthStore.setState({\n      tokenExpiry: new Date(now.getTime() + 2 * 60 * 1000),  // expires in 2 min\n      isAuthenticated: true,\n    });\n\n    const { isTokenExpiringSoon } = useAuthStore.getState();\n    expect(isTokenExpiringSoon()).toBe(true);  // Within 5-minute default threshold\n  });\n\n  it('getTimeUntilExpiry should return milliseconds remaining', () => {\n    const now = new Date('2024-01-01T12:00:00Z');\n    vi.setSystemTime(now);\n\n    const expiresInMs = 30 * 60 * 1000;  // 30 minutes\n    useAuthStore.setState({\n      tokenExpiry: new Date(now.getTime() + expiresInMs),\n      isAuthenticated: true,\n    });\n\n    const { getTimeUntilExpiry } = useAuthStore.getState();\n    const timeLeft = getTimeUntilExpiry();\n    expect(timeLeft).toBeGreaterThan(0);\n    expect(timeLeft).toBeLessThanOrEqual(expiresInMs);\n  });\n});\n"})}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.strong,{children:"Key patterns:"})}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["Use ",(0,i.jsx)(t.code,{children:"vi.useFakeTimers()"})," to control time"]}),"\n",(0,i.jsxs)(t.li,{children:["Set system time with ",(0,i.jsx)(t.code,{children:"vi.setSystemTime()"})]}),"\n",(0,i.jsxs)(t.li,{children:["Advance time with ",(0,i.jsx)(t.code,{children:"vi.advanceTimersByTime(ms)"})]}),"\n",(0,i.jsxs)(t.li,{children:["Always call ",(0,i.jsx)(t.code,{children:"vi.useRealTimers()"})," in afterEach"]}),"\n",(0,i.jsx)(t.li,{children:"Test edge cases (expired, expiring, valid)"}),"\n"]}),"\n",(0,i.jsx)(t.h3,{id:"using-storesetstate-for-setup",children:"Using store.setState() for Setup"}),"\n",(0,i.jsxs)(t.p,{children:["For complex test setup, use ",(0,i.jsx)(t.code,{children:"setState()"})," directly:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-typescript",children:"// Set up complex state for test\nuseConnectionStore.setState({\n  wsStatus: 'connecting',\n  isReconnecting: true,\n  reconnectAttempts: 2,\n  activeRouterId: 'router-1',\n  routers: {\n    'router-1': {\n      status: 'connecting',\n      protocol: 'api',\n      latencyMs: 150,\n    },\n  },\n});\n\n// Now test behavior from that state\nconst { hasExceededMaxAttempts } = useConnectionStore.getState();\nexpect(hasExceededMaxAttempts()).toBe(false);  // Under limit\n"})}),"\n",(0,i.jsx)(t.h2,{id:"testing-xstate-machines",children:"Testing XState Machines"}),"\n",(0,i.jsx)(t.h3,{id:"creating-test-actors",children:"Creating Test Actors"}),"\n",(0,i.jsx)(t.p,{children:"Create actors from machines for testing state transitions:"}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Source:"})," ",(0,i.jsx)(t.code,{children:"libs/state/machines/src/__tests__/wizardMachine.test.ts"})]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-typescript",children:"import { createActor } from 'xstate';\nimport { createWizardMachine } from '../wizardMachine';\n\ndescribe('Wizard Machine', () => {\n  it('should start at step 1', () => {\n    const machine = createWizardMachine<TestData>({\n      id: 'test-wizard',\n      totalSteps: 3,\n      validateStep: async () => ({ valid: true }),\n      onSubmit: async () => {},\n    });\n\n    const actor = createActor(machine, {});\n    actor.start();\n\n    expect(actor.getSnapshot().context.currentStep).toBe(1);\n    expect(actor.getSnapshot().matches('step')).toBe(true);\n  });\n});\n"})}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.strong,{children:"Key patterns:"})}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["Call ",(0,i.jsx)(t.code,{children:"createActor(machine, {})"})," to create instance"]}),"\n",(0,i.jsxs)(t.li,{children:["Call ",(0,i.jsx)(t.code,{children:"actor.start()"})," to begin state machine"]}),"\n",(0,i.jsxs)(t.li,{children:["Use ",(0,i.jsx)(t.code,{children:"actor.getSnapshot()"})," to inspect current state"]}),"\n",(0,i.jsxs)(t.li,{children:["Check ",(0,i.jsx)(t.code,{children:"snapshot.value"})," for state name"]}),"\n",(0,i.jsxs)(t.li,{children:["Check ",(0,i.jsx)(t.code,{children:"snapshot.context"})," for data"]}),"\n",(0,i.jsxs)(t.li,{children:["Check ",(0,i.jsx)(t.code,{children:"snapshot.matches('state')"})," for state matching"]}),"\n",(0,i.jsxs)(t.li,{children:["Call ",(0,i.jsx)(t.code,{children:"actor.stop()"})," in cleanup"]}),"\n"]}),"\n",(0,i.jsx)(t.h3,{id:"sending-events-and-asserting-states",children:"Sending Events and Asserting States"}),"\n",(0,i.jsx)(t.p,{children:"Test transitions by sending events and checking resulting state:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-typescript",children:"it('should go back from step 2 to step 1', async () => {\n  const machine = createWizardMachine<TestData>({\n    id: 'test',\n    totalSteps: 3,\n    validateStep: async () => ({ valid: true }),\n    onSubmit: async () => {},\n  });\n\n  const actor = createActor(machine, {});\n  actor.start();\n\n  // Advance to step 2\n  actor.send({ type: 'NEXT', data: { name: 'Test' } });\n\n  // Wait for async validation\n  await new Promise((resolve) => setTimeout(resolve, 10));\n\n  // Go back\n  actor.send({ type: 'BACK' });\n\n  expect(actor.getSnapshot().context.currentStep).toBe(1);\n});\n"})}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.strong,{children:"Key patterns:"})}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["Send events with ",(0,i.jsx)(t.code,{children:"actor.send({ type: 'EVENT_NAME', ... })"})]}),"\n",(0,i.jsxs)(t.li,{children:["Wait for async operations: ",(0,i.jsx)(t.code,{children:"await new Promise(resolve => setTimeout(resolve, ms))"})]}),"\n",(0,i.jsxs)(t.li,{children:["Use ",(0,i.jsx)(t.code,{children:"vi.waitFor()"})," for better async handling"]}),"\n",(0,i.jsx)(t.li,{children:"Assert state after transitions"}),"\n",(0,i.jsx)(t.li,{children:"Test error cases and edge conditions"}),"\n"]}),"\n",(0,i.jsx)(t.h3,{id:"testing-guards-and-actions",children:"Testing Guards and Actions"}),"\n",(0,i.jsx)(t.p,{children:"Test conditional transitions with guards:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-typescript",children:"it('should prevent going back from step 1', () => {\n  const actor = createActor(machine, {});\n  actor.start();\n\n  actor.send({ type: 'BACK' });\n\n  // Still on step 1 (BACK guard prevents transition)\n  expect(actor.getSnapshot().context.currentStep).toBe(1);\n});\n\nit('should advance step on successful validation', async () => {\n  const validateStep = vi.fn().mockResolvedValue({ valid: true });\n  const machine = createWizardMachine<TestData>({\n    id: 'test',\n    totalSteps: 3,\n    validateStep,\n    onSubmit: async () => {},\n  });\n\n  const actor = createActor(machine, {});\n  actor.start();\n\n  actor.send({ type: 'NEXT', data: { name: 'Test' } });\n\n  await new Promise((resolve) => setTimeout(resolve, 50));\n\n  // Should have advanced\n  expect(actor.getSnapshot().context.currentStep).toBe(2);\n  expect(validateStep).toHaveBeenCalledWith(1, { name: 'Test' });\n});\n"})}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.strong,{children:"Key patterns:"})}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"Guards prevent unwanted transitions"}),"\n",(0,i.jsx)(t.li,{children:"Actions modify context during transitions"}),"\n",(0,i.jsxs)(t.li,{children:["Mock service calls with ",(0,i.jsx)(t.code,{children:"vi.fn()"})]}),"\n",(0,i.jsx)(t.li,{children:"Assert action was called with correct arguments"}),"\n",(0,i.jsx)(t.li,{children:"Test both valid and invalid paths"}),"\n"]}),"\n",(0,i.jsx)(t.h3,{id:"testing-async-services",children:"Testing Async Services"}),"\n",(0,i.jsx)(t.p,{children:"Test machines with async operations (validation, API calls):"}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Source:"})," ",(0,i.jsx)(t.code,{children:"libs/state/machines/src/__tests__/changeSetMachine.test.ts"})]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-typescript",children:"it('should transition to ready on successful validation', async () => {\n  const validateFn = vi.fn().mockResolvedValue({\n    canApply: true,\n    errors: [],\n    warnings: [],\n    conflicts: [],\n    missingDependencies: [],\n    circularDependencies: null,\n  });\n\n  const config = {\n    validateChangeSet: validateFn,\n    applyItem: vi.fn().mockResolvedValue({\n      confirmedState: { id: 'created-id' },\n      resourceUuid: 'uuid-123',\n    }),\n    rollbackItem: vi.fn().mockResolvedValue(undefined),\n    onValidationComplete: vi.fn(),\n    onProgress: vi.fn(),\n    onComplete: vi.fn(),\n    onFailed: vi.fn(),\n    onRolledBack: vi.fn(),\n  };\n\n  const machine = createChangeSetMachine(config);\n  const actor = createActor(machine, {});\n\n  actor.start();\n  actor.send({ type: 'LOAD', changeSet, routerId: 'router-1' });\n  actor.send({ type: 'START_VALIDATION' });\n\n  // Wait for validation to complete\n  await vi.waitFor(() => {\n    expect(actor.getSnapshot().value).toBe('ready');\n  });\n\n  expect(actor.getSnapshot().context.validationResult?.canApply).toBe(true);\n});\n"})}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.strong,{children:"Key patterns:"})}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["Mock service functions with ",(0,i.jsx)(t.code,{children:"vi.fn()"})]}),"\n",(0,i.jsxs)(t.li,{children:["Use ",(0,i.jsx)(t.code,{children:"mockResolvedValue()"})," for successful async"]}),"\n",(0,i.jsxs)(t.li,{children:["Use ",(0,i.jsx)(t.code,{children:"mockRejectedValue()"})," for errors"]}),"\n",(0,i.jsxs)(t.li,{children:["Use ",(0,i.jsx)(t.code,{children:"vi.waitFor()"})," to wait for async completion"]}),"\n",(0,i.jsx)(t.li,{children:"Assert final state after async operation completes"}),"\n",(0,i.jsx)(t.li,{children:"Test error paths with rejection"}),"\n"]}),"\n",(0,i.jsx)(t.h3,{id:"testing-persistence",children:"Testing Persistence"}),"\n",(0,i.jsx)(t.p,{children:"Test machine state persistence and restoration:"}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Source:"})," ",(0,i.jsx)(t.code,{children:"libs/state/machines/src/__tests__/persistence.test.ts"})]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-typescript",children:"describe('persistMachineState', () => {\n  it('should save state to localStorage', () => {\n    const context = { step: 1, data: { name: 'Test' } };\n\n    persistMachineState('test-machine', 'step', context);\n\n    const stored = localStorage.getItem(`${STORAGE_KEY_PREFIX}test-machine`);\n    expect(stored).toBeDefined();\n    expect(JSON.parse(stored!)).toMatchObject({\n      state: 'step',\n      context,\n      machineId: 'test-machine',\n    });\n  });\n\n  it('should include timestamp', () => {\n    persistMachineState('test-machine', 'step', { data: {} });\n\n    const stored = JSON.parse(localStorage.getItem(`${STORAGE_KEY_PREFIX}test-machine`)!);\n    expect(stored.timestamp).toBeDefined();\n    expect(typeof stored.timestamp).toBe('number');\n  });\n\n  it('should restore saved state', () => {\n    const context = { step: 2, data: { name: 'Test' } };\n    persistMachineState('test-machine', 'validating', context);\n\n    const restored = restoreMachineState('test-machine');\n\n    expect(restored).toBeDefined();\n    expect(restored?.context).toEqual(context);\n    expect(restored?.state).toBe('validating');\n  });\n\n  it('should return null for stale sessions', () => {\n    const oldData = {\n      state: 'step',\n      context: {},\n      timestamp: Date.now() - SESSION_TIMEOUT_MS - 1000,\n      machineId: 'old-machine',\n    };\n    localStorage.setItem(`${STORAGE_KEY_PREFIX}old-machine`, JSON.stringify(oldData));\n\n    const restored = restoreMachineState('old-machine');\n\n    expect(restored).toBeNull();\n  });\n});\n"})}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.strong,{children:"Key patterns:"})}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"Test save/restore cycle"}),"\n",(0,i.jsx)(t.li,{children:"Verify localStorage format (key, structure)"}),"\n",(0,i.jsx)(t.li,{children:"Test timestamp handling"}),"\n",(0,i.jsx)(t.li,{children:"Test session expiry (stale session cleanup)"}),"\n",(0,i.jsx)(t.li,{children:"Test corruption recovery"}),"\n"]}),"\n",(0,i.jsx)(t.h2,{id:"mock-patterns",children:"Mock Patterns"}),"\n",(0,i.jsx)(t.h3,{id:"mocking-localstorage",children:"Mocking localStorage"}),"\n",(0,i.jsx)(t.p,{children:"Most tests need localStorage mocks. Test setup file provides this:"}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Source:"})," ",(0,i.jsx)(t.code,{children:"libs/state/machines/src/test-setup.ts"})]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-typescript",children:"const localStorageMock = (() => {\n  let store: Record<string, string> = {};\n  return {\n    getItem: vi.fn((key: string) => store[key] || null),\n    setItem: vi.fn((key: string, value: string) => {\n      store[key] = value;\n    }),\n    removeItem: vi.fn((key: string) => {\n      delete store[key];\n    }),\n    clear: vi.fn(() => {\n      store = {};\n    }),\n    get length() {\n      return Object.keys(store).length;\n    },\n    key: vi.fn((index: number) => Object.keys(store)[index] || null),\n  };\n})();\n\nObject.defineProperty(window, 'localStorage', {\n  value: localStorageMock,\n});\n"})}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.strong,{children:"Usage in tests:"})}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-typescript",children:"beforeEach(() => {\n  localStorageMock.clear();\n});\n\nit('test', () => {\n  const value = localStorage.getItem('key');\n  expect(value).toBeTruthy();\n});\n"})}),"\n",(0,i.jsx)(t.h3,{id:"mocking-time",children:"Mocking Time"}),"\n",(0,i.jsx)(t.p,{children:"For time-dependent logic, use fake timers:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-typescript",children:"beforeEach(() => {\n  vi.useFakeTimers();\n});\n\nafterEach(() => {\n  vi.useRealTimers();\n});\n\nit('should handle time-based expiry', () => {\n  const now = new Date('2024-01-01T12:00:00Z');\n  vi.setSystemTime(now);\n\n  // Test time-dependent logic\n  const expiry = new Date(now.getTime() + 5000);\n  expect(expiry.getTime()).toBeGreaterThan(now.getTime());\n\n  // Advance time\n  vi.advanceTimersByTime(3000);\n  expect(Date.now()).toBe(now.getTime() + 3000);\n});\n"})}),"\n",(0,i.jsx)(t.h3,{id:"mocking-service-functions",children:"Mocking Service Functions"}),"\n",(0,i.jsx)(t.p,{children:"Mock async operations in tests:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-typescript",children:"const validateStep = vi.fn()\n  .mockResolvedValueOnce({ valid: true })\n  .mockRejectedValueOnce(new Error('Network error'));\n\nconst result1 = await validateStep(1, data);\nexpect(result1.valid).toBe(true);\n\nconst result2 = await validateStep(1, data);\n// throws Error: Network error\n"})}),"\n",(0,i.jsx)(t.h2,{id:"best-practices-checklist",children:"Best Practices Checklist"}),"\n",(0,i.jsx)(t.h3,{id:"store-testing",children:"Store Testing"}),"\n",(0,i.jsxs)(t.ul,{className:"contains-task-list",children:["\n",(0,i.jsxs)(t.li,{className:"task-list-item",children:[(0,i.jsx)(t.input,{type:"checkbox",disabled:!0})," ","Reset store state in ",(0,i.jsx)(t.code,{children:"beforeEach"})]}),"\n",(0,i.jsxs)(t.li,{className:"task-list-item",children:[(0,i.jsx)(t.input,{type:"checkbox",disabled:!0})," ","Clear localStorage in ",(0,i.jsx)(t.code,{children:"beforeEach"})]}),"\n",(0,i.jsxs)(t.li,{className:"task-list-item",children:[(0,i.jsx)(t.input,{type:"checkbox",disabled:!0})," ","Test state mutations independently"]}),"\n",(0,i.jsxs)(t.li,{className:"task-list-item",children:[(0,i.jsx)(t.input,{type:"checkbox",disabled:!0})," ","Test persistence to localStorage"]}),"\n",(0,i.jsxs)(t.li,{className:"task-list-item",children:[(0,i.jsx)(t.input,{type:"checkbox",disabled:!0})," ","Test Date serialization correctly"]}),"\n",(0,i.jsxs)(t.li,{className:"task-list-item",children:[(0,i.jsx)(t.input,{type:"checkbox",disabled:!0})," ","Test async operations with fake timers"]}),"\n",(0,i.jsxs)(t.li,{className:"task-list-item",children:[(0,i.jsx)(t.input,{type:"checkbox",disabled:!0})," ","Use ",(0,i.jsx)(t.code,{children:"getState()"})," to read current state"]}),"\n",(0,i.jsxs)(t.li,{className:"task-list-item",children:[(0,i.jsx)(t.input,{type:"checkbox",disabled:!0})," ","Call actions through state, not directly"]}),"\n",(0,i.jsxs)(t.li,{className:"task-list-item",children:[(0,i.jsx)(t.input,{type:"checkbox",disabled:!0})," ","Verify ",(0,i.jsx)(t.code,{children:"partialize"})," filters sensitive fields"]}),"\n",(0,i.jsxs)(t.li,{className:"task-list-item",children:[(0,i.jsx)(t.input,{type:"checkbox",disabled:!0})," ","Test error handling in async actions"]}),"\n"]}),"\n",(0,i.jsx)(t.h3,{id:"machine-testing",children:"Machine Testing"}),"\n",(0,i.jsxs)(t.ul,{className:"contains-task-list",children:["\n",(0,i.jsxs)(t.li,{className:"task-list-item",children:[(0,i.jsx)(t.input,{type:"checkbox",disabled:!0})," ","Create actor from machine"]}),"\n",(0,i.jsxs)(t.li,{className:"task-list-item",children:[(0,i.jsx)(t.input,{type:"checkbox",disabled:!0})," ","Call ",(0,i.jsx)(t.code,{children:"actor.start()"})," before sending events"]}),"\n",(0,i.jsxs)(t.li,{className:"task-list-item",children:[(0,i.jsx)(t.input,{type:"checkbox",disabled:!0})," ","Call ",(0,i.jsx)(t.code,{children:"actor.stop()"})," in cleanup"]}),"\n",(0,i.jsxs)(t.li,{className:"task-list-item",children:[(0,i.jsx)(t.input,{type:"checkbox",disabled:!0})," ","Use ",(0,i.jsx)(t.code,{children:"getSnapshot()"})," for current state"]}),"\n",(0,i.jsxs)(t.li,{className:"task-list-item",children:[(0,i.jsx)(t.input,{type:"checkbox",disabled:!0})," ","Wait for async operations with ",(0,i.jsx)(t.code,{children:"vi.waitFor()"})]}),"\n",(0,i.jsxs)(t.li,{className:"task-list-item",children:[(0,i.jsx)(t.input,{type:"checkbox",disabled:!0})," ","Test guards prevent unwanted transitions"]}),"\n",(0,i.jsxs)(t.li,{className:"task-list-item",children:[(0,i.jsx)(t.input,{type:"checkbox",disabled:!0})," ","Test actions modify context correctly"]}),"\n",(0,i.jsxs)(t.li,{className:"task-list-item",children:[(0,i.jsx)(t.input,{type:"checkbox",disabled:!0})," ","Mock service functions with ",(0,i.jsx)(t.code,{children:"vi.fn()"})]}),"\n",(0,i.jsxs)(t.li,{className:"task-list-item",children:[(0,i.jsx)(t.input,{type:"checkbox",disabled:!0})," ","Test error paths and rollback scenarios"]}),"\n",(0,i.jsxs)(t.li,{className:"task-list-item",children:[(0,i.jsx)(t.input,{type:"checkbox",disabled:!0})," ","Test persistence and restoration cycle"]}),"\n"]}),"\n",(0,i.jsx)(t.h3,{id:"general-testing",children:"General Testing"}),"\n",(0,i.jsxs)(t.ul,{className:"contains-task-list",children:["\n",(0,i.jsxs)(t.li,{className:"task-list-item",children:[(0,i.jsx)(t.input,{type:"checkbox",disabled:!0})," ","Reset mocks in ",(0,i.jsx)(t.code,{children:"afterEach"})]}),"\n",(0,i.jsxs)(t.li,{className:"task-list-item",children:[(0,i.jsx)(t.input,{type:"checkbox",disabled:!0})," ","Use ",(0,i.jsx)(t.code,{children:"vi.useFakeTimers()"})," and ",(0,i.jsx)(t.code,{children:"vi.useRealTimers()"})]}),"\n",(0,i.jsxs)(t.li,{className:"task-list-item",children:[(0,i.jsx)(t.input,{type:"checkbox",disabled:!0})," ","Mock localStorage in test-setup"]}),"\n",(0,i.jsxs)(t.li,{className:"task-list-item",children:[(0,i.jsx)(t.input,{type:"checkbox",disabled:!0})," ","Test both happy path and error cases"]}),"\n",(0,i.jsxs)(t.li,{className:"task-list-item",children:[(0,i.jsx)(t.input,{type:"checkbox",disabled:!0})," ","Test edge conditions (empty, null, invalid)"]}),"\n",(0,i.jsxs)(t.li,{className:"task-list-item",children:[(0,i.jsx)(t.input,{type:"checkbox",disabled:!0})," ","Verify callbacks are called with correct args"]}),"\n",(0,i.jsxs)(t.li,{className:"task-list-item",children:[(0,i.jsx)(t.input,{type:"checkbox",disabled:!0})," ","Use clear, descriptive test names"]}),"\n",(0,i.jsxs)(t.li,{className:"task-list-item",children:[(0,i.jsx)(t.input,{type:"checkbox",disabled:!0})," ","Keep test functions focused and small"]}),"\n",(0,i.jsxs)(t.li,{className:"task-list-item",children:[(0,i.jsx)(t.input,{type:"checkbox",disabled:!0})," ","Test public API, not implementation details"]}),"\n",(0,i.jsxs)(t.li,{className:"task-list-item",children:[(0,i.jsx)(t.input,{type:"checkbox",disabled:!0})," ","Comment on non-obvious test logic"]}),"\n"]}),"\n",(0,i.jsx)(t.h2,{id:"common-testing-patterns",children:"Common Testing Patterns"}),"\n",(0,i.jsx)(t.h3,{id:"testing-recoveryretry",children:"Testing Recovery/Retry"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-typescript",children:"it('should retry on failure and succeed', async () => {\n  const operation = vi\n    .fn()\n    .mockRejectedValueOnce(new Error('Network error'))\n    .mockResolvedValueOnce('success');\n\n  const result = await withRetry(operation, { maxRetries: 2 });\n\n  expect(result.success).toBe(true);\n  expect(result.data).toBe('success');\n  expect(operation).toHaveBeenCalledTimes(2);\n});\n"})}),"\n",(0,i.jsx)(t.h3,{id:"testing-backoff",children:"Testing Backoff"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-typescript",children:"it('should apply exponential backoff', () => {\n  const backoff0 = calculateBackoff(0);\n  const backoff1 = calculateBackoff(1);\n  const backoff2 = calculateBackoff(2);\n\n  // Each should be roughly double (with jitter)\n  expect(backoff1).toBeGreaterThan(backoff0 * 0.8);\n  expect(backoff2).toBeGreaterThan(backoff1 * 0.8);\n});\n"})}),"\n",(0,i.jsx)(t.h3,{id:"testing-state-machines-with-multiple-items",children:"Testing State Machines with Multiple Items"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-typescript",children:"it('should apply items in order and rollback on error', async () => {\n  const applyFn = vi\n    .fn()\n    .mockResolvedValueOnce({ confirmedState: {}, resourceUuid: 'uuid-1' })\n    .mockRejectedValueOnce(new Error('Second item failed'));\n\n  const changeSet = createChangeSet({\n    items: [\n      { id: 'item-1', name: 'First' },\n      { id: 'item-2', name: 'Second' },\n    ],\n  });\n\n  // ... test that first item succeeded, then rollback happens\n});\n"})}),"\n",(0,i.jsx)(t.h2,{id:"running-tests",children:"Running Tests"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-bash",children:"# Run all tests\nnpm test\n\n# Run specific file\nnpm test -- auth.store.test.ts\n\n# Watch mode\nnpm test -- --watch\n\n# Coverage\nnpm test -- --coverage\n"})}),"\n",(0,i.jsx)(t.h2,{id:"related-documentation",children:"Related Documentation"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Debugging:"})," See ",(0,i.jsx)(t.code,{children:"debugging.md"})," for state inspection techniques"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Persistence:"})," Explore ",(0,i.jsx)(t.code,{children:"libs/state/docs/machines/persistence.md"})," for session recovery"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Machines:"})," See individual machine docs (wizard.md, config-pipeline.md, etc.)"]}),"\n"]})]})}function h(e={}){const{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},71184:(e,t,n)=>{n.d(t,{R:()=>c,x:()=>r});var s=n(14041);const i={},a=s.createContext(i);function c(e){const t=s.useContext(a);return s.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:c(e.components),s.createElement(a.Provider,{value:t},e.children)}}}]);