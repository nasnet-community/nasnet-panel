"use strict";(globalThis.webpackChunk_nas_net_docs=globalThis.webpackChunk_nas_net_docs||[]).push([[51588],{35946:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>s,contentTitle:()=>o,default:()=>h,frontMatter:()=>l,metadata:()=>r,toc:()=>a});const r=JSON.parse('{"id":"flows/router-connection-flow","title":"Flow: Router Connection Establishment","description":"Traces how the backend connects to a MikroTik router, automatically selecting the best available protocol with circuit-breaker protection.","source":"@site/../backend/docs/flows/router-connection-flow.md","sourceDirName":"flows","slug":"/flows/router-connection-flow","permalink":"/docs/backend/flows/router-connection-flow","draft":false,"unlisted":false,"editUrl":"https://github.com/nasnet-community/nasnet-panel/tree/main/../backend/docs/flows/router-connection-flow.md","tags":[],"version":"current","frontMatter":{},"sidebar":"sidebar","previous":{"title":"Flow: GraphQL Request Lifecycle","permalink":"/docs/backend/flows/graphql-request-lifecycle"},"next":{"title":"Flow: Service Installation","permalink":"/docs/backend/flows/service-installation-flow"}}');var c=t(31085),i=t(71184);const l={},o="Flow: Router Connection Establishment",s={},a=[{value:"Overview",id:"overview",level:2},{value:"Sequence Diagram (Success Path)",id:"sequence-diagram-success-path",level:2},{value:"Sequence Diagram (Fallback Scenario)",id:"sequence-diagram-fallback-scenario",level:2},{value:"Step-by-Step Walkthrough",id:"step-by-step-walkthrough",level:2},{value:"Step 1: Connection Initiation",id:"step-1-connection-initiation",level:3},{value:"Step 2: Circuit Breaker Check",id:"step-2-circuit-breaker-check",level:3},{value:"Step 3: Protocol Connection Attempt",id:"step-3-protocol-connection-attempt",level:3},{value:"Step 4: Capability Detection (Post-Connect)",id:"step-4-capability-detection-post-connect",level:3},{value:"Step 5: Connection Pool Registration",id:"step-5-connection-pool-registration",level:3},{value:"Step 6: Event Publication",id:"step-6-event-publication",level:3},{value:"Step 7: Health Check Background Loop",id:"step-7-health-check-background-loop",level:3},{value:"Reconnection Behavior",id:"reconnection-behavior",level:2},{value:"Error Handling",id:"error-handling",level:2},{value:"Observability",id:"observability",level:2},{value:"Cross-References",id:"cross-references",level:2}];function d(e){const n={blockquote:"blockquote",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",mermaid:"mermaid",ol:"ol",p:"p",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,i.R)(),...e.components};return(0,c.jsxs)(c.Fragment,{children:[(0,c.jsx)(n.header,{children:(0,c.jsx)(n.h1,{id:"flow-router-connection-establishment",children:"Flow: Router Connection Establishment"})}),"\n",(0,c.jsxs)(n.blockquote,{children:["\n",(0,c.jsx)(n.p,{children:"Traces how the backend connects to a MikroTik router, automatically selecting the best available protocol with circuit-breaker protection."}),"\n"]}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.strong,{children:"Touches:"})," ",(0,c.jsx)(n.code,{children:"internal/router/"}),", ",(0,c.jsx)(n.code,{children:"internal/router/adapters/"}),", ",(0,c.jsx)(n.code,{children:"internal/capability/"}),", ",(0,c.jsx)(n.code,{children:"internal/connection/"}),"\n",(0,c.jsx)(n.strong,{children:"Entry Point:"})," ",(0,c.jsx)(n.code,{children:"FallbackChain.Connect(ctx)"})," in ",(0,c.jsx)(n.code,{children:"internal/router/fallback_chain.go"}),"\n",(0,c.jsx)(n.strong,{children:"Prerequisites:"})]}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsx)(n.li,{children:"[See: 04-router-communication.md] \u2014 adapter implementations and protocol details"}),"\n",(0,c.jsx)(n.li,{children:"[See: 05-event-system.md] \u2014 RouterStatusChangedEvent publishing"}),"\n"]}),"\n",(0,c.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,c.jsxs)(n.p,{children:["When a router is added or the connection drops, ",(0,c.jsx)(n.code,{children:"FallbackChain.Connect()"})," attempts protocols in priority order: REST \u2192 RouterOS API \u2192 RouterOS API+TLS \u2192 SSH \u2192 Telnet. Each protocol has an independent circuit breaker that opens after 3 consecutive failures and stays open for 5 minutes. Once connected, a background health check runs every 30 seconds. On reconnect or disconnect, ",(0,c.jsx)(n.code,{children:"RouterStatusChangedEvent"})," is published within 100ms."]}),"\n",(0,c.jsx)(n.h2,{id:"sequence-diagram-success-path",children:"Sequence Diagram (Success Path)"}),"\n",(0,c.jsx)(n.mermaid,{value:"sequenceDiagram\n    participant Caller\n    participant FallbackChain\n    participant CircuitBreaker\n    participant AdapterFactory\n    participant RouterAdapter\n\n    Caller->>FallbackChain: Connect(ctx)\n    FallbackChain->>FallbackChain: publishStatus<br/>(RECONNECTING)\n\n    FallbackChain->>CircuitBreaker: [REST] cb.Execute()\n    CircuitBreaker->>CircuitBreaker: State == Open?\n    CircuitBreaker->>AdapterFactory: factory(REST)\n    AdapterFactory->>RouterAdapter: create RESTAdapter\n    RouterAdapter->>RouterAdapter: TCP:443/80<br/>response\n\n    RouterAdapter--\x3e>AdapterFactory: RESTAdapter\n    AdapterFactory--\x3e>CircuitBreaker: return adapter\n    RouterAdapter->>RouterAdapter: adapter.Connect()\n\n    CircuitBreaker--\x3e>FallbackChain: success\n\n    FallbackChain->>FallbackChain: currentPort = REST\n    FallbackChain->>FallbackChain: publishStatus<br/>(CONNECTED, REST)\n    FallbackChain--\x3e>Caller: nil (success)\n\n    FallbackChain->>FallbackChain: StartHealthCheck()\n    Note over FallbackChain: every 30s: /system/identity query"}),"\n",(0,c.jsx)(n.h2,{id:"sequence-diagram-fallback-scenario",children:"Sequence Diagram (Fallback Scenario)"}),"\n",(0,c.jsx)(n.mermaid,{value:"sequenceDiagram\n    participant FallbackChain\n    participant CB_REST as CircuitBreaker[REST]\n    participant CB_API as CircuitBreaker[API]\n    participant APIAdapter\n\n    FallbackChain->>CB_REST: cb[REST].Execute()\n    CB_REST->>CB_REST: connect timeout\n    CB_REST--\x3e>FallbackChain: error\n\n    FallbackChain->>CB_API: cb[API].Execute()\n    CB_API->>CB_API: State == Closed?\n    CB_API->>APIAdapter: factory(API)\n    APIAdapter->>APIAdapter: TCP:8728\n\n    APIAdapter--\x3e>CB_API: APIAdapter\n    APIAdapter->>APIAdapter: adapter.Connect()\n\n    CB_API--\x3e>FallbackChain: success\n\n    FallbackChain->>FallbackChain: currentPort = API\n    FallbackChain->>FallbackChain: publishStatus<br/>(CONNECTED, API)"}),"\n",(0,c.jsx)(n.h2,{id:"step-by-step-walkthrough",children:"Step-by-Step Walkthrough"}),"\n",(0,c.jsx)(n.h3,{id:"step-1-connection-initiation",children:"Step 1: Connection Initiation"}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.code,{children:"FallbackChain.Connect(ctx)"})," acquires the write lock (",(0,c.jsx)(n.code,{children:"mu.Lock()"}),")"]}),"\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.strong,{children:"File:"})," ",(0,c.jsx)(n.code,{children:"internal/router/fallback_chain.go:161"})]}),"\n",(0,c.jsxs)(n.li,{children:["Publishes ",(0,c.jsx)(n.code,{children:"RouterStatusChangedEvent"})," with ",(0,c.jsx)(n.code,{children:"status: RECONNECTING"})," via ",(0,c.jsx)(n.code,{children:"publishStatusChange()"})]}),"\n",(0,c.jsxs)(n.li,{children:["Iterates through ",(0,c.jsx)(n.code,{children:"DefaultFallbackOrder = [REST, API, API_SSL, SSH, Telnet]"})]}),"\n"]}),"\n",(0,c.jsx)(n.h3,{id:"step-2-circuit-breaker-check",children:"Step 2: Circuit Breaker Check"}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsxs)(n.li,{children:["For each protocol, retrieves the circuit breaker from ",(0,c.jsx)(n.code,{children:"fc.breakers[proto]"})]}),"\n",(0,c.jsxs)(n.li,{children:["If ",(0,c.jsx)(n.code,{children:"cb.State() == gobreaker.StateOpen"})," \u2192 skip this protocol entirely"]}),"\n",(0,c.jsxs)(n.li,{children:["Circuit breaker is configured with: ",(0,c.jsx)(n.code,{children:"MaxFailures: 3"}),", ",(0,c.jsx)(n.code,{children:"Timeout: 5min"}),", ",(0,c.jsx)(n.code,{children:"MaxRequests: 1"})," (half-open)"]}),"\n",(0,c.jsxs)(n.li,{children:["State transitions: ",(0,c.jsx)(n.code,{children:"Closed"})," \u2192 ",(0,c.jsx)(n.code,{children:"Open"})," (after 3 failures) \u2192 ",(0,c.jsx)(n.code,{children:"HalfOpen"})," (after 5min) \u2192 ",(0,c.jsx)(n.code,{children:"Closed"})," (if success)"]}),"\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.strong,{children:"File:"})," ",(0,c.jsx)(n.code,{children:"internal/router/fallback_chain.go:144"})," \u2014 ",(0,c.jsx)(n.code,{children:"createCircuitBreaker()"})]}),"\n"]}),"\n",(0,c.jsx)(n.h3,{id:"step-3-protocol-connection-attempt",children:"Step 3: Protocol Connection Attempt"}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.code,{children:"cb.Execute(func() { fc.tryConnect(ctx, proto) })"})," wraps the attempt"]}),"\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.strong,{children:"File:"})," ",(0,c.jsx)(n.code,{children:"internal/router/fallback_chain.go:209"})," \u2014 ",(0,c.jsx)(n.code,{children:"tryConnect()"})]}),"\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.code,{children:"factory(config, proto)"})," creates the appropriate adapter:","\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.code,{children:"ProtocolREST"})," \u2192 REST adapter via RouterOS v7+ REST API (port 80/443)"]}),"\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.code,{children:"ProtocolAPI"})," \u2192 Binary RouterOS API (port 8728)"]}),"\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.code,{children:"ProtocolAPISSL"})," \u2192 TLS-encrypted binary API (port 8729)"]}),"\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.code,{children:"ProtocolSSH"})," \u2192 SSH command execution (port 22)"]}),"\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.code,{children:"ProtocolTelnet"})," \u2192 Telnet (port 23) \u2014 legacy last resort"]}),"\n"]}),"\n"]}),"\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.code,{children:"adapter.Connect(ctx)"})," performs the actual TCP connection and handshake"]}),"\n"]}),"\n",(0,c.jsx)(n.h3,{id:"step-4-capability-detection-post-connect",children:"Step 4: Capability Detection (Post-Connect)"}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsxs)(n.li,{children:["After successful connection, ",(0,c.jsx)(n.code,{children:"capability.Detector.Detect(ctx, port)"})," is called"]}),"\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.strong,{children:"File:"})," ",(0,c.jsx)(n.code,{children:"internal/capability/detector.go:26"})]}),"\n",(0,c.jsxs)(n.li,{children:["Queries router in 4 steps:","\n",(0,c.jsxs)(n.ol,{children:["\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.code,{children:"/system/resource"})," \u2192 version, architecture, CPU count, total memory, free storage"]}),"\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.code,{children:"/system/package"})," \u2192 installed packages (detects ",(0,c.jsx)(n.code,{children:"container"}),", ",(0,c.jsx)(n.code,{children:"wireless"}),", ",(0,c.jsx)(n.code,{children:"lte"}),")"]}),"\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.code,{children:"/system/routerboard"})," \u2192 hardware model (non-fatal if unavailable)"]}),"\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.code,{children:"/container/config"})," \u2192 container enable state, registry URL"]}),"\n"]}),"\n"]}),"\n",(0,c.jsx)(n.li,{children:"Computes capability levels: memory tier, max containers, network namespace support"}),"\n",(0,c.jsxs)(n.li,{children:["Results stored in ",(0,c.jsx)(n.code,{children:"Capabilities"})," struct \u2014 used by feature installation to check prerequisites"]}),"\n"]}),"\n",(0,c.jsx)(n.h3,{id:"step-5-connection-pool-registration",children:"Step 5: Connection Pool Registration"}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsx)(n.li,{children:"The connected adapter is registered in the connection pool"}),"\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.strong,{children:"File:"})," ",(0,c.jsx)(n.code,{children:"internal/connection/pool.go"})]}),"\n",(0,c.jsx)(n.li,{children:"Pool provides reference-counted access; callers acquire/release connections"}),"\n",(0,c.jsxs)(n.li,{children:["Circuit breaker wraps every ",(0,c.jsx)(n.code,{children:"ExecuteCommand()"})," and ",(0,c.jsx)(n.code,{children:"QueryState()"})," call after connection"]}),"\n",(0,c.jsxs)(n.li,{children:["If the circuit breaker opens during normal operation, ",(0,c.jsx)(n.code,{children:"attemptReconnect()"})," is launched in background"]}),"\n"]}),"\n",(0,c.jsx)(n.h3,{id:"step-6-event-publication",children:"Step 6: Event Publication"}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsxs)(n.li,{children:["On success: ",(0,c.jsx)(n.code,{children:'publishStatusChange(ctx, RouterStatusConnected, proto.String(), "")'})," is called"]}),"\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.strong,{children:"File:"})," ",(0,c.jsx)(n.code,{children:"internal/router/fallback_chain.go:118"})]}),"\n",(0,c.jsx)(n.li,{children:"Uses a 100ms timeout context to avoid blocking connection operations"}),"\n",(0,c.jsxs)(n.li,{children:["Emits ",(0,c.jsx)(n.code,{children:"RouterStatusChangedEvent"})," with: ",(0,c.jsx)(n.code,{children:"routerID"}),", ",(0,c.jsx)(n.code,{children:"newStatus"}),", ",(0,c.jsx)(n.code,{children:"previousStatus"}),", ",(0,c.jsx)(n.code,{children:"protocol"})]}),"\n",(0,c.jsxs)(n.li,{children:["On total failure (all protocols exhausted): ",(0,c.jsx)(n.code,{children:"RouterStatusError"})," is published with the last error"]}),"\n"]}),"\n",(0,c.jsx)(n.h3,{id:"step-7-health-check-background-loop",children:"Step 7: Health Check Background Loop"}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.code,{children:"StartHealthCheck(ctx)"})," starts a goroutine with a 30-second ticker"]}),"\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.strong,{children:"File:"})," ",(0,c.jsx)(n.code,{children:"internal/router/fallback_chain.go:362"})]}),"\n",(0,c.jsxs)(n.li,{children:["Each tick: ",(0,c.jsx)(n.code,{children:'QueryState(ctx, StateQuery{Path: "/system/identity", Limit: 1})'})]}),"\n",(0,c.jsx)(n.li,{children:"If query fails \u2192 logs debug warning (circuit breaker handles retry)"}),"\n",(0,c.jsxs)(n.li,{children:["If not connected \u2192 calls ",(0,c.jsx)(n.code,{children:"attemptReconnect()"})," to restart the fallback chain"]}),"\n"]}),"\n",(0,c.jsx)(n.h2,{id:"reconnection-behavior",children:"Reconnection Behavior"}),"\n",(0,c.jsx)(n.p,{children:"When a command fails and the circuit breaker opens:"}),"\n",(0,c.jsxs)(n.ol,{children:["\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.code,{children:"ExecuteCommand()"}),' returns error with "circuit breaker open"']}),"\n",(0,c.jsxs)(n.li,{children:["Caller sees error; background ",(0,c.jsx)(n.code,{children:"go fc.attemptReconnect(context.Background())"})," is launched"]}),"\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.code,{children:"attemptReconnect()"})," disconnects current adapter and restarts the full fallback chain"]}),"\n",(0,c.jsxs)(n.li,{children:["On reconnect success: new ",(0,c.jsx)(n.code,{children:"RouterStatusConnected"})," event with (potentially different) protocol"]}),"\n"]}),"\n",(0,c.jsx)(n.h2,{id:"error-handling",children:"Error Handling"}),"\n",(0,c.jsxs)(n.table,{children:[(0,c.jsx)(n.thead,{children:(0,c.jsxs)(n.tr,{children:[(0,c.jsx)(n.th,{children:"Scenario"}),(0,c.jsx)(n.th,{children:"Behavior"})]})}),(0,c.jsxs)(n.tbody,{children:[(0,c.jsxs)(n.tr,{children:[(0,c.jsx)(n.td,{children:"All protocols fail"}),(0,c.jsxs)(n.td,{children:[(0,c.jsx)(n.code,{children:"RouterStatusError"})," event; returns ",(0,c.jsx)(n.code,{children:'"all protocols failed"'})," error"]})]}),(0,c.jsxs)(n.tr,{children:[(0,c.jsx)(n.td,{children:"Circuit breaker open"}),(0,c.jsx)(n.td,{children:"Protocol skipped; no connection attempt"})]}),(0,c.jsxs)(n.tr,{children:[(0,c.jsx)(n.td,{children:"Adapter factory error"}),(0,c.jsx)(n.td,{children:"Circuit breaker counts as failure; tries next protocol"})]}),(0,c.jsxs)(n.tr,{children:[(0,c.jsx)(n.td,{children:"Health check ping fails"}),(0,c.jsx)(n.td,{children:"Debug log; circuit breaker tracks failure; reconnect if opens"})]}),(0,c.jsxs)(n.tr,{children:[(0,c.jsx)(n.td,{children:"Context cancelled"}),(0,c.jsx)(n.td,{children:"Connection attempt aborted; no status published"})]})]})]}),"\n",(0,c.jsx)(n.h2,{id:"observability",children:"Observability"}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)(n.strong,{children:"Events emitted (event bus):"})}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.code,{children:"RouterStatusChangedEvent"})," \u2014 type ",(0,c.jsx)(n.code,{children:"router.status.changed"})," \u2014 on every status transition (RECONNECTING \u2192 CONNECTED/ERROR/DISCONNECTED)"]}),"\n"]}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)(n.strong,{children:"Logs generated:"})}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.code,{children:"[FallbackChain]"})," component tag with ",(0,c.jsx)(n.code,{children:"host"})," field"]}),"\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.code,{children:"DEBUG: attempting protocol connection"})," \u2014 for each protocol tried"]}),"\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.code,{children:"INFO: connection successful"})," with protocol name"]}),"\n",(0,c.jsx)(n.li,{children:(0,c.jsx)(n.code,{children:"DEBUG: circuit breaker open, skipping protocol"})}),"\n",(0,c.jsx)(n.li,{children:(0,c.jsx)(n.code,{children:"WARN: circuit breaker opened, attempting reconnect"})}),"\n",(0,c.jsx)(n.li,{children:(0,c.jsx)(n.code,{children:"ERROR: reconnection failed, all protocols exhausted"})}),"\n"]}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)(n.strong,{children:"Circuit breaker state:"})}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.code,{children:"GetCircuitBreakerStates()"})," returns map of ",(0,c.jsx)(n.code,{children:'Protocol \u2192 "closed/open/half-open"'})," for health endpoints"]}),"\n"]}),"\n",(0,c.jsx)(n.h2,{id:"cross-references",children:"Cross-References"}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsx)(n.li,{children:"[See: 04-router-communication.md \xa7Adapters] \u2014 REST, API, SSH, Telnet adapter implementations"}),"\n",(0,c.jsx)(n.li,{children:"[See: 04-router-communication.md \xa7Protocol] \u2014 adapter factory and protocol selection"}),"\n",(0,c.jsx)(n.li,{children:"[See: 05-event-system.md \xa7RouterStatus] \u2014 RouterStatusChangedEvent structure"}),"\n",(0,c.jsx)(n.li,{children:"[See: 06-service-orchestrator.md \xa7HealthCheck] \u2014 how orchestrator uses connection health"}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,c.jsx)(n,{...e,children:(0,c.jsx)(d,{...e})}):d(e)}},71184:(e,n,t)=>{t.d(n,{R:()=>l,x:()=>o});var r=t(14041);const c={},i=r.createContext(c);function l(e){const n=r.useContext(i);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(c):e.components||c:l(e.components),r.createElement(i.Provider,{value:n},e.children)}}}]);