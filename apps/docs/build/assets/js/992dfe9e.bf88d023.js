"use strict";(globalThis.webpackChunk_nas_net_docs=globalThis.webpackChunk_nas_net_docs||[]).push([[71742],{71184:(e,t,n)=>{n.d(t,{R:()=>o,x:()=>c});var r=n(14041);const i={},s=r.createContext(i);function o(e){const t=r.useContext(s);return r.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function c(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),r.createElement(s.Provider,{value:t},e.children)}},85389:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>c,default:()=>u,frontMatter:()=>o,metadata:()=>r,toc:()=>d});const r=JSON.parse('{"id":"cross-cutting-features/drift-detection-feature","title":"Drift Detection Feature","description":"Configuration drift occurs when the desired state stored in NasNet\'s configuration layer differs from the actual state on the router. This happens when someone changes the router directly via SSH or the RouterOS web interface, bypassing NasNet.","source":"@site/../connect/docs/cross-cutting-features/drift-detection-feature.md","sourceDirName":"cross-cutting-features","slug":"/cross-cutting-features/drift-detection-feature","permalink":"/docs/frontend/cross-cutting-features/drift-detection-feature","draft":false,"unlisted":false,"editUrl":"https://github.com/nasnet-community/nasnet-panel/tree/main/../connect/docs/cross-cutting-features/drift-detection-feature.md","tags":[],"version":"current","frontMatter":{},"sidebar":"sidebar","previous":{"title":"Configuration Import","permalink":"/docs/frontend/cross-cutting-features/configuration-import"},"next":{"title":"Router Connection","permalink":"/docs/frontend/cross-cutting-features/router-connection"}}');var i=n(31085),s=n(71184);const o={},c="Drift Detection Feature",l={},d=[{value:"Drift Status Values",id:"drift-status-values",level:2},{value:"How Drift Is Detected",id:"how-drift-is-detected",level:2},{value:"Detection Hooks",id:"detection-hooks",level:2},{value:"<code>useDriftDetection(input, options?)</code>",id:"usedriftdetectioninput-options",level:3},{value:"<code>useQuickDriftCheck(configuration, deployment)</code>",id:"usequickdriftcheckconfiguration-deployment",level:3},{value:"<code>useBatchDriftStatus(resources)</code>",id:"usebatchdriftstatusresources",level:3},{value:"<code>detectDrift(input, options?)</code> / <code>detectResourceDrift(resource, options?)</code>",id:"detectdriftinput-options--detectresourcedriftresource-options",level:3},{value:"DriftResult Structure",id:"driftresult-structure",level:2},{value:"Reconciliation Polling",id:"reconciliation-polling",level:2},{value:"Priority Tiers",id:"priority-tiers",level:3},{value:"Apply-Confirm-Merge Pattern",id:"apply-confirm-merge-pattern",level:2},{value:"<code>useApplyConfirmDrift(options)</code>",id:"useapplyconfirmdriftoptions",level:3},{value:"Drift Resolution",id:"drift-resolution",level:2},{value:"<code>useDriftResolution(options)</code>",id:"usedriftresolutionoptions",level:3},{value:"UI Patterns",id:"ui-patterns",level:2},{value:"Drift Indicator in Lists",id:"drift-indicator-in-lists",level:3},{value:"Drift Detail Panel",id:"drift-detail-panel",level:3},{value:"Stale Deployment Warning",id:"stale-deployment-warning",level:3}];function a(e){const t={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.header,{children:(0,i.jsx)(t.h1,{id:"drift-detection-feature",children:"Drift Detection Feature"})}),"\n",(0,i.jsx)(t.p,{children:"Configuration drift occurs when the desired state stored in NasNet's configuration layer differs from the actual state on the router. This happens when someone changes the router directly via SSH or the RouterOS web interface, bypassing NasNet."}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.strong,{children:"Key files:"})}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"libs/state/stores/src/drift-detection/useDriftDetection.ts"})," \u2014 core detection hook"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"libs/state/stores/src/drift-detection/useApplyConfirmDrift.ts"})," \u2014 Apply-Confirm-Merge integration"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"libs/state/stores/src/drift-detection/types.ts"})," \u2014 status enums, field types, options"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"libs/state/stores/src/drift-detection/driftUtils.ts"})," \u2014 hash computation, field diffing"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"libs/state/stores/src/drift-detection/reconciliationScheduler.ts"})," \u2014 polling scheduler"]}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.strong,{children:"Cross-references:"})}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["See ",(0,i.jsx)(t.code,{children:"../architecture/data-flow.md"})," for the Universal State v2 8-layer model"]}),"\n",(0,i.jsxs)(t.li,{children:["See ",(0,i.jsx)(t.code,{children:"change-set-system.md"})," for applying changes that reconcile drift"]}),"\n"]}),"\n",(0,i.jsx)(t.hr,{}),"\n",(0,i.jsx)(t.h2,{id:"drift-status-values",children:"Drift Status Values"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-typescript",children:"const DriftStatus = {\n  SYNCED: 'SYNCED',    // Configuration matches router (green)\n  DRIFTED: 'DRIFTED',  // Configuration differs from router (amber)\n  ERROR: 'ERROR',      // Unable to determine status (red)\n  CHECKING: 'CHECKING', // Check in progress\n  PENDING: 'PENDING',  // Resource not yet applied, no deployment data\n};\n"})}),"\n",(0,i.jsx)(t.hr,{}),"\n",(0,i.jsx)(t.h2,{id:"how-drift-is-detected",children:"How Drift Is Detected"}),"\n",(0,i.jsx)(t.p,{children:"The Universal State v2 model stores each resource in 8 layers. Drift detection compares two of them:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Layer 3 (Configuration)"})," \u2014 the user's desired state, stored in NasNet's database"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Layer 4 (Deployment)"})," \u2014 the state that was last applied to the router, including any fields generated by RouterOS"]}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:"The comparison uses:"}),"\n",(0,i.jsxs)(t.ol,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Hash comparison"})," (fast path): SHA-based hash of normalized configuration vs. normalized deployment. Equal hashes = no drift, skips detailed diff."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Field-level diff"})," (detail path): When hashes differ, ",(0,i.jsx)(t.code,{children:"findDriftedFields"})," walks the objects and identifies exactly which fields changed."]}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:"Runtime-only fields are excluded from comparison (they fluctuate without user action):"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-typescript",children:"const RUNTIME_ONLY_FIELDS = [\n  'bytesIn', 'bytesOut', 'packetsIn', 'packetsOut', 'txRate', 'rxRate',\n  'lastHandshake', 'lastSeen', 'connectedSince', 'lastConnected',\n  'uptime', 'currentPeers', 'activeConnections', 'cpuLoad', 'memoryUsage',\n  'lastUpdated', 'lastModified', 'lastAccessed',\n  'health', 'status', 'isRunning', 'errorCount',\n];\n"})}),"\n",(0,i.jsx)(t.hr,{}),"\n",(0,i.jsx)(t.h2,{id:"detection-hooks",children:"Detection Hooks"}),"\n",(0,i.jsx)(t.h3,{id:"usedriftdetectioninput-options",children:(0,i.jsx)(t.code,{children:"useDriftDetection(input, options?)"})}),"\n",(0,i.jsx)(t.p,{children:"Primary hook for resource-level drift display. Memoized \u2014 only recomputes when input data changes."}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-typescript",children:"const { hasDrift, status, driftCount, result } = useDriftDetection({\n  configuration: resource.configuration,  // From Layer 3\n  deployment: resource.deployment,        // From Layer 4\n  resourceType: resource.type,            // For priority classification\n});\n\n// result.driftedFields contains field-level details\nresult.driftedFields.forEach(field => {\n  console.log(`${field.path}: was ${field.configValue}, router has ${field.deployValue}`);\n});\n"})}),"\n",(0,i.jsx)(t.p,{children:"Options:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-typescript",children:"interface DriftDetectionOptions {\n  excludeFields?: string[];   // Additional fields to skip\n  deepCompare?: boolean;      // Include nested objects (default: true)\n  staleThreshold?: number;    // Max age of deployment layer in ms (default: 30 min)\n}\n"})}),"\n",(0,i.jsx)(t.h3,{id:"usequickdriftcheckconfiguration-deployment",children:(0,i.jsx)(t.code,{children:"useQuickDriftCheck(configuration, deployment)"})}),"\n",(0,i.jsx)(t.p,{children:"Lightweight hook for list views \u2014 hash-only, no field-level diff. Use when you only need to know IF drift exists, not WHAT drifted."}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-typescript",children:"const { hasDrift, status } = useQuickDriftCheck(\n  resource.configuration,\n  resource.deployment,\n);\n"})}),"\n",(0,i.jsx)(t.h3,{id:"usebatchdriftstatusresources",children:(0,i.jsx)(t.code,{children:"useBatchDriftStatus(resources)"})}),"\n",(0,i.jsxs)(t.p,{children:["Check multiple resources at once. Returns a ",(0,i.jsx)(t.code,{children:"Map<resourceUuid, DriftStatus>"}),"."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-typescript",children:"const statusMap = useBatchDriftStatus(resources);\n\nresources.forEach(r => {\n  const status = statusMap.get(r.uuid);\n  // Render drift indicator per resource\n});\n"})}),"\n",(0,i.jsxs)(t.h3,{id:"detectdriftinput-options--detectresourcedriftresource-options",children:[(0,i.jsx)(t.code,{children:"detectDrift(input, options?)"})," / ",(0,i.jsx)(t.code,{children:"detectResourceDrift(resource, options?)"})]}),"\n",(0,i.jsx)(t.p,{children:"Pure functions for one-off checks outside of React (e.g., in event handlers or machine actions)."}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-typescript",children:"const result = detectResourceDrift(resource, { deepCompare: true });\nif (result.hasDrift) {\n  console.log(`${result.driftedFields.length} fields drifted`);\n}\n"})}),"\n",(0,i.jsx)(t.hr,{}),"\n",(0,i.jsx)(t.h2,{id:"driftresult-structure",children:"DriftResult Structure"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-typescript",children:"interface DriftResult {\n  hasDrift: boolean;\n  status: DriftStatus;\n  driftedFields: DriftedField[];     // Empty if no drift\n  configurationHash: string;         // Hash of config layer\n  deploymentHash: string;            // Hash of deployment layer\n  lastChecked: Date;\n  errorMessage?: string;             // Set when status = ERROR\n  isStale?: boolean;                 // Deployment older than staleThreshold\n}\n\ninterface DriftedField {\n  path: string;        // JSON path, e.g., 'address.ip' or 'peers[0].endpoint'\n  configValue: unknown; // What NasNet thinks it should be\n  deployValue: unknown; // What the router actually has\n  category?: 'network' | 'security' | 'general';\n}\n"})}),"\n",(0,i.jsx)(t.hr,{}),"\n",(0,i.jsx)(t.h2,{id:"reconciliation-polling",children:"Reconciliation Polling"}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.code,{children:"reconciliationScheduler.ts"})," implements priority-based polling to periodically fetch the actual router state and update the deployment layer."]}),"\n",(0,i.jsx)(t.h3,{id:"priority-tiers",children:"Priority Tiers"}),"\n",(0,i.jsxs)(t.table,{children:[(0,i.jsx)(t.thead,{children:(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.th,{children:"Priority"}),(0,i.jsx)(t.th,{children:"Interval"}),(0,i.jsx)(t.th,{children:"Resource Types"})]})}),(0,i.jsxs)(t.tbody,{children:[(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"HIGH"}),(0,i.jsx)(t.td,{children:"5 minutes"}),(0,i.jsx)(t.td,{children:"WAN, VPN, authentication"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"NORMAL"}),(0,i.jsx)(t.td,{children:"15 minutes"}),(0,i.jsx)(t.td,{children:"LAN, DHCP, firewall, NAT, routing, wireless"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"LOW"}),(0,i.jsx)(t.td,{children:"60 minutes"}),(0,i.jsx)(t.td,{children:"Logging, scripts, scheduler, backup, SNMP"})]})]})]}),"\n",(0,i.jsx)(t.p,{children:"Priority is determined by resource type prefix:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-typescript",children:"const priority = getResourcePriority('vpn.wireguard'); // HIGH (5 min)\nconst priority = getResourcePriority('dhcp');          // NORMAL (15 min)\nconst priority = getResourcePriority('logging');       // LOW (60 min)\n"})}),"\n",(0,i.jsx)(t.hr,{}),"\n",(0,i.jsx)(t.h2,{id:"apply-confirm-merge-pattern",children:"Apply-Confirm-Merge Pattern"}),"\n",(0,i.jsx)(t.p,{children:"When a configuration change is applied to the router, the Apply-Confirm-Merge flow ensures the deployment layer stays accurate:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"1. Apply   \u2014 Send new configuration to router via GraphQL mutation\n2. Confirm \u2014 Verify actual state from router (backend queries RouterOS)\n3. Merge   \u2014 Store confirmed state in deployment layer (Layer 4)\n4. Detect  \u2014 Recompute drift (should be SYNCED after successful apply)\n"})}),"\n",(0,i.jsx)(t.h3,{id:"useapplyconfirmdriftoptions",children:(0,i.jsx)(t.code,{children:"useApplyConfirmDrift(options)"})}),"\n",(0,i.jsx)(t.p,{children:"Wraps any apply mutation to follow this pattern:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-typescript",children:"const { applyWithConfirm, isApplying, lastResult } = useApplyConfirmDrift({\n  applyFn: async (resourceUuid, configuration) => {\n    const result = await client.mutate({\n      mutation: APPLY_RESOURCE,\n      variables: { uuid: resourceUuid, configuration },\n    });\n    return result.data.applyResource; // { success, deployment, resource }\n  },\n  confirmFn: async (resourceUuid) => {\n    // Optional \u2014 if backend doesn't auto-confirm\n    const result = await client.query({ query: GET_DEPLOYMENT, variables: { uuid: resourceUuid } });\n    return result.data.deployment;\n  },\n  onDriftChange: (uuid, driftResult) => {\n    if (driftResult.status === 'DRIFTED') {\n      toast.warning('Drift detected after apply \u2014 router may not have accepted all changes');\n    }\n  },\n  onApplySuccess: (uuid, result) => {\n    toast.success('Configuration applied');\n  },\n  onApplyError: (uuid, error) => {\n    toast.error(`Apply failed: ${error}`);\n  },\n});\n\n// In your form submit handler:\nconst handleSave = async (newConfig) => {\n  const result = await applyWithConfirm({ ...resource, configuration: newConfig });\n  if (!result.success) {\n    setFormError(result.error);\n  }\n};\n"})}),"\n",(0,i.jsx)(t.hr,{}),"\n",(0,i.jsx)(t.h2,{id:"drift-resolution",children:"Drift Resolution"}),"\n",(0,i.jsx)(t.p,{children:"When drift is detected, the user can choose one of three actions:"}),"\n",(0,i.jsxs)(t.table,{children:[(0,i.jsx)(t.thead,{children:(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.th,{children:"Action"}),(0,i.jsx)(t.th,{children:"Description"})]})}),(0,i.jsxs)(t.tbody,{children:[(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"REAPPLY"}),(0,i.jsx)(t.td,{children:"Re-send local configuration to router (overwrite router's change)"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"ACCEPT"}),(0,i.jsx)(t.td,{children:"Accept router's current state as the new configuration"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"DISMISS"}),(0,i.jsx)(t.td,{children:"Ignore this drift instance (it will appear again on next check)"})]})]})]}),"\n",(0,i.jsx)(t.h3,{id:"usedriftresolutionoptions",children:(0,i.jsx)(t.code,{children:"useDriftResolution(options)"})}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-typescript",children:"const { reapply, accept, isResolving, error } = useDriftResolution({\n  reapplyFn: async (uuid, config) => {\n    await client.mutate({ mutation: APPLY_RESOURCE, variables: { uuid, configuration: config } });\n  },\n  acceptFn: async (uuid, deployment) => {\n    await client.mutate({\n      mutation: UPDATE_CONFIGURATION,\n      variables: { uuid, configuration: deployment.generatedFields },\n    });\n  },\n  onResolved: (uuid, action) => {\n    toast.success(`Drift resolved via ${action}`);\n  },\n});\n"})}),"\n",(0,i.jsx)(t.hr,{}),"\n",(0,i.jsx)(t.h2,{id:"ui-patterns",children:"UI Patterns"}),"\n",(0,i.jsx)(t.h3,{id:"drift-indicator-in-lists",children:"Drift Indicator in Lists"}),"\n",(0,i.jsx)(t.p,{children:"For resource list views, use the quick check to show a compact indicator:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-tsx",children:"function ResourceRow({ resource }) {\n  const { hasDrift, status } = useQuickDriftCheck(\n    resource.configuration,\n    resource.deployment,\n  );\n\n  return (\n    <tr>\n      <td>{resource.name}</td>\n      <td>\n        {hasDrift && <DriftBadge status={status} />}\n      </td>\n    </tr>\n  );\n}\n"})}),"\n",(0,i.jsx)(t.p,{children:"Drift badge colors follow semantic tokens:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"SYNCED \u2192 no badge (or hidden green checkmark)"}),"\n",(0,i.jsx)(t.li,{children:"DRIFTED \u2192 amber warning badge with field count"}),"\n",(0,i.jsx)(t.li,{children:"ERROR \u2192 red badge with error icon"}),"\n",(0,i.jsx)(t.li,{children:'PENDING \u2192 gray badge ("Not yet applied")'}),"\n",(0,i.jsx)(t.li,{children:"CHECKING \u2192 spinning indicator"}),"\n"]}),"\n",(0,i.jsx)(t.h3,{id:"drift-detail-panel",children:"Drift Detail Panel"}),"\n",(0,i.jsxs)(t.p,{children:["For resource detail views, use the full ",(0,i.jsx)(t.code,{children:"useDriftDetection"})," to show field-level diff:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-tsx",children:"function ResourceDriftPanel({ resource }) {\n  const { hasDrift, result } = useDriftDetection({\n    configuration: resource.configuration,\n    deployment: resource.deployment,\n  });\n\n  if (!hasDrift) return null;\n\n  return (\n    <DriftPanel>\n      <p>{result.driftedFields.length} fields differ from router</p>\n      {result.driftedFields.map(field => (\n        <DriftField\n          key={field.path}\n          path={field.path}\n          expected={field.configValue}\n          actual={field.deployValue}\n        />\n      ))}\n      <DriftResolutionActions resource={resource} />\n    </DriftPanel>\n  );\n}\n"})}),"\n",(0,i.jsx)(t.h3,{id:"stale-deployment-warning",children:"Stale Deployment Warning"}),"\n",(0,i.jsxs)(t.p,{children:["When ",(0,i.jsx)(t.code,{children:"result.isStale"})," is true, the deployment layer is older than 30 minutes (the default threshold). Show a warning:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-tsx",children:'{result.isStale && (\n  <Alert variant="warning">\n    Router state was last checked {formatRelativeTime(resource.deployment.appliedAt)}.\n    Drift data may be outdated.\n  </Alert>\n)}\n'})})]})}function u(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(a,{...e})}):a(e)}}}]);