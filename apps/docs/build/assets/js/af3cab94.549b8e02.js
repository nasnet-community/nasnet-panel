"use strict";(globalThis.webpackChunk_nas_net_docs=globalThis.webpackChunk_nas_net_docs||[]).push([[48774],{10731:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>a,contentTitle:()=>c,default:()=>h,frontMatter:()=>s,metadata:()=>r,toc:()=>o});const r=JSON.parse('{"id":"flows/device-routing-chain-flow","title":"Flow: Device Routing Chain","description":"Traces how a client device\'s traffic is steered through a multi-hop service chain (e.g., Device \u2192 VPN \u2192 Tor \u2192 Internet) using MikroTik PBR mangle rules, with kill switch enforcement on service failure.","source":"@site/../backend/docs/flows/device-routing-chain-flow.md","sourceDirName":"flows","slug":"/flows/device-routing-chain-flow","permalink":"/docs/backend/flows/device-routing-chain-flow","draft":false,"unlisted":false,"editUrl":"https://github.com/nasnet-community/nasnet-panel/tree/main/../backend/docs/flows/device-routing-chain-flow.md","tags":[],"version":"current","frontMatter":{},"sidebar":"sidebar","previous":{"title":"Flow: Config Provisioning","permalink":"/docs/backend/flows/config-provisioning-flow"},"next":{"title":"Flow: GraphQL Request Lifecycle","permalink":"/docs/backend/flows/graphql-request-lifecycle"}}');var t=i(31085),l=i(71184);const s={},c="Flow: Device Routing Chain",a={},o=[{value:"Overview",id:"overview",level:2},{value:"Sequence Diagram \u2014 Single-Hop Assignment",id:"sequence-diagram--single-hop-assignment",level:2},{value:"Sequence Diagram \u2014 Multi-Hop Chain (ChainRouter)",id:"sequence-diagram--multi-hop-chain-chainrouter",level:2},{value:"Sequence Diagram \u2014 Kill Switch (Service Failure)",id:"sequence-diagram--kill-switch-service-failure",level:2},{value:"Step-by-Step Walkthrough",id:"step-by-step-walkthrough",level:2},{value:"Step 1: Device Routing Assignment",id:"step-1-device-routing-assignment",level:3},{value:"Step 2: Mangle Rule Creation",id:"step-2-mangle-rule-creation",level:3},{value:"Step 3: Routing Table Lookup (RouterOS runtime)",id:"step-3-routing-table-lookup-routeros-runtime",level:3},{value:"Step 4: Multi-Hop Chain Routing",id:"step-4-multi-hop-chain-routing",level:3},{value:"Step 5: Latency Measurement",id:"step-5-latency-measurement",level:3},{value:"Step 6: Kill Switch Activation",id:"step-6-kill-switch-activation",level:3},{value:"Step 7: Kill Switch Deactivation",id:"step-7-kill-switch-deactivation",level:3},{value:"Step 8: Startup Reconciliation",id:"step-8-startup-reconciliation",level:3},{value:"Error Handling",id:"error-handling",level:2},{value:"Observability",id:"observability",level:2},{value:"Cross-References",id:"cross-references",level:2}];function d(e){const n={blockquote:"blockquote",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",mermaid:"mermaid",ol:"ol",p:"p",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,l.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"flow-device-routing-chain",children:"Flow: Device Routing Chain"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"Traces how a client device's traffic is steered through a multi-hop service chain (e.g., Device \u2192 VPN \u2192 Tor \u2192 Internet) using MikroTik PBR mangle rules, with kill switch enforcement on service failure."}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Touches:"})," ",(0,t.jsx)(n.code,{children:"internal/vif/routing/"}),", ",(0,t.jsx)(n.code,{children:"internal/vif/isolation/"}),", ",(0,t.jsx)(n.code,{children:"internal/provisioning/network/"}),"\n",(0,t.jsx)(n.strong,{children:"Entry Point:"})," ",(0,t.jsx)(n.code,{children:"PBREngine.AssignDeviceRouting()"})," in ",(0,t.jsx)(n.code,{children:"internal/vif/routing/pbr_engine.go"}),"\n",(0,t.jsx)(n.strong,{children:"Prerequisites:"})]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"[See: 07-virtual-interface-factory.md] \u2014 VIF VLAN interface that serves as routing target"}),"\n",(0,t.jsx)(n.li,{children:"[See: 06-service-orchestrator.md \xa7Health] \u2014 health events that trigger kill switch"}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,t.jsx)(n.p,{children:"Device routing assigns a physical LAN client device (identified by MAC address) to route its traffic through one or more NasNet service instances. For a single-hop assignment, the PBR engine creates one mangle rule. For multi-hop chains (e.g., VPN \u2192 Tor), the ChainRouter creates ordered hop records and the mangle rules link each hop's routing mark to the next. The kill switch listener monitors health events and blocks the device's internet access if any hop in the chain becomes unhealthy."}),"\n",(0,t.jsx)(n.h2,{id:"sequence-diagram--single-hop-assignment",children:"Sequence Diagram \u2014 Single-Hop Assignment"}),"\n",(0,t.jsx)(n.mermaid,{value:'sequenceDiagram\n    participant GraphQL\n    participant PBREngine\n    participant RouterPort as RouterPort<br/>(Mangle)\n    participant DB as DB<br/>(DeviceRouting)\n\n    GraphQL->>PBREngine: AssignDevice()<br/>(deviceID, MAC,<br/>routingMark, instanceID)\n    PBREngine->>DB: query DeviceRouting\n    DB--\x3e>PBREngine: existing? (conflict)\n\n    alt conflict exists\n        PBREngine->>RouterPort: removeMangleRule()<br/>/ip/firewall/mangle remove .id=*N\n        PBREngine->>DB: DeleteOneID()\n        DB--\x3e>PBREngine: delete old record\n    end\n\n    PBREngine->>RouterPort: createMangleRule()<br/>/ip/firewall/mangle add<br/>chain=prerouting<br/>src-mac-address={MAC}<br/>action=mark-routing<br/>new-routing-mark={routingMark}<br/>passthrough=yes<br/>comment=nnc-routing-{deviceID}\n    RouterPort--\x3e>PBREngine: {.id: "*17"}\n    PBREngine->>DB: Create record<br/>{deviceID, MAC,<br/>routingMark,<br/>mangleRuleID: "*17"}\n    DB--\x3e>PBREngine: record created\n\n    PBREngine->>PBREngine: Publish(device.routing.assigned)\n    PBREngine--\x3e>GraphQL: result'}),"\n",(0,t.jsx)(n.h2,{id:"sequence-diagram--multi-hop-chain-chainrouter",children:"Sequence Diagram \u2014 Multi-Hop Chain (ChainRouter)"}),"\n",(0,t.jsx)(n.mermaid,{value:"sequenceDiagram\n    participant GraphQL\n    participant ChainRouter\n    participant PBREngine\n    participant RouterPort\n\n    GraphQL->>ChainRouter: CreateChain()<br/>{deviceID, MAC,<br/>hops: [VIF-A, VIF-B]}\n\n    ChainRouter->>ChainRouter: validateChainInput()<br/>[2-5 hops required]<br/>[no circular refs]<br/>[all VIFs exist]\n\n    ChainRouter->>ChainRouter: removeExistingChain()<br/>(idempotent cleanup)\n\n    ChainRouter->>ChainRouter: createChainRecord()<br/>DB: RoutingChain{<br/>deviceID, MAC,<br/>routingMode,<br/>killSwitchEnabled}\n\n    ChainRouter->>ChainRouter: createChainHops()<br/>for each hop (ordered):<br/>DB: ChainHop{order, interfaceID}\n\n    ChainRouter->>PBREngine: Hop 1 (VIF-A):<br/>AssignDeviceRouting(MAC, VIF-A.mark)\n    PBREngine->>RouterPort: mangle add rule<br/>(MAC \u2192 VIF-A mark)\n\n    ChainRouter->>RouterPort: Hop 2 (VIF-B):<br/>Create inter-hop route<br/>(VIF-A subnet \u2192 VIF-B mark)\n\n    ChainRouter->>ChainRouter: Publish(routing.chain.created)\n    ChainRouter--\x3e>GraphQL: RoutingChain"}),"\n",(0,t.jsx)(n.h2,{id:"sequence-diagram--kill-switch-service-failure",children:"Sequence Diagram \u2014 Kill Switch (Service Failure)"}),"\n",(0,t.jsx)(n.mermaid,{value:'sequenceDiagram\n    participant EventBus\n    participant KillSwitchListener\n    participant KillSwitchManager\n    participant RouterPort\n\n    EventBus->>KillSwitchListener: HealthChanged<br/>(FeatureHealth<br/>HEALTHY\u2192UNHEALTHY)\n\n    KillSwitchListener->>KillSwitchListener: query DeviceRouting<br/>WHERE instanceID=X<br/>AND killSwitchEnabled=true\n\n    KillSwitchListener->>KillSwitchManager: handleUnhealthy()\n\n    KillSwitchManager->>RouterPort: Activate(routingID)<br/>/ip/firewall/filter add<br/>chain=forward<br/>routing-mark={mark}<br/>action=drop<br/>comment=nnc-ks-{routingID}\n    RouterPort--\x3e>KillSwitchManager: {.id: "*21"}\n\n    KillSwitchManager->>KillSwitchManager: DB: killSwitchRuleID = "*21"<br/>DB: killSwitchActivatedAt = now\n\n    KillSwitchListener->>EventBus: Publish(kill_switch.activated)\n\n    Note over EventBus: service recovers\n\n    EventBus->>KillSwitchListener: HealthChanged<br/>(UNHEALTHY\u2192HEALTHY)\n\n    KillSwitchListener->>KillSwitchManager: handleHealthy()\n\n    KillSwitchManager->>RouterPort: Deactivate(routingID)<br/>/ip/firewall/filter remove .id=*21\n\n    KillSwitchManager->>KillSwitchManager: DB: killSwitchRuleID = ""\n\n    KillSwitchListener->>EventBus: Publish(kill_switch.deactivated)'}),"\n",(0,t.jsx)(n.h2,{id:"step-by-step-walkthrough",children:"Step-by-Step Walkthrough"}),"\n",(0,t.jsx)(n.h3,{id:"step-1-device-routing-assignment",children:"Step 1: Device Routing Assignment"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"PBREngine.AssignDeviceRouting(ctx, deviceID, macAddress, routingMark, instanceID)"})," is called"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"File:"})," ",(0,t.jsx)(n.code,{children:"internal/vif/routing/pbr_engine.go:67"})]}),"\n",(0,t.jsxs)(n.li,{children:["Implements the Apply-Confirm-Merge pattern:","\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Check conflict"})," \u2014 query ",(0,t.jsx)(n.code,{children:"DeviceRouting"})," for existing rule with same ",(0,t.jsx)(n.code,{children:"deviceID"})]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Remove conflict"})," \u2014 if found, remove old mangle rule from router + delete DB record"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Apply"})," \u2014 create new mangle rule on router"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Confirm"})," \u2014 persist ",(0,t.jsx)(n.code,{children:"DeviceRouting"})," record with returned ",(0,t.jsx)(n.code,{children:".id"})]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Merge"})," \u2014 publish ",(0,t.jsx)(n.code,{children:"device.routing.assigned"})," event"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"step-2-mangle-rule-creation",children:"Step 2: Mangle Rule Creation"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"createMangleRule(ctx, deviceID, macAddress, routingMark)"})," executes the router command"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"File:"})," ",(0,t.jsx)(n.code,{children:"internal/vif/routing/pbr_engine.go:366"})]}),"\n",(0,t.jsxs)(n.li,{children:["RouterOS command: ",(0,t.jsx)(n.code,{children:"/ip/firewall/mangle add"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"chain=prerouting"})," \u2014 intercepts incoming traffic before routing decision"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"src-mac-address={macAddress}"})," \u2014 matches traffic from the specific device"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"action=mark-routing"})," \u2014 sets the routing mark (does NOT modify the packet)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"new-routing-mark={routingMark}"})," \u2014 the VIF's routing mark (e.g., ",(0,t.jsx)(n.code,{children:'"tor-instance1"'}),")"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"passthrough=yes"})," \u2014 allows other mangle rules to also process the packet"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"comment=nnc-routing-{deviceID}"})," \u2014 used for reconciliation on startup"]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["Router returns the ",(0,t.jsx)(n.code,{children:".id"})," (e.g., ",(0,t.jsx)(n.code,{children:'"*17"'}),") for O(1) removal later"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"step-3-routing-table-lookup-routeros-runtime",children:"Step 3: Routing Table Lookup (RouterOS runtime)"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"When the device sends a packet, RouterOS evaluates mangle rules in chain=prerouting order"}),"\n",(0,t.jsxs)(n.li,{children:["The mangle rule sets ",(0,t.jsx)(n.code,{children:"routing-mark=tor-instance1"})," on matching packets"]}),"\n",(0,t.jsxs)(n.li,{children:["RouterOS then looks up the routing table named ",(0,t.jsx)(n.code,{children:'"tor-instance1"'})," (created by VIF factory)"]}),"\n",(0,t.jsxs)(n.li,{children:["The VIF routing table has a default route: ",(0,t.jsx)(n.code,{children:"0.0.0.0/0 via 10.99.{vlanID}.2"})]}),"\n",(0,t.jsxs)(n.li,{children:["The gateway ",(0,t.jsx)(n.code,{children:"10.99.{vlanID}.2"})," is the service's internal gateway (e.g., Tor transparent proxy)"]}),"\n",(0,t.jsxs)(n.li,{children:["Traffic exits through the VLAN interface ",(0,t.jsx)(n.code,{children:"nnc-tor-instance1"})]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"step-4-multi-hop-chain-routing",children:"Step 4: Multi-Hop Chain Routing"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"ChainRouter.CreateRoutingChain(ctx, routerID, input)"})," orchestrates multi-hop routing"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"File:"})," ",(0,t.jsx)(n.code,{children:"internal/vif/routing/chain_router.go:82"})]}),"\n",(0,t.jsx)(n.li,{children:"Validates input: 2-5 hops required, no duplicate interfaces (circular chain detection)"}),"\n",(0,t.jsxs)(n.li,{children:["Creates ",(0,t.jsx)(n.code,{children:"RoutingChain"})," DB record with: ",(0,t.jsx)(n.code,{children:"deviceID"}),", ",(0,t.jsx)(n.code,{children:"routingMode"}),", ",(0,t.jsx)(n.code,{children:"killSwitchEnabled"})]}),"\n",(0,t.jsxs)(n.li,{children:["Creates ordered ",(0,t.jsx)(n.code,{children:"ChainHop"})," records for each hop (with ",(0,t.jsx)(n.code,{children:"hopOrder"})," field)"]}),"\n",(0,t.jsxs)(n.li,{children:["For each consecutive hop pair (A\u2192B): creates an inter-hop mangle rule:","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Traffic arriving at Hop A's VLAN gets marked for Hop B's routing table"}),"\n",(0,t.jsx)(n.li,{children:"This creates a chain: Device MAC \u2192 VIF-A mark \u2192 VIF-B mark \u2192 ... \u2192 Internet"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"step-5-latency-measurement",children:"Step 5: Latency Measurement"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"ChainLatencyMeasurer"})," measures latency across the chain periodically"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"File:"})," ",(0,t.jsx)(n.code,{children:"internal/vif/routing/chain_latency.go"})]}),"\n",(0,t.jsx)(n.li,{children:"Sends probe packets through each hop in sequence and measures RTT"}),"\n",(0,t.jsxs)(n.li,{children:["Results stored as ",(0,t.jsx)(n.code,{children:"ChainHop.LatencyMs"})," and used for chain health scoring"]}),"\n",(0,t.jsx)(n.li,{children:'High latency (>4 hop chains warned at creation: "latency may be significant")'}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"step-6-kill-switch-activation",children:"Step 6: Kill Switch Activation"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"KillSwitchListener.Start()"})," subscribes to ",(0,t.jsx)(n.code,{children:"events.EventTypeHealthChanged"})]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"File:"})," ",(0,t.jsx)(n.code,{children:"internal/vif/isolation/kill_switch_listener.go:55"})]}),"\n",(0,t.jsxs)(n.li,{children:["On ",(0,t.jsx)(n.code,{children:"HEALTHY \u2192 UNHEALTHY"})," transition:","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Queries all ",(0,t.jsx)(n.code,{children:"DeviceRouting"})," records for ",(0,t.jsx)(n.code,{children:"instanceID"})," with ",(0,t.jsx)(n.code,{children:"killSwitchEnabled=true"})]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"KillSwitchManager.Activate(ctx, routingID)"})," creates a firewall filter rule:","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"/ip/firewall/filter add chain=forward routing-mark={mark} action=drop"})}),"\n",(0,t.jsx)(n.li,{children:"Rule blocks all forwarded traffic for that routing mark (internet cut)"}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["Stores ",(0,t.jsx)(n.code,{children:"killSwitchRuleID"})," and ",(0,t.jsx)(n.code,{children:"killSwitchActivatedAt"})," in DB"]}),"\n",(0,t.jsxs)(n.li,{children:["Publishes ",(0,t.jsx)(n.code,{children:"kill_switch.activated"})," event"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"step-7-kill-switch-deactivation",children:"Step 7: Kill Switch Deactivation"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["On ",(0,t.jsx)(n.code,{children:"UNHEALTHY \u2192 HEALTHY"})," transition:","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"KillSwitchManager.Deactivate(ctx, routingID)"})," removes the filter rule:","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"/ip/firewall/filter remove .id={killSwitchRuleID}"})," (O(1) via stored ID)"]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["Clears ",(0,t.jsx)(n.code,{children:"killSwitchRuleID"})," in DB"]}),"\n",(0,t.jsxs)(n.li,{children:["Calculates ",(0,t.jsx)(n.code,{children:"activeFor"})," duration from ",(0,t.jsx)(n.code,{children:"killSwitchActivatedAt"})]}),"\n",(0,t.jsxs)(n.li,{children:["Publishes ",(0,t.jsx)(n.code,{children:"kill_switch.deactivated"})," event"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"step-8-startup-reconciliation",children:"Step 8: Startup Reconciliation"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["On boot, ",(0,t.jsx)(n.code,{children:"PBREngine.ReconcileOnStartup(ctx)"})," handles three scenarios:","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Missing rules:"})," In DB but not on router \u2192 recreate mangle rule"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Orphaned rules:"})," On router (comment=",(0,t.jsx)(n.code,{children:"nnc-routing-*"}),") but not in DB \u2192 remove"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Deleted VIF cascade:"})," DeviceRouting references non-existent ServiceInstance \u2192 remove both"]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"File:"})," ",(0,t.jsx)(n.code,{children:"internal/vif/routing/pbr_engine.go:231"})]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"error-handling",children:"Error Handling"}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Scenario"}),(0,t.jsx)(n.th,{children:"Behavior"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Conflict removal fails"}),(0,t.jsx)(n.td,{children:"Error returned; new rule NOT created (atomic guard)"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Mangle rule creation fails"}),(0,t.jsx)(n.td,{children:"Error returned; DB record NOT created"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"DB persist fails after mangle created"}),(0,t.jsx)(n.td,{children:"Best-effort rollback: remove the mangle rule just created"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Kill switch activation fails"}),(0,t.jsx)(n.td,{children:"Error logged per routing; other routings still processed"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Kill switch deactivation fails"}),(0,t.jsx)(n.td,{children:"Error logged; device remains blocked until manual intervention"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Startup reconciliation error"}),(0,t.jsx)(n.td,{children:"Logged; startup continues (non-fatal)"})]})]})]}),"\n",(0,t.jsx)(n.h2,{id:"observability",children:"Observability"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Events emitted (event bus):"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"device.routing.assigned"})," \u2014 when a device is assigned to a service"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"device.routing.removed"})," \u2014 when assignment is removed"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"routing.chain.created"})," \u2014 when a multi-hop chain is established"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"routing.chain.removed"})," \u2014 when a chain is torn down"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"kill_switch.activated"})," \u2014 when kill switch blocks a device (with mode, reason, state)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"kill_switch.deactivated"})," \u2014 when kill switch is lifted (with activeFor duration)"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Logs generated:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"INFO: Creating routing chain"})," with device_id, hop_count"]}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"WARN: Chain has 4+ hops - latency may be significant"})}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"WARN: Failed to remove single-hop mangle rule"})," on chain cleanup"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"ERROR: failed to activate kill switch"})," with routing_id and device_id"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"INFO: Reconciliation complete"})," with missing/orphaned/cascade counts"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"cross-references",children:"Cross-References"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"[See: 07-virtual-interface-factory.md \xa7VIF] \u2014 how VLAN interfaces and routing tables are created"}),"\n",(0,t.jsx)(n.li,{children:"[See: 06-service-orchestrator.md \xa7Health] \u2014 health state machine that triggers kill switch events"}),"\n",(0,t.jsx)(n.li,{children:"[See: 08-provisioning-engine.md \xa7Phase6] \u2014 routing table and rule provisioning in Phase 6"}),"\n",(0,t.jsx)(n.li,{children:"[See: 05-event-system.md \xa7HealthEvents] \u2014 FeatureHealthChangedEvent structure"}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,l.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},71184:(e,n,i)=>{i.d(n,{R:()=>s,x:()=>c});var r=i(14041);const t={},l=r.createContext(t);function s(e){const n=r.useContext(l);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:s(e.components),r.createElement(l.Provider,{value:n},e.children)}}}]);