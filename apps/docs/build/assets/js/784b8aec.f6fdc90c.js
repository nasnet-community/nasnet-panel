"use strict";(globalThis.webpackChunk_nas_net_docs=globalThis.webpackChunk_nas_net_docs||[]).push([[23145],{28699:(n,e,t)=>{t.r(e),t.d(e,{assets:()=>d,contentTitle:()=>o,default:()=>h,frontMatter:()=>r,metadata:()=>c,toc:()=>a});const c=JSON.parse('{"id":"machines/vpn-connection","title":"VPN Connection Machine (Feature Example)","description":"The VPN Connection Machine demonstrates a practical XState machine for VPN lifecycle management. It handles connection, disconnection, automatic reconnection with exponential backoff, and real-time metrics collection.","source":"@site/../../libs/state/docs/machines/vpn-connection.md","sourceDirName":"machines","slug":"/machines/vpn-connection","permalink":"/docs/state/machines/vpn-connection","draft":false,"unlisted":false,"editUrl":"https://github.com/nasnet-community/nasnet-panel/tree/main/../../libs/state/docs/machines/vpn-connection.md","tags":[],"version":"current","frontMatter":{},"sidebar":"sidebar","previous":{"title":"Resource Lifecycle Machine (Universal State v2)","permalink":"/docs/state/machines/resource-lifecycle"},"next":{"title":"Wizard Machine (Multi-Step Flows)","permalink":"/docs/state/machines/wizard"}}');var s=t(31085),i=t(71184);const r={},o="VPN Connection Machine (Feature Example)",d={},a=[{value:"Complete State Chart",id:"complete-state-chart",level:2},{value:"States Reference",id:"states-reference",level:2},{value:"Context",id:"context",level:2},{value:"Events",id:"events",level:2},{value:"Guards",id:"guards",level:2},{value:"Configuration",id:"configuration",level:2},{value:"Constants",id:"constants",level:2},{value:"Usage with <code>useVPNConnection</code> Hook",id:"usage-with-usevpnconnection-hook",level:2},{value:"Hook Return Type",id:"hook-return-type",level:2},{value:"Code Examples",id:"code-examples",level:2},{value:"Connect to VPN",id:"connect-to-vpn",level:3},{value:"Automatic Reconnection with Backoff",id:"automatic-reconnection-with-backoff",level:3},{value:"Real-time Metrics",id:"real-time-metrics",level:3},{value:"Handle Connection Loss with Auto-Reconnect",id:"handle-connection-loss-with-auto-reconnect",level:3},{value:"Error Scenarios",id:"error-scenarios",level:2},{value:"Scenario 1: Connection Timeout",id:"scenario-1-connection-timeout",level:3},{value:"Scenario 2: Connection Lost (Auto-Reconnect)",id:"scenario-2-connection-lost-auto-reconnect",level:3},{value:"Scenario 3: Max Reconnect Attempts Exceeded",id:"scenario-3-max-reconnect-attempts-exceeded",level:3},{value:"Comparing with Other State Management",id:"comparing-with-other-state-management",level:2},{value:"Building Your Own Feature Machine",id:"building-your-own-feature-machine",level:2},{value:"Related Documentation",id:"related-documentation",level:2}];function l(n){const e={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",mermaid:"mermaid",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,i.R)(),...n.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(e.header,{children:(0,s.jsx)(e.h1,{id:"vpn-connection-machine-feature-example",children:"VPN Connection Machine (Feature Example)"})}),"\n",(0,s.jsxs)(e.p,{children:["The ",(0,s.jsx)(e.strong,{children:"VPN Connection Machine"})," demonstrates a practical XState machine for VPN lifecycle management. It handles connection, disconnection, automatic reconnection with exponential backoff, and real-time metrics collection."]}),"\n",(0,s.jsxs)(e.p,{children:["This is an ",(0,s.jsx)(e.strong,{children:"example implementation"})," showing how to build feature-specific machines. In a real project, this would be located in ",(0,s.jsx)(e.code,{children:"libs/features/vpn/src/machines/"}),"."]}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Source:"})," ",(0,s.jsx)(e.code,{children:"libs/state/machines/src/vpnConnectionMachine.ts"}),"\n",(0,s.jsx)(e.strong,{children:"Hook:"})," ",(0,s.jsx)(e.code,{children:"libs/state/machines/src/vpnConnectionMachine.ts"})," (exported as ",(0,s.jsx)(e.code,{children:"useVPNConnection"}),")"]}),"\n",(0,s.jsx)(e.h2,{id:"complete-state-chart",children:"Complete State Chart"}),"\n",(0,s.jsx)(e.mermaid,{value:"stateDiagram-v2\n    [*] --\x3e DISCONNECTED\n\n    DISCONNECTED --\x3e CONNECTING: CONNECT\\n(serverAddress, provider)\n\n    CONNECTING --\x3e CONNECTED: onDone\n    CONNECTING --\x3e ERROR: onError\\n(timeout: 30s)\n\n    CONNECTED --\x3e DISCONNECTING: DISCONNECT\n    CONNECTED --\x3e RECONNECTING: CONN_LOST\n    CONNECTED --\x3e CONNECTED: METRICS_UPDATE\n\n    ERROR --\x3e CONNECTING: RETRY\n    ERROR --\x3e DISCONNECTED: DISMISS\n\n    RECONNECTING --\x3e CONNECTED: onDone\\n(success)\n    RECONNECTING --\x3e RECONNECTING: onError\\n(canReconnect)\\n(exponential backoff)\n    RECONNECTING --\x3e DISCONNECTED: onError\\n(!canReconnect)\n\n    DISCONNECTING --\x3e DISCONNECTED: onDone/onError\n\n    DISCONNECTED --\x3e [*]\n    CONNECTED --\x3e [*]\n    ERROR --\x3e [*]"}),"\n",(0,s.jsx)(e.h2,{id:"states-reference",children:"States Reference"}),"\n",(0,s.jsxs)(e.table,{children:[(0,s.jsx)(e.thead,{children:(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.th,{children:"State"}),(0,s.jsx)(e.th,{children:"Purpose"}),(0,s.jsx)(e.th,{children:"Duration"}),(0,s.jsx)(e.th,{children:"Transitions"})]})}),(0,s.jsxs)(e.tbody,{children:[(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:(0,s.jsx)(e.strong,{children:"disconnected"})}),(0,s.jsx)(e.td,{children:"Not connected to VPN"}),(0,s.jsx)(e.td,{children:"Indefinite"}),(0,s.jsx)(e.td,{children:"CONNECT \u2192 connecting"})]}),(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:(0,s.jsx)(e.strong,{children:"connecting"})}),(0,s.jsx)(e.td,{children:"Establishing VPN connection"}),(0,s.jsx)(e.td,{children:"30s timeout"}),(0,s.jsx)(e.td,{children:"onDone \u2192 connected, onError/timeout \u2192 error"})]}),(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:(0,s.jsx)(e.strong,{children:"connected"})}),(0,s.jsx)(e.td,{children:"Active VPN connection"}),(0,s.jsx)(e.td,{children:"Indefinite"}),(0,s.jsx)(e.td,{children:"DISCONNECT \u2192 disconnecting, METRICS_UPDATE (stay), CONNECTION_LOST \u2192 reconnecting"})]}),(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:(0,s.jsx)(e.strong,{children:"reconnecting"})}),(0,s.jsx)(e.td,{children:"Attempting to reconnect"}),(0,s.jsx)(e.td,{children:"10s timeout + backoff"}),(0,s.jsx)(e.td,{children:"onDone \u2192 connected, onError (retry or give up)"})]}),(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:(0,s.jsx)(e.strong,{children:"disconnecting"})}),(0,s.jsx)(e.td,{children:"Gracefully closing connection"}),(0,s.jsx)(e.td,{children:"5-10s"}),(0,s.jsx)(e.td,{children:"onDone/onError \u2192 disconnected"})]}),(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:(0,s.jsx)(e.strong,{children:"error"})}),(0,s.jsx)(e.td,{children:"Connection error"}),(0,s.jsx)(e.td,{children:"Indefinite"}),(0,s.jsx)(e.td,{children:"RETRY \u2192 connecting, DISMISS \u2192 disconnected"})]})]})]}),"\n",(0,s.jsx)(e.h2,{id:"context",children:"Context"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-typescript",children:"interface VPNConnectionContext {\n  /** Connection ID (if connected) */\n  connectionId: string | null;\n\n  /** VPN provider name (wireguard, openvpn, etc.) */\n  provider: string | null;\n\n  /** Server address */\n  serverAddress: string | null;\n\n  /** Real-time connection metrics */\n  metrics: ConnectionMetrics | null;\n\n  /** Error message if in error state */\n  error: string | null;\n\n  /** Reconnection attempt count */\n  reconnectAttempts: number;\n\n  /** Maximum reconnection attempts before giving up */\n  maxReconnectAttempts: number;\n}\n\ninterface ConnectionMetrics {\n  uploadSpeed: number;              // bytes/sec\n  downloadSpeed: number;            // bytes/sec\n  bytesUploaded: number;\n  bytesDownloaded: number;\n  latencyMs: number;\n  uptimeSeconds: number;\n  serverLocation?: string;\n}\n"})}),"\n",(0,s.jsx)(e.h2,{id:"events",children:"Events"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-typescript",children:"type VPNConnectionEvent =\n  | { type: 'CONNECT'; serverAddress: string; provider: string }\n  | { type: 'DISCONNECT' }\n  | { type: 'METRICS_UPDATE'; metrics: ConnectionMetrics }\n  | { type: 'CONNECTION_LOST' }\n  | { type: 'RETRY' }\n  | { type: 'DISMISS' };\n"})}),"\n",(0,s.jsx)(e.h2,{id:"guards",children:"Guards"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-typescript",children:"{\n  canReconnect: boolean;    // reconnectAttempts < maxReconnectAttempts\n  hasConnectionId: boolean; // connectionId !== null\n}\n"})}),"\n",(0,s.jsx)(e.h2,{id:"configuration",children:"Configuration"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-typescript",children:"interface VPNConnectionServices {\n  /** Establish VPN connection */\n  establishConnection: (params: {\n    serverAddress: string;\n    provider: string;\n    attempt?: number;\n  }) => Promise<{ connectionId: string }>;\n\n  /** Attempt to reconnect */\n  attemptReconnect: (params: {\n    serverAddress: string;\n    provider: string;\n    attempt?: number;\n  }) => Promise<{ connectionId: string }>;\n\n  /** Close VPN connection */\n  closeConnection: (connectionId: string) => Promise<void>;\n}\n"})}),"\n",(0,s.jsx)(e.h2,{id:"constants",children:"Constants"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-typescript",children:"const CONNECTION_TIMEOUT_MS = 30000;       // 30 seconds to establish\nconst RECONNECTION_TIMEOUT_MS = 10000;     // 10 seconds per reconnect attempt\nconst MAX_RECONNECT_ATTEMPTS = 3;          // Try up to 3 times\nconst BACKOFF_BASE_MS = 1000;              // 1s, 2s, 4s, 8s...\n"})}),"\n",(0,s.jsxs)(e.h2,{id:"usage-with-usevpnconnection-hook",children:["Usage with ",(0,s.jsx)(e.code,{children:"useVPNConnection"})," Hook"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-tsx",children:"import { useVPNConnection } from '@nasnet/state/machines';\n\nfunction VPNStatus() {\n  const vpn = useVPNConnection({\n    establishConnection: async ({ serverAddress, provider }) => {\n      const response = await api.connectVPN(serverAddress, provider);\n      return { connectionId: response.id };\n    },\n    attemptReconnect: async ({ serverAddress, provider, attempt }) => {\n      const response = await api.reconnectVPN(serverAddress, provider);\n      return { connectionId: response.id };\n    },\n    closeConnection: async (connectionId) => {\n      await api.disconnectVPN(connectionId);\n    },\n  });\n\n  // Subscribe to metrics updates\n  useEffect(() => {\n    if (!vpn.isConnected) return;\n\n    const interval = setInterval(() => {\n      const metrics = getMetrics(vpn.connectionId!);\n      vpn.updateMetrics(metrics);\n    }, 1000);\n\n    return () => clearInterval(interval);\n  }, [vpn.isConnected, vpn.connectionId]);\n\n  // Subscribe to connection status\n  useEffect(() => {\n    if (!vpn.isConnected) return;\n\n    const unsubscribe = subscribeToConnectionStatus(\n      vpn.connectionId!,\n      (status) => {\n        if (status === 'lost') {\n          vpn.reportConnectionLost();\n        }\n      }\n    );\n\n    return unsubscribe;\n  }, [vpn.isConnected, vpn.connectionId]);\n\n  return (\n    <div className=\"vpn-status\">\n      <StatusBadge\n        status={vpn.state}\n        label={vpn.isConnected ? 'Connected' : 'Disconnected'}\n        spinner={vpn.isConnecting}\n      />\n\n      {vpn.isConnected && vpn.metrics && (\n        <MetricsDisplay\n          uploadSpeed={vpn.metrics.uploadSpeed}\n          downloadSpeed={vpn.metrics.downloadSpeed}\n          latency={vpn.metrics.latencyMs}\n          uptime={vpn.metrics.uptimeSeconds}\n          location={vpn.metrics.serverLocation}\n        />\n      )}\n\n      {vpn.isError && (\n        <ErrorPanel\n          error={vpn.error}\n          attempts={vpn.reconnectAttempts}\n          maxAttempts={3}\n          onRetry={vpn.retry}\n          onDismiss={vpn.dismissError}\n        />\n      )}\n\n      <VPNControls\n        onConnect={() =>\n          vpn.connect('vpn.example.com', 'wireguard')\n        }\n        onDisconnect={vpn.disconnect}\n        disabled={vpn.isConnecting}\n        connected={vpn.isConnected}\n      />\n    </div>\n  );\n}\n"})}),"\n",(0,s.jsx)(e.h2,{id:"hook-return-type",children:"Hook Return Type"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-typescript",children:"interface UseVPNConnectionReturn {\n  // State\n  state: 'disconnected' | 'connecting' | 'connected' | 'reconnecting' | 'disconnecting' | 'error';\n  connectionId: string | null;\n  provider: string | null;\n  serverAddress: string | null;\n  metrics: ConnectionMetrics | null;\n  error: string | null;\n  reconnectAttempts: number;\n\n  // Predicates\n  isConnected: boolean;\n  isConnecting: boolean;\n  isError: boolean;\n\n  // Actions\n  connect: (serverAddress: string, provider: string) => void;\n  disconnect: () => void;\n  retry: () => void;\n  dismissError: () => void;\n  updateMetrics: (metrics: ConnectionMetrics) => void;\n  reportConnectionLost: () => void;\n}\n"})}),"\n",(0,s.jsx)(e.h2,{id:"code-examples",children:"Code Examples"}),"\n",(0,s.jsx)(e.h3,{id:"connect-to-vpn",children:"Connect to VPN"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-tsx",children:"const handleConnect = () => {\n  vpn.connect('vpn.example.com', 'wireguard');\n  // Transitions: disconnected \u2192 connecting\n  // After 30s: \u2192 connected (on success) or error (on failure)\n};\n"})}),"\n",(0,s.jsx)(e.h3,{id:"automatic-reconnection-with-backoff",children:"Automatic Reconnection with Backoff"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{children:"Attempt 1: delay = 1000ms (1s)\n\u251c\u2500 After delay, invoke attemptReconnect\n\u251c\u2500 If fails and attempts < 3 \u2192 Attempt 2\n\nAttempt 2: delay = 2000ms (2s)\n\u251c\u2500 After delay, invoke attemptReconnect\n\u251c\u2500 If fails and attempts < 3 \u2192 Attempt 3\n\nAttempt 3: delay = 4000ms (4s)\n\u251c\u2500 After delay, invoke attemptReconnect\n\u251c\u2500 If fails \u2192 Give up, transition to disconnected\n"})}),"\n",(0,s.jsx)(e.h3,{id:"real-time-metrics",children:"Real-time Metrics"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-tsx",children:"// Metrics update while connected (every 1s)\nuseEffect(() => {\n  if (!vpn.isConnected) return;\n\n  const updateMetrics = async () => {\n    const metrics = await api.getVPNMetrics();\n    vpn.updateMetrics({\n      uploadSpeed: metrics.upload_bps,\n      downloadSpeed: metrics.download_bps,\n      bytesUploaded: metrics.bytes_sent,\n      bytesDownloaded: metrics.bytes_recv,\n      latencyMs: metrics.ping_ms,\n      uptimeSeconds: metrics.uptime_s,\n      serverLocation: metrics.location,\n    });\n  };\n\n  const interval = setInterval(updateMetrics, 1000);\n  return () => clearInterval(interval);\n}, [vpn.isConnected]);\n\n// Display metrics\n{vpn.isConnected && (\n  <MetricsPanel\n    download={`${(vpn.metrics.downloadSpeed / 1e6).toFixed(1)} Mbps`}\n    upload={`${(vpn.metrics.uploadSpeed / 1e6).toFixed(1)} Mbps`}\n    latency={`${vpn.metrics.latencyMs} ms`}\n  />\n)}\n"})}),"\n",(0,s.jsx)(e.h3,{id:"handle-connection-loss-with-auto-reconnect",children:"Handle Connection Loss with Auto-Reconnect"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-tsx",children:"// Subscribe to connection health\nuseEffect(() => {\n  if (!vpn.isConnected) return;\n\n  const unsubscribe = vpnService.onConnectionStatus(\n    vpn.connectionId!,\n    (status) => {\n      if (status.type === 'connection_lost') {\n        // Trigger reconnection with backoff\n        vpn.reportConnectionLost();\n        // Transitions: connected \u2192 reconnecting\n        // Auto-attempts up to 3 times with exponential backoff\n      }\n    }\n  );\n\n  return unsubscribe;\n}, [vpn.isConnected]);\n"})}),"\n",(0,s.jsx)(e.h2,{id:"error-scenarios",children:"Error Scenarios"}),"\n",(0,s.jsx)(e.h3,{id:"scenario-1-connection-timeout",children:"Scenario 1: Connection Timeout"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{children:"User clicks Connect\n\u2192 CONNECTING (30s timeout)\n\u2192 Server doesn't respond\n\u2192 ERROR (timeout error)\n\u2192 User can RETRY or DISMISS\n"})}),"\n",(0,s.jsx)(e.h3,{id:"scenario-2-connection-lost-auto-reconnect",children:"Scenario 2: Connection Lost (Auto-Reconnect)"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{children:"CONNECTED (stable for 60s)\n\u2192 Connection drops (router restart, network issue)\n\u2192 CONNECTION_LOST event\n\u2192 RECONNECTING (backoff 1s)\n  \u2192 Failed, retry\n\u2192 RECONNECTING (backoff 2s)\n  \u2192 Failed, retry\n\u2192 RECONNECTING (backoff 4s)\n  \u2192 Succeeded!\n\u2192 CONNECTED (reset attempts)\n"})}),"\n",(0,s.jsx)(e.h3,{id:"scenario-3-max-reconnect-attempts-exceeded",children:"Scenario 3: Max Reconnect Attempts Exceeded"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{children:"CONNECTED\n\u2192 CONNECTION_LOST\n\u2192 RECONNECTING (attempt 1) \u2192 fail\n\u2192 RECONNECTING (attempt 2) \u2192 fail\n\u2192 RECONNECTING (attempt 3) \u2192 fail\n\u2192 canReconnect guard fails\n\u2192 DISCONNECTED (give up)\n"})}),"\n",(0,s.jsx)(e.h2,{id:"comparing-with-other-state-management",children:"Comparing with Other State Management"}),"\n",(0,s.jsxs)(e.table,{children:[(0,s.jsx)(e.thead,{children:(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.th,{children:"Aspect"}),(0,s.jsx)(e.th,{children:"VPN Machine"}),(0,s.jsx)(e.th,{children:"Zustand Store"}),(0,s.jsx)(e.th,{children:"Apollo Client"})]})}),(0,s.jsxs)(e.tbody,{children:[(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:(0,s.jsx)(e.strong,{children:"State"})}),(0,s.jsx)(e.td,{children:"connection + metrics"}),(0,s.jsx)(e.td,{children:"\u2713 Can store"}),(0,s.jsx)(e.td,{children:"N/A"})]}),(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:(0,s.jsx)(e.strong,{children:"Async Operations"})}),(0,s.jsx)(e.td,{children:"Built-in (actors)"}),(0,s.jsx)(e.td,{children:"Need middleware"}),(0,s.jsx)(e.td,{children:"Built-in (mutations)"})]}),(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:(0,s.jsx)(e.strong,{children:"Auto-Reconnect"})}),(0,s.jsx)(e.td,{children:"\u2713 Built-in backoff"}),(0,s.jsx)(e.td,{children:"Manual logic"}),(0,s.jsx)(e.td,{children:"N/A"})]}),(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:(0,s.jsx)(e.strong,{children:"Metrics Updates"})}),(0,s.jsx)(e.td,{children:"Real-time"}),(0,s.jsx)(e.td,{children:"Manual updates"}),(0,s.jsx)(e.td,{children:"Subscriptions"})]}),(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:(0,s.jsx)(e.strong,{children:"Persistence"})}),(0,s.jsx)(e.td,{children:"Via persistence.ts"}),(0,s.jsx)(e.td,{children:"Built-in"}),(0,s.jsx)(e.td,{children:"N/A"})]}),(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:(0,s.jsx)(e.strong,{children:"Use Case"})}),(0,s.jsx)(e.td,{children:"VPN connection lifecycle"}),(0,s.jsx)(e.td,{children:"Global UI state"}),(0,s.jsx)(e.td,{children:"Backend data sync"})]})]})]}),"\n",(0,s.jsx)(e.h2,{id:"building-your-own-feature-machine",children:"Building Your Own Feature Machine"}),"\n",(0,s.jsx)(e.p,{children:"This VPN example shows the pattern for building feature-specific machines:"}),"\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Define Context"})," - What data does this feature hold?"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Define Events"})," - What can the user/system do?"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Define States"})," - What states can the feature be in?"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Define Transitions"})," - How do events move between states?"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Define Actors"})," - What async operations are needed?"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Create Hook"})," - Wrap machine in a React hook for easy use"]}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:"Apply this pattern to build machines for:"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"DNS configuration"}),"\n",(0,s.jsx)(e.li,{children:"Firewall rules"}),"\n",(0,s.jsx)(e.li,{children:"Service mesh networking"}),"\n",(0,s.jsx)(e.li,{children:"Backup/restore operations"}),"\n"]}),"\n",(0,s.jsx)(e.h2,{id:"related-documentation",children:"Related Documentation"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Overview:"})," See ",(0,s.jsx)(e.code,{children:"overview.md"})," for machine catalog and factory pattern"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Persistence:"})," See ",(0,s.jsx)(e.code,{children:"persistence.md"})," for saving connection state"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Hooks Pattern:"})," See ",(0,s.jsx)(e.code,{children:"wizard.md"})," for useWizard hook pattern (similar structure)"]}),"\n"]})]})}function h(n={}){const{wrapper:e}={...(0,i.R)(),...n.components};return e?(0,s.jsx)(e,{...n,children:(0,s.jsx)(l,{...n})}):l(n)}},71184:(n,e,t)=>{t.d(e,{R:()=>r,x:()=>o});var c=t(14041);const s={},i=c.createContext(s);function r(n){const e=c.useContext(i);return c.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function o(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(s):n.components||s:r(n.components),c.createElement(i.Provider,{value:e},n.children)}}}]);