"use strict";(globalThis.webpackChunk_nas_net_docs=globalThis.webpackChunk_nas_net_docs||[]).push([[7200],{45591:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>o,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"state-management/overview","title":"State Management Overview","description":"The apps/connect frontend uses a four-layer state architecture. Each layer handles a distinct","source":"@site/../connect/docs/state-management/overview.md","sourceDirName":"state-management","slug":"/state-management/overview","permalink":"/docs/frontend/state-management/overview","draft":false,"unlisted":false,"editUrl":"https://github.com/nasnet-community/nasnet-panel/tree/main/../connect/docs/state-management/overview.md","tags":[],"version":"current","frontMatter":{},"sidebar":"sidebar","previous":{"title":"Drift Detection System","permalink":"/docs/frontend/state-management/drift-detection"},"next":{"title":"XState State Machines","permalink":"/docs/frontend/state-management/xstate-machines"}}');var r=t(31085),i=t(71184);const o={},a="State Management Overview",l={},c=[{value:"The Four Layers",id:"the-four-layers",level:2},{value:"Layer 1: Server State \u2014 Apollo Client",id:"layer-1-server-state--apollo-client",level:2},{value:"Layer 2: UI State \u2014 Zustand",id:"layer-2-ui-state--zustand",level:2},{value:"Layer 3: Complex Flows \u2014 XState",id:"layer-3-complex-flows--xstate",level:2},{value:"Layer 4: Form State \u2014 React Hook Form + Zod",id:"layer-4-form-state--react-hook-form--zod",level:2},{value:"Decision Tree",id:"decision-tree",level:2},{value:"Cross-Layer Interactions",id:"cross-layer-interactions",level:2},{value:"Provider Initialization Order",id:"provider-initialization-order",level:2},{value:"Performance Guidelines",id:"performance-guidelines",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",header:"header",hr:"hr",li:"li",mermaid:"mermaid",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"state-management-overview",children:"State Management Overview"})}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"apps/connect"})," frontend uses a four-layer state architecture. Each layer handles a distinct\nclass of state, and the choice of tool for any given piece of state follows from which layer it\nbelongs to."]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"the-four-layers",children:"The Four Layers"}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Layer"}),(0,r.jsx)(n.th,{children:"Tool"}),(0,r.jsx)(n.th,{children:"Scope"}),(0,r.jsx)(n.th,{children:"Persistence"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"1. Server State"}),(0,r.jsx)(n.td,{children:"Apollo Client"}),(0,r.jsx)(n.td,{children:"Router config, resources, GraphQL data"}),(0,r.jsx)(n.td,{children:"Cache + optional IndexedDB"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"2. UI State"}),(0,r.jsx)(n.td,{children:"Zustand"}),(0,r.jsx)(n.td,{children:"Auth, connection, theme, modals, notifications"}),(0,r.jsx)(n.td,{children:"localStorage (selectively)"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"3. Complex Flows"}),(0,r.jsx)(n.td,{children:"XState"}),(0,r.jsx)(n.td,{children:"Config pipeline, change sets, wizards, VPN lifecycle"}),(0,r.jsx)(n.td,{children:"In-memory (session)"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"4. Form State"}),(0,r.jsx)(n.td,{children:"React Hook Form + Zod"}),(0,r.jsx)(n.td,{children:"Field values, errors, touched state, submission"}),(0,r.jsx)(n.td,{children:"In-memory (form lifetime)"})]})]})]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"layer-1-server-state--apollo-client",children:"Layer 1: Server State \u2014 Apollo Client"}),"\n",(0,r.jsx)(n.p,{children:"Apollo Client is the source of truth for all data that originates on the router or backend. It\nmanages fetching, caching, subscriptions, and cache normalization."}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Use Apollo when:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Data comes from a GraphQL query or mutation"}),"\n",(0,r.jsx)(n.li,{children:"You need real-time updates via subscriptions"}),"\n",(0,r.jsx)(n.li,{children:"Multiple components share the same server data"}),"\n",(0,r.jsx)(n.li,{children:"You want automatic cache invalidation and updates"}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-tsx",children:"// Queries and mutations via generated hooks\nimport { useGetRouterQuery } from '@nasnet/api-client/queries';\n\nfunction RouterStatus({ routerId }: { routerId: string }) {\n  const { data, loading, error } = useGetRouterQuery({\n    variables: { routerId },\n  });\n  // ...\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["See ",(0,r.jsx)(n.code,{children:"apollo-client.md"})," for full configuration details."]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"layer-2-ui-state--zustand",children:"Layer 2: UI State \u2014 Zustand"}),"\n",(0,r.jsxs)(n.p,{children:["Zustand stores hold global client-side state that is not server-derived. All stores live in\n",(0,r.jsx)(n.code,{children:"libs/state/stores/src/"}),"."]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Use Zustand when:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"State affects multiple unrelated components"}),"\n",(0,r.jsx)(n.li,{children:"State must persist across page navigations (theme, auth tokens)"}),"\n",(0,r.jsx)(n.li,{children:"State is purely client-side (no server round-trip needed)"}),"\n",(0,r.jsx)(n.li,{children:"You need to access state outside React (e.g., in Apollo links)"}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-tsx",children:"// Selector pattern \u2014 always prefer granular selectors\nconst isAuthenticated = useAuthStore((state) => state.isAuthenticated);\nconst wsStatus = useConnectionStore((state) => state.wsStatus);\n"})}),"\n",(0,r.jsxs)(n.p,{children:["See ",(0,r.jsx)(n.code,{children:"zustand-stores.md"})," for a complete inventory of all stores."]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"layer-3-complex-flows--xstate",children:"Layer 3: Complex Flows \u2014 XState"}),"\n",(0,r.jsxs)(n.p,{children:["XState v5 machines model multi-step workflows where the sequence of operations and possible error\npaths must be explicit. All machines live in ",(0,r.jsx)(n.code,{children:"libs/state/machines/src/"}),"."]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Use XState when:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"A feature has distinct sequential states (e.g., draft \u2192 validating \u2192 applying \u2192 verified)"}),"\n",(0,r.jsx)(n.li,{children:"Incorrect state transitions would cause data loss or router misconfiguration"}),"\n",(0,r.jsx)(n.li,{children:"Multiple async operations must coordinate with rollback support"}),"\n",(0,r.jsx)(n.li,{children:"A wizard collects data across steps with per-step validation"}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-tsx",children:"import { useActor } from '@xstate/react';\nimport { createConfigPipelineMachine } from '@nasnet/state/machines';\n\nconst machine = createConfigPipelineMachine({ ... });\nconst [state, send] = useActor(machine);\n\nsend({ type: 'EDIT', config: newConfig });\n"})}),"\n",(0,r.jsxs)(n.p,{children:["See ",(0,r.jsx)(n.code,{children:"xstate-machines.md"})," for all machine definitions and state diagrams."]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"layer-4-form-state--react-hook-form--zod",children:"Layer 4: Form State \u2014 React Hook Form + Zod"}),"\n",(0,r.jsx)(n.p,{children:"Forms maintain their own local state through React Hook Form. Zod schemas define validation rules.\nThis state is ephemeral and scoped to the form's lifetime."}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Use React Hook Form when:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Managing a form with field-level validation"}),"\n",(0,r.jsx)(n.li,{children:"Handling submission, dirty state, and touched fields"}),"\n",(0,r.jsx)(n.li,{children:"Performing async validation against the backend"}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-tsx",children:"import { useForm } from 'react-hook-form';\nimport { zodResolver } from '@hookform/resolvers/zod';\nimport { z } from 'zod';\n\nconst schema = z.object({\n  address: z.string().ip({ version: 'v4' }),\n  port: z.number().int().min(1).max(65535),\n});\n\nconst form = useForm({\n  resolver: zodResolver(schema),\n  defaultValues: { address: '', port: 8728 },\n});\n"})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"decision-tree",children:"Decision Tree"}),"\n",(0,r.jsx)(n.p,{children:"Use the following questions in order:"}),"\n",(0,r.jsx)(n.mermaid,{value:'flowchart TD\n    Q1{"Data from the\\nrouter or backend?"}\n    Q1 --\x3e|YES| Apollo["Apollo Client\\n(useQuery, useMutation,\\nuseSubscription)"]\n    Q1 --\x3e|NO| Q2{"Multi-step workflow\\nwith async operations\\nor rollback?"}\n    Q2 --\x3e|YES| XState[XState machine]\n    Q2 --\x3e|NO| Q3{"Scoped to a\\nsingle form?"}\n    Q3 --\x3e|YES| RHF["React Hook Form + Zod"]\n    Q3 --\x3e|NO| Q4{"Global client-side state?\\n(auth, theme, UI prefs,\\nconnection, notifications)"}\n    Q4 --\x3e|YES| Zustand[Zustand store]\n    Q4 --\x3e|NO| Reeval["Re-evaluate \u2014 you likely\\nfit one of the above"]'}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"cross-layer-interactions",children:"Cross-Layer Interactions"}),"\n",(0,r.jsx)(n.p,{children:"The layers interact in predictable ways:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Apollo links read Zustand stores"})," \u2014 The auth link reads ",(0,r.jsx)(n.code,{children:"useAuthStore"})," to inject JWT tokens.\nThe WebSocket client reads ",(0,r.jsx)(n.code,{children:"useConnectionStore"})," for the active router ID."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"XState machines call Apollo"})," \u2014 Pipeline and change set machines invoke GraphQL mutations as\ntheir ",(0,r.jsx)(n.code,{children:"applyConfig"})," / ",(0,r.jsx)(n.code,{children:"applyItem"})," services."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Zustand stores trigger XState events"})," \u2014 Connection loss detected in ",(0,r.jsx)(n.code,{children:"useConnectionStore"})," can\ndrive a reconnection machine."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Forms submit via Apollo mutations"})," \u2014 React Hook Form ",(0,r.jsx)(n.code,{children:"onSubmit"})," typically calls a ",(0,r.jsx)(n.code,{children:"useMutation"}),"\nhook."]}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"provider-initialization-order",children:"Provider Initialization Order"}),"\n",(0,r.jsxs)(n.p,{children:["State providers initialize in a specific order to satisfy dependencies. See\n",(0,r.jsx)(n.code,{children:"../architecture/provider-stack.md"})," for the full provider stack."]}),"\n",(0,r.jsx)(n.p,{children:"At a high level:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Zustand stores"})," initialize lazily on first use (no provider needed)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Apollo Provider"})," wraps the app and provides the client"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"XState actors"})," are created within feature components that need them"]}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"performance-guidelines",children:"Performance Guidelines"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Zustand selectors are critical."})," Without a selector, a component re-renders on any store change:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-tsx",children:"// BAD \u2014 re-renders on any connection store change\nconst store = useConnectionStore();\n\n// GOOD \u2014 re-renders only when wsStatus changes\nconst wsStatus = useConnectionStore((state) => state.wsStatus);\n\n// GOOD \u2014 multiple fields with shallow comparison\nimport { shallow } from 'zustand/shallow';\nconst { wsStatus, isReconnecting } = useConnectionStore(\n  (state) => ({ wsStatus: state.wsStatus, isReconnecting: state.isReconnecting }),\n  shallow\n);\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Apollo fetch policies."})," The default ",(0,r.jsx)(n.code,{children:"watchQuery"})," policy is ",(0,r.jsx)(n.code,{children:"cache-and-network"}),", which returns\ncached data immediately and refreshes in the background. Use ",(0,r.jsx)(n.code,{children:"cache-first"})," for rarely-changing data."]})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},71184:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>a});var s=t(14041);const r={},i=s.createContext(r);function o(e){const n=s.useContext(i);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),s.createElement(i.Provider,{value:n},e.children)}}}]);