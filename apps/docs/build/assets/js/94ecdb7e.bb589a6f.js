"use strict";(globalThis.webpackChunk_nas_net_docs=globalThis.webpackChunk_nas_net_docs||[]).push([[21206],{71184:(e,n,t)=>{t.d(n,{R:()=>s,x:()=>l});var i=t(14041);const a={},r=i.createContext(a);function s(e){const n=i.useContext(r);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:s(e.components),i.createElement(r.Provider,{value:n},e.children)}},95212:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>l,default:()=>p,frontMatter:()=>s,metadata:()=>i,toc:()=>o});const i=JSON.parse('{"id":"guides/state-machines-guide","title":"State Machines Guide","description":"This guide documents the XState machines used in NasNetConnect for managing complex, multi-step workflows.","source":"@site/../../libs/core/docs/guides/state-machines-guide.md","sourceDirName":"guides","slug":"/guides/state-machines-guide","permalink":"/docs/core/guides/state-machines-guide","draft":false,"unlisted":false,"editUrl":"https://github.com/nasnet-community/nasnet-panel/tree/main/../../libs/core/docs/guides/state-machines-guide.md","tags":[],"version":"current","sidebarPosition":11,"frontMatter":{"sidebar_position":11,"title":"State Machines Guide"},"sidebar":"sidebar","previous":{"title":"Testing Patterns","permalink":"/docs/core/guides/testing-patterns"},"next":{"title":"Accessibility Patterns","permalink":"/docs/core/guides/accessibility-patterns"}}');var a=t(31085),r=t(71184);const s={sidebar_position:11,title:"State Machines Guide"},l="State Machines Guide",c={},o=[{value:"XState Overview",id:"xstate-overview",level:2},{value:"Machine Architecture",id:"machine-architecture",level:2},{value:"Example: Dependency Injection",id:"example-dependency-injection",level:3},{value:"changeSetMachine",id:"changesetmachine",level:2},{value:"States",id:"states",level:3},{value:"Context",id:"context",level:3},{value:"Events",id:"events",level:3},{value:"Safety Features",id:"safety-features",level:3},{value:"Helper Functions",id:"helper-functions",level:3},{value:"Usage Example",id:"usage-example",level:3},{value:"configPipelineMachine",id:"configpipelinemachine",level:2},{value:"States",id:"states-1",level:3},{value:"Context",id:"context-1",level:3},{value:"Events",id:"events-1",level:3},{value:"Configuration",id:"configuration",level:3},{value:"Guards",id:"guards",level:3},{value:"Safety Flow",id:"safety-flow",level:3},{value:"Helper Functions",id:"helper-functions-1",level:3},{value:"Usage Example",id:"usage-example-1",level:3},{value:"resourceLifecycleMachine",id:"resourcelifecyclemachine",level:2},{value:"States",id:"states-2",level:3},{value:"Context",id:"context-2",level:3},{value:"Health Monitoring",id:"health-monitoring",level:3},{value:"Degradation Detection",id:"degradation-detection",level:3},{value:"Helper Functions",id:"helper-functions-2",level:3},{value:"vpnConnectionMachine",id:"vpnconnectionmachine",level:2},{value:"States",id:"states-3",level:3},{value:"Context",id:"context-3",level:3},{value:"Metrics",id:"metrics",level:3},{value:"Exponential Backoff",id:"exponential-backoff",level:3},{value:"Hook: useVPNConnection",id:"hook-usevpnconnection",level:3},{value:"wizardMachine",id:"wizardmachine",level:2},{value:"States",id:"states-4",level:3},{value:"Context",id:"context-4",level:3},{value:"Events",id:"events-2",level:3},{value:"Configuration",id:"configuration-1",level:3},{value:"Step Validation",id:"step-validation",level:3},{value:"Session Persistence",id:"session-persistence",level:3},{value:"Hook: useWizard",id:"hook-usewizard",level:3},{value:"Machine Hooks",id:"machine-hooks",level:2},{value:"useChangeSet",id:"usechangeset",level:3},{value:"useConfigPipeline",id:"useconfigpipeline",level:3},{value:"useResourceLifecycle",id:"useresourcelifecycle",level:3},{value:"useVPNConnection",id:"usevpnconnection",level:3},{value:"useWizard",id:"usewizard",level:3},{value:"Persistence",id:"persistence",level:2},{value:"Integration with Validation Pipeline",id:"integration-with-validation-pipeline",level:2},{value:"State Diagram: Config Pipeline",id:"state-diagram-config-pipeline",level:2},{value:"Testing State Machines",id:"testing-state-machines",level:2},{value:"Summary Table",id:"summary-table",level:2},{value:"Further Reading",id:"further-reading",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"state-machines-guide",children:"State Machines Guide"})}),"\n",(0,a.jsx)(n.p,{children:"This guide documents the XState machines used in NasNetConnect for managing complex, multi-step workflows."}),"\n",(0,a.jsx)(n.h2,{id:"xstate-overview",children:"XState Overview"}),"\n",(0,a.jsxs)(n.p,{children:["NasNetConnect uses ",(0,a.jsx)(n.strong,{children:"XState"})," for modeling stateful, asynchronous workflows that:"]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Cannot be easily expressed as simple React state"})," \u2014 Complex flows with guards, timeouts, and side effects"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Require guaranteed state transitions"})," \u2014 Formal state machine semantics prevent invalid states"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Need explicit state modeling"})," \u2014 Business logic is self-documenting through machine definition"]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Key Benefits:"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Prevent impossible states (invalid state transitions are rejected)"}),"\n",(0,a.jsx)(n.li,{children:"Automatic timeout/cleanup management"}),"\n",(0,a.jsx)(n.li,{children:"Built-in support for parallel states and hierarchical machines"}),"\n",(0,a.jsx)(n.li,{children:"Time-travel debugging with visualizer"}),"\n",(0,a.jsx)(n.li,{children:"Testable and mockable (pure functions with deterministic output)"}),"\n"]}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Version:"})," XState v4.x"]}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.h2,{id:"machine-architecture",children:"Machine Architecture"}),"\n",(0,a.jsx)(n.p,{children:"All machines in NasNetConnect follow a consistent factory pattern:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"// Factory function accepts dependency-injected services\nexport function createMachine<TContext, TEvent>(\n  config: MachineConfig<TContext, TEvent>\n) {\n  return setup({\n    types: { context: {} as TContext, events: {} as TEvent },\n    actors: { /* async actors for side effects */ },\n    guards: { /* state transition guards */ },\n  }).createMachine({\n    // State machine definition\n  });\n}\n"})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Why this pattern?"})}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Dependency injection"})," \u2014 Services (API calls, validators) passed at creation time"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Testability"})," \u2014 Mock services easily, test state transitions without network calls"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Reusability"})," \u2014 Same machine logic used across multiple components with different services"]}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"example-dependency-injection",children:"Example: Dependency Injection"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"import { useMachine } from '@xstate/react';\nimport { createConfigPipelineMachine } from '@nasnet/state/machines';\n\nfunction ConfigForm({ routerId }: { routerId: string }) {\n  const [state, send] = useMachine(\n    createConfigPipelineMachine({\n      id: 'firewall-config',\n      // Inject services (API calls, validators)\n      runValidationPipeline: async (config) => {\n        // Call validation API\n        return await validateConfig(routerId, config);\n      },\n      applyConfig: async ({ config }) => {\n        // Call apply API\n        return await applyRouterConfig(routerId, config);\n      },\n      verifyApplied: async () => {\n        // Poll router to verify changes\n        return await verifyRouterConfig(routerId);\n      },\n      executeRollback: async (rollbackData) => {\n        // Call rollback API\n        return await rollbackRouterConfig(routerId, rollbackData);\n      },\n    })\n  );\n\n  return /* UI */;\n}\n"})}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.h2,{id:"changesetmachine",children:"changeSetMachine"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Atomic Multi-Resource Operations"})}),"\n",(0,a.jsx)(n.p,{children:"Orchestrates applying multiple interdependent changes in the correct order with automatic rollback."}),"\n",(0,a.jsx)(n.h3,{id:"states",children:"States"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"idle\n  \u2193\nvalidating  \u2190 START_VALIDATION\n  \u2193\nready  \u2190 validation passed\n  \u251c\u2192 APPLY \u2192 applying\n  \u2502          \u251c\u2192 applyingItem (apply current item)\n  \u2502          \u2514\u2192 checkingMore (more items?)\n  \u2502              \u251c\u2192 applyingItem (next item)\n  \u2502              \u2514\u2192 completed \u2713\n  \u2502\n  \u2514\u2192 CANCEL \u2192 cancelled\n      \u2193\n  rolledBack (items rolled back)\n\napplying \u2192 failed \u2192 (optional: rollback)\n       \u2193\n   rollingBack\n       \u251c\u2192 rolledBack \u2713\n       \u2514\u2192 partialFailure \u26a0 (manual intervention)\n"})}),"\n",(0,a.jsx)(n.h3,{id:"context",children:"Context"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"interface ChangeSetMachineContext {\n  changeSet: ChangeSet | null;           // Multi-resource operation\n  routerId: string | null;               // Target router\n  validationResult: ValidationResult | null;\n  currentItemIndex: number;              // Progress tracking\n  sortedItems: ChangeSetItem[];          // Topologically sorted\n  appliedItems: ChangeSetItem[];         // Already applied\n  rollbackPlan: RollbackStep[];          // Items to roll back\n  error: ChangeSetError | null;\n  errorMessage: string | null;\n  cancelRequested: boolean;\n  applyStartedAt: number | null;\n  onProgress?: (event: ProgressEvent) => void;\n}\n"})}),"\n",(0,a.jsx)(n.h3,{id:"events",children:"Events"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"type ChangeSetMachineEvent =\n  | { type: 'LOAD'; changeSet: ChangeSet; routerId: string }\n  | { type: 'START_VALIDATION' }\n  | { type: 'APPLY' }\n  | { type: 'CANCEL' }\n  | { type: 'RETRY' }\n  | { type: 'RESET' }\n  | { type: 'FORCE_ROLLBACK' };\n"})}),"\n",(0,a.jsx)(n.h3,{id:"safety-features",children:"Safety Features"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Cannot skip validation"})," \u2014 All items validated before apply"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Dependency-ordered apply"})," \u2014 Topological sort ensures dependencies applied first"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Automatic rollback"})," \u2014 Applied items rolled back in reverse order on failure"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Cancellation points"})," \u2014 Can cancel only at safe checkpoints (after validation, between items)"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Progress tracking"})," \u2014 Real-time progress via ",(0,a.jsx)(n.code,{children:"onProgress"})," callback"]}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"helper-functions",children:"Helper Functions"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"import { isChangeSetProcessing, isChangeSetFinal } from '@nasnet/state/machines';\n\n// Check if operation in progress\nif (isChangeSetProcessing(state.value)) {\n  // Show progress UI\n}\n\n// Check if operation finished\nif (isChangeSetFinal(state.value)) {\n  // Close dialog, refresh data\n}\n"})}),"\n",(0,a.jsx)(n.h3,{id:"usage-example",children:"Usage Example"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"import { useMachine } from '@xstate/react';\nimport { createChangeSetMachine } from '@nasnet/state/machines';\n\nfunction ChangeSetApplyDialog({ changeSet, routerId }: Props) {\n  const [state, send] = useMachine(\n    createChangeSetMachine({\n      id: 'changeset-apply',\n      onValidate: async (items) => {\n        return await validateChangeSet(routerId, items);\n      },\n      onApply: async (item) => {\n        return await applyChangeSetItem(routerId, item);\n      },\n      onRollback: async (item) => {\n        return await rollbackChangeSetItem(routerId, item);\n      },\n    })\n  );\n\n  useEffect(() => {\n    // Load change set\n    send({ type: 'LOAD', changeSet, routerId });\n    // Start validation\n    send({ type: 'START_VALIDATION' });\n  }, [changeSet, routerId]);\n\n  if (state.matches('validating')) {\n    return <LoadingSpinner>Validating changes...</LoadingSpinner>;\n  }\n\n  if (state.matches('invalid')) {\n    return <ErrorAlert errors={state.context.validationErrors} />;\n  }\n\n  if (state.matches('applying')) {\n    return (\n      <ProgressBar\n        current={state.context.currentItemIndex}\n        total={state.context.sortedItems.length}\n      />\n    );\n  }\n\n  if (state.matches('completed')) {\n    return <SuccessAlert message=\"All changes applied successfully\" />;\n  }\n\n  return null;\n}\n"})}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.h2,{id:"configpipelinemachine",children:"configPipelineMachine"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Safety-First Configuration (Apply-Confirm-Merge Pattern)"})}),"\n",(0,a.jsx)(n.p,{children:"Implements a safety flow preventing accidental network lockouts through explicit state modeling."}),"\n",(0,a.jsx)(n.h3,{id:"states-1",children:"States"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"idle\n  \u2193\ndraft (EDIT)\n  \u2193\nvalidating (VALIDATE)\n  \u251c\u2192 invalid (errors found)\n  \u2502   \u2514\u2192 draft (FIX_ERRORS)\n  \u2502\n  \u2514\u2192 previewing (no errors)\n      \u251c\u2192 confirming (high-risk? ACKNOWLEDGED required)\n      \u2502   \u2514\u2192 applying\n      \u2502       \u251c\u2192 verifying\n      \u2502       \u2502   \u251c\u2192 active \u2713\n      \u2502       \u2502   \u2514\u2192 rollback \u2192 rolled_back\n      \u2502       \u2514\u2192 error\n      \u2502\n      \u2514\u2192 applying (low-risk)\n"})}),"\n",(0,a.jsx)(n.h3,{id:"context-1",children:"Context"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"interface ConfigPipelineContext<TConfig> {\n  resourceId: string | null;\n  originalConfig: TConfig | null;\n  pendingConfig: TConfig | null;\n  validationErrors: ValidationError[];\n  diff: ConfigDiff | null;\n  rollbackData: TConfig | null;\n  applyStartedAt: number | null;\n  errorMessage: string | null;\n}\n"})}),"\n",(0,a.jsx)(n.h3,{id:"events-1",children:"Events"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"type ConfigPipelineEvent<TConfig> =\n  | { type: 'EDIT'; config: TConfig }\n  | { type: 'VALIDATE' }\n  | { type: 'CONFIRM' }\n  | { type: 'ACKNOWLEDGED' }  // High-risk ops require explicit ack\n  | { type: 'CANCEL' }\n  | { type: 'RETRY' }\n  | { type: 'RESET' }\n  | { type: 'FORCE_ROLLBACK' };\n"})}),"\n",(0,a.jsx)(n.h3,{id:"configuration",children:"Configuration"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"interface ConfigPipelineConfig<TConfig> {\n  id?: string;\n  runValidationPipeline: (config: TConfig) => Promise<ValidationPipelineResult>;\n  applyConfig: (params: { resourceId: string; config: TConfig }) => Promise<ApplyResult>;\n  verifyApplied: (resourceId: string) => Promise<void>;\n  executeRollback: (rollbackData: TConfig) => Promise<void>;\n}\n"})}),"\n",(0,a.jsx)(n.h3,{id:"guards",children:"Guards"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"// High-risk operations require explicit acknowledgment\nguard: ({ context, event }) => {\n  return context.diff?.isHighRisk === false;\n}\n\n// Can only confirm after validation passes\nguard: ({ context }) => {\n  return context.validationErrors.length === 0;\n}\n\n// Can only apply after confirmed\nguard: ({ context }) => {\n  return context.rollbackData !== null;\n}\n"})}),"\n",(0,a.jsx)(n.h3,{id:"safety-flow",children:"Safety Flow"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"1. Draft    \u2014 User edits configuration\n                \u2193\n2. Validate \u2014 7-stage validation pipeline (schema, semantic, network, etc.)\n                \u2193\n3. Preview  \u2014 Show diff of changes (added, removed, modified)\n                \u2193\n4. Confirm  \u2014 For high-risk ops: require explicit ACKNOWLEDGED event\n                \u2193\n5. Apply    \u2014 Send configuration to router\n                \u2193\n6. Verify   \u2014 Confirm router accepted changes\n                \u2193\n7. Success/Rollback \u2014 Operation complete or auto-rollback on failure\n"})}),"\n",(0,a.jsx)(n.h3,{id:"helper-functions-1",children:"Helper Functions"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:'import {\n  isPipelineFinal,\n  isPipelineCancellable,\n  isPipelineProcessing,\n  getPipelineStateDescription,\n} from \'@nasnet/state/machines\';\n\nconst description = getPipelineStateDescription(state.value);\n// Returns: "Validating configuration", "Waiting for confirmation", etc.\n\nif (isPipelineProcessing(state.value)) {\n  // Show spinner\n}\n\nif (isPipelineCancellable(state.value)) {\n  // Show cancel button\n}\n'})}),"\n",(0,a.jsx)(n.h3,{id:"usage-example-1",children:"Usage Example"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"import { useConfigPipeline } from '@nasnet/state/machines';\n\nfunction FirewallRuleForm({ routerId, ruleId }: Props) {\n  const pipeline = useConfigPipeline({\n    id: 'firewall-form',\n    runValidationPipeline: async (rule) => {\n      const result = await validateFirewallRule(routerId, rule);\n      return { errors: result.errors, diff: result.diff };\n    },\n    applyConfig: async ({ config }) => {\n      const rollbackData = await applyRule(routerId, config);\n      return { rollbackData };\n    },\n    verifyApplied: async () => {\n      await verifyRuleApplied(routerId, ruleId);\n    },\n    executeRollback: async (rollbackData) => {\n      await applyRule(routerId, rollbackData);\n    },\n  });\n\n  return (\n    <>\n      {pipeline.state.matches('draft') && (\n        <RuleEditor\n          rule={pipeline.pendingConfig}\n          onChange={(rule) => pipeline.send({ type: 'EDIT', config: rule })}\n          onValidate={() => pipeline.send({ type: 'VALIDATE' })}\n        />\n      )}\n\n      {pipeline.state.matches('previewing') && (\n        <PreviewDialog\n          diff={pipeline.diff}\n          isHighRisk={pipeline.diff?.isHighRisk}\n          onConfirm={() => {\n            if (pipeline.diff?.isHighRisk) {\n              // High-risk: require explicit ack\n              pipeline.send({ type: 'ACKNOWLEDGED' });\n            } else {\n              pipeline.send({ type: 'CONFIRM' });\n            }\n          }}\n          onCancel={() => pipeline.send({ type: 'CANCEL' })}\n        />\n      )}\n\n      {pipeline.state.matches('applying') && (\n        <ProgressDialog message=\"Applying configuration...\" />\n      )}\n\n      {pipeline.state.matches('error') && (\n        <ErrorDialog\n          error={pipeline.errorMessage}\n          onRetry={() => pipeline.send({ type: 'RETRY' })}\n          onReset={() => pipeline.send({ type: 'RESET' })}\n        />\n      )}\n    </>\n  );\n}\n"})}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.h2,{id:"resourcelifecyclemachine",children:"resourceLifecycleMachine"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Resource Lifecycle Management (9-State Lifecycle)"})}),"\n",(0,a.jsx)(n.p,{children:"Models the complete lifecycle of a router resource (interface, service, tunnel, etc.)."}),"\n",(0,a.jsx)(n.h3,{id:"states-2",children:"States"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"draft       \u2014 Resource being configured, not yet applied\n  \u2193\nvalidating  \u2014 Validation in progress\n  \u251c\u2192 invalid (revert to draft)\n  \u2514\u2192 valid\n      \u2193\n  applying   \u2014 Applying to router\n      \u251c\u2192 active \u2713 (running successfully)\n      \u2502   \u251c\u2192 degraded (health check fails)\n      \u2502   \u2502   \u2514\u2192 active (recovered)\n      \u2502   \u251c\u2192 error (unexpected failure)\n      \u2502   \u2502   \u2514\u2192 active (recovered)\n      \u2502   \u2514\u2192 deprecated (newer version available)\n      \u2502       \u2514\u2192 syncing (updating)\n      \u2502           \u2514\u2192 active\n      \u2502\n      \u2514\u2192 archived (no longer needed)\n"})}),"\n",(0,a.jsx)(n.h3,{id:"context-2",children:"Context"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"interface ResourceLifecycleContext<TResource> {\n  resource: TResource | null;\n  state: ResourceState;\n  validationErrors: ValidationError[];\n  healthStatus: 'healthy' | 'degraded' | 'error' | null;\n  lastHealthCheck: number | null;\n  availableVersion?: string;\n  error: Error | null;\n  metrics?: ResourceMetrics;\n}\n"})}),"\n",(0,a.jsx)(n.h3,{id:"health-monitoring",children:"Health Monitoring"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"// Health check runs periodically when active\nonHealthCheck: async (resourceId: string) => {\n  const health = await getResourceHealth(resourceId);\n  return {\n    status: health.status,  // 'healthy' | 'degraded' | 'error'\n    metrics: health.metrics,\n  };\n}\n"})}),"\n",(0,a.jsx)(n.h3,{id:"degradation-detection",children:"Degradation Detection"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Network latency > 500ms \u2192 degraded"}),"\n",(0,a.jsx)(n.li,{children:"Packet loss > 5% \u2192 degraded"}),"\n",(0,a.jsx)(n.li,{children:"Memory usage > 90% \u2192 degraded"}),"\n",(0,a.jsx)(n.li,{children:"Explicit error response \u2192 error"}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"helper-functions-2",children:"Helper Functions"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"import {\n  isResourcePending,\n  isResourceActive,\n  isResourceEditable,\n  isResourceAppliable,\n  getResourceStateDisplayInfo,\n} from '@nasnet/state/machines';\n\nif (isResourceEditable(state.value)) {\n  // Show edit form\n}\n\nif (isResourceActive(state.value)) {\n  // Show health status\n}\n\nif (isResourcePending(state.value)) {\n  // Show spinner\n}\n\nconst { label, color, icon } = getResourceStateDisplayInfo(state.value);\n"})}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.h2,{id:"vpnconnectionmachine",children:"vpnConnectionMachine"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"VPN Connection Flow with Auto-Reconnect"})}),"\n",(0,a.jsx)(n.p,{children:"Manages VPN connection lifecycle with exponential backoff reconnection."}),"\n",(0,a.jsx)(n.h3,{id:"states-3",children:"States"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"disconnected\n  \u251c\u2192 CONNECT\n  \u2514\u2192 connecting (timeout: 30s)\n      \u251c\u2192 connected \u2713\n      \u2502   \u251c\u2192 DISCONNECT \u2192 disconnected\n      \u2502   \u251c\u2192 CONNECTION_LOST\n      \u2502   \u2502   \u2514\u2192 reconnecting (backoff: 1s, 2s, 4s, 8s...)\n      \u2502   \u2502       \u251c\u2192 connected \u2713\n      \u2502   \u2502       \u2514\u2192 CONNECTION_LOST (max retries?)\n      \u2502   \u2502           \u2514\u2192 error\n      \u2502   \u2514\u2192 METRICS_UPDATE (real-time speed/latency)\n      \u2502\n      \u2514\u2192 error (timeout or connection failed)\n          \u2514\u2192 RETRY or DISCONNECT\n"})}),"\n",(0,a.jsx)(n.h3,{id:"context-3",children:"Context"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"interface VPNConnectionContext {\n  connectionId: string | null;\n  provider: string | null;           // 'wireguard' | 'openvpn' | etc.\n  serverAddress: string | null;\n  metrics: ConnectionMetrics | null;\n  error: string | null;\n  reconnectAttempts: number;\n  maxReconnectAttempts: number;      // Default: 5\n}\n"})}),"\n",(0,a.jsx)(n.h3,{id:"metrics",children:"Metrics"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"interface ConnectionMetrics {\n  uploadSpeed: number;               // bytes/sec\n  downloadSpeed: number;             // bytes/sec\n  bytesUploaded: number;\n  bytesDownloaded: number;\n  latencyMs: number;\n  uptimeSeconds: number;\n  serverLocation?: string;\n}\n"})}),"\n",(0,a.jsx)(n.h3,{id:"exponential-backoff",children:"Exponential Backoff"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"// Reconnection attempts with exponential backoff\nconst BACKOFF_MS = [\n  1000,   // Attempt 1: 1 second\n  2000,   // Attempt 2: 2 seconds\n  4000,   // Attempt 3: 4 seconds\n  8000,   // Attempt 4: 8 seconds\n  16000,  // Attempt 5: 16 seconds\n];\n\n// After max attempts, enter error state\nif (reconnectAttempts >= maxReconnectAttempts) {\n  // \u2192 error state\n}\n"})}),"\n",(0,a.jsx)(n.h3,{id:"hook-usevpnconnection",children:"Hook: useVPNConnection"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"import { useVPNConnection } from '@nasnet/state/machines';\n\nfunction VPNStatusWidget() {\n  const vpn = useVPNConnection({\n    onConnect: async (serverAddress, provider) => {\n      return await connectVPN(serverAddress, provider);\n    },\n    onDisconnect: async (connectionId) => {\n      return await disconnectVPN(connectionId);\n    },\n    onMetricsUpdate: async (connectionId) => {\n      return await getVPNMetrics(connectionId);\n    },\n  });\n\n  return (\n    <>\n      {vpn.state.matches('disconnected') && (\n        <Button onClick={() => vpn.send({ type: 'CONNECT', ... })}>\n          Connect to VPN\n        </Button>\n      )}\n\n      {vpn.state.matches('connecting') && (\n        <LoadingSpinner>Connecting to {vpn.serverAddress}...</LoadingSpinner>\n      )}\n\n      {vpn.state.matches('connected') && (\n        <>\n          <StatusBadge status=\"online\" />\n          <SpeedIndicator\n            upload={vpn.metrics?.uploadSpeed}\n            download={vpn.metrics?.downloadSpeed}\n          />\n          <Button onClick={() => vpn.send({ type: 'DISCONNECT' })}>\n            Disconnect\n          </Button>\n        </>\n      )}\n\n      {vpn.state.matches('error') && (\n        <>\n          <ErrorAlert message={vpn.error} />\n          <Button onClick={() => vpn.send({ type: 'RETRY' })}>\n            Retry\n          </Button>\n        </>\n      )}\n    </>\n  );\n}\n"})}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.h2,{id:"wizardmachine",children:"wizardMachine"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Multi-Step Wizard Pattern"})}),"\n",(0,a.jsx)(n.p,{children:"Generic wizard machine supporting step navigation, validation, and session persistence."}),"\n",(0,a.jsx)(n.h3,{id:"states-4",children:"States"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"step (editing step)\n  \u251c\u2192 NEXT\n  \u2502   \u2514\u2192 validating\n  \u2502       \u251c\u2192 step (validation passed)\n  \u2502       \u2514\u2192 step (validation failed, show errors)\n  \u2502\n  \u251c\u2192 BACK\n  \u2502   \u2514\u2192 step (previous)\n  \u2502\n  \u251c\u2192 GOTO\n  \u2502   \u2514\u2192 step (jump to step if canSkip)\n  \u2502\n  \u2514\u2192 SUBMIT (on last step)\n      \u2514\u2192 submitting\n          \u251c\u2192 completed \u2713\n          \u2514\u2192 error (can RETRY)\n\nOR at any time:\n  \u2514\u2192 CANCEL \u2192 cancelled\n"})}),"\n",(0,a.jsx)(n.h3,{id:"context-4",children:"Context"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"interface WizardContext<TData> {\n  currentStep: number;                // 1-indexed\n  totalSteps: number;\n  data: Partial<TData>;              // Collected across steps\n  errors: Record<string, string>;    // Field errors\n  sessionId: string;                 // For persistence\n  canSkip?: boolean;                 // Skip to any step?\n}\n"})}),"\n",(0,a.jsx)(n.h3,{id:"events-2",children:"Events"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"type WizardEvent<TData> =\n  | { type: 'NEXT'; data?: Partial<TData> }\n  | { type: 'BACK' }\n  | { type: 'GOTO'; step: number }\n  | { type: 'VALIDATE' }\n  | { type: 'SUBMIT' }\n  | { type: 'CANCEL' }\n  | { type: 'RESTORE'; savedContext: WizardContext<TData> }\n  | { type: 'SET_DATA'; data: Partial<TData> }\n  | { type: 'CLEAR_ERRORS' };\n"})}),"\n",(0,a.jsx)(n.h3,{id:"configuration-1",children:"Configuration"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"interface WizardConfig<TData> {\n  id: string;\n  totalSteps: number;\n  validateStep: (\n    step: number,\n    data: Partial<TData>\n  ) => Promise<{ valid: boolean; errors?: Record<string, string> }>;\n  onSubmit: (data: TData) => Promise<void>;\n  initialData?: Partial<TData>;\n  persist?: boolean;  // Default: true\n}\n"})}),"\n",(0,a.jsx)(n.h3,{id:"step-validation",children:"Step Validation"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"// Each step validates independently\nasync validateStep(step, data) {\n  switch (step) {\n    case 1:  // Connection details\n      if (!data.serverAddress) return { valid: false, errors: { ... } };\n      if (!isValidIPv4(data.serverAddress)) return { valid: false, ... };\n      return { valid: true };\n\n    case 2:  // Credentials\n      if (!data.username) return { valid: false, ... };\n      if (!data.password) return { valid: false, ... };\n      return { valid: true };\n\n    case 3:  // Advanced options\n      // Server-side validation (e.g., check protocol compatibility)\n      return await validateAdvancedOptions(data);\n\n    case 4:  // Confirm\n      return { valid: true };  // No validation needed\n\n    default:\n      return { valid: true };\n  }\n}\n"})}),"\n",(0,a.jsx)(n.h3,{id:"session-persistence",children:"Session Persistence"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"// Wizard state auto-saved to localStorage\n// On browser close/refresh, user can resume\n\n// Option 1: Auto-restore (prompt user)\nconst wizard = useWizard({\n  persist: true,\n  onRestore: () => console.log('Session restored'),\n  onDiscard: () => console.log('Session discarded'),\n});\n\n// Option 2: Manual restore\nconst savedState = localStorage.getItem('wizard-state');\nif (savedState) {\n  wizard.send({\n    type: 'RESTORE',\n    savedContext: JSON.parse(savedState),\n  });\n}\n"})}),"\n",(0,a.jsx)(n.h3,{id:"hook-usewizard",children:"Hook: useWizard"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"import { useWizard } from '@nasnet/state/machines';\n\ninterface VPNWizardData {\n  serverAddress: string;\n  port: number;\n  protocol: 'wireguard' | 'openvpn';\n  username: string;\n  password: string;\n}\n\nfunction VPNSetupWizard() {\n  const wizard = useWizard<VPNWizardData>({\n    id: 'vpn-setup',\n    totalSteps: 4,\n    validateStep: async (step, data) => {\n      // Per-step validation\n      const validation = await validateVPNWizardStep(step, data);\n      return validation;\n    },\n    onSubmit: async (data) => {\n      // Create VPN connection\n      await createVPNConnection(data);\n    },\n    persist: true,\n  });\n\n  const isLastStep = wizard.currentStep === wizard.totalSteps;\n\n  return (\n    <>\n      <ProgressBar\n        current={wizard.currentStep}\n        total={wizard.totalSteps}\n      />\n\n      {wizard.currentStep === 1 && (\n        <ServerAddressStep\n          value={wizard.data.serverAddress}\n          error={wizard.errors.serverAddress}\n          onChange={(value) => wizard.send({\n            type: 'SET_DATA',\n            data: { serverAddress: value },\n          })}\n        />\n      )}\n\n      {wizard.currentStep === 2 && (\n        <ProtocolStep\n          value={wizard.data.protocol}\n          onChange={(value) => wizard.send({\n            type: 'SET_DATA',\n            data: { protocol: value },\n          })}\n        />\n      )}\n\n      {wizard.currentStep === 3 && (\n        <CredentialsStep\n          username={wizard.data.username}\n          password={wizard.data.password}\n          onChange={(username, password) => wizard.send({\n            type: 'SET_DATA',\n            data: { username, password },\n          })}\n        />\n      )}\n\n      {wizard.currentStep === 4 && (\n        <ConfirmStep data={wizard.data} />\n      )}\n\n      <div className=\"wizard-buttons\">\n        <Button\n          disabled={wizard.currentStep === 1}\n          onClick={() => wizard.send({ type: 'BACK' })}\n        >\n          Back\n        </Button>\n\n        <Button\n          onClick={() => {\n            if (isLastStep) {\n              wizard.send({ type: 'SUBMIT' });\n            } else {\n              wizard.send({ type: 'NEXT' });\n            }\n          }}\n          loading={wizard.state.matches('submitting')}\n        >\n          {isLastStep ? 'Create' : 'Next'}\n        </Button>\n\n        <Button\n          variant=\"ghost\"\n          onClick={() => wizard.send({ type: 'CANCEL' })}\n        >\n          Cancel\n        </Button>\n      </div>\n\n      {wizard.state.matches('completed') && (\n        <SuccessDialog message=\"VPN connection created!\" />\n      )}\n\n      {wizard.state.matches('error') && (\n        <ErrorDialog\n          error={wizard.error}\n          onRetry={() => wizard.send({ type: 'SUBMIT' })}\n        />\n      )}\n    </>\n  );\n}\n"})}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.h2,{id:"machine-hooks",children:"Machine Hooks"}),"\n",(0,a.jsx)(n.p,{children:"All machines provide React hooks for convenient integration:"}),"\n",(0,a.jsx)(n.h3,{id:"usechangeset",children:"useChangeSet"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"const changeSet = useChangeSet(config);\n// Properties:\n// - state: ChangeSetState\n// - context: ChangeSetMachineContext\n// - send: (event) => void\n// - matches: (state) => boolean\n"})}),"\n",(0,a.jsx)(n.h3,{id:"useconfigpipeline",children:"useConfigPipeline"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"const pipeline = useConfigPipeline(config);\n// Properties:\n// - state: ConfigPipelineState\n// - stateDescription: string\n// - resourceId, pendingConfig, diff, errorMessage: context properties\n// - isFinal, isProcessing, isCancellable: booleans\n// - send: (event) => void\n"})}),"\n",(0,a.jsx)(n.h3,{id:"useresourcelifecycle",children:"useResourceLifecycle"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"const resource = useResourceLifecycle(config);\n// Properties:\n// - state: ResourceState\n// - resource, validationErrors, healthStatus: context\n// - send: (event) => void\n"})}),"\n",(0,a.jsx)(n.h3,{id:"usevpnconnection",children:"useVPNConnection"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"const vpn = useVPNConnection(config);\n// Properties:\n// - state: VPNConnectionState\n// - connectionId, provider, metrics, error: context\n// - send: (event) => void\n"})}),"\n",(0,a.jsx)(n.h3,{id:"usewizard",children:"useWizard"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"const wizard = useWizard<TData>(config);\n// Properties:\n// - currentStep, totalSteps, data, errors, sessionId: context\n// - state: WizardState\n// - isFirstStep, isLastStep: computed\n// - send: (event) => void\n"})}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.h2,{id:"persistence",children:"Persistence"}),"\n",(0,a.jsx)(n.p,{children:"The persistence module provides utilities for saving and restoring machine state:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"// libs/state/machines/src/persistence.ts\nimport {\n  saveMachineState,\n  restoreMachineState,\n  clearMachineState,\n} from '@nasnet/state/machines';\n\n// Save on state change\nconst subscription = actor.subscribe((state) => {\n  if (!state.matches('idle')) {\n    saveMachineState('wizard-vpn', {\n      state: state.value,\n      context: state.context,\n      timestamp: Date.now(),\n      machineId: 'vpn-wizard',\n    });\n  }\n});\n\n// Restore on mount\nconst saved = restoreMachineState('wizard-vpn', {\n  maxAge: 86400000,  // 24 hours\n  promptBeforeRestore: true,\n});\n\nif (saved) {\n  send({ type: 'RESTORE', savedContext: saved.context });\n}\n\n// Clear when complete\nsend({ type: 'RESET' });\nclearMachineState('wizard-vpn');\n"})}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.h2,{id:"integration-with-validation-pipeline",children:"Integration with Validation Pipeline"}),"\n",(0,a.jsx)(n.p,{children:"Machines integrate with the 7-stage validation pipeline:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"Stage 1: Schema Validation      (Zod, format checks)\nStage 2: Semantic Validation    (Business rules)\nStage 3: Network Validation     (Router connectivity)\nStage 4: Conflict Detection     (Service conflicts)\nStage 5: Performance Checks     (Resource constraints)\nStage 6: Security Checks        (Access control, firewall)\nStage 7: Compatibility Check    (RouterOS version, hardware)\n"})}),"\n",(0,a.jsx)(n.p,{children:"Machine calls:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"const validationResult = await runValidationPipeline(config);\n// Returns:\n// {\n//   errors: ValidationError[],\n//   diff: ConfigDiff,\n//   isHighRisk: boolean,\n// }\n"})}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.h2,{id:"state-diagram-config-pipeline",children:"State Diagram: Config Pipeline"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                    CONFIG PIPELINE FLOW                         \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n         EDIT\n         \u2193\n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    \u2502   DRAFT     \u2502  \u2190 User editing config\n    \u2514\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n          \u2502 VALIDATE\n          \u2193\n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    \u2502  VALIDATING \u2502  \u2190 7-stage validation pipeline\n    \u2514\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2518\n       \u2502      \u2502\n   Invalid  Valid\n       \u2502      \u2502\n       \u2193      \u2193\n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    \u2502    INVALID      \u2502  \u2190 Show errors, go back to DRAFT\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n           \u2502 FIX \u2192 EDIT\n           \u2514\u2500\u2192 DRAFT\n\n       Valid\n       \u2193\n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    \u2502  PREVIEWING  \u2502  \u2190 Show diff of changes\n    \u2514\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n       \u2502 CONFIRM (or ACKNOWLEDGED if high-risk)\n       \u2193\n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    \u2502  CONFIRMING  \u2502  \u2190 For high-risk: require explicit ACKNOWLEDGED\n    \u2514\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n       \u2502 \u2192 APPLYING\n       \u2193\n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    \u2502   APPLYING   \u2502  \u2190 Send to router\n    \u2514\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n       \u2502 \u2192 VERIFYING\n       \u2193\n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    \u2502  VERIFYING   \u2502  \u2190 Confirm router accepted\n    \u2514\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n       \u2502 Success\n       \u251c\u2500\u2192 ACTIVE \u2713\n       \u2502\n       \u2502 Failure\n       \u251c\u2500\u2192 ROLLBACK \u2192 ROLLED_BACK\n       \u2502\n       \u2514\u2500\u2192 ERROR (with auto-retry)\n           \u2193 RETRY\n           \u2192 APPLYING\n"})}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.h2,{id:"testing-state-machines",children:"Testing State Machines"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"import { describe, it, expect, vi } from 'vitest';\nimport { createTestingUtils } from '@xstate/test';\nimport { createConfigPipelineMachine } from '@nasnet/state/machines';\n\ndescribe('configPipelineMachine', () => {\n  it('should validate before applying', async () => {\n    const machine = createConfigPipelineMachine({\n      runValidationPipeline: vi.fn().mockResolvedValue({\n        errors: [],\n        diff: { added: [], removed: [], modified: [] },\n      }),\n      applyConfig: vi.fn().mockResolvedValue({ rollbackData: {} }),\n      verifyApplied: vi.fn(),\n      executeRollback: vi.fn(),\n    });\n\n    const state = machine.initialState;\n    expect(state.matches('idle')).toBe(true);\n\n    const nextState = state.transitions.find(t => t.event.type === 'EDIT');\n    expect(nextState?.target.matches('draft')).toBe(true);\n  });\n\n  it('should auto-rollback on verification failure', async () => {\n    const mockRollback = vi.fn();\n    const machine = createConfigPipelineMachine({\n      runValidationPipeline: vi.fn().mockResolvedValue({\n        errors: [],\n        diff: {},\n      }),\n      applyConfig: vi.fn().mockResolvedValue({ rollbackData: {} }),\n      verifyApplied: vi.fn().mockRejectedValue(new Error('Verify failed')),\n      executeRollback: mockRollback,\n    });\n\n    // ... run through state transitions\n    // ... assert mockRollback was called\n  });\n});\n"})}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.h2,{id:"summary-table",children:"Summary Table"}),"\n",(0,a.jsxs)(n.table,{children:[(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{children:"Machine"}),(0,a.jsx)(n.th,{children:"Purpose"}),(0,a.jsx)(n.th,{children:"States"}),(0,a.jsx)(n.th,{children:"Main Events"})]})}),(0,a.jsxs)(n.tbody,{children:[(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:(0,a.jsx)(n.strong,{children:"changeSetMachine"})}),(0,a.jsx)(n.td,{children:"Atomic multi-resource ops"}),(0,a.jsx)(n.td,{children:"idle, validating, ready, applying, completed, failed"}),(0,a.jsx)(n.td,{children:"LOAD, START_VALIDATION, APPLY, CANCEL, RETRY"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:(0,a.jsx)(n.strong,{children:"configPipelineMachine"})}),(0,a.jsx)(n.td,{children:"Safety-first config"}),(0,a.jsx)(n.td,{children:"draft, validating, previewing, confirming, applying, active, error"}),(0,a.jsx)(n.td,{children:"EDIT, VALIDATE, CONFIRM, ACKNOWLEDGED, APPLY"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:(0,a.jsx)(n.strong,{children:"resourceLifecycleMachine"})}),(0,a.jsx)(n.td,{children:"Resource lifecycle"}),(0,a.jsx)(n.td,{children:"draft, validating, applying, active, degraded, error, archived"}),(0,a.jsx)(n.td,{children:"APPLY, HEALTH_UPDATE, UPGRADE"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:(0,a.jsx)(n.strong,{children:"vpnConnectionMachine"})}),(0,a.jsx)(n.td,{children:"VPN connections"}),(0,a.jsx)(n.td,{children:"disconnected, connecting, connected, reconnecting, error"}),(0,a.jsx)(n.td,{children:"CONNECT, DISCONNECT, CONNECTION_LOST, METRICS_UPDATE"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:(0,a.jsx)(n.strong,{children:"wizardMachine"})}),(0,a.jsx)(n.td,{children:"Multi-step wizards"}),(0,a.jsx)(n.td,{children:"step, validating, submitting, completed, cancelled"}),(0,a.jsx)(n.td,{children:"NEXT, BACK, GOTO, SUBMIT, VALIDATE, CANCEL"})]})]})]}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.h2,{id:"further-reading",children:"Further Reading"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"https://xstate.js.org/",children:"XState Documentation"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"https://xstate.js.org/docs/packages/xstate-react/",children:"XState React Integration"})}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"Docs/architecture/novel-pattern-designs.md"})," \u2014 Safety Pipeline, Apply-Confirm-Merge"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"Docs/architecture/implementation-patterns/universal-state-architecture.md"})," \u2014 Detailed patterns"]}),"\n"]})]})}function p(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}}}]);