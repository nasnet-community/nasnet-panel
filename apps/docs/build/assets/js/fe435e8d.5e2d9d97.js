"use strict";(globalThis.webpackChunk_nas_net_docs=globalThis.webpackChunk_nas_net_docs||[]).push([[63773],{2271:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>c,default:()=>h,frontMatter:()=>o,metadata:()=>s,toc:()=>d});const s=JSON.parse('{"id":"websocket-subscriptions","title":"WebSocket Subscriptions","description":"This document covers the real-time subscription layer of @nasnet/api-client: how the WebSocket client is created and configured, how split-link routing directs subscription operations to the WebSocket transport while keeping queries and mutations on HTTP, how authentication is provided per-connection, how the retry/reconnect strategy works, and how connection lifecycle events flow into the Zustand stores and the offline detector.","source":"@site/../../libs/api-client/docs/websocket-subscriptions.md","sourceDirName":".","slug":"/websocket-subscriptions","permalink":"/docs/api-client/websocket-subscriptions","draft":false,"unlisted":false,"editUrl":"https://github.com/nasnet-community/nasnet-panel/tree/main/../../libs/api-client/docs/websocket-subscriptions.md","tags":[],"version":"current","frontMatter":{},"sidebar":"sidebar","previous":{"title":"Testing and Code Generation","permalink":"/docs/api-client/testing-and-codegen"}}');var r=t(31085),i=t(71184);const o={},c="WebSocket Subscriptions",l={},d=[{value:"Table of Contents",id:"table-of-contents",level:2},{value:"1. Architecture Overview",id:"1-architecture-overview",level:2},{value:"2. Split Link Routing",id:"2-split-link-routing",level:2},{value:"3. WsClientOptions \u2014 Configuration Reference",id:"3-wsclientoptions--configuration-reference",level:2},{value:"4. Auto wss / ws Protocol Detection",id:"4-auto-wss--ws-protocol-detection",level:2},{value:"5. connectionParams \u2014 Per-Connection Authentication",id:"5-connectionparams--per-connection-authentication",level:2},{value:"6. Retry Strategy \u2014 Exponential Backoff with Jitter",id:"6-retry-strategy--exponential-backoff-with-jitter",level:2},{value:"retryAttempts",id:"retryattempts",level:3},{value:"retryWait",id:"retrywait",level:3},{value:"shouldRetry \u2014 Fatal Codes",id:"shouldretry--fatal-codes",level:3},{value:"7. Connection Lifecycle Events",id:"7-connection-lifecycle-events",level:2},{value:"connecting",id:"connecting",level:3},{value:"connected",id:"connected",level:3},{value:"closed",id:"closed",level:3},{value:"error",id:"error",level:3},{value:"Event Summary",id:"event-summary",level:3},{value:"8. Zustand Store Updates",id:"8-zustand-store-updates",level:2},{value:"9. Integration with the Offline Detector",id:"9-integration-with-the-offline-detector",level:2},{value:"OfflineDetectorConfig",id:"offlinedetectorconfig",level:3},{value:"Usage in a React App",id:"usage-in-a-react-app",level:3},{value:"Utility Functions",id:"utility-functions",level:3},{value:"10. Subscription Usage Pattern in Domain Hooks",id:"10-subscription-usage-pattern-in-domain-hooks",level:2},{value:"Basic Pattern",id:"basic-pattern",level:3},{value:"Real Examples from the Codebase",id:"real-examples-from-the-codebase",level:3},{value:"Combining Multiple Subscriptions",id:"combining-multiple-subscriptions",level:3},{value:"11. Exported API Reference",id:"11-exported-api-reference",level:2},{value:"From <code>libs/api-client/core/src/apollo/apollo-ws-client.ts</code>",id:"from-libsapi-clientcoresrcapolloapollo-ws-clientts",level:3},{value:"From <code>libs/api-client/core/src/apollo/offline-detector.ts</code>",id:"from-libsapi-clientcoresrcapollooffline-detectorts",level:3}];function a(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"websocket-subscriptions",children:"WebSocket Subscriptions"})}),"\n",(0,r.jsxs)(n.p,{children:["This document covers the real-time subscription layer of ",(0,r.jsx)(n.code,{children:"@nasnet/api-client"}),": how the WebSocket client is created and configured, how split-link routing directs subscription operations to the WebSocket transport while keeping queries and mutations on HTTP, how authentication is provided per-connection, how the retry/reconnect strategy works, and how connection lifecycle events flow into the Zustand stores and the offline detector."]}),"\n",(0,r.jsxs)(n.p,{children:["Related docs: ",(0,r.jsx)(n.a,{href:"/docs/api-client/apollo-client",children:"./apollo-client.md"})," (link chain), ",(0,r.jsx)(n.a,{href:"/docs/api-client/authentication",children:"./authentication.md"})," (auth tokens), ",(0,r.jsx)(n.a,{href:"/docs/api-client/offline-first",children:"./offline-first.md"})," (offline integration)."]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"table-of-contents",children:"Table of Contents"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#1-architecture-overview",children:"Architecture Overview"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#2-split-link-routing",children:"Split Link Routing"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#3-wsclientoptions--configuration-reference",children:"WsClientOptions \u2014 Configuration Reference"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#4-auto-wss--ws-protocol-detection",children:"Auto wss / ws Protocol Detection"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#5-connectionparams--per-connection-authentication",children:"connectionParams \u2014 Per-Connection Authentication"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#6-retry-strategy--exponential-backoff-with-jitter",children:"Retry Strategy \u2014 Exponential Backoff with Jitter"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#7-connection-lifecycle-events",children:"Connection Lifecycle Events"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#8-zustand-store-updates",children:"Zustand Store Updates"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#9-integration-with-the-offline-detector",children:"Integration with the Offline Detector"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#10-subscription-usage-pattern-in-domain-hooks",children:"Subscription Usage Pattern in Domain Hooks"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#11-exported-api-reference",children:"Exported API Reference"})}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"1-architecture-overview",children:"1. Architecture Overview"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"Browser\n  |\n  |-- Query / Mutation \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n  |                                                          v\n  |-- Subscription \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                    authLink \u2192 httpLink\n                             v                         \u2193\n                       GraphQLWsLink               /graphql (HTTP)\n                             \u2193\n                        wsClient (graphql-ws)\n                             \u2193\n                       /graphql (WebSocket)\n                             \u2193\n                          Go backend\n\nConnection events (ws:connecting, ws:connected, ws:closed, ws:error)\n      \u2193\n  CustomEvents on window\n      \u2193\n  OfflineDetector \u2500\u2500\u2192 useNetworkStore (Zustand)\n  WsClient handlers \u2500\u2192 useConnectionStore (Zustand)\n"})}),"\n",(0,r.jsxs)(n.p,{children:["The WebSocket client is implemented in ",(0,r.jsx)(n.code,{children:"libs/api-client/core/src/apollo/apollo-ws-client.ts"})," using the ",(0,r.jsx)(n.code,{children:"graphql-ws"})," library. Apollo Client's ",(0,r.jsx)(n.code,{children:"split"})," function in ",(0,r.jsx)(n.code,{children:"libs/api-client/core/src/apollo/apollo-client.ts"})," routes subscriptions to the WebSocket link and everything else to the HTTP link."]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"2-split-link-routing",children:"2. Split Link Routing"}),"\n",(0,r.jsxs)(n.p,{children:["Source: ",(0,r.jsx)(n.code,{children:"libs/api-client/core/src/apollo/apollo-client.ts:50"})]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"const splitLink = split(\n  ({ query }) => {\n    const definition = getMainDefinition(query);\n    return (\n      definition.kind === 'OperationDefinition' &&\n      definition.operation === 'subscription'\n    );\n  },\n  wsLink,              // subscription \u2192 WebSocket\n  authLink.concat(httpLink)  // query / mutation \u2192 HTTP with auth headers\n);\n"})}),"\n",(0,r.jsx)(n.p,{children:"The complete link chain is:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"Request \u2192 errorLink \u2192 retryLink \u2192 splitLink \u2192 (authLink \u2192 httpLink) OR (wsLink)\n                                                              \u2191\n                                              subscriptions bypass errorLink/retryLink\n                                              because wsClient has its own retry\n"})}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"retryLink"})," at the HTTP level (initial delay 300 ms, max 3 s, max 3 attempts, no retry on 4xx) is separate from the WebSocket reconnect logic. Subscriptions are retried exclusively by ",(0,r.jsx)(n.code,{children:"graphql-ws"}),"."]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"3-wsclientoptions--configuration-reference",children:"3. WsClientOptions \u2014 Configuration Reference"}),"\n",(0,r.jsxs)(n.p,{children:["Source: ",(0,r.jsx)(n.code,{children:"libs/api-client/core/src/apollo/apollo-ws-client.ts:26"})]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"export interface WsClientOptions {\n  /**\n   * WebSocket URL (default: auto-detected from current location)\n   */\n  url?: string;\n\n  /**\n   * Maximum retry attempts (default: 10)\n   */\n  maxRetries?: number;\n\n  /**\n   * Whether to show notifications for status changes (default: true)\n   */\n  showNotifications?: boolean;\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["The module-level ",(0,r.jsx)(n.code,{children:"wsClient"})," is created with all defaults:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"export const wsClient: Client = createWsClient();\n// url:               auto-detected (see section 4)\n// maxRetries:        10\n// showNotifications: true\n"})}),"\n",(0,r.jsx)(n.p,{children:"To create a second client for a different backend or with notifications silenced:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"import { createWsClient } from '@nasnet/api-client/core/apollo';\n\nconst customClient = createWsClient({\n  url: 'wss://my-other-backend/graphql',\n  maxRetries: 3,\n  showNotifications: false,\n});\n"})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"4-auto-wss--ws-protocol-detection",children:"4. Auto wss / ws Protocol Detection"}),"\n",(0,r.jsxs)(n.p,{children:["Source: ",(0,r.jsx)(n.code,{children:"libs/api-client/core/src/apollo/apollo-ws-client.ts:51"})]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"function getWebSocketUrl(): string {\n  if (typeof window === 'undefined') {\n    return 'ws://localhost:8080/graphql'; // SSR fallback\n  }\n\n  const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';\n  const host = window.location.host;\n  return `${protocol}//${host}/graphql`;\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"The logic is deliberately simple:"}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Page protocol"}),(0,r.jsx)(n.th,{children:"WS protocol"}),(0,r.jsx)(n.th,{children:"Endpoint example"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"https:"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"wss:"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"wss://router.local/graphql"})})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"http:"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"ws:"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"ws://192.168.88.1/graphql"})})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"SSR / no window"}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"ws:"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"ws://localhost:8080/graphql"})})]})]})]}),"\n",(0,r.jsxs)(n.p,{children:["In production the NasNetConnect frontend is served from the router itself (",(0,r.jsx)(n.code,{children:"http://"})," for local network access) so ",(0,r.jsx)(n.code,{children:"ws:"})," is typical. When TLS is terminated upstream (e.g., a reverse proxy), ",(0,r.jsx)(n.code,{children:"wss:"})," kicks in automatically because ",(0,r.jsx)(n.code,{children:"window.location.protocol"})," will be ",(0,r.jsx)(n.code,{children:"https:"}),"."]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"5-connectionparams--per-connection-authentication",children:"5. connectionParams \u2014 Per-Connection Authentication"}),"\n",(0,r.jsxs)(n.p,{children:["Source: ",(0,r.jsx)(n.code,{children:"libs/api-client/core/src/apollo/apollo-ws-client.ts:149"})]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"connectionParams"})," is evaluated as a ",(0,r.jsx)(n.strong,{children:"function"})," (not a static object), so it is called fresh on every connection attempt including reconnects. This ensures that a refreshed JWT token is always used after the previous token expires."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"connectionParams: () => {\n  const { currentRouterId } = useConnectionStore.getState();\n  const authorization = getAuthorization(currentRouterId);\n\n  return {\n    routerId: currentRouterId,\n    authorization,\n  };\n},\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"getAuthorization"})," follows the same two-step priority as the HTTP auth link (see ",(0,r.jsx)(n.a,{href:"/docs/api-client/authentication",children:"./authentication.md"}),"):"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"function getAuthorization(routerId: string | null): string | undefined {\n  // 1. JWT Bearer token from auth store\n  const jwtToken = getAuthToken();\n  if (jwtToken) return `Bearer ${jwtToken}`;\n\n  // 2. Basic auth from sessionStorage per-router credentials\n  const credentials = getStoredCredentials(routerId);\n  if (credentials) {\n    return `Basic ${btoa(`${credentials.username}:${credentials.password}`)}`;\n  }\n\n  return undefined;\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["The backend receives ",(0,r.jsx)(n.code,{children:"routerId"})," and ",(0,r.jsx)(n.code,{children:"authorization"})," in the ",(0,r.jsx)(n.code,{children:"connection_init"})," message of the ",(0,r.jsx)(n.code,{children:"graphql-ws"})," protocol. When the socket reconnects after a token refresh, the new token is automatically provided."]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"6-retry-strategy--exponential-backoff-with-jitter",children:"6. Retry Strategy \u2014 Exponential Backoff with Jitter"}),"\n",(0,r.jsxs)(n.p,{children:["Source: ",(0,r.jsx)(n.code,{children:"libs/api-client/core/src/apollo/apollo-ws-client.ts:160"})]}),"\n",(0,r.jsx)(n.h3,{id:"retryattempts",children:"retryAttempts"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"retryAttempts: maxRetries,  // default: 10\n"})}),"\n",(0,r.jsx)(n.h3,{id:"retrywait",children:"retryWait"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"retryWait: async (retries) => {\n  const delay = calculateBackoff(retries);\n  await new Promise((resolve) => setTimeout(resolve, delay));\n},\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"calculateBackoff"})," is imported from ",(0,r.jsx)(n.code,{children:"@nasnet/state/stores"}),". It implements exponential backoff with jitter. The approximate delay schedule is:"]}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Attempt"}),(0,r.jsx)(n.th,{children:"Base"}),(0,r.jsx)(n.th,{children:"With jitter (approx)"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"1"}),(0,r.jsx)(n.td,{children:"1 000 ms"}),(0,r.jsx)(n.td,{children:"800 \u2013 1 200 ms"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"2"}),(0,r.jsx)(n.td,{children:"2 000 ms"}),(0,r.jsx)(n.td,{children:"1 600 \u2013 2 400 ms"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"3"}),(0,r.jsx)(n.td,{children:"4 000 ms"}),(0,r.jsx)(n.td,{children:"3 200 \u2013 4 800 ms"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"4"}),(0,r.jsx)(n.td,{children:"8 000 ms"}),(0,r.jsx)(n.td,{children:"6 400 \u2013 9 600 ms"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"5+"}),(0,r.jsx)(n.td,{children:"16 000 ms"}),(0,r.jsx)(n.td,{children:"capped at ~30 000 ms"})]})]})]}),"\n",(0,r.jsx)(n.h3,{id:"shouldretry--fatal-codes",children:"shouldRetry \u2014 Fatal Codes"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"shouldRetry: (errOrCloseEvent) => {\n  // Do not retry on authentication failures\n  if (errOrCloseEvent instanceof CloseEvent) {\n    if (errOrCloseEvent.code === 4401 || errOrCloseEvent.code === 4403) {\n      return false;  // 4401 = auth failed, 4403 = forbidden\n    }\n  }\n\n  // Stop retrying once max attempts exceeded\n  const { hasExceededMaxAttempts } = useConnectionStore.getState();\n  if (hasExceededMaxAttempts()) {\n    return false;\n  }\n\n  return true;\n},\n"})}),"\n",(0,r.jsx)(n.p,{children:"Fatal close codes that abort retrying immediately:"}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Code"}),(0,r.jsx)(n.th,{children:"Meaning"}),(0,r.jsx)(n.th,{children:"Action"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"4401"})}),(0,r.jsx)(n.td,{children:"Authentication failed"}),(0,r.jsx)(n.td,{children:"Stop \u2014 credentials are wrong"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"4403"})}),(0,r.jsx)(n.td,{children:"Forbidden"}),(0,r.jsx)(n.td,{children:"Stop \u2014 access denied"})]})]})]}),"\n",(0,r.jsxs)(n.p,{children:["When ",(0,r.jsx)(n.code,{children:"hasExceededMaxAttempts()"})," returns ",(0,r.jsx)(n.code,{children:"true"}),' (after 10 failures), a toast notification is shown with a "Retry" prompt, and no further automatic reconnects are attempted.']}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"7-connection-lifecycle-events",children:"7. Connection Lifecycle Events"}),"\n",(0,r.jsxs)(n.p,{children:["Source: ",(0,r.jsx)(n.code,{children:"libs/api-client/core/src/apollo/apollo-ws-client.ts:188"})]}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"graphql-ws"})," ",(0,r.jsx)(n.code,{children:"on"})," handlers bridge the library's internal lifecycle into the application layer through two mechanisms: Zustand store mutations and ",(0,r.jsx)(n.code,{children:"window.CustomEvent"})," dispatches."]}),"\n",(0,r.jsx)(n.h3,{id:"connecting",children:"connecting"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"on: {\n  connecting: () => {\n    store.setWsStatus('connecting');\n    window.dispatchEvent(new CustomEvent('ws:connecting'));\n  },\n"})}),"\n",(0,r.jsx)(n.h3,{id:"connected",children:"connected"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"  connected: () => {\n    store.setWsStatus('connected');\n    store.resetReconnection();\n\n    if (activeRouterId) {\n      store.setRouterConnection(activeRouterId, {\n        status: 'connected',\n        lastConnected: new Date(),\n        lastError: null,\n      });\n    }\n\n    // Show success toast only if we were reconnecting\n    if (store.reconnectAttempts > 0) {\n      showToast('success', 'Connection restored', 'WebSocket connection re-established.');\n    }\n\n    window.dispatchEvent(new CustomEvent('ws:connected'));\n  },\n"})}),"\n",(0,r.jsx)(n.h3,{id:"closed",children:"closed"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"  closed: (event) => {\n    if (event.wasClean) {\n      store.setWsStatus('disconnected');\n    } else {\n      store.setWsStatus('error', reason);\n      store.incrementReconnectAttempts();\n\n      if (store.hasExceededMaxAttempts()) {\n        showToast('error', 'Connection failed', 'Unable to reconnect...');\n      }\n    }\n\n    window.dispatchEvent(new CustomEvent('ws:closed', {\n      detail: { code, reason, wasClean },\n    }));\n  },\n"})}),"\n",(0,r.jsx)(n.h3,{id:"error",children:"error"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"  error: (error) => {\n    store.setWsStatus('error', errorMessage);\n\n    window.dispatchEvent(new CustomEvent('ws:error', {\n      detail: { error },\n    }));\n  },\n"})}),"\n",(0,r.jsx)(n.h3,{id:"event-summary",children:"Event Summary"}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsxs)(n.th,{children:[(0,r.jsx)(n.code,{children:"CustomEvent"})," name"]}),(0,r.jsx)(n.th,{children:"Dispatched when"}),(0,r.jsxs)(n.th,{children:[(0,r.jsx)(n.code,{children:"detail"})," payload"]})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"ws:connecting"})}),(0,r.jsx)(n.td,{children:"Connection attempt starts"}),(0,r.jsx)(n.td,{children:"none"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"ws:connected"})}),(0,r.jsx)(n.td,{children:"Socket opened"}),(0,r.jsx)(n.td,{children:"none"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"ws:closed"})}),(0,r.jsx)(n.td,{children:"Socket closed"}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"{ code, reason, wasClean }"})})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"ws:error"})}),(0,r.jsx)(n.td,{children:"Protocol/network error"}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"{ error }"})})]})]})]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"8-zustand-store-updates",children:"8. Zustand Store Updates"}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"ws:*"})," lifecycle handlers write directly to ",(0,r.jsx)(n.code,{children:"useConnectionStore"}),":"]}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Method called"}),(0,r.jsx)(n.th,{children:"When"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"setWsStatus('connecting')"})}),(0,r.jsx)(n.td,{children:"Socket dialing"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"setWsStatus('connected')"})}),(0,r.jsx)(n.td,{children:"Handshake complete"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"resetReconnection()"})}),(0,r.jsx)(n.td,{children:"After a successful reconnect"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"setWsStatus('error', msg)"})}),(0,r.jsx)(n.td,{children:"Error or unexpected close"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"incrementReconnectAttempts()"})}),(0,r.jsx)(n.td,{children:"After each failed close"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"setRouterConnection(id, {...})"})}),(0,r.jsx)(n.td,{children:"Connected / error with router details"})]})]})]}),"\n",(0,r.jsx)(n.p,{children:"Components can reactively observe these:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-tsx",children:"import { useConnectionStore } from '@nasnet/state/stores';\n\nfunction ConnectionBadge() {\n  const wsStatus = useConnectionStore((s) => s.wsStatus);\n  const attempts = useConnectionStore((s) => s.reconnectAttempts);\n\n  return (\n    <span>\n      {wsStatus} {attempts > 0 && `(retry ${attempts})`}\n    </span>\n  );\n}\n"})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"9-integration-with-the-offline-detector",children:"9. Integration with the Offline Detector"}),"\n",(0,r.jsxs)(n.p,{children:["Source: ",(0,r.jsx)(n.code,{children:"libs/api-client/core/src/apollo/offline-detector.ts"})]}),"\n",(0,r.jsxs)(n.p,{children:["The offline detector subscribes to the same ",(0,r.jsx)(n.code,{children:"ws:*"})," ",(0,r.jsx)(n.code,{children:"CustomEvent"}),"s emitted by the WebSocket client:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"// inside setupOfflineDetector()\n\nconst handleWsConnected = () => {\n  store().setRouterConnected(true);\n  store().setRouterReachable(true);\n  store().resetReconnectAttempts();\n};\n\nconst handleWsClosed = () => {\n  store().setRouterConnected(false);\n  store().incrementReconnectAttempts();\n};\n\nconst handleWsError = () => {\n  store().setRouterConnected(false);\n  store().incrementReconnectAttempts();\n};\n\nwindow.addEventListener('ws:connected', handleWsConnected);\nwindow.addEventListener('ws:closed', handleWsClosed);\nwindow.addEventListener('ws:error', handleWsError);\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Additionally, ",(0,r.jsx)(n.code,{children:"setupOfflineDetector"})," listens for:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"online"})," / ",(0,r.jsx)(n.code,{children:"offline"})," browser events \u2192 ",(0,r.jsx)(n.code,{children:"setOnline(true/false)"})," on ",(0,r.jsx)(n.code,{children:"useNetworkStore"})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"network:error"})," (dispatched by the Apollo error link on HTTP failures) \u2192 ",(0,r.jsx)(n.code,{children:"setRouterReachable(false)"})]}),"\n",(0,r.jsxs)(n.li,{children:["Periodic health-check ",(0,r.jsx)(n.code,{children:"GET /api/health"})," every 30 s (configurable)"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"offlinedetectorconfig",children:"OfflineDetectorConfig"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"export interface OfflineDetectorConfig {\n  healthEndpoint?: string;        // default: '/api/health'\n  healthCheckInterval?: number;   // default: 30000 ms\n  healthCheckTimeout?: number;    // default: 5000 ms\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"usage-in-a-react-app",children:"Usage in a React App"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-tsx",children:"// Option A: imperative (e.g., in a top-level effect)\nuseEffect(() => {\n  const cleanup = setupOfflineDetector();\n  return cleanup;\n}, []);\n\n// Option B: declarative hook\nfunction App() {\n  useOfflineDetector(); // automatic cleanup on unmount\n  return <Router />;\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"utility-functions",children:"Utility Functions"}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Function"}),(0,r.jsx)(n.th,{children:"Returns"}),(0,r.jsx)(n.th,{children:"Reads from"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"isOffline()"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"boolean"})}),(0,r.jsxs)(n.td,{children:[(0,r.jsx)(n.code,{children:"useNetworkStore"})," \u2014 ",(0,r.jsx)(n.code,{children:"!isOnline || !isRouterReachable"})]})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"isDegraded()"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"boolean"})}),(0,r.jsxs)(n.td,{children:[(0,r.jsx)(n.code,{children:"useNetworkStore"})," \u2014 online but router/ws unreachable"]})]})]})]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"10-subscription-usage-pattern-in-domain-hooks",children:"10. Subscription Usage Pattern in Domain Hooks"}),"\n",(0,r.jsxs)(n.p,{children:["Domain hooks use ",(0,r.jsx)(n.code,{children:"useSubscription"})," from ",(0,r.jsx)(n.code,{children:"@apollo/client"})," directly. The WebSocket connection is established automatically when any subscription is mounted (Apollo Client holds the ",(0,r.jsx)(n.code,{children:"wsClient"})," reference via ",(0,r.jsx)(n.code,{children:"GraphQLWsLink"}),")."]}),"\n",(0,r.jsx)(n.h3,{id:"basic-pattern",children:"Basic Pattern"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-tsx",children:"import { useSubscription, gql } from '@apollo/client';\n\nconst SUBSCRIBE_FOO = gql`\n  subscription FooChanged($routerId: ID!) {\n    fooChanged(routerId: $routerId) {\n      id\n      status\n    }\n  }\n`;\n\nexport function useFooChanged(routerId: string, enabled = true) {\n  const { data, loading, error } = useSubscription(SUBSCRIBE_FOO, {\n    variables: { routerId },\n    skip: !enabled || !routerId,\n    onData: ({ data }) => {\n      // Side-effects: cache updates are handled automatically\n      // by Apollo's normalized cache when __typename + id are present\n    },\n  });\n\n  return {\n    event: data?.fooChanged,\n    loading,\n    error,\n  };\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"real-examples-from-the-codebase",children:"Real Examples from the Codebase"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Install progress"})," (",(0,r.jsx)(n.code,{children:"queries/src/services/useInstanceSubscriptions.ts:55"}),"):"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-tsx",children:"export function useInstallProgress(routerId: string, enabled = true) {\n  const { data, loading, error } = useSubscription(SUBSCRIBE_INSTALL_PROGRESS, {\n    variables: { routerID: routerId },\n    skip: !enabled || !routerId,\n    onData: ({ data }) => {\n      const progress = data.data?.installProgress;\n      if (progress?.status === 'completed') {\n        console.log(`Installation complete for ${progress.featureID}`);\n      }\n    },\n  });\n\n  return {\n    progress: data?.installProgress as InstallProgress | undefined,\n    loading,\n    error,\n  };\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Resource runtime"})," (",(0,r.jsx)(n.code,{children:"queries/src/resources/useResourceSubscription.ts:208"}),"):"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-tsx",children:"export function useResourceRuntimeSubscription(\n  uuid: string | undefined,\n  options: UseResourceRuntimeSubscriptionOptions = {}\n): SubscriptionResult<RuntimeUpdateEvent> {\n  const { skip = false, onUpdate, throttleMs = 0 } = options;\n\n  const { data, loading, error } = useSubscription(RESOURCE_RUNTIME_SUBSCRIPTION, {\n    variables: { uuid },\n    skip: skip || !uuid,\n    onData: ({ data: eventData }) => {\n      // throttle and invoke onUpdate callback\n    },\n  });\n\n  return { data: eventData, loading, error, isConnected: !skip && !!uuid && !error };\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"combining-multiple-subscriptions",children:"Combining Multiple Subscriptions"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-tsx",children:"// queries/src/services/useInstanceSubscriptions.ts:163\nexport function useInstanceMonitoring(routerId: string, enabled = true) {\n  const { progress, loading: il, error: ie } = useInstallProgress(routerId, enabled);\n  const { statusChange, loading: sl, error: se } = useInstanceStatusChanged(routerId, enabled);\n\n  return {\n    installProgress: progress,\n    statusChange,\n    loading: il || sl,\n    error: ie || se,\n  };\n}\n"})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"11-exported-api-reference",children:"11. Exported API Reference"}),"\n",(0,r.jsxs)(n.h3,{id:"from-libsapi-clientcoresrcapolloapollo-ws-clientts",children:["From ",(0,r.jsx)(n.code,{children:"libs/api-client/core/src/apollo/apollo-ws-client.ts"})]}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Export"}),(0,r.jsx)(n.th,{children:"Kind"}),(0,r.jsx)(n.th,{children:"Description"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"WsClientOptions"})}),(0,r.jsx)(n.td,{children:"interface"}),(0,r.jsxs)(n.td,{children:["Configuration shape for ",(0,r.jsx)(n.code,{children:"createWsClient"})]})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"createWsClient(options?)"})}),(0,r.jsx)(n.td,{children:"function"}),(0,r.jsxs)(n.td,{children:["Factory \u2014 creates a new ",(0,r.jsx)(n.code,{children:"graphql-ws"})," ",(0,r.jsx)(n.code,{children:"Client"})]})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"wsClient"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"Client"})}),(0,r.jsxs)(n.td,{children:["Default singleton used by ",(0,r.jsx)(n.code,{children:"apolloClient"})]})]})]})]}),"\n",(0,r.jsxs)(n.h3,{id:"from-libsapi-clientcoresrcapollooffline-detectorts",children:["From ",(0,r.jsx)(n.code,{children:"libs/api-client/core/src/apollo/offline-detector.ts"})]}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Export"}),(0,r.jsx)(n.th,{children:"Kind"}),(0,r.jsx)(n.th,{children:"Description"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"OfflineDetectorConfig"})}),(0,r.jsx)(n.td,{children:"interface"}),(0,r.jsx)(n.td,{children:"Configuration for the offline detector"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"setupOfflineDetector(config?)"})}),(0,r.jsx)(n.td,{children:"function"}),(0,r.jsx)(n.td,{children:"Imperative setup, returns cleanup function"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"useOfflineDetector(config?)"})}),(0,r.jsx)(n.td,{children:"hook"}),(0,r.jsx)(n.td,{children:"React hook version with auto-cleanup"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"isOffline()"})}),(0,r.jsx)(n.td,{children:"function"}),(0,r.jsxs)(n.td,{children:[(0,r.jsx)(n.code,{children:"true"})," if browser offline or backend unreachable"]})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"isDegraded()"})}),(0,r.jsx)(n.td,{children:"function"}),(0,r.jsxs)(n.td,{children:[(0,r.jsx)(n.code,{children:"true"})," if online but WS/backend partially unreachable"]})]})]})]})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(a,{...e})}):a(e)}},71184:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>c});var s=t(14041);const r={},i=s.createContext(r);function o(e){const n=s.useContext(i);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),s.createElement(i.Provider,{value:n},e.children)}}}]);