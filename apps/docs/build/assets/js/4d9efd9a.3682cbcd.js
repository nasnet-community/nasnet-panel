"use strict";(globalThis.webpackChunk_nas_net_docs=globalThis.webpackChunk_nas_net_docs||[]).push([[51137],{46224:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>i,default:()=>d,frontMatter:()=>a,metadata:()=>r,toc:()=>l});const r=JSON.parse('{"id":"integrations/cross-feature-sharing","title":"Cross-Feature Communication via Stores","description":"Zustand stores enable cross-feature communication without violating dependency rules. Features can read from any store but should not import directly from other features. Instead, they communicate through shared stores.","source":"@site/../../libs/state/docs/integrations/cross-feature-sharing.md","sourceDirName":"integrations","slug":"/integrations/cross-feature-sharing","permalink":"/docs/state/integrations/cross-feature-sharing","draft":false,"unlisted":false,"editUrl":"https://github.com/nasnet-community/nasnet-panel/tree/main/../../libs/state/docs/integrations/cross-feature-sharing.md","tags":[],"version":"current","frontMatter":{},"sidebar":"sidebar","previous":{"title":"Apollo Client & Zustand Integration","permalink":"/docs/state/integrations/apollo-integration"},"next":{"title":"Machine Hooks Reference","permalink":"/docs/state/machines/hooks-reference"}}');var s=t(31085),o=t(71184);const a={},i="Cross-Feature Communication via Stores",c={},l=[{value:"Dependency Rules",id:"dependency-rules",level:2},{value:"Pattern: Event-Based Communication via Stores",id:"pattern-event-based-communication-via-stores",level:2},{value:"Cross-Feature Examples",id:"cross-feature-examples",level:2},{value:"1. Auth State Affects All Features",id:"1-auth-state-affects-all-features",level:3},{value:"2. Connection State Drives All Features",id:"2-connection-state-drives-all-features",level:3},{value:"3. Selection Sharing Between Features",id:"3-selection-sharing-between-features",level:3},{value:"4. UI State Triggers Feature Actions",id:"4-ui-state-triggers-feature-actions",level:3},{value:"Store Communication Patterns",id:"store-communication-patterns",level:2},{value:"Pattern 1: Cascading Updates",id:"pattern-1-cascading-updates",level:3},{value:"Pattern 2: Event Dispatch via Custom Events",id:"pattern-2-event-dispatch-via-custom-events",level:3},{value:"Pattern 3: Shared State in Core Stores",id:"pattern-3-shared-state-in-core-stores",level:3},{value:"Real-World Cross-Feature Scenarios",id:"real-world-cross-feature-scenarios",level:2},{value:"Scenario 1: Configuration Apply Affects Multiple Features",id:"scenario-1-configuration-apply-affects-multiple-features",level:3},{value:"Scenario 2: Device/Router Selection in One Feature Affects All",id:"scenario-2-devicerouter-selection-in-one-feature-affects-all",level:3},{value:"Scenario 3: Bulk Operations Across Features",id:"scenario-3-bulk-operations-across-features",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"1. Use Selector Hooks for Optimization",id:"1-use-selector-hooks-for-optimization",level:3},{value:"2. Keep Domain Stores Local",id:"2-keep-domain-stores-local",level:3},{value:"3. Don&#39;t Over-Share",id:"3-dont-over-share",level:3},{value:"4. Use TypeScript for Type Safety",id:"4-use-typescript-for-type-safety",level:3},{value:"Troubleshooting",id:"troubleshooting",level:2},{value:"Store Update Not Reflected in Component",id:"store-update-not-reflected-in-component",level:3},{value:"Circular Dependencies",id:"circular-dependencies",level:3},{value:"Memory Leaks from Event Listeners",id:"memory-leaks-from-event-listeners",level:3},{value:"Summary",id:"summary",level:2}];function u(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,o.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"cross-feature-communication-via-stores",children:"Cross-Feature Communication via Stores"})}),"\n",(0,s.jsx)(n.p,{children:"Zustand stores enable cross-feature communication without violating dependency rules. Features can read from any store but should not import directly from other features. Instead, they communicate through shared stores."}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Source:"})," ",(0,s.jsx)(n.code,{children:"libs/state/stores/src/index.ts"})," - All stores are exported centrally"]}),"\n",(0,s.jsx)(n.h2,{id:"dependency-rules",children:"Dependency Rules"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"apps/connect/\n  \u251c\u2500 features/firewall/        Cannot import from features/dashboard\n  \u251c\u2500 features/dashboard/       Cannot import from features/firewall\n  \u251c\u2500 features/network/         Cannot import from other features\n  \u2514\u2500 features/vpn/             Cannot import from other features\n\nBut ALL features can:\n  \u2705 Import from libs/state/stores\n  \u2705 Import from libs/ui/patterns\n  \u2705 Import from libs/core/types\n"})}),"\n",(0,s.jsx)(n.h2,{id:"pattern-event-based-communication-via-stores",children:"Pattern: Event-Based Communication via Stores"}),"\n",(0,s.jsx)(n.p,{children:"Instead of direct imports, features communicate through stores:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// \u274c WRONG - Direct feature import\n// features/dashboard/Dashboard.tsx\nimport { ServicePanel } from '@nasnet/features/services'; // Violates dependency!\n\n// \u2705 RIGHT - Communicate via stores\n// features/dashboard/Dashboard.tsx\nimport { useServiceUIStore } from '@nasnet/state/stores';\n\nfunction Dashboard() {\n  const { selectedServices } = useServiceUIStore();\n  // Read service selection from store instead of importing Service feature\n}\n\n// features/services/ServicePanel.tsx\nimport { useServiceUIStore } from '@nasnet/state/stores';\n\nfunction ServicePanel() {\n  const { setSelectedServices } = useServiceUIStore();\n  // Update store, which Dashboard automatically reads\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"cross-feature-examples",children:"Cross-Feature Examples"}),"\n",(0,s.jsx)(n.h3,{id:"1-auth-state-affects-all-features",children:"1. Auth State Affects All Features"}),"\n",(0,s.jsx)(n.p,{children:"When user logs out, all features need to know:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// features/firewall/useFirewallData.ts\nimport { useAuthStore } from '@nasnet/state/stores';\nimport { useDHCPQuery } from '@nasnet/api-client/queries';\n\nexport function useFirewallData(routerId: string) {\n  const { isAuthenticated } = useAuthStore();\n\n  // Query only if authenticated\n  const { data } = useDHCPQuery(routerId, { skip: !isAuthenticated });\n\n  return data;\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"When auth state changes (logout):"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// Any feature detects logout automatically\nfunction FeatureComponent() {\n  const { isAuthenticated } = useAuthStore();\n\n  if (!isAuthenticated) {\n    return <RequiresAuth />;\n  }\n\n  return <FeatureContent />;\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"2-connection-state-drives-all-features",children:"2. Connection State Drives All Features"}),"\n",(0,s.jsx)(n.p,{children:"All features respond to router connection changes:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// features/dashboard/Dashboard.tsx\nimport { useConnectionStore } from '@nasnet/state/stores';\n\nfunction Dashboard() {\n  const { currentRouterId, websocketConnected } = useConnectionStore();\n\n  if (!currentRouterId) {\n    return <SelectRouter />;\n  }\n\n  if (!websocketConnected) {\n    return <Reconnecting />;\n  }\n\n  return <DashboardContent routerId={currentRouterId} />;\n}\n\n// features/firewall/FirewallPage.tsx\nfunction FirewallPage() {\n  const { currentRouterId } = useConnectionStore();\n\n  // Same store - automatically synced\n  return <FirewallRules routerId={currentRouterId} />;\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"3-selection-sharing-between-features",children:"3. Selection Sharing Between Features"}),"\n",(0,s.jsx)(n.p,{children:"One feature's selection updates another feature's UI:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// features/services/ServiceList.tsx - Updates store\nimport { useServiceUIStore } from '@nasnet/state/stores';\n\nfunction ServiceList() {\n  const { selectedServices, toggleServiceSelection } = useServiceUIStore();\n\n  return (\n    <div>\n      {services.map((service) => (\n        <ServiceCard\n          key={service.id}\n          selected={selectedServices.includes(service.id)}\n          onToggle={() => toggleServiceSelection(service.id)}\n        />\n      ))}\n    </div>\n  );\n}\n\n// features/dashboard/SelectedServicesCard.tsx - Reads store\nfunction SelectedServicesCard() {\n  const { selectedServices } = useServiceUIStore();\n\n  return (\n    <Card>\n      <h3>Selected Services ({selectedServices.length})</h3>\n      {selectedServices.map((id) => (\n        <ServiceBadge key={id} serviceId={id} />\n      ))}\n    </Card>\n  );\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"4-ui-state-triggers-feature-actions",children:"4. UI State Triggers Feature Actions"}),"\n",(0,s.jsx)(n.p,{children:"Global theme/sidebar changes affect all features:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// features/firewall/FirewallTable.tsx\nimport { useThemeStore, useSidebarStore } from '@nasnet/state/stores';\n\nfunction FirewallTable() {\n  const { isDark } = useThemeStore();\n  const { isCollapsed } = useSidebarStore();\n\n  return (\n    <table\n      className={isDark ? 'dark-mode' : 'light-mode'}\n      style={{\n        width: isCollapsed ? '100%' : 'calc(100% - 300px)',\n      }}\n    >\n      {/* Table content */}\n    </table>\n  );\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"store-communication-patterns",children:"Store Communication Patterns"}),"\n",(0,s.jsx)(n.h3,{id:"pattern-1-cascading-updates",children:"Pattern 1: Cascading Updates"}),"\n",(0,s.jsx)(n.p,{children:"Store changes cascade through UI:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"User Action\n  \u2193\nFeature A updates store\n  \u2193\nStore notifies all subscribers\n  \u2193\nFeature B's useEffect runs\n  \u2193\nFeature B updates UI\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// Feature A (Service List)\nfunction ServiceList() {\n  const { selectAllServices } = useServiceUIStore();\n\n  return (\n    <button onClick={() => selectAllServices(allServiceIds)}>\n      Select All\n    </button>\n  );\n}\n\n// Feature B (Dashboard) automatically updates\nfunction Dashboard() {\n  const { selectedServices } = useServiceUIStore();\n\n  useEffect(() => {\n    // Runs when selectedServices changes (from Feature A)\n    syncWithBackend(selectedServices);\n  }, [selectedServices]);\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"pattern-2-event-dispatch-via-custom-events",children:"Pattern 2: Event Dispatch via Custom Events"}),"\n",(0,s.jsx)(n.p,{children:"For complex workflows, use CustomEvent for non-store communication:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// Feature A: Dispatch event\nexport function triggerFirewallReload() {\n  window.dispatchEvent(\n    new CustomEvent('firewall:reload', {\n      detail: { routerId: 'router-123' }\n    })\n  );\n}\n\n// Feature B: Listen to event\nuseEffect(() => {\n  const handleReload = (e: Event) => {\n    const { routerId } = (e as CustomEvent).detail;\n    refetchFirewallRules(routerId);\n  };\n\n  window.addEventListener('firewall:reload', handleReload);\n  return () => window.removeEventListener('firewall:reload', handleReload);\n}, []);\n"})}),"\n",(0,s.jsx)(n.h3,{id:"pattern-3-shared-state-in-core-stores",children:"Pattern 3: Shared State in Core Stores"}),"\n",(0,s.jsx)(n.p,{children:"Core stores are designed for cross-feature sharing:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// libs/state/stores/auth/auth.store.ts\nexport interface AuthState {\n  user: User | null;\n  isAuthenticated: boolean;\n  token: string | null;\n  // ... used by ALL features\n}\n\n// libs/state/stores/connection/connection.store.ts\nexport interface ConnectionState {\n  currentRouterId: string | null;\n  websocketConnected: boolean;\n  // ... used by ALL features\n}\n\n// libs/state/stores/ui/theme.store.ts\nexport interface ThemeState {\n  isDark: boolean;\n  theme: 'light' | 'dark' | 'auto';\n  // ... used by ALL features\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"real-world-cross-feature-scenarios",children:"Real-World Cross-Feature Scenarios"}),"\n",(0,s.jsx)(n.h3,{id:"scenario-1-configuration-apply-affects-multiple-features",children:"Scenario 1: Configuration Apply Affects Multiple Features"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// Feature A: Firewall Config\nfunction FirewallConfigForm() {\n  const [draft, setDraft] = useState(initialConfig);\n\n  async function applyConfig() {\n    await applyFirewallChanges(draft);\n\n    // Dispatch event that other features listen to\n    window.dispatchEvent(\n      new CustomEvent('config:applied', {\n        detail: { type: 'firewall' }\n      })\n    );\n  }\n\n  return <form onSubmit={applyConfig}>...</form>;\n}\n\n// Feature B: Dashboard (listens for any config changes)\nfunction Dashboard() {\n  const [syncStatus, setSyncStatus] = useState('synced');\n\n  useEffect(() => {\n    const handleConfigApplied = () => {\n      setSyncStatus('syncing...');\n      refetchAllData();\n    };\n\n    window.addEventListener('config:applied', handleConfigApplied);\n    return () => window.removeEventListener('config:applied', handleConfigApplied);\n  }, []);\n\n  return <div>Status: {syncStatus}</div>;\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"scenario-2-devicerouter-selection-in-one-feature-affects-all",children:"Scenario 2: Device/Router Selection in One Feature Affects All"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// Feature A: Router List (user selects router)\nfunction RouterList() {\n  const { setCurrentRouterId } = useConnectionStore();\n\n  return (\n    <div>\n      {routers.map((router) => (\n        <button\n          key={router.id}\n          onClick={() => setCurrentRouterId(router.id)}\n        >\n          {router.name}\n        </button>\n      ))}\n    </div>\n  );\n}\n\n// Features B, C, D: All automatically switch to new router\nfunction FirewallPage() {\n  const { currentRouterId } = useConnectionStore();\n  return <FirewallRules key={currentRouterId} routerId={currentRouterId} />;\n}\n\nfunction DHCPPage() {\n  const { currentRouterId } = useConnectionStore();\n  return <DHCPServers key={currentRouterId} routerId={currentRouterId} />;\n}\n\nfunction NetworkPage() {\n  const { currentRouterId } = useConnectionStore();\n  return <Interfaces key={currentRouterId} routerId={currentRouterId} />;\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"scenario-3-bulk-operations-across-features",children:"Scenario 3: Bulk Operations Across Features"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// Firewall Feature: Select rules\nconst useFirewallRuleStore = create((set) => ({\n  selectedRuleIds: [],\n  toggleRule: (ruleId) => { /* ... */ },\n}));\n\n// Feature exports selection\nexport function getSelectedFirewallRules() {\n  const { selectedRuleIds } = useFirewallRuleStore.getState();\n  return selectedRuleIds;\n}\n\n// Dashboard: Bulk operation on selected items\nfunction BulkOperationsPanel() {\n  const { selectedRuleIds: firewallRules } = useFirewallRuleStore();\n  const { selectedServices } = useServiceUIStore();\n\n  async function deleteAllSelected() {\n    // Delete from multiple features in one operation\n    await Promise.all([\n      deleteFirewallRules(firewallRules),\n      deleteServices(selectedServices),\n    ]);\n\n    // Clear all selections\n    useFirewallRuleStore.getState().clearSelection?.();\n    useServiceUIStore.getState().clearServiceSelection();\n  }\n\n  return (\n    <button\n      disabled={firewallRules.length === 0 && selectedServices.length === 0}\n      onClick={deleteAllSelected}\n    >\n      Delete {firewallRules.length + selectedServices.length} items\n    </button>\n  );\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,s.jsx)(n.h3,{id:"1-use-selector-hooks-for-optimization",children:"1. Use Selector Hooks for Optimization"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// \u2705 GOOD - Optimized, only re-renders when search changes\nconst search = useFirewallLogSearch();\n\n// \u274c BAD - Re-renders when any firewall log store value changes\nconst { search, filters, sorts } = useFirewallLogStore();\n"})}),"\n",(0,s.jsx)(n.h3,{id:"2-keep-domain-stores-local",children:"2. Keep Domain Stores Local"}),"\n",(0,s.jsx)(n.p,{children:"Domain-specific UI state stays in domain stores:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// Feature-local state\nconst { selectedChain } = useMangleUIStore(); // Private to mangle feature\n\n// Shared state goes to core stores\nconst { currentRouterId } = useConnectionStore(); // Shared with all features\n"})}),"\n",(0,s.jsx)(n.h3,{id:"3-dont-over-share",children:"3. Don't Over-Share"}),"\n",(0,s.jsx)(n.p,{children:"Not everything needs to be a store:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// \u274c WRONG - Should be local component state\nconst useFormDraftStore = create((set) => ({\n  formDraft: {},\n  setFormDraft: (draft) => set({ formDraft: draft }),\n}));\n\n// \u2705 RIGHT - Local state (only shared if needed across features)\nfunction EditForm() {\n  const [draft, setDraft] = useState({});\n  return <form>...</form>;\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"4-use-typescript-for-type-safety",children:"4. Use TypeScript for Type Safety"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// Create well-typed store exports\nexport const useCurrentRouterId = () =>\n  useConnectionStore((state) => state.currentRouterId);\n\nexport const setCurrentRouterId = (id: string | null) =>\n  useConnectionStore.setState({ currentRouterId: id });\n\n// Use in features with full type safety\nconst routerId = useCurrentRouterId(); // string | null (typed)\n"})}),"\n",(0,s.jsx)(n.h2,{id:"troubleshooting",children:"Troubleshooting"}),"\n",(0,s.jsx)(n.h3,{id:"store-update-not-reflected-in-component",children:"Store Update Not Reflected in Component"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Problem:"})," Component doesn't re-render when store updates."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Solution:"})," Use selector hooks instead of whole store:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// \u274c WRONG - Component might not re-render\nconst store = useConnectionStore();\nconst routerId = store.currentRouterId;\n\n// \u2705 RIGHT - Automatically re-renders on change\nconst routerId = useConnectionStore((state) => state.currentRouterId);\n"})}),"\n",(0,s.jsx)(n.h3,{id:"circular-dependencies",children:"Circular Dependencies"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Problem:"})," Feature A needs Feature B's store, Feature B needs Feature A's store."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Solution:"})," Use core stores as intermediary:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// Instead of:\n// Feature A \u2192 Feature B \u2192 Feature A (circular)\n\n// Use:\n// Feature A \u2192 Core Store \u2190 Feature B\nconst { selectedIds } = useConnectionStore(); // Shared core\n"})}),"\n",(0,s.jsx)(n.h3,{id:"memory-leaks-from-event-listeners",children:"Memory Leaks from Event Listeners"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Problem:"})," Event listeners accumulate without cleanup."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Solution:"})," Always unsubscribe:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// \u2705 RIGHT\nuseEffect(() => {\n  const handler = () => { /* ... */ };\n  window.addEventListener('custom:event', handler);\n\n  return () => window.removeEventListener('custom:event', handler);\n}, []);\n\n// \u274c WRONG - No cleanup\nuseEffect(() => {\n  window.addEventListener('custom:event', handler);\n}, []);\n"})}),"\n",(0,s.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,s.jsx)(n.p,{children:"Cross-feature communication via stores:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Respects dependency rules"})," - features don't import each other"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Uses centralized stores"})," - all features read/write shared state"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Enables reactive UI"})," - store changes automatically update all listeners"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Prevents prop drilling"})," - no need to pass state through component tree"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Maintains isolation"})," - features stay independent but coordinated"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["The key principle: ",(0,s.jsx)(n.strong,{children:"Share through stores, not through imports."})]})]})}function d(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(u,{...e})}):u(e)}},71184:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>i});var r=t(14041);const s={},o=r.createContext(s);function a(e){const n=r.useContext(o);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),r.createElement(o.Provider,{value:n},e.children)}}}]);