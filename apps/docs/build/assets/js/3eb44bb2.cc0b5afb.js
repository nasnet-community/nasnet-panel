"use strict";(globalThis.webpackChunk_nas_net_docs=globalThis.webpackChunk_nas_net_docs||[]).push([[88271],{71184:(e,n,i)=>{i.d(n,{R:()=>c,x:()=>l});var t=i(14041);const r={},s=t.createContext(r);function c(e){const n=t.useContext(s);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:c(e.components),t.createElement(s.Provider,{value:n},e.children)}},82362:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>d,contentTitle:()=>l,default:()=>h,frontMatter:()=>c,metadata:()=>t,toc:()=>o});const t=JSON.parse('{"id":"state-management/drift-detection","title":"Drift Detection System","description":"Source: libs/state/stores/src/drift-detection/","source":"@site/../connect/docs/state-management/drift-detection.md","sourceDirName":"state-management","slug":"/state-management/drift-detection","permalink":"/docs/frontend/state-management/drift-detection","draft":false,"unlisted":false,"editUrl":"https://github.com/nasnet-community/nasnet-panel/tree/main/../connect/docs/state-management/drift-detection.md","tags":[],"version":"current","frontMatter":{},"sidebar":"sidebar","previous":{"title":"Apollo Client Configuration","permalink":"/docs/frontend/state-management/apollo-client"},"next":{"title":"State Management Overview","permalink":"/docs/frontend/state-management/overview"}}');var r=i(31085),s=i(71184);const c={},l="Drift Detection System",d={},o=[{value:"Architecture Overview",id:"architecture-overview",level:2},{value:"Types",id:"types",level:2},{value:"DriftStatus",id:"driftstatus",level:3},{value:"DriftedField",id:"driftedfield",level:3},{value:"DriftResult",id:"driftresult",level:3},{value:"ResourcePriority",id:"resourcepriority",level:3},{value:"RUNTIME_ONLY_FIELDS",id:"runtime_only_fields",level:3},{value:"DriftResolutionAction",id:"driftresolutionaction",level:3},{value:"Hashing \u2014 FNV-1a",id:"hashing--fnv-1a",level:2},{value:"Algorithm",id:"algorithm",level:3},{value:"Normalization before hashing",id:"normalization-before-hashing",level:3},{value:"Quick comparison",id:"quick-comparison",level:3},{value:"Field-Level Diff",id:"field-level-diff",level:2},{value:"Walk strategy",id:"walk-strategy",level:3},{value:"Category classification",id:"category-classification",level:3},{value:"Usage",id:"usage",level:3},{value:"React Hooks",id:"react-hooks",level:2},{value:"useDriftDetection",id:"usedriftdetection",level:3},{value:"useQuickDriftCheck",id:"usequickdriftcheck",level:3},{value:"useBatchDriftStatus",id:"usebatchdriftstatus",level:3},{value:"Internal detectDrift function",id:"internal-detectdrift-function",level:3},{value:"Reconciliation Scheduler",id:"reconciliation-scheduler",level:2},{value:"Class interface",id:"class-interface",level:3},{value:"Priority intervals",id:"priority-intervals",level:3},{value:"Scheduling algorithm",id:"scheduling-algorithm",level:3},{value:"Offline behavior",id:"offline-behavior",level:3},{value:"Usage",id:"usage-1",level:3},{value:"Two-Phase Detection in Practice",id:"two-phase-detection-in-practice",level:2},{value:"Integration with Apollo Cache",id:"integration-with-apollo-cache",level:2},{value:"Related Documentation",id:"related-documentation",level:2}];function a(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",mermaid:"mermaid",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"drift-detection-system",children:"Drift Detection System"})}),"\n",(0,r.jsxs)(n.p,{children:["Source: ",(0,r.jsx)(n.code,{children:"libs/state/stores/src/drift-detection/"})]}),"\n",(0,r.jsxs)(n.p,{children:["The drift detection system compares the ",(0,r.jsx)(n.strong,{children:"desired configuration"})," stored in the Apollo cache against\nthe ",(0,r.jsx)(n.strong,{children:"live state"})," returned by a re-fetch, identifying fields that have changed on the router\nwithout going through NasNet. It uses a two-phase approach: a fast hash comparison to detect whether\nany change occurred, followed by a field-level diff only when the hashes differ."]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"architecture-overview",children:"Architecture Overview"}),"\n",(0,r.jsx)(n.mermaid,{value:'graph TD\n    A["Apollo Cache<br/>(desired)"] --\x3e B["detectDrift"]\n    C["Router<br/>(live)"] --\x3e B\n    B --\x3e D["Phase 1: Hash<br/>FNV-1a 32-bit"]\n    D --\x3e|mismatch| E["Phase 2: Diff<br/>findDriftedFields()"]\n    D --\x3e|match| F["DriftResult<br/>SYNCED"]\n    E --\x3e G["DriftResult<br/>status, driftedFields, fieldCount"]'}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"ReconciliationScheduler"})," drives periodic re-fetches. It assigns each resource a priority that\ncontrols how often it checks."]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"types",children:"Types"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"File:"})," ",(0,r.jsx)(n.code,{children:"libs/state/stores/src/drift-detection/types.ts"})]}),"\n",(0,r.jsx)(n.h3,{id:"driftstatus",children:"DriftStatus"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"type DriftStatus =\n  | 'SYNCED' // Hashes match \u2014 no fields have changed\n  | 'DRIFTED' // Fields differ between cache and live state\n  | 'ERROR' // Re-fetch or comparison threw an error\n  | 'CHECKING' // Comparison in progress\n  | 'PENDING'; // Not yet checked\n"})}),"\n",(0,r.jsx)(n.h3,{id:"driftedfield",children:"DriftedField"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"interface DriftedField {\n  path: string; // Dot-notation path, e.g. 'network.gateway'\n  cachedValue: unknown; // Value in Apollo cache\n  liveValue: unknown; // Value from router\n  category: 'network' | 'security' | 'general';\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"driftresult",children:"DriftResult"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"interface DriftResult {\n  status: DriftStatus;\n  driftedFields: DriftedField[];\n  fieldCount: number;\n  checkedAt: Date;\n  resourceId: string;\n  cachedHash: string;\n  liveHash: string;\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"resourcepriority",children:"ResourcePriority"}),"\n",(0,r.jsxs)(n.p,{children:["Controls the polling interval used by ",(0,r.jsx)(n.code,{children:"ReconciliationScheduler"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"enum ResourcePriority {\n  HIGH = 'HIGH', // 5-minute check interval\n  NORMAL = 'NORMAL', // 15-minute check interval\n  LOW = 'LOW', // 60-minute check interval\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Default assignments:"})}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Priority"}),(0,r.jsx)(n.th,{children:"Resource Types"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"HIGH"}),(0,r.jsx)(n.td,{children:"WAN interfaces, VPN tunnels"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"NORMAL"}),(0,r.jsx)(n.td,{children:"LAN interfaces, DHCP servers, firewall rules"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"LOW"}),(0,r.jsx)(n.td,{children:"Logging, DNS settings"})]})]})]}),"\n",(0,r.jsx)(n.h3,{id:"runtime_only_fields",children:"RUNTIME_ONLY_FIELDS"}),"\n",(0,r.jsx)(n.p,{children:"Fields excluded from all drift comparisons because they change constantly during normal operation\nand do not represent configuration drift:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"const RUNTIME_ONLY_FIELDS = new Set([\n  'bytesIn',\n  'bytesOut',\n  'packetsIn',\n  'packetsOut',\n  'txRate',\n  'rxRate',\n  'lastHandshake',\n  'uptime',\n  'status',\n  'isRunning',\n  // ... additional runtime metrics\n]);\n"})}),"\n",(0,r.jsx)(n.p,{children:"Excluding these prevents false positives from traffic counters and uptime ticks."}),"\n",(0,r.jsx)(n.h3,{id:"driftresolutionaction",children:"DriftResolutionAction"}),"\n",(0,r.jsx)(n.p,{children:"When drift is detected, the UI presents resolution options:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"type DriftResolutionAction =\n  | 'APPLY_CACHED' // Push cached (desired) config back to router\n  | 'ACCEPT_LIVE' // Update Apollo cache to match live state\n  | 'IGNORE' // Dismiss without action\n  | 'INVESTIGATE'; // Open diagnostic view\n"})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"hashing--fnv-1a",children:"Hashing \u2014 FNV-1a"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"File:"})," ",(0,r.jsx)(n.code,{children:"libs/state/stores/src/drift-detection/driftUtils.ts"})]}),"\n",(0,r.jsx)(n.h3,{id:"algorithm",children:"Algorithm"}),"\n",(0,r.jsxs)(n.p,{children:["The system uses ",(0,r.jsx)(n.strong,{children:"FNV-1a 32-bit"})," (Fowler\u2013Noll\u2013Vo) to produce a deterministic hash of a normalized\nresource snapshot. FNV-1a was chosen because:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["It is fast for small-to-medium objects (router config is typically ",(0,r.jsx)(n.code,{children:"<10 KB"}),")"]}),"\n",(0,r.jsx)(n.li,{children:"It produces a stable 32-bit unsigned integer"}),"\n",(0,r.jsx)(n.li,{children:"The JavaScript implementation is compact (no external dependency)"}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"const FNV_OFFSET_BASIS = 2166136261;\nconst FNV_PRIME = 16777619;\n\nfunction fnv1aHash(str: string): number {\n  let hash = FNV_OFFSET_BASIS;\n  for (let i = 0; i < str.length; i++) {\n    hash ^= str.charCodeAt(i);\n    hash = Math.imul(hash, FNV_PRIME);\n  }\n  // Force to 32-bit unsigned integer\n  return hash >>> 0;\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"Math.imul"})," is used for multiplication to correctly simulate 32-bit integer overflow in JavaScript,\nwhich would otherwise use 64-bit floating point."]}),"\n",(0,r.jsx)(n.h3,{id:"normalization-before-hashing",children:"Normalization before hashing"}),"\n",(0,r.jsxs)(n.p,{children:["Before hashing, objects are normalized to ensure deterministic output regardless of key insertion\norder or ",(0,r.jsx)(n.code,{children:"Date"})," vs string representation:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"function normalizeForComparison(value: unknown): unknown {\n  if (value instanceof Date) {\n    return value.toISOString();\n  }\n  if (Array.isArray(value)) {\n    return value.map(normalizeForComparison);\n  }\n  if (value !== null && typeof value === 'object') {\n    // Sort keys alphabetically for deterministic JSON\n    return Object.keys(value)\n      .sort()\n      .reduce<Record<string, unknown>>((acc, key) => {\n        acc[key] = normalizeForComparison((value as Record<string, unknown>)[key]);\n        return acc;\n      }, {});\n  }\n  return value;\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"Key transformations:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Dates"})," \u2192 ISO 8601 strings (prevents ",(0,r.jsx)(n.code,{children:"Date"})," vs string mismatch)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Object keys"})," \u2192 sorted alphabetically (prevents false positives from key order)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Arrays"})," \u2192 elements normalized recursively (order preserved intentionally)"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"The public entry point:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"export function computeHash(obj: unknown): string {\n  const normalized = normalizeForComparison(obj);\n  const serialized = JSON.stringify(normalized);\n  return String(fnv1aHash(serialized));\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"quick-comparison",children:"Quick comparison"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"hasQuickDrift()"})," checks only the hash without performing a full field diff. Used in list views\nwhere computing full diffs for dozens of rows simultaneously would be expensive:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"export function hasQuickDrift(cached: unknown, live: unknown): boolean {\n  if (cached === live) return false;\n  return computeHash(cached) !== computeHash(live);\n}\n"})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"field-level-diff",children:"Field-Level Diff"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"File:"})," ",(0,r.jsx)(n.code,{children:"libs/state/stores/src/drift-detection/driftUtils.ts"})]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"findDriftedFields()"})," walks the object tree recursively and collects every leaf that differs between\nthe cached and live values:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"export function findDriftedFields(\n  cached: Record<string, unknown>,\n  live: Record<string, unknown>,\n  path = ''\n): DriftedField[];\n"})}),"\n",(0,r.jsx)(n.h3,{id:"walk-strategy",children:"Walk strategy"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"Collect all keys from both objects (union)."}),"\n",(0,r.jsxs)(n.li,{children:["For each key, skip if it is in ",(0,r.jsx)(n.code,{children:"RUNTIME_ONLY_FIELDS"}),"."]}),"\n",(0,r.jsx)(n.li,{children:"If both values are plain objects, recurse with the dotted path."}),"\n",(0,r.jsxs)(n.li,{children:["If values differ (using normalized string comparison), emit a ",(0,r.jsx)(n.code,{children:"DriftedField"}),"."]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"category-classification",children:"Category classification"}),"\n",(0,r.jsx)(n.p,{children:"Each drifted field is tagged with a category based on path prefix:"}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Path prefix"}),(0,r.jsx)(n.th,{children:"Category"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsxs)(n.td,{children:[(0,r.jsx)(n.code,{children:"network.*"}),", ",(0,r.jsx)(n.code,{children:"ip.*"}),", ",(0,r.jsx)(n.code,{children:"gateway.*"}),", ",(0,r.jsx)(n.code,{children:"dns.*"})]}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"network"})})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsxs)(n.td,{children:[(0,r.jsx)(n.code,{children:"firewall.*"}),", ",(0,r.jsx)(n.code,{children:"nat.*"}),", ",(0,r.jsx)(n.code,{children:"auth.*"}),", ",(0,r.jsx)(n.code,{children:"password.*"})]}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"security"})})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"everything else"}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"general"})})]})]})]}),"\n",(0,r.jsx)(n.p,{children:"This allows the UI to group and prioritize drift notifications \u2014 security category drifts are shown\nwith higher urgency."}),"\n",(0,r.jsx)(n.h3,{id:"usage",children:"Usage"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"import { findDriftedFields, hasQuickDrift } from '@nasnet/state/stores';\n\n// Quick check (hash only)\nif (hasQuickDrift(cached, live)) {\n  // Full diff\n  const drifted = findDriftedFields(cached, live);\n  // drifted: [{ path: 'network.gateway', cachedValue: '192.168.1.1', liveValue: '10.0.0.1', category: 'network' }]\n}\n"})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"react-hooks",children:"React Hooks"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"File:"})," ",(0,r.jsx)(n.code,{children:"libs/state/stores/src/drift-detection/useDriftDetection.ts"})]}),"\n",(0,r.jsx)(n.h3,{id:"usedriftdetection",children:"useDriftDetection"}),"\n",(0,r.jsx)(n.p,{children:"Primary hook for a single resource. Memoizes the result by resource ID so repeated renders do not\ntrigger unnecessary recomputations:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"export function useDriftDetection(\n  resourceId: string,\n  options?: {\n    priority?: ResourcePriority;\n    onDriftDetected?: (result: DriftResult) => void;\n  }\n): {\n  status: DriftStatus;\n  driftedFields: DriftedField[];\n  fieldCount: number;\n  checkedAt: Date | null;\n  isChecking: boolean;\n  triggerCheck: () => void;\n};\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Parameter"}),(0,r.jsx)(n.th,{children:"Default"}),(0,r.jsx)(n.th,{children:"Description"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"resourceId"})}),(0,r.jsx)(n.td,{children:"required"}),(0,r.jsx)(n.td,{children:"ULID of the resource to monitor"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"priority"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"NORMAL"})}),(0,r.jsxs)(n.td,{children:["Polling priority; controls ",(0,r.jsx)(n.code,{children:"ReconciliationScheduler"})," interval"]})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"onDriftDetected"})}),(0,r.jsx)(n.td,{children:"\u2014"}),(0,r.jsx)(n.td,{children:"Callback fired when drift is first detected; not called for subsequent checks if already DRIFTED"})]})]})]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Example:"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-tsx",children:"function ResourceStatusBadge({ resourceId }: { resourceId: string }) {\n  const { status, fieldCount } = useDriftDetection(resourceId, {\n    priority: ResourcePriority.HIGH,\n    onDriftDetected: (result) => {\n      showWarning('Configuration drift', `${result.fieldCount} fields changed`);\n    },\n  });\n\n  if (status === 'DRIFTED') {\n    return <DriftBadge fieldCount={fieldCount} />;\n  }\n  return <SyncedBadge />;\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"usequickdriftcheck",children:"useQuickDriftCheck"}),"\n",(0,r.jsx)(n.p,{children:"Hash-only check for list views. Does not perform a full field diff, so it is cheaper for tables with\nmany rows:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"export function useQuickDriftCheck(resourceId: string): {\n  hasDrift: boolean;\n  isChecking: boolean;\n};\n"})}),"\n",(0,r.jsx)(n.p,{children:"Use this in table rows where you only need a visual indicator (badge, color) without the field\nbreakdown."}),"\n",(0,r.jsx)(n.h3,{id:"usebatchdriftstatus",children:"useBatchDriftStatus"}),"\n",(0,r.jsx)(n.p,{children:"Checks multiple resources at once, returning a map from resource ID to status:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"export function useBatchDriftStatus(resourceIds: string[]): Record<string, DriftStatus>;\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Example:"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-tsx",children:"function DriftSummaryPanel({ resourceIds }: { resourceIds: string[] }) {\n  const statusMap = useBatchDriftStatus(resourceIds);\n  const driftedCount = Object.values(statusMap).filter((s) => s === 'DRIFTED').length;\n\n  return <div>{driftedCount} resources have drifted</div>;\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"internal-detectdrift-function",children:"Internal detectDrift function"}),"\n",(0,r.jsxs)(n.p,{children:["Used by the hooks and by ",(0,r.jsx)(n.code,{children:"ReconciliationScheduler"}),". Not exported for direct use:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"async function detectDrift(resourceId: string): Promise<DriftResult> {\n  // 1. Read cached config from Apollo cache\n  // 2. Re-fetch live config from router\n  // 3. Normalize both (strip RUNTIME_ONLY_FIELDS)\n  // 4. Hash comparison (phase 1)\n  // 5. If hashes differ: findDriftedFields() (phase 2)\n  // 6. Return DriftResult\n}\n"})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"reconciliation-scheduler",children:"Reconciliation Scheduler"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"File:"})," ",(0,r.jsx)(n.code,{children:"libs/state/stores/src/drift-detection/reconciliationScheduler.ts"})]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"ReconciliationScheduler"})," is a singleton class that maintains a queue of resources to check and\nticks every 60 seconds to process due items."]}),"\n",(0,r.jsx)(n.h3,{id:"class-interface",children:"Class interface"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"class ReconciliationScheduler {\n  register(resourceId: string, priority: ResourcePriority): void;\n  unregister(resourceId: string): void;\n  start(): void;\n  stop(): void;\n  triggerImmediately(resourceId: string): void;\n  onDriftDetected(callback: (result: DriftResult) => void): () => void;\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"priority-intervals",children:"Priority intervals"}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Priority"}),(0,r.jsx)(n.th,{children:"Interval"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"HIGH"})}),(0,r.jsx)(n.td,{children:"5 minutes"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"NORMAL"})}),(0,r.jsx)(n.td,{children:"15 minutes"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"LOW"})}),(0,r.jsx)(n.td,{children:"60 minutes"})]})]})]}),"\n",(0,r.jsx)(n.h3,{id:"scheduling-algorithm",children:"Scheduling algorithm"}),"\n",(0,r.jsxs)(n.p,{children:["Each registered resource has a ",(0,r.jsx)(n.code,{children:"nextCheck"})," timestamp. On each 60-second tick, the scheduler:"]}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["Collects all resources where ",(0,r.jsx)(n.code,{children:"nextCheck <= now"}),"."]}),"\n",(0,r.jsx)(n.li,{children:"Batches them in groups of 10 (to avoid saturating the router API)."}),"\n",(0,r.jsxs)(n.li,{children:["Calls ",(0,r.jsx)(n.code,{children:"detectDrift()"})," for each batch item."]}),"\n",(0,r.jsxs)(n.li,{children:["Updates ",(0,r.jsx)(n.code,{children:"nextCheck = now + intervalForPriority(priority)"}),"."]}),"\n",(0,r.jsxs)(n.li,{children:["Emits ",(0,r.jsx)(n.code,{children:"onDriftDetected"})," for any ",(0,r.jsx)(n.code,{children:"DRIFTED"})," results."]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"The 60-second tick is the minimum resolution. HIGH priority resources are checked every 5 minutes =\n5 ticks between checks."}),"\n",(0,r.jsx)(n.h3,{id:"offline-behavior",children:"Offline behavior"}),"\n",(0,r.jsxs)(n.p,{children:["The scheduler pauses when ",(0,r.jsx)(n.code,{children:"useConnectionStore.getState().wsStatus !== 'connected'"}),". It resumes\nautomatically when the connection is restored, immediately re-checking HIGH priority resources that\nare overdue."]}),"\n",(0,r.jsx)(n.h3,{id:"usage-1",children:"Usage"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"ReconciliationScheduler"})," is managed internally by ",(0,r.jsx)(n.code,{children:"useDriftDetection"}),". Components do not interact\nwith it directly. The lifecycle is:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"// Inside useDriftDetection\nuseEffect(() => {\n  scheduler.register(resourceId, priority ?? ResourcePriority.NORMAL);\n  return () => scheduler.unregister(resourceId);\n}, [resourceId, priority]);\n"})}),"\n",(0,r.jsx)(n.p,{children:"The scheduler singleton is started once at app startup and runs for the session lifetime."}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"two-phase-detection-in-practice",children:"Two-Phase Detection in Practice"}),"\n",(0,r.jsx)(n.p,{children:"The two-phase design trades memory (storing hashes alongside full state) for CPU savings (skipping\nthe field walk when unchanged):"}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Phase"}),(0,r.jsx)(n.th,{children:"Complexity"}),(0,r.jsx)(n.th,{children:"Condition"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Phase 1"}),(0,r.jsx)(n.td,{children:"O(n) string hash comparison"}),(0,r.jsx)(n.td,{children:"Always"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Phase 2"}),(0,r.jsx)(n.td,{children:"O(n\xb2) object traversal"}),(0,r.jsx)(n.td,{children:"Only on hash mismatch"})]})]})]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Typical ratio:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"~95% of checks end at Phase 1 (SYNCED)"}),"\n",(0,r.jsx)(n.li,{children:"~5% proceed to Phase 2 (network noise, actual drift)"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"For a router with 50 registered resources at NORMAL priority:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"50 resources \xd7 hash check every 15 min = 3.3 hash checks per minute"}),"\n",(0,r.jsx)(n.li,{children:"Full diffs happen only when router config actually changes"}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"integration-with-apollo-cache",children:"Integration with Apollo Cache"}),"\n",(0,r.jsx)(n.p,{children:"Drift detection reads from and writes to the Apollo cache directly:"}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Direction"}),(0,r.jsx)(n.th,{children:"Action"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Read"}),(0,r.jsxs)(n.td,{children:["Reads ",(0,r.jsx)(n.code,{children:"cached"})," value from Apollo ",(0,r.jsx)(n.code,{children:"InMemoryCache"})," using resource UUID"]})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Accept live"}),(0,r.jsxs)(n.td,{children:["Writes ",(0,r.jsx)(n.code,{children:"live"})," value back to Apollo cache (",(0,r.jsx)(n.code,{children:"cache.writeFragment"}),")"]})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Apply cached"}),(0,r.jsxs)(n.td,{children:["Triggers a GraphQL mutation via ",(0,r.jsx)(n.code,{children:"applyConfig"})," to push cached state to router"]})]})]})]}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"ACCEPT_LIVE"})," resolution path updates the Apollo cache, which then propagates to all subscribed\ncomponents automatically via Apollo's reactive cache."]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"related-documentation",children:"Related Documentation"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"../architecture/provider-stack.md"})," \u2014 Where ",(0,r.jsx)(n.code,{children:"ReconciliationScheduler.start()"})," is called in the\nprovider initialization order"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"../cross-cutting-features/drift-detection-feature.md"})," \u2014 User-facing feature documentation (UI\nflows, resolution dialogs)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"apollo-client.md"})," \u2014 Apollo cache type policies; ",(0,r.jsx)(n.code,{children:"runtime"})," layer merge strategy used by drift\ndetection to get clean configuration snapshots"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"zustand-stores.md"})," \u2014 ",(0,r.jsx)(n.code,{children:"useConnectionStore"})," (used by scheduler for online/offline detection)"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(a,{...e})}):a(e)}}}]);