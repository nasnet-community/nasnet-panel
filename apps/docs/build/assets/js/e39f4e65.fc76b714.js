"use strict";(globalThis.webpackChunk_nas_net_docs=globalThis.webpackChunk_nas_net_docs||[]).push([[57644],{27836:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>a,contentTitle:()=>c,default:()=>u,frontMatter:()=>o,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"guides/testing-patterns","title":"Testing Patterns","description":"This guide documents the testing patterns and best practices used across libs/core in the NasNetConnect project.","source":"@site/../../libs/core/docs/guides/testing-patterns.md","sourceDirName":"guides","slug":"/guides/testing-patterns","permalink":"/docs/core/guides/testing-patterns","draft":false,"unlisted":false,"editUrl":"https://github.com/nasnet-community/nasnet-panel/tree/main/../../libs/core/docs/guides/testing-patterns.md","tags":[],"version":"current","sidebarPosition":10,"frontMatter":{"sidebar_position":10,"title":"Testing Patterns"},"sidebar":"sidebar","previous":{"title":"GraphQL Integration Guide","permalink":"/docs/core/guides/graphql-integration-guide"},"next":{"title":"State Machines Guide","permalink":"/docs/core/guides/state-machines-guide"}}');var r=t(31085),i=t(71184);const o={sidebar_position:10,title:"Testing Patterns"},c="Testing Patterns",a={},l=[{value:"Vitest Setup",id:"vitest-setup",level:2},{value:"Configuration",id:"configuration",level:3},{value:"Running Tests",id:"running-tests",level:3},{value:"Testing Pure Utility Functions",id:"testing-pure-utility-functions",level:2},{value:"Example: Network Validators",id:"example-network-validators",level:3},{value:"Example: Formatters",id:"example-formatters",level:3},{value:"Example: Dependency Graph",id:"example-dependency-graph",level:3},{value:"Example: Status Calculators",id:"example-status-calculators",level:3},{value:"Testing React Hooks",id:"testing-react-hooks",level:2},{value:"useReducedMotion (Accessibility Hook)",id:"usereducedmotion-accessibility-hook",level:3},{value:"useAutoScroll (Scroll Container Hook)",id:"useautoscroll-scroll-container-hook",level:3},{value:"useRelativeTime (Time Formatting Hook)",id:"userelativetime-time-formatting-hook",level:3},{value:"Testing Zod Schemas and Validators",id:"testing-zod-schemas-and-validators",level:2},{value:"Example: Network Configuration Schemas",id:"example-network-configuration-schemas",level:3},{value:"Testing Async Validation",id:"testing-async-validation",level:2},{value:"Mock Strategies",id:"mock-strategies",level:2},{value:"Mocking Router Responses",id:"mocking-router-responses",level:3},{value:"Mocking i18n",id:"mocking-i18n",level:3},{value:"Mocking Storage",id:"mocking-storage",level:3},{value:"Fixture Patterns",id:"fixture-patterns",level:2},{value:"Coverage Requirements",id:"coverage-requirements",level:2},{value:"Running Coverage Reports",id:"running-coverage-reports",level:3},{value:"Coverage Configuration",id:"coverage-configuration",level:3},{value:"Tips for Reaching Coverage",id:"tips-for-reaching-coverage",level:3},{value:"Summary",id:"summary",level:2},{value:"Further Reading",id:"further-reading",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"testing-patterns",children:"Testing Patterns"})}),"\n",(0,r.jsxs)(n.p,{children:["This guide documents the testing patterns and best practices used across ",(0,r.jsx)(n.code,{children:"libs/core"})," in the NasNetConnect project."]}),"\n",(0,r.jsx)(n.h2,{id:"vitest-setup",children:"Vitest Setup"}),"\n",(0,r.jsxs)(n.p,{children:["NasNetConnect uses ",(0,r.jsx)(n.strong,{children:"Vitest"})," as the test runner of choice, offering:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"4x faster"})," than Jest with native ESM support"]}),"\n",(0,r.jsx)(n.li,{children:"Native TypeScript support without transpilation overhead"}),"\n",(0,r.jsx)(n.li,{children:"Compatible with Jest APIs (easy migration path)"}),"\n",(0,r.jsx)(n.li,{children:"Parallel test execution by default"}),"\n",(0,r.jsx)(n.li,{children:"Better watch mode performance"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"configuration",children:"Configuration"}),"\n",(0,r.jsxs)(n.p,{children:["The Vitest configuration is located at ",(0,r.jsx)(n.code,{children:"apps/connect/vitest.config.ts"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"export default defineConfig({\n  plugins: [react()],\n  test: {\n    globals: true,\n    environment: 'jsdom',\n    setupFiles: ['@testing-library/jest-dom/vitest', './src/test/setup.ts'],\n    include: ['src/**/*.{test,spec}.{ts,tsx}'],\n    coverage: {\n      provider: 'v8',\n      thresholds: {\n        lines: 80,\n        branches: 75,\n        functions: 75,\n        statements: 80,\n      },\n    },\n  },\n});\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Key settings:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"environment: 'jsdom'"})," \u2014 Simulates browser environment for React components"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"globals: true"})," \u2014 Enables ",(0,r.jsx)(n.code,{children:"describe()"}),", ",(0,r.jsx)(n.code,{children:"it()"}),", ",(0,r.jsx)(n.code,{children:"expect()"})," without imports"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Coverage thresholds:"})," 80% lines, 75% branches (enforced in CI)"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"running-tests",children:"Running Tests"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"# Run all tests once\nnpm run test\n\n# Watch mode (re-run on file changes)\nnpm run test:watch\n\n# Run specific test file\nnpx vitest libs/core/utils/src/network/ip.test.ts\n\n# Generate coverage report\nnpx vitest --coverage\n"})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"testing-pure-utility-functions",children:"Testing Pure Utility Functions"}),"\n",(0,r.jsx)(n.p,{children:"Pure functions are the simplest to test \u2014 no mocks, no side effects, no global state."}),"\n",(0,r.jsx)(n.h3,{id:"example-network-validators",children:"Example: Network Validators"}),"\n",(0,r.jsxs)(n.p,{children:["Located in ",(0,r.jsx)(n.code,{children:"libs/core/utils/src/network/ip.test.ts"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"import { describe, it, expect } from 'vitest';\nimport {\n  isValidIPv4,\n  isValidSubnet,\n  compareIPv4,\n  isValidMACAddress,\n  formatMACAddress\n} from './ip';\n\ndescribe('IP Utilities', () => {\n  describe('isValidIPv4', () => {\n    it('should validate correct IPv4 addresses', () => {\n      expect(isValidIPv4('192.168.1.1')).toBe(true);\n      expect(isValidIPv4('10.0.0.0')).toBe(true);\n      expect(isValidIPv4('255.255.255.255')).toBe(true);\n    });\n\n    it('should reject invalid IPv4 addresses', () => {\n      expect(isValidIPv4('256.1.1.1')).toBe(false);\n      expect(isValidIPv4('192.168.1')).toBe(false);\n      expect(isValidIPv4('invalid')).toBe(false);\n    });\n  });\n\n  describe('isValidSubnet', () => {\n    it('should validate correct CIDR notation', () => {\n      expect(isValidSubnet('192.168.1.0/24')).toBe(true);\n      expect(isValidSubnet('10.0.0.0/8')).toBe(true);\n      expect(isValidSubnet('172.16.0.0/12')).toBe(true);\n    });\n\n    it('should reject invalid CIDR notation', () => {\n      expect(isValidSubnet('192.168.1.0')).toBe(false);  // Missing prefix\n      expect(isValidSubnet('192.168.1.0/33')).toBe(false);  // Invalid prefix\n      expect(isValidSubnet('256.1.1.1/24')).toBe(false);  // Invalid IP\n    });\n  });\n\n  describe('compareIPv4', () => {\n    it('should compare IP addresses numerically', () => {\n      expect(compareIPv4('192.168.1.1', '192.168.1.2')).toBeLessThan(0);\n      expect(compareIPv4('192.168.1.10', '192.168.1.2')).toBeGreaterThan(0);\n      expect(compareIPv4('192.168.1.1', '192.168.1.1')).toBe(0);\n    });\n\n    it('should sort IP addresses correctly', () => {\n      const ips = ['192.168.1.10', '192.168.1.2', '192.168.1.1', '10.0.0.1'];\n      const sorted = ips.sort(compareIPv4);\n      expect(sorted).toEqual(['10.0.0.1', '192.168.1.1', '192.168.1.2', '192.168.1.10']);\n    });\n  });\n\n  describe('isValidMACAddress', () => {\n    it('should validate MAC addresses with various separators', () => {\n      expect(isValidMACAddress('AA:BB:CC:DD:EE:FF')).toBe(true);\n      expect(isValidMACAddress('AA-BB-CC-DD-EE-FF')).toBe(true);\n      expect(isValidMACAddress('AABBCCDDEEFF')).toBe(true);\n    });\n\n    it('should reject invalid MAC addresses', () => {\n      expect(isValidMACAddress('AA:BB:CC:DD:EE')).toBe(false);  // Too short\n      expect(isValidMACAddress('GG:HH:II:JJ:KK:LL')).toBe(false);  // Invalid hex\n      expect(isValidMACAddress('')).toBe(false);  // Empty\n    });\n  });\n\n  describe('formatMACAddress', () => {\n    it('should format with consistent separators', () => {\n      expect(formatMACAddress('AABBCCDDEEFF')).toBe('AA:BB:CC:DD:EE:FF');\n      expect(formatMACAddress('AA-BB-CC-DD-EE-FF')).toBe('AA:BB:CC:DD:EE:FF');\n      expect(formatMACAddress('aabbccddeeff')).toBe('AA:BB:CC:DD:EE:FF');\n    });\n\n    it('should handle mixed case normalization', () => {\n      expect(formatMACAddress('AaBbCcDdEeFf')).toBe('AA:BB:CC:DD:EE:FF');\n    });\n  });\n});\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Pattern:"})," Test both valid and invalid inputs, edge cases, and common use cases."]}),"\n",(0,r.jsx)(n.h3,{id:"example-formatters",children:"Example: Formatters"}),"\n",(0,r.jsxs)(n.p,{children:["Located in ",(0,r.jsx)(n.code,{children:"libs/core/utils/src/formatters/formatters.test.ts"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"import { describe, it, expect } from 'vitest';\nimport {\n  formatBytes,\n  formatDuration,\n  formatUptime,\n  formatNumber,\n} from './index';\n\ndescribe('Formatter Utilities', () => {\n  describe('formatBytes', () => {\n    it('should format bytes to human readable size', () => {\n      expect(formatBytes(0)).toBe('0 B');\n      expect(formatBytes(1024)).toBe('1 KB');\n      expect(formatBytes(1024 * 1024)).toBe('1 MB');\n      expect(formatBytes(1024 * 1024 * 1024)).toBe('1 GB');\n    });\n\n    it('should respect decimal places', () => {\n      expect(formatBytes(1536, 1)).toBe('1.5 KB');\n      expect(formatBytes(1536, 2)).toBe('1.50 KB');\n    });\n  });\n\n  describe('formatDuration', () => {\n    it('should format milliseconds to human readable duration', () => {\n      expect(formatDuration(1000)).toBe('1s');\n      expect(formatDuration(60000)).toBe('1m');\n      expect(formatDuration(3600000)).toBe('1h');\n      expect(formatDuration(86400000)).toBe('1d');\n    });\n\n    it('should format combined durations', () => {\n      const duration = (1 * 86400 + 2 * 3600 + 30 * 60 + 45) * 1000;\n      const formatted = formatDuration(duration);\n      expect(formatted).toContain('d');\n      expect(formatted).toContain('h');\n      expect(formatted).toContain('m');\n    });\n  });\n\n  describe('formatUptime', () => {\n    it('should format uptime in seconds', () => {\n      expect(formatUptime(60)).toBe('1m');\n      expect(formatUptime(3600)).toBe('1h');\n      expect(formatUptime(86400)).toBe('1d');\n    });\n  });\n});\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Pattern:"})," Test boundary conditions, edge cases (0, null, empty), and typical inputs."]}),"\n",(0,r.jsx)(n.h3,{id:"example-dependency-graph",children:"Example: Dependency Graph"}),"\n",(0,r.jsxs)(n.p,{children:["Located in ",(0,r.jsx)(n.code,{children:"libs/core/utils/src/graph/dependency-graph.test.ts"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"import { describe, it, expect } from 'vitest';\nimport { topologicalSort, buildDependencyGraph } from './dependency-graph';\n\ndescribe('Dependency Graph Utilities', () => {\n  describe('topologicalSort', () => {\n    it('should sort items respecting dependencies', () => {\n      const items = [\n        { id: 'a', dependencies: [] },\n        { id: 'b', dependencies: ['a'] },\n        { id: 'c', dependencies: ['a', 'b'] },\n      ];\n      const sorted = topologicalSort(items);\n      expect(sorted[0].id).toBe('a');\n      expect(sorted[1].id).toBe('b');\n      expect(sorted[2].id).toBe('c');\n    });\n\n    it('should handle circular dependencies', () => {\n      const items = [\n        { id: 'a', dependencies: ['b'] },\n        { id: 'b', dependencies: ['a'] },\n      ];\n      expect(() => topologicalSort(items)).toThrow('Circular dependency detected');\n    });\n\n    it('should handle independent items', () => {\n      const items = [\n        { id: 'a', dependencies: [] },\n        { id: 'b', dependencies: [] },\n      ];\n      const sorted = topologicalSort(items);\n      expect(sorted).toHaveLength(2);\n    });\n  });\n\n  describe('buildDependencyGraph', () => {\n    it('should build graph structure from dependencies', () => {\n      const graph = buildDependencyGraph([\n        { id: 'a', dependencies: [] },\n        { id: 'b', dependencies: ['a'] },\n      ]);\n      expect(graph.get('a')).toBeDefined();\n      expect(graph.get('b')).toContain('a');\n    });\n  });\n});\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Pattern:"})," Algorithm tests verify ordering, handle edge cases (cycles, empty inputs)."]}),"\n",(0,r.jsx)(n.h3,{id:"example-status-calculators",children:"Example: Status Calculators"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"import { describe, it, expect } from 'vitest';\nimport { calculateStatus, mergeStatuses } from '@nasnet/core/utils';\n\ndescribe('Status Calculators', () => {\n  describe('calculateStatus', () => {\n    it('should return online when all checks pass', () => {\n      const status = calculateStatus({\n        latency: 50,\n        packetLoss: 0,\n        uptime: 99.9,\n        isConnected: true,\n      });\n      expect(status).toBe('online');\n    });\n\n    it('should return degraded when latency is high', () => {\n      const status = calculateStatus({\n        latency: 2000,  // High latency\n        packetLoss: 0,\n        uptime: 99.9,\n        isConnected: true,\n      });\n      expect(status).toBe('degraded');\n    });\n\n    it('should return offline when disconnected', () => {\n      const status = calculateStatus({\n        latency: 0,\n        packetLoss: 100,\n        uptime: 0,\n        isConnected: false,\n      });\n      expect(status).toBe('offline');\n    });\n  });\n\n  describe('mergeStatuses', () => {\n    it('should merge multiple statuses (worst wins)', () => {\n      expect(mergeStatuses(['online', 'online', 'degraded'])).toBe('degraded');\n      expect(mergeStatuses(['online', 'degraded', 'offline'])).toBe('offline');\n      expect(mergeStatuses(['online', 'online'])).toBe('online');\n    });\n  });\n});\n"})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"testing-react-hooks",children:"Testing React Hooks"}),"\n",(0,r.jsxs)(n.p,{children:["React hooks require ",(0,r.jsx)(n.code,{children:"renderHook"})," from ",(0,r.jsx)(n.code,{children:"@testing-library/react"})," to test in isolation."]}),"\n",(0,r.jsx)(n.h3,{id:"usereducedmotion-accessibility-hook",children:"useReducedMotion (Accessibility Hook)"}),"\n",(0,r.jsxs)(n.p,{children:["Located in ",(0,r.jsx)(n.code,{children:"libs/core/utils/src/hooks/useReducedMotion.test.ts"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';\nimport { renderHook, act } from '@testing-library/react';\nimport { useReducedMotion } from './useReducedMotion';\n\ndescribe('useReducedMotion', () => {\n  let matchMediaMock: ReturnType<typeof vi.fn>;\n\n  beforeEach(() => {\n    matchMediaMock = vi.fn().mockImplementation((query: string) => ({\n      matches: false,\n      media: query,\n      addEventListener: vi.fn(),\n      removeEventListener: vi.fn(),\n    }));\n    vi.stubGlobal('matchMedia', matchMediaMock);\n  });\n\n  afterEach(() => {\n    vi.unstubAllGlobals();\n  });\n\n  it('should return false when prefers-reduced-motion is not set', () => {\n    const { result } = renderHook(() => useReducedMotion());\n    expect(result.current).toBe(false);\n  });\n\n  it('should return true when user prefers reduced motion', () => {\n    matchMediaMock.mockImplementation((query: string) => ({\n      matches: query === '(prefers-reduced-motion: reduce)',\n      media: query,\n      addEventListener: vi.fn(),\n      removeEventListener: vi.fn(),\n    }));\n    const { result } = renderHook(() => useReducedMotion());\n    expect(result.current).toBe(true);\n  });\n\n  it('should update when preference changes', () => {\n    let changeHandler: ((event: any) => void) | null = null;\n\n    matchMediaMock.mockImplementation((query: string) => ({\n      matches: false,\n      media: query,\n      addEventListener: (event: string, handler: (e: any) => void) => {\n        if (event === 'change') changeHandler = handler;\n      },\n      removeEventListener: vi.fn(),\n    }));\n\n    const { result } = renderHook(() => useReducedMotion());\n    expect(result.current).toBe(false);\n\n    // Simulate preference change\n    act(() => {\n      changeHandler?.({ matches: true });\n    });\n\n    expect(result.current).toBe(true);\n  });\n\n  it('should clean up event listener on unmount', () => {\n    const removeListener = vi.fn();\n    matchMediaMock.mockImplementation((query: string) => ({\n      matches: false,\n      media: query,\n      addEventListener: vi.fn(),\n      removeEventListener: removeListener,\n    }));\n\n    const { unmount } = renderHook(() => useReducedMotion());\n    unmount();\n    expect(removeListener).toHaveBeenCalled();\n  });\n});\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Key patterns:"})}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["Mock ",(0,r.jsx)(n.code,{children:"matchMedia"})," using ",(0,r.jsx)(n.code,{children:"vi.fn()"})," and ",(0,r.jsx)(n.code,{children:"vi.stubGlobal()"})]}),"\n",(0,r.jsx)(n.li,{children:'Test both "not set" and "set" cases'}),"\n",(0,r.jsxs)(n.li,{children:["Simulate user preference changes with ",(0,r.jsx)(n.code,{children:"act()"})]}),"\n",(0,r.jsxs)(n.li,{children:["Verify cleanup with ",(0,r.jsx)(n.code,{children:"unmount()"})]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"useautoscroll-scroll-container-hook",children:"useAutoScroll (Scroll Container Hook)"}),"\n",(0,r.jsxs)(n.p,{children:["Located in ",(0,r.jsx)(n.code,{children:"libs/core/utils/src/hooks/useAutoScroll.test.ts"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"import { describe, it, expect, beforeEach, vi } from 'vitest';\nimport { renderHook, act, waitFor } from '@testing-library/react';\nimport { useRef } from 'react';\nimport { useAutoScroll } from './useAutoScroll';\n\ndescribe('useAutoScroll', () => {\n  let scrollContainer: HTMLDivElement;\n\n  beforeEach(() => {\n    // Create a mock scroll container with scroll properties\n    scrollContainer = document.createElement('div');\n    Object.defineProperty(scrollContainer, 'scrollHeight', {\n      writable: true,\n      value: 1000,\n    });\n    Object.defineProperty(scrollContainer, 'clientHeight', {\n      writable: true,\n      value: 500,\n    });\n    Object.defineProperty(scrollContainer, 'scrollTop', {\n      writable: true,\n      value: 0,\n    });\n    scrollContainer.scrollTo = vi.fn();\n  });\n\n  it('should detect when scrolled to bottom', async () => {\n    const { result } = renderHook(() => {\n      const scrollRef = useRef<HTMLDivElement>(scrollContainer);\n      return useAutoScroll({ scrollRef, data: [], threshold: 100 });\n    });\n\n    // Scroll to bottom: scrollTop + clientHeight >= scrollHeight - threshold\n    Object.defineProperty(scrollContainer, 'scrollTop', {\n      writable: true,\n      value: 500,  // 500 + 500 = 1000 >= (1000 - 100)\n    });\n\n    act(() => {\n      scrollContainer.dispatchEvent(new Event('scroll'));\n    });\n\n    await waitFor(() => {\n      expect(result.current.isAtBottom).toBe(true);\n    });\n  });\n\n  it('should detect when scrolled up from bottom', async () => {\n    const { result } = renderHook(() => {\n      const scrollRef = useRef<HTMLDivElement>(scrollContainer);\n      return useAutoScroll({ scrollRef, data: [], threshold: 100 });\n    });\n\n    // Scroll up significantly\n    Object.defineProperty(scrollContainer, 'scrollTop', {\n      writable: true,\n      value: 200,  // 200 + 500 = 700 < 900 (1000 - 100)\n    });\n\n    act(() => {\n      scrollContainer.dispatchEvent(new Event('scroll'));\n    });\n\n    await waitFor(() => {\n      expect(result.current.isAtBottom).toBe(false);\n    });\n  });\n\n  it('should track new entries count while scrolled up', () => {\n    const { result, rerender } = renderHook(\n      ({ data }) => {\n        const scrollRef = useRef<HTMLDivElement>(scrollContainer);\n        return useAutoScroll({ scrollRef, data });\n      },\n      { initialProps: { data: [1, 2, 3] } }\n    );\n\n    // Scroll up\n    Object.defineProperty(scrollContainer, 'scrollTop', {\n      writable: true,\n      value: 0,\n    });\n\n    act(() => {\n      scrollContainer.dispatchEvent(new Event('scroll'));\n    });\n\n    // Add new entries\n    act(() => {\n      rerender({ data: [1, 2, 3, 4, 5] });\n    });\n\n    expect(result.current.newEntriesCount).toBe(2);\n  });\n\n  it('should provide scrollToBottom function', () => {\n    const { result } = renderHook(() => {\n      const scrollRef = useRef<HTMLDivElement>(scrollContainer);\n      return useAutoScroll({ scrollRef, data: [] });\n    });\n\n    act(() => {\n      result.current.scrollToBottom();\n    });\n\n    expect(scrollContainer.scrollTo).toHaveBeenCalledWith({\n      top: 1000,\n      behavior: 'smooth',\n    });\n  });\n\n  it('should not track when disabled', () => {\n    const { rerender } = renderHook(\n      ({ data, enabled }) => {\n        const scrollRef = useRef<HTMLDivElement>(scrollContainer);\n        return useAutoScroll({ scrollRef, data, enabled });\n      },\n      { initialProps: { data: [1, 2, 3], enabled: false } }\n    );\n\n    Object.defineProperty(scrollContainer, 'scrollTop', {\n      writable: true,\n      value: 0,\n    });\n\n    act(() => {\n      rerender({ data: [1, 2, 3, 4, 5], enabled: false });\n    });\n\n    expect(scrollContainer.scrollTo).not.toHaveBeenCalled();\n  });\n});\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Key patterns:"})}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["Mock DOM element properties with ",(0,r.jsx)(n.code,{children:"Object.defineProperty()"})]}),"\n",(0,r.jsxs)(n.li,{children:["Simulate scroll events with ",(0,r.jsx)(n.code,{children:"dispatchEvent(new Event('scroll'))"})]}),"\n",(0,r.jsxs)(n.li,{children:["Use ",(0,r.jsx)(n.code,{children:"act()"})," to wrap state updates"]}),"\n",(0,r.jsxs)(n.li,{children:["Use ",(0,r.jsx)(n.code,{children:"rerender()"})," to test hook responses to prop changes"]}),"\n",(0,r.jsx)(n.li,{children:"Test edge cases: disabled state, threshold configuration"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"userelativetime-time-formatting-hook",children:"useRelativeTime (Time Formatting Hook)"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"import { describe, it, expect, beforeEach, afterEach, vi } from 'vitest';\nimport { renderHook, act, waitFor } from '@testing-library/react';\nimport { useRelativeTime } from './useRelativeTime';\n\ndescribe('useRelativeTime', () => {\n  beforeEach(() => {\n    vi.useFakeTimers();\n  });\n\n  afterEach(() => {\n    vi.restoreAllMocks();\n  });\n\n  it('should format time relative to now', () => {\n    const now = new Date();\n    const { result } = renderHook(() => useRelativeTime(now));\n    expect(result.current).toBe('just now');\n  });\n\n  it('should update when time advances', async () => {\n    const now = new Date();\n    const { result } = renderHook(() => useRelativeTime(now));\n    expect(result.current).toBe('just now');\n\n    // Advance time by 1 minute\n    act(() => {\n      vi.advanceTimersByTime(60000);\n    });\n\n    await waitFor(() => {\n      expect(result.current).toBe('1 minute ago');\n    });\n  });\n\n  it('should handle different time intervals', () => {\n    const testCases = [\n      { ms: 1000, expected: 'just now' },\n      { ms: 60000, expected: '1 minute ago' },\n      { ms: 3600000, expected: '1 hour ago' },\n    ];\n\n    testCases.forEach(({ ms, expected }) => {\n      const pastDate = new Date(Date.now() - ms);\n      const { result } = renderHook(() => useRelativeTime(pastDate));\n      expect(result.current).toBe(expected);\n    });\n  });\n});\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Key patterns:"})}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["Use ",(0,r.jsx)(n.code,{children:"vi.useFakeTimers()"})," to control time"]}),"\n",(0,r.jsxs)(n.li,{children:["Use ",(0,r.jsx)(n.code,{children:"vi.advanceTimersByTime()"})," to simulate passage of time"]}),"\n",(0,r.jsx)(n.li,{children:"Test multiple time intervals with parameterized tests"}),"\n",(0,r.jsxs)(n.li,{children:["Clean up with ",(0,r.jsx)(n.code,{children:"vi.restoreAllMocks()"})]}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"testing-zod-schemas-and-validators",children:"Testing Zod Schemas and Validators"}),"\n",(0,r.jsx)(n.p,{children:"Zod schemas are tested by verifying both valid and invalid inputs."}),"\n",(0,r.jsx)(n.h3,{id:"example-network-configuration-schemas",children:"Example: Network Configuration Schemas"}),"\n",(0,r.jsxs)(n.p,{children:["Located in ",(0,r.jsx)(n.code,{children:"libs/core/utils/src/validation/index.ts"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"import { describe, it, expect } from 'vitest';\nimport {\n  ipAddressSchema,\n  cidrSchema,\n  portSchema,\n  macAddressSchema,\n  routerConnectionConfigSchema,\n} from '@nasnet/core/utils';\n\ndescribe('Zod Validation Schemas', () => {\n  describe('ipAddressSchema', () => {\n    it('should validate correct IPv4 addresses', () => {\n      expect(ipAddressSchema.safeParse('192.168.1.1').success).toBe(true);\n      expect(ipAddressSchema.safeParse('10.0.0.0').success).toBe(true);\n      expect(ipAddressSchema.safeParse('255.255.255.255').success).toBe(true);\n    });\n\n    it('should reject invalid IPv4 addresses', () => {\n      expect(ipAddressSchema.safeParse('999.999.999.999').success).toBe(false);\n      expect(ipAddressSchema.safeParse('192.168.1').success).toBe(false);\n      expect(ipAddressSchema.safeParse('invalid').success).toBe(false);\n    });\n  });\n\n  describe('cidrSchema', () => {\n    it('should validate CIDR notation', () => {\n      expect(cidrSchema.safeParse('192.168.1.0/24').success).toBe(true);\n      expect(cidrSchema.safeParse('10.0.0.0/8').success).toBe(true);\n      expect(cidrSchema.safeParse('172.16.0.0/12').success).toBe(true);\n    });\n\n    it('should reject invalid CIDR notation', () => {\n      expect(cidrSchema.safeParse('192.168.1.0').success).toBe(false);  // Missing prefix\n      expect(cidrSchema.safeParse('192.168.1.0/33').success).toBe(false);  // Invalid prefix\n      expect(cidrSchema.safeParse('256.1.1.1/24').success).toBe(false);  // Invalid IP\n    });\n  });\n\n  describe('portSchema', () => {\n    it('should validate port numbers (1-65535)', () => {\n      expect(portSchema.safeParse(80).success).toBe(true);\n      expect(portSchema.safeParse(443).success).toBe(true);\n      expect(portSchema.safeParse(65535).success).toBe(true);\n    });\n\n    it('should reject invalid port numbers', () => {\n      expect(portSchema.safeParse(0).success).toBe(false);  // Min is 1\n      expect(portSchema.safeParse(70000).success).toBe(false);  // Max is 65535\n      expect(portSchema.safeParse(-1).success).toBe(false);  // Negative\n    });\n  });\n\n  describe('macAddressSchema', () => {\n    it('should validate MAC addresses', () => {\n      expect(macAddressSchema.safeParse('AA:BB:CC:DD:EE:FF').success).toBe(true);\n      expect(macAddressSchema.safeParse('AA-BB-CC-DD-EE-FF').success).toBe(true);\n      expect(macAddressSchema.safeParse('aabbccddeeff').success).toBe(true);\n    });\n\n    it('should reject invalid MAC addresses', () => {\n      expect(macAddressSchema.safeParse('AA:BB:CC:DD:EE').success).toBe(false);  // Too short\n      expect(macAddressSchema.safeParse('GG:HH:II:JJ:KK:LL').success).toBe(false);  // Invalid hex\n    });\n  });\n\n  describe('routerConnectionConfigSchema', () => {\n    it('should validate router connection config', () => {\n      const result = routerConnectionConfigSchema.safeParse({\n        address: '192.168.1.1',\n        username: 'admin',\n        password: 'secret',\n      });\n      expect(result.success).toBe(true);\n      if (result.success) {\n        expect(result.data.port).toBe(80);  // Default\n        expect(result.data.timeout).toBe(5000);  // Default\n      }\n    });\n\n    it('should use defaults for optional fields', () => {\n      const result = routerConnectionConfigSchema.safeParse({\n        address: '192.168.1.1',\n        username: 'admin',\n        password: 'secret',\n      });\n      expect(result.success).toBe(true);\n      if (result.success) {\n        expect(result.data.port).toBe(80);\n        expect(result.data.useTLS).toBe(false);\n      }\n    });\n\n    it('should reject invalid config', () => {\n      const result = routerConnectionConfigSchema.safeParse({\n        address: 'invalid',\n        username: '',  // Empty not allowed\n        password: 'secret',\n      });\n      expect(result.success).toBe(false);\n    });\n\n    it('should validate timeout bounds', () => {\n      const result = routerConnectionConfigSchema.safeParse({\n        address: '192.168.1.1',\n        username: 'admin',\n        password: 'secret',\n        timeout: 100,  // Too low (min: 1000)\n      });\n      expect(result.success).toBe(false);\n    });\n  });\n});\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Pattern:"})}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["Use ",(0,r.jsx)(n.code,{children:"safeParse()"})," which returns ",(0,r.jsx)(n.code,{children:"{ success: boolean; data?: T; error?: ZodError }"})]}),"\n",(0,r.jsx)(n.li,{children:"Test both valid and invalid cases"}),"\n",(0,r.jsx)(n.li,{children:"Test default values with optional fields"}),"\n",(0,r.jsx)(n.li,{children:"Test bounds and constraints (min, max, regex)"}),"\n",(0,r.jsx)(n.li,{children:"Test composed schemas with nested objects"}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"testing-async-validation",children:"Testing Async Validation"}),"\n",(0,r.jsx)(n.p,{children:"The validation pipeline supports 7 stages of async validation for complex workflows."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"import { describe, it, expect, beforeEach, vi } from 'vitest';\nimport { renderHook, act, waitFor } from '@testing-library/react';\nimport { useAsyncValidation } from '@nasnet/core/utils';\n\ndescribe('Async Validation', () => {\n  const mockValidatorFn = vi.fn().mockResolvedValue({\n    valid: true,\n    errors: [],\n  });\n\n  beforeEach(() => {\n    mockValidatorFn.mockClear();\n  });\n\n  it('should debounce validation calls', async () => {\n    const { result } = renderHook(() =>\n      useAsyncValidation(mockValidatorFn, { debounceMs: 300 })\n    );\n\n    // Trigger validation 3 times rapidly\n    act(() => {\n      result.current.validate({ field: 'value1' });\n      result.current.validate({ field: 'value2' });\n      result.current.validate({ field: 'value3' });\n    });\n\n    // Only the last call should execute\n    await waitFor(() => {\n      expect(mockValidatorFn).toHaveBeenCalledTimes(1);\n      expect(mockValidatorFn).toHaveBeenCalledWith({ field: 'value3' });\n    });\n  });\n\n  it('should cancel pending validations on new request', async () => {\n    const slowValidator = vi.fn(\n      () => new Promise(resolve => setTimeout(resolve, 1000))\n    );\n\n    const { result } = renderHook(() =>\n      useAsyncValidation(slowValidator)\n    );\n\n    act(() => {\n      result.current.validate({ attempt: 1 });\n    });\n\n    // Cancel and start new validation\n    act(() => {\n      result.current.cancel();\n      result.current.validate({ attempt: 2 });\n    });\n\n    await waitFor(() => {\n      expect(slowValidator).toHaveBeenCalledWith({ attempt: 2 });\n    });\n  });\n\n  it('should handle validation errors', async () => {\n    const errorValidator = vi.fn().mockRejectedValue(\n      new Error('Validation failed')\n    );\n\n    const { result } = renderHook(() =>\n      useAsyncValidation(errorValidator)\n    );\n\n    act(() => {\n      result.current.validate({ field: 'value' });\n    });\n\n    await waitFor(() => {\n      expect(result.current.error).toBeTruthy();\n      expect(result.current.error?.message).toBe('Validation failed');\n    });\n  });\n\n  it('should track validation state', async () => {\n    const { result } = renderHook(() =>\n      useAsyncValidation(mockValidatorFn)\n    );\n\n    expect(result.current.isValidating).toBe(false);\n\n    act(() => {\n      result.current.validate({ field: 'value' });\n    });\n\n    expect(result.current.isValidating).toBe(true);\n\n    await waitFor(() => {\n      expect(result.current.isValidating).toBe(false);\n      expect(result.current.result).toBeDefined();\n    });\n  });\n});\n"})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"mock-strategies",children:"Mock Strategies"}),"\n",(0,r.jsx)(n.h3,{id:"mocking-router-responses",children:"Mocking Router Responses"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"import { describe, it, expect, beforeEach, vi } from 'vitest';\nimport { MockedProvider } from '@apollo/client/testing';\nimport { renderHook, waitFor } from '@testing-library/react';\nimport { useGetDHCPLeases } from '@nasnet/api-client/queries';\n\ndescribe('Router Query Mocks', () => {\n  it('should handle successful router query', async () => {\n    const mocks = [\n      {\n        request: {\n          query: GET_DHCP_LEASES,\n          variables: { routerId: 'router-1' },\n        },\n        result: {\n          data: {\n            dhcpLeases: [\n              { id: '1', address: '192.168.1.100', hostname: 'device-1' },\n              { id: '2', address: '192.168.1.101', hostname: 'device-2' },\n            ],\n          },\n        },\n      },\n    ];\n\n    const { result } = renderHook(\n      () => useGetDHCPLeases('router-1'),\n      {\n        wrapper: ({ children }) => (\n          <MockedProvider mocks={mocks} addTypename={false}>\n            {children}\n          </MockedProvider>\n        ),\n      }\n    );\n\n    await waitFor(() => {\n      expect(result.current.loading).toBe(false);\n      expect(result.current.data?.dhcpLeases).toHaveLength(2);\n    });\n  });\n\n  it('should handle router query errors', async () => {\n    const mocks = [\n      {\n        request: {\n          query: GET_DHCP_LEASES,\n          variables: { routerId: 'router-1' },\n        },\n        error: new Error('Connection timeout'),\n      },\n    ];\n\n    const { result } = renderHook(\n      () => useGetDHCPLeases('router-1'),\n      {\n        wrapper: ({ children }) => (\n          <MockedProvider mocks={mocks} addTypename={false}>\n            {children}\n          </MockedProvider>\n        ),\n      }\n    );\n\n    await waitFor(() => {\n      expect(result.current.error).toBeTruthy();\n      expect(result.current.error?.message).toContain('Connection timeout');\n    });\n  });\n});\n"})}),"\n",(0,r.jsx)(n.h3,{id:"mocking-i18n",children:"Mocking i18n"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"import { describe, it, expect, beforeEach, vi } from 'vitest';\n\n// Mock i18n module\nvi.mock('@nasnet/core/i18n', () => ({\n  useTranslation: () => ({\n    t: (key: string, ...args: any[]) => key,  // Return key as-is for testing\n  }),\n  useFormatters: () => ({\n    formatNumber: (n: number) => n.toLocaleString(),\n    formatDate: (d: Date) => d.toLocaleDateString(),\n  }),\n}));\n\ndescribe('i18n Mocks', () => {\n  it('should provide mocked translation function', () => {\n    const { useTranslation } = require('@nasnet/core/i18n');\n    const { t } = useTranslation();\n    expect(t('common.save')).toBe('common.save');\n  });\n});\n"})}),"\n",(0,r.jsx)(n.h3,{id:"mocking-storage",children:"Mocking Storage"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"import { describe, it, expect, beforeEach, vi } from 'vitest';\n\ndescribe('Storage Mocks', () => {\n  beforeEach(() => {\n    // Create in-memory storage mock\n    const store: Record<string, string> = {};\n    const mockStorage = {\n      getItem: (key: string) => store[key] || null,\n      setItem: (key: string, value: string) => {\n        store[key] = value;\n      },\n      removeItem: (key: string) => {\n        delete store[key];\n      },\n      clear: () => {\n        Object.keys(store).forEach(key => delete store[key]);\n      },\n      length: 0,\n      key: (index: number) => Object.keys(store)[index] || null,\n    };\n\n    Object.defineProperty(window, 'localStorage', {\n      value: mockStorage,\n      writable: true,\n    });\n\n    Object.defineProperty(window, 'sessionStorage', {\n      value: mockStorage,\n      writable: true,\n    });\n  });\n\n  it('should mock localStorage.setItem and getItem', () => {\n    localStorage.setItem('key', 'value');\n    expect(localStorage.getItem('key')).toBe('value');\n  });\n\n  it('should mock localStorage.removeItem', () => {\n    localStorage.setItem('key', 'value');\n    localStorage.removeItem('key');\n    expect(localStorage.getItem('key')).toBe(null);\n  });\n});\n"})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"fixture-patterns",children:"Fixture Patterns"}),"\n",(0,r.jsx)(n.p,{children:"Test data factories for creating consistent test fixtures:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"// libs/core/utils/src/__fixtures__/router.fixtures.ts\nexport const createMockRouter = (overrides = {}) => ({\n  id: 'router-1',\n  address: '192.168.1.1',\n  hostname: 'MikroTik',\n  version: '7.10',\n  uptime: 86400,\n  cpu: 45,\n  memory: 67,\n  ...overrides,\n});\n\nexport const createMockDHCPLease = (overrides = {}) => ({\n  id: 'lease-1',\n  address: '192.168.1.100',\n  hostname: 'device-1',\n  macAddress: 'AA:BB:CC:DD:EE:FF',\n  expiresAt: new Date(Date.now() + 86400000),\n  ...overrides,\n});\n\nexport const createMockFirewallRule = (overrides = {}) => ({\n  id: 'rule-1',\n  name: 'Allow SSH',\n  protocol: 'tcp',\n  destPort: 22,\n  action: 'accept',\n  enabled: true,\n  ...overrides,\n});\n\n// Usage in tests\ndescribe('Router Operations', () => {\n  it('should update router config', () => {\n    const router = createMockRouter({ address: '10.0.0.1' });\n    expect(router.address).toBe('10.0.0.1');\n  });\n});\n"})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"coverage-requirements",children:"Coverage Requirements"}),"\n",(0,r.jsxs)(n.p,{children:["Target coverage: ",(0,r.jsx)(n.strong,{children:"80%+ for lines and statements, 75%+ for branches and functions"}),"."]}),"\n",(0,r.jsx)(n.h3,{id:"running-coverage-reports",children:"Running Coverage Reports"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"# Generate coverage report\nnpx vitest --coverage\n\n# View HTML report\nopen coverage/index.html\n\n# Check coverage for specific file\nnpx vitest --coverage libs/core/utils/src/network/ip.ts\n"})}),"\n",(0,r.jsx)(n.h3,{id:"coverage-configuration",children:"Coverage Configuration"}),"\n",(0,r.jsxs)(n.p,{children:["From ",(0,r.jsx)(n.code,{children:"vitest.config.ts"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"coverage: {\n  provider: 'v8',\n  reporter: ['text', 'json', 'html', 'lcov'],\n  reportsDirectory: './coverage',\n  exclude: [\n    'node_modules/',\n    'src/test/',\n    '**/*.d.ts',\n    '**/*.config.*',\n    '**/types/**',\n    '**/__mocks__/**',\n  ],\n  thresholds: {\n    lines: 80,\n    branches: 75,\n    functions: 75,\n    statements: 80,\n  },\n},\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Excluding from coverage:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Type-only files (",(0,r.jsx)(n.code,{children:"**/*.d.ts"}),", ",(0,r.jsx)(n.code,{children:"**/types/**"}),")"]}),"\n",(0,r.jsxs)(n.li,{children:["Configuration files (",(0,r.jsx)(n.code,{children:"**/*.config.*"}),")"]}),"\n",(0,r.jsxs)(n.li,{children:["Test setup files (",(0,r.jsx)(n.code,{children:"src/test/**"}),")"]}),"\n",(0,r.jsxs)(n.li,{children:["Mock files (",(0,r.jsx)(n.code,{children:"**/__mocks__/**"}),")"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"tips-for-reaching-coverage",children:"Tips for Reaching Coverage"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Add missing edge cases"})," \u2014 Boundary values, null/undefined, empty collections"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Test error paths"})," \u2014 Throw statements, validation failures"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Test async flows"})," \u2014 Promises, callbacks, timeouts"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Test hook cleanup"})," \u2014 ",(0,r.jsx)(n.code,{children:"unmount()"}),", event listener removal"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Test accessibility"})," \u2014 ",(0,r.jsx)(n.code,{children:"vi.stubGlobal('matchMedia', ...)"})," for a11y tests"]}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Category"}),(0,r.jsx)(n.th,{children:"Pattern"}),(0,r.jsx)(n.th,{children:"Tool"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Pure functions"}),(0,r.jsxs)(n.td,{children:["Simple ",(0,r.jsx)(n.code,{children:"expect(func(input)).toBe(output)"})]}),(0,r.jsx)(n.td,{children:"Vitest"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Validators/Schemas"}),(0,r.jsxs)(n.td,{children:[(0,r.jsx)(n.code,{children:"safeParse()"})," with valid/invalid cases"]}),(0,r.jsx)(n.td,{children:"Zod + Vitest"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"React hooks"}),(0,r.jsxs)(n.td,{children:[(0,r.jsx)(n.code,{children:"renderHook()"})," + ",(0,r.jsx)(n.code,{children:"act()"})," + mocking"]}),(0,r.jsx)(n.td,{children:"@testing-library/react"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Async operations"}),(0,r.jsxs)(n.td,{children:[(0,r.jsx)(n.code,{children:"vi.fn().mockResolvedValue()"})," + ",(0,r.jsx)(n.code,{children:"waitFor()"})]}),(0,r.jsx)(n.td,{children:"Vitest + @testing-library"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"DOM/Timers"}),(0,r.jsxs)(n.td,{children:[(0,r.jsx)(n.code,{children:"vi.useFakeTimers()"}),", ",(0,r.jsx)(n.code,{children:"vi.stubGlobal()"})]}),(0,r.jsx)(n.td,{children:"Vitest"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Test data"}),(0,r.jsxs)(n.td,{children:["Factory functions in ",(0,r.jsx)(n.code,{children:"__fixtures__/"})]}),(0,r.jsx)(n.td,{children:"Fixtures"})]})]})]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"further-reading",children:"Further Reading"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"https://vitest.dev/",children:"Vitest Documentation"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"https://testing-library.com/react",children:"React Testing Library Docs"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"https://zod.dev/",children:"Zod Documentation"})}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"Docs/architecture/implementation-patterns/18-testing-strategy-patterns.md"})," \u2014 Full testing architecture guide"]}),"\n"]})]})}function u(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},71184:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>c});var s=t(14041);const r={},i=s.createContext(r);function o(e){const n=s.useContext(i);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),s.createElement(i.Provider,{value:n},e.children)}}}]);