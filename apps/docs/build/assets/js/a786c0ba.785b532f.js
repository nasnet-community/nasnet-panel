"use strict";(globalThis.webpackChunk_nas_net_docs=globalThis.webpackChunk_nas_net_docs||[]).push([[28379],{23773:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>o,default:()=>h,frontMatter:()=>a,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"state-management","title":"State Management Guide","description":"This document covers all state management patterns used in NasNetConnect. The application uses four distinct tools, each with a well-defined role. Choosing the wrong tool for a given situation is the most common source of bugs and unnecessary re-renders.","source":"@site/../../libs/features/docs/state-management.md","sourceDirName":".","slug":"/state-management","permalink":"/docs/features/state-management","draft":false,"unlisted":false,"editUrl":"https://github.com/nasnet-community/nasnet-panel/tree/main/../../libs/features/docs/state-management.md","tags":[],"version":"current","frontMatter":{},"sidebar":"sidebar","previous":{"title":"Routing and Navigation Architecture","permalink":"/docs/features/routing-and-navigation"},"next":{"title":"Testing and Storybook","permalink":"/docs/features/testing-and-storybook"}}');var s=t(31085),i=t(71184);const a={},o="State Management Guide",d={},c=[{value:"Table of Contents",id:"table-of-contents",level:2},{value:"Decision Tree",id:"decision-tree",level:2},{value:"Apollo Client \u2014 Server State",id:"apollo-client--server-state",level:2},{value:"Cache Architecture",id:"cache-architecture",level:3},{value:"Query Hook Pattern",id:"query-hook-pattern",level:3},{value:"Lazy Query Pattern",id:"lazy-query-pattern",level:3},{value:"Convenience Wrapper Pattern",id:"convenience-wrapper-pattern",level:3},{value:"Subscription Pattern",id:"subscription-pattern",level:3},{value:"Cache Policies Reference",id:"cache-policies-reference",level:3},{value:"Apollo Query Domains",id:"apollo-query-domains",level:3},{value:"Zustand Stores \u2014 UI State",id:"zustand-stores--ui-state",level:2},{value:"Performance-Critical Selector Pattern",id:"performance-critical-selector-pattern",level:3},{value:"Store Inventory",id:"store-inventory",level:3},{value:"useAuthStore",id:"useauthstore",level:4},{value:"useConnectionStore",id:"useconnectionstore",level:4},{value:"useThemeStore",id:"usethemestore",level:4},{value:"useChangeSetStore",id:"usechangesetstore",level:4},{value:"useHistoryStore",id:"usehistorystore",level:4},{value:"useServiceUIStore",id:"useserviceuistore",level:4},{value:"Firewall UI Stores",id:"firewall-ui-stores",level:4},{value:"Alert and Notification Stores",id:"alert-and-notification-stores",level:4},{value:"UI Infrastructure Stores",id:"ui-infrastructure-stores",level:4},{value:"Change Set Store Deep Dive",id:"change-set-store-deep-dive",level:3},{value:"Data Model",id:"data-model",level:4},{value:"Dependency Ordering",id:"dependency-ordering",level:4},{value:"Status Lifecycle",id:"status-lifecycle",level:4},{value:"Persistence Strategy",id:"persistence-strategy",level:4},{value:"Selectors",id:"selectors",level:4},{value:"React Hook Form + Zod \u2014 Form State",id:"react-hook-form--zod--form-state",level:2},{value:"Standard Form Pattern",id:"standard-form-pattern",level:3},{value:"Zod Schema Patterns",id:"zod-schema-patterns",level:3},{value:"Multi-Step Wizard with RHF",id:"multi-step-wizard-with-rhf",level:3},{value:"Integration with XState Wizards",id:"integration-with-xstate-wizards",level:3},{value:"Drift Detection",id:"drift-detection",level:2},{value:"Core Hook",id:"core-hook",level:3},{value:"Drift Result Shape",id:"drift-result-shape",level:3},{value:"Performance-Optimized Variant",id:"performance-optimized-variant",level:3},{value:"Batch Drift Status",id:"batch-drift-status",level:3},{value:"Apply-Confirm Drift",id:"apply-confirm-drift",level:3},{value:"History and Undo/Redo",id:"history-and-undoredo",level:2},{value:"Pushing an Action",id:"pushing-an-action",level:3},{value:"Performing Undo/Redo",id:"performing-undoredo",level:3},{value:"Scope Rules",id:"scope-rules",level:3},{value:"Keyboard Shortcuts",id:"keyboard-shortcuts",level:3},{value:"History Limits",id:"history-limits",level:3},{value:"Convenience Functions",id:"convenience-functions",level:3},{value:"Cross-Layer Integration Patterns",id:"cross-layer-integration-patterns",level:2},{value:"Apollo Mutation + Zustand Update",id:"apollo-mutation--zustand-update",level:3},{value:"XState + Apollo Subscription Bridge",id:"xstate--apollo-subscription-bridge",level:3},{value:"Form Data \u2192 Change Set",id:"form-data--change-set",level:3},{value:"Cross-References",id:"cross-references",level:2}];function l(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",hr:"hr",li:"li",mermaid:"mermaid",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"state-management-guide",children:"State Management Guide"})}),"\n",(0,s.jsx)(n.p,{children:"This document covers all state management patterns used in NasNetConnect. The application uses four distinct tools, each with a well-defined role. Choosing the wrong tool for a given situation is the most common source of bugs and unnecessary re-renders."}),"\n",(0,s.jsx)(n.h2,{id:"table-of-contents",children:"Table of Contents"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#decision-tree",children:"Decision Tree"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#apollo-client--server-state",children:"Apollo Client \u2014 Server State"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#zustand-stores--ui-state",children:"Zustand Stores \u2014 UI State"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#react-hook-form--zod--form-state",children:"React Hook Form + Zod \u2014 Form State"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#drift-detection",children:"Drift Detection"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#history-and-undoredo",children:"History and Undo/Redo"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#cross-layer-integration-patterns",children:"Cross-Layer Integration Patterns"})}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"decision-tree",children:"Decision Tree"}),"\n",(0,s.jsx)(n.p,{children:"Before writing any state code, answer these questions in order:"}),"\n",(0,s.jsx)(n.mermaid,{value:'flowchart TD\n    Start{"Is the data fetched from<br/>the router or backend?"} --\x3e|YES| Apollo["Apollo Client<br/>(GraphQL query/mutation/subscription)"]\n    Start --\x3e|NO| Step2{"Is it a multi-step workflow<br/>with complex conditional<br/>transitions?"}\n\n    Step2 --\x3e|YES| XState["XState machine<br/>(see xstate-machines.md)"]\n    Step2 --\x3e|NO| Step3{"Is it form input being<br/>validated before<br/>submission?"}\n\n    Step3 --\x3e|YES| RHF["React Hook Form + Zod"]\n    Step3 --\x3e|NO| Step4{"Is it ephemeral UI state<br/>(sidebar open, theme,<br/>modal visibility, filters)?"}\n\n    Step4 --\x3e|YES| Zustand["Zustand store"]\n    Step4 --\x3e|NO| Default["When in doubt: if it would<br/>make sense to include in<br/>a bug report reproduction,<br/>it is UI State Zustand.<br/>If it lives on the router,<br/>it is Server State Apollo."]\n\n    Apollo -.-> Hint1["\u2713 Router interfaces, VPN tunnels,<br/>DHCP leases"]\n    XState -.-> Hint2["\u2713 Config pipeline, VPN connect,<br/>troubleshoot"]\n    RHF -.-> Hint3["\u2713 Interface edit, VPN wizard,<br/>firewall rule"]\n    Zustand -.-> Hint4["\u2713 Theme, sidebar state,<br/>active router ID"]\n\n    style Apollo fill:#4ade80,color:#000\n    style XState fill:#60a5fa,color:#fff\n    style RHF fill:#fbbf24,color:#000\n    style Zustand fill:#f87171,color:#fff\n    style Default fill:#9ca3af,color:#fff'}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"State Type"}),(0,s.jsx)(n.th,{children:"Tool"}),(0,s.jsx)(n.th,{children:"Examples"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Server state"}),(0,s.jsx)(n.td,{children:"Apollo Client"}),(0,s.jsx)(n.td,{children:"Router interfaces, VPN tunnels, DHCP leases"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"UI preferences"}),(0,s.jsx)(n.td,{children:"Zustand"}),(0,s.jsx)(n.td,{children:"Theme, sidebar state, active router ID"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Transient UI"}),(0,s.jsx)(n.td,{children:"Zustand"}),(0,s.jsx)(n.td,{children:"Search filters, selected rows, modal open"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Complex workflows"}),(0,s.jsx)(n.td,{children:"XState"}),(0,s.jsx)(n.td,{children:"Config pipeline, VPN connect, troubleshoot"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Form data"}),(0,s.jsx)(n.td,{children:"React Hook Form"}),(0,s.jsx)(n.td,{children:"Interface edit, VPN wizard, firewall rule"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Form validation"}),(0,s.jsx)(n.td,{children:"Zod"}),(0,s.jsx)(n.td,{children:"Schema definitions, runtime type guards"})]})]})]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"apollo-client--server-state",children:"Apollo Client \u2014 Server State"}),"\n",(0,s.jsxs)(n.p,{children:["All data that originates from the router or backend is managed through Apollo Client's normalized cache. Query hooks live in ",(0,s.jsx)(n.code,{children:"libs/api-client/queries/src/"})," organized by domain."]}),"\n",(0,s.jsx)(n.h3,{id:"cache-architecture",children:"Cache Architecture"}),"\n",(0,s.jsxs)(n.p,{children:["Apollo stores all query results in a normalized in-memory cache keyed by ",(0,s.jsx)(n.code,{children:"__typename + id"}),". This means that when a mutation returns updated data for a ",(0,s.jsx)(n.code,{children:"WireGuardPeer"})," with ",(0,s.jsx)(n.code,{children:'id: "peer-1"'}),", every query that included that peer automatically receives the update \u2014 no manual state synchronization required."]}),"\n",(0,s.jsx)(n.h3,{id:"query-hook-pattern",children:"Query Hook Pattern"}),"\n",(0,s.jsx)(n.p,{children:"Every domain has its own query file. The pattern is consistent:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// libs/api-client/queries/src/change-set/useChangeSetQueries.ts\n\nimport { useQuery, useLazyQuery, type ApolloError } from '@apollo/client';\nimport { gql } from '@apollo/client';\nimport { CHANGE_SET_FULL_FRAGMENT } from './fragments';\n\nconst GET_CHANGE_SET_QUERY = gql`\n  query GetChangeSet($id: ID!, $routerId: ID!) {\n    changeSet(id: $id, routerId: $routerId) {\n      ...ChangeSetFull\n    }\n  }\n  ${CHANGE_SET_FULL_FRAGMENT}\n`;\n\nexport function useChangeSet(\n  routerId: string | undefined,\n  changeSetId: string | undefined,\n  options: GetChangeSetOptions = {}\n): {\n  changeSet: ChangeSet | undefined;\n  loading: boolean;\n  error: ApolloError | undefined;\n  refetch: () => Promise<void>;\n} {\n  const { skip = false, pollInterval, fetchPolicy = 'cache-first' } = options;\n\n  const { data, loading, error, refetch } = useQuery(GET_CHANGE_SET_QUERY, {\n    variables: { id: changeSetId, routerId },\n    skip: skip || !routerId || !changeSetId,\n    pollInterval,\n    fetchPolicy,\n  });\n\n  return {\n    changeSet: data?.changeSet,\n    loading,\n    error,\n    refetch: async () => { await refetch(); },\n  };\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"Key conventions:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Variables that may be undefined use ",(0,s.jsx)(n.code,{children:"skip: skip || !variable"})," to prevent firing with incomplete input."]}),"\n",(0,s.jsxs)(n.li,{children:["The return shape always unwraps the ",(0,s.jsx)(n.code,{children:"data?.field"})," accessor so callers never deal with the Apollo ",(0,s.jsx)(n.code,{children:"data"})," wrapper."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"fetchPolicy"})," defaults to ",(0,s.jsx)(n.code,{children:"'cache-first'"})," for read queries. Use ",(0,s.jsx)(n.code,{children:"'network-only'"})," when you must guarantee fresh data (e.g., after a mutation that may have been applied by another session)."]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"lazy-query-pattern",children:"Lazy Query Pattern"}),"\n",(0,s.jsxs)(n.p,{children:["For on-demand fetching (search, click-to-expand), use ",(0,s.jsx)(n.code,{children:"useLazyQuery"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"export function useLazyChangeSet(): {\n  fetch: (routerId: string, changeSetId: string) => Promise<ChangeSet | undefined>;\n  changeSet: ChangeSet | undefined;\n  loading: boolean;\n  error: ApolloError | undefined;\n} {\n  const [fetchQuery, { data, loading, error }] = useLazyQuery(GET_CHANGE_SET_QUERY);\n\n  const fetch = async (routerId: string, changeSetId: string) => {\n    const result = await fetchQuery({ variables: { id: changeSetId, routerId } });\n    return result.data?.changeSet;\n  };\n\n  return { fetch, changeSet: data?.changeSet, loading, error };\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"convenience-wrapper-pattern",children:"Convenience Wrapper Pattern"}),"\n",(0,s.jsx)(n.p,{children:"Thin wrappers add domain logic without duplicating query plumbing:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// Adds hasActive boolean derived from the list result\nexport function useActiveChangeSets(routerId, options) {\n  const result = useChangeSets(routerId, { ...options, includeCompleted: false });\n  return { ...result, hasActive: result.changeSets.length > 0 };\n}\n\n// Badge counter \u2014 computes pending count from shared query\nexport function usePendingChangeSetsCount(routerId) {\n  const { changeSets, loading } = useChangeSets(routerId, { includeCompleted: false });\n  const pendingCount = changeSets.filter(\n    (cs) => cs.status === 'DRAFT' || cs.status === 'READY'\n  ).length;\n  return { count: pendingCount, isLoading: loading };\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"subscription-pattern",children:"Subscription Pattern"}),"\n",(0,s.jsxs)(n.p,{children:["GraphQL subscriptions are used for real-time data: log streaming, update progress, alert notifications. The subscription hook wraps ",(0,s.jsx)(n.code,{children:"useSubscription"})," and feeds events into XState machines or Zustand stores:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// Pattern used in service update and alert streams\nuseEffect(() => {\n  if (progressEvent) {\n    send({ type: 'PROGRESS', stage: progressEvent.stage, progress: progressEvent.progress });\n    if (progressEvent.stage === 'COMPLETE') {\n      send({ type: 'COMPLETE', toVersion: progressEvent.newVersion });\n    }\n  }\n}, [progressEvent, send]);\n"})}),"\n",(0,s.jsx)(n.h3,{id:"cache-policies-reference",children:"Cache Policies Reference"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Policy"}),(0,s.jsx)(n.th,{children:"When to Use"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"cache-first"})}),(0,s.jsx)(n.td,{children:"Default. Read from cache, fetch only on miss."})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"cache-and-network"})}),(0,s.jsx)(n.td,{children:"Show cached data immediately, refresh in background."})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"network-only"})}),(0,s.jsx)(n.td,{children:"Always fetch fresh. Use after writes or for critical data."})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"no-cache"})}),(0,s.jsx)(n.td,{children:"Never cache. Diagnostics, one-shot operations."})]})]})]}),"\n",(0,s.jsx)(n.h3,{id:"apollo-query-domains",children:"Apollo Query Domains"}),"\n",(0,s.jsxs)(n.p,{children:["Queries are organized under ",(0,s.jsx)(n.code,{children:"libs/api-client/queries/src/"}),":"]}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Directory"}),(0,s.jsx)(n.th,{children:"Domain"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"alerts/"})}),(0,s.jsx)(n.td,{children:"Alert rules, templates, digest queue, history"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"batch/"})}),(0,s.jsx)(n.td,{children:"Batch job status polling"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"change-set/"})}),(0,s.jsx)(n.td,{children:"Change set CRUD and status"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"dhcp/"})}),(0,s.jsx)(n.td,{children:"DHCP servers and lease queries"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"diagnostics/"})}),(0,s.jsx)(n.td,{children:"Ping, traceroute, circuit breaker"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"discovery/"})}),(0,s.jsx)(n.td,{children:"Router connection testing"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"dns/"})}),(0,s.jsx)(n.td,{children:"DNS settings and cache operations"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"firewall/"})}),(0,s.jsx)(n.td,{children:"Filter, mangle, NAT, raw rules, templates"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"network/"})}),(0,s.jsx)(n.td,{children:"Interfaces, bridges, VLANs, IP addresses, routes"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"notifications/"})}),(0,s.jsx)(n.td,{children:"In-app notification channels"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"oui/"})}),(0,s.jsx)(n.td,{children:"OUI vendor lookup"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"resources/"})}),(0,s.jsx)(n.td,{children:"Universal State v2 resource model operations"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"services/"})}),(0,s.jsx)(n.td,{children:"Feature marketplace, instances, VLANs, traffic"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"storage/"})}),(0,s.jsx)(n.td,{children:"Storage config, usage, info"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"system/"})}),(0,s.jsx)(n.td,{children:"IP services, system notes"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"vpn/"})}),(0,s.jsx)(n.td,{children:"PPP/IPsec active connections"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"wan/"})}),(0,s.jsx)(n.td,{children:"WAN interface queries and mutations"})]})]})]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"zustand-stores--ui-state",children:"Zustand Stores \u2014 UI State"}),"\n",(0,s.jsxs)(n.p,{children:["Zustand stores hold ephemeral UI state: things that do not exist on the router and are not tracked in Apollo's cache. All stores use ",(0,s.jsx)(n.code,{children:"devtools"})," middleware for Redux DevTools integration and ",(0,s.jsx)(n.code,{children:"persist"})," middleware for selective localStorage persistence."]}),"\n",(0,s.jsx)(n.h3,{id:"performance-critical-selector-pattern",children:"Performance-Critical Selector Pattern"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Always use selectors"})," to avoid unnecessary re-renders. Subscribing to the entire store causes the component to re-render on any state change:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// BAD - re-renders on any change to the store\nconst { wsStatus, routers } = useConnectionStore();\n\n// GOOD - re-renders only when wsStatus changes\nconst wsStatus = useConnectionStore(state => state.wsStatus);\n\n// GOOD - multiple fields with shallow comparison\nimport { useShallow } from 'zustand/react/shallow';\nconst { wsStatus, isReconnecting } = useConnectionStore(\n  useShallow(state => ({ wsStatus: state.wsStatus, isReconnecting: state.isReconnecting }))\n);\n"})}),"\n",(0,s.jsx)(n.h3,{id:"store-inventory",children:"Store Inventory"}),"\n",(0,s.jsx)(n.h4,{id:"useauthstore",children:"useAuthStore"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"File:"})," ",(0,s.jsx)(n.code,{children:"libs/state/stores/src/auth/auth.store.ts"}),"\n",(0,s.jsx)(n.strong,{children:"Purpose:"})," JWT tokens, user session, proactive token refresh.\n",(0,s.jsx)(n.strong,{children:"Persisted:"})," ",(0,s.jsx)(n.code,{children:"token"}),", ",(0,s.jsx)(n.code,{children:"tokenExpiry"}),", ",(0,s.jsx)(n.code,{children:"refreshToken"}),", ",(0,s.jsx)(n.code,{children:"user"}),", ",(0,s.jsx)(n.code,{children:"isAuthenticated"}),"\n",(0,s.jsx)(n.strong,{children:"Not persisted:"})," ",(0,s.jsx)(n.code,{children:"isRefreshing"}),", ",(0,s.jsx)(n.code,{children:"refreshAttempts"})]}),"\n",(0,s.jsx)(n.p,{children:"Key state fields:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"interface AuthState {\n  token: string | null;              // JWT access token\n  tokenExpiry: Date | null;          // Expiration timestamp\n  refreshToken: string | null;       // For token renewal\n  user: User | null;                 // Profile: id, username, email, permissions[]\n  isAuthenticated: boolean;\n  isRefreshing: boolean;             // Refresh in progress\n  refreshAttempts: number;           // Max 3 before re-login required\n  lastActivity: Date | null;\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Token refresh flow: ",(0,s.jsx)(n.code,{children:"useTokenRefresh"})," hook polls ",(0,s.jsx)(n.code,{children:"isTokenExpiringSoon()"})," every minute. When it returns ",(0,s.jsx)(n.code,{children:"true"})," and ",(0,s.jsx)(n.code,{children:"shouldAttemptRefresh()"})," is ",(0,s.jsx)(n.code,{children:"true"}),", the hook calls the refresh API. On success, ",(0,s.jsx)(n.code,{children:"setAuth()"})," is called with the new token. On failure, ",(0,s.jsx)(n.code,{children:"incrementRefreshAttempts()"})," is called. After 3 failures, the session expiry dialog is shown."]}),"\n",(0,s.jsxs)(n.p,{children:["Key actions: ",(0,s.jsx)(n.code,{children:"setAuth(token, user, expiresAt, refreshToken?)"}),", ",(0,s.jsx)(n.code,{children:"clearAuth()"}),", ",(0,s.jsx)(n.code,{children:"isTokenExpiringSoon()"}),", ",(0,s.jsx)(n.code,{children:"shouldAttemptRefresh()"}),"."]}),"\n",(0,s.jsx)(n.h4,{id:"useconnectionstore",children:"useConnectionStore"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"File:"})," ",(0,s.jsx)(n.code,{children:"libs/state/stores/src/connection/connection.store.ts"}),"\n",(0,s.jsx)(n.strong,{children:"Purpose:"})," WebSocket status, per-router connections, reconnection state.\n",(0,s.jsx)(n.strong,{children:"Persisted:"})," ",(0,s.jsx)(n.code,{children:"activeRouterId"})," only."]}),"\n",(0,s.jsx)(n.p,{children:"Key state fields:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"interface ConnectionState {\n  wsStatus: 'connecting' | 'connected' | 'disconnected' | 'error';\n  wsError: string | null;\n  routers: Record<string, RouterConnection>;  // Per-router connection info\n  activeRouterId: string | null;\n  reconnectAttempts: number;\n  maxReconnectAttempts: number;               // Default: 10\n  isReconnecting: boolean;\n}\n\ninterface RouterConnection {\n  routerId: string;\n  status: WebSocketStatus;\n  protocol: 'rest' | 'api' | 'ssh';\n  latencyMs: number | null;\n  lastConnected: Date | null;\n  lastError: string | null;\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Key actions: ",(0,s.jsx)(n.code,{children:"setWsStatus(status, error?)"}),", ",(0,s.jsx)(n.code,{children:"setRouterConnection(routerId, connection)"}),", ",(0,s.jsx)(n.code,{children:"setActiveRouter(routerId)"}),", ",(0,s.jsx)(n.code,{children:"updateLatency(routerId, ms)"}),", ",(0,s.jsx)(n.code,{children:"incrementReconnectAttempts()"}),", ",(0,s.jsx)(n.code,{children:"resetReconnection()"}),", ",(0,s.jsx)(n.code,{children:"hasExceededMaxAttempts()"}),"."]}),"\n",(0,s.jsx)(n.h4,{id:"usethemestore",children:"useThemeStore"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"File:"})," ",(0,s.jsx)(n.code,{children:"libs/state/stores/src/ui/theme.store.ts"}),"\n",(0,s.jsx)(n.strong,{children:"Purpose:"})," Theme mode with localStorage persistence and system preference sync.\n",(0,s.jsx)(n.strong,{children:"Persisted:"})," ",(0,s.jsx)(n.code,{children:"theme"})," (the user preference).\n",(0,s.jsx)(n.strong,{children:"localStorage key:"})," ",(0,s.jsx)(n.code,{children:"nasnet-theme"})]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"interface ThemeState {\n  theme: 'light' | 'dark' | 'system';\n  resolvedTheme: 'light' | 'dark';  // Computed from theme + OS preference\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"resolvedTheme"})," is always ",(0,s.jsx)(n.code,{children:"'light'"})," or ",(0,s.jsx)(n.code,{children:"'dark'"}),". When ",(0,s.jsx)(n.code,{children:"theme === 'system'"}),", ",(0,s.jsx)(n.code,{children:"resolvedTheme"})," is computed from ",(0,s.jsx)(n.code,{children:"window.matchMedia('(prefers-color-scheme: dark)')"}),". The ",(0,s.jsx)(n.code,{children:"initThemeListener()"})," function sets up a ",(0,s.jsx)(n.code,{children:"MediaQueryList"})," listener to update ",(0,s.jsx)(n.code,{children:"resolvedTheme"})," when the OS preference changes. The ",(0,s.jsx)(n.code,{children:"syncThemeToDOM()"})," function subscribes to store changes and toggles the ",(0,s.jsx)(n.code,{children:"dark"})," class on ",(0,s.jsx)(n.code,{children:"document.documentElement"}),"."]}),"\n",(0,s.jsx)(n.h4,{id:"usechangesetstore",children:"useChangeSetStore"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"File:"})," ",(0,s.jsx)(n.code,{children:"libs/state/stores/src/change-set/change-set.store.ts"}),"\n",(0,s.jsx)(n.strong,{children:"Purpose:"})," Atomic multi-resource operation batches \u2014 the core of the Apply-Confirm-Merge pattern.\n",(0,s.jsx)(n.strong,{children:"Persisted:"})," Draft and READY change sets only (applying and completed change sets are not persisted).\n",(0,s.jsx)(n.strong,{children:"localStorage key:"})," ",(0,s.jsx)(n.code,{children:"nasnet-change-sets"})]}),"\n",(0,s.jsxs)(n.p,{children:["This store is covered in depth in the ",(0,s.jsx)(n.a,{href:"#change-set-store-deep-dive",children:"Change Set Store Deep Dive"})," section below."]}),"\n",(0,s.jsx)(n.h4,{id:"usehistorystore",children:"useHistoryStore"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"File:"})," ",(0,s.jsx)(n.code,{children:"libs/state/stores/src/history/history.store.ts"}),"\n",(0,s.jsx)(n.strong,{children:"Purpose:"})," Undo/redo history with command pattern (max 50 actions).\n",(0,s.jsx)(n.strong,{children:"Persisted:"})," Global-scope actions only (page-scope actions are ephemeral)."]}),"\n",(0,s.jsx)(n.h4,{id:"useserviceuistore",children:"useServiceUIStore"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"File:"})," ",(0,s.jsx)(n.code,{children:"libs/state/stores/src/service-ui.store.ts"}),"\n",(0,s.jsx)(n.strong,{children:"Purpose:"})," Feature marketplace UI state: search filters, installation wizard draft, view preferences.\n",(0,s.jsx)(n.strong,{children:"Persisted:"})," ",(0,s.jsx)(n.code,{children:"wizardDraft"}),", ",(0,s.jsx)(n.code,{children:"viewMode"}),", ",(0,s.jsx)(n.code,{children:"showResourceMetrics"}),", ",(0,s.jsx)(n.code,{children:"showAdvancedConfig"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"interface ServiceUIState {\n  // NOT persisted (ephemeral)\n  serviceSearch: string;\n  categoryFilter: ServiceCategory;     // 'all' | 'privacy' | 'proxy' | 'dns' | 'security' | 'monitoring'\n  statusFilter: ServiceStatusFilter;   // 'all' | 'available' | 'installed' | 'running' | 'stopped' | 'failed'\n  selectedServices: string[];\n  wizardStep: number;\n  updateInProgress: Record<string, boolean>;\n  updateStage: Record<string, UpdateStage>;\n  showUpdateAll: boolean;\n\n  // PERSISTED (survive page refresh)\n  wizardDraft: ServiceInstallWizardDraft | null;  // Recovery after accidental close\n  viewMode: 'grid' | 'list';\n  showResourceMetrics: boolean;\n  showAdvancedConfig: boolean;\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"wizardDraft"})," is persisted explicitly to support crash recovery: if the user was mid-way through a four-step installation wizard and refreshes the page, the wizard can restore their progress from the draft."]}),"\n",(0,s.jsx)(n.h4,{id:"firewall-ui-stores",children:"Firewall UI Stores"}),"\n",(0,s.jsx)(n.p,{children:"Domain-specific filter/sort state stores for each firewall subsection:"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Store File"}),(0,s.jsx)(n.th,{children:"Purpose"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"nat-ui.store.ts"})}),(0,s.jsx)(n.td,{children:"NAT rule table search, sort, column visibility"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"mangle-ui.store.ts"})}),(0,s.jsx)(n.td,{children:"Mangle rule filters and expanded state"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"raw-ui.store.ts"})}),(0,s.jsx)(n.td,{children:"Raw rule table filters"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"firewall-log-ui.store.ts"})}),(0,s.jsx)(n.td,{children:"Log viewer filters and scroll position"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"port-knock-ui.store.ts"})}),(0,s.jsx)(n.td,{children:"Port knocking UI panel state"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"rate-limiting-ui.store.ts"})}),(0,s.jsx)(n.td,{children:"Rate limit rule filter/search"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"dhcp-ui.store.ts"})}),(0,s.jsx)(n.td,{children:"DHCP lease filter and expanded pools"})]})]})]}),"\n",(0,s.jsx)(n.h4,{id:"alert-and-notification-stores",children:"Alert and Notification Stores"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Store File"}),(0,s.jsx)(n.th,{children:"Purpose"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"alert-notification.store.ts"})}),(0,s.jsx)(n.td,{children:"In-app notification queue and read state"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"alert-rule-template-ui.store.ts"})}),(0,s.jsx)(n.td,{children:"Alert template browser selection/preview state"})]})]})]}),"\n",(0,s.jsx)(n.h4,{id:"ui-infrastructure-stores",children:"UI Infrastructure Stores"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Store File"}),(0,s.jsx)(n.th,{children:"Purpose"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"ui/ui.store.ts"})}),(0,s.jsx)(n.td,{children:"Application-wide UI state (loading overlay, etc.)"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"ui/sidebar.store.ts"})}),(0,s.jsx)(n.td,{children:"Sidebar open/collapsed, pinned state"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"ui/modal.store.ts"})}),(0,s.jsx)(n.td,{children:"Modal stack management"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"ui/notification.store.ts"})}),(0,s.jsx)(n.td,{children:"Toast notification queue"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"ui/help-mode.store.ts"})}),(0,s.jsx)(n.td,{children:"Contextual help mode toggle"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"command/command-registry.store.ts"})}),(0,s.jsx)(n.td,{children:"Command palette command registration"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"command/shortcut-registry.store.ts"})}),(0,s.jsx)(n.td,{children:"Keyboard shortcut registration"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"router/router.store.ts"})}),(0,s.jsx)(n.td,{children:"Router list and selected router metadata"})]})]})]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h3,{id:"change-set-store-deep-dive",children:"Change Set Store Deep Dive"}),"\n",(0,s.jsx)(n.p,{children:"The change set store is the frontend implementation of the Apply-Confirm-Merge pattern. It holds batches of pending configuration changes that are validated, previewed, and applied atomically to the router."}),"\n",(0,s.jsx)(n.h4,{id:"data-model",children:"Data Model"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"interface ChangeSet {\n  id: string;\n  name: string;\n  description?: string;\n  routerId: string;\n  items: ChangeSetItem[];\n  status: ChangeSetStatus;  // DRAFT | READY | APPLYING | ROLLING_BACK | COMPLETED | FAILED | ROLLED_BACK | CANCELLED\n  validation: ChangeSetValidationResult | null;\n  rollbackPlan: RollbackStep[];\n  error: ChangeSetError | null;\n  createdAt: Date;\n  applyStartedAt: Date | null;\n  completedAt: Date | null;\n  source?: string;           // Which feature created this (e.g., 'lan-wizard')\n  version: number;           // Incremented on every mutation for optimistic locking\n}\n\ninterface ChangeSetItem {\n  id: string;\n  resourceType: string;      // e.g., 'network.bridge', 'vpn.wireguard-peer'\n  resourceCategory: string;\n  resourceUuid: string | null;\n  name: string;\n  operation: 'CREATE' | 'UPDATE' | 'DELETE';\n  configuration: Record<string, unknown>;\n  previousState: Record<string, unknown> | null;  // For rollback\n  dependencies: string[];    // Item IDs that must be applied first\n  status: ChangeSetItemStatus;  // PENDING | APPLYING | APPLIED | FAILED | ROLLED_BACK\n  applyOrder: number;        // Computed by topological sort\n}\n"})}),"\n",(0,s.jsx)(n.h4,{id:"dependency-ordering",children:"Dependency Ordering"}),"\n",(0,s.jsxs)(n.p,{children:["When ",(0,s.jsx)(n.code,{children:"addItem()"})," or ",(0,s.jsx)(n.code,{children:"setItemDependencies()"})," is called, the store automatically calls ",(0,s.jsx)(n.code,{children:"recalculateApplyOrder()"}),". This runs a topological sort on the dependency graph using ",(0,s.jsx)(n.code,{children:"buildDependencyGraph()"})," and ",(0,s.jsx)(n.code,{children:"computeApplyOrder()"})," from ",(0,s.jsx)(n.code,{children:"@nasnet/core/utils"}),". The result is stored as ",(0,s.jsx)(n.code,{children:"item.applyOrder"}),", which the XState ",(0,s.jsx)(n.code,{children:"changeSetMachine"})," reads when applying items in sequence."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// Example: Creating a LAN network requires bridge \u2192 IP address \u2192 DHCP server, in that order\nconst id = createChangeSet({ name: 'New LAN', routerId: 'router-1', source: 'lan-wizard' });\n\nconst bridgeId = addItem(id, {\n  name: 'Bridge Interface',\n  resourceType: 'network.bridge',\n  operation: 'CREATE',\n  configuration: { name: 'bridge-lan', vlanFiltering: true },\n  dependencies: [],\n});\n\nconst ipId = addItem(id, {\n  name: 'IP Address',\n  resourceType: 'network.ip-address',\n  operation: 'CREATE',\n  configuration: { address: '192.168.10.1/24', interface: 'bridge-lan' },\n  dependencies: [bridgeId],  // Bridge must exist first\n});\n\naddItem(id, {\n  name: 'DHCP Server',\n  resourceType: 'network.dhcp-server',\n  operation: 'CREATE',\n  configuration: { interface: 'bridge-lan', poolRange: '192.168.10.100-200' },\n  dependencies: [bridgeId, ipId],  // Both must exist first\n});\n"})}),"\n",(0,s.jsx)(n.h4,{id:"status-lifecycle",children:"Status Lifecycle"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"DRAFT \u2192 READY (after validation passes)\nREADY \u2192 APPLYING (user confirms)\nAPPLYING \u2192 COMPLETED (all items applied)\nAPPLYING \u2192 FAILED (item failed, rollback not available)\nAPPLYING \u2192 ROLLING_BACK (item failed, rollback executing)\nROLLING_BACK \u2192 ROLLED_BACK (all applied items reversed)\nROLLING_BACK \u2192 FAILED (rollback partially failed)\n"})}),"\n",(0,s.jsx)(n.h4,{id:"persistence-strategy",children:"Persistence Strategy"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// Only DRAFT and READY change sets survive page refresh\npartialize: (state) => ({\n  changeSets: Object.fromEntries(\n    Object.entries(state.changeSets).filter(\n      ([, cs]) => cs.status === CS.DRAFT || cs.status === CS.READY\n    )\n  ),\n  activeChangeSetId: state.activeChangeSetId,\n}),\n"})}),"\n",(0,s.jsx)(n.p,{children:"APPLYING, COMPLETED, FAILED, and ROLLED_BACK states are not persisted. If the page refreshes mid-apply, the backend is responsible for completing or rolling back the operation; the frontend reloads and shows the final state from the server."}),"\n",(0,s.jsx)(n.h4,{id:"selectors",children:"Selectors"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"import {\n  selectActiveChangeSet,\n  createSelectChangeSetsForRouter,\n  createSelectDraftChangeSets,\n  selectApplyingChangeSets,\n  selectIsAnyApplying,\n} from '@nasnet/state/stores';\n\n// In a component\nconst activeChangeSet = useChangeSetStore(selectActiveChangeSet);\nconst isApplying = useChangeSetStore(selectIsAnyApplying);\n\n// Router-specific (use factory selectors to avoid recreating on each render)\nconst selectRouterChangeSets = useMemo(\n  () => createSelectChangeSetsForRouter(routerId),\n  [routerId]\n);\nconst changeSets = useChangeSetStore(selectRouterChangeSets);\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"react-hook-form--zod--form-state",children:"React Hook Form + Zod \u2014 Form State"}),"\n",(0,s.jsx)(n.p,{children:"All forms in NasNetConnect use React Hook Form (RHF) with Zod schema validation. RHF manages field state, dirty tracking, and submission. Zod provides runtime validation and TypeScript type inference."}),"\n",(0,s.jsx)(n.h3,{id:"standard-form-pattern",children:"Standard Form Pattern"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"import { useForm } from 'react-hook-form';\nimport { zodResolver } from '@hookform/resolvers/zod';\nimport { z } from 'zod';\n\n// Step 1: Define schema (this is the single source of truth for types AND validation)\nconst interfaceSchema = z.object({\n  name: z.string().min(1, 'Name is required').max(15, 'Max 15 characters'),\n  address: z.string().ip({ version: 'v4', message: 'Must be a valid IPv4 address' }),\n  mtu: z.number().min(68).max(9000).default(1500),\n  disabled: z.boolean().default(false),\n  comment: z.string().max(255).optional(),\n});\n\ntype InterfaceFormValues = z.infer<typeof interfaceSchema>;\n\n// Step 2: Initialize form\nfunction InterfaceEditForm({ initialValues, onSubmit }) {\n  const form = useForm<InterfaceFormValues>({\n    resolver: zodResolver(interfaceSchema),\n    defaultValues: initialValues,\n    mode: 'onBlur',  // Validate on blur for better UX\n  });\n\n  const handleSubmit = form.handleSubmit(async (values) => {\n    // values is fully typed as InterfaceFormValues\n    // Zod has already validated and coerced all fields\n    await onSubmit(values);\n  });\n\n  return (\n    <Form {...form}>\n      <form onSubmit={handleSubmit}>\n        <FormField\n          control={form.control}\n          name=\"name\"\n          render={({ field }) => (\n            <FormItem>\n              <FormLabel>Interface Name</FormLabel>\n              <FormControl>\n                <Input {...field} />\n              </FormControl>\n              <FormMessage />  {/* Automatically shows Zod error */}\n            </FormItem>\n          )}\n        />\n        {/* ... */}\n      </form>\n    </Form>\n  );\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"zod-schema-patterns",children:"Zod Schema Patterns"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// IPv4 CIDR address (e.g., \"192.168.1.1/24\")\nconst cidrSchema = z\n  .string()\n  .regex(/^(\\d{1,3}\\.){3}\\d{1,3}\\/\\d{1,2}$/, 'Must be valid CIDR notation');\n\n// Port number\nconst portSchema = z.number().int().min(1).max(65535);\n\n// MAC address\nconst macSchema = z\n  .string()\n  .regex(/^([0-9A-Fa-f]{2}:){5}[0-9A-Fa-f]{2}$/, 'Must be valid MAC address');\n\n// MikroTik interface name (alphanumeric with hyphens, max 15 chars)\nconst interfaceNameSchema = z\n  .string()\n  .min(1)\n  .max(15)\n  .regex(/^[a-zA-Z0-9\\-\\.\\/]+$/, 'Only letters, numbers, hyphens, dots, and slashes');\n\n// VPN peer configuration\nconst wireguardPeerSchema = z.object({\n  publicKey: z.string().length(44, 'WireGuard public key must be 44 characters'),\n  presharedKey: z.string().length(44).optional(),\n  allowedAddresses: z.array(cidrSchema).min(1, 'At least one allowed address required'),\n  endpoint: z.string().optional(),\n  persistentKeepalive: z.number().min(0).max(65535).optional(),\n});\n\n// Discriminated union for different WAN types\nconst wanConfigSchema = z.discriminatedUnion('type', [\n  z.object({ type: z.literal('dhcp'), interface: interfaceNameSchema }),\n  z.object({ type: z.literal('pppoe'), username: z.string(), password: z.string() }),\n  z.object({ type: z.literal('static'), address: cidrSchema, gateway: z.string().ip() }),\n]);\n"})}),"\n",(0,s.jsx)(n.h3,{id:"multi-step-wizard-with-rhf",children:"Multi-Step Wizard with RHF"}),"\n",(0,s.jsx)(n.p,{children:"For wizards, each step has its own Zod schema. The wizard accumulates partial data across steps:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// Step 1 schema\nconst step1Schema = z.object({\n  featureId: z.string().min(1),\n  instanceName: z.string().min(1).max(30),\n});\n\n// Step 2 schema\nconst step2Schema = z.object({\n  vlanId: z.number().int().min(2).max(4094),\n  bindIp: z.string().ip({ version: 'v4' }),\n});\n\n// Combined (for final submission validation)\nconst fullWizardSchema = step1Schema.merge(step2Schema).merge(step3Schema);\n\n// In the wizard component, validate only the current step's fields\nconst form = useForm({ resolver: zodResolver(currentStepSchema) });\n"})}),"\n",(0,s.jsx)(n.h3,{id:"integration-with-xstate-wizards",children:"Integration with XState Wizards"}),"\n",(0,s.jsxs)(n.p,{children:["When using the ",(0,s.jsx)(n.code,{children:"createWizardMachine"})," from ",(0,s.jsx)(n.code,{children:"libs/state/machines/src/wizardMachine.ts"}),", the ",(0,s.jsx)(n.code,{children:"validateStep"})," callback bridges RHF with XState:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"const machine = createWizardMachine({\n  id: 'service-install',\n  totalSteps: 4,\n  validateStep: async (step, data) => {\n    // Use Zod to validate the step-specific fields\n    const stepSchema = STEP_SCHEMAS[step];\n    const result = stepSchema.safeParse(data);\n    if (!result.success) {\n      const errors: Record<string, string> = {};\n      result.error.issues.forEach(issue => {\n        errors[issue.path.join('.')] = issue.message;\n      });\n      return { valid: false, errors };\n    }\n    return { valid: true };\n  },\n  onSubmit: async (data) => {\n    await installService(data);\n  },\n});\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"drift-detection",children:"Drift Detection"}),"\n",(0,s.jsxs)(n.p,{children:["Drift detection compares the ",(0,s.jsx)(n.strong,{children:"configuration layer"})," (what the user has set) against the ",(0,s.jsx)(n.strong,{children:"deployment layer"})," (what is actually running on the router). This is part of the Universal State v2 8-layer resource model."]}),"\n",(0,s.jsx)(n.h3,{id:"core-hook",children:"Core Hook"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// libs/state/stores/src/drift-detection/useDriftDetection.ts\n\nconst { hasDrift, status, driftCount, result } = useDriftDetection({\n  configuration: resource.configuration,\n  deployment: resource.deployment,   // Contains generatedFields from router\n});\n\n// Status values\ntype DriftStatus = 'PENDING' | 'SYNCED' | 'DRIFTED' | 'ERROR';\n"})}),"\n",(0,s.jsxs)(n.p,{children:["The hook is memoized \u2014 drift is only recomputed when ",(0,s.jsx)(n.code,{children:"configuration"})," or ",(0,s.jsx)(n.code,{children:"deployment"})," changes (by reference). The computation hashes both objects and does an early exit on hash equality, making it cheap in list views."]}),"\n",(0,s.jsx)(n.h3,{id:"drift-result-shape",children:"Drift Result Shape"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"interface DriftResult {\n  hasDrift: boolean;\n  status: DriftStatus;\n  driftedFields: DriftedField[];  // Field-level diff for UI display\n  configurationHash: string;\n  deploymentHash: string;\n  lastChecked: Date;\n  isStale?: boolean;  // Deployment is older than staleThreshold\n  errorMessage?: string;\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"performance-optimized-variant",children:"Performance-Optimized Variant"}),"\n",(0,s.jsxs)(n.p,{children:["For list views where you only need to know ",(0,s.jsx)(n.em,{children:"if"})," drift exists (not ",(0,s.jsx)(n.em,{children:"what"})," drifted), use the hash-only check:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"const { hasDrift, status } = useQuickDriftCheck(\n  resource.configuration,\n  resource.deployment\n);\n"})}),"\n",(0,s.jsxs)(n.p,{children:["This skips the expensive field-level diff computation. Use ",(0,s.jsx)(n.code,{children:"useDriftDetection"})," only in detail views where you render which fields drifted."]}),"\n",(0,s.jsx)(n.h3,{id:"batch-drift-status",children:"Batch Drift Status"}),"\n",(0,s.jsx)(n.p,{children:"For tables showing many resources:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"const driftStatusMap = useBatchDriftStatus(resources);\n\n// In table row render\nconst status = driftStatusMap.get(resource.uuid);\n"})}),"\n",(0,s.jsx)(n.h3,{id:"apply-confirm-drift",children:"Apply-Confirm Drift"}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"useApplyConfirmDrift"})," hook specifically handles the case where the user is in the middle of applying a change set and the deployment layer reports a different state than expected. This triggers an alert to the user that the router state may have changed since the change set was created."]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"history-and-undoredo",children:"History and Undo/Redo"}),"\n",(0,s.jsxs)(n.p,{children:["The history store (",(0,s.jsx)(n.code,{children:"useHistoryStore"}),") implements the command pattern for undo/redo. It keeps two stacks: ",(0,s.jsx)(n.code,{children:"past"})," (executed actions) and ",(0,s.jsx)(n.code,{children:"future"})," (undone actions)."]}),"\n",(0,s.jsx)(n.h3,{id:"pushing-an-action",children:"Pushing an Action"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"import { useHistoryStore } from '@nasnet/state/stores';\n\nconst { pushAction } = useHistoryStore();\n\n// Before making a change, register undo/redo handlers\nconst actionId = pushAction({\n  type: 'edit',\n  description: 'Edit interface MTU',\n  scope: 'page',        // 'page' | 'global'\n  resourceId: 'iface-1',\n  resourceType: 'network.interface',\n  execute: async () => {\n    await updateInterface({ id: 'iface-1', mtu: newMtu });\n  },\n  undo: async () => {\n    await updateInterface({ id: 'iface-1', mtu: previousMtu });\n  },\n});\n"})}),"\n",(0,s.jsx)(n.h3,{id:"performing-undoredo",children:"Performing Undo/Redo"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"const { undo, redo } = useHistoryStore();\n\n// Returns true if successful\nconst didUndo = await undo();\nconst didRedo = await redo();\n"})}),"\n",(0,s.jsx)(n.h3,{id:"scope-rules",children:"Scope Rules"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"'page'"})," scope: cleared when navigating away (via ",(0,s.jsx)(n.code,{children:"clearPageScopedHistory()"}),"). Use for form edits."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"'global'"})," scope: persisted across navigation. Use for significant configuration changes."]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"keyboard-shortcuts",children:"Keyboard Shortcuts"}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"useHistoryShortcuts"})," hook registers ",(0,s.jsx)(n.code,{children:"Ctrl+Z"})," (undo) and ",(0,s.jsx)(n.code,{children:"Ctrl+Y"})," / ",(0,s.jsx)(n.code,{children:"Ctrl+Shift+Z"})," (redo) globally. It integrates with the ",(0,s.jsx)(n.code,{children:"shortcut-registry.store.ts"})," to avoid conflicts with textarea and input elements."]}),"\n",(0,s.jsx)(n.h3,{id:"history-limits",children:"History Limits"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Maximum 50 actions total (oldest are dropped when the limit is exceeded)."}),"\n",(0,s.jsxs)(n.li,{children:["Functions (",(0,s.jsx)(n.code,{children:"execute"})," and ",(0,s.jsx)(n.code,{children:"undo"})," callbacks) are ",(0,s.jsx)(n.strong,{children:"not"})," persisted to localStorage. Persisted actions (global scope only) display in the history panel as read-only entries but cannot be re-executed after a page reload."]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"convenience-functions",children:"Convenience Functions"}),"\n",(0,s.jsx)(n.p,{children:"For use outside React components:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"import { undoLast, redoLast, pushHistoryAction, clearAllHistory } from '@nasnet/state/stores';\n\nawait undoLast();\nawait redoLast();\npushHistoryAction({ type: 'edit', description: '...', scope: 'global', execute, undo });\nclearAllHistory();\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"cross-layer-integration-patterns",children:"Cross-Layer Integration Patterns"}),"\n",(0,s.jsx)(n.h3,{id:"apollo-mutation--zustand-update",children:"Apollo Mutation + Zustand Update"}),"\n",(0,s.jsx)(n.p,{children:"When a mutation changes data that is also tracked in a Zustand store, update both:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"const [applyChangeSet] = useMutation(APPLY_CHANGE_SET_MUTATION);\nconst { markApplying, markCompleted, markFailed } = useChangeSetStore();\n\nconst handleApply = async (changeSetId: string) => {\n  markApplying(changeSetId);  // Optimistic update\n  try {\n    await applyChangeSet({ variables: { id: changeSetId } });\n    markCompleted(changeSetId);\n  } catch (error) {\n    markFailed(changeSetId, error.message, /* failedItemId */ 'unknown');\n  }\n};\n"})}),"\n",(0,s.jsx)(n.h3,{id:"xstate--apollo-subscription-bridge",children:"XState + Apollo Subscription Bridge"}),"\n",(0,s.jsxs)(n.p,{children:["XState machines receive data from Apollo subscriptions via ",(0,s.jsx)(n.code,{children:"send()"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// libs/features/services/src/machines/update-machine.ts pattern\nconst [state, send] = useMachine(updateMachine);\nconst { data: progressData } = useSubscription(UPDATE_PROGRESS_SUBSCRIPTION, {\n  variables: { instanceId },\n});\n\nuseEffect(() => {\n  if (!progressData?.updateProgress) return;\n  const event = progressData.updateProgress;\n\n  send({ type: 'PROGRESS', stage: event.stage, progress: event.progress, message: event.message });\n\n  if (event.stage === 'COMPLETE') {\n    send({ type: 'COMPLETE', toVersion: event.newVersion });\n  } else if (event.rolledBack) {\n    send({ type: 'ROLLED_BACK', error: event.error });\n  } else if (event.stage === 'FAILED') {\n    send({ type: 'FAILED', error: event.error });\n  }\n}, [progressData, send]);\n"})}),"\n",(0,s.jsx)(n.h3,{id:"form-data--change-set",children:"Form Data \u2192 Change Set"}),"\n",(0,s.jsx)(n.p,{children:"The typical flow for a wizard that creates a change set:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"const form = useForm({ resolver: zodResolver(createLANSchema) });\nconst { createChangeSet, addItem } = useChangeSetStore();\n\nconst handleSubmit = form.handleSubmit((values) => {\n  // Create a change set from validated form data\n  const csId = createChangeSet({\n    name: `Create LAN: ${values.networkName}`,\n    routerId,\n    source: 'lan-wizard',\n  });\n\n  addItem(csId, {\n    name: 'Bridge Interface',\n    resourceType: 'network.bridge',\n    operation: 'CREATE',\n    configuration: { name: values.bridgeName },\n    dependencies: [],\n  });\n\n  // Navigate to change set review page\n  navigate(`/router/${routerId}/change-sets/${csId}`);\n});\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"cross-references",children:"Cross-References"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["For XState machine details: ",(0,s.jsx)(n.code,{children:"libs/features/docs/xstate-machines.md"})]}),"\n",(0,s.jsxs)(n.li,{children:["For GraphQL schema patterns: ",(0,s.jsx)(n.code,{children:"Docs/architecture/api-contracts.md"})]}),"\n",(0,s.jsxs)(n.li,{children:["For the 8-layer resource model (deployment vs. configuration layers): ",(0,s.jsx)(n.code,{children:"Docs/architecture/data-architecture.md"})]}),"\n",(0,s.jsxs)(n.li,{children:["For component patterns that consume these stores: ",(0,s.jsx)(n.code,{children:"Docs/design/PLATFORM_PRESENTER_GUIDE.md"})]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(l,{...e})}):l(e)}},71184:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>o});var r=t(14041);const s={},i=r.createContext(s);function a(e){const n=r.useContext(i);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),r.createElement(i.Provider,{value:n},e.children)}}}]);