"use strict";(globalThis.webpackChunk_nas_net_docs=globalThis.webpackChunk_nas_net_docs||[]).push([[96449],{9936:(n,e,i)=>{i.r(e),i.d(e,{assets:()=>l,contentTitle:()=>o,default:()=>u,frontMatter:()=>s,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"guides/validation-pipeline","title":"Validation Pipeline: 7-Stage Risk-Based Validation","description":"Reference: libs/core/forms/src/ | Universal State v2 Layer 2","source":"@site/../../libs/core/docs/guides/validation-pipeline.md","sourceDirName":"guides","slug":"/guides/validation-pipeline","permalink":"/docs/core/guides/validation-pipeline","draft":false,"unlisted":false,"editUrl":"https://github.com/nasnet-community/nasnet-panel/tree/main/../../libs/core/docs/guides/validation-pipeline.md","tags":[],"version":"current","frontMatter":{},"sidebar":"sidebar","previous":{"title":"Universal State v2: The 8-Layer Resource Model","permalink":"/docs/core/guides/universal-state-v2"},"next":{"title":"Constants Reference","permalink":"/docs/core/sub-libraries/constants"}}');var t=i(31085),a=i(71184);const s={},o="Validation Pipeline: 7-Stage Risk-Based Validation",l={},c=[{value:"Table of Contents",id:"table-of-contents",level:2},{value:"Pipeline Architecture",id:"pipeline-architecture",level:2},{value:"The 7 Stages",id:"the-7-stages",level:2},{value:"Stage 1: SCHEMA Validation",id:"stage-1-schema-validation",level:3},{value:"Stage 2: SYNTAX Check",id:"stage-2-syntax-check",level:3},{value:"Stage 3: CROSS-RESOURCE Validation",id:"stage-3-cross-resource-validation",level:3},{value:"Stage 4: DEPENDENCIES Validation",id:"stage-4-dependencies-validation",level:3},{value:"Stage 5: NETWORK Validation",id:"stage-5-network-validation",level:3},{value:"Stage 6: PLATFORM Validation",id:"stage-6-platform-validation",level:3},{value:"Stage 7: DRY-RUN Simulation",id:"stage-7-dry-run-simulation",level:3},{value:"Risk Levels",id:"risk-levels",level:2},{value:"Strategy Configuration",id:"strategy-configuration",level:3},{value:"Schema Validation",id:"schema-validation",level:2},{value:"Abort and Cancellation",id:"abort-and-cancellation",level:2},{value:"Error Propagation",id:"error-propagation",level:2},{value:"Custom Validators",id:"custom-validators",level:2},{value:"Form Provider Integration",id:"form-provider-integration",level:2},{value:"Practical Examples",id:"practical-examples",level:2},{value:"Example 1: Low-Risk Field Validation",id:"example-1-low-risk-field-validation",level:3},{value:"Example 2: Medium-Risk with Conflict Detection",id:"example-2-medium-risk-with-conflict-detection",level:3},{value:"Example 3: High-Risk with Dry-Run",id:"example-3-high-risk-with-dry-run",level:3},{value:"See Also",id:"see-also",level:2}];function d(n){const e={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",mermaid:"mermaid",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...n.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.header,{children:(0,t.jsx)(e.h1,{id:"validation-pipeline-7-stage-risk-based-validation",children:"Validation Pipeline: 7-Stage Risk-Based Validation"})}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Reference:"})," ",(0,t.jsx)(e.code,{children:"libs/core/forms/src/"})," | Universal State v2 Layer 2"]}),"\n",(0,t.jsx)(e.h2,{id:"table-of-contents",children:"Table of Contents"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#pipeline-architecture",children:"Pipeline Architecture"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#the-7-stages",children:"The 7 Stages"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#risk-levels",children:"Risk Levels"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#schema-validation",children:"Schema Validation"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#abort-and-cancellation",children:"Abort and Cancellation"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#error-propagation",children:"Error Propagation"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#custom-validators",children:"Custom Validators"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#form-provider-integration",children:"Form Provider Integration"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#practical-examples",children:"Practical Examples"})}),"\n"]}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"pipeline-architecture",children:"Pipeline Architecture"}),"\n",(0,t.jsx)(e.p,{children:"The validation pipeline is a sequential 7-stage process that ensures configuration validity before applying to the router."}),"\n",(0,t.jsx)(e.mermaid,{value:'flowchart TD\n    Start["Input Data"]\n\n    Stage1["<b>Stage 1: SCHEMA Validation</b><br/>(Client-Side)<br/>\u251c\u2500 Zod/GraphQL type checking<br/>\u251c\u2500 Data structure conformance<br/>\u2514\u2500 Must pass before proceeding"]\n\n    Stage2["<b>Stage 2: SYNTAX Check</b><br/>(Client-Side)<br/>\u251c\u2500 IP addresses, MAC addresses<br/>\u251c\u2500 Port numbers, CIDR notation<br/>\u251c\u2500 Format validation<br/>\u2514\u2500 Fast local validation"]\n\n    RiskCheck{"Risk Level?"}\n    LowRisk["<b>Low-Risk</b><br/>(WiFi password,<br/>display name)<br/><br/>\u2713 DONE<br/>(Stages 1-2)"]\n    MediumHigh["<b>Medium/High-Risk</b><br/>Continue to Backend"]\n\n    Stage3["<b>Stage 3: CROSS-RESOURCE</b><br/>(Backend)<br/>\u251c\u2500 Port conflicts<br/>\u251c\u2500 IP collisions<br/>\u251c\u2500 Route overlaps<br/>\u2514\u2500 Async validation"]\n\n    Stage4["<b>Stage 4: DEPENDENCIES</b><br/>(Backend)<br/>\u251c\u2500 Resources exist<br/>\u251c\u2500 Dependencies active<br/>\u251c\u2500 Circular deps<br/>\u2514\u2500 Graph analysis"]\n\n    RiskCheck2{"High-Risk?"}\n    MediumDone["<b>Medium-Risk</b><br/>\u2713 DONE<br/>(Stages 1-4)"]\n    HighRisk["<b>High-Risk</b><br/>Continue Advanced"]\n\n    Stage5["<b>Stage 5: NETWORK</b><br/>(Backend)<br/>\u251c\u2500 IP/VLAN availability<br/>\u251c\u2500 Network reachability<br/>\u251c\u2500 Routing feasibility<br/>\u2514\u2500 WAN link checks"]\n\n    Stage6["<b>Stage 6: PLATFORM</b><br/>(Backend)<br/>\u251c\u2500 Router capabilities<br/>\u251c\u2500 Feature availability<br/>\u251c\u2500 Version requirements<br/>\u2514\u2500 License/package check"]\n\n    Stage7["<b>Stage 7: DRY-RUN</b><br/>(Backend)<br/>\u251c\u2500 Simulate apply<br/>\u251c\u2500 Verify changes<br/>\u251c\u2500 Most expensive<br/>\u2514\u2500 High-risk only"]\n\n    Complete["\u2713 Validation Complete<br/>Resource Can Apply"]\n\n    Start --\x3e Stage1 --\x3e Stage2 --\x3e RiskCheck\n\n    RiskCheck --\x3e|Low-Risk| LowRisk\n    RiskCheck --\x3e|Medium/High-Risk| MediumHigh\n\n    LowRisk --\x3e Complete\n\n    MediumHigh --\x3e Stage3 --\x3e Stage4 --\x3e RiskCheck2\n\n    RiskCheck2 --\x3e|Medium-Risk| MediumDone\n    RiskCheck2 --\x3e|High-Risk| HighRisk\n\n    MediumDone --\x3e Complete\n\n    HighRisk --\x3e Stage5 --\x3e Stage6 --\x3e Stage7 --\x3e Complete\n\n    style Start fill:#f9f9f9\n    style Complete fill:#e8f5e9\n    style LowRisk fill:#fff9c4\n    style MediumDone fill:#fff9c4\n    style RiskCheck fill:#e3f2fd\n    style RiskCheck2 fill:#e3f2fd'}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"the-7-stages",children:"The 7 Stages"}),"\n",(0,t.jsx)(e.h3,{id:"stage-1-schema-validation",children:"Stage 1: SCHEMA Validation"}),"\n",(0,t.jsx)(e.p,{children:"Type checking with Zod or GraphQL schemas. Runs on client, required for all risk levels."}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-typescript",children:"import { z } from 'zod';\n\n// Define schema\nconst WireGuardServerSchema = z.object({\n  enabled: z.boolean(),\n  port: z.number().int().min(1).max(65535),\n  privateKey: z.string().min(1),\n  ipAddress: z.string().ip(),\n  mtu: z.number().int().min(1280).max(65535).optional(),\n});\n\n// Validate\nconst result = WireGuardServerSchema.safeParse({\n  enabled: true,\n  port: 51820,\n  privateKey: 'invalid-base64', // \u2717 FAILS\n  ipAddress: '10.0.0.1',\n  mtu: 1500,\n});\n\nif (!result.success) {\n  result.error.errors.forEach((err) => {\n    console.error(`${err.path.join('.')}: ${err.message}`);\n    // Output: \"privateKey: String must contain at least 1 character(s)\"\n  });\n}\n"})}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"When it runs:"})}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Always (required for all risk levels)"}),"\n",(0,t.jsx)(e.li,{children:"First in pipeline"}),"\n",(0,t.jsx)(e.li,{children:"Synchronously on client"}),"\n"]}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Failures block further validation:"})}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"If schema fails, remaining stages skipped"}),"\n",(0,t.jsx)(e.li,{children:"User must fix structure before applying"}),"\n",(0,t.jsx)(e.li,{children:"Fast fail prevents wasted backend calls"}),"\n"]}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h3,{id:"stage-2-syntax-check",children:"Stage 2: SYNTAX Check"}),"\n",(0,t.jsx)(e.p,{children:"Format validation for specific types (IP, MAC, CIDR, ports). Client-side, fast."}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-typescript",children:"import { isValidIPv4, isValidMAC, isValidCIDR } from '@nasnet/core/utils';\n\n// IP address validation\nif (!isValidIPv4('192.168.1.1')) {\n  console.error('Invalid IPv4 address');\n}\n\n// MAC address validation\nif (!isValidMAC('02:11:22:33:44:55')) {\n  console.error('Invalid MAC address');\n}\n\n// CIDR notation validation\nif (!isValidCIDR('10.0.0.0/24')) {\n  console.error('Invalid CIDR notation');\n}\n\n// Port range validation\nfunction validatePort(port: number): boolean {\n  return port >= 1 && port <= 65535;\n}\n"})}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Covered by:"})}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Zod refinements"}),"\n",(0,t.jsx)(e.li,{children:"Custom validators"}),"\n",(0,t.jsx)(e.li,{children:"Regex patterns"}),"\n",(0,t.jsx)(e.li,{children:"Domain-specific checks"}),"\n"]}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Example with Zod:"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-typescript",children:"const IPAddressSchema = z.string()\n  .ip()  // Built-in IP validation\n  .refine((ip) => {\n    const parts = ip.split('.');\n    return parts[0] !== '127'; // Reject loopback\n  }, 'Cannot use loopback address');\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h3,{id:"stage-3-cross-resource-validation",children:"Stage 3: CROSS-RESOURCE Validation"}),"\n",(0,t.jsx)(e.p,{children:"Detect conflicts with existing resources. Backend only, for medium/high risk."}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-typescript",children:"import type { ValidationIssue, ConflictType } from '@nasnet/core/types';\n\n// Backend checks\ninterface CrossResourceValidation {\n  // Port conflicts\n  conflicts: Array<{\n    type: 'PORT' | 'IP_ADDRESS' | 'ROUTE' | 'INTERFACE' | 'NAME';\n    conflictingResourceId: string;\n    field: string;\n    currentValue: unknown;\n    conflictingValue: unknown;\n    resolution: string;\n  }>;\n}\n\n// Example response\nconst conflicts: CrossResourceValidation['conflicts'] = [\n  {\n    type: 'PORT',\n    conflictingResourceId: 'openvpn-server',\n    field: 'port',\n    currentValue: 51820,\n    conflictingValue: 51820,\n    resolution: 'Use a different port or disable OpenVPN server',\n  },\n  {\n    type: 'IP_ADDRESS',\n    conflictingResourceId: 'lan-dhcp',\n    field: 'ipAddress',\n    currentValue: '10.0.0.1',\n    conflictingValue: '10.0.0.1',\n    resolution: 'Use IP in different range (10.0.0.2-254)',\n  },\n];\n"})}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Checked by backend:"})}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Run VALIDATE_CONFIGURATION GraphQL mutation"}),"\n",(0,t.jsx)(e.li,{children:"Pass current configuration for comparison"}),"\n",(0,t.jsx)(e.li,{children:"Returns conflicts with suggestions"}),"\n",(0,t.jsx)(e.li,{children:"Non-blocking if resolvable (warnings, not errors)"}),"\n"]}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h3,{id:"stage-4-dependencies-validation",children:"Stage 4: DEPENDENCIES Validation"}),"\n",(0,t.jsx)(e.p,{children:"Verify required resources exist and are active."}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-typescript",children:"import { buildDependencyGraph, detectCycles } from '@nasnet/core/utils';\n\n// Define dependencies\nconst changeSet = [\n  {\n    id: 'wg-server',\n    dependencies: ['lan-bridge'],  // Requires LAN bridge\n  },\n  {\n    id: 'lan-bridge',\n    dependencies: [],\n  },\n];\n\n// Check cycles\nconst cycleResult = detectCycles(changeSet);\nif (cycleResult.hasCycle) {\n  console.error('Circular dependency detected:', cycleResult.cycles);\n  // Result: [[\"a\", \"b\"]]  means a\u2192b\u2192a\n}\n\n// Validate graph\nconst { valid, errors, warnings } = validateDependencyGraph(changeSet);\nif (!valid) {\n  errors.forEach((err) => {\n    console.error(err);\n    // \"Node 'wg-server' depends on 'lan-bridge' which is not in the change set\"\n  });\n}\n"})}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Dependency status check:"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-typescript",children:"interface DependencyStatus {\n  resourceUuid: string;\n  resourceType: string;\n  isActive: boolean;              // Can be used right now?\n  state: ResourceLifecycleState;  // DRAFT, VALID, ACTIVE, etc.\n  reason: string;                 // Why it's required\n}\n\n// Example validation\nconst dependency: DependencyStatus = {\n  resourceUuid: 'lan-bridge-001',\n  resourceType: 'network.bridge',\n  isActive: true,           // \u2713 Can be used\n  state: 'ACTIVE',\n  reason: 'WireGuard needs LAN interface to tunnel through',\n};\n\nif (!dependency.isActive) {\n  console.error(\n    `Cannot use ${dependency.resourceType}: ${dependency.reason}`\n  );\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h3,{id:"stage-5-network-validation",children:"Stage 5: NETWORK Validation"}),"\n",(0,t.jsx)(e.p,{children:"Check IP/VLAN availability, network reachability. High-risk only."}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-typescript",children:"interface NetworkValidation {\n  ipAvailability: {\n    field: string;\n    requestedIP: string;\n    isAvailable: boolean;\n    availableRange?: string;\n    conflict?: {\n      resourceId: string;\n      resourceType: string;\n    };\n  }[];\n\n  vlanAvailability: {\n    requestedVlan: number;\n    isAvailable: boolean;\n    usedBy?: string;\n  };\n\n  routingFeasibility: {\n    routes: Array<{\n      destination: string;\n      gateway: string;\n      feasible: boolean;\n      reason?: string;\n    }>;\n  };\n\n  wanLinkStatus: {\n    interface: string;\n    isUp: boolean;\n    speedMbps?: number;\n  };\n}\n\n// Example\nconst networkCheck: NetworkValidation = {\n  ipAvailability: [\n    {\n      field: 'ipAddress',\n      requestedIP: '10.0.0.1',\n      isAvailable: false,\n      availableRange: '10.0.0.2-254',\n      conflict: {\n        resourceId: 'dhcp-server',\n        resourceType: 'dhcp.server',\n      },\n    },\n  ],\n  vlanAvailability: {\n    requestedVlan: 100,\n    isAvailable: true,\n  },\n  routingFeasibility: {\n    routes: [\n      {\n        destination: '0.0.0.0/0',\n        gateway: '192.168.1.1',\n        feasible: true,\n      },\n    ],\n  },\n  wanLinkStatus: {\n    interface: 'ether1',\n    isUp: true,\n    speedMbps: 1000,\n  },\n};\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h3,{id:"stage-6-platform-validation",children:"Stage 6: PLATFORM Validation"}),"\n",(0,t.jsx)(e.p,{children:"Check router capabilities, version requirements, feature availability."}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-typescript",children:"import type { PlatformCapabilities, CapabilityLevel } from '@nasnet/core/types';\n\n// Platform capability check\nconst capabilities: PlatformCapabilities = {\n  isSupported: true,\n  level: 'FULL' as CapabilityLevel,  // NONE | BASIC | ADVANCED | FULL\n  minVersion: '6.48.0',\n  requiredPackages: [\n    'routeros-system',\n    'routeros-routing',\n    'routeros-container',\n  ],\n  details: {\n    maxPeers: 1000,\n    maxConnections: 10000,\n  },\n};\n\n// Validation logic\nfunction validatePlatformSupport(\n  routerVersion: string,\n  installedPackages: string[],\n  capabilities: PlatformCapabilities\n): { valid: boolean; issues: string[] } {\n  const issues: string[] = [];\n\n  // Check version\n  if (!isVersionAtLeast(routerVersion, capabilities.minVersion)) {\n    issues.push(\n      `Router version ${routerVersion} ` +\n      `is below minimum required ${capabilities.minVersion}`\n    );\n  }\n\n  // Check packages\n  capabilities.requiredPackages?.forEach((pkg) => {\n    if (!installedPackages.includes(pkg)) {\n      issues.push(`Required package not installed: ${pkg}`);\n    }\n  });\n\n  return {\n    valid: issues.length === 0,\n    issues,\n  };\n}\n"})}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Limitations:"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-typescript",children:"interface PlatformLimitation {\n  code: string;\n  description: string;\n  affectedFields: string[];\n  workaround?: string;\n}\n\nconst limitation: PlatformLimitation = {\n  code: 'MTK_WG_PEERS_LIMIT',\n  description: 'MikroTik limits WireGuard to 1000 peers per server',\n  affectedFields: ['configuration.peers'],\n  workaround: 'Split load across multiple WireGuard servers',\n};\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h3,{id:"stage-7-dry-run-simulation",children:"Stage 7: DRY-RUN Simulation"}),"\n",(0,t.jsx)(e.p,{children:"Simulate applying changes on test instance. Most expensive, high-risk only."}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-typescript",children:"interface DryRunValidation {\n  success: boolean;\n  simulatedChanges: Array<{\n    operation: 'CREATE' | 'UPDATE' | 'DELETE';\n    resourceType: string;\n    resourceId: string;\n    description: string;\n  }>;\n  expectedOutcome: {\n    systemRestart?: boolean;\n    downtime?: string;  // ISO 8601 duration\n    affectedServices: string[];\n  };\n  warnings: Array<{\n    severity: 'WARNING' | 'CRITICAL';\n    message: string;\n  }>;\n  estimatedApplyTime: number;  // milliseconds\n}\n\n// Example\nconst dryRun: DryRunValidation = {\n  success: true,\n  simulatedChanges: [\n    {\n      operation: 'CREATE',\n      resourceType: 'network.bridge',\n      resourceId: 'br-lan',\n      description: 'Create bridge for LAN',\n    },\n    {\n      operation: 'CREATE',\n      resourceType: 'dhcp.server',\n      resourceId: 'dhcp-lan',\n      description: 'Create DHCP server on bridge',\n    },\n  ],\n  expectedOutcome: {\n    systemRestart: false,\n    downtime: 'PT0S',  // No downtime\n    affectedServices: ['DHCP', 'ARP'],\n  },\n  warnings: [\n    {\n      severity: 'WARNING',\n      message: 'DHCP scope may conflict with existing scope',\n    },\n  ],\n  estimatedApplyTime: 2500,  // 2.5 seconds\n};\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"risk-levels",children:"Risk Levels"}),"\n",(0,t.jsx)(e.p,{children:"Risk levels determine which stages run."}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-typescript",children:"import type { ValidationStrategy } from '@nasnet/core/forms';\n\ntype ValidationStrategy = 'low' | 'medium' | 'high';\n\n// LOW-RISK: Client-side only (Stages 1-2)\n// Examples: WiFi password, display name, comment fields\n// User impact: Minimal, easily undone\n// Confirmation: Not required\n\n// MEDIUM-RISK: Client + basic backend (Stages 1-4)\n// Examples: Firewall rules, DHCP settings, VPN peer config\n// User impact: Moderate, affects network\n// Confirmation: Not required (but review recommended)\n\n// HIGH-RISK: Full pipeline (Stages 1-7)\n// Examples: WAN changes, routing tables, VPN deletion, factory reset\n// User impact: Major, potential downtime\n// Confirmation: Required (preview + countdown)\n"})}),"\n",(0,t.jsx)(e.h3,{id:"strategy-configuration",children:"Strategy Configuration"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-typescript",children:"import { VALIDATION_CONFIGS } from '@nasnet/core/forms';\n\n// Low-risk (2 stages)\nconst low = VALIDATION_CONFIGS.low;\n// {\n//   stages: ['schema', 'syntax'],\n//   clientOnly: true,\n//   requiresConfirmation: false,\n// }\n\n// Medium-risk (4 stages)\nconst medium = VALIDATION_CONFIGS.medium;\n// {\n//   stages: ['schema', 'syntax', 'cross-resource', 'dependencies'],\n//   clientOnly: false,\n//   requiresConfirmation: false,\n// }\n\n// High-risk (7 stages)\nconst high = VALIDATION_CONFIGS.high;\n// {\n//   stages: [\n//     'schema', 'syntax', 'cross-resource', 'dependencies',\n//     'network', 'platform', 'dry-run'\n//   ],\n//   clientOnly: false,\n//   requiresConfirmation: true,\n//   confirmationSteps: ['preview', 'countdown'],\n// }\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"schema-validation",children:"Schema Validation"}),"\n",(0,t.jsx)(e.p,{children:"Local Zod validation vs backend validation stages."}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-typescript",children:"import { z } from 'zod';\n\n// Zod schema (Stage 1)\nconst FirewallRuleSchema = z.object({\n  chain: z.enum(['input', 'forward', 'output']),\n  protocol: z.enum(['tcp', 'udp', 'icmp', 'all']),\n  srcAddress: z.string().ip().optional(),\n  dstAddress: z.string().ip().optional(),\n  srcPort: z.number().int().min(1).max(65535).optional(),\n  dstPort: z.number().int().min(1).max(65535).optional(),\n  action: z.enum(['accept', 'drop', 'reject', 'mark']),\n  comment: z.string().optional(),\n});\n\n// Zod refinement (Stage 2 - Syntax)\nconst RefinedSchema = FirewallRuleSchema\n  .refine(\n    (rule) => {\n      // If both ports specified, they must be in order\n      if (rule.srcPort && rule.dstPort) {\n        return rule.srcPort <= rule.dstPort;\n      }\n      return true;\n    },\n    {\n      message: 'Source port must be <= destination port',\n      path: ['dstPort'],\n    }\n  )\n  .refine(\n    (rule) => {\n      // Mark action requires comment\n      if (rule.action === 'mark' && !rule.comment) {\n        return false;\n      }\n      return true;\n    },\n    {\n      message: 'Mark action requires a comment for the mark name',\n      path: ['comment'],\n    }\n  );\n\n// Validate\nconst result = RefinedSchema.safeParse({\n  chain: 'input',\n  protocol: 'tcp',\n  dstPort: 443,\n  action: 'accept',\n});\n\nif (!result.success) {\n  console.error(result.error.flatten());\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"abort-and-cancellation",children:"Abort and Cancellation"}),"\n",(0,t.jsx)(e.p,{children:"Cancel long-running validations."}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-typescript",children:"import { useValidationPipeline } from '@nasnet/core/forms';\n\nfunction FormComponent() {\n  const pipeline = useValidationPipeline({\n    schema: MySchema,\n    strategy: 'high',\n    resourceUuid: 'resource-001',\n  });\n\n  async function handleValidate() {\n    // Start validation\n    const result = await pipeline.validate(formData);\n\n    if (!result.isValid) {\n      console.error('Validation failed:', result.errors);\n    }\n  }\n\n  function handleCancel() {\n    // Abort in-flight validations\n    pipeline.reset();\n  }\n\n  return (\n    <>\n      <button onClick={handleValidate} disabled={pipeline.isValidating}>\n        {pipeline.isValidating ? 'Validating...' : 'Validate'}\n      </button>\n\n      {pipeline.isValidating && (\n        <>\n          <progress\n            value={pipeline.currentStage}\n            max={pipeline.stages.length}\n          />\n          <button onClick={handleCancel}>Cancel</button>\n        </>\n      )}\n\n      {/* Display stage progress */}\n      <ul>\n        {pipeline.stages.map((stage) => (\n          <li key={stage.stage}>\n            {stage.stage}: {stage.status}\n            {stage.durationMs && ` (${stage.durationMs}ms)`}\n          </li>\n        ))}\n      </ul>\n    </>\n  );\n}\n"})}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"AbortController:"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-typescript",children:"import { useRef } from 'react';\n\nfunction useValidationWithCancel() {\n  const abortRef = useRef<AbortController | null>(null);\n\n  async function validate(data: unknown) {\n    // Create new abort controller\n    abortRef.current = new AbortController();\n\n    try {\n      const response = await fetch('/api/validate', {\n        method: 'POST',\n        body: JSON.stringify(data),\n        signal: abortRef.current.signal,  // Pass signal\n      });\n\n      return await response.json();\n    } catch (error) {\n      if (error instanceof DOMException && error.name === 'AbortError') {\n        console.log('Validation cancelled');\n      }\n      throw error;\n    }\n  }\n\n  function cancel() {\n    abortRef.current?.abort();\n  }\n\n  return { validate, cancel };\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"error-propagation",children:"Error Propagation"}),"\n",(0,t.jsx)(e.p,{children:"Map validation pipeline errors to form field errors."}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-typescript",children:"import type { ValidationError } from '@nasnet/core/types';\nimport { FieldValues, UseFormReturn } from 'react-hook-form';\n\nfunction mapValidationErrorsToForm<T extends FieldValues>(\n  errors: ValidationError[],\n  form: UseFormReturn<T>\n) {\n  // Group errors by field\n  const fieldErrors = new Map<string, string[]>();\n\n  errors.forEach((error) => {\n    if (error.fieldPath) {\n      const messages = fieldErrors.get(error.fieldPath) || [];\n      messages.push(error.message);\n      fieldErrors.set(error.fieldPath, messages);\n    }\n  });\n\n  // Set form errors\n  fieldErrors.forEach((messages, fieldPath) => {\n    const path = fieldPath.split('.') as any;\n    form.setError(path, {\n      type: 'custom',\n      message: messages[0],  // Show first error\n    });\n  });\n}\n\n// Usage\nconst pipeline = useValidationPipeline({\n  schema: MySchema,\n  strategy: 'medium',\n});\n\nconst form = useForm<MyFormData>();\n\nasync function handleValidate(data: MyFormData) {\n  const result = await pipeline.validate(data);\n\n  if (!result.isValid) {\n    mapValidationErrorsToForm(result.errors, form);\n  }\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"custom-validators",children:"Custom Validators"}),"\n",(0,t.jsx)(e.p,{children:"Build and register custom validation stages."}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-typescript",children:"import type { ValidationStage, ValidationPipelineResult } from '@nasnet/core/forms';\n\ninterface CustomValidator {\n  stage: ValidationStage;\n  validate: (data: unknown) => Promise<ValidationError[]>;\n  description: string;\n}\n\n// Example: Custom network connectivity validator\nconst networkConnectivityValidator: CustomValidator = {\n  stage: 'network',\n  description: 'Check if gateway IP is reachable',\n  validate: async (data: { gateway: string }) => {\n    try {\n      const response = await fetch(`/api/ping/${data.gateway}`);\n      const result = await response.json();\n\n      if (!result.reachable) {\n        return [\n          {\n            code: 'GATEWAY_UNREACHABLE',\n            message: `Gateway ${data.gateway} is not reachable`,\n            severity: 'ERROR',\n          },\n        ];\n      }\n\n      return [];\n    } catch (error) {\n      return [\n        {\n          code: 'CONNECTIVITY_CHECK_FAILED',\n          message: `Failed to check connectivity: ${(error as Error).message}`,\n          severity: 'WARNING',\n        },\n      ];\n    }\n  },\n};\n\n// Register in form context\nfunction FormWithCustomValidation() {\n  const form = useForm<MyFormData>();\n\n  const pipeline = useValidationPipeline({\n    schema: MySchema,\n    strategy: 'medium',\n    resourceUuid: 'resource-001',\n    customValidators: [networkConnectivityValidator],\n  });\n\n  return <></>;\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"form-provider-integration",children:"Form Provider Integration"}),"\n",(0,t.jsx)(e.p,{children:"Integration with NasFormProvider context."}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-typescript",children:"import {\n  NasFormProvider,\n  useFormContext,\n  useValidationPipeline,\n} from '@nasnet/core/forms';\n\n// Provider setup (typically in app root)\nfunction App() {\n  return (\n    <NasFormProvider>\n      <YourRoutes />\n    </NasFormProvider>\n  );\n}\n\n// Use in component\nfunction MyFormComponent() {\n  const form = useForm<MyFormData>();\n  const { register, handleSubmit, formState } = form;\n\n  // Access validation pipeline from context\n  const { validationStrategy, validationConfig } = useFormContext();\n\n  const pipeline = useValidationPipeline({\n    schema: MySchema,\n    strategy: validationStrategy,\n    resourceUuid: 'resource-001',\n  });\n\n  async function onSubmit(data: MyFormData) {\n    // Validate through pipeline\n    const result = await pipeline.validate(data);\n\n    if (!result.isValid) {\n      // Show errors\n      result.errors.forEach((err) => {\n        console.error(`${err.code}: ${err.message}`);\n      });\n      return;\n    }\n\n    // Apply changes\n    await applyChanges(data);\n  }\n\n  return (\n    <form onSubmit={handleSubmit(onSubmit)}>\n      <input {...register('port')} />\n      {formState.errors.port && (\n        <span>{formState.errors.port.message}</span>\n      )}\n\n      {pipeline.isValidating && <progress />}\n\n      <button type=\"submit\">Save</button>\n    </form>\n  );\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"practical-examples",children:"Practical Examples"}),"\n",(0,t.jsx)(e.h3,{id:"example-1-low-risk-field-validation",children:"Example 1: Low-Risk Field Validation"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-typescript",children:"function WiFiPasswordForm() {\n  const form = useForm({\n    resolver: zodResolver(\n      z.object({\n        ssid: z.string().min(1),\n        password: z.string().min(8),  // Stage 1: Schema\n      })\n    ),\n  });\n\n  // Low-risk: only client-side validation\n  const pipeline = useValidationPipeline({\n    schema: form.formState.schema,\n    strategy: 'low',  // Only stages 1-2\n  });\n\n  async function onSubmit(data: any) {\n    const result = await pipeline.validate(data);\n    if (result.isValid) {\n      // Apply immediately, no backend call\n      await updateWiFi(data);\n    }\n  }\n\n  return (\n    <form onSubmit={form.handleSubmit(onSubmit)}>\n      {/* form fields */}\n    </form>\n  );\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"example-2-medium-risk-with-conflict-detection",children:"Example 2: Medium-Risk with Conflict Detection"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-typescript",children:"function FirewallRuleForm() {\n  const form = useForm({\n    resolver: zodResolver(FirewallRuleSchema),\n  });\n\n  const pipeline = useValidationPipeline({\n    schema: FirewallRuleSchema,\n    strategy: 'medium',  // Stages 1-4\n    resourceUuid: 'rule-001',\n  });\n\n  async function onSubmit(data: any) {\n    const result = await pipeline.validate(data);\n\n    if (!result.isValid) {\n      // Show validation errors\n      result.errors.forEach((err) => {\n        console.error(`${err.code}: ${err.message}`);\n        if (err.fieldPath) {\n          form.setError(err.fieldPath as any, { message: err.message });\n        }\n      });\n      return;\n    }\n\n    // Check for conflicts\n    const conflicts = result.conflicts || [];\n    if (conflicts.length > 0) {\n      // Show conflict resolution dialog\n      conflicts.forEach((conflict) => {\n        console.warn(`${conflict.type} conflict: ${conflict.description}`);\n        showConflictDialog(conflict);\n      });\n      return;\n    }\n\n    // Safe to apply\n    await updateFirewallRule(data);\n  }\n\n  return (\n    <form onSubmit={form.handleSubmit(onSubmit)}>\n      <div>\n        {pipeline.stages.map((stage) => (\n          <StageProgress key={stage.stage} stage={stage} />\n        ))}\n      </div>\n      {/* form fields */}\n    </form>\n  );\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"example-3-high-risk-with-dry-run",children:"Example 3: High-Risk with Dry-Run"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-typescript",children:"function WANConfigForm() {\n  const form = useForm({\n    resolver: zodResolver(WANConfigSchema),\n  });\n\n  const [dryRunResult, setDryRunResult] = useState(null);\n\n  const pipeline = useValidationPipeline({\n    schema: WANConfigSchema,\n    strategy: 'high',  // All stages including dry-run\n    resourceUuid: 'wan-001',\n  });\n\n  async function onSubmit(data: any) {\n    const result = await pipeline.validate(data);\n\n    if (!result.isValid) {\n      showErrors(result.errors);\n      return;\n    }\n\n    // For high-risk, show dry-run results\n    if (result.dryRun) {\n      setDryRunResult(result.dryRun);\n      showPreviewDialog(result.dryRun);\n\n      // Require countdown confirmation\n      const confirmed = await showCountdownConfirmation(10);\n      if (!confirmed) {\n        return;\n      }\n    }\n\n    // Apply with final confirmation\n    const applied = await applyWANConfig(data);\n    if (applied) {\n      showSuccessMessage('WAN configuration updated');\n    }\n  }\n\n  return (\n    <form onSubmit={form.handleSubmit(onSubmit)}>\n      <div className=\"validation-stages\">\n        {pipeline.stages.map((stage) => (\n          <StageIndicator\n            key={stage.stage}\n            stage={stage}\n            duration={stage.durationMs}\n          />\n        ))}\n      </div>\n\n      {dryRunResult && (\n        <PreviewPanel result={dryRunResult}>\n          <ul>\n            {dryRunResult.simulatedChanges.map((change) => (\n              <li key={change.resourceId}>\n                {change.operation} {change.resourceType}\n              </li>\n            ))}\n          </ul>\n          {dryRunResult.estimatedApplyTime && (\n            <p>\n              Estimated apply time:{' '}\n              {(dryRunResult.estimatedApplyTime / 1000).toFixed(1)}s\n            </p>\n          )}\n        </PreviewPanel>\n      )}\n\n      <button type=\"submit\" disabled={pipeline.isValidating}>\n        {pipeline.isValidating ? 'Validating...' : 'Apply'}\n      </button>\n    </form>\n  );\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"see-also",children:"See Also"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"universal-state-v2.md"})," - 8-layer model (validation is Layer 2)"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"change-set-operations.md"})," - Atomic operations with validation"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"forms.md"})," - React Hook Form patterns"]}),"\n"]})]})}function u(n={}){const{wrapper:e}={...(0,a.R)(),...n.components};return e?(0,t.jsx)(e,{...n,children:(0,t.jsx)(d,{...n})}):d(n)}},71184:(n,e,i)=>{i.d(e,{R:()=>s,x:()=>o});var r=i(14041);const t={},a=r.createContext(t);function s(n){const e=r.useContext(a);return r.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function o(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(t):n.components||t:s(n.components),r.createElement(a.Provider,{value:e},n.children)}}}]);