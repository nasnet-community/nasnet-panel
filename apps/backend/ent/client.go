// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"log"
	"reflect"

	"backend/ent/migrate"

	"backend/ent/apikey"
	"backend/ent/configsnapshot"
	"backend/ent/globalsettings"
	"backend/ent/resource"
	"backend/ent/resourceevent"
	"backend/ent/router"
	"backend/ent/routercapability"
	"backend/ent/routersecret"
	"backend/ent/schemaversion"
	"backend/ent/session"
	"backend/ent/user"

	"entgo.io/ent"
	"entgo.io/ent/dialect"
	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"

	"backend/ent/internal"
	stdsql "database/sql"
)

// Client is the client that holds all ent builders.
type Client struct {
	config
	// Schema is the client for creating, migrating and dropping schema.
	Schema *migrate.Schema
	// APIKey is the client for interacting with the APIKey builders.
	APIKey *APIKeyClient
	// ConfigSnapshot is the client for interacting with the ConfigSnapshot builders.
	ConfigSnapshot *ConfigSnapshotClient
	// GlobalSettings is the client for interacting with the GlobalSettings builders.
	GlobalSettings *GlobalSettingsClient
	// Resource is the client for interacting with the Resource builders.
	Resource *ResourceClient
	// ResourceEvent is the client for interacting with the ResourceEvent builders.
	ResourceEvent *ResourceEventClient
	// Router is the client for interacting with the Router builders.
	Router *RouterClient
	// RouterCapability is the client for interacting with the RouterCapability builders.
	RouterCapability *RouterCapabilityClient
	// RouterSecret is the client for interacting with the RouterSecret builders.
	RouterSecret *RouterSecretClient
	// SchemaVersion is the client for interacting with the SchemaVersion builders.
	SchemaVersion *SchemaVersionClient
	// Session is the client for interacting with the Session builders.
	Session *SessionClient
	// User is the client for interacting with the User builders.
	User *UserClient
}

// NewClient creates a new client configured with the given options.
func NewClient(opts ...Option) *Client {
	client := &Client{config: newConfig(opts...)}
	client.init()
	return client
}

func (c *Client) init() {
	c.Schema = migrate.NewSchema(c.driver)
	c.APIKey = NewAPIKeyClient(c.config)
	c.ConfigSnapshot = NewConfigSnapshotClient(c.config)
	c.GlobalSettings = NewGlobalSettingsClient(c.config)
	c.Resource = NewResourceClient(c.config)
	c.ResourceEvent = NewResourceEventClient(c.config)
	c.Router = NewRouterClient(c.config)
	c.RouterCapability = NewRouterCapabilityClient(c.config)
	c.RouterSecret = NewRouterSecretClient(c.config)
	c.SchemaVersion = NewSchemaVersionClient(c.config)
	c.Session = NewSessionClient(c.config)
	c.User = NewUserClient(c.config)
}

type (
	// config is the configuration for the client and its builder.
	config struct {
		// driver used for executing database requests.
		driver dialect.Driver
		// debug enable a debug logging.
		debug bool
		// log used for logging on debug mode.
		log func(...any)
		// hooks to execute on mutations.
		hooks *hooks
		// interceptors to execute on queries.
		inters *inters
		// schemaConfig contains alternative names for all tables.
		schemaConfig SchemaConfig
	}
	// Option function to configure the client.
	Option func(*config)
)

// newConfig creates a new config for the client.
func newConfig(opts ...Option) config {
	cfg := config{log: log.Println, hooks: &hooks{}, inters: &inters{}}
	cfg.options(opts...)
	return cfg
}

// options applies the options on the config object.
func (c *config) options(opts ...Option) {
	for _, opt := range opts {
		opt(c)
	}
	if c.debug {
		c.driver = dialect.Debug(c.driver, c.log)
	}
}

// Debug enables debug logging on the ent.Driver.
func Debug() Option {
	return func(c *config) {
		c.debug = true
	}
}

// Log sets the logging function for debug mode.
func Log(fn func(...any)) Option {
	return func(c *config) {
		c.log = fn
	}
}

// Driver configures the client driver.
func Driver(driver dialect.Driver) Option {
	return func(c *config) {
		c.driver = driver
	}
}

// Open opens a database/sql.DB specified by the driver name and
// the data source name, and returns a new client attached to it.
// Optional parameters can be added for configuring the client.
func Open(driverName, dataSourceName string, options ...Option) (*Client, error) {
	switch driverName {
	case dialect.MySQL, dialect.Postgres, dialect.SQLite:
		drv, err := sql.Open(driverName, dataSourceName)
		if err != nil {
			return nil, err
		}
		return NewClient(append(options, Driver(drv))...), nil
	default:
		return nil, fmt.Errorf("unsupported driver: %q", driverName)
	}
}

// ErrTxStarted is returned when trying to start a new transaction from a transactional client.
var ErrTxStarted = errors.New("ent: cannot start a transaction within a transaction")

// Tx returns a new transactional client. The provided context
// is used until the transaction is committed or rolled back.
func (c *Client) Tx(ctx context.Context) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, ErrTxStarted
	}
	tx, err := newTx(ctx, c.driver)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = tx
	return &Tx{
		ctx:              ctx,
		config:           cfg,
		APIKey:           NewAPIKeyClient(cfg),
		ConfigSnapshot:   NewConfigSnapshotClient(cfg),
		GlobalSettings:   NewGlobalSettingsClient(cfg),
		Resource:         NewResourceClient(cfg),
		ResourceEvent:    NewResourceEventClient(cfg),
		Router:           NewRouterClient(cfg),
		RouterCapability: NewRouterCapabilityClient(cfg),
		RouterSecret:     NewRouterSecretClient(cfg),
		SchemaVersion:    NewSchemaVersionClient(cfg),
		Session:          NewSessionClient(cfg),
		User:             NewUserClient(cfg),
	}, nil
}

// BeginTx returns a transactional client with specified options.
func (c *Client) BeginTx(ctx context.Context, opts *sql.TxOptions) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, errors.New("ent: cannot start a transaction within a transaction")
	}
	tx, err := c.driver.(interface {
		BeginTx(context.Context, *sql.TxOptions) (dialect.Tx, error)
	}).BeginTx(ctx, opts)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = &txDriver{tx: tx, drv: c.driver}
	return &Tx{
		ctx:              ctx,
		config:           cfg,
		APIKey:           NewAPIKeyClient(cfg),
		ConfigSnapshot:   NewConfigSnapshotClient(cfg),
		GlobalSettings:   NewGlobalSettingsClient(cfg),
		Resource:         NewResourceClient(cfg),
		ResourceEvent:    NewResourceEventClient(cfg),
		Router:           NewRouterClient(cfg),
		RouterCapability: NewRouterCapabilityClient(cfg),
		RouterSecret:     NewRouterSecretClient(cfg),
		SchemaVersion:    NewSchemaVersionClient(cfg),
		Session:          NewSessionClient(cfg),
		User:             NewUserClient(cfg),
	}, nil
}

// Debug returns a new debug-client. It's used to get verbose logging on specific operations.
//
//	client.Debug().
//		APIKey.
//		Query().
//		Count(ctx)
func (c *Client) Debug() *Client {
	if c.debug {
		return c
	}
	cfg := c.config
	cfg.driver = dialect.Debug(c.driver, c.log)
	client := &Client{config: cfg}
	client.init()
	return client
}

// Close closes the database connection and prevents new queries from starting.
func (c *Client) Close() error {
	return c.driver.Close()
}

// Use adds the mutation hooks to all the entity clients.
// In order to add hooks to a specific client, call: `client.Node.Use(...)`.
func (c *Client) Use(hooks ...Hook) {
	for _, n := range []interface{ Use(...Hook) }{
		c.APIKey, c.ConfigSnapshot, c.GlobalSettings, c.Resource, c.ResourceEvent,
		c.Router, c.RouterCapability, c.RouterSecret, c.SchemaVersion, c.Session,
		c.User,
	} {
		n.Use(hooks...)
	}
}

// Intercept adds the query interceptors to all the entity clients.
// In order to add interceptors to a specific client, call: `client.Node.Intercept(...)`.
func (c *Client) Intercept(interceptors ...Interceptor) {
	for _, n := range []interface{ Intercept(...Interceptor) }{
		c.APIKey, c.ConfigSnapshot, c.GlobalSettings, c.Resource, c.ResourceEvent,
		c.Router, c.RouterCapability, c.RouterSecret, c.SchemaVersion, c.Session,
		c.User,
	} {
		n.Intercept(interceptors...)
	}
}

// Mutate implements the ent.Mutator interface.
func (c *Client) Mutate(ctx context.Context, m Mutation) (Value, error) {
	switch m := m.(type) {
	case *APIKeyMutation:
		return c.APIKey.mutate(ctx, m)
	case *ConfigSnapshotMutation:
		return c.ConfigSnapshot.mutate(ctx, m)
	case *GlobalSettingsMutation:
		return c.GlobalSettings.mutate(ctx, m)
	case *ResourceMutation:
		return c.Resource.mutate(ctx, m)
	case *ResourceEventMutation:
		return c.ResourceEvent.mutate(ctx, m)
	case *RouterMutation:
		return c.Router.mutate(ctx, m)
	case *RouterCapabilityMutation:
		return c.RouterCapability.mutate(ctx, m)
	case *RouterSecretMutation:
		return c.RouterSecret.mutate(ctx, m)
	case *SchemaVersionMutation:
		return c.SchemaVersion.mutate(ctx, m)
	case *SessionMutation:
		return c.Session.mutate(ctx, m)
	case *UserMutation:
		return c.User.mutate(ctx, m)
	default:
		return nil, fmt.Errorf("ent: unknown mutation type %T", m)
	}
}

// APIKeyClient is a client for the APIKey schema.
type APIKeyClient struct {
	config
}

// NewAPIKeyClient returns a client for the APIKey from the given config.
func NewAPIKeyClient(c config) *APIKeyClient {
	return &APIKeyClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `apikey.Hooks(f(g(h())))`.
func (c *APIKeyClient) Use(hooks ...Hook) {
	c.hooks.APIKey = append(c.hooks.APIKey, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `apikey.Intercept(f(g(h())))`.
func (c *APIKeyClient) Intercept(interceptors ...Interceptor) {
	c.inters.APIKey = append(c.inters.APIKey, interceptors...)
}

// Create returns a builder for creating a APIKey entity.
func (c *APIKeyClient) Create() *APIKeyCreate {
	mutation := newAPIKeyMutation(c.config, OpCreate)
	return &APIKeyCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of APIKey entities.
func (c *APIKeyClient) CreateBulk(builders ...*APIKeyCreate) *APIKeyCreateBulk {
	return &APIKeyCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *APIKeyClient) MapCreateBulk(slice any, setFunc func(*APIKeyCreate, int)) *APIKeyCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &APIKeyCreateBulk{err: fmt.Errorf("calling to APIKeyClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*APIKeyCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &APIKeyCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for APIKey.
func (c *APIKeyClient) Update() *APIKeyUpdate {
	mutation := newAPIKeyMutation(c.config, OpUpdate)
	return &APIKeyUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *APIKeyClient) UpdateOne(_m *APIKey) *APIKeyUpdateOne {
	mutation := newAPIKeyMutation(c.config, OpUpdateOne, withAPIKey(_m))
	return &APIKeyUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *APIKeyClient) UpdateOneID(id string) *APIKeyUpdateOne {
	mutation := newAPIKeyMutation(c.config, OpUpdateOne, withAPIKeyID(id))
	return &APIKeyUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for APIKey.
func (c *APIKeyClient) Delete() *APIKeyDelete {
	mutation := newAPIKeyMutation(c.config, OpDelete)
	return &APIKeyDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *APIKeyClient) DeleteOne(_m *APIKey) *APIKeyDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *APIKeyClient) DeleteOneID(id string) *APIKeyDeleteOne {
	builder := c.Delete().Where(apikey.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &APIKeyDeleteOne{builder}
}

// Query returns a query builder for APIKey.
func (c *APIKeyClient) Query() *APIKeyQuery {
	return &APIKeyQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeAPIKey},
		inters: c.Interceptors(),
	}
}

// Get returns a APIKey entity by its id.
func (c *APIKeyClient) Get(ctx context.Context, id string) (*APIKey, error) {
	return c.Query().Where(apikey.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *APIKeyClient) GetX(ctx context.Context, id string) *APIKey {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a APIKey.
func (c *APIKeyClient) QueryUser(_m *APIKey) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(apikey.Table, apikey.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, apikey.UserTable, apikey.UserColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.User
		step.Edge.Schema = schemaConfig.APIKey
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *APIKeyClient) Hooks() []Hook {
	return c.hooks.APIKey
}

// Interceptors returns the client interceptors.
func (c *APIKeyClient) Interceptors() []Interceptor {
	return c.inters.APIKey
}

func (c *APIKeyClient) mutate(ctx context.Context, m *APIKeyMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&APIKeyCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&APIKeyUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&APIKeyUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&APIKeyDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown APIKey mutation op: %q", m.Op())
	}
}

// ConfigSnapshotClient is a client for the ConfigSnapshot schema.
type ConfigSnapshotClient struct {
	config
}

// NewConfigSnapshotClient returns a client for the ConfigSnapshot from the given config.
func NewConfigSnapshotClient(c config) *ConfigSnapshotClient {
	return &ConfigSnapshotClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `configsnapshot.Hooks(f(g(h())))`.
func (c *ConfigSnapshotClient) Use(hooks ...Hook) {
	c.hooks.ConfigSnapshot = append(c.hooks.ConfigSnapshot, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `configsnapshot.Intercept(f(g(h())))`.
func (c *ConfigSnapshotClient) Intercept(interceptors ...Interceptor) {
	c.inters.ConfigSnapshot = append(c.inters.ConfigSnapshot, interceptors...)
}

// Create returns a builder for creating a ConfigSnapshot entity.
func (c *ConfigSnapshotClient) Create() *ConfigSnapshotCreate {
	mutation := newConfigSnapshotMutation(c.config, OpCreate)
	return &ConfigSnapshotCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ConfigSnapshot entities.
func (c *ConfigSnapshotClient) CreateBulk(builders ...*ConfigSnapshotCreate) *ConfigSnapshotCreateBulk {
	return &ConfigSnapshotCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ConfigSnapshotClient) MapCreateBulk(slice any, setFunc func(*ConfigSnapshotCreate, int)) *ConfigSnapshotCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ConfigSnapshotCreateBulk{err: fmt.Errorf("calling to ConfigSnapshotClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ConfigSnapshotCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ConfigSnapshotCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ConfigSnapshot.
func (c *ConfigSnapshotClient) Update() *ConfigSnapshotUpdate {
	mutation := newConfigSnapshotMutation(c.config, OpUpdate)
	return &ConfigSnapshotUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ConfigSnapshotClient) UpdateOne(_m *ConfigSnapshot) *ConfigSnapshotUpdateOne {
	mutation := newConfigSnapshotMutation(c.config, OpUpdateOne, withConfigSnapshot(_m))
	return &ConfigSnapshotUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ConfigSnapshotClient) UpdateOneID(id string) *ConfigSnapshotUpdateOne {
	mutation := newConfigSnapshotMutation(c.config, OpUpdateOne, withConfigSnapshotID(id))
	return &ConfigSnapshotUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ConfigSnapshot.
func (c *ConfigSnapshotClient) Delete() *ConfigSnapshotDelete {
	mutation := newConfigSnapshotMutation(c.config, OpDelete)
	return &ConfigSnapshotDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ConfigSnapshotClient) DeleteOne(_m *ConfigSnapshot) *ConfigSnapshotDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ConfigSnapshotClient) DeleteOneID(id string) *ConfigSnapshotDeleteOne {
	builder := c.Delete().Where(configsnapshot.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ConfigSnapshotDeleteOne{builder}
}

// Query returns a query builder for ConfigSnapshot.
func (c *ConfigSnapshotClient) Query() *ConfigSnapshotQuery {
	return &ConfigSnapshotQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeConfigSnapshot},
		inters: c.Interceptors(),
	}
}

// Get returns a ConfigSnapshot entity by its id.
func (c *ConfigSnapshotClient) Get(ctx context.Context, id string) (*ConfigSnapshot, error) {
	return c.Query().Where(configsnapshot.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ConfigSnapshotClient) GetX(ctx context.Context, id string) *ConfigSnapshot {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *ConfigSnapshotClient) Hooks() []Hook {
	return c.hooks.ConfigSnapshot
}

// Interceptors returns the client interceptors.
func (c *ConfigSnapshotClient) Interceptors() []Interceptor {
	return c.inters.ConfigSnapshot
}

func (c *ConfigSnapshotClient) mutate(ctx context.Context, m *ConfigSnapshotMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ConfigSnapshotCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ConfigSnapshotUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ConfigSnapshotUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ConfigSnapshotDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown ConfigSnapshot mutation op: %q", m.Op())
	}
}

// GlobalSettingsClient is a client for the GlobalSettings schema.
type GlobalSettingsClient struct {
	config
}

// NewGlobalSettingsClient returns a client for the GlobalSettings from the given config.
func NewGlobalSettingsClient(c config) *GlobalSettingsClient {
	return &GlobalSettingsClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `globalsettings.Hooks(f(g(h())))`.
func (c *GlobalSettingsClient) Use(hooks ...Hook) {
	c.hooks.GlobalSettings = append(c.hooks.GlobalSettings, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `globalsettings.Intercept(f(g(h())))`.
func (c *GlobalSettingsClient) Intercept(interceptors ...Interceptor) {
	c.inters.GlobalSettings = append(c.inters.GlobalSettings, interceptors...)
}

// Create returns a builder for creating a GlobalSettings entity.
func (c *GlobalSettingsClient) Create() *GlobalSettingsCreate {
	mutation := newGlobalSettingsMutation(c.config, OpCreate)
	return &GlobalSettingsCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of GlobalSettings entities.
func (c *GlobalSettingsClient) CreateBulk(builders ...*GlobalSettingsCreate) *GlobalSettingsCreateBulk {
	return &GlobalSettingsCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *GlobalSettingsClient) MapCreateBulk(slice any, setFunc func(*GlobalSettingsCreate, int)) *GlobalSettingsCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &GlobalSettingsCreateBulk{err: fmt.Errorf("calling to GlobalSettingsClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*GlobalSettingsCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &GlobalSettingsCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for GlobalSettings.
func (c *GlobalSettingsClient) Update() *GlobalSettingsUpdate {
	mutation := newGlobalSettingsMutation(c.config, OpUpdate)
	return &GlobalSettingsUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *GlobalSettingsClient) UpdateOne(_m *GlobalSettings) *GlobalSettingsUpdateOne {
	mutation := newGlobalSettingsMutation(c.config, OpUpdateOne, withGlobalSettings(_m))
	return &GlobalSettingsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *GlobalSettingsClient) UpdateOneID(id string) *GlobalSettingsUpdateOne {
	mutation := newGlobalSettingsMutation(c.config, OpUpdateOne, withGlobalSettingsID(id))
	return &GlobalSettingsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for GlobalSettings.
func (c *GlobalSettingsClient) Delete() *GlobalSettingsDelete {
	mutation := newGlobalSettingsMutation(c.config, OpDelete)
	return &GlobalSettingsDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *GlobalSettingsClient) DeleteOne(_m *GlobalSettings) *GlobalSettingsDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *GlobalSettingsClient) DeleteOneID(id string) *GlobalSettingsDeleteOne {
	builder := c.Delete().Where(globalsettings.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &GlobalSettingsDeleteOne{builder}
}

// Query returns a query builder for GlobalSettings.
func (c *GlobalSettingsClient) Query() *GlobalSettingsQuery {
	return &GlobalSettingsQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeGlobalSettings},
		inters: c.Interceptors(),
	}
}

// Get returns a GlobalSettings entity by its id.
func (c *GlobalSettingsClient) Get(ctx context.Context, id string) (*GlobalSettings, error) {
	return c.Query().Where(globalsettings.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *GlobalSettingsClient) GetX(ctx context.Context, id string) *GlobalSettings {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *GlobalSettingsClient) Hooks() []Hook {
	return c.hooks.GlobalSettings
}

// Interceptors returns the client interceptors.
func (c *GlobalSettingsClient) Interceptors() []Interceptor {
	return c.inters.GlobalSettings
}

func (c *GlobalSettingsClient) mutate(ctx context.Context, m *GlobalSettingsMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&GlobalSettingsCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&GlobalSettingsUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&GlobalSettingsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&GlobalSettingsDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown GlobalSettings mutation op: %q", m.Op())
	}
}

// ResourceClient is a client for the Resource schema.
type ResourceClient struct {
	config
}

// NewResourceClient returns a client for the Resource from the given config.
func NewResourceClient(c config) *ResourceClient {
	return &ResourceClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `resource.Hooks(f(g(h())))`.
func (c *ResourceClient) Use(hooks ...Hook) {
	c.hooks.Resource = append(c.hooks.Resource, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `resource.Intercept(f(g(h())))`.
func (c *ResourceClient) Intercept(interceptors ...Interceptor) {
	c.inters.Resource = append(c.inters.Resource, interceptors...)
}

// Create returns a builder for creating a Resource entity.
func (c *ResourceClient) Create() *ResourceCreate {
	mutation := newResourceMutation(c.config, OpCreate)
	return &ResourceCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Resource entities.
func (c *ResourceClient) CreateBulk(builders ...*ResourceCreate) *ResourceCreateBulk {
	return &ResourceCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ResourceClient) MapCreateBulk(slice any, setFunc func(*ResourceCreate, int)) *ResourceCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ResourceCreateBulk{err: fmt.Errorf("calling to ResourceClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ResourceCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ResourceCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Resource.
func (c *ResourceClient) Update() *ResourceUpdate {
	mutation := newResourceMutation(c.config, OpUpdate)
	return &ResourceUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ResourceClient) UpdateOne(_m *Resource) *ResourceUpdateOne {
	mutation := newResourceMutation(c.config, OpUpdateOne, withResource(_m))
	return &ResourceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ResourceClient) UpdateOneID(id string) *ResourceUpdateOne {
	mutation := newResourceMutation(c.config, OpUpdateOne, withResourceID(id))
	return &ResourceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Resource.
func (c *ResourceClient) Delete() *ResourceDelete {
	mutation := newResourceMutation(c.config, OpDelete)
	return &ResourceDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ResourceClient) DeleteOne(_m *Resource) *ResourceDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ResourceClient) DeleteOneID(id string) *ResourceDeleteOne {
	builder := c.Delete().Where(resource.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ResourceDeleteOne{builder}
}

// Query returns a query builder for Resource.
func (c *ResourceClient) Query() *ResourceQuery {
	return &ResourceQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeResource},
		inters: c.Interceptors(),
	}
}

// Get returns a Resource entity by its id.
func (c *ResourceClient) Get(ctx context.Context, id string) (*Resource, error) {
	return c.Query().Where(resource.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ResourceClient) GetX(ctx context.Context, id string) *Resource {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryEvents queries the events edge of a Resource.
func (c *ResourceClient) QueryEvents(_m *Resource) *ResourceEventQuery {
	query := (&ResourceEventClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(resource.Table, resource.FieldID, id),
			sqlgraph.To(resourceevent.Table, resourceevent.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, resource.EventsTable, resource.EventsColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.ResourceEvent
		step.Edge.Schema = schemaConfig.ResourceEvent
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ResourceClient) Hooks() []Hook {
	return c.hooks.Resource
}

// Interceptors returns the client interceptors.
func (c *ResourceClient) Interceptors() []Interceptor {
	return c.inters.Resource
}

func (c *ResourceClient) mutate(ctx context.Context, m *ResourceMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ResourceCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ResourceUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ResourceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ResourceDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Resource mutation op: %q", m.Op())
	}
}

// ResourceEventClient is a client for the ResourceEvent schema.
type ResourceEventClient struct {
	config
}

// NewResourceEventClient returns a client for the ResourceEvent from the given config.
func NewResourceEventClient(c config) *ResourceEventClient {
	return &ResourceEventClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `resourceevent.Hooks(f(g(h())))`.
func (c *ResourceEventClient) Use(hooks ...Hook) {
	c.hooks.ResourceEvent = append(c.hooks.ResourceEvent, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `resourceevent.Intercept(f(g(h())))`.
func (c *ResourceEventClient) Intercept(interceptors ...Interceptor) {
	c.inters.ResourceEvent = append(c.inters.ResourceEvent, interceptors...)
}

// Create returns a builder for creating a ResourceEvent entity.
func (c *ResourceEventClient) Create() *ResourceEventCreate {
	mutation := newResourceEventMutation(c.config, OpCreate)
	return &ResourceEventCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ResourceEvent entities.
func (c *ResourceEventClient) CreateBulk(builders ...*ResourceEventCreate) *ResourceEventCreateBulk {
	return &ResourceEventCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ResourceEventClient) MapCreateBulk(slice any, setFunc func(*ResourceEventCreate, int)) *ResourceEventCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ResourceEventCreateBulk{err: fmt.Errorf("calling to ResourceEventClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ResourceEventCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ResourceEventCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ResourceEvent.
func (c *ResourceEventClient) Update() *ResourceEventUpdate {
	mutation := newResourceEventMutation(c.config, OpUpdate)
	return &ResourceEventUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ResourceEventClient) UpdateOne(_m *ResourceEvent) *ResourceEventUpdateOne {
	mutation := newResourceEventMutation(c.config, OpUpdateOne, withResourceEvent(_m))
	return &ResourceEventUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ResourceEventClient) UpdateOneID(id string) *ResourceEventUpdateOne {
	mutation := newResourceEventMutation(c.config, OpUpdateOne, withResourceEventID(id))
	return &ResourceEventUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ResourceEvent.
func (c *ResourceEventClient) Delete() *ResourceEventDelete {
	mutation := newResourceEventMutation(c.config, OpDelete)
	return &ResourceEventDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ResourceEventClient) DeleteOne(_m *ResourceEvent) *ResourceEventDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ResourceEventClient) DeleteOneID(id string) *ResourceEventDeleteOne {
	builder := c.Delete().Where(resourceevent.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ResourceEventDeleteOne{builder}
}

// Query returns a query builder for ResourceEvent.
func (c *ResourceEventClient) Query() *ResourceEventQuery {
	return &ResourceEventQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeResourceEvent},
		inters: c.Interceptors(),
	}
}

// Get returns a ResourceEvent entity by its id.
func (c *ResourceEventClient) Get(ctx context.Context, id string) (*ResourceEvent, error) {
	return c.Query().Where(resourceevent.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ResourceEventClient) GetX(ctx context.Context, id string) *ResourceEvent {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryResource queries the resource edge of a ResourceEvent.
func (c *ResourceEventClient) QueryResource(_m *ResourceEvent) *ResourceQuery {
	query := (&ResourceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(resourceevent.Table, resourceevent.FieldID, id),
			sqlgraph.To(resource.Table, resource.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, resourceevent.ResourceTable, resourceevent.ResourceColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Resource
		step.Edge.Schema = schemaConfig.ResourceEvent
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ResourceEventClient) Hooks() []Hook {
	return c.hooks.ResourceEvent
}

// Interceptors returns the client interceptors.
func (c *ResourceEventClient) Interceptors() []Interceptor {
	return c.inters.ResourceEvent
}

func (c *ResourceEventClient) mutate(ctx context.Context, m *ResourceEventMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ResourceEventCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ResourceEventUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ResourceEventUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ResourceEventDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown ResourceEvent mutation op: %q", m.Op())
	}
}

// RouterClient is a client for the Router schema.
type RouterClient struct {
	config
}

// NewRouterClient returns a client for the Router from the given config.
func NewRouterClient(c config) *RouterClient {
	return &RouterClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `router.Hooks(f(g(h())))`.
func (c *RouterClient) Use(hooks ...Hook) {
	c.hooks.Router = append(c.hooks.Router, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `router.Intercept(f(g(h())))`.
func (c *RouterClient) Intercept(interceptors ...Interceptor) {
	c.inters.Router = append(c.inters.Router, interceptors...)
}

// Create returns a builder for creating a Router entity.
func (c *RouterClient) Create() *RouterCreate {
	mutation := newRouterMutation(c.config, OpCreate)
	return &RouterCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Router entities.
func (c *RouterClient) CreateBulk(builders ...*RouterCreate) *RouterCreateBulk {
	return &RouterCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *RouterClient) MapCreateBulk(slice any, setFunc func(*RouterCreate, int)) *RouterCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &RouterCreateBulk{err: fmt.Errorf("calling to RouterClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*RouterCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &RouterCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Router.
func (c *RouterClient) Update() *RouterUpdate {
	mutation := newRouterMutation(c.config, OpUpdate)
	return &RouterUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *RouterClient) UpdateOne(_m *Router) *RouterUpdateOne {
	mutation := newRouterMutation(c.config, OpUpdateOne, withRouter(_m))
	return &RouterUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *RouterClient) UpdateOneID(id string) *RouterUpdateOne {
	mutation := newRouterMutation(c.config, OpUpdateOne, withRouterID(id))
	return &RouterUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Router.
func (c *RouterClient) Delete() *RouterDelete {
	mutation := newRouterMutation(c.config, OpDelete)
	return &RouterDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *RouterClient) DeleteOne(_m *Router) *RouterDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *RouterClient) DeleteOneID(id string) *RouterDeleteOne {
	builder := c.Delete().Where(router.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &RouterDeleteOne{builder}
}

// Query returns a query builder for Router.
func (c *RouterClient) Query() *RouterQuery {
	return &RouterQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeRouter},
		inters: c.Interceptors(),
	}
}

// Get returns a Router entity by its id.
func (c *RouterClient) Get(ctx context.Context, id string) (*Router, error) {
	return c.Query().Where(router.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *RouterClient) GetX(ctx context.Context, id string) *Router {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QuerySecrets queries the secrets edge of a Router.
func (c *RouterClient) QuerySecrets(_m *Router) *RouterSecretQuery {
	query := (&RouterSecretClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(router.Table, router.FieldID, id),
			sqlgraph.To(routersecret.Table, routersecret.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, router.SecretsTable, router.SecretsColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.RouterSecret
		step.Edge.Schema = schemaConfig.RouterSecret
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *RouterClient) Hooks() []Hook {
	return c.hooks.Router
}

// Interceptors returns the client interceptors.
func (c *RouterClient) Interceptors() []Interceptor {
	return c.inters.Router
}

func (c *RouterClient) mutate(ctx context.Context, m *RouterMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&RouterCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&RouterUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&RouterUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&RouterDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Router mutation op: %q", m.Op())
	}
}

// RouterCapabilityClient is a client for the RouterCapability schema.
type RouterCapabilityClient struct {
	config
}

// NewRouterCapabilityClient returns a client for the RouterCapability from the given config.
func NewRouterCapabilityClient(c config) *RouterCapabilityClient {
	return &RouterCapabilityClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `routercapability.Hooks(f(g(h())))`.
func (c *RouterCapabilityClient) Use(hooks ...Hook) {
	c.hooks.RouterCapability = append(c.hooks.RouterCapability, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `routercapability.Intercept(f(g(h())))`.
func (c *RouterCapabilityClient) Intercept(interceptors ...Interceptor) {
	c.inters.RouterCapability = append(c.inters.RouterCapability, interceptors...)
}

// Create returns a builder for creating a RouterCapability entity.
func (c *RouterCapabilityClient) Create() *RouterCapabilityCreate {
	mutation := newRouterCapabilityMutation(c.config, OpCreate)
	return &RouterCapabilityCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of RouterCapability entities.
func (c *RouterCapabilityClient) CreateBulk(builders ...*RouterCapabilityCreate) *RouterCapabilityCreateBulk {
	return &RouterCapabilityCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *RouterCapabilityClient) MapCreateBulk(slice any, setFunc func(*RouterCapabilityCreate, int)) *RouterCapabilityCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &RouterCapabilityCreateBulk{err: fmt.Errorf("calling to RouterCapabilityClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*RouterCapabilityCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &RouterCapabilityCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for RouterCapability.
func (c *RouterCapabilityClient) Update() *RouterCapabilityUpdate {
	mutation := newRouterCapabilityMutation(c.config, OpUpdate)
	return &RouterCapabilityUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *RouterCapabilityClient) UpdateOne(_m *RouterCapability) *RouterCapabilityUpdateOne {
	mutation := newRouterCapabilityMutation(c.config, OpUpdateOne, withRouterCapability(_m))
	return &RouterCapabilityUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *RouterCapabilityClient) UpdateOneID(id string) *RouterCapabilityUpdateOne {
	mutation := newRouterCapabilityMutation(c.config, OpUpdateOne, withRouterCapabilityID(id))
	return &RouterCapabilityUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for RouterCapability.
func (c *RouterCapabilityClient) Delete() *RouterCapabilityDelete {
	mutation := newRouterCapabilityMutation(c.config, OpDelete)
	return &RouterCapabilityDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *RouterCapabilityClient) DeleteOne(_m *RouterCapability) *RouterCapabilityDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *RouterCapabilityClient) DeleteOneID(id string) *RouterCapabilityDeleteOne {
	builder := c.Delete().Where(routercapability.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &RouterCapabilityDeleteOne{builder}
}

// Query returns a query builder for RouterCapability.
func (c *RouterCapabilityClient) Query() *RouterCapabilityQuery {
	return &RouterCapabilityQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeRouterCapability},
		inters: c.Interceptors(),
	}
}

// Get returns a RouterCapability entity by its id.
func (c *RouterCapabilityClient) Get(ctx context.Context, id string) (*RouterCapability, error) {
	return c.Query().Where(routercapability.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *RouterCapabilityClient) GetX(ctx context.Context, id string) *RouterCapability {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *RouterCapabilityClient) Hooks() []Hook {
	return c.hooks.RouterCapability
}

// Interceptors returns the client interceptors.
func (c *RouterCapabilityClient) Interceptors() []Interceptor {
	return c.inters.RouterCapability
}

func (c *RouterCapabilityClient) mutate(ctx context.Context, m *RouterCapabilityMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&RouterCapabilityCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&RouterCapabilityUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&RouterCapabilityUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&RouterCapabilityDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown RouterCapability mutation op: %q", m.Op())
	}
}

// RouterSecretClient is a client for the RouterSecret schema.
type RouterSecretClient struct {
	config
}

// NewRouterSecretClient returns a client for the RouterSecret from the given config.
func NewRouterSecretClient(c config) *RouterSecretClient {
	return &RouterSecretClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `routersecret.Hooks(f(g(h())))`.
func (c *RouterSecretClient) Use(hooks ...Hook) {
	c.hooks.RouterSecret = append(c.hooks.RouterSecret, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `routersecret.Intercept(f(g(h())))`.
func (c *RouterSecretClient) Intercept(interceptors ...Interceptor) {
	c.inters.RouterSecret = append(c.inters.RouterSecret, interceptors...)
}

// Create returns a builder for creating a RouterSecret entity.
func (c *RouterSecretClient) Create() *RouterSecretCreate {
	mutation := newRouterSecretMutation(c.config, OpCreate)
	return &RouterSecretCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of RouterSecret entities.
func (c *RouterSecretClient) CreateBulk(builders ...*RouterSecretCreate) *RouterSecretCreateBulk {
	return &RouterSecretCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *RouterSecretClient) MapCreateBulk(slice any, setFunc func(*RouterSecretCreate, int)) *RouterSecretCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &RouterSecretCreateBulk{err: fmt.Errorf("calling to RouterSecretClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*RouterSecretCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &RouterSecretCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for RouterSecret.
func (c *RouterSecretClient) Update() *RouterSecretUpdate {
	mutation := newRouterSecretMutation(c.config, OpUpdate)
	return &RouterSecretUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *RouterSecretClient) UpdateOne(_m *RouterSecret) *RouterSecretUpdateOne {
	mutation := newRouterSecretMutation(c.config, OpUpdateOne, withRouterSecret(_m))
	return &RouterSecretUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *RouterSecretClient) UpdateOneID(id string) *RouterSecretUpdateOne {
	mutation := newRouterSecretMutation(c.config, OpUpdateOne, withRouterSecretID(id))
	return &RouterSecretUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for RouterSecret.
func (c *RouterSecretClient) Delete() *RouterSecretDelete {
	mutation := newRouterSecretMutation(c.config, OpDelete)
	return &RouterSecretDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *RouterSecretClient) DeleteOne(_m *RouterSecret) *RouterSecretDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *RouterSecretClient) DeleteOneID(id string) *RouterSecretDeleteOne {
	builder := c.Delete().Where(routersecret.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &RouterSecretDeleteOne{builder}
}

// Query returns a query builder for RouterSecret.
func (c *RouterSecretClient) Query() *RouterSecretQuery {
	return &RouterSecretQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeRouterSecret},
		inters: c.Interceptors(),
	}
}

// Get returns a RouterSecret entity by its id.
func (c *RouterSecretClient) Get(ctx context.Context, id string) (*RouterSecret, error) {
	return c.Query().Where(routersecret.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *RouterSecretClient) GetX(ctx context.Context, id string) *RouterSecret {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryRouter queries the router edge of a RouterSecret.
func (c *RouterSecretClient) QueryRouter(_m *RouterSecret) *RouterQuery {
	query := (&RouterClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(routersecret.Table, routersecret.FieldID, id),
			sqlgraph.To(router.Table, router.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, routersecret.RouterTable, routersecret.RouterColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Router
		step.Edge.Schema = schemaConfig.RouterSecret
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *RouterSecretClient) Hooks() []Hook {
	return c.hooks.RouterSecret
}

// Interceptors returns the client interceptors.
func (c *RouterSecretClient) Interceptors() []Interceptor {
	return c.inters.RouterSecret
}

func (c *RouterSecretClient) mutate(ctx context.Context, m *RouterSecretMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&RouterSecretCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&RouterSecretUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&RouterSecretUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&RouterSecretDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown RouterSecret mutation op: %q", m.Op())
	}
}

// SchemaVersionClient is a client for the SchemaVersion schema.
type SchemaVersionClient struct {
	config
}

// NewSchemaVersionClient returns a client for the SchemaVersion from the given config.
func NewSchemaVersionClient(c config) *SchemaVersionClient {
	return &SchemaVersionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `schemaversion.Hooks(f(g(h())))`.
func (c *SchemaVersionClient) Use(hooks ...Hook) {
	c.hooks.SchemaVersion = append(c.hooks.SchemaVersion, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `schemaversion.Intercept(f(g(h())))`.
func (c *SchemaVersionClient) Intercept(interceptors ...Interceptor) {
	c.inters.SchemaVersion = append(c.inters.SchemaVersion, interceptors...)
}

// Create returns a builder for creating a SchemaVersion entity.
func (c *SchemaVersionClient) Create() *SchemaVersionCreate {
	mutation := newSchemaVersionMutation(c.config, OpCreate)
	return &SchemaVersionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of SchemaVersion entities.
func (c *SchemaVersionClient) CreateBulk(builders ...*SchemaVersionCreate) *SchemaVersionCreateBulk {
	return &SchemaVersionCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *SchemaVersionClient) MapCreateBulk(slice any, setFunc func(*SchemaVersionCreate, int)) *SchemaVersionCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &SchemaVersionCreateBulk{err: fmt.Errorf("calling to SchemaVersionClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*SchemaVersionCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &SchemaVersionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for SchemaVersion.
func (c *SchemaVersionClient) Update() *SchemaVersionUpdate {
	mutation := newSchemaVersionMutation(c.config, OpUpdate)
	return &SchemaVersionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *SchemaVersionClient) UpdateOne(_m *SchemaVersion) *SchemaVersionUpdateOne {
	mutation := newSchemaVersionMutation(c.config, OpUpdateOne, withSchemaVersion(_m))
	return &SchemaVersionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *SchemaVersionClient) UpdateOneID(id string) *SchemaVersionUpdateOne {
	mutation := newSchemaVersionMutation(c.config, OpUpdateOne, withSchemaVersionID(id))
	return &SchemaVersionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for SchemaVersion.
func (c *SchemaVersionClient) Delete() *SchemaVersionDelete {
	mutation := newSchemaVersionMutation(c.config, OpDelete)
	return &SchemaVersionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *SchemaVersionClient) DeleteOne(_m *SchemaVersion) *SchemaVersionDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *SchemaVersionClient) DeleteOneID(id string) *SchemaVersionDeleteOne {
	builder := c.Delete().Where(schemaversion.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &SchemaVersionDeleteOne{builder}
}

// Query returns a query builder for SchemaVersion.
func (c *SchemaVersionClient) Query() *SchemaVersionQuery {
	return &SchemaVersionQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeSchemaVersion},
		inters: c.Interceptors(),
	}
}

// Get returns a SchemaVersion entity by its id.
func (c *SchemaVersionClient) Get(ctx context.Context, id string) (*SchemaVersion, error) {
	return c.Query().Where(schemaversion.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *SchemaVersionClient) GetX(ctx context.Context, id string) *SchemaVersion {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *SchemaVersionClient) Hooks() []Hook {
	return c.hooks.SchemaVersion
}

// Interceptors returns the client interceptors.
func (c *SchemaVersionClient) Interceptors() []Interceptor {
	return c.inters.SchemaVersion
}

func (c *SchemaVersionClient) mutate(ctx context.Context, m *SchemaVersionMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&SchemaVersionCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&SchemaVersionUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&SchemaVersionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&SchemaVersionDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown SchemaVersion mutation op: %q", m.Op())
	}
}

// SessionClient is a client for the Session schema.
type SessionClient struct {
	config
}

// NewSessionClient returns a client for the Session from the given config.
func NewSessionClient(c config) *SessionClient {
	return &SessionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `session.Hooks(f(g(h())))`.
func (c *SessionClient) Use(hooks ...Hook) {
	c.hooks.Session = append(c.hooks.Session, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `session.Intercept(f(g(h())))`.
func (c *SessionClient) Intercept(interceptors ...Interceptor) {
	c.inters.Session = append(c.inters.Session, interceptors...)
}

// Create returns a builder for creating a Session entity.
func (c *SessionClient) Create() *SessionCreate {
	mutation := newSessionMutation(c.config, OpCreate)
	return &SessionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Session entities.
func (c *SessionClient) CreateBulk(builders ...*SessionCreate) *SessionCreateBulk {
	return &SessionCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *SessionClient) MapCreateBulk(slice any, setFunc func(*SessionCreate, int)) *SessionCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &SessionCreateBulk{err: fmt.Errorf("calling to SessionClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*SessionCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &SessionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Session.
func (c *SessionClient) Update() *SessionUpdate {
	mutation := newSessionMutation(c.config, OpUpdate)
	return &SessionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *SessionClient) UpdateOne(_m *Session) *SessionUpdateOne {
	mutation := newSessionMutation(c.config, OpUpdateOne, withSession(_m))
	return &SessionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *SessionClient) UpdateOneID(id string) *SessionUpdateOne {
	mutation := newSessionMutation(c.config, OpUpdateOne, withSessionID(id))
	return &SessionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Session.
func (c *SessionClient) Delete() *SessionDelete {
	mutation := newSessionMutation(c.config, OpDelete)
	return &SessionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *SessionClient) DeleteOne(_m *Session) *SessionDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *SessionClient) DeleteOneID(id string) *SessionDeleteOne {
	builder := c.Delete().Where(session.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &SessionDeleteOne{builder}
}

// Query returns a query builder for Session.
func (c *SessionClient) Query() *SessionQuery {
	return &SessionQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeSession},
		inters: c.Interceptors(),
	}
}

// Get returns a Session entity by its id.
func (c *SessionClient) Get(ctx context.Context, id string) (*Session, error) {
	return c.Query().Where(session.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *SessionClient) GetX(ctx context.Context, id string) *Session {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a Session.
func (c *SessionClient) QueryUser(_m *Session) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(session.Table, session.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, session.UserTable, session.UserColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.User
		step.Edge.Schema = schemaConfig.Session
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *SessionClient) Hooks() []Hook {
	return c.hooks.Session
}

// Interceptors returns the client interceptors.
func (c *SessionClient) Interceptors() []Interceptor {
	return c.inters.Session
}

func (c *SessionClient) mutate(ctx context.Context, m *SessionMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&SessionCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&SessionUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&SessionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&SessionDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Session mutation op: %q", m.Op())
	}
}

// UserClient is a client for the User schema.
type UserClient struct {
	config
}

// NewUserClient returns a client for the User from the given config.
func NewUserClient(c config) *UserClient {
	return &UserClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `user.Hooks(f(g(h())))`.
func (c *UserClient) Use(hooks ...Hook) {
	c.hooks.User = append(c.hooks.User, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `user.Intercept(f(g(h())))`.
func (c *UserClient) Intercept(interceptors ...Interceptor) {
	c.inters.User = append(c.inters.User, interceptors...)
}

// Create returns a builder for creating a User entity.
func (c *UserClient) Create() *UserCreate {
	mutation := newUserMutation(c.config, OpCreate)
	return &UserCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of User entities.
func (c *UserClient) CreateBulk(builders ...*UserCreate) *UserCreateBulk {
	return &UserCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *UserClient) MapCreateBulk(slice any, setFunc func(*UserCreate, int)) *UserCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &UserCreateBulk{err: fmt.Errorf("calling to UserClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*UserCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &UserCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for User.
func (c *UserClient) Update() *UserUpdate {
	mutation := newUserMutation(c.config, OpUpdate)
	return &UserUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UserClient) UpdateOne(_m *User) *UserUpdateOne {
	mutation := newUserMutation(c.config, OpUpdateOne, withUser(_m))
	return &UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *UserClient) UpdateOneID(id string) *UserUpdateOne {
	mutation := newUserMutation(c.config, OpUpdateOne, withUserID(id))
	return &UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for User.
func (c *UserClient) Delete() *UserDelete {
	mutation := newUserMutation(c.config, OpDelete)
	return &UserDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *UserClient) DeleteOne(_m *User) *UserDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *UserClient) DeleteOneID(id string) *UserDeleteOne {
	builder := c.Delete().Where(user.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &UserDeleteOne{builder}
}

// Query returns a query builder for User.
func (c *UserClient) Query() *UserQuery {
	return &UserQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeUser},
		inters: c.Interceptors(),
	}
}

// Get returns a User entity by its id.
func (c *UserClient) Get(ctx context.Context, id string) (*User, error) {
	return c.Query().Where(user.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *UserClient) GetX(ctx context.Context, id string) *User {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QuerySessions queries the sessions edge of a User.
func (c *UserClient) QuerySessions(_m *User) *SessionQuery {
	query := (&SessionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(session.Table, session.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.SessionsTable, user.SessionsColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Session
		step.Edge.Schema = schemaConfig.Session
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAPIKeys queries the api_keys edge of a User.
func (c *UserClient) QueryAPIKeys(_m *User) *APIKeyQuery {
	query := (&APIKeyClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(apikey.Table, apikey.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.APIKeysTable, user.APIKeysColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.APIKey
		step.Edge.Schema = schemaConfig.APIKey
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *UserClient) Hooks() []Hook {
	return c.hooks.User
}

// Interceptors returns the client interceptors.
func (c *UserClient) Interceptors() []Interceptor {
	return c.inters.User
}

func (c *UserClient) mutate(ctx context.Context, m *UserMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&UserCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&UserUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&UserDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown User mutation op: %q", m.Op())
	}
}

// hooks and interceptors per client, for fast access.
type (
	hooks struct {
		APIKey, ConfigSnapshot, GlobalSettings, Resource, ResourceEvent, Router,
		RouterCapability, RouterSecret, SchemaVersion, Session, User []ent.Hook
	}
	inters struct {
		APIKey, ConfigSnapshot, GlobalSettings, Resource, ResourceEvent, Router,
		RouterCapability, RouterSecret, SchemaVersion, Session, User []ent.Interceptor
	}
)

// SchemaConfig represents alternative schema names for all tables
// that can be passed at runtime.
type SchemaConfig = internal.SchemaConfig

// AlternateSchemas allows alternate schema names to be
// passed into ent operations.
func AlternateSchema(schemaConfig SchemaConfig) Option {
	return func(c *config) {
		c.schemaConfig = schemaConfig
	}
}

// ExecContext allows calling the underlying ExecContext method of the driver if it is supported by it.
// See, database/sql#DB.ExecContext for more information.
func (c *config) ExecContext(ctx context.Context, query string, args ...any) (stdsql.Result, error) {
	ex, ok := c.driver.(interface {
		ExecContext(context.Context, string, ...any) (stdsql.Result, error)
	})
	if !ok {
		return nil, fmt.Errorf("Driver.ExecContext is not supported")
	}
	return ex.ExecContext(ctx, query, args...)
}

// QueryContext allows calling the underlying QueryContext method of the driver if it is supported by it.
// See, database/sql#DB.QueryContext for more information.
func (c *config) QueryContext(ctx context.Context, query string, args ...any) (*stdsql.Rows, error) {
	q, ok := c.driver.(interface {
		QueryContext(context.Context, string, ...any) (*stdsql.Rows, error)
	})
	if !ok {
		return nil, fmt.Errorf("Driver.QueryContext is not supported")
	}
	return q.QueryContext(ctx, query, args...)
}
