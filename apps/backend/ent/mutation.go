// Code generated by ent, DO NOT EDIT.

package ent

import (
	"backend/ent/alert"
	"backend/ent/alertrule"
	"backend/ent/apikey"
	"backend/ent/configsnapshot"
	"backend/ent/globalsettings"
	"backend/ent/notificationsettings"
	"backend/ent/predicate"
	"backend/ent/resource"
	"backend/ent/resourceevent"
	"backend/ent/router"
	"backend/ent/routercapability"
	"backend/ent/routersecret"
	"backend/ent/schemaversion"
	"backend/ent/session"
	"backend/ent/user"
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAPIKey               = "APIKey"
	TypeAlert                = "Alert"
	TypeAlertRule            = "AlertRule"
	TypeConfigSnapshot       = "ConfigSnapshot"
	TypeGlobalSettings       = "GlobalSettings"
	TypeNotificationSettings = "NotificationSettings"
	TypeResource             = "Resource"
	TypeResourceEvent        = "ResourceEvent"
	TypeRouter               = "Router"
	TypeRouterCapability     = "RouterCapability"
	TypeRouterSecret         = "RouterSecret"
	TypeSchemaVersion        = "SchemaVersion"
	TypeSession              = "Session"
	TypeUser                 = "User"
)

// APIKeyMutation represents an operation that mutates the APIKey nodes in the graph.
type APIKeyMutation struct {
	config
	op                    Op
	typ                   string
	id                    *string
	name                  *string
	prefix                *string
	key_hash              *string
	scopes                *[]string
	appendscopes          []string
	allowed_routers       *[]string
	appendallowed_routers []string
	expires_at            *time.Time
	last_used_at          *time.Time
	usage_count           *int
	addusage_count        *int
	active                *bool
	revoked_at            *time.Time
	created_at            *time.Time
	updated_at            *time.Time
	clearedFields         map[string]struct{}
	user                  *string
	cleareduser           bool
	done                  bool
	oldValue              func(context.Context) (*APIKey, error)
	predicates            []predicate.APIKey
}

var _ ent.Mutation = (*APIKeyMutation)(nil)

// apikeyOption allows management of the mutation configuration using functional options.
type apikeyOption func(*APIKeyMutation)

// newAPIKeyMutation creates new mutation for the APIKey entity.
func newAPIKeyMutation(c config, op Op, opts ...apikeyOption) *APIKeyMutation {
	m := &APIKeyMutation{
		config:        c,
		op:            op,
		typ:           TypeAPIKey,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAPIKeyID sets the ID field of the mutation.
func withAPIKeyID(id string) apikeyOption {
	return func(m *APIKeyMutation) {
		var (
			err   error
			once  sync.Once
			value *APIKey
		)
		m.oldValue = func(ctx context.Context) (*APIKey, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().APIKey.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAPIKey sets the old APIKey of the mutation.
func withAPIKey(node *APIKey) apikeyOption {
	return func(m *APIKeyMutation) {
		m.oldValue = func(context.Context) (*APIKey, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m APIKeyMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m APIKeyMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of APIKey entities.
func (m *APIKeyMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *APIKeyMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *APIKeyMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().APIKey.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserID sets the "user_id" field.
func (m *APIKeyMutation) SetUserID(s string) {
	m.user = &s
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *APIKeyMutation) UserID() (r string, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the APIKey entity.
// If the APIKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIKeyMutation) OldUserID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *APIKeyMutation) ResetUserID() {
	m.user = nil
}

// SetName sets the "name" field.
func (m *APIKeyMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *APIKeyMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the APIKey entity.
// If the APIKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIKeyMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *APIKeyMutation) ResetName() {
	m.name = nil
}

// SetPrefix sets the "prefix" field.
func (m *APIKeyMutation) SetPrefix(s string) {
	m.prefix = &s
}

// Prefix returns the value of the "prefix" field in the mutation.
func (m *APIKeyMutation) Prefix() (r string, exists bool) {
	v := m.prefix
	if v == nil {
		return
	}
	return *v, true
}

// OldPrefix returns the old "prefix" field's value of the APIKey entity.
// If the APIKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIKeyMutation) OldPrefix(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrefix is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrefix requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrefix: %w", err)
	}
	return oldValue.Prefix, nil
}

// ResetPrefix resets all changes to the "prefix" field.
func (m *APIKeyMutation) ResetPrefix() {
	m.prefix = nil
}

// SetKeyHash sets the "key_hash" field.
func (m *APIKeyMutation) SetKeyHash(s string) {
	m.key_hash = &s
}

// KeyHash returns the value of the "key_hash" field in the mutation.
func (m *APIKeyMutation) KeyHash() (r string, exists bool) {
	v := m.key_hash
	if v == nil {
		return
	}
	return *v, true
}

// OldKeyHash returns the old "key_hash" field's value of the APIKey entity.
// If the APIKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIKeyMutation) OldKeyHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKeyHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKeyHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKeyHash: %w", err)
	}
	return oldValue.KeyHash, nil
}

// ResetKeyHash resets all changes to the "key_hash" field.
func (m *APIKeyMutation) ResetKeyHash() {
	m.key_hash = nil
}

// SetScopes sets the "scopes" field.
func (m *APIKeyMutation) SetScopes(s []string) {
	m.scopes = &s
	m.appendscopes = nil
}

// Scopes returns the value of the "scopes" field in the mutation.
func (m *APIKeyMutation) Scopes() (r []string, exists bool) {
	v := m.scopes
	if v == nil {
		return
	}
	return *v, true
}

// OldScopes returns the old "scopes" field's value of the APIKey entity.
// If the APIKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIKeyMutation) OldScopes(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScopes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScopes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScopes: %w", err)
	}
	return oldValue.Scopes, nil
}

// AppendScopes adds s to the "scopes" field.
func (m *APIKeyMutation) AppendScopes(s []string) {
	m.appendscopes = append(m.appendscopes, s...)
}

// AppendedScopes returns the list of values that were appended to the "scopes" field in this mutation.
func (m *APIKeyMutation) AppendedScopes() ([]string, bool) {
	if len(m.appendscopes) == 0 {
		return nil, false
	}
	return m.appendscopes, true
}

// ResetScopes resets all changes to the "scopes" field.
func (m *APIKeyMutation) ResetScopes() {
	m.scopes = nil
	m.appendscopes = nil
}

// SetAllowedRouters sets the "allowed_routers" field.
func (m *APIKeyMutation) SetAllowedRouters(s []string) {
	m.allowed_routers = &s
	m.appendallowed_routers = nil
}

// AllowedRouters returns the value of the "allowed_routers" field in the mutation.
func (m *APIKeyMutation) AllowedRouters() (r []string, exists bool) {
	v := m.allowed_routers
	if v == nil {
		return
	}
	return *v, true
}

// OldAllowedRouters returns the old "allowed_routers" field's value of the APIKey entity.
// If the APIKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIKeyMutation) OldAllowedRouters(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAllowedRouters is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAllowedRouters requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAllowedRouters: %w", err)
	}
	return oldValue.AllowedRouters, nil
}

// AppendAllowedRouters adds s to the "allowed_routers" field.
func (m *APIKeyMutation) AppendAllowedRouters(s []string) {
	m.appendallowed_routers = append(m.appendallowed_routers, s...)
}

// AppendedAllowedRouters returns the list of values that were appended to the "allowed_routers" field in this mutation.
func (m *APIKeyMutation) AppendedAllowedRouters() ([]string, bool) {
	if len(m.appendallowed_routers) == 0 {
		return nil, false
	}
	return m.appendallowed_routers, true
}

// ClearAllowedRouters clears the value of the "allowed_routers" field.
func (m *APIKeyMutation) ClearAllowedRouters() {
	m.allowed_routers = nil
	m.appendallowed_routers = nil
	m.clearedFields[apikey.FieldAllowedRouters] = struct{}{}
}

// AllowedRoutersCleared returns if the "allowed_routers" field was cleared in this mutation.
func (m *APIKeyMutation) AllowedRoutersCleared() bool {
	_, ok := m.clearedFields[apikey.FieldAllowedRouters]
	return ok
}

// ResetAllowedRouters resets all changes to the "allowed_routers" field.
func (m *APIKeyMutation) ResetAllowedRouters() {
	m.allowed_routers = nil
	m.appendallowed_routers = nil
	delete(m.clearedFields, apikey.FieldAllowedRouters)
}

// SetExpiresAt sets the "expires_at" field.
func (m *APIKeyMutation) SetExpiresAt(t time.Time) {
	m.expires_at = &t
}

// ExpiresAt returns the value of the "expires_at" field in the mutation.
func (m *APIKeyMutation) ExpiresAt() (r time.Time, exists bool) {
	v := m.expires_at
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiresAt returns the old "expires_at" field's value of the APIKey entity.
// If the APIKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIKeyMutation) OldExpiresAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiresAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiresAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiresAt: %w", err)
	}
	return oldValue.ExpiresAt, nil
}

// ClearExpiresAt clears the value of the "expires_at" field.
func (m *APIKeyMutation) ClearExpiresAt() {
	m.expires_at = nil
	m.clearedFields[apikey.FieldExpiresAt] = struct{}{}
}

// ExpiresAtCleared returns if the "expires_at" field was cleared in this mutation.
func (m *APIKeyMutation) ExpiresAtCleared() bool {
	_, ok := m.clearedFields[apikey.FieldExpiresAt]
	return ok
}

// ResetExpiresAt resets all changes to the "expires_at" field.
func (m *APIKeyMutation) ResetExpiresAt() {
	m.expires_at = nil
	delete(m.clearedFields, apikey.FieldExpiresAt)
}

// SetLastUsedAt sets the "last_used_at" field.
func (m *APIKeyMutation) SetLastUsedAt(t time.Time) {
	m.last_used_at = &t
}

// LastUsedAt returns the value of the "last_used_at" field in the mutation.
func (m *APIKeyMutation) LastUsedAt() (r time.Time, exists bool) {
	v := m.last_used_at
	if v == nil {
		return
	}
	return *v, true
}

// OldLastUsedAt returns the old "last_used_at" field's value of the APIKey entity.
// If the APIKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIKeyMutation) OldLastUsedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastUsedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastUsedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastUsedAt: %w", err)
	}
	return oldValue.LastUsedAt, nil
}

// ClearLastUsedAt clears the value of the "last_used_at" field.
func (m *APIKeyMutation) ClearLastUsedAt() {
	m.last_used_at = nil
	m.clearedFields[apikey.FieldLastUsedAt] = struct{}{}
}

// LastUsedAtCleared returns if the "last_used_at" field was cleared in this mutation.
func (m *APIKeyMutation) LastUsedAtCleared() bool {
	_, ok := m.clearedFields[apikey.FieldLastUsedAt]
	return ok
}

// ResetLastUsedAt resets all changes to the "last_used_at" field.
func (m *APIKeyMutation) ResetLastUsedAt() {
	m.last_used_at = nil
	delete(m.clearedFields, apikey.FieldLastUsedAt)
}

// SetUsageCount sets the "usage_count" field.
func (m *APIKeyMutation) SetUsageCount(i int) {
	m.usage_count = &i
	m.addusage_count = nil
}

// UsageCount returns the value of the "usage_count" field in the mutation.
func (m *APIKeyMutation) UsageCount() (r int, exists bool) {
	v := m.usage_count
	if v == nil {
		return
	}
	return *v, true
}

// OldUsageCount returns the old "usage_count" field's value of the APIKey entity.
// If the APIKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIKeyMutation) OldUsageCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsageCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsageCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsageCount: %w", err)
	}
	return oldValue.UsageCount, nil
}

// AddUsageCount adds i to the "usage_count" field.
func (m *APIKeyMutation) AddUsageCount(i int) {
	if m.addusage_count != nil {
		*m.addusage_count += i
	} else {
		m.addusage_count = &i
	}
}

// AddedUsageCount returns the value that was added to the "usage_count" field in this mutation.
func (m *APIKeyMutation) AddedUsageCount() (r int, exists bool) {
	v := m.addusage_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetUsageCount resets all changes to the "usage_count" field.
func (m *APIKeyMutation) ResetUsageCount() {
	m.usage_count = nil
	m.addusage_count = nil
}

// SetActive sets the "active" field.
func (m *APIKeyMutation) SetActive(b bool) {
	m.active = &b
}

// Active returns the value of the "active" field in the mutation.
func (m *APIKeyMutation) Active() (r bool, exists bool) {
	v := m.active
	if v == nil {
		return
	}
	return *v, true
}

// OldActive returns the old "active" field's value of the APIKey entity.
// If the APIKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIKeyMutation) OldActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActive: %w", err)
	}
	return oldValue.Active, nil
}

// ResetActive resets all changes to the "active" field.
func (m *APIKeyMutation) ResetActive() {
	m.active = nil
}

// SetRevokedAt sets the "revoked_at" field.
func (m *APIKeyMutation) SetRevokedAt(t time.Time) {
	m.revoked_at = &t
}

// RevokedAt returns the value of the "revoked_at" field in the mutation.
func (m *APIKeyMutation) RevokedAt() (r time.Time, exists bool) {
	v := m.revoked_at
	if v == nil {
		return
	}
	return *v, true
}

// OldRevokedAt returns the old "revoked_at" field's value of the APIKey entity.
// If the APIKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIKeyMutation) OldRevokedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRevokedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRevokedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRevokedAt: %w", err)
	}
	return oldValue.RevokedAt, nil
}

// ClearRevokedAt clears the value of the "revoked_at" field.
func (m *APIKeyMutation) ClearRevokedAt() {
	m.revoked_at = nil
	m.clearedFields[apikey.FieldRevokedAt] = struct{}{}
}

// RevokedAtCleared returns if the "revoked_at" field was cleared in this mutation.
func (m *APIKeyMutation) RevokedAtCleared() bool {
	_, ok := m.clearedFields[apikey.FieldRevokedAt]
	return ok
}

// ResetRevokedAt resets all changes to the "revoked_at" field.
func (m *APIKeyMutation) ResetRevokedAt() {
	m.revoked_at = nil
	delete(m.clearedFields, apikey.FieldRevokedAt)
}

// SetCreatedAt sets the "created_at" field.
func (m *APIKeyMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *APIKeyMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the APIKey entity.
// If the APIKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIKeyMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *APIKeyMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *APIKeyMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *APIKeyMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the APIKey entity.
// If the APIKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIKeyMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *APIKeyMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *APIKeyMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[apikey.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *APIKeyMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *APIKeyMutation) UserIDs() (ids []string) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *APIKeyMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the APIKeyMutation builder.
func (m *APIKeyMutation) Where(ps ...predicate.APIKey) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the APIKeyMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *APIKeyMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.APIKey, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *APIKeyMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *APIKeyMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (APIKey).
func (m *APIKeyMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *APIKeyMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.user != nil {
		fields = append(fields, apikey.FieldUserID)
	}
	if m.name != nil {
		fields = append(fields, apikey.FieldName)
	}
	if m.prefix != nil {
		fields = append(fields, apikey.FieldPrefix)
	}
	if m.key_hash != nil {
		fields = append(fields, apikey.FieldKeyHash)
	}
	if m.scopes != nil {
		fields = append(fields, apikey.FieldScopes)
	}
	if m.allowed_routers != nil {
		fields = append(fields, apikey.FieldAllowedRouters)
	}
	if m.expires_at != nil {
		fields = append(fields, apikey.FieldExpiresAt)
	}
	if m.last_used_at != nil {
		fields = append(fields, apikey.FieldLastUsedAt)
	}
	if m.usage_count != nil {
		fields = append(fields, apikey.FieldUsageCount)
	}
	if m.active != nil {
		fields = append(fields, apikey.FieldActive)
	}
	if m.revoked_at != nil {
		fields = append(fields, apikey.FieldRevokedAt)
	}
	if m.created_at != nil {
		fields = append(fields, apikey.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, apikey.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *APIKeyMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case apikey.FieldUserID:
		return m.UserID()
	case apikey.FieldName:
		return m.Name()
	case apikey.FieldPrefix:
		return m.Prefix()
	case apikey.FieldKeyHash:
		return m.KeyHash()
	case apikey.FieldScopes:
		return m.Scopes()
	case apikey.FieldAllowedRouters:
		return m.AllowedRouters()
	case apikey.FieldExpiresAt:
		return m.ExpiresAt()
	case apikey.FieldLastUsedAt:
		return m.LastUsedAt()
	case apikey.FieldUsageCount:
		return m.UsageCount()
	case apikey.FieldActive:
		return m.Active()
	case apikey.FieldRevokedAt:
		return m.RevokedAt()
	case apikey.FieldCreatedAt:
		return m.CreatedAt()
	case apikey.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *APIKeyMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case apikey.FieldUserID:
		return m.OldUserID(ctx)
	case apikey.FieldName:
		return m.OldName(ctx)
	case apikey.FieldPrefix:
		return m.OldPrefix(ctx)
	case apikey.FieldKeyHash:
		return m.OldKeyHash(ctx)
	case apikey.FieldScopes:
		return m.OldScopes(ctx)
	case apikey.FieldAllowedRouters:
		return m.OldAllowedRouters(ctx)
	case apikey.FieldExpiresAt:
		return m.OldExpiresAt(ctx)
	case apikey.FieldLastUsedAt:
		return m.OldLastUsedAt(ctx)
	case apikey.FieldUsageCount:
		return m.OldUsageCount(ctx)
	case apikey.FieldActive:
		return m.OldActive(ctx)
	case apikey.FieldRevokedAt:
		return m.OldRevokedAt(ctx)
	case apikey.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case apikey.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown APIKey field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *APIKeyMutation) SetField(name string, value ent.Value) error {
	switch name {
	case apikey.FieldUserID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case apikey.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case apikey.FieldPrefix:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrefix(v)
		return nil
	case apikey.FieldKeyHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKeyHash(v)
		return nil
	case apikey.FieldScopes:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScopes(v)
		return nil
	case apikey.FieldAllowedRouters:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAllowedRouters(v)
		return nil
	case apikey.FieldExpiresAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiresAt(v)
		return nil
	case apikey.FieldLastUsedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastUsedAt(v)
		return nil
	case apikey.FieldUsageCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsageCount(v)
		return nil
	case apikey.FieldActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActive(v)
		return nil
	case apikey.FieldRevokedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRevokedAt(v)
		return nil
	case apikey.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case apikey.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown APIKey field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *APIKeyMutation) AddedFields() []string {
	var fields []string
	if m.addusage_count != nil {
		fields = append(fields, apikey.FieldUsageCount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *APIKeyMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case apikey.FieldUsageCount:
		return m.AddedUsageCount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *APIKeyMutation) AddField(name string, value ent.Value) error {
	switch name {
	case apikey.FieldUsageCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUsageCount(v)
		return nil
	}
	return fmt.Errorf("unknown APIKey numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *APIKeyMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(apikey.FieldAllowedRouters) {
		fields = append(fields, apikey.FieldAllowedRouters)
	}
	if m.FieldCleared(apikey.FieldExpiresAt) {
		fields = append(fields, apikey.FieldExpiresAt)
	}
	if m.FieldCleared(apikey.FieldLastUsedAt) {
		fields = append(fields, apikey.FieldLastUsedAt)
	}
	if m.FieldCleared(apikey.FieldRevokedAt) {
		fields = append(fields, apikey.FieldRevokedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *APIKeyMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *APIKeyMutation) ClearField(name string) error {
	switch name {
	case apikey.FieldAllowedRouters:
		m.ClearAllowedRouters()
		return nil
	case apikey.FieldExpiresAt:
		m.ClearExpiresAt()
		return nil
	case apikey.FieldLastUsedAt:
		m.ClearLastUsedAt()
		return nil
	case apikey.FieldRevokedAt:
		m.ClearRevokedAt()
		return nil
	}
	return fmt.Errorf("unknown APIKey nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *APIKeyMutation) ResetField(name string) error {
	switch name {
	case apikey.FieldUserID:
		m.ResetUserID()
		return nil
	case apikey.FieldName:
		m.ResetName()
		return nil
	case apikey.FieldPrefix:
		m.ResetPrefix()
		return nil
	case apikey.FieldKeyHash:
		m.ResetKeyHash()
		return nil
	case apikey.FieldScopes:
		m.ResetScopes()
		return nil
	case apikey.FieldAllowedRouters:
		m.ResetAllowedRouters()
		return nil
	case apikey.FieldExpiresAt:
		m.ResetExpiresAt()
		return nil
	case apikey.FieldLastUsedAt:
		m.ResetLastUsedAt()
		return nil
	case apikey.FieldUsageCount:
		m.ResetUsageCount()
		return nil
	case apikey.FieldActive:
		m.ResetActive()
		return nil
	case apikey.FieldRevokedAt:
		m.ResetRevokedAt()
		return nil
	case apikey.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case apikey.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown APIKey field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *APIKeyMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, apikey.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *APIKeyMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case apikey.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *APIKeyMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *APIKeyMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *APIKeyMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, apikey.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *APIKeyMutation) EdgeCleared(name string) bool {
	switch name {
	case apikey.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *APIKeyMutation) ClearEdge(name string) error {
	switch name {
	case apikey.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown APIKey unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *APIKeyMutation) ResetEdge(name string) error {
	switch name {
	case apikey.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown APIKey edge %s", name)
}

// AlertMutation represents an operation that mutates the Alert nodes in the graph.
type AlertMutation struct {
	config
	op              Op
	typ             string
	id              *string
	event_type      *string
	severity        *alert.Severity
	title           *string
	message         *string
	data            *map[string]interface{}
	device_id       *string
	acknowledged_at *time.Time
	acknowledged_by *string
	delivery_status *map[string]interface{}
	triggered_at    *time.Time
	updated_at      *time.Time
	clearedFields   map[string]struct{}
	rule            *string
	clearedrule     bool
	done            bool
	oldValue        func(context.Context) (*Alert, error)
	predicates      []predicate.Alert
}

var _ ent.Mutation = (*AlertMutation)(nil)

// alertOption allows management of the mutation configuration using functional options.
type alertOption func(*AlertMutation)

// newAlertMutation creates new mutation for the Alert entity.
func newAlertMutation(c config, op Op, opts ...alertOption) *AlertMutation {
	m := &AlertMutation{
		config:        c,
		op:            op,
		typ:           TypeAlert,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAlertID sets the ID field of the mutation.
func withAlertID(id string) alertOption {
	return func(m *AlertMutation) {
		var (
			err   error
			once  sync.Once
			value *Alert
		)
		m.oldValue = func(ctx context.Context) (*Alert, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Alert.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAlert sets the old Alert of the mutation.
func withAlert(node *Alert) alertOption {
	return func(m *AlertMutation) {
		m.oldValue = func(context.Context) (*Alert, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AlertMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AlertMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Alert entities.
func (m *AlertMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AlertMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AlertMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Alert.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetRuleID sets the "rule_id" field.
func (m *AlertMutation) SetRuleID(s string) {
	m.rule = &s
}

// RuleID returns the value of the "rule_id" field in the mutation.
func (m *AlertMutation) RuleID() (r string, exists bool) {
	v := m.rule
	if v == nil {
		return
	}
	return *v, true
}

// OldRuleID returns the old "rule_id" field's value of the Alert entity.
// If the Alert object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertMutation) OldRuleID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRuleID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRuleID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRuleID: %w", err)
	}
	return oldValue.RuleID, nil
}

// ResetRuleID resets all changes to the "rule_id" field.
func (m *AlertMutation) ResetRuleID() {
	m.rule = nil
}

// SetEventType sets the "event_type" field.
func (m *AlertMutation) SetEventType(s string) {
	m.event_type = &s
}

// EventType returns the value of the "event_type" field in the mutation.
func (m *AlertMutation) EventType() (r string, exists bool) {
	v := m.event_type
	if v == nil {
		return
	}
	return *v, true
}

// OldEventType returns the old "event_type" field's value of the Alert entity.
// If the Alert object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertMutation) OldEventType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEventType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEventType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEventType: %w", err)
	}
	return oldValue.EventType, nil
}

// ResetEventType resets all changes to the "event_type" field.
func (m *AlertMutation) ResetEventType() {
	m.event_type = nil
}

// SetSeverity sets the "severity" field.
func (m *AlertMutation) SetSeverity(a alert.Severity) {
	m.severity = &a
}

// Severity returns the value of the "severity" field in the mutation.
func (m *AlertMutation) Severity() (r alert.Severity, exists bool) {
	v := m.severity
	if v == nil {
		return
	}
	return *v, true
}

// OldSeverity returns the old "severity" field's value of the Alert entity.
// If the Alert object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertMutation) OldSeverity(ctx context.Context) (v alert.Severity, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSeverity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSeverity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSeverity: %w", err)
	}
	return oldValue.Severity, nil
}

// ResetSeverity resets all changes to the "severity" field.
func (m *AlertMutation) ResetSeverity() {
	m.severity = nil
}

// SetTitle sets the "title" field.
func (m *AlertMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *AlertMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Alert entity.
// If the Alert object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *AlertMutation) ResetTitle() {
	m.title = nil
}

// SetMessage sets the "message" field.
func (m *AlertMutation) SetMessage(s string) {
	m.message = &s
}

// Message returns the value of the "message" field in the mutation.
func (m *AlertMutation) Message() (r string, exists bool) {
	v := m.message
	if v == nil {
		return
	}
	return *v, true
}

// OldMessage returns the old "message" field's value of the Alert entity.
// If the Alert object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertMutation) OldMessage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMessage: %w", err)
	}
	return oldValue.Message, nil
}

// ResetMessage resets all changes to the "message" field.
func (m *AlertMutation) ResetMessage() {
	m.message = nil
}

// SetData sets the "data" field.
func (m *AlertMutation) SetData(value map[string]interface{}) {
	m.data = &value
}

// Data returns the value of the "data" field in the mutation.
func (m *AlertMutation) Data() (r map[string]interface{}, exists bool) {
	v := m.data
	if v == nil {
		return
	}
	return *v, true
}

// OldData returns the old "data" field's value of the Alert entity.
// If the Alert object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertMutation) OldData(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldData is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldData requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldData: %w", err)
	}
	return oldValue.Data, nil
}

// ClearData clears the value of the "data" field.
func (m *AlertMutation) ClearData() {
	m.data = nil
	m.clearedFields[alert.FieldData] = struct{}{}
}

// DataCleared returns if the "data" field was cleared in this mutation.
func (m *AlertMutation) DataCleared() bool {
	_, ok := m.clearedFields[alert.FieldData]
	return ok
}

// ResetData resets all changes to the "data" field.
func (m *AlertMutation) ResetData() {
	m.data = nil
	delete(m.clearedFields, alert.FieldData)
}

// SetDeviceID sets the "device_id" field.
func (m *AlertMutation) SetDeviceID(s string) {
	m.device_id = &s
}

// DeviceID returns the value of the "device_id" field in the mutation.
func (m *AlertMutation) DeviceID() (r string, exists bool) {
	v := m.device_id
	if v == nil {
		return
	}
	return *v, true
}

// OldDeviceID returns the old "device_id" field's value of the Alert entity.
// If the Alert object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertMutation) OldDeviceID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeviceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeviceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeviceID: %w", err)
	}
	return oldValue.DeviceID, nil
}

// ClearDeviceID clears the value of the "device_id" field.
func (m *AlertMutation) ClearDeviceID() {
	m.device_id = nil
	m.clearedFields[alert.FieldDeviceID] = struct{}{}
}

// DeviceIDCleared returns if the "device_id" field was cleared in this mutation.
func (m *AlertMutation) DeviceIDCleared() bool {
	_, ok := m.clearedFields[alert.FieldDeviceID]
	return ok
}

// ResetDeviceID resets all changes to the "device_id" field.
func (m *AlertMutation) ResetDeviceID() {
	m.device_id = nil
	delete(m.clearedFields, alert.FieldDeviceID)
}

// SetAcknowledgedAt sets the "acknowledged_at" field.
func (m *AlertMutation) SetAcknowledgedAt(t time.Time) {
	m.acknowledged_at = &t
}

// AcknowledgedAt returns the value of the "acknowledged_at" field in the mutation.
func (m *AlertMutation) AcknowledgedAt() (r time.Time, exists bool) {
	v := m.acknowledged_at
	if v == nil {
		return
	}
	return *v, true
}

// OldAcknowledgedAt returns the old "acknowledged_at" field's value of the Alert entity.
// If the Alert object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertMutation) OldAcknowledgedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAcknowledgedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAcknowledgedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAcknowledgedAt: %w", err)
	}
	return oldValue.AcknowledgedAt, nil
}

// ClearAcknowledgedAt clears the value of the "acknowledged_at" field.
func (m *AlertMutation) ClearAcknowledgedAt() {
	m.acknowledged_at = nil
	m.clearedFields[alert.FieldAcknowledgedAt] = struct{}{}
}

// AcknowledgedAtCleared returns if the "acknowledged_at" field was cleared in this mutation.
func (m *AlertMutation) AcknowledgedAtCleared() bool {
	_, ok := m.clearedFields[alert.FieldAcknowledgedAt]
	return ok
}

// ResetAcknowledgedAt resets all changes to the "acknowledged_at" field.
func (m *AlertMutation) ResetAcknowledgedAt() {
	m.acknowledged_at = nil
	delete(m.clearedFields, alert.FieldAcknowledgedAt)
}

// SetAcknowledgedBy sets the "acknowledged_by" field.
func (m *AlertMutation) SetAcknowledgedBy(s string) {
	m.acknowledged_by = &s
}

// AcknowledgedBy returns the value of the "acknowledged_by" field in the mutation.
func (m *AlertMutation) AcknowledgedBy() (r string, exists bool) {
	v := m.acknowledged_by
	if v == nil {
		return
	}
	return *v, true
}

// OldAcknowledgedBy returns the old "acknowledged_by" field's value of the Alert entity.
// If the Alert object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertMutation) OldAcknowledgedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAcknowledgedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAcknowledgedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAcknowledgedBy: %w", err)
	}
	return oldValue.AcknowledgedBy, nil
}

// ClearAcknowledgedBy clears the value of the "acknowledged_by" field.
func (m *AlertMutation) ClearAcknowledgedBy() {
	m.acknowledged_by = nil
	m.clearedFields[alert.FieldAcknowledgedBy] = struct{}{}
}

// AcknowledgedByCleared returns if the "acknowledged_by" field was cleared in this mutation.
func (m *AlertMutation) AcknowledgedByCleared() bool {
	_, ok := m.clearedFields[alert.FieldAcknowledgedBy]
	return ok
}

// ResetAcknowledgedBy resets all changes to the "acknowledged_by" field.
func (m *AlertMutation) ResetAcknowledgedBy() {
	m.acknowledged_by = nil
	delete(m.clearedFields, alert.FieldAcknowledgedBy)
}

// SetDeliveryStatus sets the "delivery_status" field.
func (m *AlertMutation) SetDeliveryStatus(value map[string]interface{}) {
	m.delivery_status = &value
}

// DeliveryStatus returns the value of the "delivery_status" field in the mutation.
func (m *AlertMutation) DeliveryStatus() (r map[string]interface{}, exists bool) {
	v := m.delivery_status
	if v == nil {
		return
	}
	return *v, true
}

// OldDeliveryStatus returns the old "delivery_status" field's value of the Alert entity.
// If the Alert object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertMutation) OldDeliveryStatus(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeliveryStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeliveryStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeliveryStatus: %w", err)
	}
	return oldValue.DeliveryStatus, nil
}

// ClearDeliveryStatus clears the value of the "delivery_status" field.
func (m *AlertMutation) ClearDeliveryStatus() {
	m.delivery_status = nil
	m.clearedFields[alert.FieldDeliveryStatus] = struct{}{}
}

// DeliveryStatusCleared returns if the "delivery_status" field was cleared in this mutation.
func (m *AlertMutation) DeliveryStatusCleared() bool {
	_, ok := m.clearedFields[alert.FieldDeliveryStatus]
	return ok
}

// ResetDeliveryStatus resets all changes to the "delivery_status" field.
func (m *AlertMutation) ResetDeliveryStatus() {
	m.delivery_status = nil
	delete(m.clearedFields, alert.FieldDeliveryStatus)
}

// SetTriggeredAt sets the "triggered_at" field.
func (m *AlertMutation) SetTriggeredAt(t time.Time) {
	m.triggered_at = &t
}

// TriggeredAt returns the value of the "triggered_at" field in the mutation.
func (m *AlertMutation) TriggeredAt() (r time.Time, exists bool) {
	v := m.triggered_at
	if v == nil {
		return
	}
	return *v, true
}

// OldTriggeredAt returns the old "triggered_at" field's value of the Alert entity.
// If the Alert object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertMutation) OldTriggeredAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTriggeredAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTriggeredAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTriggeredAt: %w", err)
	}
	return oldValue.TriggeredAt, nil
}

// ResetTriggeredAt resets all changes to the "triggered_at" field.
func (m *AlertMutation) ResetTriggeredAt() {
	m.triggered_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AlertMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AlertMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Alert entity.
// If the Alert object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AlertMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearRule clears the "rule" edge to the AlertRule entity.
func (m *AlertMutation) ClearRule() {
	m.clearedrule = true
	m.clearedFields[alert.FieldRuleID] = struct{}{}
}

// RuleCleared reports if the "rule" edge to the AlertRule entity was cleared.
func (m *AlertMutation) RuleCleared() bool {
	return m.clearedrule
}

// RuleIDs returns the "rule" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RuleID instead. It exists only for internal usage by the builders.
func (m *AlertMutation) RuleIDs() (ids []string) {
	if id := m.rule; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRule resets all changes to the "rule" edge.
func (m *AlertMutation) ResetRule() {
	m.rule = nil
	m.clearedrule = false
}

// Where appends a list predicates to the AlertMutation builder.
func (m *AlertMutation) Where(ps ...predicate.Alert) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AlertMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AlertMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Alert, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AlertMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AlertMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Alert).
func (m *AlertMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AlertMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.rule != nil {
		fields = append(fields, alert.FieldRuleID)
	}
	if m.event_type != nil {
		fields = append(fields, alert.FieldEventType)
	}
	if m.severity != nil {
		fields = append(fields, alert.FieldSeverity)
	}
	if m.title != nil {
		fields = append(fields, alert.FieldTitle)
	}
	if m.message != nil {
		fields = append(fields, alert.FieldMessage)
	}
	if m.data != nil {
		fields = append(fields, alert.FieldData)
	}
	if m.device_id != nil {
		fields = append(fields, alert.FieldDeviceID)
	}
	if m.acknowledged_at != nil {
		fields = append(fields, alert.FieldAcknowledgedAt)
	}
	if m.acknowledged_by != nil {
		fields = append(fields, alert.FieldAcknowledgedBy)
	}
	if m.delivery_status != nil {
		fields = append(fields, alert.FieldDeliveryStatus)
	}
	if m.triggered_at != nil {
		fields = append(fields, alert.FieldTriggeredAt)
	}
	if m.updated_at != nil {
		fields = append(fields, alert.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AlertMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case alert.FieldRuleID:
		return m.RuleID()
	case alert.FieldEventType:
		return m.EventType()
	case alert.FieldSeverity:
		return m.Severity()
	case alert.FieldTitle:
		return m.Title()
	case alert.FieldMessage:
		return m.Message()
	case alert.FieldData:
		return m.Data()
	case alert.FieldDeviceID:
		return m.DeviceID()
	case alert.FieldAcknowledgedAt:
		return m.AcknowledgedAt()
	case alert.FieldAcknowledgedBy:
		return m.AcknowledgedBy()
	case alert.FieldDeliveryStatus:
		return m.DeliveryStatus()
	case alert.FieldTriggeredAt:
		return m.TriggeredAt()
	case alert.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AlertMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case alert.FieldRuleID:
		return m.OldRuleID(ctx)
	case alert.FieldEventType:
		return m.OldEventType(ctx)
	case alert.FieldSeverity:
		return m.OldSeverity(ctx)
	case alert.FieldTitle:
		return m.OldTitle(ctx)
	case alert.FieldMessage:
		return m.OldMessage(ctx)
	case alert.FieldData:
		return m.OldData(ctx)
	case alert.FieldDeviceID:
		return m.OldDeviceID(ctx)
	case alert.FieldAcknowledgedAt:
		return m.OldAcknowledgedAt(ctx)
	case alert.FieldAcknowledgedBy:
		return m.OldAcknowledgedBy(ctx)
	case alert.FieldDeliveryStatus:
		return m.OldDeliveryStatus(ctx)
	case alert.FieldTriggeredAt:
		return m.OldTriggeredAt(ctx)
	case alert.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Alert field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AlertMutation) SetField(name string, value ent.Value) error {
	switch name {
	case alert.FieldRuleID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRuleID(v)
		return nil
	case alert.FieldEventType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEventType(v)
		return nil
	case alert.FieldSeverity:
		v, ok := value.(alert.Severity)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSeverity(v)
		return nil
	case alert.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case alert.FieldMessage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMessage(v)
		return nil
	case alert.FieldData:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetData(v)
		return nil
	case alert.FieldDeviceID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeviceID(v)
		return nil
	case alert.FieldAcknowledgedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAcknowledgedAt(v)
		return nil
	case alert.FieldAcknowledgedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAcknowledgedBy(v)
		return nil
	case alert.FieldDeliveryStatus:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeliveryStatus(v)
		return nil
	case alert.FieldTriggeredAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTriggeredAt(v)
		return nil
	case alert.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Alert field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AlertMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AlertMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AlertMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Alert numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AlertMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(alert.FieldData) {
		fields = append(fields, alert.FieldData)
	}
	if m.FieldCleared(alert.FieldDeviceID) {
		fields = append(fields, alert.FieldDeviceID)
	}
	if m.FieldCleared(alert.FieldAcknowledgedAt) {
		fields = append(fields, alert.FieldAcknowledgedAt)
	}
	if m.FieldCleared(alert.FieldAcknowledgedBy) {
		fields = append(fields, alert.FieldAcknowledgedBy)
	}
	if m.FieldCleared(alert.FieldDeliveryStatus) {
		fields = append(fields, alert.FieldDeliveryStatus)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AlertMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AlertMutation) ClearField(name string) error {
	switch name {
	case alert.FieldData:
		m.ClearData()
		return nil
	case alert.FieldDeviceID:
		m.ClearDeviceID()
		return nil
	case alert.FieldAcknowledgedAt:
		m.ClearAcknowledgedAt()
		return nil
	case alert.FieldAcknowledgedBy:
		m.ClearAcknowledgedBy()
		return nil
	case alert.FieldDeliveryStatus:
		m.ClearDeliveryStatus()
		return nil
	}
	return fmt.Errorf("unknown Alert nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AlertMutation) ResetField(name string) error {
	switch name {
	case alert.FieldRuleID:
		m.ResetRuleID()
		return nil
	case alert.FieldEventType:
		m.ResetEventType()
		return nil
	case alert.FieldSeverity:
		m.ResetSeverity()
		return nil
	case alert.FieldTitle:
		m.ResetTitle()
		return nil
	case alert.FieldMessage:
		m.ResetMessage()
		return nil
	case alert.FieldData:
		m.ResetData()
		return nil
	case alert.FieldDeviceID:
		m.ResetDeviceID()
		return nil
	case alert.FieldAcknowledgedAt:
		m.ResetAcknowledgedAt()
		return nil
	case alert.FieldAcknowledgedBy:
		m.ResetAcknowledgedBy()
		return nil
	case alert.FieldDeliveryStatus:
		m.ResetDeliveryStatus()
		return nil
	case alert.FieldTriggeredAt:
		m.ResetTriggeredAt()
		return nil
	case alert.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Alert field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AlertMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.rule != nil {
		edges = append(edges, alert.EdgeRule)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AlertMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case alert.EdgeRule:
		if id := m.rule; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AlertMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AlertMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AlertMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedrule {
		edges = append(edges, alert.EdgeRule)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AlertMutation) EdgeCleared(name string) bool {
	switch name {
	case alert.EdgeRule:
		return m.clearedrule
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AlertMutation) ClearEdge(name string) error {
	switch name {
	case alert.EdgeRule:
		m.ClearRule()
		return nil
	}
	return fmt.Errorf("unknown Alert unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AlertMutation) ResetEdge(name string) error {
	switch name {
	case alert.EdgeRule:
		m.ResetRule()
		return nil
	}
	return fmt.Errorf("unknown Alert edge %s", name)
}

// AlertRuleMutation represents an operation that mutates the AlertRule nodes in the graph.
type AlertRuleMutation struct {
	config
	op               Op
	typ              string
	id               *string
	name             *string
	description      *string
	event_type       *string
	conditions       *[]map[string]interface{}
	appendconditions []map[string]interface{}
	severity         *alertrule.Severity
	channels         *[]string
	appendchannels   []string
	throttle         *map[string]interface{}
	quiet_hours      *map[string]interface{}
	device_id        *string
	enabled          *bool
	created_at       *time.Time
	updated_at       *time.Time
	clearedFields    map[string]struct{}
	alerts           map[string]struct{}
	removedalerts    map[string]struct{}
	clearedalerts    bool
	done             bool
	oldValue         func(context.Context) (*AlertRule, error)
	predicates       []predicate.AlertRule
}

var _ ent.Mutation = (*AlertRuleMutation)(nil)

// alertruleOption allows management of the mutation configuration using functional options.
type alertruleOption func(*AlertRuleMutation)

// newAlertRuleMutation creates new mutation for the AlertRule entity.
func newAlertRuleMutation(c config, op Op, opts ...alertruleOption) *AlertRuleMutation {
	m := &AlertRuleMutation{
		config:        c,
		op:            op,
		typ:           TypeAlertRule,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAlertRuleID sets the ID field of the mutation.
func withAlertRuleID(id string) alertruleOption {
	return func(m *AlertRuleMutation) {
		var (
			err   error
			once  sync.Once
			value *AlertRule
		)
		m.oldValue = func(ctx context.Context) (*AlertRule, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AlertRule.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAlertRule sets the old AlertRule of the mutation.
func withAlertRule(node *AlertRule) alertruleOption {
	return func(m *AlertRuleMutation) {
		m.oldValue = func(context.Context) (*AlertRule, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AlertRuleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AlertRuleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AlertRule entities.
func (m *AlertRuleMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AlertRuleMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AlertRuleMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AlertRule.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *AlertRuleMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *AlertRuleMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the AlertRule entity.
// If the AlertRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertRuleMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *AlertRuleMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *AlertRuleMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *AlertRuleMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the AlertRule entity.
// If the AlertRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertRuleMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *AlertRuleMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[alertrule.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *AlertRuleMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[alertrule.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *AlertRuleMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, alertrule.FieldDescription)
}

// SetEventType sets the "event_type" field.
func (m *AlertRuleMutation) SetEventType(s string) {
	m.event_type = &s
}

// EventType returns the value of the "event_type" field in the mutation.
func (m *AlertRuleMutation) EventType() (r string, exists bool) {
	v := m.event_type
	if v == nil {
		return
	}
	return *v, true
}

// OldEventType returns the old "event_type" field's value of the AlertRule entity.
// If the AlertRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertRuleMutation) OldEventType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEventType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEventType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEventType: %w", err)
	}
	return oldValue.EventType, nil
}

// ResetEventType resets all changes to the "event_type" field.
func (m *AlertRuleMutation) ResetEventType() {
	m.event_type = nil
}

// SetConditions sets the "conditions" field.
func (m *AlertRuleMutation) SetConditions(value []map[string]interface{}) {
	m.conditions = &value
	m.appendconditions = nil
}

// Conditions returns the value of the "conditions" field in the mutation.
func (m *AlertRuleMutation) Conditions() (r []map[string]interface{}, exists bool) {
	v := m.conditions
	if v == nil {
		return
	}
	return *v, true
}

// OldConditions returns the old "conditions" field's value of the AlertRule entity.
// If the AlertRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertRuleMutation) OldConditions(ctx context.Context) (v []map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConditions is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConditions requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConditions: %w", err)
	}
	return oldValue.Conditions, nil
}

// AppendConditions adds value to the "conditions" field.
func (m *AlertRuleMutation) AppendConditions(value []map[string]interface{}) {
	m.appendconditions = append(m.appendconditions, value...)
}

// AppendedConditions returns the list of values that were appended to the "conditions" field in this mutation.
func (m *AlertRuleMutation) AppendedConditions() ([]map[string]interface{}, bool) {
	if len(m.appendconditions) == 0 {
		return nil, false
	}
	return m.appendconditions, true
}

// ClearConditions clears the value of the "conditions" field.
func (m *AlertRuleMutation) ClearConditions() {
	m.conditions = nil
	m.appendconditions = nil
	m.clearedFields[alertrule.FieldConditions] = struct{}{}
}

// ConditionsCleared returns if the "conditions" field was cleared in this mutation.
func (m *AlertRuleMutation) ConditionsCleared() bool {
	_, ok := m.clearedFields[alertrule.FieldConditions]
	return ok
}

// ResetConditions resets all changes to the "conditions" field.
func (m *AlertRuleMutation) ResetConditions() {
	m.conditions = nil
	m.appendconditions = nil
	delete(m.clearedFields, alertrule.FieldConditions)
}

// SetSeverity sets the "severity" field.
func (m *AlertRuleMutation) SetSeverity(a alertrule.Severity) {
	m.severity = &a
}

// Severity returns the value of the "severity" field in the mutation.
func (m *AlertRuleMutation) Severity() (r alertrule.Severity, exists bool) {
	v := m.severity
	if v == nil {
		return
	}
	return *v, true
}

// OldSeverity returns the old "severity" field's value of the AlertRule entity.
// If the AlertRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertRuleMutation) OldSeverity(ctx context.Context) (v alertrule.Severity, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSeverity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSeverity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSeverity: %w", err)
	}
	return oldValue.Severity, nil
}

// ResetSeverity resets all changes to the "severity" field.
func (m *AlertRuleMutation) ResetSeverity() {
	m.severity = nil
}

// SetChannels sets the "channels" field.
func (m *AlertRuleMutation) SetChannels(s []string) {
	m.channels = &s
	m.appendchannels = nil
}

// Channels returns the value of the "channels" field in the mutation.
func (m *AlertRuleMutation) Channels() (r []string, exists bool) {
	v := m.channels
	if v == nil {
		return
	}
	return *v, true
}

// OldChannels returns the old "channels" field's value of the AlertRule entity.
// If the AlertRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertRuleMutation) OldChannels(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChannels is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChannels requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChannels: %w", err)
	}
	return oldValue.Channels, nil
}

// AppendChannels adds s to the "channels" field.
func (m *AlertRuleMutation) AppendChannels(s []string) {
	m.appendchannels = append(m.appendchannels, s...)
}

// AppendedChannels returns the list of values that were appended to the "channels" field in this mutation.
func (m *AlertRuleMutation) AppendedChannels() ([]string, bool) {
	if len(m.appendchannels) == 0 {
		return nil, false
	}
	return m.appendchannels, true
}

// ResetChannels resets all changes to the "channels" field.
func (m *AlertRuleMutation) ResetChannels() {
	m.channels = nil
	m.appendchannels = nil
}

// SetThrottle sets the "throttle" field.
func (m *AlertRuleMutation) SetThrottle(value map[string]interface{}) {
	m.throttle = &value
}

// Throttle returns the value of the "throttle" field in the mutation.
func (m *AlertRuleMutation) Throttle() (r map[string]interface{}, exists bool) {
	v := m.throttle
	if v == nil {
		return
	}
	return *v, true
}

// OldThrottle returns the old "throttle" field's value of the AlertRule entity.
// If the AlertRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertRuleMutation) OldThrottle(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldThrottle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldThrottle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldThrottle: %w", err)
	}
	return oldValue.Throttle, nil
}

// ClearThrottle clears the value of the "throttle" field.
func (m *AlertRuleMutation) ClearThrottle() {
	m.throttle = nil
	m.clearedFields[alertrule.FieldThrottle] = struct{}{}
}

// ThrottleCleared returns if the "throttle" field was cleared in this mutation.
func (m *AlertRuleMutation) ThrottleCleared() bool {
	_, ok := m.clearedFields[alertrule.FieldThrottle]
	return ok
}

// ResetThrottle resets all changes to the "throttle" field.
func (m *AlertRuleMutation) ResetThrottle() {
	m.throttle = nil
	delete(m.clearedFields, alertrule.FieldThrottle)
}

// SetQuietHours sets the "quiet_hours" field.
func (m *AlertRuleMutation) SetQuietHours(value map[string]interface{}) {
	m.quiet_hours = &value
}

// QuietHours returns the value of the "quiet_hours" field in the mutation.
func (m *AlertRuleMutation) QuietHours() (r map[string]interface{}, exists bool) {
	v := m.quiet_hours
	if v == nil {
		return
	}
	return *v, true
}

// OldQuietHours returns the old "quiet_hours" field's value of the AlertRule entity.
// If the AlertRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertRuleMutation) OldQuietHours(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQuietHours is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQuietHours requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQuietHours: %w", err)
	}
	return oldValue.QuietHours, nil
}

// ClearQuietHours clears the value of the "quiet_hours" field.
func (m *AlertRuleMutation) ClearQuietHours() {
	m.quiet_hours = nil
	m.clearedFields[alertrule.FieldQuietHours] = struct{}{}
}

// QuietHoursCleared returns if the "quiet_hours" field was cleared in this mutation.
func (m *AlertRuleMutation) QuietHoursCleared() bool {
	_, ok := m.clearedFields[alertrule.FieldQuietHours]
	return ok
}

// ResetQuietHours resets all changes to the "quiet_hours" field.
func (m *AlertRuleMutation) ResetQuietHours() {
	m.quiet_hours = nil
	delete(m.clearedFields, alertrule.FieldQuietHours)
}

// SetDeviceID sets the "device_id" field.
func (m *AlertRuleMutation) SetDeviceID(s string) {
	m.device_id = &s
}

// DeviceID returns the value of the "device_id" field in the mutation.
func (m *AlertRuleMutation) DeviceID() (r string, exists bool) {
	v := m.device_id
	if v == nil {
		return
	}
	return *v, true
}

// OldDeviceID returns the old "device_id" field's value of the AlertRule entity.
// If the AlertRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertRuleMutation) OldDeviceID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeviceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeviceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeviceID: %w", err)
	}
	return oldValue.DeviceID, nil
}

// ClearDeviceID clears the value of the "device_id" field.
func (m *AlertRuleMutation) ClearDeviceID() {
	m.device_id = nil
	m.clearedFields[alertrule.FieldDeviceID] = struct{}{}
}

// DeviceIDCleared returns if the "device_id" field was cleared in this mutation.
func (m *AlertRuleMutation) DeviceIDCleared() bool {
	_, ok := m.clearedFields[alertrule.FieldDeviceID]
	return ok
}

// ResetDeviceID resets all changes to the "device_id" field.
func (m *AlertRuleMutation) ResetDeviceID() {
	m.device_id = nil
	delete(m.clearedFields, alertrule.FieldDeviceID)
}

// SetEnabled sets the "enabled" field.
func (m *AlertRuleMutation) SetEnabled(b bool) {
	m.enabled = &b
}

// Enabled returns the value of the "enabled" field in the mutation.
func (m *AlertRuleMutation) Enabled() (r bool, exists bool) {
	v := m.enabled
	if v == nil {
		return
	}
	return *v, true
}

// OldEnabled returns the old "enabled" field's value of the AlertRule entity.
// If the AlertRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertRuleMutation) OldEnabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnabled: %w", err)
	}
	return oldValue.Enabled, nil
}

// ResetEnabled resets all changes to the "enabled" field.
func (m *AlertRuleMutation) ResetEnabled() {
	m.enabled = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *AlertRuleMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AlertRuleMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the AlertRule entity.
// If the AlertRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertRuleMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AlertRuleMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AlertRuleMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AlertRuleMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the AlertRule entity.
// If the AlertRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertRuleMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AlertRuleMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// AddAlertIDs adds the "alerts" edge to the Alert entity by ids.
func (m *AlertRuleMutation) AddAlertIDs(ids ...string) {
	if m.alerts == nil {
		m.alerts = make(map[string]struct{})
	}
	for i := range ids {
		m.alerts[ids[i]] = struct{}{}
	}
}

// ClearAlerts clears the "alerts" edge to the Alert entity.
func (m *AlertRuleMutation) ClearAlerts() {
	m.clearedalerts = true
}

// AlertsCleared reports if the "alerts" edge to the Alert entity was cleared.
func (m *AlertRuleMutation) AlertsCleared() bool {
	return m.clearedalerts
}

// RemoveAlertIDs removes the "alerts" edge to the Alert entity by IDs.
func (m *AlertRuleMutation) RemoveAlertIDs(ids ...string) {
	if m.removedalerts == nil {
		m.removedalerts = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.alerts, ids[i])
		m.removedalerts[ids[i]] = struct{}{}
	}
}

// RemovedAlerts returns the removed IDs of the "alerts" edge to the Alert entity.
func (m *AlertRuleMutation) RemovedAlertsIDs() (ids []string) {
	for id := range m.removedalerts {
		ids = append(ids, id)
	}
	return
}

// AlertsIDs returns the "alerts" edge IDs in the mutation.
func (m *AlertRuleMutation) AlertsIDs() (ids []string) {
	for id := range m.alerts {
		ids = append(ids, id)
	}
	return
}

// ResetAlerts resets all changes to the "alerts" edge.
func (m *AlertRuleMutation) ResetAlerts() {
	m.alerts = nil
	m.clearedalerts = false
	m.removedalerts = nil
}

// Where appends a list predicates to the AlertRuleMutation builder.
func (m *AlertRuleMutation) Where(ps ...predicate.AlertRule) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AlertRuleMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AlertRuleMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AlertRule, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AlertRuleMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AlertRuleMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AlertRule).
func (m *AlertRuleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AlertRuleMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.name != nil {
		fields = append(fields, alertrule.FieldName)
	}
	if m.description != nil {
		fields = append(fields, alertrule.FieldDescription)
	}
	if m.event_type != nil {
		fields = append(fields, alertrule.FieldEventType)
	}
	if m.conditions != nil {
		fields = append(fields, alertrule.FieldConditions)
	}
	if m.severity != nil {
		fields = append(fields, alertrule.FieldSeverity)
	}
	if m.channels != nil {
		fields = append(fields, alertrule.FieldChannels)
	}
	if m.throttle != nil {
		fields = append(fields, alertrule.FieldThrottle)
	}
	if m.quiet_hours != nil {
		fields = append(fields, alertrule.FieldQuietHours)
	}
	if m.device_id != nil {
		fields = append(fields, alertrule.FieldDeviceID)
	}
	if m.enabled != nil {
		fields = append(fields, alertrule.FieldEnabled)
	}
	if m.created_at != nil {
		fields = append(fields, alertrule.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, alertrule.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AlertRuleMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case alertrule.FieldName:
		return m.Name()
	case alertrule.FieldDescription:
		return m.Description()
	case alertrule.FieldEventType:
		return m.EventType()
	case alertrule.FieldConditions:
		return m.Conditions()
	case alertrule.FieldSeverity:
		return m.Severity()
	case alertrule.FieldChannels:
		return m.Channels()
	case alertrule.FieldThrottle:
		return m.Throttle()
	case alertrule.FieldQuietHours:
		return m.QuietHours()
	case alertrule.FieldDeviceID:
		return m.DeviceID()
	case alertrule.FieldEnabled:
		return m.Enabled()
	case alertrule.FieldCreatedAt:
		return m.CreatedAt()
	case alertrule.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AlertRuleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case alertrule.FieldName:
		return m.OldName(ctx)
	case alertrule.FieldDescription:
		return m.OldDescription(ctx)
	case alertrule.FieldEventType:
		return m.OldEventType(ctx)
	case alertrule.FieldConditions:
		return m.OldConditions(ctx)
	case alertrule.FieldSeverity:
		return m.OldSeverity(ctx)
	case alertrule.FieldChannels:
		return m.OldChannels(ctx)
	case alertrule.FieldThrottle:
		return m.OldThrottle(ctx)
	case alertrule.FieldQuietHours:
		return m.OldQuietHours(ctx)
	case alertrule.FieldDeviceID:
		return m.OldDeviceID(ctx)
	case alertrule.FieldEnabled:
		return m.OldEnabled(ctx)
	case alertrule.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case alertrule.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown AlertRule field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AlertRuleMutation) SetField(name string, value ent.Value) error {
	switch name {
	case alertrule.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case alertrule.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case alertrule.FieldEventType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEventType(v)
		return nil
	case alertrule.FieldConditions:
		v, ok := value.([]map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConditions(v)
		return nil
	case alertrule.FieldSeverity:
		v, ok := value.(alertrule.Severity)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSeverity(v)
		return nil
	case alertrule.FieldChannels:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChannels(v)
		return nil
	case alertrule.FieldThrottle:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetThrottle(v)
		return nil
	case alertrule.FieldQuietHours:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQuietHours(v)
		return nil
	case alertrule.FieldDeviceID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeviceID(v)
		return nil
	case alertrule.FieldEnabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnabled(v)
		return nil
	case alertrule.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case alertrule.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown AlertRule field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AlertRuleMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AlertRuleMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AlertRuleMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown AlertRule numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AlertRuleMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(alertrule.FieldDescription) {
		fields = append(fields, alertrule.FieldDescription)
	}
	if m.FieldCleared(alertrule.FieldConditions) {
		fields = append(fields, alertrule.FieldConditions)
	}
	if m.FieldCleared(alertrule.FieldThrottle) {
		fields = append(fields, alertrule.FieldThrottle)
	}
	if m.FieldCleared(alertrule.FieldQuietHours) {
		fields = append(fields, alertrule.FieldQuietHours)
	}
	if m.FieldCleared(alertrule.FieldDeviceID) {
		fields = append(fields, alertrule.FieldDeviceID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AlertRuleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AlertRuleMutation) ClearField(name string) error {
	switch name {
	case alertrule.FieldDescription:
		m.ClearDescription()
		return nil
	case alertrule.FieldConditions:
		m.ClearConditions()
		return nil
	case alertrule.FieldThrottle:
		m.ClearThrottle()
		return nil
	case alertrule.FieldQuietHours:
		m.ClearQuietHours()
		return nil
	case alertrule.FieldDeviceID:
		m.ClearDeviceID()
		return nil
	}
	return fmt.Errorf("unknown AlertRule nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AlertRuleMutation) ResetField(name string) error {
	switch name {
	case alertrule.FieldName:
		m.ResetName()
		return nil
	case alertrule.FieldDescription:
		m.ResetDescription()
		return nil
	case alertrule.FieldEventType:
		m.ResetEventType()
		return nil
	case alertrule.FieldConditions:
		m.ResetConditions()
		return nil
	case alertrule.FieldSeverity:
		m.ResetSeverity()
		return nil
	case alertrule.FieldChannels:
		m.ResetChannels()
		return nil
	case alertrule.FieldThrottle:
		m.ResetThrottle()
		return nil
	case alertrule.FieldQuietHours:
		m.ResetQuietHours()
		return nil
	case alertrule.FieldDeviceID:
		m.ResetDeviceID()
		return nil
	case alertrule.FieldEnabled:
		m.ResetEnabled()
		return nil
	case alertrule.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case alertrule.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown AlertRule field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AlertRuleMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.alerts != nil {
		edges = append(edges, alertrule.EdgeAlerts)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AlertRuleMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case alertrule.EdgeAlerts:
		ids := make([]ent.Value, 0, len(m.alerts))
		for id := range m.alerts {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AlertRuleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedalerts != nil {
		edges = append(edges, alertrule.EdgeAlerts)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AlertRuleMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case alertrule.EdgeAlerts:
		ids := make([]ent.Value, 0, len(m.removedalerts))
		for id := range m.removedalerts {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AlertRuleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedalerts {
		edges = append(edges, alertrule.EdgeAlerts)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AlertRuleMutation) EdgeCleared(name string) bool {
	switch name {
	case alertrule.EdgeAlerts:
		return m.clearedalerts
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AlertRuleMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown AlertRule unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AlertRuleMutation) ResetEdge(name string) error {
	switch name {
	case alertrule.EdgeAlerts:
		m.ResetAlerts()
		return nil
	}
	return fmt.Errorf("unknown AlertRule edge %s", name)
}

// ConfigSnapshotMutation represents an operation that mutates the ConfigSnapshot nodes in the graph.
type ConfigSnapshotMutation struct {
	config
	op              Op
	typ             string
	id              *string
	name            *string
	description     *string
	snapshot_type   *configsnapshot.SnapshotType
	configuration   *map[string]interface{}
	resource_counts *map[string]int
	ros_version     *string
	router_model    *string
	checksum        *string
	size_bytes      *int64
	addsize_bytes   *int64
	tags            *[]string
	appendtags      []string
	pinned          *bool
	created_by      *string
	created_at      *time.Time
	expires_at      *time.Time
	clearedFields   map[string]struct{}
	done            bool
	oldValue        func(context.Context) (*ConfigSnapshot, error)
	predicates      []predicate.ConfigSnapshot
}

var _ ent.Mutation = (*ConfigSnapshotMutation)(nil)

// configsnapshotOption allows management of the mutation configuration using functional options.
type configsnapshotOption func(*ConfigSnapshotMutation)

// newConfigSnapshotMutation creates new mutation for the ConfigSnapshot entity.
func newConfigSnapshotMutation(c config, op Op, opts ...configsnapshotOption) *ConfigSnapshotMutation {
	m := &ConfigSnapshotMutation{
		config:        c,
		op:            op,
		typ:           TypeConfigSnapshot,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withConfigSnapshotID sets the ID field of the mutation.
func withConfigSnapshotID(id string) configsnapshotOption {
	return func(m *ConfigSnapshotMutation) {
		var (
			err   error
			once  sync.Once
			value *ConfigSnapshot
		)
		m.oldValue = func(ctx context.Context) (*ConfigSnapshot, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ConfigSnapshot.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withConfigSnapshot sets the old ConfigSnapshot of the mutation.
func withConfigSnapshot(node *ConfigSnapshot) configsnapshotOption {
	return func(m *ConfigSnapshotMutation) {
		m.oldValue = func(context.Context) (*ConfigSnapshot, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ConfigSnapshotMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ConfigSnapshotMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ConfigSnapshot entities.
func (m *ConfigSnapshotMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ConfigSnapshotMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ConfigSnapshotMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ConfigSnapshot.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *ConfigSnapshotMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ConfigSnapshotMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the ConfigSnapshot entity.
// If the ConfigSnapshot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConfigSnapshotMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ConfigSnapshotMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *ConfigSnapshotMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ConfigSnapshotMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the ConfigSnapshot entity.
// If the ConfigSnapshot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConfigSnapshotMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *ConfigSnapshotMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[configsnapshot.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *ConfigSnapshotMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[configsnapshot.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *ConfigSnapshotMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, configsnapshot.FieldDescription)
}

// SetSnapshotType sets the "snapshot_type" field.
func (m *ConfigSnapshotMutation) SetSnapshotType(ct configsnapshot.SnapshotType) {
	m.snapshot_type = &ct
}

// SnapshotType returns the value of the "snapshot_type" field in the mutation.
func (m *ConfigSnapshotMutation) SnapshotType() (r configsnapshot.SnapshotType, exists bool) {
	v := m.snapshot_type
	if v == nil {
		return
	}
	return *v, true
}

// OldSnapshotType returns the old "snapshot_type" field's value of the ConfigSnapshot entity.
// If the ConfigSnapshot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConfigSnapshotMutation) OldSnapshotType(ctx context.Context) (v configsnapshot.SnapshotType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSnapshotType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSnapshotType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSnapshotType: %w", err)
	}
	return oldValue.SnapshotType, nil
}

// ResetSnapshotType resets all changes to the "snapshot_type" field.
func (m *ConfigSnapshotMutation) ResetSnapshotType() {
	m.snapshot_type = nil
}

// SetConfiguration sets the "configuration" field.
func (m *ConfigSnapshotMutation) SetConfiguration(value map[string]interface{}) {
	m.configuration = &value
}

// Configuration returns the value of the "configuration" field in the mutation.
func (m *ConfigSnapshotMutation) Configuration() (r map[string]interface{}, exists bool) {
	v := m.configuration
	if v == nil {
		return
	}
	return *v, true
}

// OldConfiguration returns the old "configuration" field's value of the ConfigSnapshot entity.
// If the ConfigSnapshot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConfigSnapshotMutation) OldConfiguration(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConfiguration is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConfiguration requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConfiguration: %w", err)
	}
	return oldValue.Configuration, nil
}

// ResetConfiguration resets all changes to the "configuration" field.
func (m *ConfigSnapshotMutation) ResetConfiguration() {
	m.configuration = nil
}

// SetResourceCounts sets the "resource_counts" field.
func (m *ConfigSnapshotMutation) SetResourceCounts(value map[string]int) {
	m.resource_counts = &value
}

// ResourceCounts returns the value of the "resource_counts" field in the mutation.
func (m *ConfigSnapshotMutation) ResourceCounts() (r map[string]int, exists bool) {
	v := m.resource_counts
	if v == nil {
		return
	}
	return *v, true
}

// OldResourceCounts returns the old "resource_counts" field's value of the ConfigSnapshot entity.
// If the ConfigSnapshot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConfigSnapshotMutation) OldResourceCounts(ctx context.Context) (v map[string]int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResourceCounts is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResourceCounts requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResourceCounts: %w", err)
	}
	return oldValue.ResourceCounts, nil
}

// ClearResourceCounts clears the value of the "resource_counts" field.
func (m *ConfigSnapshotMutation) ClearResourceCounts() {
	m.resource_counts = nil
	m.clearedFields[configsnapshot.FieldResourceCounts] = struct{}{}
}

// ResourceCountsCleared returns if the "resource_counts" field was cleared in this mutation.
func (m *ConfigSnapshotMutation) ResourceCountsCleared() bool {
	_, ok := m.clearedFields[configsnapshot.FieldResourceCounts]
	return ok
}

// ResetResourceCounts resets all changes to the "resource_counts" field.
func (m *ConfigSnapshotMutation) ResetResourceCounts() {
	m.resource_counts = nil
	delete(m.clearedFields, configsnapshot.FieldResourceCounts)
}

// SetRosVersion sets the "ros_version" field.
func (m *ConfigSnapshotMutation) SetRosVersion(s string) {
	m.ros_version = &s
}

// RosVersion returns the value of the "ros_version" field in the mutation.
func (m *ConfigSnapshotMutation) RosVersion() (r string, exists bool) {
	v := m.ros_version
	if v == nil {
		return
	}
	return *v, true
}

// OldRosVersion returns the old "ros_version" field's value of the ConfigSnapshot entity.
// If the ConfigSnapshot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConfigSnapshotMutation) OldRosVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRosVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRosVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRosVersion: %w", err)
	}
	return oldValue.RosVersion, nil
}

// ClearRosVersion clears the value of the "ros_version" field.
func (m *ConfigSnapshotMutation) ClearRosVersion() {
	m.ros_version = nil
	m.clearedFields[configsnapshot.FieldRosVersion] = struct{}{}
}

// RosVersionCleared returns if the "ros_version" field was cleared in this mutation.
func (m *ConfigSnapshotMutation) RosVersionCleared() bool {
	_, ok := m.clearedFields[configsnapshot.FieldRosVersion]
	return ok
}

// ResetRosVersion resets all changes to the "ros_version" field.
func (m *ConfigSnapshotMutation) ResetRosVersion() {
	m.ros_version = nil
	delete(m.clearedFields, configsnapshot.FieldRosVersion)
}

// SetRouterModel sets the "router_model" field.
func (m *ConfigSnapshotMutation) SetRouterModel(s string) {
	m.router_model = &s
}

// RouterModel returns the value of the "router_model" field in the mutation.
func (m *ConfigSnapshotMutation) RouterModel() (r string, exists bool) {
	v := m.router_model
	if v == nil {
		return
	}
	return *v, true
}

// OldRouterModel returns the old "router_model" field's value of the ConfigSnapshot entity.
// If the ConfigSnapshot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConfigSnapshotMutation) OldRouterModel(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRouterModel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRouterModel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRouterModel: %w", err)
	}
	return oldValue.RouterModel, nil
}

// ClearRouterModel clears the value of the "router_model" field.
func (m *ConfigSnapshotMutation) ClearRouterModel() {
	m.router_model = nil
	m.clearedFields[configsnapshot.FieldRouterModel] = struct{}{}
}

// RouterModelCleared returns if the "router_model" field was cleared in this mutation.
func (m *ConfigSnapshotMutation) RouterModelCleared() bool {
	_, ok := m.clearedFields[configsnapshot.FieldRouterModel]
	return ok
}

// ResetRouterModel resets all changes to the "router_model" field.
func (m *ConfigSnapshotMutation) ResetRouterModel() {
	m.router_model = nil
	delete(m.clearedFields, configsnapshot.FieldRouterModel)
}

// SetChecksum sets the "checksum" field.
func (m *ConfigSnapshotMutation) SetChecksum(s string) {
	m.checksum = &s
}

// Checksum returns the value of the "checksum" field in the mutation.
func (m *ConfigSnapshotMutation) Checksum() (r string, exists bool) {
	v := m.checksum
	if v == nil {
		return
	}
	return *v, true
}

// OldChecksum returns the old "checksum" field's value of the ConfigSnapshot entity.
// If the ConfigSnapshot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConfigSnapshotMutation) OldChecksum(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChecksum is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChecksum requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChecksum: %w", err)
	}
	return oldValue.Checksum, nil
}

// ClearChecksum clears the value of the "checksum" field.
func (m *ConfigSnapshotMutation) ClearChecksum() {
	m.checksum = nil
	m.clearedFields[configsnapshot.FieldChecksum] = struct{}{}
}

// ChecksumCleared returns if the "checksum" field was cleared in this mutation.
func (m *ConfigSnapshotMutation) ChecksumCleared() bool {
	_, ok := m.clearedFields[configsnapshot.FieldChecksum]
	return ok
}

// ResetChecksum resets all changes to the "checksum" field.
func (m *ConfigSnapshotMutation) ResetChecksum() {
	m.checksum = nil
	delete(m.clearedFields, configsnapshot.FieldChecksum)
}

// SetSizeBytes sets the "size_bytes" field.
func (m *ConfigSnapshotMutation) SetSizeBytes(i int64) {
	m.size_bytes = &i
	m.addsize_bytes = nil
}

// SizeBytes returns the value of the "size_bytes" field in the mutation.
func (m *ConfigSnapshotMutation) SizeBytes() (r int64, exists bool) {
	v := m.size_bytes
	if v == nil {
		return
	}
	return *v, true
}

// OldSizeBytes returns the old "size_bytes" field's value of the ConfigSnapshot entity.
// If the ConfigSnapshot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConfigSnapshotMutation) OldSizeBytes(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSizeBytes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSizeBytes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSizeBytes: %w", err)
	}
	return oldValue.SizeBytes, nil
}

// AddSizeBytes adds i to the "size_bytes" field.
func (m *ConfigSnapshotMutation) AddSizeBytes(i int64) {
	if m.addsize_bytes != nil {
		*m.addsize_bytes += i
	} else {
		m.addsize_bytes = &i
	}
}

// AddedSizeBytes returns the value that was added to the "size_bytes" field in this mutation.
func (m *ConfigSnapshotMutation) AddedSizeBytes() (r int64, exists bool) {
	v := m.addsize_bytes
	if v == nil {
		return
	}
	return *v, true
}

// ClearSizeBytes clears the value of the "size_bytes" field.
func (m *ConfigSnapshotMutation) ClearSizeBytes() {
	m.size_bytes = nil
	m.addsize_bytes = nil
	m.clearedFields[configsnapshot.FieldSizeBytes] = struct{}{}
}

// SizeBytesCleared returns if the "size_bytes" field was cleared in this mutation.
func (m *ConfigSnapshotMutation) SizeBytesCleared() bool {
	_, ok := m.clearedFields[configsnapshot.FieldSizeBytes]
	return ok
}

// ResetSizeBytes resets all changes to the "size_bytes" field.
func (m *ConfigSnapshotMutation) ResetSizeBytes() {
	m.size_bytes = nil
	m.addsize_bytes = nil
	delete(m.clearedFields, configsnapshot.FieldSizeBytes)
}

// SetTags sets the "tags" field.
func (m *ConfigSnapshotMutation) SetTags(s []string) {
	m.tags = &s
	m.appendtags = nil
}

// Tags returns the value of the "tags" field in the mutation.
func (m *ConfigSnapshotMutation) Tags() (r []string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the ConfigSnapshot entity.
// If the ConfigSnapshot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConfigSnapshotMutation) OldTags(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// AppendTags adds s to the "tags" field.
func (m *ConfigSnapshotMutation) AppendTags(s []string) {
	m.appendtags = append(m.appendtags, s...)
}

// AppendedTags returns the list of values that were appended to the "tags" field in this mutation.
func (m *ConfigSnapshotMutation) AppendedTags() ([]string, bool) {
	if len(m.appendtags) == 0 {
		return nil, false
	}
	return m.appendtags, true
}

// ClearTags clears the value of the "tags" field.
func (m *ConfigSnapshotMutation) ClearTags() {
	m.tags = nil
	m.appendtags = nil
	m.clearedFields[configsnapshot.FieldTags] = struct{}{}
}

// TagsCleared returns if the "tags" field was cleared in this mutation.
func (m *ConfigSnapshotMutation) TagsCleared() bool {
	_, ok := m.clearedFields[configsnapshot.FieldTags]
	return ok
}

// ResetTags resets all changes to the "tags" field.
func (m *ConfigSnapshotMutation) ResetTags() {
	m.tags = nil
	m.appendtags = nil
	delete(m.clearedFields, configsnapshot.FieldTags)
}

// SetPinned sets the "pinned" field.
func (m *ConfigSnapshotMutation) SetPinned(b bool) {
	m.pinned = &b
}

// Pinned returns the value of the "pinned" field in the mutation.
func (m *ConfigSnapshotMutation) Pinned() (r bool, exists bool) {
	v := m.pinned
	if v == nil {
		return
	}
	return *v, true
}

// OldPinned returns the old "pinned" field's value of the ConfigSnapshot entity.
// If the ConfigSnapshot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConfigSnapshotMutation) OldPinned(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPinned is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPinned requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPinned: %w", err)
	}
	return oldValue.Pinned, nil
}

// ResetPinned resets all changes to the "pinned" field.
func (m *ConfigSnapshotMutation) ResetPinned() {
	m.pinned = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *ConfigSnapshotMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *ConfigSnapshotMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the ConfigSnapshot entity.
// If the ConfigSnapshot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConfigSnapshotMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *ConfigSnapshotMutation) ResetCreatedBy() {
	m.created_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ConfigSnapshotMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ConfigSnapshotMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ConfigSnapshot entity.
// If the ConfigSnapshot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConfigSnapshotMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ConfigSnapshotMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetExpiresAt sets the "expires_at" field.
func (m *ConfigSnapshotMutation) SetExpiresAt(t time.Time) {
	m.expires_at = &t
}

// ExpiresAt returns the value of the "expires_at" field in the mutation.
func (m *ConfigSnapshotMutation) ExpiresAt() (r time.Time, exists bool) {
	v := m.expires_at
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiresAt returns the old "expires_at" field's value of the ConfigSnapshot entity.
// If the ConfigSnapshot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConfigSnapshotMutation) OldExpiresAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiresAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiresAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiresAt: %w", err)
	}
	return oldValue.ExpiresAt, nil
}

// ClearExpiresAt clears the value of the "expires_at" field.
func (m *ConfigSnapshotMutation) ClearExpiresAt() {
	m.expires_at = nil
	m.clearedFields[configsnapshot.FieldExpiresAt] = struct{}{}
}

// ExpiresAtCleared returns if the "expires_at" field was cleared in this mutation.
func (m *ConfigSnapshotMutation) ExpiresAtCleared() bool {
	_, ok := m.clearedFields[configsnapshot.FieldExpiresAt]
	return ok
}

// ResetExpiresAt resets all changes to the "expires_at" field.
func (m *ConfigSnapshotMutation) ResetExpiresAt() {
	m.expires_at = nil
	delete(m.clearedFields, configsnapshot.FieldExpiresAt)
}

// Where appends a list predicates to the ConfigSnapshotMutation builder.
func (m *ConfigSnapshotMutation) Where(ps ...predicate.ConfigSnapshot) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ConfigSnapshotMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ConfigSnapshotMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ConfigSnapshot, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ConfigSnapshotMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ConfigSnapshotMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ConfigSnapshot).
func (m *ConfigSnapshotMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ConfigSnapshotMutation) Fields() []string {
	fields := make([]string, 0, 14)
	if m.name != nil {
		fields = append(fields, configsnapshot.FieldName)
	}
	if m.description != nil {
		fields = append(fields, configsnapshot.FieldDescription)
	}
	if m.snapshot_type != nil {
		fields = append(fields, configsnapshot.FieldSnapshotType)
	}
	if m.configuration != nil {
		fields = append(fields, configsnapshot.FieldConfiguration)
	}
	if m.resource_counts != nil {
		fields = append(fields, configsnapshot.FieldResourceCounts)
	}
	if m.ros_version != nil {
		fields = append(fields, configsnapshot.FieldRosVersion)
	}
	if m.router_model != nil {
		fields = append(fields, configsnapshot.FieldRouterModel)
	}
	if m.checksum != nil {
		fields = append(fields, configsnapshot.FieldChecksum)
	}
	if m.size_bytes != nil {
		fields = append(fields, configsnapshot.FieldSizeBytes)
	}
	if m.tags != nil {
		fields = append(fields, configsnapshot.FieldTags)
	}
	if m.pinned != nil {
		fields = append(fields, configsnapshot.FieldPinned)
	}
	if m.created_by != nil {
		fields = append(fields, configsnapshot.FieldCreatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, configsnapshot.FieldCreatedAt)
	}
	if m.expires_at != nil {
		fields = append(fields, configsnapshot.FieldExpiresAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ConfigSnapshotMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case configsnapshot.FieldName:
		return m.Name()
	case configsnapshot.FieldDescription:
		return m.Description()
	case configsnapshot.FieldSnapshotType:
		return m.SnapshotType()
	case configsnapshot.FieldConfiguration:
		return m.Configuration()
	case configsnapshot.FieldResourceCounts:
		return m.ResourceCounts()
	case configsnapshot.FieldRosVersion:
		return m.RosVersion()
	case configsnapshot.FieldRouterModel:
		return m.RouterModel()
	case configsnapshot.FieldChecksum:
		return m.Checksum()
	case configsnapshot.FieldSizeBytes:
		return m.SizeBytes()
	case configsnapshot.FieldTags:
		return m.Tags()
	case configsnapshot.FieldPinned:
		return m.Pinned()
	case configsnapshot.FieldCreatedBy:
		return m.CreatedBy()
	case configsnapshot.FieldCreatedAt:
		return m.CreatedAt()
	case configsnapshot.FieldExpiresAt:
		return m.ExpiresAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ConfigSnapshotMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case configsnapshot.FieldName:
		return m.OldName(ctx)
	case configsnapshot.FieldDescription:
		return m.OldDescription(ctx)
	case configsnapshot.FieldSnapshotType:
		return m.OldSnapshotType(ctx)
	case configsnapshot.FieldConfiguration:
		return m.OldConfiguration(ctx)
	case configsnapshot.FieldResourceCounts:
		return m.OldResourceCounts(ctx)
	case configsnapshot.FieldRosVersion:
		return m.OldRosVersion(ctx)
	case configsnapshot.FieldRouterModel:
		return m.OldRouterModel(ctx)
	case configsnapshot.FieldChecksum:
		return m.OldChecksum(ctx)
	case configsnapshot.FieldSizeBytes:
		return m.OldSizeBytes(ctx)
	case configsnapshot.FieldTags:
		return m.OldTags(ctx)
	case configsnapshot.FieldPinned:
		return m.OldPinned(ctx)
	case configsnapshot.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case configsnapshot.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case configsnapshot.FieldExpiresAt:
		return m.OldExpiresAt(ctx)
	}
	return nil, fmt.Errorf("unknown ConfigSnapshot field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ConfigSnapshotMutation) SetField(name string, value ent.Value) error {
	switch name {
	case configsnapshot.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case configsnapshot.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case configsnapshot.FieldSnapshotType:
		v, ok := value.(configsnapshot.SnapshotType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSnapshotType(v)
		return nil
	case configsnapshot.FieldConfiguration:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConfiguration(v)
		return nil
	case configsnapshot.FieldResourceCounts:
		v, ok := value.(map[string]int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResourceCounts(v)
		return nil
	case configsnapshot.FieldRosVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRosVersion(v)
		return nil
	case configsnapshot.FieldRouterModel:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRouterModel(v)
		return nil
	case configsnapshot.FieldChecksum:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChecksum(v)
		return nil
	case configsnapshot.FieldSizeBytes:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSizeBytes(v)
		return nil
	case configsnapshot.FieldTags:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	case configsnapshot.FieldPinned:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPinned(v)
		return nil
	case configsnapshot.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case configsnapshot.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case configsnapshot.FieldExpiresAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiresAt(v)
		return nil
	}
	return fmt.Errorf("unknown ConfigSnapshot field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ConfigSnapshotMutation) AddedFields() []string {
	var fields []string
	if m.addsize_bytes != nil {
		fields = append(fields, configsnapshot.FieldSizeBytes)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ConfigSnapshotMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case configsnapshot.FieldSizeBytes:
		return m.AddedSizeBytes()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ConfigSnapshotMutation) AddField(name string, value ent.Value) error {
	switch name {
	case configsnapshot.FieldSizeBytes:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSizeBytes(v)
		return nil
	}
	return fmt.Errorf("unknown ConfigSnapshot numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ConfigSnapshotMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(configsnapshot.FieldDescription) {
		fields = append(fields, configsnapshot.FieldDescription)
	}
	if m.FieldCleared(configsnapshot.FieldResourceCounts) {
		fields = append(fields, configsnapshot.FieldResourceCounts)
	}
	if m.FieldCleared(configsnapshot.FieldRosVersion) {
		fields = append(fields, configsnapshot.FieldRosVersion)
	}
	if m.FieldCleared(configsnapshot.FieldRouterModel) {
		fields = append(fields, configsnapshot.FieldRouterModel)
	}
	if m.FieldCleared(configsnapshot.FieldChecksum) {
		fields = append(fields, configsnapshot.FieldChecksum)
	}
	if m.FieldCleared(configsnapshot.FieldSizeBytes) {
		fields = append(fields, configsnapshot.FieldSizeBytes)
	}
	if m.FieldCleared(configsnapshot.FieldTags) {
		fields = append(fields, configsnapshot.FieldTags)
	}
	if m.FieldCleared(configsnapshot.FieldExpiresAt) {
		fields = append(fields, configsnapshot.FieldExpiresAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ConfigSnapshotMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ConfigSnapshotMutation) ClearField(name string) error {
	switch name {
	case configsnapshot.FieldDescription:
		m.ClearDescription()
		return nil
	case configsnapshot.FieldResourceCounts:
		m.ClearResourceCounts()
		return nil
	case configsnapshot.FieldRosVersion:
		m.ClearRosVersion()
		return nil
	case configsnapshot.FieldRouterModel:
		m.ClearRouterModel()
		return nil
	case configsnapshot.FieldChecksum:
		m.ClearChecksum()
		return nil
	case configsnapshot.FieldSizeBytes:
		m.ClearSizeBytes()
		return nil
	case configsnapshot.FieldTags:
		m.ClearTags()
		return nil
	case configsnapshot.FieldExpiresAt:
		m.ClearExpiresAt()
		return nil
	}
	return fmt.Errorf("unknown ConfigSnapshot nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ConfigSnapshotMutation) ResetField(name string) error {
	switch name {
	case configsnapshot.FieldName:
		m.ResetName()
		return nil
	case configsnapshot.FieldDescription:
		m.ResetDescription()
		return nil
	case configsnapshot.FieldSnapshotType:
		m.ResetSnapshotType()
		return nil
	case configsnapshot.FieldConfiguration:
		m.ResetConfiguration()
		return nil
	case configsnapshot.FieldResourceCounts:
		m.ResetResourceCounts()
		return nil
	case configsnapshot.FieldRosVersion:
		m.ResetRosVersion()
		return nil
	case configsnapshot.FieldRouterModel:
		m.ResetRouterModel()
		return nil
	case configsnapshot.FieldChecksum:
		m.ResetChecksum()
		return nil
	case configsnapshot.FieldSizeBytes:
		m.ResetSizeBytes()
		return nil
	case configsnapshot.FieldTags:
		m.ResetTags()
		return nil
	case configsnapshot.FieldPinned:
		m.ResetPinned()
		return nil
	case configsnapshot.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case configsnapshot.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case configsnapshot.FieldExpiresAt:
		m.ResetExpiresAt()
		return nil
	}
	return fmt.Errorf("unknown ConfigSnapshot field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ConfigSnapshotMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ConfigSnapshotMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ConfigSnapshotMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ConfigSnapshotMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ConfigSnapshotMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ConfigSnapshotMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ConfigSnapshotMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown ConfigSnapshot unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ConfigSnapshotMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown ConfigSnapshot edge %s", name)
}

// GlobalSettingsMutation represents an operation that mutates the GlobalSettings nodes in the graph.
type GlobalSettingsMutation struct {
	config
	op               Op
	typ              string
	id               *string
	namespace        *string
	key              *string
	value            *map[string]interface{}
	value_type       *globalsettings.ValueType
	description      *string
	editable         *bool
	requires_restart *bool
	sensitive        *bool
	created_at       *time.Time
	updated_at       *time.Time
	clearedFields    map[string]struct{}
	done             bool
	oldValue         func(context.Context) (*GlobalSettings, error)
	predicates       []predicate.GlobalSettings
}

var _ ent.Mutation = (*GlobalSettingsMutation)(nil)

// globalsettingsOption allows management of the mutation configuration using functional options.
type globalsettingsOption func(*GlobalSettingsMutation)

// newGlobalSettingsMutation creates new mutation for the GlobalSettings entity.
func newGlobalSettingsMutation(c config, op Op, opts ...globalsettingsOption) *GlobalSettingsMutation {
	m := &GlobalSettingsMutation{
		config:        c,
		op:            op,
		typ:           TypeGlobalSettings,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withGlobalSettingsID sets the ID field of the mutation.
func withGlobalSettingsID(id string) globalsettingsOption {
	return func(m *GlobalSettingsMutation) {
		var (
			err   error
			once  sync.Once
			value *GlobalSettings
		)
		m.oldValue = func(ctx context.Context) (*GlobalSettings, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().GlobalSettings.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withGlobalSettings sets the old GlobalSettings of the mutation.
func withGlobalSettings(node *GlobalSettings) globalsettingsOption {
	return func(m *GlobalSettingsMutation) {
		m.oldValue = func(context.Context) (*GlobalSettings, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m GlobalSettingsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m GlobalSettingsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of GlobalSettings entities.
func (m *GlobalSettingsMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *GlobalSettingsMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *GlobalSettingsMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().GlobalSettings.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetNamespace sets the "namespace" field.
func (m *GlobalSettingsMutation) SetNamespace(s string) {
	m.namespace = &s
}

// Namespace returns the value of the "namespace" field in the mutation.
func (m *GlobalSettingsMutation) Namespace() (r string, exists bool) {
	v := m.namespace
	if v == nil {
		return
	}
	return *v, true
}

// OldNamespace returns the old "namespace" field's value of the GlobalSettings entity.
// If the GlobalSettings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GlobalSettingsMutation) OldNamespace(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNamespace is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNamespace requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNamespace: %w", err)
	}
	return oldValue.Namespace, nil
}

// ResetNamespace resets all changes to the "namespace" field.
func (m *GlobalSettingsMutation) ResetNamespace() {
	m.namespace = nil
}

// SetKey sets the "key" field.
func (m *GlobalSettingsMutation) SetKey(s string) {
	m.key = &s
}

// Key returns the value of the "key" field in the mutation.
func (m *GlobalSettingsMutation) Key() (r string, exists bool) {
	v := m.key
	if v == nil {
		return
	}
	return *v, true
}

// OldKey returns the old "key" field's value of the GlobalSettings entity.
// If the GlobalSettings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GlobalSettingsMutation) OldKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKey: %w", err)
	}
	return oldValue.Key, nil
}

// ResetKey resets all changes to the "key" field.
func (m *GlobalSettingsMutation) ResetKey() {
	m.key = nil
}

// SetValue sets the "value" field.
func (m *GlobalSettingsMutation) SetValue(value map[string]interface{}) {
	m.value = &value
}

// Value returns the value of the "value" field in the mutation.
func (m *GlobalSettingsMutation) Value() (r map[string]interface{}, exists bool) {
	v := m.value
	if v == nil {
		return
	}
	return *v, true
}

// OldValue returns the old "value" field's value of the GlobalSettings entity.
// If the GlobalSettings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GlobalSettingsMutation) OldValue(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValue: %w", err)
	}
	return oldValue.Value, nil
}

// ResetValue resets all changes to the "value" field.
func (m *GlobalSettingsMutation) ResetValue() {
	m.value = nil
}

// SetValueType sets the "value_type" field.
func (m *GlobalSettingsMutation) SetValueType(gt globalsettings.ValueType) {
	m.value_type = &gt
}

// ValueType returns the value of the "value_type" field in the mutation.
func (m *GlobalSettingsMutation) ValueType() (r globalsettings.ValueType, exists bool) {
	v := m.value_type
	if v == nil {
		return
	}
	return *v, true
}

// OldValueType returns the old "value_type" field's value of the GlobalSettings entity.
// If the GlobalSettings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GlobalSettingsMutation) OldValueType(ctx context.Context) (v globalsettings.ValueType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValueType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValueType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValueType: %w", err)
	}
	return oldValue.ValueType, nil
}

// ResetValueType resets all changes to the "value_type" field.
func (m *GlobalSettingsMutation) ResetValueType() {
	m.value_type = nil
}

// SetDescription sets the "description" field.
func (m *GlobalSettingsMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *GlobalSettingsMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the GlobalSettings entity.
// If the GlobalSettings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GlobalSettingsMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *GlobalSettingsMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[globalsettings.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *GlobalSettingsMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[globalsettings.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *GlobalSettingsMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, globalsettings.FieldDescription)
}

// SetEditable sets the "editable" field.
func (m *GlobalSettingsMutation) SetEditable(b bool) {
	m.editable = &b
}

// Editable returns the value of the "editable" field in the mutation.
func (m *GlobalSettingsMutation) Editable() (r bool, exists bool) {
	v := m.editable
	if v == nil {
		return
	}
	return *v, true
}

// OldEditable returns the old "editable" field's value of the GlobalSettings entity.
// If the GlobalSettings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GlobalSettingsMutation) OldEditable(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEditable is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEditable requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEditable: %w", err)
	}
	return oldValue.Editable, nil
}

// ResetEditable resets all changes to the "editable" field.
func (m *GlobalSettingsMutation) ResetEditable() {
	m.editable = nil
}

// SetRequiresRestart sets the "requires_restart" field.
func (m *GlobalSettingsMutation) SetRequiresRestart(b bool) {
	m.requires_restart = &b
}

// RequiresRestart returns the value of the "requires_restart" field in the mutation.
func (m *GlobalSettingsMutation) RequiresRestart() (r bool, exists bool) {
	v := m.requires_restart
	if v == nil {
		return
	}
	return *v, true
}

// OldRequiresRestart returns the old "requires_restart" field's value of the GlobalSettings entity.
// If the GlobalSettings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GlobalSettingsMutation) OldRequiresRestart(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRequiresRestart is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRequiresRestart requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRequiresRestart: %w", err)
	}
	return oldValue.RequiresRestart, nil
}

// ResetRequiresRestart resets all changes to the "requires_restart" field.
func (m *GlobalSettingsMutation) ResetRequiresRestart() {
	m.requires_restart = nil
}

// SetSensitive sets the "sensitive" field.
func (m *GlobalSettingsMutation) SetSensitive(b bool) {
	m.sensitive = &b
}

// Sensitive returns the value of the "sensitive" field in the mutation.
func (m *GlobalSettingsMutation) Sensitive() (r bool, exists bool) {
	v := m.sensitive
	if v == nil {
		return
	}
	return *v, true
}

// OldSensitive returns the old "sensitive" field's value of the GlobalSettings entity.
// If the GlobalSettings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GlobalSettingsMutation) OldSensitive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSensitive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSensitive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSensitive: %w", err)
	}
	return oldValue.Sensitive, nil
}

// ResetSensitive resets all changes to the "sensitive" field.
func (m *GlobalSettingsMutation) ResetSensitive() {
	m.sensitive = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *GlobalSettingsMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *GlobalSettingsMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the GlobalSettings entity.
// If the GlobalSettings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GlobalSettingsMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *GlobalSettingsMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *GlobalSettingsMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *GlobalSettingsMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the GlobalSettings entity.
// If the GlobalSettings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GlobalSettingsMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *GlobalSettingsMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// Where appends a list predicates to the GlobalSettingsMutation builder.
func (m *GlobalSettingsMutation) Where(ps ...predicate.GlobalSettings) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the GlobalSettingsMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *GlobalSettingsMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.GlobalSettings, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *GlobalSettingsMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *GlobalSettingsMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (GlobalSettings).
func (m *GlobalSettingsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *GlobalSettingsMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.namespace != nil {
		fields = append(fields, globalsettings.FieldNamespace)
	}
	if m.key != nil {
		fields = append(fields, globalsettings.FieldKey)
	}
	if m.value != nil {
		fields = append(fields, globalsettings.FieldValue)
	}
	if m.value_type != nil {
		fields = append(fields, globalsettings.FieldValueType)
	}
	if m.description != nil {
		fields = append(fields, globalsettings.FieldDescription)
	}
	if m.editable != nil {
		fields = append(fields, globalsettings.FieldEditable)
	}
	if m.requires_restart != nil {
		fields = append(fields, globalsettings.FieldRequiresRestart)
	}
	if m.sensitive != nil {
		fields = append(fields, globalsettings.FieldSensitive)
	}
	if m.created_at != nil {
		fields = append(fields, globalsettings.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, globalsettings.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *GlobalSettingsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case globalsettings.FieldNamespace:
		return m.Namespace()
	case globalsettings.FieldKey:
		return m.Key()
	case globalsettings.FieldValue:
		return m.Value()
	case globalsettings.FieldValueType:
		return m.ValueType()
	case globalsettings.FieldDescription:
		return m.Description()
	case globalsettings.FieldEditable:
		return m.Editable()
	case globalsettings.FieldRequiresRestart:
		return m.RequiresRestart()
	case globalsettings.FieldSensitive:
		return m.Sensitive()
	case globalsettings.FieldCreatedAt:
		return m.CreatedAt()
	case globalsettings.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *GlobalSettingsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case globalsettings.FieldNamespace:
		return m.OldNamespace(ctx)
	case globalsettings.FieldKey:
		return m.OldKey(ctx)
	case globalsettings.FieldValue:
		return m.OldValue(ctx)
	case globalsettings.FieldValueType:
		return m.OldValueType(ctx)
	case globalsettings.FieldDescription:
		return m.OldDescription(ctx)
	case globalsettings.FieldEditable:
		return m.OldEditable(ctx)
	case globalsettings.FieldRequiresRestart:
		return m.OldRequiresRestart(ctx)
	case globalsettings.FieldSensitive:
		return m.OldSensitive(ctx)
	case globalsettings.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case globalsettings.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown GlobalSettings field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GlobalSettingsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case globalsettings.FieldNamespace:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNamespace(v)
		return nil
	case globalsettings.FieldKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKey(v)
		return nil
	case globalsettings.FieldValue:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValue(v)
		return nil
	case globalsettings.FieldValueType:
		v, ok := value.(globalsettings.ValueType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValueType(v)
		return nil
	case globalsettings.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case globalsettings.FieldEditable:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEditable(v)
		return nil
	case globalsettings.FieldRequiresRestart:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRequiresRestart(v)
		return nil
	case globalsettings.FieldSensitive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSensitive(v)
		return nil
	case globalsettings.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case globalsettings.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown GlobalSettings field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *GlobalSettingsMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *GlobalSettingsMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GlobalSettingsMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown GlobalSettings numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *GlobalSettingsMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(globalsettings.FieldDescription) {
		fields = append(fields, globalsettings.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *GlobalSettingsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *GlobalSettingsMutation) ClearField(name string) error {
	switch name {
	case globalsettings.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown GlobalSettings nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *GlobalSettingsMutation) ResetField(name string) error {
	switch name {
	case globalsettings.FieldNamespace:
		m.ResetNamespace()
		return nil
	case globalsettings.FieldKey:
		m.ResetKey()
		return nil
	case globalsettings.FieldValue:
		m.ResetValue()
		return nil
	case globalsettings.FieldValueType:
		m.ResetValueType()
		return nil
	case globalsettings.FieldDescription:
		m.ResetDescription()
		return nil
	case globalsettings.FieldEditable:
		m.ResetEditable()
		return nil
	case globalsettings.FieldRequiresRestart:
		m.ResetRequiresRestart()
		return nil
	case globalsettings.FieldSensitive:
		m.ResetSensitive()
		return nil
	case globalsettings.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case globalsettings.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown GlobalSettings field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *GlobalSettingsMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *GlobalSettingsMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *GlobalSettingsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *GlobalSettingsMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *GlobalSettingsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *GlobalSettingsMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *GlobalSettingsMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown GlobalSettings unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *GlobalSettingsMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown GlobalSettings edge %s", name)
}

// NotificationSettingsMutation represents an operation that mutates the NotificationSettings nodes in the graph.
type NotificationSettingsMutation struct {
	config
	op                    Op
	typ                   string
	id                    *string
	channel               *notificationsettings.Channel
	credentials_encrypted *[]byte
	nonce                 *[]byte
	enabled               *bool
	test_status           *notificationsettings.TestStatus
	test_message          *string
	tested_at             *time.Time
	created_at            *time.Time
	updated_at            *time.Time
	clearedFields         map[string]struct{}
	done                  bool
	oldValue              func(context.Context) (*NotificationSettings, error)
	predicates            []predicate.NotificationSettings
}

var _ ent.Mutation = (*NotificationSettingsMutation)(nil)

// notificationsettingsOption allows management of the mutation configuration using functional options.
type notificationsettingsOption func(*NotificationSettingsMutation)

// newNotificationSettingsMutation creates new mutation for the NotificationSettings entity.
func newNotificationSettingsMutation(c config, op Op, opts ...notificationsettingsOption) *NotificationSettingsMutation {
	m := &NotificationSettingsMutation{
		config:        c,
		op:            op,
		typ:           TypeNotificationSettings,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withNotificationSettingsID sets the ID field of the mutation.
func withNotificationSettingsID(id string) notificationsettingsOption {
	return func(m *NotificationSettingsMutation) {
		var (
			err   error
			once  sync.Once
			value *NotificationSettings
		)
		m.oldValue = func(ctx context.Context) (*NotificationSettings, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().NotificationSettings.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withNotificationSettings sets the old NotificationSettings of the mutation.
func withNotificationSettings(node *NotificationSettings) notificationsettingsOption {
	return func(m *NotificationSettingsMutation) {
		m.oldValue = func(context.Context) (*NotificationSettings, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m NotificationSettingsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m NotificationSettingsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of NotificationSettings entities.
func (m *NotificationSettingsMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *NotificationSettingsMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *NotificationSettingsMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().NotificationSettings.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetChannel sets the "channel" field.
func (m *NotificationSettingsMutation) SetChannel(n notificationsettings.Channel) {
	m.channel = &n
}

// Channel returns the value of the "channel" field in the mutation.
func (m *NotificationSettingsMutation) Channel() (r notificationsettings.Channel, exists bool) {
	v := m.channel
	if v == nil {
		return
	}
	return *v, true
}

// OldChannel returns the old "channel" field's value of the NotificationSettings entity.
// If the NotificationSettings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationSettingsMutation) OldChannel(ctx context.Context) (v notificationsettings.Channel, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChannel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChannel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChannel: %w", err)
	}
	return oldValue.Channel, nil
}

// ResetChannel resets all changes to the "channel" field.
func (m *NotificationSettingsMutation) ResetChannel() {
	m.channel = nil
}

// SetCredentialsEncrypted sets the "credentials_encrypted" field.
func (m *NotificationSettingsMutation) SetCredentialsEncrypted(b []byte) {
	m.credentials_encrypted = &b
}

// CredentialsEncrypted returns the value of the "credentials_encrypted" field in the mutation.
func (m *NotificationSettingsMutation) CredentialsEncrypted() (r []byte, exists bool) {
	v := m.credentials_encrypted
	if v == nil {
		return
	}
	return *v, true
}

// OldCredentialsEncrypted returns the old "credentials_encrypted" field's value of the NotificationSettings entity.
// If the NotificationSettings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationSettingsMutation) OldCredentialsEncrypted(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCredentialsEncrypted is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCredentialsEncrypted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCredentialsEncrypted: %w", err)
	}
	return oldValue.CredentialsEncrypted, nil
}

// ResetCredentialsEncrypted resets all changes to the "credentials_encrypted" field.
func (m *NotificationSettingsMutation) ResetCredentialsEncrypted() {
	m.credentials_encrypted = nil
}

// SetNonce sets the "nonce" field.
func (m *NotificationSettingsMutation) SetNonce(b []byte) {
	m.nonce = &b
}

// Nonce returns the value of the "nonce" field in the mutation.
func (m *NotificationSettingsMutation) Nonce() (r []byte, exists bool) {
	v := m.nonce
	if v == nil {
		return
	}
	return *v, true
}

// OldNonce returns the old "nonce" field's value of the NotificationSettings entity.
// If the NotificationSettings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationSettingsMutation) OldNonce(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNonce is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNonce requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNonce: %w", err)
	}
	return oldValue.Nonce, nil
}

// ResetNonce resets all changes to the "nonce" field.
func (m *NotificationSettingsMutation) ResetNonce() {
	m.nonce = nil
}

// SetEnabled sets the "enabled" field.
func (m *NotificationSettingsMutation) SetEnabled(b bool) {
	m.enabled = &b
}

// Enabled returns the value of the "enabled" field in the mutation.
func (m *NotificationSettingsMutation) Enabled() (r bool, exists bool) {
	v := m.enabled
	if v == nil {
		return
	}
	return *v, true
}

// OldEnabled returns the old "enabled" field's value of the NotificationSettings entity.
// If the NotificationSettings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationSettingsMutation) OldEnabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnabled: %w", err)
	}
	return oldValue.Enabled, nil
}

// ResetEnabled resets all changes to the "enabled" field.
func (m *NotificationSettingsMutation) ResetEnabled() {
	m.enabled = nil
}

// SetTestStatus sets the "test_status" field.
func (m *NotificationSettingsMutation) SetTestStatus(ns notificationsettings.TestStatus) {
	m.test_status = &ns
}

// TestStatus returns the value of the "test_status" field in the mutation.
func (m *NotificationSettingsMutation) TestStatus() (r notificationsettings.TestStatus, exists bool) {
	v := m.test_status
	if v == nil {
		return
	}
	return *v, true
}

// OldTestStatus returns the old "test_status" field's value of the NotificationSettings entity.
// If the NotificationSettings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationSettingsMutation) OldTestStatus(ctx context.Context) (v notificationsettings.TestStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTestStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTestStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTestStatus: %w", err)
	}
	return oldValue.TestStatus, nil
}

// ResetTestStatus resets all changes to the "test_status" field.
func (m *NotificationSettingsMutation) ResetTestStatus() {
	m.test_status = nil
}

// SetTestMessage sets the "test_message" field.
func (m *NotificationSettingsMutation) SetTestMessage(s string) {
	m.test_message = &s
}

// TestMessage returns the value of the "test_message" field in the mutation.
func (m *NotificationSettingsMutation) TestMessage() (r string, exists bool) {
	v := m.test_message
	if v == nil {
		return
	}
	return *v, true
}

// OldTestMessage returns the old "test_message" field's value of the NotificationSettings entity.
// If the NotificationSettings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationSettingsMutation) OldTestMessage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTestMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTestMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTestMessage: %w", err)
	}
	return oldValue.TestMessage, nil
}

// ClearTestMessage clears the value of the "test_message" field.
func (m *NotificationSettingsMutation) ClearTestMessage() {
	m.test_message = nil
	m.clearedFields[notificationsettings.FieldTestMessage] = struct{}{}
}

// TestMessageCleared returns if the "test_message" field was cleared in this mutation.
func (m *NotificationSettingsMutation) TestMessageCleared() bool {
	_, ok := m.clearedFields[notificationsettings.FieldTestMessage]
	return ok
}

// ResetTestMessage resets all changes to the "test_message" field.
func (m *NotificationSettingsMutation) ResetTestMessage() {
	m.test_message = nil
	delete(m.clearedFields, notificationsettings.FieldTestMessage)
}

// SetTestedAt sets the "tested_at" field.
func (m *NotificationSettingsMutation) SetTestedAt(t time.Time) {
	m.tested_at = &t
}

// TestedAt returns the value of the "tested_at" field in the mutation.
func (m *NotificationSettingsMutation) TestedAt() (r time.Time, exists bool) {
	v := m.tested_at
	if v == nil {
		return
	}
	return *v, true
}

// OldTestedAt returns the old "tested_at" field's value of the NotificationSettings entity.
// If the NotificationSettings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationSettingsMutation) OldTestedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTestedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTestedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTestedAt: %w", err)
	}
	return oldValue.TestedAt, nil
}

// ClearTestedAt clears the value of the "tested_at" field.
func (m *NotificationSettingsMutation) ClearTestedAt() {
	m.tested_at = nil
	m.clearedFields[notificationsettings.FieldTestedAt] = struct{}{}
}

// TestedAtCleared returns if the "tested_at" field was cleared in this mutation.
func (m *NotificationSettingsMutation) TestedAtCleared() bool {
	_, ok := m.clearedFields[notificationsettings.FieldTestedAt]
	return ok
}

// ResetTestedAt resets all changes to the "tested_at" field.
func (m *NotificationSettingsMutation) ResetTestedAt() {
	m.tested_at = nil
	delete(m.clearedFields, notificationsettings.FieldTestedAt)
}

// SetCreatedAt sets the "created_at" field.
func (m *NotificationSettingsMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *NotificationSettingsMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the NotificationSettings entity.
// If the NotificationSettings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationSettingsMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *NotificationSettingsMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *NotificationSettingsMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *NotificationSettingsMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the NotificationSettings entity.
// If the NotificationSettings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationSettingsMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *NotificationSettingsMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// Where appends a list predicates to the NotificationSettingsMutation builder.
func (m *NotificationSettingsMutation) Where(ps ...predicate.NotificationSettings) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the NotificationSettingsMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *NotificationSettingsMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.NotificationSettings, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *NotificationSettingsMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *NotificationSettingsMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (NotificationSettings).
func (m *NotificationSettingsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *NotificationSettingsMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.channel != nil {
		fields = append(fields, notificationsettings.FieldChannel)
	}
	if m.credentials_encrypted != nil {
		fields = append(fields, notificationsettings.FieldCredentialsEncrypted)
	}
	if m.nonce != nil {
		fields = append(fields, notificationsettings.FieldNonce)
	}
	if m.enabled != nil {
		fields = append(fields, notificationsettings.FieldEnabled)
	}
	if m.test_status != nil {
		fields = append(fields, notificationsettings.FieldTestStatus)
	}
	if m.test_message != nil {
		fields = append(fields, notificationsettings.FieldTestMessage)
	}
	if m.tested_at != nil {
		fields = append(fields, notificationsettings.FieldTestedAt)
	}
	if m.created_at != nil {
		fields = append(fields, notificationsettings.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, notificationsettings.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *NotificationSettingsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case notificationsettings.FieldChannel:
		return m.Channel()
	case notificationsettings.FieldCredentialsEncrypted:
		return m.CredentialsEncrypted()
	case notificationsettings.FieldNonce:
		return m.Nonce()
	case notificationsettings.FieldEnabled:
		return m.Enabled()
	case notificationsettings.FieldTestStatus:
		return m.TestStatus()
	case notificationsettings.FieldTestMessage:
		return m.TestMessage()
	case notificationsettings.FieldTestedAt:
		return m.TestedAt()
	case notificationsettings.FieldCreatedAt:
		return m.CreatedAt()
	case notificationsettings.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *NotificationSettingsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case notificationsettings.FieldChannel:
		return m.OldChannel(ctx)
	case notificationsettings.FieldCredentialsEncrypted:
		return m.OldCredentialsEncrypted(ctx)
	case notificationsettings.FieldNonce:
		return m.OldNonce(ctx)
	case notificationsettings.FieldEnabled:
		return m.OldEnabled(ctx)
	case notificationsettings.FieldTestStatus:
		return m.OldTestStatus(ctx)
	case notificationsettings.FieldTestMessage:
		return m.OldTestMessage(ctx)
	case notificationsettings.FieldTestedAt:
		return m.OldTestedAt(ctx)
	case notificationsettings.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case notificationsettings.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown NotificationSettings field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NotificationSettingsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case notificationsettings.FieldChannel:
		v, ok := value.(notificationsettings.Channel)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChannel(v)
		return nil
	case notificationsettings.FieldCredentialsEncrypted:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCredentialsEncrypted(v)
		return nil
	case notificationsettings.FieldNonce:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNonce(v)
		return nil
	case notificationsettings.FieldEnabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnabled(v)
		return nil
	case notificationsettings.FieldTestStatus:
		v, ok := value.(notificationsettings.TestStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTestStatus(v)
		return nil
	case notificationsettings.FieldTestMessage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTestMessage(v)
		return nil
	case notificationsettings.FieldTestedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTestedAt(v)
		return nil
	case notificationsettings.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case notificationsettings.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown NotificationSettings field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *NotificationSettingsMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *NotificationSettingsMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NotificationSettingsMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown NotificationSettings numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *NotificationSettingsMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(notificationsettings.FieldTestMessage) {
		fields = append(fields, notificationsettings.FieldTestMessage)
	}
	if m.FieldCleared(notificationsettings.FieldTestedAt) {
		fields = append(fields, notificationsettings.FieldTestedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *NotificationSettingsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *NotificationSettingsMutation) ClearField(name string) error {
	switch name {
	case notificationsettings.FieldTestMessage:
		m.ClearTestMessage()
		return nil
	case notificationsettings.FieldTestedAt:
		m.ClearTestedAt()
		return nil
	}
	return fmt.Errorf("unknown NotificationSettings nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *NotificationSettingsMutation) ResetField(name string) error {
	switch name {
	case notificationsettings.FieldChannel:
		m.ResetChannel()
		return nil
	case notificationsettings.FieldCredentialsEncrypted:
		m.ResetCredentialsEncrypted()
		return nil
	case notificationsettings.FieldNonce:
		m.ResetNonce()
		return nil
	case notificationsettings.FieldEnabled:
		m.ResetEnabled()
		return nil
	case notificationsettings.FieldTestStatus:
		m.ResetTestStatus()
		return nil
	case notificationsettings.FieldTestMessage:
		m.ResetTestMessage()
		return nil
	case notificationsettings.FieldTestedAt:
		m.ResetTestedAt()
		return nil
	case notificationsettings.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case notificationsettings.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown NotificationSettings field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *NotificationSettingsMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *NotificationSettingsMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *NotificationSettingsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *NotificationSettingsMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *NotificationSettingsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *NotificationSettingsMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *NotificationSettingsMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown NotificationSettings unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *NotificationSettingsMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown NotificationSettings edge %s", name)
}

// ResourceMutation represents an operation that mutates the Resource nodes in the graph.
type ResourceMutation struct {
	config
	op                 Op
	typ                string
	id                 *string
	_type              *string
	category           *string
	ros_id             *string
	configuration      *map[string]interface{}
	validation         *map[string]interface{}
	deployment         *map[string]interface{}
	runtime            *map[string]interface{}
	telemetry          *map[string]interface{}
	metadata           *map[string]interface{}
	relationships      *map[string]interface{}
	platform           *map[string]interface{}
	sync_status        *resource.SyncStatus
	enabled            *bool
	managed            *bool
	version            *int64
	addversion         *int64
	created_at         *time.Time
	updated_at         *time.Time
	synced_at          *time.Time
	router_modified_at *time.Time
	clearedFields      map[string]struct{}
	events             map[string]struct{}
	removedevents      map[string]struct{}
	clearedevents      bool
	done               bool
	oldValue           func(context.Context) (*Resource, error)
	predicates         []predicate.Resource
}

var _ ent.Mutation = (*ResourceMutation)(nil)

// resourceOption allows management of the mutation configuration using functional options.
type resourceOption func(*ResourceMutation)

// newResourceMutation creates new mutation for the Resource entity.
func newResourceMutation(c config, op Op, opts ...resourceOption) *ResourceMutation {
	m := &ResourceMutation{
		config:        c,
		op:            op,
		typ:           TypeResource,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withResourceID sets the ID field of the mutation.
func withResourceID(id string) resourceOption {
	return func(m *ResourceMutation) {
		var (
			err   error
			once  sync.Once
			value *Resource
		)
		m.oldValue = func(ctx context.Context) (*Resource, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Resource.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withResource sets the old Resource of the mutation.
func withResource(node *Resource) resourceOption {
	return func(m *ResourceMutation) {
		m.oldValue = func(context.Context) (*Resource, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ResourceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ResourceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Resource entities.
func (m *ResourceMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ResourceMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ResourceMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Resource.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetType sets the "type" field.
func (m *ResourceMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *ResourceMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Resource entity.
// If the Resource object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *ResourceMutation) ResetType() {
	m._type = nil
}

// SetCategory sets the "category" field.
func (m *ResourceMutation) SetCategory(s string) {
	m.category = &s
}

// Category returns the value of the "category" field in the mutation.
func (m *ResourceMutation) Category() (r string, exists bool) {
	v := m.category
	if v == nil {
		return
	}
	return *v, true
}

// OldCategory returns the old "category" field's value of the Resource entity.
// If the Resource object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceMutation) OldCategory(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategory: %w", err)
	}
	return oldValue.Category, nil
}

// ResetCategory resets all changes to the "category" field.
func (m *ResourceMutation) ResetCategory() {
	m.category = nil
}

// SetRosID sets the "ros_id" field.
func (m *ResourceMutation) SetRosID(s string) {
	m.ros_id = &s
}

// RosID returns the value of the "ros_id" field in the mutation.
func (m *ResourceMutation) RosID() (r string, exists bool) {
	v := m.ros_id
	if v == nil {
		return
	}
	return *v, true
}

// OldRosID returns the old "ros_id" field's value of the Resource entity.
// If the Resource object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceMutation) OldRosID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRosID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRosID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRosID: %w", err)
	}
	return oldValue.RosID, nil
}

// ClearRosID clears the value of the "ros_id" field.
func (m *ResourceMutation) ClearRosID() {
	m.ros_id = nil
	m.clearedFields[resource.FieldRosID] = struct{}{}
}

// RosIDCleared returns if the "ros_id" field was cleared in this mutation.
func (m *ResourceMutation) RosIDCleared() bool {
	_, ok := m.clearedFields[resource.FieldRosID]
	return ok
}

// ResetRosID resets all changes to the "ros_id" field.
func (m *ResourceMutation) ResetRosID() {
	m.ros_id = nil
	delete(m.clearedFields, resource.FieldRosID)
}

// SetConfiguration sets the "configuration" field.
func (m *ResourceMutation) SetConfiguration(value map[string]interface{}) {
	m.configuration = &value
}

// Configuration returns the value of the "configuration" field in the mutation.
func (m *ResourceMutation) Configuration() (r map[string]interface{}, exists bool) {
	v := m.configuration
	if v == nil {
		return
	}
	return *v, true
}

// OldConfiguration returns the old "configuration" field's value of the Resource entity.
// If the Resource object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceMutation) OldConfiguration(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConfiguration is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConfiguration requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConfiguration: %w", err)
	}
	return oldValue.Configuration, nil
}

// ResetConfiguration resets all changes to the "configuration" field.
func (m *ResourceMutation) ResetConfiguration() {
	m.configuration = nil
}

// SetValidation sets the "validation" field.
func (m *ResourceMutation) SetValidation(value map[string]interface{}) {
	m.validation = &value
}

// Validation returns the value of the "validation" field in the mutation.
func (m *ResourceMutation) Validation() (r map[string]interface{}, exists bool) {
	v := m.validation
	if v == nil {
		return
	}
	return *v, true
}

// OldValidation returns the old "validation" field's value of the Resource entity.
// If the Resource object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceMutation) OldValidation(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValidation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValidation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValidation: %w", err)
	}
	return oldValue.Validation, nil
}

// ClearValidation clears the value of the "validation" field.
func (m *ResourceMutation) ClearValidation() {
	m.validation = nil
	m.clearedFields[resource.FieldValidation] = struct{}{}
}

// ValidationCleared returns if the "validation" field was cleared in this mutation.
func (m *ResourceMutation) ValidationCleared() bool {
	_, ok := m.clearedFields[resource.FieldValidation]
	return ok
}

// ResetValidation resets all changes to the "validation" field.
func (m *ResourceMutation) ResetValidation() {
	m.validation = nil
	delete(m.clearedFields, resource.FieldValidation)
}

// SetDeployment sets the "deployment" field.
func (m *ResourceMutation) SetDeployment(value map[string]interface{}) {
	m.deployment = &value
}

// Deployment returns the value of the "deployment" field in the mutation.
func (m *ResourceMutation) Deployment() (r map[string]interface{}, exists bool) {
	v := m.deployment
	if v == nil {
		return
	}
	return *v, true
}

// OldDeployment returns the old "deployment" field's value of the Resource entity.
// If the Resource object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceMutation) OldDeployment(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeployment is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeployment requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeployment: %w", err)
	}
	return oldValue.Deployment, nil
}

// ClearDeployment clears the value of the "deployment" field.
func (m *ResourceMutation) ClearDeployment() {
	m.deployment = nil
	m.clearedFields[resource.FieldDeployment] = struct{}{}
}

// DeploymentCleared returns if the "deployment" field was cleared in this mutation.
func (m *ResourceMutation) DeploymentCleared() bool {
	_, ok := m.clearedFields[resource.FieldDeployment]
	return ok
}

// ResetDeployment resets all changes to the "deployment" field.
func (m *ResourceMutation) ResetDeployment() {
	m.deployment = nil
	delete(m.clearedFields, resource.FieldDeployment)
}

// SetRuntime sets the "runtime" field.
func (m *ResourceMutation) SetRuntime(value map[string]interface{}) {
	m.runtime = &value
}

// Runtime returns the value of the "runtime" field in the mutation.
func (m *ResourceMutation) Runtime() (r map[string]interface{}, exists bool) {
	v := m.runtime
	if v == nil {
		return
	}
	return *v, true
}

// OldRuntime returns the old "runtime" field's value of the Resource entity.
// If the Resource object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceMutation) OldRuntime(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRuntime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRuntime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRuntime: %w", err)
	}
	return oldValue.Runtime, nil
}

// ClearRuntime clears the value of the "runtime" field.
func (m *ResourceMutation) ClearRuntime() {
	m.runtime = nil
	m.clearedFields[resource.FieldRuntime] = struct{}{}
}

// RuntimeCleared returns if the "runtime" field was cleared in this mutation.
func (m *ResourceMutation) RuntimeCleared() bool {
	_, ok := m.clearedFields[resource.FieldRuntime]
	return ok
}

// ResetRuntime resets all changes to the "runtime" field.
func (m *ResourceMutation) ResetRuntime() {
	m.runtime = nil
	delete(m.clearedFields, resource.FieldRuntime)
}

// SetTelemetry sets the "telemetry" field.
func (m *ResourceMutation) SetTelemetry(value map[string]interface{}) {
	m.telemetry = &value
}

// Telemetry returns the value of the "telemetry" field in the mutation.
func (m *ResourceMutation) Telemetry() (r map[string]interface{}, exists bool) {
	v := m.telemetry
	if v == nil {
		return
	}
	return *v, true
}

// OldTelemetry returns the old "telemetry" field's value of the Resource entity.
// If the Resource object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceMutation) OldTelemetry(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTelemetry is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTelemetry requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTelemetry: %w", err)
	}
	return oldValue.Telemetry, nil
}

// ClearTelemetry clears the value of the "telemetry" field.
func (m *ResourceMutation) ClearTelemetry() {
	m.telemetry = nil
	m.clearedFields[resource.FieldTelemetry] = struct{}{}
}

// TelemetryCleared returns if the "telemetry" field was cleared in this mutation.
func (m *ResourceMutation) TelemetryCleared() bool {
	_, ok := m.clearedFields[resource.FieldTelemetry]
	return ok
}

// ResetTelemetry resets all changes to the "telemetry" field.
func (m *ResourceMutation) ResetTelemetry() {
	m.telemetry = nil
	delete(m.clearedFields, resource.FieldTelemetry)
}

// SetMetadata sets the "metadata" field.
func (m *ResourceMutation) SetMetadata(value map[string]interface{}) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *ResourceMutation) Metadata() (r map[string]interface{}, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the Resource entity.
// If the Resource object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceMutation) OldMetadata(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *ResourceMutation) ResetMetadata() {
	m.metadata = nil
}

// SetRelationships sets the "relationships" field.
func (m *ResourceMutation) SetRelationships(value map[string]interface{}) {
	m.relationships = &value
}

// Relationships returns the value of the "relationships" field in the mutation.
func (m *ResourceMutation) Relationships() (r map[string]interface{}, exists bool) {
	v := m.relationships
	if v == nil {
		return
	}
	return *v, true
}

// OldRelationships returns the old "relationships" field's value of the Resource entity.
// If the Resource object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceMutation) OldRelationships(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRelationships is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRelationships requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRelationships: %w", err)
	}
	return oldValue.Relationships, nil
}

// ClearRelationships clears the value of the "relationships" field.
func (m *ResourceMutation) ClearRelationships() {
	m.relationships = nil
	m.clearedFields[resource.FieldRelationships] = struct{}{}
}

// RelationshipsCleared returns if the "relationships" field was cleared in this mutation.
func (m *ResourceMutation) RelationshipsCleared() bool {
	_, ok := m.clearedFields[resource.FieldRelationships]
	return ok
}

// ResetRelationships resets all changes to the "relationships" field.
func (m *ResourceMutation) ResetRelationships() {
	m.relationships = nil
	delete(m.clearedFields, resource.FieldRelationships)
}

// SetPlatform sets the "platform" field.
func (m *ResourceMutation) SetPlatform(value map[string]interface{}) {
	m.platform = &value
}

// Platform returns the value of the "platform" field in the mutation.
func (m *ResourceMutation) Platform() (r map[string]interface{}, exists bool) {
	v := m.platform
	if v == nil {
		return
	}
	return *v, true
}

// OldPlatform returns the old "platform" field's value of the Resource entity.
// If the Resource object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceMutation) OldPlatform(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPlatform is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPlatform requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPlatform: %w", err)
	}
	return oldValue.Platform, nil
}

// ClearPlatform clears the value of the "platform" field.
func (m *ResourceMutation) ClearPlatform() {
	m.platform = nil
	m.clearedFields[resource.FieldPlatform] = struct{}{}
}

// PlatformCleared returns if the "platform" field was cleared in this mutation.
func (m *ResourceMutation) PlatformCleared() bool {
	_, ok := m.clearedFields[resource.FieldPlatform]
	return ok
}

// ResetPlatform resets all changes to the "platform" field.
func (m *ResourceMutation) ResetPlatform() {
	m.platform = nil
	delete(m.clearedFields, resource.FieldPlatform)
}

// SetSyncStatus sets the "sync_status" field.
func (m *ResourceMutation) SetSyncStatus(rs resource.SyncStatus) {
	m.sync_status = &rs
}

// SyncStatus returns the value of the "sync_status" field in the mutation.
func (m *ResourceMutation) SyncStatus() (r resource.SyncStatus, exists bool) {
	v := m.sync_status
	if v == nil {
		return
	}
	return *v, true
}

// OldSyncStatus returns the old "sync_status" field's value of the Resource entity.
// If the Resource object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceMutation) OldSyncStatus(ctx context.Context) (v resource.SyncStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSyncStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSyncStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSyncStatus: %w", err)
	}
	return oldValue.SyncStatus, nil
}

// ResetSyncStatus resets all changes to the "sync_status" field.
func (m *ResourceMutation) ResetSyncStatus() {
	m.sync_status = nil
}

// SetEnabled sets the "enabled" field.
func (m *ResourceMutation) SetEnabled(b bool) {
	m.enabled = &b
}

// Enabled returns the value of the "enabled" field in the mutation.
func (m *ResourceMutation) Enabled() (r bool, exists bool) {
	v := m.enabled
	if v == nil {
		return
	}
	return *v, true
}

// OldEnabled returns the old "enabled" field's value of the Resource entity.
// If the Resource object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceMutation) OldEnabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnabled: %w", err)
	}
	return oldValue.Enabled, nil
}

// ResetEnabled resets all changes to the "enabled" field.
func (m *ResourceMutation) ResetEnabled() {
	m.enabled = nil
}

// SetManaged sets the "managed" field.
func (m *ResourceMutation) SetManaged(b bool) {
	m.managed = &b
}

// Managed returns the value of the "managed" field in the mutation.
func (m *ResourceMutation) Managed() (r bool, exists bool) {
	v := m.managed
	if v == nil {
		return
	}
	return *v, true
}

// OldManaged returns the old "managed" field's value of the Resource entity.
// If the Resource object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceMutation) OldManaged(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldManaged is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldManaged requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldManaged: %w", err)
	}
	return oldValue.Managed, nil
}

// ResetManaged resets all changes to the "managed" field.
func (m *ResourceMutation) ResetManaged() {
	m.managed = nil
}

// SetVersion sets the "version" field.
func (m *ResourceMutation) SetVersion(i int64) {
	m.version = &i
	m.addversion = nil
}

// Version returns the value of the "version" field in the mutation.
func (m *ResourceMutation) Version() (r int64, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the Resource entity.
// If the Resource object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceMutation) OldVersion(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// AddVersion adds i to the "version" field.
func (m *ResourceMutation) AddVersion(i int64) {
	if m.addversion != nil {
		*m.addversion += i
	} else {
		m.addversion = &i
	}
}

// AddedVersion returns the value that was added to the "version" field in this mutation.
func (m *ResourceMutation) AddedVersion() (r int64, exists bool) {
	v := m.addversion
	if v == nil {
		return
	}
	return *v, true
}

// ResetVersion resets all changes to the "version" field.
func (m *ResourceMutation) ResetVersion() {
	m.version = nil
	m.addversion = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ResourceMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ResourceMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Resource entity.
// If the Resource object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ResourceMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ResourceMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ResourceMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Resource entity.
// If the Resource object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ResourceMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetSyncedAt sets the "synced_at" field.
func (m *ResourceMutation) SetSyncedAt(t time.Time) {
	m.synced_at = &t
}

// SyncedAt returns the value of the "synced_at" field in the mutation.
func (m *ResourceMutation) SyncedAt() (r time.Time, exists bool) {
	v := m.synced_at
	if v == nil {
		return
	}
	return *v, true
}

// OldSyncedAt returns the old "synced_at" field's value of the Resource entity.
// If the Resource object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceMutation) OldSyncedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSyncedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSyncedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSyncedAt: %w", err)
	}
	return oldValue.SyncedAt, nil
}

// ClearSyncedAt clears the value of the "synced_at" field.
func (m *ResourceMutation) ClearSyncedAt() {
	m.synced_at = nil
	m.clearedFields[resource.FieldSyncedAt] = struct{}{}
}

// SyncedAtCleared returns if the "synced_at" field was cleared in this mutation.
func (m *ResourceMutation) SyncedAtCleared() bool {
	_, ok := m.clearedFields[resource.FieldSyncedAt]
	return ok
}

// ResetSyncedAt resets all changes to the "synced_at" field.
func (m *ResourceMutation) ResetSyncedAt() {
	m.synced_at = nil
	delete(m.clearedFields, resource.FieldSyncedAt)
}

// SetRouterModifiedAt sets the "router_modified_at" field.
func (m *ResourceMutation) SetRouterModifiedAt(t time.Time) {
	m.router_modified_at = &t
}

// RouterModifiedAt returns the value of the "router_modified_at" field in the mutation.
func (m *ResourceMutation) RouterModifiedAt() (r time.Time, exists bool) {
	v := m.router_modified_at
	if v == nil {
		return
	}
	return *v, true
}

// OldRouterModifiedAt returns the old "router_modified_at" field's value of the Resource entity.
// If the Resource object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceMutation) OldRouterModifiedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRouterModifiedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRouterModifiedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRouterModifiedAt: %w", err)
	}
	return oldValue.RouterModifiedAt, nil
}

// ClearRouterModifiedAt clears the value of the "router_modified_at" field.
func (m *ResourceMutation) ClearRouterModifiedAt() {
	m.router_modified_at = nil
	m.clearedFields[resource.FieldRouterModifiedAt] = struct{}{}
}

// RouterModifiedAtCleared returns if the "router_modified_at" field was cleared in this mutation.
func (m *ResourceMutation) RouterModifiedAtCleared() bool {
	_, ok := m.clearedFields[resource.FieldRouterModifiedAt]
	return ok
}

// ResetRouterModifiedAt resets all changes to the "router_modified_at" field.
func (m *ResourceMutation) ResetRouterModifiedAt() {
	m.router_modified_at = nil
	delete(m.clearedFields, resource.FieldRouterModifiedAt)
}

// AddEventIDs adds the "events" edge to the ResourceEvent entity by ids.
func (m *ResourceMutation) AddEventIDs(ids ...string) {
	if m.events == nil {
		m.events = make(map[string]struct{})
	}
	for i := range ids {
		m.events[ids[i]] = struct{}{}
	}
}

// ClearEvents clears the "events" edge to the ResourceEvent entity.
func (m *ResourceMutation) ClearEvents() {
	m.clearedevents = true
}

// EventsCleared reports if the "events" edge to the ResourceEvent entity was cleared.
func (m *ResourceMutation) EventsCleared() bool {
	return m.clearedevents
}

// RemoveEventIDs removes the "events" edge to the ResourceEvent entity by IDs.
func (m *ResourceMutation) RemoveEventIDs(ids ...string) {
	if m.removedevents == nil {
		m.removedevents = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.events, ids[i])
		m.removedevents[ids[i]] = struct{}{}
	}
}

// RemovedEvents returns the removed IDs of the "events" edge to the ResourceEvent entity.
func (m *ResourceMutation) RemovedEventsIDs() (ids []string) {
	for id := range m.removedevents {
		ids = append(ids, id)
	}
	return
}

// EventsIDs returns the "events" edge IDs in the mutation.
func (m *ResourceMutation) EventsIDs() (ids []string) {
	for id := range m.events {
		ids = append(ids, id)
	}
	return
}

// ResetEvents resets all changes to the "events" edge.
func (m *ResourceMutation) ResetEvents() {
	m.events = nil
	m.clearedevents = false
	m.removedevents = nil
}

// Where appends a list predicates to the ResourceMutation builder.
func (m *ResourceMutation) Where(ps ...predicate.Resource) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ResourceMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ResourceMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Resource, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ResourceMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ResourceMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Resource).
func (m *ResourceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ResourceMutation) Fields() []string {
	fields := make([]string, 0, 19)
	if m._type != nil {
		fields = append(fields, resource.FieldType)
	}
	if m.category != nil {
		fields = append(fields, resource.FieldCategory)
	}
	if m.ros_id != nil {
		fields = append(fields, resource.FieldRosID)
	}
	if m.configuration != nil {
		fields = append(fields, resource.FieldConfiguration)
	}
	if m.validation != nil {
		fields = append(fields, resource.FieldValidation)
	}
	if m.deployment != nil {
		fields = append(fields, resource.FieldDeployment)
	}
	if m.runtime != nil {
		fields = append(fields, resource.FieldRuntime)
	}
	if m.telemetry != nil {
		fields = append(fields, resource.FieldTelemetry)
	}
	if m.metadata != nil {
		fields = append(fields, resource.FieldMetadata)
	}
	if m.relationships != nil {
		fields = append(fields, resource.FieldRelationships)
	}
	if m.platform != nil {
		fields = append(fields, resource.FieldPlatform)
	}
	if m.sync_status != nil {
		fields = append(fields, resource.FieldSyncStatus)
	}
	if m.enabled != nil {
		fields = append(fields, resource.FieldEnabled)
	}
	if m.managed != nil {
		fields = append(fields, resource.FieldManaged)
	}
	if m.version != nil {
		fields = append(fields, resource.FieldVersion)
	}
	if m.created_at != nil {
		fields = append(fields, resource.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, resource.FieldUpdatedAt)
	}
	if m.synced_at != nil {
		fields = append(fields, resource.FieldSyncedAt)
	}
	if m.router_modified_at != nil {
		fields = append(fields, resource.FieldRouterModifiedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ResourceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case resource.FieldType:
		return m.GetType()
	case resource.FieldCategory:
		return m.Category()
	case resource.FieldRosID:
		return m.RosID()
	case resource.FieldConfiguration:
		return m.Configuration()
	case resource.FieldValidation:
		return m.Validation()
	case resource.FieldDeployment:
		return m.Deployment()
	case resource.FieldRuntime:
		return m.Runtime()
	case resource.FieldTelemetry:
		return m.Telemetry()
	case resource.FieldMetadata:
		return m.Metadata()
	case resource.FieldRelationships:
		return m.Relationships()
	case resource.FieldPlatform:
		return m.Platform()
	case resource.FieldSyncStatus:
		return m.SyncStatus()
	case resource.FieldEnabled:
		return m.Enabled()
	case resource.FieldManaged:
		return m.Managed()
	case resource.FieldVersion:
		return m.Version()
	case resource.FieldCreatedAt:
		return m.CreatedAt()
	case resource.FieldUpdatedAt:
		return m.UpdatedAt()
	case resource.FieldSyncedAt:
		return m.SyncedAt()
	case resource.FieldRouterModifiedAt:
		return m.RouterModifiedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ResourceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case resource.FieldType:
		return m.OldType(ctx)
	case resource.FieldCategory:
		return m.OldCategory(ctx)
	case resource.FieldRosID:
		return m.OldRosID(ctx)
	case resource.FieldConfiguration:
		return m.OldConfiguration(ctx)
	case resource.FieldValidation:
		return m.OldValidation(ctx)
	case resource.FieldDeployment:
		return m.OldDeployment(ctx)
	case resource.FieldRuntime:
		return m.OldRuntime(ctx)
	case resource.FieldTelemetry:
		return m.OldTelemetry(ctx)
	case resource.FieldMetadata:
		return m.OldMetadata(ctx)
	case resource.FieldRelationships:
		return m.OldRelationships(ctx)
	case resource.FieldPlatform:
		return m.OldPlatform(ctx)
	case resource.FieldSyncStatus:
		return m.OldSyncStatus(ctx)
	case resource.FieldEnabled:
		return m.OldEnabled(ctx)
	case resource.FieldManaged:
		return m.OldManaged(ctx)
	case resource.FieldVersion:
		return m.OldVersion(ctx)
	case resource.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case resource.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case resource.FieldSyncedAt:
		return m.OldSyncedAt(ctx)
	case resource.FieldRouterModifiedAt:
		return m.OldRouterModifiedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Resource field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ResourceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case resource.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case resource.FieldCategory:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategory(v)
		return nil
	case resource.FieldRosID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRosID(v)
		return nil
	case resource.FieldConfiguration:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConfiguration(v)
		return nil
	case resource.FieldValidation:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValidation(v)
		return nil
	case resource.FieldDeployment:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeployment(v)
		return nil
	case resource.FieldRuntime:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRuntime(v)
		return nil
	case resource.FieldTelemetry:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTelemetry(v)
		return nil
	case resource.FieldMetadata:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	case resource.FieldRelationships:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRelationships(v)
		return nil
	case resource.FieldPlatform:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPlatform(v)
		return nil
	case resource.FieldSyncStatus:
		v, ok := value.(resource.SyncStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSyncStatus(v)
		return nil
	case resource.FieldEnabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnabled(v)
		return nil
	case resource.FieldManaged:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetManaged(v)
		return nil
	case resource.FieldVersion:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case resource.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case resource.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case resource.FieldSyncedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSyncedAt(v)
		return nil
	case resource.FieldRouterModifiedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRouterModifiedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Resource field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ResourceMutation) AddedFields() []string {
	var fields []string
	if m.addversion != nil {
		fields = append(fields, resource.FieldVersion)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ResourceMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case resource.FieldVersion:
		return m.AddedVersion()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ResourceMutation) AddField(name string, value ent.Value) error {
	switch name {
	case resource.FieldVersion:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVersion(v)
		return nil
	}
	return fmt.Errorf("unknown Resource numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ResourceMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(resource.FieldRosID) {
		fields = append(fields, resource.FieldRosID)
	}
	if m.FieldCleared(resource.FieldValidation) {
		fields = append(fields, resource.FieldValidation)
	}
	if m.FieldCleared(resource.FieldDeployment) {
		fields = append(fields, resource.FieldDeployment)
	}
	if m.FieldCleared(resource.FieldRuntime) {
		fields = append(fields, resource.FieldRuntime)
	}
	if m.FieldCleared(resource.FieldTelemetry) {
		fields = append(fields, resource.FieldTelemetry)
	}
	if m.FieldCleared(resource.FieldRelationships) {
		fields = append(fields, resource.FieldRelationships)
	}
	if m.FieldCleared(resource.FieldPlatform) {
		fields = append(fields, resource.FieldPlatform)
	}
	if m.FieldCleared(resource.FieldSyncedAt) {
		fields = append(fields, resource.FieldSyncedAt)
	}
	if m.FieldCleared(resource.FieldRouterModifiedAt) {
		fields = append(fields, resource.FieldRouterModifiedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ResourceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ResourceMutation) ClearField(name string) error {
	switch name {
	case resource.FieldRosID:
		m.ClearRosID()
		return nil
	case resource.FieldValidation:
		m.ClearValidation()
		return nil
	case resource.FieldDeployment:
		m.ClearDeployment()
		return nil
	case resource.FieldRuntime:
		m.ClearRuntime()
		return nil
	case resource.FieldTelemetry:
		m.ClearTelemetry()
		return nil
	case resource.FieldRelationships:
		m.ClearRelationships()
		return nil
	case resource.FieldPlatform:
		m.ClearPlatform()
		return nil
	case resource.FieldSyncedAt:
		m.ClearSyncedAt()
		return nil
	case resource.FieldRouterModifiedAt:
		m.ClearRouterModifiedAt()
		return nil
	}
	return fmt.Errorf("unknown Resource nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ResourceMutation) ResetField(name string) error {
	switch name {
	case resource.FieldType:
		m.ResetType()
		return nil
	case resource.FieldCategory:
		m.ResetCategory()
		return nil
	case resource.FieldRosID:
		m.ResetRosID()
		return nil
	case resource.FieldConfiguration:
		m.ResetConfiguration()
		return nil
	case resource.FieldValidation:
		m.ResetValidation()
		return nil
	case resource.FieldDeployment:
		m.ResetDeployment()
		return nil
	case resource.FieldRuntime:
		m.ResetRuntime()
		return nil
	case resource.FieldTelemetry:
		m.ResetTelemetry()
		return nil
	case resource.FieldMetadata:
		m.ResetMetadata()
		return nil
	case resource.FieldRelationships:
		m.ResetRelationships()
		return nil
	case resource.FieldPlatform:
		m.ResetPlatform()
		return nil
	case resource.FieldSyncStatus:
		m.ResetSyncStatus()
		return nil
	case resource.FieldEnabled:
		m.ResetEnabled()
		return nil
	case resource.FieldManaged:
		m.ResetManaged()
		return nil
	case resource.FieldVersion:
		m.ResetVersion()
		return nil
	case resource.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case resource.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case resource.FieldSyncedAt:
		m.ResetSyncedAt()
		return nil
	case resource.FieldRouterModifiedAt:
		m.ResetRouterModifiedAt()
		return nil
	}
	return fmt.Errorf("unknown Resource field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ResourceMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.events != nil {
		edges = append(edges, resource.EdgeEvents)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ResourceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case resource.EdgeEvents:
		ids := make([]ent.Value, 0, len(m.events))
		for id := range m.events {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ResourceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedevents != nil {
		edges = append(edges, resource.EdgeEvents)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ResourceMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case resource.EdgeEvents:
		ids := make([]ent.Value, 0, len(m.removedevents))
		for id := range m.removedevents {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ResourceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedevents {
		edges = append(edges, resource.EdgeEvents)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ResourceMutation) EdgeCleared(name string) bool {
	switch name {
	case resource.EdgeEvents:
		return m.clearedevents
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ResourceMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Resource unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ResourceMutation) ResetEdge(name string) error {
	switch name {
	case resource.EdgeEvents:
		m.ResetEvents()
		return nil
	}
	return fmt.Errorf("unknown Resource edge %s", name)
}

// ResourceEventMutation represents an operation that mutates the ResourceEvent nodes in the graph.
type ResourceEventMutation struct {
	config
	op              Op
	typ             string
	id              *string
	event_type      *resourceevent.EventType
	actor           *string
	previous_state  *map[string]interface{}
	new_state       *map[string]interface{}
	diff            *map[string]interface{}
	metadata        *map[string]interface{}
	error_message   *string
	source          *resourceevent.Source
	reversible      *bool
	created_at      *time.Time
	clearedFields   map[string]struct{}
	resource        *string
	clearedresource bool
	done            bool
	oldValue        func(context.Context) (*ResourceEvent, error)
	predicates      []predicate.ResourceEvent
}

var _ ent.Mutation = (*ResourceEventMutation)(nil)

// resourceeventOption allows management of the mutation configuration using functional options.
type resourceeventOption func(*ResourceEventMutation)

// newResourceEventMutation creates new mutation for the ResourceEvent entity.
func newResourceEventMutation(c config, op Op, opts ...resourceeventOption) *ResourceEventMutation {
	m := &ResourceEventMutation{
		config:        c,
		op:            op,
		typ:           TypeResourceEvent,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withResourceEventID sets the ID field of the mutation.
func withResourceEventID(id string) resourceeventOption {
	return func(m *ResourceEventMutation) {
		var (
			err   error
			once  sync.Once
			value *ResourceEvent
		)
		m.oldValue = func(ctx context.Context) (*ResourceEvent, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ResourceEvent.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withResourceEvent sets the old ResourceEvent of the mutation.
func withResourceEvent(node *ResourceEvent) resourceeventOption {
	return func(m *ResourceEventMutation) {
		m.oldValue = func(context.Context) (*ResourceEvent, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ResourceEventMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ResourceEventMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ResourceEvent entities.
func (m *ResourceEventMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ResourceEventMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ResourceEventMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ResourceEvent.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetResourceID sets the "resource_id" field.
func (m *ResourceEventMutation) SetResourceID(s string) {
	m.resource = &s
}

// ResourceID returns the value of the "resource_id" field in the mutation.
func (m *ResourceEventMutation) ResourceID() (r string, exists bool) {
	v := m.resource
	if v == nil {
		return
	}
	return *v, true
}

// OldResourceID returns the old "resource_id" field's value of the ResourceEvent entity.
// If the ResourceEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceEventMutation) OldResourceID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResourceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResourceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResourceID: %w", err)
	}
	return oldValue.ResourceID, nil
}

// ResetResourceID resets all changes to the "resource_id" field.
func (m *ResourceEventMutation) ResetResourceID() {
	m.resource = nil
}

// SetEventType sets the "event_type" field.
func (m *ResourceEventMutation) SetEventType(rt resourceevent.EventType) {
	m.event_type = &rt
}

// EventType returns the value of the "event_type" field in the mutation.
func (m *ResourceEventMutation) EventType() (r resourceevent.EventType, exists bool) {
	v := m.event_type
	if v == nil {
		return
	}
	return *v, true
}

// OldEventType returns the old "event_type" field's value of the ResourceEvent entity.
// If the ResourceEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceEventMutation) OldEventType(ctx context.Context) (v resourceevent.EventType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEventType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEventType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEventType: %w", err)
	}
	return oldValue.EventType, nil
}

// ResetEventType resets all changes to the "event_type" field.
func (m *ResourceEventMutation) ResetEventType() {
	m.event_type = nil
}

// SetActor sets the "actor" field.
func (m *ResourceEventMutation) SetActor(s string) {
	m.actor = &s
}

// Actor returns the value of the "actor" field in the mutation.
func (m *ResourceEventMutation) Actor() (r string, exists bool) {
	v := m.actor
	if v == nil {
		return
	}
	return *v, true
}

// OldActor returns the old "actor" field's value of the ResourceEvent entity.
// If the ResourceEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceEventMutation) OldActor(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActor: %w", err)
	}
	return oldValue.Actor, nil
}

// ResetActor resets all changes to the "actor" field.
func (m *ResourceEventMutation) ResetActor() {
	m.actor = nil
}

// SetPreviousState sets the "previous_state" field.
func (m *ResourceEventMutation) SetPreviousState(value map[string]interface{}) {
	m.previous_state = &value
}

// PreviousState returns the value of the "previous_state" field in the mutation.
func (m *ResourceEventMutation) PreviousState() (r map[string]interface{}, exists bool) {
	v := m.previous_state
	if v == nil {
		return
	}
	return *v, true
}

// OldPreviousState returns the old "previous_state" field's value of the ResourceEvent entity.
// If the ResourceEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceEventMutation) OldPreviousState(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPreviousState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPreviousState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPreviousState: %w", err)
	}
	return oldValue.PreviousState, nil
}

// ClearPreviousState clears the value of the "previous_state" field.
func (m *ResourceEventMutation) ClearPreviousState() {
	m.previous_state = nil
	m.clearedFields[resourceevent.FieldPreviousState] = struct{}{}
}

// PreviousStateCleared returns if the "previous_state" field was cleared in this mutation.
func (m *ResourceEventMutation) PreviousStateCleared() bool {
	_, ok := m.clearedFields[resourceevent.FieldPreviousState]
	return ok
}

// ResetPreviousState resets all changes to the "previous_state" field.
func (m *ResourceEventMutation) ResetPreviousState() {
	m.previous_state = nil
	delete(m.clearedFields, resourceevent.FieldPreviousState)
}

// SetNewState sets the "new_state" field.
func (m *ResourceEventMutation) SetNewState(value map[string]interface{}) {
	m.new_state = &value
}

// NewState returns the value of the "new_state" field in the mutation.
func (m *ResourceEventMutation) NewState() (r map[string]interface{}, exists bool) {
	v := m.new_state
	if v == nil {
		return
	}
	return *v, true
}

// OldNewState returns the old "new_state" field's value of the ResourceEvent entity.
// If the ResourceEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceEventMutation) OldNewState(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNewState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNewState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNewState: %w", err)
	}
	return oldValue.NewState, nil
}

// ClearNewState clears the value of the "new_state" field.
func (m *ResourceEventMutation) ClearNewState() {
	m.new_state = nil
	m.clearedFields[resourceevent.FieldNewState] = struct{}{}
}

// NewStateCleared returns if the "new_state" field was cleared in this mutation.
func (m *ResourceEventMutation) NewStateCleared() bool {
	_, ok := m.clearedFields[resourceevent.FieldNewState]
	return ok
}

// ResetNewState resets all changes to the "new_state" field.
func (m *ResourceEventMutation) ResetNewState() {
	m.new_state = nil
	delete(m.clearedFields, resourceevent.FieldNewState)
}

// SetDiff sets the "diff" field.
func (m *ResourceEventMutation) SetDiff(value map[string]interface{}) {
	m.diff = &value
}

// Diff returns the value of the "diff" field in the mutation.
func (m *ResourceEventMutation) Diff() (r map[string]interface{}, exists bool) {
	v := m.diff
	if v == nil {
		return
	}
	return *v, true
}

// OldDiff returns the old "diff" field's value of the ResourceEvent entity.
// If the ResourceEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceEventMutation) OldDiff(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDiff is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDiff requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDiff: %w", err)
	}
	return oldValue.Diff, nil
}

// ClearDiff clears the value of the "diff" field.
func (m *ResourceEventMutation) ClearDiff() {
	m.diff = nil
	m.clearedFields[resourceevent.FieldDiff] = struct{}{}
}

// DiffCleared returns if the "diff" field was cleared in this mutation.
func (m *ResourceEventMutation) DiffCleared() bool {
	_, ok := m.clearedFields[resourceevent.FieldDiff]
	return ok
}

// ResetDiff resets all changes to the "diff" field.
func (m *ResourceEventMutation) ResetDiff() {
	m.diff = nil
	delete(m.clearedFields, resourceevent.FieldDiff)
}

// SetMetadata sets the "metadata" field.
func (m *ResourceEventMutation) SetMetadata(value map[string]interface{}) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *ResourceEventMutation) Metadata() (r map[string]interface{}, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the ResourceEvent entity.
// If the ResourceEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceEventMutation) OldMetadata(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *ResourceEventMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[resourceevent.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *ResourceEventMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[resourceevent.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *ResourceEventMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, resourceevent.FieldMetadata)
}

// SetErrorMessage sets the "error_message" field.
func (m *ResourceEventMutation) SetErrorMessage(s string) {
	m.error_message = &s
}

// ErrorMessage returns the value of the "error_message" field in the mutation.
func (m *ResourceEventMutation) ErrorMessage() (r string, exists bool) {
	v := m.error_message
	if v == nil {
		return
	}
	return *v, true
}

// OldErrorMessage returns the old "error_message" field's value of the ResourceEvent entity.
// If the ResourceEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceEventMutation) OldErrorMessage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldErrorMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldErrorMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldErrorMessage: %w", err)
	}
	return oldValue.ErrorMessage, nil
}

// ClearErrorMessage clears the value of the "error_message" field.
func (m *ResourceEventMutation) ClearErrorMessage() {
	m.error_message = nil
	m.clearedFields[resourceevent.FieldErrorMessage] = struct{}{}
}

// ErrorMessageCleared returns if the "error_message" field was cleared in this mutation.
func (m *ResourceEventMutation) ErrorMessageCleared() bool {
	_, ok := m.clearedFields[resourceevent.FieldErrorMessage]
	return ok
}

// ResetErrorMessage resets all changes to the "error_message" field.
func (m *ResourceEventMutation) ResetErrorMessage() {
	m.error_message = nil
	delete(m.clearedFields, resourceevent.FieldErrorMessage)
}

// SetSource sets the "source" field.
func (m *ResourceEventMutation) SetSource(r resourceevent.Source) {
	m.source = &r
}

// Source returns the value of the "source" field in the mutation.
func (m *ResourceEventMutation) Source() (r resourceevent.Source, exists bool) {
	v := m.source
	if v == nil {
		return
	}
	return *v, true
}

// OldSource returns the old "source" field's value of the ResourceEvent entity.
// If the ResourceEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceEventMutation) OldSource(ctx context.Context) (v resourceevent.Source, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSource is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSource requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSource: %w", err)
	}
	return oldValue.Source, nil
}

// ResetSource resets all changes to the "source" field.
func (m *ResourceEventMutation) ResetSource() {
	m.source = nil
}

// SetReversible sets the "reversible" field.
func (m *ResourceEventMutation) SetReversible(b bool) {
	m.reversible = &b
}

// Reversible returns the value of the "reversible" field in the mutation.
func (m *ResourceEventMutation) Reversible() (r bool, exists bool) {
	v := m.reversible
	if v == nil {
		return
	}
	return *v, true
}

// OldReversible returns the old "reversible" field's value of the ResourceEvent entity.
// If the ResourceEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceEventMutation) OldReversible(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReversible is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReversible requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReversible: %w", err)
	}
	return oldValue.Reversible, nil
}

// ResetReversible resets all changes to the "reversible" field.
func (m *ResourceEventMutation) ResetReversible() {
	m.reversible = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ResourceEventMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ResourceEventMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ResourceEvent entity.
// If the ResourceEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceEventMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ResourceEventMutation) ResetCreatedAt() {
	m.created_at = nil
}

// ClearResource clears the "resource" edge to the Resource entity.
func (m *ResourceEventMutation) ClearResource() {
	m.clearedresource = true
	m.clearedFields[resourceevent.FieldResourceID] = struct{}{}
}

// ResourceCleared reports if the "resource" edge to the Resource entity was cleared.
func (m *ResourceEventMutation) ResourceCleared() bool {
	return m.clearedresource
}

// ResourceIDs returns the "resource" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ResourceID instead. It exists only for internal usage by the builders.
func (m *ResourceEventMutation) ResourceIDs() (ids []string) {
	if id := m.resource; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetResource resets all changes to the "resource" edge.
func (m *ResourceEventMutation) ResetResource() {
	m.resource = nil
	m.clearedresource = false
}

// Where appends a list predicates to the ResourceEventMutation builder.
func (m *ResourceEventMutation) Where(ps ...predicate.ResourceEvent) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ResourceEventMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ResourceEventMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ResourceEvent, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ResourceEventMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ResourceEventMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ResourceEvent).
func (m *ResourceEventMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ResourceEventMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.resource != nil {
		fields = append(fields, resourceevent.FieldResourceID)
	}
	if m.event_type != nil {
		fields = append(fields, resourceevent.FieldEventType)
	}
	if m.actor != nil {
		fields = append(fields, resourceevent.FieldActor)
	}
	if m.previous_state != nil {
		fields = append(fields, resourceevent.FieldPreviousState)
	}
	if m.new_state != nil {
		fields = append(fields, resourceevent.FieldNewState)
	}
	if m.diff != nil {
		fields = append(fields, resourceevent.FieldDiff)
	}
	if m.metadata != nil {
		fields = append(fields, resourceevent.FieldMetadata)
	}
	if m.error_message != nil {
		fields = append(fields, resourceevent.FieldErrorMessage)
	}
	if m.source != nil {
		fields = append(fields, resourceevent.FieldSource)
	}
	if m.reversible != nil {
		fields = append(fields, resourceevent.FieldReversible)
	}
	if m.created_at != nil {
		fields = append(fields, resourceevent.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ResourceEventMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case resourceevent.FieldResourceID:
		return m.ResourceID()
	case resourceevent.FieldEventType:
		return m.EventType()
	case resourceevent.FieldActor:
		return m.Actor()
	case resourceevent.FieldPreviousState:
		return m.PreviousState()
	case resourceevent.FieldNewState:
		return m.NewState()
	case resourceevent.FieldDiff:
		return m.Diff()
	case resourceevent.FieldMetadata:
		return m.Metadata()
	case resourceevent.FieldErrorMessage:
		return m.ErrorMessage()
	case resourceevent.FieldSource:
		return m.Source()
	case resourceevent.FieldReversible:
		return m.Reversible()
	case resourceevent.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ResourceEventMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case resourceevent.FieldResourceID:
		return m.OldResourceID(ctx)
	case resourceevent.FieldEventType:
		return m.OldEventType(ctx)
	case resourceevent.FieldActor:
		return m.OldActor(ctx)
	case resourceevent.FieldPreviousState:
		return m.OldPreviousState(ctx)
	case resourceevent.FieldNewState:
		return m.OldNewState(ctx)
	case resourceevent.FieldDiff:
		return m.OldDiff(ctx)
	case resourceevent.FieldMetadata:
		return m.OldMetadata(ctx)
	case resourceevent.FieldErrorMessage:
		return m.OldErrorMessage(ctx)
	case resourceevent.FieldSource:
		return m.OldSource(ctx)
	case resourceevent.FieldReversible:
		return m.OldReversible(ctx)
	case resourceevent.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown ResourceEvent field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ResourceEventMutation) SetField(name string, value ent.Value) error {
	switch name {
	case resourceevent.FieldResourceID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResourceID(v)
		return nil
	case resourceevent.FieldEventType:
		v, ok := value.(resourceevent.EventType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEventType(v)
		return nil
	case resourceevent.FieldActor:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActor(v)
		return nil
	case resourceevent.FieldPreviousState:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPreviousState(v)
		return nil
	case resourceevent.FieldNewState:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNewState(v)
		return nil
	case resourceevent.FieldDiff:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDiff(v)
		return nil
	case resourceevent.FieldMetadata:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	case resourceevent.FieldErrorMessage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetErrorMessage(v)
		return nil
	case resourceevent.FieldSource:
		v, ok := value.(resourceevent.Source)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSource(v)
		return nil
	case resourceevent.FieldReversible:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReversible(v)
		return nil
	case resourceevent.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown ResourceEvent field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ResourceEventMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ResourceEventMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ResourceEventMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ResourceEvent numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ResourceEventMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(resourceevent.FieldPreviousState) {
		fields = append(fields, resourceevent.FieldPreviousState)
	}
	if m.FieldCleared(resourceevent.FieldNewState) {
		fields = append(fields, resourceevent.FieldNewState)
	}
	if m.FieldCleared(resourceevent.FieldDiff) {
		fields = append(fields, resourceevent.FieldDiff)
	}
	if m.FieldCleared(resourceevent.FieldMetadata) {
		fields = append(fields, resourceevent.FieldMetadata)
	}
	if m.FieldCleared(resourceevent.FieldErrorMessage) {
		fields = append(fields, resourceevent.FieldErrorMessage)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ResourceEventMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ResourceEventMutation) ClearField(name string) error {
	switch name {
	case resourceevent.FieldPreviousState:
		m.ClearPreviousState()
		return nil
	case resourceevent.FieldNewState:
		m.ClearNewState()
		return nil
	case resourceevent.FieldDiff:
		m.ClearDiff()
		return nil
	case resourceevent.FieldMetadata:
		m.ClearMetadata()
		return nil
	case resourceevent.FieldErrorMessage:
		m.ClearErrorMessage()
		return nil
	}
	return fmt.Errorf("unknown ResourceEvent nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ResourceEventMutation) ResetField(name string) error {
	switch name {
	case resourceevent.FieldResourceID:
		m.ResetResourceID()
		return nil
	case resourceevent.FieldEventType:
		m.ResetEventType()
		return nil
	case resourceevent.FieldActor:
		m.ResetActor()
		return nil
	case resourceevent.FieldPreviousState:
		m.ResetPreviousState()
		return nil
	case resourceevent.FieldNewState:
		m.ResetNewState()
		return nil
	case resourceevent.FieldDiff:
		m.ResetDiff()
		return nil
	case resourceevent.FieldMetadata:
		m.ResetMetadata()
		return nil
	case resourceevent.FieldErrorMessage:
		m.ResetErrorMessage()
		return nil
	case resourceevent.FieldSource:
		m.ResetSource()
		return nil
	case resourceevent.FieldReversible:
		m.ResetReversible()
		return nil
	case resourceevent.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown ResourceEvent field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ResourceEventMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.resource != nil {
		edges = append(edges, resourceevent.EdgeResource)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ResourceEventMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case resourceevent.EdgeResource:
		if id := m.resource; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ResourceEventMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ResourceEventMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ResourceEventMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedresource {
		edges = append(edges, resourceevent.EdgeResource)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ResourceEventMutation) EdgeCleared(name string) bool {
	switch name {
	case resourceevent.EdgeResource:
		return m.clearedresource
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ResourceEventMutation) ClearEdge(name string) error {
	switch name {
	case resourceevent.EdgeResource:
		m.ClearResource()
		return nil
	}
	return fmt.Errorf("unknown ResourceEvent unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ResourceEventMutation) ResetEdge(name string) error {
	switch name {
	case resourceevent.EdgeResource:
		m.ResetResource()
		return nil
	}
	return fmt.Errorf("unknown ResourceEvent edge %s", name)
}

// RouterMutation represents an operation that mutates the Router nodes in the graph.
type RouterMutation struct {
	config
	op             Op
	typ            string
	id             *string
	name           *string
	host           *string
	port           *int
	addport        *int
	platform       *router.Platform
	model          *string
	version        *string
	status         *router.Status
	last_seen      *time.Time
	created_at     *time.Time
	updated_at     *time.Time
	clearedFields  map[string]struct{}
	secrets        *string
	clearedsecrets bool
	done           bool
	oldValue       func(context.Context) (*Router, error)
	predicates     []predicate.Router
}

var _ ent.Mutation = (*RouterMutation)(nil)

// routerOption allows management of the mutation configuration using functional options.
type routerOption func(*RouterMutation)

// newRouterMutation creates new mutation for the Router entity.
func newRouterMutation(c config, op Op, opts ...routerOption) *RouterMutation {
	m := &RouterMutation{
		config:        c,
		op:            op,
		typ:           TypeRouter,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRouterID sets the ID field of the mutation.
func withRouterID(id string) routerOption {
	return func(m *RouterMutation) {
		var (
			err   error
			once  sync.Once
			value *Router
		)
		m.oldValue = func(ctx context.Context) (*Router, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Router.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRouter sets the old Router of the mutation.
func withRouter(node *Router) routerOption {
	return func(m *RouterMutation) {
		m.oldValue = func(context.Context) (*Router, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RouterMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RouterMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Router entities.
func (m *RouterMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RouterMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RouterMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Router.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *RouterMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *RouterMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Router entity.
// If the Router object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RouterMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *RouterMutation) ResetName() {
	m.name = nil
}

// SetHost sets the "host" field.
func (m *RouterMutation) SetHost(s string) {
	m.host = &s
}

// Host returns the value of the "host" field in the mutation.
func (m *RouterMutation) Host() (r string, exists bool) {
	v := m.host
	if v == nil {
		return
	}
	return *v, true
}

// OldHost returns the old "host" field's value of the Router entity.
// If the Router object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RouterMutation) OldHost(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHost is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHost requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHost: %w", err)
	}
	return oldValue.Host, nil
}

// ResetHost resets all changes to the "host" field.
func (m *RouterMutation) ResetHost() {
	m.host = nil
}

// SetPort sets the "port" field.
func (m *RouterMutation) SetPort(i int) {
	m.port = &i
	m.addport = nil
}

// Port returns the value of the "port" field in the mutation.
func (m *RouterMutation) Port() (r int, exists bool) {
	v := m.port
	if v == nil {
		return
	}
	return *v, true
}

// OldPort returns the old "port" field's value of the Router entity.
// If the Router object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RouterMutation) OldPort(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPort is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPort requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPort: %w", err)
	}
	return oldValue.Port, nil
}

// AddPort adds i to the "port" field.
func (m *RouterMutation) AddPort(i int) {
	if m.addport != nil {
		*m.addport += i
	} else {
		m.addport = &i
	}
}

// AddedPort returns the value that was added to the "port" field in this mutation.
func (m *RouterMutation) AddedPort() (r int, exists bool) {
	v := m.addport
	if v == nil {
		return
	}
	return *v, true
}

// ResetPort resets all changes to the "port" field.
func (m *RouterMutation) ResetPort() {
	m.port = nil
	m.addport = nil
}

// SetPlatform sets the "platform" field.
func (m *RouterMutation) SetPlatform(r router.Platform) {
	m.platform = &r
}

// Platform returns the value of the "platform" field in the mutation.
func (m *RouterMutation) Platform() (r router.Platform, exists bool) {
	v := m.platform
	if v == nil {
		return
	}
	return *v, true
}

// OldPlatform returns the old "platform" field's value of the Router entity.
// If the Router object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RouterMutation) OldPlatform(ctx context.Context) (v router.Platform, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPlatform is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPlatform requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPlatform: %w", err)
	}
	return oldValue.Platform, nil
}

// ResetPlatform resets all changes to the "platform" field.
func (m *RouterMutation) ResetPlatform() {
	m.platform = nil
}

// SetModel sets the "model" field.
func (m *RouterMutation) SetModel(s string) {
	m.model = &s
}

// Model returns the value of the "model" field in the mutation.
func (m *RouterMutation) Model() (r string, exists bool) {
	v := m.model
	if v == nil {
		return
	}
	return *v, true
}

// OldModel returns the old "model" field's value of the Router entity.
// If the Router object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RouterMutation) OldModel(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldModel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldModel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModel: %w", err)
	}
	return oldValue.Model, nil
}

// ClearModel clears the value of the "model" field.
func (m *RouterMutation) ClearModel() {
	m.model = nil
	m.clearedFields[router.FieldModel] = struct{}{}
}

// ModelCleared returns if the "model" field was cleared in this mutation.
func (m *RouterMutation) ModelCleared() bool {
	_, ok := m.clearedFields[router.FieldModel]
	return ok
}

// ResetModel resets all changes to the "model" field.
func (m *RouterMutation) ResetModel() {
	m.model = nil
	delete(m.clearedFields, router.FieldModel)
}

// SetVersion sets the "version" field.
func (m *RouterMutation) SetVersion(s string) {
	m.version = &s
}

// Version returns the value of the "version" field in the mutation.
func (m *RouterMutation) Version() (r string, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the Router entity.
// If the Router object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RouterMutation) OldVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// ClearVersion clears the value of the "version" field.
func (m *RouterMutation) ClearVersion() {
	m.version = nil
	m.clearedFields[router.FieldVersion] = struct{}{}
}

// VersionCleared returns if the "version" field was cleared in this mutation.
func (m *RouterMutation) VersionCleared() bool {
	_, ok := m.clearedFields[router.FieldVersion]
	return ok
}

// ResetVersion resets all changes to the "version" field.
func (m *RouterMutation) ResetVersion() {
	m.version = nil
	delete(m.clearedFields, router.FieldVersion)
}

// SetStatus sets the "status" field.
func (m *RouterMutation) SetStatus(r router.Status) {
	m.status = &r
}

// Status returns the value of the "status" field in the mutation.
func (m *RouterMutation) Status() (r router.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Router entity.
// If the Router object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RouterMutation) OldStatus(ctx context.Context) (v router.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *RouterMutation) ResetStatus() {
	m.status = nil
}

// SetLastSeen sets the "last_seen" field.
func (m *RouterMutation) SetLastSeen(t time.Time) {
	m.last_seen = &t
}

// LastSeen returns the value of the "last_seen" field in the mutation.
func (m *RouterMutation) LastSeen() (r time.Time, exists bool) {
	v := m.last_seen
	if v == nil {
		return
	}
	return *v, true
}

// OldLastSeen returns the old "last_seen" field's value of the Router entity.
// If the Router object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RouterMutation) OldLastSeen(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastSeen is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastSeen requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastSeen: %w", err)
	}
	return oldValue.LastSeen, nil
}

// ClearLastSeen clears the value of the "last_seen" field.
func (m *RouterMutation) ClearLastSeen() {
	m.last_seen = nil
	m.clearedFields[router.FieldLastSeen] = struct{}{}
}

// LastSeenCleared returns if the "last_seen" field was cleared in this mutation.
func (m *RouterMutation) LastSeenCleared() bool {
	_, ok := m.clearedFields[router.FieldLastSeen]
	return ok
}

// ResetLastSeen resets all changes to the "last_seen" field.
func (m *RouterMutation) ResetLastSeen() {
	m.last_seen = nil
	delete(m.clearedFields, router.FieldLastSeen)
}

// SetCreatedAt sets the "created_at" field.
func (m *RouterMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *RouterMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Router entity.
// If the Router object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RouterMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *RouterMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *RouterMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *RouterMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Router entity.
// If the Router object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RouterMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *RouterMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetSecretsID sets the "secrets" edge to the RouterSecret entity by id.
func (m *RouterMutation) SetSecretsID(id string) {
	m.secrets = &id
}

// ClearSecrets clears the "secrets" edge to the RouterSecret entity.
func (m *RouterMutation) ClearSecrets() {
	m.clearedsecrets = true
}

// SecretsCleared reports if the "secrets" edge to the RouterSecret entity was cleared.
func (m *RouterMutation) SecretsCleared() bool {
	return m.clearedsecrets
}

// SecretsID returns the "secrets" edge ID in the mutation.
func (m *RouterMutation) SecretsID() (id string, exists bool) {
	if m.secrets != nil {
		return *m.secrets, true
	}
	return
}

// SecretsIDs returns the "secrets" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SecretsID instead. It exists only for internal usage by the builders.
func (m *RouterMutation) SecretsIDs() (ids []string) {
	if id := m.secrets; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSecrets resets all changes to the "secrets" edge.
func (m *RouterMutation) ResetSecrets() {
	m.secrets = nil
	m.clearedsecrets = false
}

// Where appends a list predicates to the RouterMutation builder.
func (m *RouterMutation) Where(ps ...predicate.Router) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RouterMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RouterMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Router, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RouterMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RouterMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Router).
func (m *RouterMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RouterMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.name != nil {
		fields = append(fields, router.FieldName)
	}
	if m.host != nil {
		fields = append(fields, router.FieldHost)
	}
	if m.port != nil {
		fields = append(fields, router.FieldPort)
	}
	if m.platform != nil {
		fields = append(fields, router.FieldPlatform)
	}
	if m.model != nil {
		fields = append(fields, router.FieldModel)
	}
	if m.version != nil {
		fields = append(fields, router.FieldVersion)
	}
	if m.status != nil {
		fields = append(fields, router.FieldStatus)
	}
	if m.last_seen != nil {
		fields = append(fields, router.FieldLastSeen)
	}
	if m.created_at != nil {
		fields = append(fields, router.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, router.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RouterMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case router.FieldName:
		return m.Name()
	case router.FieldHost:
		return m.Host()
	case router.FieldPort:
		return m.Port()
	case router.FieldPlatform:
		return m.Platform()
	case router.FieldModel:
		return m.Model()
	case router.FieldVersion:
		return m.Version()
	case router.FieldStatus:
		return m.Status()
	case router.FieldLastSeen:
		return m.LastSeen()
	case router.FieldCreatedAt:
		return m.CreatedAt()
	case router.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RouterMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case router.FieldName:
		return m.OldName(ctx)
	case router.FieldHost:
		return m.OldHost(ctx)
	case router.FieldPort:
		return m.OldPort(ctx)
	case router.FieldPlatform:
		return m.OldPlatform(ctx)
	case router.FieldModel:
		return m.OldModel(ctx)
	case router.FieldVersion:
		return m.OldVersion(ctx)
	case router.FieldStatus:
		return m.OldStatus(ctx)
	case router.FieldLastSeen:
		return m.OldLastSeen(ctx)
	case router.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case router.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Router field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RouterMutation) SetField(name string, value ent.Value) error {
	switch name {
	case router.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case router.FieldHost:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHost(v)
		return nil
	case router.FieldPort:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPort(v)
		return nil
	case router.FieldPlatform:
		v, ok := value.(router.Platform)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPlatform(v)
		return nil
	case router.FieldModel:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModel(v)
		return nil
	case router.FieldVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case router.FieldStatus:
		v, ok := value.(router.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case router.FieldLastSeen:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastSeen(v)
		return nil
	case router.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case router.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Router field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RouterMutation) AddedFields() []string {
	var fields []string
	if m.addport != nil {
		fields = append(fields, router.FieldPort)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RouterMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case router.FieldPort:
		return m.AddedPort()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RouterMutation) AddField(name string, value ent.Value) error {
	switch name {
	case router.FieldPort:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPort(v)
		return nil
	}
	return fmt.Errorf("unknown Router numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RouterMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(router.FieldModel) {
		fields = append(fields, router.FieldModel)
	}
	if m.FieldCleared(router.FieldVersion) {
		fields = append(fields, router.FieldVersion)
	}
	if m.FieldCleared(router.FieldLastSeen) {
		fields = append(fields, router.FieldLastSeen)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RouterMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RouterMutation) ClearField(name string) error {
	switch name {
	case router.FieldModel:
		m.ClearModel()
		return nil
	case router.FieldVersion:
		m.ClearVersion()
		return nil
	case router.FieldLastSeen:
		m.ClearLastSeen()
		return nil
	}
	return fmt.Errorf("unknown Router nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RouterMutation) ResetField(name string) error {
	switch name {
	case router.FieldName:
		m.ResetName()
		return nil
	case router.FieldHost:
		m.ResetHost()
		return nil
	case router.FieldPort:
		m.ResetPort()
		return nil
	case router.FieldPlatform:
		m.ResetPlatform()
		return nil
	case router.FieldModel:
		m.ResetModel()
		return nil
	case router.FieldVersion:
		m.ResetVersion()
		return nil
	case router.FieldStatus:
		m.ResetStatus()
		return nil
	case router.FieldLastSeen:
		m.ResetLastSeen()
		return nil
	case router.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case router.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Router field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RouterMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.secrets != nil {
		edges = append(edges, router.EdgeSecrets)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RouterMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case router.EdgeSecrets:
		if id := m.secrets; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RouterMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RouterMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RouterMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedsecrets {
		edges = append(edges, router.EdgeSecrets)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RouterMutation) EdgeCleared(name string) bool {
	switch name {
	case router.EdgeSecrets:
		return m.clearedsecrets
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RouterMutation) ClearEdge(name string) error {
	switch name {
	case router.EdgeSecrets:
		m.ClearSecrets()
		return nil
	}
	return fmt.Errorf("unknown Router unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RouterMutation) ResetEdge(name string) error {
	switch name {
	case router.EdgeSecrets:
		m.ResetSecrets()
		return nil
	}
	return fmt.Errorf("unknown Router edge %s", name)
}

// RouterCapabilityMutation represents an operation that mutates the RouterCapability nodes in the graph.
type RouterCapabilityMutation struct {
	config
	op                             Op
	typ                            string
	id                             *string
	architecture                   *string
	model                          *string
	board_name                     *string
	total_memory                   *int64
	addtotal_memory                *int64
	available_storage              *int64
	addavailable_storage           *int64
	cpu_count                      *int
	addcpu_count                   *int
	has_wireless_chip              *bool
	has_lte_module                 *bool
	version_raw                    *string
	version_major                  *int
	addversion_major               *int
	version_minor                  *int
	addversion_minor               *int
	version_patch                  *int
	addversion_patch               *int
	installed_packages             *[]string
	appendinstalled_packages       []string
	license_level                  *int
	addlicense_level               *int
	update_channel                 *string
	container_package_installed    *bool
	container_enabled              *bool
	container_registry_configured  *bool
	container_storage_available    *int64
	addcontainer_storage_available *int64
	supports_network_namespace     *bool
	max_containers                 *int
	addmax_containers              *int
	capability_entries             *map[string]interface{}
	detected_at                    *time.Time
	expires_at                     *time.Time
	is_refreshing                  *bool
	created_at                     *time.Time
	updated_at                     *time.Time
	clearedFields                  map[string]struct{}
	done                           bool
	oldValue                       func(context.Context) (*RouterCapability, error)
	predicates                     []predicate.RouterCapability
}

var _ ent.Mutation = (*RouterCapabilityMutation)(nil)

// routercapabilityOption allows management of the mutation configuration using functional options.
type routercapabilityOption func(*RouterCapabilityMutation)

// newRouterCapabilityMutation creates new mutation for the RouterCapability entity.
func newRouterCapabilityMutation(c config, op Op, opts ...routercapabilityOption) *RouterCapabilityMutation {
	m := &RouterCapabilityMutation{
		config:        c,
		op:            op,
		typ:           TypeRouterCapability,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRouterCapabilityID sets the ID field of the mutation.
func withRouterCapabilityID(id string) routercapabilityOption {
	return func(m *RouterCapabilityMutation) {
		var (
			err   error
			once  sync.Once
			value *RouterCapability
		)
		m.oldValue = func(ctx context.Context) (*RouterCapability, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().RouterCapability.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRouterCapability sets the old RouterCapability of the mutation.
func withRouterCapability(node *RouterCapability) routercapabilityOption {
	return func(m *RouterCapabilityMutation) {
		m.oldValue = func(context.Context) (*RouterCapability, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RouterCapabilityMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RouterCapabilityMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of RouterCapability entities.
func (m *RouterCapabilityMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RouterCapabilityMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RouterCapabilityMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().RouterCapability.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetArchitecture sets the "architecture" field.
func (m *RouterCapabilityMutation) SetArchitecture(s string) {
	m.architecture = &s
}

// Architecture returns the value of the "architecture" field in the mutation.
func (m *RouterCapabilityMutation) Architecture() (r string, exists bool) {
	v := m.architecture
	if v == nil {
		return
	}
	return *v, true
}

// OldArchitecture returns the old "architecture" field's value of the RouterCapability entity.
// If the RouterCapability object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RouterCapabilityMutation) OldArchitecture(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldArchitecture is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldArchitecture requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldArchitecture: %w", err)
	}
	return oldValue.Architecture, nil
}

// ResetArchitecture resets all changes to the "architecture" field.
func (m *RouterCapabilityMutation) ResetArchitecture() {
	m.architecture = nil
}

// SetModel sets the "model" field.
func (m *RouterCapabilityMutation) SetModel(s string) {
	m.model = &s
}

// Model returns the value of the "model" field in the mutation.
func (m *RouterCapabilityMutation) Model() (r string, exists bool) {
	v := m.model
	if v == nil {
		return
	}
	return *v, true
}

// OldModel returns the old "model" field's value of the RouterCapability entity.
// If the RouterCapability object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RouterCapabilityMutation) OldModel(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldModel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldModel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModel: %w", err)
	}
	return oldValue.Model, nil
}

// ClearModel clears the value of the "model" field.
func (m *RouterCapabilityMutation) ClearModel() {
	m.model = nil
	m.clearedFields[routercapability.FieldModel] = struct{}{}
}

// ModelCleared returns if the "model" field was cleared in this mutation.
func (m *RouterCapabilityMutation) ModelCleared() bool {
	_, ok := m.clearedFields[routercapability.FieldModel]
	return ok
}

// ResetModel resets all changes to the "model" field.
func (m *RouterCapabilityMutation) ResetModel() {
	m.model = nil
	delete(m.clearedFields, routercapability.FieldModel)
}

// SetBoardName sets the "board_name" field.
func (m *RouterCapabilityMutation) SetBoardName(s string) {
	m.board_name = &s
}

// BoardName returns the value of the "board_name" field in the mutation.
func (m *RouterCapabilityMutation) BoardName() (r string, exists bool) {
	v := m.board_name
	if v == nil {
		return
	}
	return *v, true
}

// OldBoardName returns the old "board_name" field's value of the RouterCapability entity.
// If the RouterCapability object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RouterCapabilityMutation) OldBoardName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBoardName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBoardName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBoardName: %w", err)
	}
	return oldValue.BoardName, nil
}

// ClearBoardName clears the value of the "board_name" field.
func (m *RouterCapabilityMutation) ClearBoardName() {
	m.board_name = nil
	m.clearedFields[routercapability.FieldBoardName] = struct{}{}
}

// BoardNameCleared returns if the "board_name" field was cleared in this mutation.
func (m *RouterCapabilityMutation) BoardNameCleared() bool {
	_, ok := m.clearedFields[routercapability.FieldBoardName]
	return ok
}

// ResetBoardName resets all changes to the "board_name" field.
func (m *RouterCapabilityMutation) ResetBoardName() {
	m.board_name = nil
	delete(m.clearedFields, routercapability.FieldBoardName)
}

// SetTotalMemory sets the "total_memory" field.
func (m *RouterCapabilityMutation) SetTotalMemory(i int64) {
	m.total_memory = &i
	m.addtotal_memory = nil
}

// TotalMemory returns the value of the "total_memory" field in the mutation.
func (m *RouterCapabilityMutation) TotalMemory() (r int64, exists bool) {
	v := m.total_memory
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalMemory returns the old "total_memory" field's value of the RouterCapability entity.
// If the RouterCapability object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RouterCapabilityMutation) OldTotalMemory(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalMemory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalMemory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalMemory: %w", err)
	}
	return oldValue.TotalMemory, nil
}

// AddTotalMemory adds i to the "total_memory" field.
func (m *RouterCapabilityMutation) AddTotalMemory(i int64) {
	if m.addtotal_memory != nil {
		*m.addtotal_memory += i
	} else {
		m.addtotal_memory = &i
	}
}

// AddedTotalMemory returns the value that was added to the "total_memory" field in this mutation.
func (m *RouterCapabilityMutation) AddedTotalMemory() (r int64, exists bool) {
	v := m.addtotal_memory
	if v == nil {
		return
	}
	return *v, true
}

// ResetTotalMemory resets all changes to the "total_memory" field.
func (m *RouterCapabilityMutation) ResetTotalMemory() {
	m.total_memory = nil
	m.addtotal_memory = nil
}

// SetAvailableStorage sets the "available_storage" field.
func (m *RouterCapabilityMutation) SetAvailableStorage(i int64) {
	m.available_storage = &i
	m.addavailable_storage = nil
}

// AvailableStorage returns the value of the "available_storage" field in the mutation.
func (m *RouterCapabilityMutation) AvailableStorage() (r int64, exists bool) {
	v := m.available_storage
	if v == nil {
		return
	}
	return *v, true
}

// OldAvailableStorage returns the old "available_storage" field's value of the RouterCapability entity.
// If the RouterCapability object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RouterCapabilityMutation) OldAvailableStorage(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAvailableStorage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAvailableStorage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAvailableStorage: %w", err)
	}
	return oldValue.AvailableStorage, nil
}

// AddAvailableStorage adds i to the "available_storage" field.
func (m *RouterCapabilityMutation) AddAvailableStorage(i int64) {
	if m.addavailable_storage != nil {
		*m.addavailable_storage += i
	} else {
		m.addavailable_storage = &i
	}
}

// AddedAvailableStorage returns the value that was added to the "available_storage" field in this mutation.
func (m *RouterCapabilityMutation) AddedAvailableStorage() (r int64, exists bool) {
	v := m.addavailable_storage
	if v == nil {
		return
	}
	return *v, true
}

// ResetAvailableStorage resets all changes to the "available_storage" field.
func (m *RouterCapabilityMutation) ResetAvailableStorage() {
	m.available_storage = nil
	m.addavailable_storage = nil
}

// SetCPUCount sets the "cpu_count" field.
func (m *RouterCapabilityMutation) SetCPUCount(i int) {
	m.cpu_count = &i
	m.addcpu_count = nil
}

// CPUCount returns the value of the "cpu_count" field in the mutation.
func (m *RouterCapabilityMutation) CPUCount() (r int, exists bool) {
	v := m.cpu_count
	if v == nil {
		return
	}
	return *v, true
}

// OldCPUCount returns the old "cpu_count" field's value of the RouterCapability entity.
// If the RouterCapability object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RouterCapabilityMutation) OldCPUCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCPUCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCPUCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCPUCount: %w", err)
	}
	return oldValue.CPUCount, nil
}

// AddCPUCount adds i to the "cpu_count" field.
func (m *RouterCapabilityMutation) AddCPUCount(i int) {
	if m.addcpu_count != nil {
		*m.addcpu_count += i
	} else {
		m.addcpu_count = &i
	}
}

// AddedCPUCount returns the value that was added to the "cpu_count" field in this mutation.
func (m *RouterCapabilityMutation) AddedCPUCount() (r int, exists bool) {
	v := m.addcpu_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetCPUCount resets all changes to the "cpu_count" field.
func (m *RouterCapabilityMutation) ResetCPUCount() {
	m.cpu_count = nil
	m.addcpu_count = nil
}

// SetHasWirelessChip sets the "has_wireless_chip" field.
func (m *RouterCapabilityMutation) SetHasWirelessChip(b bool) {
	m.has_wireless_chip = &b
}

// HasWirelessChip returns the value of the "has_wireless_chip" field in the mutation.
func (m *RouterCapabilityMutation) HasWirelessChip() (r bool, exists bool) {
	v := m.has_wireless_chip
	if v == nil {
		return
	}
	return *v, true
}

// OldHasWirelessChip returns the old "has_wireless_chip" field's value of the RouterCapability entity.
// If the RouterCapability object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RouterCapabilityMutation) OldHasWirelessChip(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHasWirelessChip is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHasWirelessChip requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHasWirelessChip: %w", err)
	}
	return oldValue.HasWirelessChip, nil
}

// ResetHasWirelessChip resets all changes to the "has_wireless_chip" field.
func (m *RouterCapabilityMutation) ResetHasWirelessChip() {
	m.has_wireless_chip = nil
}

// SetHasLteModule sets the "has_lte_module" field.
func (m *RouterCapabilityMutation) SetHasLteModule(b bool) {
	m.has_lte_module = &b
}

// HasLteModule returns the value of the "has_lte_module" field in the mutation.
func (m *RouterCapabilityMutation) HasLteModule() (r bool, exists bool) {
	v := m.has_lte_module
	if v == nil {
		return
	}
	return *v, true
}

// OldHasLteModule returns the old "has_lte_module" field's value of the RouterCapability entity.
// If the RouterCapability object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RouterCapabilityMutation) OldHasLteModule(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHasLteModule is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHasLteModule requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHasLteModule: %w", err)
	}
	return oldValue.HasLteModule, nil
}

// ResetHasLteModule resets all changes to the "has_lte_module" field.
func (m *RouterCapabilityMutation) ResetHasLteModule() {
	m.has_lte_module = nil
}

// SetVersionRaw sets the "version_raw" field.
func (m *RouterCapabilityMutation) SetVersionRaw(s string) {
	m.version_raw = &s
}

// VersionRaw returns the value of the "version_raw" field in the mutation.
func (m *RouterCapabilityMutation) VersionRaw() (r string, exists bool) {
	v := m.version_raw
	if v == nil {
		return
	}
	return *v, true
}

// OldVersionRaw returns the old "version_raw" field's value of the RouterCapability entity.
// If the RouterCapability object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RouterCapabilityMutation) OldVersionRaw(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersionRaw is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersionRaw requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersionRaw: %w", err)
	}
	return oldValue.VersionRaw, nil
}

// ResetVersionRaw resets all changes to the "version_raw" field.
func (m *RouterCapabilityMutation) ResetVersionRaw() {
	m.version_raw = nil
}

// SetVersionMajor sets the "version_major" field.
func (m *RouterCapabilityMutation) SetVersionMajor(i int) {
	m.version_major = &i
	m.addversion_major = nil
}

// VersionMajor returns the value of the "version_major" field in the mutation.
func (m *RouterCapabilityMutation) VersionMajor() (r int, exists bool) {
	v := m.version_major
	if v == nil {
		return
	}
	return *v, true
}

// OldVersionMajor returns the old "version_major" field's value of the RouterCapability entity.
// If the RouterCapability object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RouterCapabilityMutation) OldVersionMajor(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersionMajor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersionMajor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersionMajor: %w", err)
	}
	return oldValue.VersionMajor, nil
}

// AddVersionMajor adds i to the "version_major" field.
func (m *RouterCapabilityMutation) AddVersionMajor(i int) {
	if m.addversion_major != nil {
		*m.addversion_major += i
	} else {
		m.addversion_major = &i
	}
}

// AddedVersionMajor returns the value that was added to the "version_major" field in this mutation.
func (m *RouterCapabilityMutation) AddedVersionMajor() (r int, exists bool) {
	v := m.addversion_major
	if v == nil {
		return
	}
	return *v, true
}

// ResetVersionMajor resets all changes to the "version_major" field.
func (m *RouterCapabilityMutation) ResetVersionMajor() {
	m.version_major = nil
	m.addversion_major = nil
}

// SetVersionMinor sets the "version_minor" field.
func (m *RouterCapabilityMutation) SetVersionMinor(i int) {
	m.version_minor = &i
	m.addversion_minor = nil
}

// VersionMinor returns the value of the "version_minor" field in the mutation.
func (m *RouterCapabilityMutation) VersionMinor() (r int, exists bool) {
	v := m.version_minor
	if v == nil {
		return
	}
	return *v, true
}

// OldVersionMinor returns the old "version_minor" field's value of the RouterCapability entity.
// If the RouterCapability object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RouterCapabilityMutation) OldVersionMinor(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersionMinor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersionMinor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersionMinor: %w", err)
	}
	return oldValue.VersionMinor, nil
}

// AddVersionMinor adds i to the "version_minor" field.
func (m *RouterCapabilityMutation) AddVersionMinor(i int) {
	if m.addversion_minor != nil {
		*m.addversion_minor += i
	} else {
		m.addversion_minor = &i
	}
}

// AddedVersionMinor returns the value that was added to the "version_minor" field in this mutation.
func (m *RouterCapabilityMutation) AddedVersionMinor() (r int, exists bool) {
	v := m.addversion_minor
	if v == nil {
		return
	}
	return *v, true
}

// ResetVersionMinor resets all changes to the "version_minor" field.
func (m *RouterCapabilityMutation) ResetVersionMinor() {
	m.version_minor = nil
	m.addversion_minor = nil
}

// SetVersionPatch sets the "version_patch" field.
func (m *RouterCapabilityMutation) SetVersionPatch(i int) {
	m.version_patch = &i
	m.addversion_patch = nil
}

// VersionPatch returns the value of the "version_patch" field in the mutation.
func (m *RouterCapabilityMutation) VersionPatch() (r int, exists bool) {
	v := m.version_patch
	if v == nil {
		return
	}
	return *v, true
}

// OldVersionPatch returns the old "version_patch" field's value of the RouterCapability entity.
// If the RouterCapability object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RouterCapabilityMutation) OldVersionPatch(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersionPatch is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersionPatch requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersionPatch: %w", err)
	}
	return oldValue.VersionPatch, nil
}

// AddVersionPatch adds i to the "version_patch" field.
func (m *RouterCapabilityMutation) AddVersionPatch(i int) {
	if m.addversion_patch != nil {
		*m.addversion_patch += i
	} else {
		m.addversion_patch = &i
	}
}

// AddedVersionPatch returns the value that was added to the "version_patch" field in this mutation.
func (m *RouterCapabilityMutation) AddedVersionPatch() (r int, exists bool) {
	v := m.addversion_patch
	if v == nil {
		return
	}
	return *v, true
}

// ResetVersionPatch resets all changes to the "version_patch" field.
func (m *RouterCapabilityMutation) ResetVersionPatch() {
	m.version_patch = nil
	m.addversion_patch = nil
}

// SetInstalledPackages sets the "installed_packages" field.
func (m *RouterCapabilityMutation) SetInstalledPackages(s []string) {
	m.installed_packages = &s
	m.appendinstalled_packages = nil
}

// InstalledPackages returns the value of the "installed_packages" field in the mutation.
func (m *RouterCapabilityMutation) InstalledPackages() (r []string, exists bool) {
	v := m.installed_packages
	if v == nil {
		return
	}
	return *v, true
}

// OldInstalledPackages returns the old "installed_packages" field's value of the RouterCapability entity.
// If the RouterCapability object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RouterCapabilityMutation) OldInstalledPackages(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInstalledPackages is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInstalledPackages requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInstalledPackages: %w", err)
	}
	return oldValue.InstalledPackages, nil
}

// AppendInstalledPackages adds s to the "installed_packages" field.
func (m *RouterCapabilityMutation) AppendInstalledPackages(s []string) {
	m.appendinstalled_packages = append(m.appendinstalled_packages, s...)
}

// AppendedInstalledPackages returns the list of values that were appended to the "installed_packages" field in this mutation.
func (m *RouterCapabilityMutation) AppendedInstalledPackages() ([]string, bool) {
	if len(m.appendinstalled_packages) == 0 {
		return nil, false
	}
	return m.appendinstalled_packages, true
}

// ResetInstalledPackages resets all changes to the "installed_packages" field.
func (m *RouterCapabilityMutation) ResetInstalledPackages() {
	m.installed_packages = nil
	m.appendinstalled_packages = nil
}

// SetLicenseLevel sets the "license_level" field.
func (m *RouterCapabilityMutation) SetLicenseLevel(i int) {
	m.license_level = &i
	m.addlicense_level = nil
}

// LicenseLevel returns the value of the "license_level" field in the mutation.
func (m *RouterCapabilityMutation) LicenseLevel() (r int, exists bool) {
	v := m.license_level
	if v == nil {
		return
	}
	return *v, true
}

// OldLicenseLevel returns the old "license_level" field's value of the RouterCapability entity.
// If the RouterCapability object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RouterCapabilityMutation) OldLicenseLevel(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLicenseLevel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLicenseLevel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLicenseLevel: %w", err)
	}
	return oldValue.LicenseLevel, nil
}

// AddLicenseLevel adds i to the "license_level" field.
func (m *RouterCapabilityMutation) AddLicenseLevel(i int) {
	if m.addlicense_level != nil {
		*m.addlicense_level += i
	} else {
		m.addlicense_level = &i
	}
}

// AddedLicenseLevel returns the value that was added to the "license_level" field in this mutation.
func (m *RouterCapabilityMutation) AddedLicenseLevel() (r int, exists bool) {
	v := m.addlicense_level
	if v == nil {
		return
	}
	return *v, true
}

// ResetLicenseLevel resets all changes to the "license_level" field.
func (m *RouterCapabilityMutation) ResetLicenseLevel() {
	m.license_level = nil
	m.addlicense_level = nil
}

// SetUpdateChannel sets the "update_channel" field.
func (m *RouterCapabilityMutation) SetUpdateChannel(s string) {
	m.update_channel = &s
}

// UpdateChannel returns the value of the "update_channel" field in the mutation.
func (m *RouterCapabilityMutation) UpdateChannel() (r string, exists bool) {
	v := m.update_channel
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateChannel returns the old "update_channel" field's value of the RouterCapability entity.
// If the RouterCapability object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RouterCapabilityMutation) OldUpdateChannel(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateChannel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateChannel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateChannel: %w", err)
	}
	return oldValue.UpdateChannel, nil
}

// ClearUpdateChannel clears the value of the "update_channel" field.
func (m *RouterCapabilityMutation) ClearUpdateChannel() {
	m.update_channel = nil
	m.clearedFields[routercapability.FieldUpdateChannel] = struct{}{}
}

// UpdateChannelCleared returns if the "update_channel" field was cleared in this mutation.
func (m *RouterCapabilityMutation) UpdateChannelCleared() bool {
	_, ok := m.clearedFields[routercapability.FieldUpdateChannel]
	return ok
}

// ResetUpdateChannel resets all changes to the "update_channel" field.
func (m *RouterCapabilityMutation) ResetUpdateChannel() {
	m.update_channel = nil
	delete(m.clearedFields, routercapability.FieldUpdateChannel)
}

// SetContainerPackageInstalled sets the "container_package_installed" field.
func (m *RouterCapabilityMutation) SetContainerPackageInstalled(b bool) {
	m.container_package_installed = &b
}

// ContainerPackageInstalled returns the value of the "container_package_installed" field in the mutation.
func (m *RouterCapabilityMutation) ContainerPackageInstalled() (r bool, exists bool) {
	v := m.container_package_installed
	if v == nil {
		return
	}
	return *v, true
}

// OldContainerPackageInstalled returns the old "container_package_installed" field's value of the RouterCapability entity.
// If the RouterCapability object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RouterCapabilityMutation) OldContainerPackageInstalled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContainerPackageInstalled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContainerPackageInstalled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContainerPackageInstalled: %w", err)
	}
	return oldValue.ContainerPackageInstalled, nil
}

// ResetContainerPackageInstalled resets all changes to the "container_package_installed" field.
func (m *RouterCapabilityMutation) ResetContainerPackageInstalled() {
	m.container_package_installed = nil
}

// SetContainerEnabled sets the "container_enabled" field.
func (m *RouterCapabilityMutation) SetContainerEnabled(b bool) {
	m.container_enabled = &b
}

// ContainerEnabled returns the value of the "container_enabled" field in the mutation.
func (m *RouterCapabilityMutation) ContainerEnabled() (r bool, exists bool) {
	v := m.container_enabled
	if v == nil {
		return
	}
	return *v, true
}

// OldContainerEnabled returns the old "container_enabled" field's value of the RouterCapability entity.
// If the RouterCapability object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RouterCapabilityMutation) OldContainerEnabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContainerEnabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContainerEnabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContainerEnabled: %w", err)
	}
	return oldValue.ContainerEnabled, nil
}

// ResetContainerEnabled resets all changes to the "container_enabled" field.
func (m *RouterCapabilityMutation) ResetContainerEnabled() {
	m.container_enabled = nil
}

// SetContainerRegistryConfigured sets the "container_registry_configured" field.
func (m *RouterCapabilityMutation) SetContainerRegistryConfigured(b bool) {
	m.container_registry_configured = &b
}

// ContainerRegistryConfigured returns the value of the "container_registry_configured" field in the mutation.
func (m *RouterCapabilityMutation) ContainerRegistryConfigured() (r bool, exists bool) {
	v := m.container_registry_configured
	if v == nil {
		return
	}
	return *v, true
}

// OldContainerRegistryConfigured returns the old "container_registry_configured" field's value of the RouterCapability entity.
// If the RouterCapability object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RouterCapabilityMutation) OldContainerRegistryConfigured(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContainerRegistryConfigured is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContainerRegistryConfigured requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContainerRegistryConfigured: %w", err)
	}
	return oldValue.ContainerRegistryConfigured, nil
}

// ResetContainerRegistryConfigured resets all changes to the "container_registry_configured" field.
func (m *RouterCapabilityMutation) ResetContainerRegistryConfigured() {
	m.container_registry_configured = nil
}

// SetContainerStorageAvailable sets the "container_storage_available" field.
func (m *RouterCapabilityMutation) SetContainerStorageAvailable(i int64) {
	m.container_storage_available = &i
	m.addcontainer_storage_available = nil
}

// ContainerStorageAvailable returns the value of the "container_storage_available" field in the mutation.
func (m *RouterCapabilityMutation) ContainerStorageAvailable() (r int64, exists bool) {
	v := m.container_storage_available
	if v == nil {
		return
	}
	return *v, true
}

// OldContainerStorageAvailable returns the old "container_storage_available" field's value of the RouterCapability entity.
// If the RouterCapability object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RouterCapabilityMutation) OldContainerStorageAvailable(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContainerStorageAvailable is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContainerStorageAvailable requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContainerStorageAvailable: %w", err)
	}
	return oldValue.ContainerStorageAvailable, nil
}

// AddContainerStorageAvailable adds i to the "container_storage_available" field.
func (m *RouterCapabilityMutation) AddContainerStorageAvailable(i int64) {
	if m.addcontainer_storage_available != nil {
		*m.addcontainer_storage_available += i
	} else {
		m.addcontainer_storage_available = &i
	}
}

// AddedContainerStorageAvailable returns the value that was added to the "container_storage_available" field in this mutation.
func (m *RouterCapabilityMutation) AddedContainerStorageAvailable() (r int64, exists bool) {
	v := m.addcontainer_storage_available
	if v == nil {
		return
	}
	return *v, true
}

// ResetContainerStorageAvailable resets all changes to the "container_storage_available" field.
func (m *RouterCapabilityMutation) ResetContainerStorageAvailable() {
	m.container_storage_available = nil
	m.addcontainer_storage_available = nil
}

// SetSupportsNetworkNamespace sets the "supports_network_namespace" field.
func (m *RouterCapabilityMutation) SetSupportsNetworkNamespace(b bool) {
	m.supports_network_namespace = &b
}

// SupportsNetworkNamespace returns the value of the "supports_network_namespace" field in the mutation.
func (m *RouterCapabilityMutation) SupportsNetworkNamespace() (r bool, exists bool) {
	v := m.supports_network_namespace
	if v == nil {
		return
	}
	return *v, true
}

// OldSupportsNetworkNamespace returns the old "supports_network_namespace" field's value of the RouterCapability entity.
// If the RouterCapability object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RouterCapabilityMutation) OldSupportsNetworkNamespace(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSupportsNetworkNamespace is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSupportsNetworkNamespace requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSupportsNetworkNamespace: %w", err)
	}
	return oldValue.SupportsNetworkNamespace, nil
}

// ResetSupportsNetworkNamespace resets all changes to the "supports_network_namespace" field.
func (m *RouterCapabilityMutation) ResetSupportsNetworkNamespace() {
	m.supports_network_namespace = nil
}

// SetMaxContainers sets the "max_containers" field.
func (m *RouterCapabilityMutation) SetMaxContainers(i int) {
	m.max_containers = &i
	m.addmax_containers = nil
}

// MaxContainers returns the value of the "max_containers" field in the mutation.
func (m *RouterCapabilityMutation) MaxContainers() (r int, exists bool) {
	v := m.max_containers
	if v == nil {
		return
	}
	return *v, true
}

// OldMaxContainers returns the old "max_containers" field's value of the RouterCapability entity.
// If the RouterCapability object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RouterCapabilityMutation) OldMaxContainers(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMaxContainers is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMaxContainers requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaxContainers: %w", err)
	}
	return oldValue.MaxContainers, nil
}

// AddMaxContainers adds i to the "max_containers" field.
func (m *RouterCapabilityMutation) AddMaxContainers(i int) {
	if m.addmax_containers != nil {
		*m.addmax_containers += i
	} else {
		m.addmax_containers = &i
	}
}

// AddedMaxContainers returns the value that was added to the "max_containers" field in this mutation.
func (m *RouterCapabilityMutation) AddedMaxContainers() (r int, exists bool) {
	v := m.addmax_containers
	if v == nil {
		return
	}
	return *v, true
}

// ResetMaxContainers resets all changes to the "max_containers" field.
func (m *RouterCapabilityMutation) ResetMaxContainers() {
	m.max_containers = nil
	m.addmax_containers = nil
}

// SetCapabilityEntries sets the "capability_entries" field.
func (m *RouterCapabilityMutation) SetCapabilityEntries(value map[string]interface{}) {
	m.capability_entries = &value
}

// CapabilityEntries returns the value of the "capability_entries" field in the mutation.
func (m *RouterCapabilityMutation) CapabilityEntries() (r map[string]interface{}, exists bool) {
	v := m.capability_entries
	if v == nil {
		return
	}
	return *v, true
}

// OldCapabilityEntries returns the old "capability_entries" field's value of the RouterCapability entity.
// If the RouterCapability object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RouterCapabilityMutation) OldCapabilityEntries(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCapabilityEntries is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCapabilityEntries requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCapabilityEntries: %w", err)
	}
	return oldValue.CapabilityEntries, nil
}

// ResetCapabilityEntries resets all changes to the "capability_entries" field.
func (m *RouterCapabilityMutation) ResetCapabilityEntries() {
	m.capability_entries = nil
}

// SetDetectedAt sets the "detected_at" field.
func (m *RouterCapabilityMutation) SetDetectedAt(t time.Time) {
	m.detected_at = &t
}

// DetectedAt returns the value of the "detected_at" field in the mutation.
func (m *RouterCapabilityMutation) DetectedAt() (r time.Time, exists bool) {
	v := m.detected_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDetectedAt returns the old "detected_at" field's value of the RouterCapability entity.
// If the RouterCapability object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RouterCapabilityMutation) OldDetectedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDetectedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDetectedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDetectedAt: %w", err)
	}
	return oldValue.DetectedAt, nil
}

// ResetDetectedAt resets all changes to the "detected_at" field.
func (m *RouterCapabilityMutation) ResetDetectedAt() {
	m.detected_at = nil
}

// SetExpiresAt sets the "expires_at" field.
func (m *RouterCapabilityMutation) SetExpiresAt(t time.Time) {
	m.expires_at = &t
}

// ExpiresAt returns the value of the "expires_at" field in the mutation.
func (m *RouterCapabilityMutation) ExpiresAt() (r time.Time, exists bool) {
	v := m.expires_at
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiresAt returns the old "expires_at" field's value of the RouterCapability entity.
// If the RouterCapability object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RouterCapabilityMutation) OldExpiresAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiresAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiresAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiresAt: %w", err)
	}
	return oldValue.ExpiresAt, nil
}

// ResetExpiresAt resets all changes to the "expires_at" field.
func (m *RouterCapabilityMutation) ResetExpiresAt() {
	m.expires_at = nil
}

// SetIsRefreshing sets the "is_refreshing" field.
func (m *RouterCapabilityMutation) SetIsRefreshing(b bool) {
	m.is_refreshing = &b
}

// IsRefreshing returns the value of the "is_refreshing" field in the mutation.
func (m *RouterCapabilityMutation) IsRefreshing() (r bool, exists bool) {
	v := m.is_refreshing
	if v == nil {
		return
	}
	return *v, true
}

// OldIsRefreshing returns the old "is_refreshing" field's value of the RouterCapability entity.
// If the RouterCapability object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RouterCapabilityMutation) OldIsRefreshing(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsRefreshing is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsRefreshing requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsRefreshing: %w", err)
	}
	return oldValue.IsRefreshing, nil
}

// ResetIsRefreshing resets all changes to the "is_refreshing" field.
func (m *RouterCapabilityMutation) ResetIsRefreshing() {
	m.is_refreshing = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *RouterCapabilityMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *RouterCapabilityMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the RouterCapability entity.
// If the RouterCapability object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RouterCapabilityMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *RouterCapabilityMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *RouterCapabilityMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *RouterCapabilityMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the RouterCapability entity.
// If the RouterCapability object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RouterCapabilityMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *RouterCapabilityMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// Where appends a list predicates to the RouterCapabilityMutation builder.
func (m *RouterCapabilityMutation) Where(ps ...predicate.RouterCapability) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RouterCapabilityMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RouterCapabilityMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.RouterCapability, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RouterCapabilityMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RouterCapabilityMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (RouterCapability).
func (m *RouterCapabilityMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RouterCapabilityMutation) Fields() []string {
	fields := make([]string, 0, 27)
	if m.architecture != nil {
		fields = append(fields, routercapability.FieldArchitecture)
	}
	if m.model != nil {
		fields = append(fields, routercapability.FieldModel)
	}
	if m.board_name != nil {
		fields = append(fields, routercapability.FieldBoardName)
	}
	if m.total_memory != nil {
		fields = append(fields, routercapability.FieldTotalMemory)
	}
	if m.available_storage != nil {
		fields = append(fields, routercapability.FieldAvailableStorage)
	}
	if m.cpu_count != nil {
		fields = append(fields, routercapability.FieldCPUCount)
	}
	if m.has_wireless_chip != nil {
		fields = append(fields, routercapability.FieldHasWirelessChip)
	}
	if m.has_lte_module != nil {
		fields = append(fields, routercapability.FieldHasLteModule)
	}
	if m.version_raw != nil {
		fields = append(fields, routercapability.FieldVersionRaw)
	}
	if m.version_major != nil {
		fields = append(fields, routercapability.FieldVersionMajor)
	}
	if m.version_minor != nil {
		fields = append(fields, routercapability.FieldVersionMinor)
	}
	if m.version_patch != nil {
		fields = append(fields, routercapability.FieldVersionPatch)
	}
	if m.installed_packages != nil {
		fields = append(fields, routercapability.FieldInstalledPackages)
	}
	if m.license_level != nil {
		fields = append(fields, routercapability.FieldLicenseLevel)
	}
	if m.update_channel != nil {
		fields = append(fields, routercapability.FieldUpdateChannel)
	}
	if m.container_package_installed != nil {
		fields = append(fields, routercapability.FieldContainerPackageInstalled)
	}
	if m.container_enabled != nil {
		fields = append(fields, routercapability.FieldContainerEnabled)
	}
	if m.container_registry_configured != nil {
		fields = append(fields, routercapability.FieldContainerRegistryConfigured)
	}
	if m.container_storage_available != nil {
		fields = append(fields, routercapability.FieldContainerStorageAvailable)
	}
	if m.supports_network_namespace != nil {
		fields = append(fields, routercapability.FieldSupportsNetworkNamespace)
	}
	if m.max_containers != nil {
		fields = append(fields, routercapability.FieldMaxContainers)
	}
	if m.capability_entries != nil {
		fields = append(fields, routercapability.FieldCapabilityEntries)
	}
	if m.detected_at != nil {
		fields = append(fields, routercapability.FieldDetectedAt)
	}
	if m.expires_at != nil {
		fields = append(fields, routercapability.FieldExpiresAt)
	}
	if m.is_refreshing != nil {
		fields = append(fields, routercapability.FieldIsRefreshing)
	}
	if m.created_at != nil {
		fields = append(fields, routercapability.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, routercapability.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RouterCapabilityMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case routercapability.FieldArchitecture:
		return m.Architecture()
	case routercapability.FieldModel:
		return m.Model()
	case routercapability.FieldBoardName:
		return m.BoardName()
	case routercapability.FieldTotalMemory:
		return m.TotalMemory()
	case routercapability.FieldAvailableStorage:
		return m.AvailableStorage()
	case routercapability.FieldCPUCount:
		return m.CPUCount()
	case routercapability.FieldHasWirelessChip:
		return m.HasWirelessChip()
	case routercapability.FieldHasLteModule:
		return m.HasLteModule()
	case routercapability.FieldVersionRaw:
		return m.VersionRaw()
	case routercapability.FieldVersionMajor:
		return m.VersionMajor()
	case routercapability.FieldVersionMinor:
		return m.VersionMinor()
	case routercapability.FieldVersionPatch:
		return m.VersionPatch()
	case routercapability.FieldInstalledPackages:
		return m.InstalledPackages()
	case routercapability.FieldLicenseLevel:
		return m.LicenseLevel()
	case routercapability.FieldUpdateChannel:
		return m.UpdateChannel()
	case routercapability.FieldContainerPackageInstalled:
		return m.ContainerPackageInstalled()
	case routercapability.FieldContainerEnabled:
		return m.ContainerEnabled()
	case routercapability.FieldContainerRegistryConfigured:
		return m.ContainerRegistryConfigured()
	case routercapability.FieldContainerStorageAvailable:
		return m.ContainerStorageAvailable()
	case routercapability.FieldSupportsNetworkNamespace:
		return m.SupportsNetworkNamespace()
	case routercapability.FieldMaxContainers:
		return m.MaxContainers()
	case routercapability.FieldCapabilityEntries:
		return m.CapabilityEntries()
	case routercapability.FieldDetectedAt:
		return m.DetectedAt()
	case routercapability.FieldExpiresAt:
		return m.ExpiresAt()
	case routercapability.FieldIsRefreshing:
		return m.IsRefreshing()
	case routercapability.FieldCreatedAt:
		return m.CreatedAt()
	case routercapability.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RouterCapabilityMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case routercapability.FieldArchitecture:
		return m.OldArchitecture(ctx)
	case routercapability.FieldModel:
		return m.OldModel(ctx)
	case routercapability.FieldBoardName:
		return m.OldBoardName(ctx)
	case routercapability.FieldTotalMemory:
		return m.OldTotalMemory(ctx)
	case routercapability.FieldAvailableStorage:
		return m.OldAvailableStorage(ctx)
	case routercapability.FieldCPUCount:
		return m.OldCPUCount(ctx)
	case routercapability.FieldHasWirelessChip:
		return m.OldHasWirelessChip(ctx)
	case routercapability.FieldHasLteModule:
		return m.OldHasLteModule(ctx)
	case routercapability.FieldVersionRaw:
		return m.OldVersionRaw(ctx)
	case routercapability.FieldVersionMajor:
		return m.OldVersionMajor(ctx)
	case routercapability.FieldVersionMinor:
		return m.OldVersionMinor(ctx)
	case routercapability.FieldVersionPatch:
		return m.OldVersionPatch(ctx)
	case routercapability.FieldInstalledPackages:
		return m.OldInstalledPackages(ctx)
	case routercapability.FieldLicenseLevel:
		return m.OldLicenseLevel(ctx)
	case routercapability.FieldUpdateChannel:
		return m.OldUpdateChannel(ctx)
	case routercapability.FieldContainerPackageInstalled:
		return m.OldContainerPackageInstalled(ctx)
	case routercapability.FieldContainerEnabled:
		return m.OldContainerEnabled(ctx)
	case routercapability.FieldContainerRegistryConfigured:
		return m.OldContainerRegistryConfigured(ctx)
	case routercapability.FieldContainerStorageAvailable:
		return m.OldContainerStorageAvailable(ctx)
	case routercapability.FieldSupportsNetworkNamespace:
		return m.OldSupportsNetworkNamespace(ctx)
	case routercapability.FieldMaxContainers:
		return m.OldMaxContainers(ctx)
	case routercapability.FieldCapabilityEntries:
		return m.OldCapabilityEntries(ctx)
	case routercapability.FieldDetectedAt:
		return m.OldDetectedAt(ctx)
	case routercapability.FieldExpiresAt:
		return m.OldExpiresAt(ctx)
	case routercapability.FieldIsRefreshing:
		return m.OldIsRefreshing(ctx)
	case routercapability.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case routercapability.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown RouterCapability field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RouterCapabilityMutation) SetField(name string, value ent.Value) error {
	switch name {
	case routercapability.FieldArchitecture:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetArchitecture(v)
		return nil
	case routercapability.FieldModel:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModel(v)
		return nil
	case routercapability.FieldBoardName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBoardName(v)
		return nil
	case routercapability.FieldTotalMemory:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalMemory(v)
		return nil
	case routercapability.FieldAvailableStorage:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAvailableStorage(v)
		return nil
	case routercapability.FieldCPUCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCPUCount(v)
		return nil
	case routercapability.FieldHasWirelessChip:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHasWirelessChip(v)
		return nil
	case routercapability.FieldHasLteModule:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHasLteModule(v)
		return nil
	case routercapability.FieldVersionRaw:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersionRaw(v)
		return nil
	case routercapability.FieldVersionMajor:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersionMajor(v)
		return nil
	case routercapability.FieldVersionMinor:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersionMinor(v)
		return nil
	case routercapability.FieldVersionPatch:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersionPatch(v)
		return nil
	case routercapability.FieldInstalledPackages:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInstalledPackages(v)
		return nil
	case routercapability.FieldLicenseLevel:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLicenseLevel(v)
		return nil
	case routercapability.FieldUpdateChannel:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateChannel(v)
		return nil
	case routercapability.FieldContainerPackageInstalled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContainerPackageInstalled(v)
		return nil
	case routercapability.FieldContainerEnabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContainerEnabled(v)
		return nil
	case routercapability.FieldContainerRegistryConfigured:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContainerRegistryConfigured(v)
		return nil
	case routercapability.FieldContainerStorageAvailable:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContainerStorageAvailable(v)
		return nil
	case routercapability.FieldSupportsNetworkNamespace:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSupportsNetworkNamespace(v)
		return nil
	case routercapability.FieldMaxContainers:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaxContainers(v)
		return nil
	case routercapability.FieldCapabilityEntries:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCapabilityEntries(v)
		return nil
	case routercapability.FieldDetectedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDetectedAt(v)
		return nil
	case routercapability.FieldExpiresAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiresAt(v)
		return nil
	case routercapability.FieldIsRefreshing:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsRefreshing(v)
		return nil
	case routercapability.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case routercapability.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown RouterCapability field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RouterCapabilityMutation) AddedFields() []string {
	var fields []string
	if m.addtotal_memory != nil {
		fields = append(fields, routercapability.FieldTotalMemory)
	}
	if m.addavailable_storage != nil {
		fields = append(fields, routercapability.FieldAvailableStorage)
	}
	if m.addcpu_count != nil {
		fields = append(fields, routercapability.FieldCPUCount)
	}
	if m.addversion_major != nil {
		fields = append(fields, routercapability.FieldVersionMajor)
	}
	if m.addversion_minor != nil {
		fields = append(fields, routercapability.FieldVersionMinor)
	}
	if m.addversion_patch != nil {
		fields = append(fields, routercapability.FieldVersionPatch)
	}
	if m.addlicense_level != nil {
		fields = append(fields, routercapability.FieldLicenseLevel)
	}
	if m.addcontainer_storage_available != nil {
		fields = append(fields, routercapability.FieldContainerStorageAvailable)
	}
	if m.addmax_containers != nil {
		fields = append(fields, routercapability.FieldMaxContainers)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RouterCapabilityMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case routercapability.FieldTotalMemory:
		return m.AddedTotalMemory()
	case routercapability.FieldAvailableStorage:
		return m.AddedAvailableStorage()
	case routercapability.FieldCPUCount:
		return m.AddedCPUCount()
	case routercapability.FieldVersionMajor:
		return m.AddedVersionMajor()
	case routercapability.FieldVersionMinor:
		return m.AddedVersionMinor()
	case routercapability.FieldVersionPatch:
		return m.AddedVersionPatch()
	case routercapability.FieldLicenseLevel:
		return m.AddedLicenseLevel()
	case routercapability.FieldContainerStorageAvailable:
		return m.AddedContainerStorageAvailable()
	case routercapability.FieldMaxContainers:
		return m.AddedMaxContainers()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RouterCapabilityMutation) AddField(name string, value ent.Value) error {
	switch name {
	case routercapability.FieldTotalMemory:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotalMemory(v)
		return nil
	case routercapability.FieldAvailableStorage:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAvailableStorage(v)
		return nil
	case routercapability.FieldCPUCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCPUCount(v)
		return nil
	case routercapability.FieldVersionMajor:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVersionMajor(v)
		return nil
	case routercapability.FieldVersionMinor:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVersionMinor(v)
		return nil
	case routercapability.FieldVersionPatch:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVersionPatch(v)
		return nil
	case routercapability.FieldLicenseLevel:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLicenseLevel(v)
		return nil
	case routercapability.FieldContainerStorageAvailable:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddContainerStorageAvailable(v)
		return nil
	case routercapability.FieldMaxContainers:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMaxContainers(v)
		return nil
	}
	return fmt.Errorf("unknown RouterCapability numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RouterCapabilityMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(routercapability.FieldModel) {
		fields = append(fields, routercapability.FieldModel)
	}
	if m.FieldCleared(routercapability.FieldBoardName) {
		fields = append(fields, routercapability.FieldBoardName)
	}
	if m.FieldCleared(routercapability.FieldUpdateChannel) {
		fields = append(fields, routercapability.FieldUpdateChannel)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RouterCapabilityMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RouterCapabilityMutation) ClearField(name string) error {
	switch name {
	case routercapability.FieldModel:
		m.ClearModel()
		return nil
	case routercapability.FieldBoardName:
		m.ClearBoardName()
		return nil
	case routercapability.FieldUpdateChannel:
		m.ClearUpdateChannel()
		return nil
	}
	return fmt.Errorf("unknown RouterCapability nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RouterCapabilityMutation) ResetField(name string) error {
	switch name {
	case routercapability.FieldArchitecture:
		m.ResetArchitecture()
		return nil
	case routercapability.FieldModel:
		m.ResetModel()
		return nil
	case routercapability.FieldBoardName:
		m.ResetBoardName()
		return nil
	case routercapability.FieldTotalMemory:
		m.ResetTotalMemory()
		return nil
	case routercapability.FieldAvailableStorage:
		m.ResetAvailableStorage()
		return nil
	case routercapability.FieldCPUCount:
		m.ResetCPUCount()
		return nil
	case routercapability.FieldHasWirelessChip:
		m.ResetHasWirelessChip()
		return nil
	case routercapability.FieldHasLteModule:
		m.ResetHasLteModule()
		return nil
	case routercapability.FieldVersionRaw:
		m.ResetVersionRaw()
		return nil
	case routercapability.FieldVersionMajor:
		m.ResetVersionMajor()
		return nil
	case routercapability.FieldVersionMinor:
		m.ResetVersionMinor()
		return nil
	case routercapability.FieldVersionPatch:
		m.ResetVersionPatch()
		return nil
	case routercapability.FieldInstalledPackages:
		m.ResetInstalledPackages()
		return nil
	case routercapability.FieldLicenseLevel:
		m.ResetLicenseLevel()
		return nil
	case routercapability.FieldUpdateChannel:
		m.ResetUpdateChannel()
		return nil
	case routercapability.FieldContainerPackageInstalled:
		m.ResetContainerPackageInstalled()
		return nil
	case routercapability.FieldContainerEnabled:
		m.ResetContainerEnabled()
		return nil
	case routercapability.FieldContainerRegistryConfigured:
		m.ResetContainerRegistryConfigured()
		return nil
	case routercapability.FieldContainerStorageAvailable:
		m.ResetContainerStorageAvailable()
		return nil
	case routercapability.FieldSupportsNetworkNamespace:
		m.ResetSupportsNetworkNamespace()
		return nil
	case routercapability.FieldMaxContainers:
		m.ResetMaxContainers()
		return nil
	case routercapability.FieldCapabilityEntries:
		m.ResetCapabilityEntries()
		return nil
	case routercapability.FieldDetectedAt:
		m.ResetDetectedAt()
		return nil
	case routercapability.FieldExpiresAt:
		m.ResetExpiresAt()
		return nil
	case routercapability.FieldIsRefreshing:
		m.ResetIsRefreshing()
		return nil
	case routercapability.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case routercapability.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown RouterCapability field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RouterCapabilityMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RouterCapabilityMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RouterCapabilityMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RouterCapabilityMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RouterCapabilityMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RouterCapabilityMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RouterCapabilityMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown RouterCapability unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RouterCapabilityMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown RouterCapability edge %s", name)
}

// RouterSecretMutation represents an operation that mutates the RouterSecret nodes in the graph.
type RouterSecretMutation struct {
	config
	op                 Op
	typ                string
	id                 *string
	encrypted_username *[]byte
	encrypted_password *[]byte
	encryption_nonce   *[]byte
	key_version        *int
	addkey_version     *int
	created_at         *time.Time
	updated_at         *time.Time
	clearedFields      map[string]struct{}
	router             *string
	clearedrouter      bool
	done               bool
	oldValue           func(context.Context) (*RouterSecret, error)
	predicates         []predicate.RouterSecret
}

var _ ent.Mutation = (*RouterSecretMutation)(nil)

// routersecretOption allows management of the mutation configuration using functional options.
type routersecretOption func(*RouterSecretMutation)

// newRouterSecretMutation creates new mutation for the RouterSecret entity.
func newRouterSecretMutation(c config, op Op, opts ...routersecretOption) *RouterSecretMutation {
	m := &RouterSecretMutation{
		config:        c,
		op:            op,
		typ:           TypeRouterSecret,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRouterSecretID sets the ID field of the mutation.
func withRouterSecretID(id string) routersecretOption {
	return func(m *RouterSecretMutation) {
		var (
			err   error
			once  sync.Once
			value *RouterSecret
		)
		m.oldValue = func(ctx context.Context) (*RouterSecret, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().RouterSecret.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRouterSecret sets the old RouterSecret of the mutation.
func withRouterSecret(node *RouterSecret) routersecretOption {
	return func(m *RouterSecretMutation) {
		m.oldValue = func(context.Context) (*RouterSecret, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RouterSecretMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RouterSecretMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of RouterSecret entities.
func (m *RouterSecretMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RouterSecretMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RouterSecretMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().RouterSecret.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetRouterID sets the "router_id" field.
func (m *RouterSecretMutation) SetRouterID(s string) {
	m.router = &s
}

// RouterID returns the value of the "router_id" field in the mutation.
func (m *RouterSecretMutation) RouterID() (r string, exists bool) {
	v := m.router
	if v == nil {
		return
	}
	return *v, true
}

// OldRouterID returns the old "router_id" field's value of the RouterSecret entity.
// If the RouterSecret object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RouterSecretMutation) OldRouterID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRouterID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRouterID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRouterID: %w", err)
	}
	return oldValue.RouterID, nil
}

// ResetRouterID resets all changes to the "router_id" field.
func (m *RouterSecretMutation) ResetRouterID() {
	m.router = nil
}

// SetEncryptedUsername sets the "encrypted_username" field.
func (m *RouterSecretMutation) SetEncryptedUsername(b []byte) {
	m.encrypted_username = &b
}

// EncryptedUsername returns the value of the "encrypted_username" field in the mutation.
func (m *RouterSecretMutation) EncryptedUsername() (r []byte, exists bool) {
	v := m.encrypted_username
	if v == nil {
		return
	}
	return *v, true
}

// OldEncryptedUsername returns the old "encrypted_username" field's value of the RouterSecret entity.
// If the RouterSecret object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RouterSecretMutation) OldEncryptedUsername(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEncryptedUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEncryptedUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEncryptedUsername: %w", err)
	}
	return oldValue.EncryptedUsername, nil
}

// ResetEncryptedUsername resets all changes to the "encrypted_username" field.
func (m *RouterSecretMutation) ResetEncryptedUsername() {
	m.encrypted_username = nil
}

// SetEncryptedPassword sets the "encrypted_password" field.
func (m *RouterSecretMutation) SetEncryptedPassword(b []byte) {
	m.encrypted_password = &b
}

// EncryptedPassword returns the value of the "encrypted_password" field in the mutation.
func (m *RouterSecretMutation) EncryptedPassword() (r []byte, exists bool) {
	v := m.encrypted_password
	if v == nil {
		return
	}
	return *v, true
}

// OldEncryptedPassword returns the old "encrypted_password" field's value of the RouterSecret entity.
// If the RouterSecret object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RouterSecretMutation) OldEncryptedPassword(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEncryptedPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEncryptedPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEncryptedPassword: %w", err)
	}
	return oldValue.EncryptedPassword, nil
}

// ResetEncryptedPassword resets all changes to the "encrypted_password" field.
func (m *RouterSecretMutation) ResetEncryptedPassword() {
	m.encrypted_password = nil
}

// SetEncryptionNonce sets the "encryption_nonce" field.
func (m *RouterSecretMutation) SetEncryptionNonce(b []byte) {
	m.encryption_nonce = &b
}

// EncryptionNonce returns the value of the "encryption_nonce" field in the mutation.
func (m *RouterSecretMutation) EncryptionNonce() (r []byte, exists bool) {
	v := m.encryption_nonce
	if v == nil {
		return
	}
	return *v, true
}

// OldEncryptionNonce returns the old "encryption_nonce" field's value of the RouterSecret entity.
// If the RouterSecret object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RouterSecretMutation) OldEncryptionNonce(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEncryptionNonce is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEncryptionNonce requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEncryptionNonce: %w", err)
	}
	return oldValue.EncryptionNonce, nil
}

// ResetEncryptionNonce resets all changes to the "encryption_nonce" field.
func (m *RouterSecretMutation) ResetEncryptionNonce() {
	m.encryption_nonce = nil
}

// SetKeyVersion sets the "key_version" field.
func (m *RouterSecretMutation) SetKeyVersion(i int) {
	m.key_version = &i
	m.addkey_version = nil
}

// KeyVersion returns the value of the "key_version" field in the mutation.
func (m *RouterSecretMutation) KeyVersion() (r int, exists bool) {
	v := m.key_version
	if v == nil {
		return
	}
	return *v, true
}

// OldKeyVersion returns the old "key_version" field's value of the RouterSecret entity.
// If the RouterSecret object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RouterSecretMutation) OldKeyVersion(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKeyVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKeyVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKeyVersion: %w", err)
	}
	return oldValue.KeyVersion, nil
}

// AddKeyVersion adds i to the "key_version" field.
func (m *RouterSecretMutation) AddKeyVersion(i int) {
	if m.addkey_version != nil {
		*m.addkey_version += i
	} else {
		m.addkey_version = &i
	}
}

// AddedKeyVersion returns the value that was added to the "key_version" field in this mutation.
func (m *RouterSecretMutation) AddedKeyVersion() (r int, exists bool) {
	v := m.addkey_version
	if v == nil {
		return
	}
	return *v, true
}

// ResetKeyVersion resets all changes to the "key_version" field.
func (m *RouterSecretMutation) ResetKeyVersion() {
	m.key_version = nil
	m.addkey_version = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *RouterSecretMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *RouterSecretMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the RouterSecret entity.
// If the RouterSecret object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RouterSecretMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *RouterSecretMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *RouterSecretMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *RouterSecretMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the RouterSecret entity.
// If the RouterSecret object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RouterSecretMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *RouterSecretMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearRouter clears the "router" edge to the Router entity.
func (m *RouterSecretMutation) ClearRouter() {
	m.clearedrouter = true
	m.clearedFields[routersecret.FieldRouterID] = struct{}{}
}

// RouterCleared reports if the "router" edge to the Router entity was cleared.
func (m *RouterSecretMutation) RouterCleared() bool {
	return m.clearedrouter
}

// RouterIDs returns the "router" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RouterID instead. It exists only for internal usage by the builders.
func (m *RouterSecretMutation) RouterIDs() (ids []string) {
	if id := m.router; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRouter resets all changes to the "router" edge.
func (m *RouterSecretMutation) ResetRouter() {
	m.router = nil
	m.clearedrouter = false
}

// Where appends a list predicates to the RouterSecretMutation builder.
func (m *RouterSecretMutation) Where(ps ...predicate.RouterSecret) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RouterSecretMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RouterSecretMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.RouterSecret, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RouterSecretMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RouterSecretMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (RouterSecret).
func (m *RouterSecretMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RouterSecretMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.router != nil {
		fields = append(fields, routersecret.FieldRouterID)
	}
	if m.encrypted_username != nil {
		fields = append(fields, routersecret.FieldEncryptedUsername)
	}
	if m.encrypted_password != nil {
		fields = append(fields, routersecret.FieldEncryptedPassword)
	}
	if m.encryption_nonce != nil {
		fields = append(fields, routersecret.FieldEncryptionNonce)
	}
	if m.key_version != nil {
		fields = append(fields, routersecret.FieldKeyVersion)
	}
	if m.created_at != nil {
		fields = append(fields, routersecret.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, routersecret.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RouterSecretMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case routersecret.FieldRouterID:
		return m.RouterID()
	case routersecret.FieldEncryptedUsername:
		return m.EncryptedUsername()
	case routersecret.FieldEncryptedPassword:
		return m.EncryptedPassword()
	case routersecret.FieldEncryptionNonce:
		return m.EncryptionNonce()
	case routersecret.FieldKeyVersion:
		return m.KeyVersion()
	case routersecret.FieldCreatedAt:
		return m.CreatedAt()
	case routersecret.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RouterSecretMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case routersecret.FieldRouterID:
		return m.OldRouterID(ctx)
	case routersecret.FieldEncryptedUsername:
		return m.OldEncryptedUsername(ctx)
	case routersecret.FieldEncryptedPassword:
		return m.OldEncryptedPassword(ctx)
	case routersecret.FieldEncryptionNonce:
		return m.OldEncryptionNonce(ctx)
	case routersecret.FieldKeyVersion:
		return m.OldKeyVersion(ctx)
	case routersecret.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case routersecret.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown RouterSecret field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RouterSecretMutation) SetField(name string, value ent.Value) error {
	switch name {
	case routersecret.FieldRouterID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRouterID(v)
		return nil
	case routersecret.FieldEncryptedUsername:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEncryptedUsername(v)
		return nil
	case routersecret.FieldEncryptedPassword:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEncryptedPassword(v)
		return nil
	case routersecret.FieldEncryptionNonce:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEncryptionNonce(v)
		return nil
	case routersecret.FieldKeyVersion:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKeyVersion(v)
		return nil
	case routersecret.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case routersecret.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown RouterSecret field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RouterSecretMutation) AddedFields() []string {
	var fields []string
	if m.addkey_version != nil {
		fields = append(fields, routersecret.FieldKeyVersion)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RouterSecretMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case routersecret.FieldKeyVersion:
		return m.AddedKeyVersion()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RouterSecretMutation) AddField(name string, value ent.Value) error {
	switch name {
	case routersecret.FieldKeyVersion:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddKeyVersion(v)
		return nil
	}
	return fmt.Errorf("unknown RouterSecret numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RouterSecretMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RouterSecretMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RouterSecretMutation) ClearField(name string) error {
	return fmt.Errorf("unknown RouterSecret nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RouterSecretMutation) ResetField(name string) error {
	switch name {
	case routersecret.FieldRouterID:
		m.ResetRouterID()
		return nil
	case routersecret.FieldEncryptedUsername:
		m.ResetEncryptedUsername()
		return nil
	case routersecret.FieldEncryptedPassword:
		m.ResetEncryptedPassword()
		return nil
	case routersecret.FieldEncryptionNonce:
		m.ResetEncryptionNonce()
		return nil
	case routersecret.FieldKeyVersion:
		m.ResetKeyVersion()
		return nil
	case routersecret.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case routersecret.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown RouterSecret field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RouterSecretMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.router != nil {
		edges = append(edges, routersecret.EdgeRouter)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RouterSecretMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case routersecret.EdgeRouter:
		if id := m.router; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RouterSecretMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RouterSecretMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RouterSecretMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedrouter {
		edges = append(edges, routersecret.EdgeRouter)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RouterSecretMutation) EdgeCleared(name string) bool {
	switch name {
	case routersecret.EdgeRouter:
		return m.clearedrouter
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RouterSecretMutation) ClearEdge(name string) error {
	switch name {
	case routersecret.EdgeRouter:
		m.ClearRouter()
		return nil
	}
	return fmt.Errorf("unknown RouterSecret unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RouterSecretMutation) ResetEdge(name string) error {
	switch name {
	case routersecret.EdgeRouter:
		m.ResetRouter()
		return nil
	}
	return fmt.Errorf("unknown RouterSecret edge %s", name)
}

// SchemaVersionMutation represents an operation that mutates the SchemaVersion nodes in the graph.
type SchemaVersionMutation struct {
	config
	op                   Op
	typ                  string
	id                   *string
	version              *int64
	addversion           *int64
	name                 *string
	checksum             *string
	applied              *bool
	error_message        *string
	execution_time_ms    *int64
	addexecution_time_ms *int64
	applied_at           *time.Time
	clearedFields        map[string]struct{}
	done                 bool
	oldValue             func(context.Context) (*SchemaVersion, error)
	predicates           []predicate.SchemaVersion
}

var _ ent.Mutation = (*SchemaVersionMutation)(nil)

// schemaversionOption allows management of the mutation configuration using functional options.
type schemaversionOption func(*SchemaVersionMutation)

// newSchemaVersionMutation creates new mutation for the SchemaVersion entity.
func newSchemaVersionMutation(c config, op Op, opts ...schemaversionOption) *SchemaVersionMutation {
	m := &SchemaVersionMutation{
		config:        c,
		op:            op,
		typ:           TypeSchemaVersion,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSchemaVersionID sets the ID field of the mutation.
func withSchemaVersionID(id string) schemaversionOption {
	return func(m *SchemaVersionMutation) {
		var (
			err   error
			once  sync.Once
			value *SchemaVersion
		)
		m.oldValue = func(ctx context.Context) (*SchemaVersion, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SchemaVersion.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSchemaVersion sets the old SchemaVersion of the mutation.
func withSchemaVersion(node *SchemaVersion) schemaversionOption {
	return func(m *SchemaVersionMutation) {
		m.oldValue = func(context.Context) (*SchemaVersion, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SchemaVersionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SchemaVersionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of SchemaVersion entities.
func (m *SchemaVersionMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SchemaVersionMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SchemaVersionMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SchemaVersion.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetVersion sets the "version" field.
func (m *SchemaVersionMutation) SetVersion(i int64) {
	m.version = &i
	m.addversion = nil
}

// Version returns the value of the "version" field in the mutation.
func (m *SchemaVersionMutation) Version() (r int64, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the SchemaVersion entity.
// If the SchemaVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SchemaVersionMutation) OldVersion(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// AddVersion adds i to the "version" field.
func (m *SchemaVersionMutation) AddVersion(i int64) {
	if m.addversion != nil {
		*m.addversion += i
	} else {
		m.addversion = &i
	}
}

// AddedVersion returns the value that was added to the "version" field in this mutation.
func (m *SchemaVersionMutation) AddedVersion() (r int64, exists bool) {
	v := m.addversion
	if v == nil {
		return
	}
	return *v, true
}

// ResetVersion resets all changes to the "version" field.
func (m *SchemaVersionMutation) ResetVersion() {
	m.version = nil
	m.addversion = nil
}

// SetName sets the "name" field.
func (m *SchemaVersionMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *SchemaVersionMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the SchemaVersion entity.
// If the SchemaVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SchemaVersionMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *SchemaVersionMutation) ResetName() {
	m.name = nil
}

// SetChecksum sets the "checksum" field.
func (m *SchemaVersionMutation) SetChecksum(s string) {
	m.checksum = &s
}

// Checksum returns the value of the "checksum" field in the mutation.
func (m *SchemaVersionMutation) Checksum() (r string, exists bool) {
	v := m.checksum
	if v == nil {
		return
	}
	return *v, true
}

// OldChecksum returns the old "checksum" field's value of the SchemaVersion entity.
// If the SchemaVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SchemaVersionMutation) OldChecksum(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChecksum is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChecksum requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChecksum: %w", err)
	}
	return oldValue.Checksum, nil
}

// ResetChecksum resets all changes to the "checksum" field.
func (m *SchemaVersionMutation) ResetChecksum() {
	m.checksum = nil
}

// SetApplied sets the "applied" field.
func (m *SchemaVersionMutation) SetApplied(b bool) {
	m.applied = &b
}

// Applied returns the value of the "applied" field in the mutation.
func (m *SchemaVersionMutation) Applied() (r bool, exists bool) {
	v := m.applied
	if v == nil {
		return
	}
	return *v, true
}

// OldApplied returns the old "applied" field's value of the SchemaVersion entity.
// If the SchemaVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SchemaVersionMutation) OldApplied(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldApplied is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldApplied requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldApplied: %w", err)
	}
	return oldValue.Applied, nil
}

// ResetApplied resets all changes to the "applied" field.
func (m *SchemaVersionMutation) ResetApplied() {
	m.applied = nil
}

// SetErrorMessage sets the "error_message" field.
func (m *SchemaVersionMutation) SetErrorMessage(s string) {
	m.error_message = &s
}

// ErrorMessage returns the value of the "error_message" field in the mutation.
func (m *SchemaVersionMutation) ErrorMessage() (r string, exists bool) {
	v := m.error_message
	if v == nil {
		return
	}
	return *v, true
}

// OldErrorMessage returns the old "error_message" field's value of the SchemaVersion entity.
// If the SchemaVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SchemaVersionMutation) OldErrorMessage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldErrorMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldErrorMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldErrorMessage: %w", err)
	}
	return oldValue.ErrorMessage, nil
}

// ClearErrorMessage clears the value of the "error_message" field.
func (m *SchemaVersionMutation) ClearErrorMessage() {
	m.error_message = nil
	m.clearedFields[schemaversion.FieldErrorMessage] = struct{}{}
}

// ErrorMessageCleared returns if the "error_message" field was cleared in this mutation.
func (m *SchemaVersionMutation) ErrorMessageCleared() bool {
	_, ok := m.clearedFields[schemaversion.FieldErrorMessage]
	return ok
}

// ResetErrorMessage resets all changes to the "error_message" field.
func (m *SchemaVersionMutation) ResetErrorMessage() {
	m.error_message = nil
	delete(m.clearedFields, schemaversion.FieldErrorMessage)
}

// SetExecutionTimeMs sets the "execution_time_ms" field.
func (m *SchemaVersionMutation) SetExecutionTimeMs(i int64) {
	m.execution_time_ms = &i
	m.addexecution_time_ms = nil
}

// ExecutionTimeMs returns the value of the "execution_time_ms" field in the mutation.
func (m *SchemaVersionMutation) ExecutionTimeMs() (r int64, exists bool) {
	v := m.execution_time_ms
	if v == nil {
		return
	}
	return *v, true
}

// OldExecutionTimeMs returns the old "execution_time_ms" field's value of the SchemaVersion entity.
// If the SchemaVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SchemaVersionMutation) OldExecutionTimeMs(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExecutionTimeMs is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExecutionTimeMs requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExecutionTimeMs: %w", err)
	}
	return oldValue.ExecutionTimeMs, nil
}

// AddExecutionTimeMs adds i to the "execution_time_ms" field.
func (m *SchemaVersionMutation) AddExecutionTimeMs(i int64) {
	if m.addexecution_time_ms != nil {
		*m.addexecution_time_ms += i
	} else {
		m.addexecution_time_ms = &i
	}
}

// AddedExecutionTimeMs returns the value that was added to the "execution_time_ms" field in this mutation.
func (m *SchemaVersionMutation) AddedExecutionTimeMs() (r int64, exists bool) {
	v := m.addexecution_time_ms
	if v == nil {
		return
	}
	return *v, true
}

// ClearExecutionTimeMs clears the value of the "execution_time_ms" field.
func (m *SchemaVersionMutation) ClearExecutionTimeMs() {
	m.execution_time_ms = nil
	m.addexecution_time_ms = nil
	m.clearedFields[schemaversion.FieldExecutionTimeMs] = struct{}{}
}

// ExecutionTimeMsCleared returns if the "execution_time_ms" field was cleared in this mutation.
func (m *SchemaVersionMutation) ExecutionTimeMsCleared() bool {
	_, ok := m.clearedFields[schemaversion.FieldExecutionTimeMs]
	return ok
}

// ResetExecutionTimeMs resets all changes to the "execution_time_ms" field.
func (m *SchemaVersionMutation) ResetExecutionTimeMs() {
	m.execution_time_ms = nil
	m.addexecution_time_ms = nil
	delete(m.clearedFields, schemaversion.FieldExecutionTimeMs)
}

// SetAppliedAt sets the "applied_at" field.
func (m *SchemaVersionMutation) SetAppliedAt(t time.Time) {
	m.applied_at = &t
}

// AppliedAt returns the value of the "applied_at" field in the mutation.
func (m *SchemaVersionMutation) AppliedAt() (r time.Time, exists bool) {
	v := m.applied_at
	if v == nil {
		return
	}
	return *v, true
}

// OldAppliedAt returns the old "applied_at" field's value of the SchemaVersion entity.
// If the SchemaVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SchemaVersionMutation) OldAppliedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppliedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppliedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppliedAt: %w", err)
	}
	return oldValue.AppliedAt, nil
}

// ResetAppliedAt resets all changes to the "applied_at" field.
func (m *SchemaVersionMutation) ResetAppliedAt() {
	m.applied_at = nil
}

// Where appends a list predicates to the SchemaVersionMutation builder.
func (m *SchemaVersionMutation) Where(ps ...predicate.SchemaVersion) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SchemaVersionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SchemaVersionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.SchemaVersion, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SchemaVersionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SchemaVersionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (SchemaVersion).
func (m *SchemaVersionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SchemaVersionMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.version != nil {
		fields = append(fields, schemaversion.FieldVersion)
	}
	if m.name != nil {
		fields = append(fields, schemaversion.FieldName)
	}
	if m.checksum != nil {
		fields = append(fields, schemaversion.FieldChecksum)
	}
	if m.applied != nil {
		fields = append(fields, schemaversion.FieldApplied)
	}
	if m.error_message != nil {
		fields = append(fields, schemaversion.FieldErrorMessage)
	}
	if m.execution_time_ms != nil {
		fields = append(fields, schemaversion.FieldExecutionTimeMs)
	}
	if m.applied_at != nil {
		fields = append(fields, schemaversion.FieldAppliedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SchemaVersionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case schemaversion.FieldVersion:
		return m.Version()
	case schemaversion.FieldName:
		return m.Name()
	case schemaversion.FieldChecksum:
		return m.Checksum()
	case schemaversion.FieldApplied:
		return m.Applied()
	case schemaversion.FieldErrorMessage:
		return m.ErrorMessage()
	case schemaversion.FieldExecutionTimeMs:
		return m.ExecutionTimeMs()
	case schemaversion.FieldAppliedAt:
		return m.AppliedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SchemaVersionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case schemaversion.FieldVersion:
		return m.OldVersion(ctx)
	case schemaversion.FieldName:
		return m.OldName(ctx)
	case schemaversion.FieldChecksum:
		return m.OldChecksum(ctx)
	case schemaversion.FieldApplied:
		return m.OldApplied(ctx)
	case schemaversion.FieldErrorMessage:
		return m.OldErrorMessage(ctx)
	case schemaversion.FieldExecutionTimeMs:
		return m.OldExecutionTimeMs(ctx)
	case schemaversion.FieldAppliedAt:
		return m.OldAppliedAt(ctx)
	}
	return nil, fmt.Errorf("unknown SchemaVersion field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SchemaVersionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case schemaversion.FieldVersion:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case schemaversion.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case schemaversion.FieldChecksum:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChecksum(v)
		return nil
	case schemaversion.FieldApplied:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetApplied(v)
		return nil
	case schemaversion.FieldErrorMessage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetErrorMessage(v)
		return nil
	case schemaversion.FieldExecutionTimeMs:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExecutionTimeMs(v)
		return nil
	case schemaversion.FieldAppliedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppliedAt(v)
		return nil
	}
	return fmt.Errorf("unknown SchemaVersion field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SchemaVersionMutation) AddedFields() []string {
	var fields []string
	if m.addversion != nil {
		fields = append(fields, schemaversion.FieldVersion)
	}
	if m.addexecution_time_ms != nil {
		fields = append(fields, schemaversion.FieldExecutionTimeMs)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SchemaVersionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case schemaversion.FieldVersion:
		return m.AddedVersion()
	case schemaversion.FieldExecutionTimeMs:
		return m.AddedExecutionTimeMs()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SchemaVersionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case schemaversion.FieldVersion:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVersion(v)
		return nil
	case schemaversion.FieldExecutionTimeMs:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddExecutionTimeMs(v)
		return nil
	}
	return fmt.Errorf("unknown SchemaVersion numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SchemaVersionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(schemaversion.FieldErrorMessage) {
		fields = append(fields, schemaversion.FieldErrorMessage)
	}
	if m.FieldCleared(schemaversion.FieldExecutionTimeMs) {
		fields = append(fields, schemaversion.FieldExecutionTimeMs)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SchemaVersionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SchemaVersionMutation) ClearField(name string) error {
	switch name {
	case schemaversion.FieldErrorMessage:
		m.ClearErrorMessage()
		return nil
	case schemaversion.FieldExecutionTimeMs:
		m.ClearExecutionTimeMs()
		return nil
	}
	return fmt.Errorf("unknown SchemaVersion nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SchemaVersionMutation) ResetField(name string) error {
	switch name {
	case schemaversion.FieldVersion:
		m.ResetVersion()
		return nil
	case schemaversion.FieldName:
		m.ResetName()
		return nil
	case schemaversion.FieldChecksum:
		m.ResetChecksum()
		return nil
	case schemaversion.FieldApplied:
		m.ResetApplied()
		return nil
	case schemaversion.FieldErrorMessage:
		m.ResetErrorMessage()
		return nil
	case schemaversion.FieldExecutionTimeMs:
		m.ResetExecutionTimeMs()
		return nil
	case schemaversion.FieldAppliedAt:
		m.ResetAppliedAt()
		return nil
	}
	return fmt.Errorf("unknown SchemaVersion field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SchemaVersionMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SchemaVersionMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SchemaVersionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SchemaVersionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SchemaVersionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SchemaVersionMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SchemaVersionMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown SchemaVersion unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SchemaVersionMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown SchemaVersion edge %s", name)
}

// SessionMutation represents an operation that mutates the Session nodes in the graph.
type SessionMutation struct {
	config
	op             Op
	typ            string
	id             *string
	token_id       *string
	token_family   *string
	user_agent     *string
	ip_address     *string
	expires_at     *time.Time
	last_activity  *time.Time
	revoked        *bool
	revoked_at     *time.Time
	revoked_reason *string
	created_at     *time.Time
	clearedFields  map[string]struct{}
	user           *string
	cleareduser    bool
	done           bool
	oldValue       func(context.Context) (*Session, error)
	predicates     []predicate.Session
}

var _ ent.Mutation = (*SessionMutation)(nil)

// sessionOption allows management of the mutation configuration using functional options.
type sessionOption func(*SessionMutation)

// newSessionMutation creates new mutation for the Session entity.
func newSessionMutation(c config, op Op, opts ...sessionOption) *SessionMutation {
	m := &SessionMutation{
		config:        c,
		op:            op,
		typ:           TypeSession,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSessionID sets the ID field of the mutation.
func withSessionID(id string) sessionOption {
	return func(m *SessionMutation) {
		var (
			err   error
			once  sync.Once
			value *Session
		)
		m.oldValue = func(ctx context.Context) (*Session, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Session.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSession sets the old Session of the mutation.
func withSession(node *Session) sessionOption {
	return func(m *SessionMutation) {
		m.oldValue = func(context.Context) (*Session, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SessionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SessionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Session entities.
func (m *SessionMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SessionMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SessionMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Session.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserID sets the "user_id" field.
func (m *SessionMutation) SetUserID(s string) {
	m.user = &s
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *SessionMutation) UserID() (r string, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldUserID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *SessionMutation) ResetUserID() {
	m.user = nil
}

// SetTokenID sets the "token_id" field.
func (m *SessionMutation) SetTokenID(s string) {
	m.token_id = &s
}

// TokenID returns the value of the "token_id" field in the mutation.
func (m *SessionMutation) TokenID() (r string, exists bool) {
	v := m.token_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTokenID returns the old "token_id" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldTokenID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTokenID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTokenID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTokenID: %w", err)
	}
	return oldValue.TokenID, nil
}

// ResetTokenID resets all changes to the "token_id" field.
func (m *SessionMutation) ResetTokenID() {
	m.token_id = nil
}

// SetTokenFamily sets the "token_family" field.
func (m *SessionMutation) SetTokenFamily(s string) {
	m.token_family = &s
}

// TokenFamily returns the value of the "token_family" field in the mutation.
func (m *SessionMutation) TokenFamily() (r string, exists bool) {
	v := m.token_family
	if v == nil {
		return
	}
	return *v, true
}

// OldTokenFamily returns the old "token_family" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldTokenFamily(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTokenFamily is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTokenFamily requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTokenFamily: %w", err)
	}
	return oldValue.TokenFamily, nil
}

// ClearTokenFamily clears the value of the "token_family" field.
func (m *SessionMutation) ClearTokenFamily() {
	m.token_family = nil
	m.clearedFields[session.FieldTokenFamily] = struct{}{}
}

// TokenFamilyCleared returns if the "token_family" field was cleared in this mutation.
func (m *SessionMutation) TokenFamilyCleared() bool {
	_, ok := m.clearedFields[session.FieldTokenFamily]
	return ok
}

// ResetTokenFamily resets all changes to the "token_family" field.
func (m *SessionMutation) ResetTokenFamily() {
	m.token_family = nil
	delete(m.clearedFields, session.FieldTokenFamily)
}

// SetUserAgent sets the "user_agent" field.
func (m *SessionMutation) SetUserAgent(s string) {
	m.user_agent = &s
}

// UserAgent returns the value of the "user_agent" field in the mutation.
func (m *SessionMutation) UserAgent() (r string, exists bool) {
	v := m.user_agent
	if v == nil {
		return
	}
	return *v, true
}

// OldUserAgent returns the old "user_agent" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldUserAgent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserAgent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserAgent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserAgent: %w", err)
	}
	return oldValue.UserAgent, nil
}

// ClearUserAgent clears the value of the "user_agent" field.
func (m *SessionMutation) ClearUserAgent() {
	m.user_agent = nil
	m.clearedFields[session.FieldUserAgent] = struct{}{}
}

// UserAgentCleared returns if the "user_agent" field was cleared in this mutation.
func (m *SessionMutation) UserAgentCleared() bool {
	_, ok := m.clearedFields[session.FieldUserAgent]
	return ok
}

// ResetUserAgent resets all changes to the "user_agent" field.
func (m *SessionMutation) ResetUserAgent() {
	m.user_agent = nil
	delete(m.clearedFields, session.FieldUserAgent)
}

// SetIPAddress sets the "ip_address" field.
func (m *SessionMutation) SetIPAddress(s string) {
	m.ip_address = &s
}

// IPAddress returns the value of the "ip_address" field in the mutation.
func (m *SessionMutation) IPAddress() (r string, exists bool) {
	v := m.ip_address
	if v == nil {
		return
	}
	return *v, true
}

// OldIPAddress returns the old "ip_address" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldIPAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIPAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIPAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIPAddress: %w", err)
	}
	return oldValue.IPAddress, nil
}

// ClearIPAddress clears the value of the "ip_address" field.
func (m *SessionMutation) ClearIPAddress() {
	m.ip_address = nil
	m.clearedFields[session.FieldIPAddress] = struct{}{}
}

// IPAddressCleared returns if the "ip_address" field was cleared in this mutation.
func (m *SessionMutation) IPAddressCleared() bool {
	_, ok := m.clearedFields[session.FieldIPAddress]
	return ok
}

// ResetIPAddress resets all changes to the "ip_address" field.
func (m *SessionMutation) ResetIPAddress() {
	m.ip_address = nil
	delete(m.clearedFields, session.FieldIPAddress)
}

// SetExpiresAt sets the "expires_at" field.
func (m *SessionMutation) SetExpiresAt(t time.Time) {
	m.expires_at = &t
}

// ExpiresAt returns the value of the "expires_at" field in the mutation.
func (m *SessionMutation) ExpiresAt() (r time.Time, exists bool) {
	v := m.expires_at
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiresAt returns the old "expires_at" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldExpiresAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiresAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiresAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiresAt: %w", err)
	}
	return oldValue.ExpiresAt, nil
}

// ResetExpiresAt resets all changes to the "expires_at" field.
func (m *SessionMutation) ResetExpiresAt() {
	m.expires_at = nil
}

// SetLastActivity sets the "last_activity" field.
func (m *SessionMutation) SetLastActivity(t time.Time) {
	m.last_activity = &t
}

// LastActivity returns the value of the "last_activity" field in the mutation.
func (m *SessionMutation) LastActivity() (r time.Time, exists bool) {
	v := m.last_activity
	if v == nil {
		return
	}
	return *v, true
}

// OldLastActivity returns the old "last_activity" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldLastActivity(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastActivity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastActivity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastActivity: %w", err)
	}
	return oldValue.LastActivity, nil
}

// ResetLastActivity resets all changes to the "last_activity" field.
func (m *SessionMutation) ResetLastActivity() {
	m.last_activity = nil
}

// SetRevoked sets the "revoked" field.
func (m *SessionMutation) SetRevoked(b bool) {
	m.revoked = &b
}

// Revoked returns the value of the "revoked" field in the mutation.
func (m *SessionMutation) Revoked() (r bool, exists bool) {
	v := m.revoked
	if v == nil {
		return
	}
	return *v, true
}

// OldRevoked returns the old "revoked" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldRevoked(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRevoked is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRevoked requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRevoked: %w", err)
	}
	return oldValue.Revoked, nil
}

// ResetRevoked resets all changes to the "revoked" field.
func (m *SessionMutation) ResetRevoked() {
	m.revoked = nil
}

// SetRevokedAt sets the "revoked_at" field.
func (m *SessionMutation) SetRevokedAt(t time.Time) {
	m.revoked_at = &t
}

// RevokedAt returns the value of the "revoked_at" field in the mutation.
func (m *SessionMutation) RevokedAt() (r time.Time, exists bool) {
	v := m.revoked_at
	if v == nil {
		return
	}
	return *v, true
}

// OldRevokedAt returns the old "revoked_at" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldRevokedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRevokedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRevokedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRevokedAt: %w", err)
	}
	return oldValue.RevokedAt, nil
}

// ClearRevokedAt clears the value of the "revoked_at" field.
func (m *SessionMutation) ClearRevokedAt() {
	m.revoked_at = nil
	m.clearedFields[session.FieldRevokedAt] = struct{}{}
}

// RevokedAtCleared returns if the "revoked_at" field was cleared in this mutation.
func (m *SessionMutation) RevokedAtCleared() bool {
	_, ok := m.clearedFields[session.FieldRevokedAt]
	return ok
}

// ResetRevokedAt resets all changes to the "revoked_at" field.
func (m *SessionMutation) ResetRevokedAt() {
	m.revoked_at = nil
	delete(m.clearedFields, session.FieldRevokedAt)
}

// SetRevokedReason sets the "revoked_reason" field.
func (m *SessionMutation) SetRevokedReason(s string) {
	m.revoked_reason = &s
}

// RevokedReason returns the value of the "revoked_reason" field in the mutation.
func (m *SessionMutation) RevokedReason() (r string, exists bool) {
	v := m.revoked_reason
	if v == nil {
		return
	}
	return *v, true
}

// OldRevokedReason returns the old "revoked_reason" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldRevokedReason(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRevokedReason is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRevokedReason requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRevokedReason: %w", err)
	}
	return oldValue.RevokedReason, nil
}

// ClearRevokedReason clears the value of the "revoked_reason" field.
func (m *SessionMutation) ClearRevokedReason() {
	m.revoked_reason = nil
	m.clearedFields[session.FieldRevokedReason] = struct{}{}
}

// RevokedReasonCleared returns if the "revoked_reason" field was cleared in this mutation.
func (m *SessionMutation) RevokedReasonCleared() bool {
	_, ok := m.clearedFields[session.FieldRevokedReason]
	return ok
}

// ResetRevokedReason resets all changes to the "revoked_reason" field.
func (m *SessionMutation) ResetRevokedReason() {
	m.revoked_reason = nil
	delete(m.clearedFields, session.FieldRevokedReason)
}

// SetCreatedAt sets the "created_at" field.
func (m *SessionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SessionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SessionMutation) ResetCreatedAt() {
	m.created_at = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *SessionMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[session.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *SessionMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *SessionMutation) UserIDs() (ids []string) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *SessionMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the SessionMutation builder.
func (m *SessionMutation) Where(ps ...predicate.Session) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SessionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SessionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Session, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SessionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SessionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Session).
func (m *SessionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SessionMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.user != nil {
		fields = append(fields, session.FieldUserID)
	}
	if m.token_id != nil {
		fields = append(fields, session.FieldTokenID)
	}
	if m.token_family != nil {
		fields = append(fields, session.FieldTokenFamily)
	}
	if m.user_agent != nil {
		fields = append(fields, session.FieldUserAgent)
	}
	if m.ip_address != nil {
		fields = append(fields, session.FieldIPAddress)
	}
	if m.expires_at != nil {
		fields = append(fields, session.FieldExpiresAt)
	}
	if m.last_activity != nil {
		fields = append(fields, session.FieldLastActivity)
	}
	if m.revoked != nil {
		fields = append(fields, session.FieldRevoked)
	}
	if m.revoked_at != nil {
		fields = append(fields, session.FieldRevokedAt)
	}
	if m.revoked_reason != nil {
		fields = append(fields, session.FieldRevokedReason)
	}
	if m.created_at != nil {
		fields = append(fields, session.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SessionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case session.FieldUserID:
		return m.UserID()
	case session.FieldTokenID:
		return m.TokenID()
	case session.FieldTokenFamily:
		return m.TokenFamily()
	case session.FieldUserAgent:
		return m.UserAgent()
	case session.FieldIPAddress:
		return m.IPAddress()
	case session.FieldExpiresAt:
		return m.ExpiresAt()
	case session.FieldLastActivity:
		return m.LastActivity()
	case session.FieldRevoked:
		return m.Revoked()
	case session.FieldRevokedAt:
		return m.RevokedAt()
	case session.FieldRevokedReason:
		return m.RevokedReason()
	case session.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SessionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case session.FieldUserID:
		return m.OldUserID(ctx)
	case session.FieldTokenID:
		return m.OldTokenID(ctx)
	case session.FieldTokenFamily:
		return m.OldTokenFamily(ctx)
	case session.FieldUserAgent:
		return m.OldUserAgent(ctx)
	case session.FieldIPAddress:
		return m.OldIPAddress(ctx)
	case session.FieldExpiresAt:
		return m.OldExpiresAt(ctx)
	case session.FieldLastActivity:
		return m.OldLastActivity(ctx)
	case session.FieldRevoked:
		return m.OldRevoked(ctx)
	case session.FieldRevokedAt:
		return m.OldRevokedAt(ctx)
	case session.FieldRevokedReason:
		return m.OldRevokedReason(ctx)
	case session.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Session field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SessionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case session.FieldUserID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case session.FieldTokenID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTokenID(v)
		return nil
	case session.FieldTokenFamily:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTokenFamily(v)
		return nil
	case session.FieldUserAgent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserAgent(v)
		return nil
	case session.FieldIPAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIPAddress(v)
		return nil
	case session.FieldExpiresAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiresAt(v)
		return nil
	case session.FieldLastActivity:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastActivity(v)
		return nil
	case session.FieldRevoked:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRevoked(v)
		return nil
	case session.FieldRevokedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRevokedAt(v)
		return nil
	case session.FieldRevokedReason:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRevokedReason(v)
		return nil
	case session.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Session field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SessionMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SessionMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SessionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Session numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SessionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(session.FieldTokenFamily) {
		fields = append(fields, session.FieldTokenFamily)
	}
	if m.FieldCleared(session.FieldUserAgent) {
		fields = append(fields, session.FieldUserAgent)
	}
	if m.FieldCleared(session.FieldIPAddress) {
		fields = append(fields, session.FieldIPAddress)
	}
	if m.FieldCleared(session.FieldRevokedAt) {
		fields = append(fields, session.FieldRevokedAt)
	}
	if m.FieldCleared(session.FieldRevokedReason) {
		fields = append(fields, session.FieldRevokedReason)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SessionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SessionMutation) ClearField(name string) error {
	switch name {
	case session.FieldTokenFamily:
		m.ClearTokenFamily()
		return nil
	case session.FieldUserAgent:
		m.ClearUserAgent()
		return nil
	case session.FieldIPAddress:
		m.ClearIPAddress()
		return nil
	case session.FieldRevokedAt:
		m.ClearRevokedAt()
		return nil
	case session.FieldRevokedReason:
		m.ClearRevokedReason()
		return nil
	}
	return fmt.Errorf("unknown Session nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SessionMutation) ResetField(name string) error {
	switch name {
	case session.FieldUserID:
		m.ResetUserID()
		return nil
	case session.FieldTokenID:
		m.ResetTokenID()
		return nil
	case session.FieldTokenFamily:
		m.ResetTokenFamily()
		return nil
	case session.FieldUserAgent:
		m.ResetUserAgent()
		return nil
	case session.FieldIPAddress:
		m.ResetIPAddress()
		return nil
	case session.FieldExpiresAt:
		m.ResetExpiresAt()
		return nil
	case session.FieldLastActivity:
		m.ResetLastActivity()
		return nil
	case session.FieldRevoked:
		m.ResetRevoked()
		return nil
	case session.FieldRevokedAt:
		m.ResetRevokedAt()
		return nil
	case session.FieldRevokedReason:
		m.ResetRevokedReason()
		return nil
	case session.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown Session field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SessionMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, session.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SessionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case session.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SessionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SessionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SessionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, session.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SessionMutation) EdgeCleared(name string) bool {
	switch name {
	case session.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SessionMutation) ClearEdge(name string) error {
	switch name {
	case session.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown Session unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SessionMutation) ResetEdge(name string) error {
	switch name {
	case session.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown Session edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op                  Op
	typ                 string
	id                  *string
	username            *string
	email               *string
	display_name        *string
	password_hash       *string
	role                *user.Role
	active              *bool
	mfa_enabled         *bool
	mfa_secret          *string
	last_login          *time.Time
	password_changed_at *time.Time
	created_at          *time.Time
	updated_at          *time.Time
	clearedFields       map[string]struct{}
	sessions            map[string]struct{}
	removedsessions     map[string]struct{}
	clearedsessions     bool
	api_keys            map[string]struct{}
	removedapi_keys     map[string]struct{}
	clearedapi_keys     bool
	done                bool
	oldValue            func(context.Context) (*User, error)
	predicates          []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id string) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of User entities.
func (m *UserMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUsername sets the "username" field.
func (m *UserMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *UserMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ResetUsername resets all changes to the "username" field.
func (m *UserMutation) ResetUsername() {
	m.username = nil
}

// SetEmail sets the "email" field.
func (m *UserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *UserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ClearEmail clears the value of the "email" field.
func (m *UserMutation) ClearEmail() {
	m.email = nil
	m.clearedFields[user.FieldEmail] = struct{}{}
}

// EmailCleared returns if the "email" field was cleared in this mutation.
func (m *UserMutation) EmailCleared() bool {
	_, ok := m.clearedFields[user.FieldEmail]
	return ok
}

// ResetEmail resets all changes to the "email" field.
func (m *UserMutation) ResetEmail() {
	m.email = nil
	delete(m.clearedFields, user.FieldEmail)
}

// SetDisplayName sets the "display_name" field.
func (m *UserMutation) SetDisplayName(s string) {
	m.display_name = &s
}

// DisplayName returns the value of the "display_name" field in the mutation.
func (m *UserMutation) DisplayName() (r string, exists bool) {
	v := m.display_name
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplayName returns the old "display_name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldDisplayName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplayName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplayName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplayName: %w", err)
	}
	return oldValue.DisplayName, nil
}

// ClearDisplayName clears the value of the "display_name" field.
func (m *UserMutation) ClearDisplayName() {
	m.display_name = nil
	m.clearedFields[user.FieldDisplayName] = struct{}{}
}

// DisplayNameCleared returns if the "display_name" field was cleared in this mutation.
func (m *UserMutation) DisplayNameCleared() bool {
	_, ok := m.clearedFields[user.FieldDisplayName]
	return ok
}

// ResetDisplayName resets all changes to the "display_name" field.
func (m *UserMutation) ResetDisplayName() {
	m.display_name = nil
	delete(m.clearedFields, user.FieldDisplayName)
}

// SetPasswordHash sets the "password_hash" field.
func (m *UserMutation) SetPasswordHash(s string) {
	m.password_hash = &s
}

// PasswordHash returns the value of the "password_hash" field in the mutation.
func (m *UserMutation) PasswordHash() (r string, exists bool) {
	v := m.password_hash
	if v == nil {
		return
	}
	return *v, true
}

// OldPasswordHash returns the old "password_hash" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPasswordHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPasswordHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPasswordHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPasswordHash: %w", err)
	}
	return oldValue.PasswordHash, nil
}

// ResetPasswordHash resets all changes to the "password_hash" field.
func (m *UserMutation) ResetPasswordHash() {
	m.password_hash = nil
}

// SetRole sets the "role" field.
func (m *UserMutation) SetRole(u user.Role) {
	m.role = &u
}

// Role returns the value of the "role" field in the mutation.
func (m *UserMutation) Role() (r user.Role, exists bool) {
	v := m.role
	if v == nil {
		return
	}
	return *v, true
}

// OldRole returns the old "role" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldRole(ctx context.Context) (v user.Role, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRole is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRole requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRole: %w", err)
	}
	return oldValue.Role, nil
}

// ResetRole resets all changes to the "role" field.
func (m *UserMutation) ResetRole() {
	m.role = nil
}

// SetActive sets the "active" field.
func (m *UserMutation) SetActive(b bool) {
	m.active = &b
}

// Active returns the value of the "active" field in the mutation.
func (m *UserMutation) Active() (r bool, exists bool) {
	v := m.active
	if v == nil {
		return
	}
	return *v, true
}

// OldActive returns the old "active" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActive: %w", err)
	}
	return oldValue.Active, nil
}

// ResetActive resets all changes to the "active" field.
func (m *UserMutation) ResetActive() {
	m.active = nil
}

// SetMfaEnabled sets the "mfa_enabled" field.
func (m *UserMutation) SetMfaEnabled(b bool) {
	m.mfa_enabled = &b
}

// MfaEnabled returns the value of the "mfa_enabled" field in the mutation.
func (m *UserMutation) MfaEnabled() (r bool, exists bool) {
	v := m.mfa_enabled
	if v == nil {
		return
	}
	return *v, true
}

// OldMfaEnabled returns the old "mfa_enabled" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldMfaEnabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMfaEnabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMfaEnabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMfaEnabled: %w", err)
	}
	return oldValue.MfaEnabled, nil
}

// ResetMfaEnabled resets all changes to the "mfa_enabled" field.
func (m *UserMutation) ResetMfaEnabled() {
	m.mfa_enabled = nil
}

// SetMfaSecret sets the "mfa_secret" field.
func (m *UserMutation) SetMfaSecret(s string) {
	m.mfa_secret = &s
}

// MfaSecret returns the value of the "mfa_secret" field in the mutation.
func (m *UserMutation) MfaSecret() (r string, exists bool) {
	v := m.mfa_secret
	if v == nil {
		return
	}
	return *v, true
}

// OldMfaSecret returns the old "mfa_secret" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldMfaSecret(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMfaSecret is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMfaSecret requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMfaSecret: %w", err)
	}
	return oldValue.MfaSecret, nil
}

// ClearMfaSecret clears the value of the "mfa_secret" field.
func (m *UserMutation) ClearMfaSecret() {
	m.mfa_secret = nil
	m.clearedFields[user.FieldMfaSecret] = struct{}{}
}

// MfaSecretCleared returns if the "mfa_secret" field was cleared in this mutation.
func (m *UserMutation) MfaSecretCleared() bool {
	_, ok := m.clearedFields[user.FieldMfaSecret]
	return ok
}

// ResetMfaSecret resets all changes to the "mfa_secret" field.
func (m *UserMutation) ResetMfaSecret() {
	m.mfa_secret = nil
	delete(m.clearedFields, user.FieldMfaSecret)
}

// SetLastLogin sets the "last_login" field.
func (m *UserMutation) SetLastLogin(t time.Time) {
	m.last_login = &t
}

// LastLogin returns the value of the "last_login" field in the mutation.
func (m *UserMutation) LastLogin() (r time.Time, exists bool) {
	v := m.last_login
	if v == nil {
		return
	}
	return *v, true
}

// OldLastLogin returns the old "last_login" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldLastLogin(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastLogin is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastLogin requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastLogin: %w", err)
	}
	return oldValue.LastLogin, nil
}

// ClearLastLogin clears the value of the "last_login" field.
func (m *UserMutation) ClearLastLogin() {
	m.last_login = nil
	m.clearedFields[user.FieldLastLogin] = struct{}{}
}

// LastLoginCleared returns if the "last_login" field was cleared in this mutation.
func (m *UserMutation) LastLoginCleared() bool {
	_, ok := m.clearedFields[user.FieldLastLogin]
	return ok
}

// ResetLastLogin resets all changes to the "last_login" field.
func (m *UserMutation) ResetLastLogin() {
	m.last_login = nil
	delete(m.clearedFields, user.FieldLastLogin)
}

// SetPasswordChangedAt sets the "password_changed_at" field.
func (m *UserMutation) SetPasswordChangedAt(t time.Time) {
	m.password_changed_at = &t
}

// PasswordChangedAt returns the value of the "password_changed_at" field in the mutation.
func (m *UserMutation) PasswordChangedAt() (r time.Time, exists bool) {
	v := m.password_changed_at
	if v == nil {
		return
	}
	return *v, true
}

// OldPasswordChangedAt returns the old "password_changed_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPasswordChangedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPasswordChangedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPasswordChangedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPasswordChangedAt: %w", err)
	}
	return oldValue.PasswordChangedAt, nil
}

// ResetPasswordChangedAt resets all changes to the "password_changed_at" field.
func (m *UserMutation) ResetPasswordChangedAt() {
	m.password_changed_at = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *UserMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// AddSessionIDs adds the "sessions" edge to the Session entity by ids.
func (m *UserMutation) AddSessionIDs(ids ...string) {
	if m.sessions == nil {
		m.sessions = make(map[string]struct{})
	}
	for i := range ids {
		m.sessions[ids[i]] = struct{}{}
	}
}

// ClearSessions clears the "sessions" edge to the Session entity.
func (m *UserMutation) ClearSessions() {
	m.clearedsessions = true
}

// SessionsCleared reports if the "sessions" edge to the Session entity was cleared.
func (m *UserMutation) SessionsCleared() bool {
	return m.clearedsessions
}

// RemoveSessionIDs removes the "sessions" edge to the Session entity by IDs.
func (m *UserMutation) RemoveSessionIDs(ids ...string) {
	if m.removedsessions == nil {
		m.removedsessions = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.sessions, ids[i])
		m.removedsessions[ids[i]] = struct{}{}
	}
}

// RemovedSessions returns the removed IDs of the "sessions" edge to the Session entity.
func (m *UserMutation) RemovedSessionsIDs() (ids []string) {
	for id := range m.removedsessions {
		ids = append(ids, id)
	}
	return
}

// SessionsIDs returns the "sessions" edge IDs in the mutation.
func (m *UserMutation) SessionsIDs() (ids []string) {
	for id := range m.sessions {
		ids = append(ids, id)
	}
	return
}

// ResetSessions resets all changes to the "sessions" edge.
func (m *UserMutation) ResetSessions() {
	m.sessions = nil
	m.clearedsessions = false
	m.removedsessions = nil
}

// AddAPIKeyIDs adds the "api_keys" edge to the APIKey entity by ids.
func (m *UserMutation) AddAPIKeyIDs(ids ...string) {
	if m.api_keys == nil {
		m.api_keys = make(map[string]struct{})
	}
	for i := range ids {
		m.api_keys[ids[i]] = struct{}{}
	}
}

// ClearAPIKeys clears the "api_keys" edge to the APIKey entity.
func (m *UserMutation) ClearAPIKeys() {
	m.clearedapi_keys = true
}

// APIKeysCleared reports if the "api_keys" edge to the APIKey entity was cleared.
func (m *UserMutation) APIKeysCleared() bool {
	return m.clearedapi_keys
}

// RemoveAPIKeyIDs removes the "api_keys" edge to the APIKey entity by IDs.
func (m *UserMutation) RemoveAPIKeyIDs(ids ...string) {
	if m.removedapi_keys == nil {
		m.removedapi_keys = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.api_keys, ids[i])
		m.removedapi_keys[ids[i]] = struct{}{}
	}
}

// RemovedAPIKeys returns the removed IDs of the "api_keys" edge to the APIKey entity.
func (m *UserMutation) RemovedAPIKeysIDs() (ids []string) {
	for id := range m.removedapi_keys {
		ids = append(ids, id)
	}
	return
}

// APIKeysIDs returns the "api_keys" edge IDs in the mutation.
func (m *UserMutation) APIKeysIDs() (ids []string) {
	for id := range m.api_keys {
		ids = append(ids, id)
	}
	return
}

// ResetAPIKeys resets all changes to the "api_keys" edge.
func (m *UserMutation) ResetAPIKeys() {
	m.api_keys = nil
	m.clearedapi_keys = false
	m.removedapi_keys = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.username != nil {
		fields = append(fields, user.FieldUsername)
	}
	if m.email != nil {
		fields = append(fields, user.FieldEmail)
	}
	if m.display_name != nil {
		fields = append(fields, user.FieldDisplayName)
	}
	if m.password_hash != nil {
		fields = append(fields, user.FieldPasswordHash)
	}
	if m.role != nil {
		fields = append(fields, user.FieldRole)
	}
	if m.active != nil {
		fields = append(fields, user.FieldActive)
	}
	if m.mfa_enabled != nil {
		fields = append(fields, user.FieldMfaEnabled)
	}
	if m.mfa_secret != nil {
		fields = append(fields, user.FieldMfaSecret)
	}
	if m.last_login != nil {
		fields = append(fields, user.FieldLastLogin)
	}
	if m.password_changed_at != nil {
		fields = append(fields, user.FieldPasswordChangedAt)
	}
	if m.created_at != nil {
		fields = append(fields, user.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, user.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldUsername:
		return m.Username()
	case user.FieldEmail:
		return m.Email()
	case user.FieldDisplayName:
		return m.DisplayName()
	case user.FieldPasswordHash:
		return m.PasswordHash()
	case user.FieldRole:
		return m.Role()
	case user.FieldActive:
		return m.Active()
	case user.FieldMfaEnabled:
		return m.MfaEnabled()
	case user.FieldMfaSecret:
		return m.MfaSecret()
	case user.FieldLastLogin:
		return m.LastLogin()
	case user.FieldPasswordChangedAt:
		return m.PasswordChangedAt()
	case user.FieldCreatedAt:
		return m.CreatedAt()
	case user.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldUsername:
		return m.OldUsername(ctx)
	case user.FieldEmail:
		return m.OldEmail(ctx)
	case user.FieldDisplayName:
		return m.OldDisplayName(ctx)
	case user.FieldPasswordHash:
		return m.OldPasswordHash(ctx)
	case user.FieldRole:
		return m.OldRole(ctx)
	case user.FieldActive:
		return m.OldActive(ctx)
	case user.FieldMfaEnabled:
		return m.OldMfaEnabled(ctx)
	case user.FieldMfaSecret:
		return m.OldMfaSecret(ctx)
	case user.FieldLastLogin:
		return m.OldLastLogin(ctx)
	case user.FieldPasswordChangedAt:
		return m.OldPasswordChangedAt(ctx)
	case user.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case user.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case user.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case user.FieldDisplayName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplayName(v)
		return nil
	case user.FieldPasswordHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPasswordHash(v)
		return nil
	case user.FieldRole:
		v, ok := value.(user.Role)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRole(v)
		return nil
	case user.FieldActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActive(v)
		return nil
	case user.FieldMfaEnabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMfaEnabled(v)
		return nil
	case user.FieldMfaSecret:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMfaSecret(v)
		return nil
	case user.FieldLastLogin:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastLogin(v)
		return nil
	case user.FieldPasswordChangedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPasswordChangedAt(v)
		return nil
	case user.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case user.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(user.FieldEmail) {
		fields = append(fields, user.FieldEmail)
	}
	if m.FieldCleared(user.FieldDisplayName) {
		fields = append(fields, user.FieldDisplayName)
	}
	if m.FieldCleared(user.FieldMfaSecret) {
		fields = append(fields, user.FieldMfaSecret)
	}
	if m.FieldCleared(user.FieldLastLogin) {
		fields = append(fields, user.FieldLastLogin)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	switch name {
	case user.FieldEmail:
		m.ClearEmail()
		return nil
	case user.FieldDisplayName:
		m.ClearDisplayName()
		return nil
	case user.FieldMfaSecret:
		m.ClearMfaSecret()
		return nil
	case user.FieldLastLogin:
		m.ClearLastLogin()
		return nil
	}
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldUsername:
		m.ResetUsername()
		return nil
	case user.FieldEmail:
		m.ResetEmail()
		return nil
	case user.FieldDisplayName:
		m.ResetDisplayName()
		return nil
	case user.FieldPasswordHash:
		m.ResetPasswordHash()
		return nil
	case user.FieldRole:
		m.ResetRole()
		return nil
	case user.FieldActive:
		m.ResetActive()
		return nil
	case user.FieldMfaEnabled:
		m.ResetMfaEnabled()
		return nil
	case user.FieldMfaSecret:
		m.ResetMfaSecret()
		return nil
	case user.FieldLastLogin:
		m.ResetLastLogin()
		return nil
	case user.FieldPasswordChangedAt:
		m.ResetPasswordChangedAt()
		return nil
	case user.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case user.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.sessions != nil {
		edges = append(edges, user.EdgeSessions)
	}
	if m.api_keys != nil {
		edges = append(edges, user.EdgeAPIKeys)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeSessions:
		ids := make([]ent.Value, 0, len(m.sessions))
		for id := range m.sessions {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeAPIKeys:
		ids := make([]ent.Value, 0, len(m.api_keys))
		for id := range m.api_keys {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedsessions != nil {
		edges = append(edges, user.EdgeSessions)
	}
	if m.removedapi_keys != nil {
		edges = append(edges, user.EdgeAPIKeys)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeSessions:
		ids := make([]ent.Value, 0, len(m.removedsessions))
		for id := range m.removedsessions {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeAPIKeys:
		ids := make([]ent.Value, 0, len(m.removedapi_keys))
		for id := range m.removedapi_keys {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedsessions {
		edges = append(edges, user.EdgeSessions)
	}
	if m.clearedapi_keys {
		edges = append(edges, user.EdgeAPIKeys)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeSessions:
		return m.clearedsessions
	case user.EdgeAPIKeys:
		return m.clearedapi_keys
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeSessions:
		m.ResetSessions()
		return nil
	case user.EdgeAPIKeys:
		m.ResetAPIKeys()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}
