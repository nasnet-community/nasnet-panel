// Code generated by ent, DO NOT EDIT.

package ent

import (
	"backend/ent/alert"
	"backend/ent/alertdigestentry"
	"backend/ent/alertescalation"
	"backend/ent/alertrule"
	"backend/ent/alertruletemplate"
	"backend/ent/alerttemplate"
	"backend/ent/apikey"
	"backend/ent/configsnapshot"
	"backend/ent/globalsettings"
	"backend/ent/notificationchannelconfig"
	"backend/ent/notificationlog"
	"backend/ent/notificationsettings"
	"backend/ent/portknocksequence"
	"backend/ent/predicate"
	"backend/ent/resource"
	"backend/ent/resourceevent"
	"backend/ent/router"
	"backend/ent/routercapability"
	"backend/ent/routersecret"
	"backend/ent/schemaversion"
	"backend/ent/serviceinstance"
	"backend/ent/session"
	"backend/ent/user"
	"backend/ent/webhook"
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/google/uuid"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAPIKey                    = "APIKey"
	TypeAlert                     = "Alert"
	TypeAlertDigestEntry          = "AlertDigestEntry"
	TypeAlertEscalation           = "AlertEscalation"
	TypeAlertRule                 = "AlertRule"
	TypeAlertRuleTemplate         = "AlertRuleTemplate"
	TypeAlertTemplate             = "AlertTemplate"
	TypeConfigSnapshot            = "ConfigSnapshot"
	TypeGlobalSettings            = "GlobalSettings"
	TypeNotificationChannelConfig = "NotificationChannelConfig"
	TypeNotificationLog           = "NotificationLog"
	TypeNotificationSettings      = "NotificationSettings"
	TypePortKnockSequence         = "PortKnockSequence"
	TypeResource                  = "Resource"
	TypeResourceEvent             = "ResourceEvent"
	TypeRouter                    = "Router"
	TypeRouterCapability          = "RouterCapability"
	TypeRouterSecret              = "RouterSecret"
	TypeSchemaVersion             = "SchemaVersion"
	TypeServiceInstance           = "ServiceInstance"
	TypeSession                   = "Session"
	TypeUser                      = "User"
	TypeWebhook                   = "Webhook"
)

// APIKeyMutation represents an operation that mutates the APIKey nodes in the graph.
type APIKeyMutation struct {
	config
	op                    Op
	typ                   string
	id                    *string
	name                  *string
	prefix                *string
	key_hash              *string
	scopes                *[]string
	appendscopes          []string
	allowed_routers       *[]string
	appendallowed_routers []string
	expires_at            *time.Time
	last_used_at          *time.Time
	usage_count           *int
	addusage_count        *int
	active                *bool
	revoked_at            *time.Time
	created_at            *time.Time
	updated_at            *time.Time
	clearedFields         map[string]struct{}
	user                  *string
	cleareduser           bool
	done                  bool
	oldValue              func(context.Context) (*APIKey, error)
	predicates            []predicate.APIKey
}

var _ ent.Mutation = (*APIKeyMutation)(nil)

// apikeyOption allows management of the mutation configuration using functional options.
type apikeyOption func(*APIKeyMutation)

// newAPIKeyMutation creates new mutation for the APIKey entity.
func newAPIKeyMutation(c config, op Op, opts ...apikeyOption) *APIKeyMutation {
	m := &APIKeyMutation{
		config:        c,
		op:            op,
		typ:           TypeAPIKey,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAPIKeyID sets the ID field of the mutation.
func withAPIKeyID(id string) apikeyOption {
	return func(m *APIKeyMutation) {
		var (
			err   error
			once  sync.Once
			value *APIKey
		)
		m.oldValue = func(ctx context.Context) (*APIKey, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().APIKey.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAPIKey sets the old APIKey of the mutation.
func withAPIKey(node *APIKey) apikeyOption {
	return func(m *APIKeyMutation) {
		m.oldValue = func(context.Context) (*APIKey, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m APIKeyMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m APIKeyMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of APIKey entities.
func (m *APIKeyMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *APIKeyMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *APIKeyMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().APIKey.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserID sets the "user_id" field.
func (m *APIKeyMutation) SetUserID(s string) {
	m.user = &s
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *APIKeyMutation) UserID() (r string, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the APIKey entity.
// If the APIKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIKeyMutation) OldUserID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *APIKeyMutation) ResetUserID() {
	m.user = nil
}

// SetName sets the "name" field.
func (m *APIKeyMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *APIKeyMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the APIKey entity.
// If the APIKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIKeyMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *APIKeyMutation) ResetName() {
	m.name = nil
}

// SetPrefix sets the "prefix" field.
func (m *APIKeyMutation) SetPrefix(s string) {
	m.prefix = &s
}

// Prefix returns the value of the "prefix" field in the mutation.
func (m *APIKeyMutation) Prefix() (r string, exists bool) {
	v := m.prefix
	if v == nil {
		return
	}
	return *v, true
}

// OldPrefix returns the old "prefix" field's value of the APIKey entity.
// If the APIKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIKeyMutation) OldPrefix(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrefix is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrefix requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrefix: %w", err)
	}
	return oldValue.Prefix, nil
}

// ResetPrefix resets all changes to the "prefix" field.
func (m *APIKeyMutation) ResetPrefix() {
	m.prefix = nil
}

// SetKeyHash sets the "key_hash" field.
func (m *APIKeyMutation) SetKeyHash(s string) {
	m.key_hash = &s
}

// KeyHash returns the value of the "key_hash" field in the mutation.
func (m *APIKeyMutation) KeyHash() (r string, exists bool) {
	v := m.key_hash
	if v == nil {
		return
	}
	return *v, true
}

// OldKeyHash returns the old "key_hash" field's value of the APIKey entity.
// If the APIKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIKeyMutation) OldKeyHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKeyHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKeyHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKeyHash: %w", err)
	}
	return oldValue.KeyHash, nil
}

// ResetKeyHash resets all changes to the "key_hash" field.
func (m *APIKeyMutation) ResetKeyHash() {
	m.key_hash = nil
}

// SetScopes sets the "scopes" field.
func (m *APIKeyMutation) SetScopes(s []string) {
	m.scopes = &s
	m.appendscopes = nil
}

// Scopes returns the value of the "scopes" field in the mutation.
func (m *APIKeyMutation) Scopes() (r []string, exists bool) {
	v := m.scopes
	if v == nil {
		return
	}
	return *v, true
}

// OldScopes returns the old "scopes" field's value of the APIKey entity.
// If the APIKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIKeyMutation) OldScopes(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScopes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScopes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScopes: %w", err)
	}
	return oldValue.Scopes, nil
}

// AppendScopes adds s to the "scopes" field.
func (m *APIKeyMutation) AppendScopes(s []string) {
	m.appendscopes = append(m.appendscopes, s...)
}

// AppendedScopes returns the list of values that were appended to the "scopes" field in this mutation.
func (m *APIKeyMutation) AppendedScopes() ([]string, bool) {
	if len(m.appendscopes) == 0 {
		return nil, false
	}
	return m.appendscopes, true
}

// ResetScopes resets all changes to the "scopes" field.
func (m *APIKeyMutation) ResetScopes() {
	m.scopes = nil
	m.appendscopes = nil
}

// SetAllowedRouters sets the "allowed_routers" field.
func (m *APIKeyMutation) SetAllowedRouters(s []string) {
	m.allowed_routers = &s
	m.appendallowed_routers = nil
}

// AllowedRouters returns the value of the "allowed_routers" field in the mutation.
func (m *APIKeyMutation) AllowedRouters() (r []string, exists bool) {
	v := m.allowed_routers
	if v == nil {
		return
	}
	return *v, true
}

// OldAllowedRouters returns the old "allowed_routers" field's value of the APIKey entity.
// If the APIKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIKeyMutation) OldAllowedRouters(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAllowedRouters is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAllowedRouters requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAllowedRouters: %w", err)
	}
	return oldValue.AllowedRouters, nil
}

// AppendAllowedRouters adds s to the "allowed_routers" field.
func (m *APIKeyMutation) AppendAllowedRouters(s []string) {
	m.appendallowed_routers = append(m.appendallowed_routers, s...)
}

// AppendedAllowedRouters returns the list of values that were appended to the "allowed_routers" field in this mutation.
func (m *APIKeyMutation) AppendedAllowedRouters() ([]string, bool) {
	if len(m.appendallowed_routers) == 0 {
		return nil, false
	}
	return m.appendallowed_routers, true
}

// ClearAllowedRouters clears the value of the "allowed_routers" field.
func (m *APIKeyMutation) ClearAllowedRouters() {
	m.allowed_routers = nil
	m.appendallowed_routers = nil
	m.clearedFields[apikey.FieldAllowedRouters] = struct{}{}
}

// AllowedRoutersCleared returns if the "allowed_routers" field was cleared in this mutation.
func (m *APIKeyMutation) AllowedRoutersCleared() bool {
	_, ok := m.clearedFields[apikey.FieldAllowedRouters]
	return ok
}

// ResetAllowedRouters resets all changes to the "allowed_routers" field.
func (m *APIKeyMutation) ResetAllowedRouters() {
	m.allowed_routers = nil
	m.appendallowed_routers = nil
	delete(m.clearedFields, apikey.FieldAllowedRouters)
}

// SetExpiresAt sets the "expires_at" field.
func (m *APIKeyMutation) SetExpiresAt(t time.Time) {
	m.expires_at = &t
}

// ExpiresAt returns the value of the "expires_at" field in the mutation.
func (m *APIKeyMutation) ExpiresAt() (r time.Time, exists bool) {
	v := m.expires_at
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiresAt returns the old "expires_at" field's value of the APIKey entity.
// If the APIKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIKeyMutation) OldExpiresAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiresAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiresAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiresAt: %w", err)
	}
	return oldValue.ExpiresAt, nil
}

// ClearExpiresAt clears the value of the "expires_at" field.
func (m *APIKeyMutation) ClearExpiresAt() {
	m.expires_at = nil
	m.clearedFields[apikey.FieldExpiresAt] = struct{}{}
}

// ExpiresAtCleared returns if the "expires_at" field was cleared in this mutation.
func (m *APIKeyMutation) ExpiresAtCleared() bool {
	_, ok := m.clearedFields[apikey.FieldExpiresAt]
	return ok
}

// ResetExpiresAt resets all changes to the "expires_at" field.
func (m *APIKeyMutation) ResetExpiresAt() {
	m.expires_at = nil
	delete(m.clearedFields, apikey.FieldExpiresAt)
}

// SetLastUsedAt sets the "last_used_at" field.
func (m *APIKeyMutation) SetLastUsedAt(t time.Time) {
	m.last_used_at = &t
}

// LastUsedAt returns the value of the "last_used_at" field in the mutation.
func (m *APIKeyMutation) LastUsedAt() (r time.Time, exists bool) {
	v := m.last_used_at
	if v == nil {
		return
	}
	return *v, true
}

// OldLastUsedAt returns the old "last_used_at" field's value of the APIKey entity.
// If the APIKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIKeyMutation) OldLastUsedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastUsedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastUsedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastUsedAt: %w", err)
	}
	return oldValue.LastUsedAt, nil
}

// ClearLastUsedAt clears the value of the "last_used_at" field.
func (m *APIKeyMutation) ClearLastUsedAt() {
	m.last_used_at = nil
	m.clearedFields[apikey.FieldLastUsedAt] = struct{}{}
}

// LastUsedAtCleared returns if the "last_used_at" field was cleared in this mutation.
func (m *APIKeyMutation) LastUsedAtCleared() bool {
	_, ok := m.clearedFields[apikey.FieldLastUsedAt]
	return ok
}

// ResetLastUsedAt resets all changes to the "last_used_at" field.
func (m *APIKeyMutation) ResetLastUsedAt() {
	m.last_used_at = nil
	delete(m.clearedFields, apikey.FieldLastUsedAt)
}

// SetUsageCount sets the "usage_count" field.
func (m *APIKeyMutation) SetUsageCount(i int) {
	m.usage_count = &i
	m.addusage_count = nil
}

// UsageCount returns the value of the "usage_count" field in the mutation.
func (m *APIKeyMutation) UsageCount() (r int, exists bool) {
	v := m.usage_count
	if v == nil {
		return
	}
	return *v, true
}

// OldUsageCount returns the old "usage_count" field's value of the APIKey entity.
// If the APIKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIKeyMutation) OldUsageCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsageCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsageCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsageCount: %w", err)
	}
	return oldValue.UsageCount, nil
}

// AddUsageCount adds i to the "usage_count" field.
func (m *APIKeyMutation) AddUsageCount(i int) {
	if m.addusage_count != nil {
		*m.addusage_count += i
	} else {
		m.addusage_count = &i
	}
}

// AddedUsageCount returns the value that was added to the "usage_count" field in this mutation.
func (m *APIKeyMutation) AddedUsageCount() (r int, exists bool) {
	v := m.addusage_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetUsageCount resets all changes to the "usage_count" field.
func (m *APIKeyMutation) ResetUsageCount() {
	m.usage_count = nil
	m.addusage_count = nil
}

// SetActive sets the "active" field.
func (m *APIKeyMutation) SetActive(b bool) {
	m.active = &b
}

// Active returns the value of the "active" field in the mutation.
func (m *APIKeyMutation) Active() (r bool, exists bool) {
	v := m.active
	if v == nil {
		return
	}
	return *v, true
}

// OldActive returns the old "active" field's value of the APIKey entity.
// If the APIKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIKeyMutation) OldActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActive: %w", err)
	}
	return oldValue.Active, nil
}

// ResetActive resets all changes to the "active" field.
func (m *APIKeyMutation) ResetActive() {
	m.active = nil
}

// SetRevokedAt sets the "revoked_at" field.
func (m *APIKeyMutation) SetRevokedAt(t time.Time) {
	m.revoked_at = &t
}

// RevokedAt returns the value of the "revoked_at" field in the mutation.
func (m *APIKeyMutation) RevokedAt() (r time.Time, exists bool) {
	v := m.revoked_at
	if v == nil {
		return
	}
	return *v, true
}

// OldRevokedAt returns the old "revoked_at" field's value of the APIKey entity.
// If the APIKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIKeyMutation) OldRevokedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRevokedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRevokedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRevokedAt: %w", err)
	}
	return oldValue.RevokedAt, nil
}

// ClearRevokedAt clears the value of the "revoked_at" field.
func (m *APIKeyMutation) ClearRevokedAt() {
	m.revoked_at = nil
	m.clearedFields[apikey.FieldRevokedAt] = struct{}{}
}

// RevokedAtCleared returns if the "revoked_at" field was cleared in this mutation.
func (m *APIKeyMutation) RevokedAtCleared() bool {
	_, ok := m.clearedFields[apikey.FieldRevokedAt]
	return ok
}

// ResetRevokedAt resets all changes to the "revoked_at" field.
func (m *APIKeyMutation) ResetRevokedAt() {
	m.revoked_at = nil
	delete(m.clearedFields, apikey.FieldRevokedAt)
}

// SetCreatedAt sets the "created_at" field.
func (m *APIKeyMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *APIKeyMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the APIKey entity.
// If the APIKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIKeyMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *APIKeyMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *APIKeyMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *APIKeyMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the APIKey entity.
// If the APIKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIKeyMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *APIKeyMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *APIKeyMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[apikey.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *APIKeyMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *APIKeyMutation) UserIDs() (ids []string) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *APIKeyMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the APIKeyMutation builder.
func (m *APIKeyMutation) Where(ps ...predicate.APIKey) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the APIKeyMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *APIKeyMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.APIKey, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *APIKeyMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *APIKeyMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (APIKey).
func (m *APIKeyMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *APIKeyMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.user != nil {
		fields = append(fields, apikey.FieldUserID)
	}
	if m.name != nil {
		fields = append(fields, apikey.FieldName)
	}
	if m.prefix != nil {
		fields = append(fields, apikey.FieldPrefix)
	}
	if m.key_hash != nil {
		fields = append(fields, apikey.FieldKeyHash)
	}
	if m.scopes != nil {
		fields = append(fields, apikey.FieldScopes)
	}
	if m.allowed_routers != nil {
		fields = append(fields, apikey.FieldAllowedRouters)
	}
	if m.expires_at != nil {
		fields = append(fields, apikey.FieldExpiresAt)
	}
	if m.last_used_at != nil {
		fields = append(fields, apikey.FieldLastUsedAt)
	}
	if m.usage_count != nil {
		fields = append(fields, apikey.FieldUsageCount)
	}
	if m.active != nil {
		fields = append(fields, apikey.FieldActive)
	}
	if m.revoked_at != nil {
		fields = append(fields, apikey.FieldRevokedAt)
	}
	if m.created_at != nil {
		fields = append(fields, apikey.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, apikey.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *APIKeyMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case apikey.FieldUserID:
		return m.UserID()
	case apikey.FieldName:
		return m.Name()
	case apikey.FieldPrefix:
		return m.Prefix()
	case apikey.FieldKeyHash:
		return m.KeyHash()
	case apikey.FieldScopes:
		return m.Scopes()
	case apikey.FieldAllowedRouters:
		return m.AllowedRouters()
	case apikey.FieldExpiresAt:
		return m.ExpiresAt()
	case apikey.FieldLastUsedAt:
		return m.LastUsedAt()
	case apikey.FieldUsageCount:
		return m.UsageCount()
	case apikey.FieldActive:
		return m.Active()
	case apikey.FieldRevokedAt:
		return m.RevokedAt()
	case apikey.FieldCreatedAt:
		return m.CreatedAt()
	case apikey.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *APIKeyMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case apikey.FieldUserID:
		return m.OldUserID(ctx)
	case apikey.FieldName:
		return m.OldName(ctx)
	case apikey.FieldPrefix:
		return m.OldPrefix(ctx)
	case apikey.FieldKeyHash:
		return m.OldKeyHash(ctx)
	case apikey.FieldScopes:
		return m.OldScopes(ctx)
	case apikey.FieldAllowedRouters:
		return m.OldAllowedRouters(ctx)
	case apikey.FieldExpiresAt:
		return m.OldExpiresAt(ctx)
	case apikey.FieldLastUsedAt:
		return m.OldLastUsedAt(ctx)
	case apikey.FieldUsageCount:
		return m.OldUsageCount(ctx)
	case apikey.FieldActive:
		return m.OldActive(ctx)
	case apikey.FieldRevokedAt:
		return m.OldRevokedAt(ctx)
	case apikey.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case apikey.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown APIKey field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *APIKeyMutation) SetField(name string, value ent.Value) error {
	switch name {
	case apikey.FieldUserID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case apikey.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case apikey.FieldPrefix:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrefix(v)
		return nil
	case apikey.FieldKeyHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKeyHash(v)
		return nil
	case apikey.FieldScopes:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScopes(v)
		return nil
	case apikey.FieldAllowedRouters:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAllowedRouters(v)
		return nil
	case apikey.FieldExpiresAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiresAt(v)
		return nil
	case apikey.FieldLastUsedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastUsedAt(v)
		return nil
	case apikey.FieldUsageCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsageCount(v)
		return nil
	case apikey.FieldActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActive(v)
		return nil
	case apikey.FieldRevokedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRevokedAt(v)
		return nil
	case apikey.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case apikey.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown APIKey field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *APIKeyMutation) AddedFields() []string {
	var fields []string
	if m.addusage_count != nil {
		fields = append(fields, apikey.FieldUsageCount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *APIKeyMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case apikey.FieldUsageCount:
		return m.AddedUsageCount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *APIKeyMutation) AddField(name string, value ent.Value) error {
	switch name {
	case apikey.FieldUsageCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUsageCount(v)
		return nil
	}
	return fmt.Errorf("unknown APIKey numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *APIKeyMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(apikey.FieldAllowedRouters) {
		fields = append(fields, apikey.FieldAllowedRouters)
	}
	if m.FieldCleared(apikey.FieldExpiresAt) {
		fields = append(fields, apikey.FieldExpiresAt)
	}
	if m.FieldCleared(apikey.FieldLastUsedAt) {
		fields = append(fields, apikey.FieldLastUsedAt)
	}
	if m.FieldCleared(apikey.FieldRevokedAt) {
		fields = append(fields, apikey.FieldRevokedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *APIKeyMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *APIKeyMutation) ClearField(name string) error {
	switch name {
	case apikey.FieldAllowedRouters:
		m.ClearAllowedRouters()
		return nil
	case apikey.FieldExpiresAt:
		m.ClearExpiresAt()
		return nil
	case apikey.FieldLastUsedAt:
		m.ClearLastUsedAt()
		return nil
	case apikey.FieldRevokedAt:
		m.ClearRevokedAt()
		return nil
	}
	return fmt.Errorf("unknown APIKey nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *APIKeyMutation) ResetField(name string) error {
	switch name {
	case apikey.FieldUserID:
		m.ResetUserID()
		return nil
	case apikey.FieldName:
		m.ResetName()
		return nil
	case apikey.FieldPrefix:
		m.ResetPrefix()
		return nil
	case apikey.FieldKeyHash:
		m.ResetKeyHash()
		return nil
	case apikey.FieldScopes:
		m.ResetScopes()
		return nil
	case apikey.FieldAllowedRouters:
		m.ResetAllowedRouters()
		return nil
	case apikey.FieldExpiresAt:
		m.ResetExpiresAt()
		return nil
	case apikey.FieldLastUsedAt:
		m.ResetLastUsedAt()
		return nil
	case apikey.FieldUsageCount:
		m.ResetUsageCount()
		return nil
	case apikey.FieldActive:
		m.ResetActive()
		return nil
	case apikey.FieldRevokedAt:
		m.ResetRevokedAt()
		return nil
	case apikey.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case apikey.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown APIKey field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *APIKeyMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, apikey.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *APIKeyMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case apikey.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *APIKeyMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *APIKeyMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *APIKeyMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, apikey.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *APIKeyMutation) EdgeCleared(name string) bool {
	switch name {
	case apikey.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *APIKeyMutation) ClearEdge(name string) error {
	switch name {
	case apikey.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown APIKey unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *APIKeyMutation) ResetEdge(name string) error {
	switch name {
	case apikey.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown APIKey edge %s", name)
}

// AlertMutation represents an operation that mutates the Alert nodes in the graph.
type AlertMutation struct {
	config
	op                       Op
	typ                      string
	id                       *string
	event_type               *string
	severity                 *alert.Severity
	title                    *string
	message                  *string
	data                     *map[string]interface{}
	device_id                *string
	acknowledged_at          *time.Time
	acknowledged_by          *string
	suppressed_count         *int
	addsuppressed_count      *int
	suppress_reason          *string
	delivery_status          *map[string]interface{}
	triggered_at             *time.Time
	updated_at               *time.Time
	clearedFields            map[string]struct{}
	rule                     *string
	clearedrule              bool
	escalations              map[string]struct{}
	removedescalations       map[string]struct{}
	clearedescalations       bool
	notification_logs        map[string]struct{}
	removednotification_logs map[string]struct{}
	clearednotification_logs bool
	done                     bool
	oldValue                 func(context.Context) (*Alert, error)
	predicates               []predicate.Alert
}

var _ ent.Mutation = (*AlertMutation)(nil)

// alertOption allows management of the mutation configuration using functional options.
type alertOption func(*AlertMutation)

// newAlertMutation creates new mutation for the Alert entity.
func newAlertMutation(c config, op Op, opts ...alertOption) *AlertMutation {
	m := &AlertMutation{
		config:        c,
		op:            op,
		typ:           TypeAlert,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAlertID sets the ID field of the mutation.
func withAlertID(id string) alertOption {
	return func(m *AlertMutation) {
		var (
			err   error
			once  sync.Once
			value *Alert
		)
		m.oldValue = func(ctx context.Context) (*Alert, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Alert.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAlert sets the old Alert of the mutation.
func withAlert(node *Alert) alertOption {
	return func(m *AlertMutation) {
		m.oldValue = func(context.Context) (*Alert, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AlertMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AlertMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Alert entities.
func (m *AlertMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AlertMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AlertMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Alert.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetRuleID sets the "rule_id" field.
func (m *AlertMutation) SetRuleID(s string) {
	m.rule = &s
}

// RuleID returns the value of the "rule_id" field in the mutation.
func (m *AlertMutation) RuleID() (r string, exists bool) {
	v := m.rule
	if v == nil {
		return
	}
	return *v, true
}

// OldRuleID returns the old "rule_id" field's value of the Alert entity.
// If the Alert object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertMutation) OldRuleID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRuleID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRuleID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRuleID: %w", err)
	}
	return oldValue.RuleID, nil
}

// ResetRuleID resets all changes to the "rule_id" field.
func (m *AlertMutation) ResetRuleID() {
	m.rule = nil
}

// SetEventType sets the "event_type" field.
func (m *AlertMutation) SetEventType(s string) {
	m.event_type = &s
}

// EventType returns the value of the "event_type" field in the mutation.
func (m *AlertMutation) EventType() (r string, exists bool) {
	v := m.event_type
	if v == nil {
		return
	}
	return *v, true
}

// OldEventType returns the old "event_type" field's value of the Alert entity.
// If the Alert object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertMutation) OldEventType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEventType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEventType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEventType: %w", err)
	}
	return oldValue.EventType, nil
}

// ResetEventType resets all changes to the "event_type" field.
func (m *AlertMutation) ResetEventType() {
	m.event_type = nil
}

// SetSeverity sets the "severity" field.
func (m *AlertMutation) SetSeverity(a alert.Severity) {
	m.severity = &a
}

// Severity returns the value of the "severity" field in the mutation.
func (m *AlertMutation) Severity() (r alert.Severity, exists bool) {
	v := m.severity
	if v == nil {
		return
	}
	return *v, true
}

// OldSeverity returns the old "severity" field's value of the Alert entity.
// If the Alert object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertMutation) OldSeverity(ctx context.Context) (v alert.Severity, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSeverity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSeverity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSeverity: %w", err)
	}
	return oldValue.Severity, nil
}

// ResetSeverity resets all changes to the "severity" field.
func (m *AlertMutation) ResetSeverity() {
	m.severity = nil
}

// SetTitle sets the "title" field.
func (m *AlertMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *AlertMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Alert entity.
// If the Alert object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *AlertMutation) ResetTitle() {
	m.title = nil
}

// SetMessage sets the "message" field.
func (m *AlertMutation) SetMessage(s string) {
	m.message = &s
}

// Message returns the value of the "message" field in the mutation.
func (m *AlertMutation) Message() (r string, exists bool) {
	v := m.message
	if v == nil {
		return
	}
	return *v, true
}

// OldMessage returns the old "message" field's value of the Alert entity.
// If the Alert object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertMutation) OldMessage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMessage: %w", err)
	}
	return oldValue.Message, nil
}

// ResetMessage resets all changes to the "message" field.
func (m *AlertMutation) ResetMessage() {
	m.message = nil
}

// SetData sets the "data" field.
func (m *AlertMutation) SetData(value map[string]interface{}) {
	m.data = &value
}

// Data returns the value of the "data" field in the mutation.
func (m *AlertMutation) Data() (r map[string]interface{}, exists bool) {
	v := m.data
	if v == nil {
		return
	}
	return *v, true
}

// OldData returns the old "data" field's value of the Alert entity.
// If the Alert object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertMutation) OldData(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldData is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldData requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldData: %w", err)
	}
	return oldValue.Data, nil
}

// ClearData clears the value of the "data" field.
func (m *AlertMutation) ClearData() {
	m.data = nil
	m.clearedFields[alert.FieldData] = struct{}{}
}

// DataCleared returns if the "data" field was cleared in this mutation.
func (m *AlertMutation) DataCleared() bool {
	_, ok := m.clearedFields[alert.FieldData]
	return ok
}

// ResetData resets all changes to the "data" field.
func (m *AlertMutation) ResetData() {
	m.data = nil
	delete(m.clearedFields, alert.FieldData)
}

// SetDeviceID sets the "device_id" field.
func (m *AlertMutation) SetDeviceID(s string) {
	m.device_id = &s
}

// DeviceID returns the value of the "device_id" field in the mutation.
func (m *AlertMutation) DeviceID() (r string, exists bool) {
	v := m.device_id
	if v == nil {
		return
	}
	return *v, true
}

// OldDeviceID returns the old "device_id" field's value of the Alert entity.
// If the Alert object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertMutation) OldDeviceID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeviceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeviceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeviceID: %w", err)
	}
	return oldValue.DeviceID, nil
}

// ClearDeviceID clears the value of the "device_id" field.
func (m *AlertMutation) ClearDeviceID() {
	m.device_id = nil
	m.clearedFields[alert.FieldDeviceID] = struct{}{}
}

// DeviceIDCleared returns if the "device_id" field was cleared in this mutation.
func (m *AlertMutation) DeviceIDCleared() bool {
	_, ok := m.clearedFields[alert.FieldDeviceID]
	return ok
}

// ResetDeviceID resets all changes to the "device_id" field.
func (m *AlertMutation) ResetDeviceID() {
	m.device_id = nil
	delete(m.clearedFields, alert.FieldDeviceID)
}

// SetAcknowledgedAt sets the "acknowledged_at" field.
func (m *AlertMutation) SetAcknowledgedAt(t time.Time) {
	m.acknowledged_at = &t
}

// AcknowledgedAt returns the value of the "acknowledged_at" field in the mutation.
func (m *AlertMutation) AcknowledgedAt() (r time.Time, exists bool) {
	v := m.acknowledged_at
	if v == nil {
		return
	}
	return *v, true
}

// OldAcknowledgedAt returns the old "acknowledged_at" field's value of the Alert entity.
// If the Alert object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertMutation) OldAcknowledgedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAcknowledgedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAcknowledgedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAcknowledgedAt: %w", err)
	}
	return oldValue.AcknowledgedAt, nil
}

// ClearAcknowledgedAt clears the value of the "acknowledged_at" field.
func (m *AlertMutation) ClearAcknowledgedAt() {
	m.acknowledged_at = nil
	m.clearedFields[alert.FieldAcknowledgedAt] = struct{}{}
}

// AcknowledgedAtCleared returns if the "acknowledged_at" field was cleared in this mutation.
func (m *AlertMutation) AcknowledgedAtCleared() bool {
	_, ok := m.clearedFields[alert.FieldAcknowledgedAt]
	return ok
}

// ResetAcknowledgedAt resets all changes to the "acknowledged_at" field.
func (m *AlertMutation) ResetAcknowledgedAt() {
	m.acknowledged_at = nil
	delete(m.clearedFields, alert.FieldAcknowledgedAt)
}

// SetAcknowledgedBy sets the "acknowledged_by" field.
func (m *AlertMutation) SetAcknowledgedBy(s string) {
	m.acknowledged_by = &s
}

// AcknowledgedBy returns the value of the "acknowledged_by" field in the mutation.
func (m *AlertMutation) AcknowledgedBy() (r string, exists bool) {
	v := m.acknowledged_by
	if v == nil {
		return
	}
	return *v, true
}

// OldAcknowledgedBy returns the old "acknowledged_by" field's value of the Alert entity.
// If the Alert object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertMutation) OldAcknowledgedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAcknowledgedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAcknowledgedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAcknowledgedBy: %w", err)
	}
	return oldValue.AcknowledgedBy, nil
}

// ClearAcknowledgedBy clears the value of the "acknowledged_by" field.
func (m *AlertMutation) ClearAcknowledgedBy() {
	m.acknowledged_by = nil
	m.clearedFields[alert.FieldAcknowledgedBy] = struct{}{}
}

// AcknowledgedByCleared returns if the "acknowledged_by" field was cleared in this mutation.
func (m *AlertMutation) AcknowledgedByCleared() bool {
	_, ok := m.clearedFields[alert.FieldAcknowledgedBy]
	return ok
}

// ResetAcknowledgedBy resets all changes to the "acknowledged_by" field.
func (m *AlertMutation) ResetAcknowledgedBy() {
	m.acknowledged_by = nil
	delete(m.clearedFields, alert.FieldAcknowledgedBy)
}

// SetSuppressedCount sets the "suppressed_count" field.
func (m *AlertMutation) SetSuppressedCount(i int) {
	m.suppressed_count = &i
	m.addsuppressed_count = nil
}

// SuppressedCount returns the value of the "suppressed_count" field in the mutation.
func (m *AlertMutation) SuppressedCount() (r int, exists bool) {
	v := m.suppressed_count
	if v == nil {
		return
	}
	return *v, true
}

// OldSuppressedCount returns the old "suppressed_count" field's value of the Alert entity.
// If the Alert object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertMutation) OldSuppressedCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSuppressedCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSuppressedCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSuppressedCount: %w", err)
	}
	return oldValue.SuppressedCount, nil
}

// AddSuppressedCount adds i to the "suppressed_count" field.
func (m *AlertMutation) AddSuppressedCount(i int) {
	if m.addsuppressed_count != nil {
		*m.addsuppressed_count += i
	} else {
		m.addsuppressed_count = &i
	}
}

// AddedSuppressedCount returns the value that was added to the "suppressed_count" field in this mutation.
func (m *AlertMutation) AddedSuppressedCount() (r int, exists bool) {
	v := m.addsuppressed_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetSuppressedCount resets all changes to the "suppressed_count" field.
func (m *AlertMutation) ResetSuppressedCount() {
	m.suppressed_count = nil
	m.addsuppressed_count = nil
}

// SetSuppressReason sets the "suppress_reason" field.
func (m *AlertMutation) SetSuppressReason(s string) {
	m.suppress_reason = &s
}

// SuppressReason returns the value of the "suppress_reason" field in the mutation.
func (m *AlertMutation) SuppressReason() (r string, exists bool) {
	v := m.suppress_reason
	if v == nil {
		return
	}
	return *v, true
}

// OldSuppressReason returns the old "suppress_reason" field's value of the Alert entity.
// If the Alert object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertMutation) OldSuppressReason(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSuppressReason is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSuppressReason requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSuppressReason: %w", err)
	}
	return oldValue.SuppressReason, nil
}

// ClearSuppressReason clears the value of the "suppress_reason" field.
func (m *AlertMutation) ClearSuppressReason() {
	m.suppress_reason = nil
	m.clearedFields[alert.FieldSuppressReason] = struct{}{}
}

// SuppressReasonCleared returns if the "suppress_reason" field was cleared in this mutation.
func (m *AlertMutation) SuppressReasonCleared() bool {
	_, ok := m.clearedFields[alert.FieldSuppressReason]
	return ok
}

// ResetSuppressReason resets all changes to the "suppress_reason" field.
func (m *AlertMutation) ResetSuppressReason() {
	m.suppress_reason = nil
	delete(m.clearedFields, alert.FieldSuppressReason)
}

// SetDeliveryStatus sets the "delivery_status" field.
func (m *AlertMutation) SetDeliveryStatus(value map[string]interface{}) {
	m.delivery_status = &value
}

// DeliveryStatus returns the value of the "delivery_status" field in the mutation.
func (m *AlertMutation) DeliveryStatus() (r map[string]interface{}, exists bool) {
	v := m.delivery_status
	if v == nil {
		return
	}
	return *v, true
}

// OldDeliveryStatus returns the old "delivery_status" field's value of the Alert entity.
// If the Alert object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertMutation) OldDeliveryStatus(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeliveryStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeliveryStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeliveryStatus: %w", err)
	}
	return oldValue.DeliveryStatus, nil
}

// ClearDeliveryStatus clears the value of the "delivery_status" field.
func (m *AlertMutation) ClearDeliveryStatus() {
	m.delivery_status = nil
	m.clearedFields[alert.FieldDeliveryStatus] = struct{}{}
}

// DeliveryStatusCleared returns if the "delivery_status" field was cleared in this mutation.
func (m *AlertMutation) DeliveryStatusCleared() bool {
	_, ok := m.clearedFields[alert.FieldDeliveryStatus]
	return ok
}

// ResetDeliveryStatus resets all changes to the "delivery_status" field.
func (m *AlertMutation) ResetDeliveryStatus() {
	m.delivery_status = nil
	delete(m.clearedFields, alert.FieldDeliveryStatus)
}

// SetTriggeredAt sets the "triggered_at" field.
func (m *AlertMutation) SetTriggeredAt(t time.Time) {
	m.triggered_at = &t
}

// TriggeredAt returns the value of the "triggered_at" field in the mutation.
func (m *AlertMutation) TriggeredAt() (r time.Time, exists bool) {
	v := m.triggered_at
	if v == nil {
		return
	}
	return *v, true
}

// OldTriggeredAt returns the old "triggered_at" field's value of the Alert entity.
// If the Alert object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertMutation) OldTriggeredAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTriggeredAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTriggeredAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTriggeredAt: %w", err)
	}
	return oldValue.TriggeredAt, nil
}

// ResetTriggeredAt resets all changes to the "triggered_at" field.
func (m *AlertMutation) ResetTriggeredAt() {
	m.triggered_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AlertMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AlertMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Alert entity.
// If the Alert object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AlertMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearRule clears the "rule" edge to the AlertRule entity.
func (m *AlertMutation) ClearRule() {
	m.clearedrule = true
	m.clearedFields[alert.FieldRuleID] = struct{}{}
}

// RuleCleared reports if the "rule" edge to the AlertRule entity was cleared.
func (m *AlertMutation) RuleCleared() bool {
	return m.clearedrule
}

// RuleIDs returns the "rule" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RuleID instead. It exists only for internal usage by the builders.
func (m *AlertMutation) RuleIDs() (ids []string) {
	if id := m.rule; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRule resets all changes to the "rule" edge.
func (m *AlertMutation) ResetRule() {
	m.rule = nil
	m.clearedrule = false
}

// AddEscalationIDs adds the "escalations" edge to the AlertEscalation entity by ids.
func (m *AlertMutation) AddEscalationIDs(ids ...string) {
	if m.escalations == nil {
		m.escalations = make(map[string]struct{})
	}
	for i := range ids {
		m.escalations[ids[i]] = struct{}{}
	}
}

// ClearEscalations clears the "escalations" edge to the AlertEscalation entity.
func (m *AlertMutation) ClearEscalations() {
	m.clearedescalations = true
}

// EscalationsCleared reports if the "escalations" edge to the AlertEscalation entity was cleared.
func (m *AlertMutation) EscalationsCleared() bool {
	return m.clearedescalations
}

// RemoveEscalationIDs removes the "escalations" edge to the AlertEscalation entity by IDs.
func (m *AlertMutation) RemoveEscalationIDs(ids ...string) {
	if m.removedescalations == nil {
		m.removedescalations = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.escalations, ids[i])
		m.removedescalations[ids[i]] = struct{}{}
	}
}

// RemovedEscalations returns the removed IDs of the "escalations" edge to the AlertEscalation entity.
func (m *AlertMutation) RemovedEscalationsIDs() (ids []string) {
	for id := range m.removedescalations {
		ids = append(ids, id)
	}
	return
}

// EscalationsIDs returns the "escalations" edge IDs in the mutation.
func (m *AlertMutation) EscalationsIDs() (ids []string) {
	for id := range m.escalations {
		ids = append(ids, id)
	}
	return
}

// ResetEscalations resets all changes to the "escalations" edge.
func (m *AlertMutation) ResetEscalations() {
	m.escalations = nil
	m.clearedescalations = false
	m.removedescalations = nil
}

// AddNotificationLogIDs adds the "notification_logs" edge to the NotificationLog entity by ids.
func (m *AlertMutation) AddNotificationLogIDs(ids ...string) {
	if m.notification_logs == nil {
		m.notification_logs = make(map[string]struct{})
	}
	for i := range ids {
		m.notification_logs[ids[i]] = struct{}{}
	}
}

// ClearNotificationLogs clears the "notification_logs" edge to the NotificationLog entity.
func (m *AlertMutation) ClearNotificationLogs() {
	m.clearednotification_logs = true
}

// NotificationLogsCleared reports if the "notification_logs" edge to the NotificationLog entity was cleared.
func (m *AlertMutation) NotificationLogsCleared() bool {
	return m.clearednotification_logs
}

// RemoveNotificationLogIDs removes the "notification_logs" edge to the NotificationLog entity by IDs.
func (m *AlertMutation) RemoveNotificationLogIDs(ids ...string) {
	if m.removednotification_logs == nil {
		m.removednotification_logs = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.notification_logs, ids[i])
		m.removednotification_logs[ids[i]] = struct{}{}
	}
}

// RemovedNotificationLogs returns the removed IDs of the "notification_logs" edge to the NotificationLog entity.
func (m *AlertMutation) RemovedNotificationLogsIDs() (ids []string) {
	for id := range m.removednotification_logs {
		ids = append(ids, id)
	}
	return
}

// NotificationLogsIDs returns the "notification_logs" edge IDs in the mutation.
func (m *AlertMutation) NotificationLogsIDs() (ids []string) {
	for id := range m.notification_logs {
		ids = append(ids, id)
	}
	return
}

// ResetNotificationLogs resets all changes to the "notification_logs" edge.
func (m *AlertMutation) ResetNotificationLogs() {
	m.notification_logs = nil
	m.clearednotification_logs = false
	m.removednotification_logs = nil
}

// Where appends a list predicates to the AlertMutation builder.
func (m *AlertMutation) Where(ps ...predicate.Alert) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AlertMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AlertMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Alert, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AlertMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AlertMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Alert).
func (m *AlertMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AlertMutation) Fields() []string {
	fields := make([]string, 0, 14)
	if m.rule != nil {
		fields = append(fields, alert.FieldRuleID)
	}
	if m.event_type != nil {
		fields = append(fields, alert.FieldEventType)
	}
	if m.severity != nil {
		fields = append(fields, alert.FieldSeverity)
	}
	if m.title != nil {
		fields = append(fields, alert.FieldTitle)
	}
	if m.message != nil {
		fields = append(fields, alert.FieldMessage)
	}
	if m.data != nil {
		fields = append(fields, alert.FieldData)
	}
	if m.device_id != nil {
		fields = append(fields, alert.FieldDeviceID)
	}
	if m.acknowledged_at != nil {
		fields = append(fields, alert.FieldAcknowledgedAt)
	}
	if m.acknowledged_by != nil {
		fields = append(fields, alert.FieldAcknowledgedBy)
	}
	if m.suppressed_count != nil {
		fields = append(fields, alert.FieldSuppressedCount)
	}
	if m.suppress_reason != nil {
		fields = append(fields, alert.FieldSuppressReason)
	}
	if m.delivery_status != nil {
		fields = append(fields, alert.FieldDeliveryStatus)
	}
	if m.triggered_at != nil {
		fields = append(fields, alert.FieldTriggeredAt)
	}
	if m.updated_at != nil {
		fields = append(fields, alert.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AlertMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case alert.FieldRuleID:
		return m.RuleID()
	case alert.FieldEventType:
		return m.EventType()
	case alert.FieldSeverity:
		return m.Severity()
	case alert.FieldTitle:
		return m.Title()
	case alert.FieldMessage:
		return m.Message()
	case alert.FieldData:
		return m.Data()
	case alert.FieldDeviceID:
		return m.DeviceID()
	case alert.FieldAcknowledgedAt:
		return m.AcknowledgedAt()
	case alert.FieldAcknowledgedBy:
		return m.AcknowledgedBy()
	case alert.FieldSuppressedCount:
		return m.SuppressedCount()
	case alert.FieldSuppressReason:
		return m.SuppressReason()
	case alert.FieldDeliveryStatus:
		return m.DeliveryStatus()
	case alert.FieldTriggeredAt:
		return m.TriggeredAt()
	case alert.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AlertMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case alert.FieldRuleID:
		return m.OldRuleID(ctx)
	case alert.FieldEventType:
		return m.OldEventType(ctx)
	case alert.FieldSeverity:
		return m.OldSeverity(ctx)
	case alert.FieldTitle:
		return m.OldTitle(ctx)
	case alert.FieldMessage:
		return m.OldMessage(ctx)
	case alert.FieldData:
		return m.OldData(ctx)
	case alert.FieldDeviceID:
		return m.OldDeviceID(ctx)
	case alert.FieldAcknowledgedAt:
		return m.OldAcknowledgedAt(ctx)
	case alert.FieldAcknowledgedBy:
		return m.OldAcknowledgedBy(ctx)
	case alert.FieldSuppressedCount:
		return m.OldSuppressedCount(ctx)
	case alert.FieldSuppressReason:
		return m.OldSuppressReason(ctx)
	case alert.FieldDeliveryStatus:
		return m.OldDeliveryStatus(ctx)
	case alert.FieldTriggeredAt:
		return m.OldTriggeredAt(ctx)
	case alert.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Alert field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AlertMutation) SetField(name string, value ent.Value) error {
	switch name {
	case alert.FieldRuleID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRuleID(v)
		return nil
	case alert.FieldEventType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEventType(v)
		return nil
	case alert.FieldSeverity:
		v, ok := value.(alert.Severity)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSeverity(v)
		return nil
	case alert.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case alert.FieldMessage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMessage(v)
		return nil
	case alert.FieldData:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetData(v)
		return nil
	case alert.FieldDeviceID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeviceID(v)
		return nil
	case alert.FieldAcknowledgedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAcknowledgedAt(v)
		return nil
	case alert.FieldAcknowledgedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAcknowledgedBy(v)
		return nil
	case alert.FieldSuppressedCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSuppressedCount(v)
		return nil
	case alert.FieldSuppressReason:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSuppressReason(v)
		return nil
	case alert.FieldDeliveryStatus:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeliveryStatus(v)
		return nil
	case alert.FieldTriggeredAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTriggeredAt(v)
		return nil
	case alert.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Alert field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AlertMutation) AddedFields() []string {
	var fields []string
	if m.addsuppressed_count != nil {
		fields = append(fields, alert.FieldSuppressedCount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AlertMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case alert.FieldSuppressedCount:
		return m.AddedSuppressedCount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AlertMutation) AddField(name string, value ent.Value) error {
	switch name {
	case alert.FieldSuppressedCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSuppressedCount(v)
		return nil
	}
	return fmt.Errorf("unknown Alert numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AlertMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(alert.FieldData) {
		fields = append(fields, alert.FieldData)
	}
	if m.FieldCleared(alert.FieldDeviceID) {
		fields = append(fields, alert.FieldDeviceID)
	}
	if m.FieldCleared(alert.FieldAcknowledgedAt) {
		fields = append(fields, alert.FieldAcknowledgedAt)
	}
	if m.FieldCleared(alert.FieldAcknowledgedBy) {
		fields = append(fields, alert.FieldAcknowledgedBy)
	}
	if m.FieldCleared(alert.FieldSuppressReason) {
		fields = append(fields, alert.FieldSuppressReason)
	}
	if m.FieldCleared(alert.FieldDeliveryStatus) {
		fields = append(fields, alert.FieldDeliveryStatus)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AlertMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AlertMutation) ClearField(name string) error {
	switch name {
	case alert.FieldData:
		m.ClearData()
		return nil
	case alert.FieldDeviceID:
		m.ClearDeviceID()
		return nil
	case alert.FieldAcknowledgedAt:
		m.ClearAcknowledgedAt()
		return nil
	case alert.FieldAcknowledgedBy:
		m.ClearAcknowledgedBy()
		return nil
	case alert.FieldSuppressReason:
		m.ClearSuppressReason()
		return nil
	case alert.FieldDeliveryStatus:
		m.ClearDeliveryStatus()
		return nil
	}
	return fmt.Errorf("unknown Alert nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AlertMutation) ResetField(name string) error {
	switch name {
	case alert.FieldRuleID:
		m.ResetRuleID()
		return nil
	case alert.FieldEventType:
		m.ResetEventType()
		return nil
	case alert.FieldSeverity:
		m.ResetSeverity()
		return nil
	case alert.FieldTitle:
		m.ResetTitle()
		return nil
	case alert.FieldMessage:
		m.ResetMessage()
		return nil
	case alert.FieldData:
		m.ResetData()
		return nil
	case alert.FieldDeviceID:
		m.ResetDeviceID()
		return nil
	case alert.FieldAcknowledgedAt:
		m.ResetAcknowledgedAt()
		return nil
	case alert.FieldAcknowledgedBy:
		m.ResetAcknowledgedBy()
		return nil
	case alert.FieldSuppressedCount:
		m.ResetSuppressedCount()
		return nil
	case alert.FieldSuppressReason:
		m.ResetSuppressReason()
		return nil
	case alert.FieldDeliveryStatus:
		m.ResetDeliveryStatus()
		return nil
	case alert.FieldTriggeredAt:
		m.ResetTriggeredAt()
		return nil
	case alert.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Alert field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AlertMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.rule != nil {
		edges = append(edges, alert.EdgeRule)
	}
	if m.escalations != nil {
		edges = append(edges, alert.EdgeEscalations)
	}
	if m.notification_logs != nil {
		edges = append(edges, alert.EdgeNotificationLogs)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AlertMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case alert.EdgeRule:
		if id := m.rule; id != nil {
			return []ent.Value{*id}
		}
	case alert.EdgeEscalations:
		ids := make([]ent.Value, 0, len(m.escalations))
		for id := range m.escalations {
			ids = append(ids, id)
		}
		return ids
	case alert.EdgeNotificationLogs:
		ids := make([]ent.Value, 0, len(m.notification_logs))
		for id := range m.notification_logs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AlertMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedescalations != nil {
		edges = append(edges, alert.EdgeEscalations)
	}
	if m.removednotification_logs != nil {
		edges = append(edges, alert.EdgeNotificationLogs)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AlertMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case alert.EdgeEscalations:
		ids := make([]ent.Value, 0, len(m.removedescalations))
		for id := range m.removedescalations {
			ids = append(ids, id)
		}
		return ids
	case alert.EdgeNotificationLogs:
		ids := make([]ent.Value, 0, len(m.removednotification_logs))
		for id := range m.removednotification_logs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AlertMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedrule {
		edges = append(edges, alert.EdgeRule)
	}
	if m.clearedescalations {
		edges = append(edges, alert.EdgeEscalations)
	}
	if m.clearednotification_logs {
		edges = append(edges, alert.EdgeNotificationLogs)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AlertMutation) EdgeCleared(name string) bool {
	switch name {
	case alert.EdgeRule:
		return m.clearedrule
	case alert.EdgeEscalations:
		return m.clearedescalations
	case alert.EdgeNotificationLogs:
		return m.clearednotification_logs
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AlertMutation) ClearEdge(name string) error {
	switch name {
	case alert.EdgeRule:
		m.ClearRule()
		return nil
	}
	return fmt.Errorf("unknown Alert unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AlertMutation) ResetEdge(name string) error {
	switch name {
	case alert.EdgeRule:
		m.ResetRule()
		return nil
	case alert.EdgeEscalations:
		m.ResetEscalations()
		return nil
	case alert.EdgeNotificationLogs:
		m.ResetNotificationLogs()
		return nil
	}
	return fmt.Errorf("unknown Alert edge %s", name)
}

// AlertDigestEntryMutation represents an operation that mutates the AlertDigestEntry nodes in the graph.
type AlertDigestEntryMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	alert_id      *string
	rule_id       *string
	channel_id    *string
	channel_type  *string
	severity      *alertdigestentry.Severity
	event_type    *string
	title         *string
	message       *string
	data          *map[string]interface{}
	queued_at     *time.Time
	delivered_at  *time.Time
	digest_id     *string
	bypass_sent   *bool
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*AlertDigestEntry, error)
	predicates    []predicate.AlertDigestEntry
}

var _ ent.Mutation = (*AlertDigestEntryMutation)(nil)

// alertdigestentryOption allows management of the mutation configuration using functional options.
type alertdigestentryOption func(*AlertDigestEntryMutation)

// newAlertDigestEntryMutation creates new mutation for the AlertDigestEntry entity.
func newAlertDigestEntryMutation(c config, op Op, opts ...alertdigestentryOption) *AlertDigestEntryMutation {
	m := &AlertDigestEntryMutation{
		config:        c,
		op:            op,
		typ:           TypeAlertDigestEntry,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAlertDigestEntryID sets the ID field of the mutation.
func withAlertDigestEntryID(id uuid.UUID) alertdigestentryOption {
	return func(m *AlertDigestEntryMutation) {
		var (
			err   error
			once  sync.Once
			value *AlertDigestEntry
		)
		m.oldValue = func(ctx context.Context) (*AlertDigestEntry, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AlertDigestEntry.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAlertDigestEntry sets the old AlertDigestEntry of the mutation.
func withAlertDigestEntry(node *AlertDigestEntry) alertdigestentryOption {
	return func(m *AlertDigestEntryMutation) {
		m.oldValue = func(context.Context) (*AlertDigestEntry, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AlertDigestEntryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AlertDigestEntryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AlertDigestEntry entities.
func (m *AlertDigestEntryMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AlertDigestEntryMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AlertDigestEntryMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AlertDigestEntry.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetAlertID sets the "alert_id" field.
func (m *AlertDigestEntryMutation) SetAlertID(s string) {
	m.alert_id = &s
}

// AlertID returns the value of the "alert_id" field in the mutation.
func (m *AlertDigestEntryMutation) AlertID() (r string, exists bool) {
	v := m.alert_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAlertID returns the old "alert_id" field's value of the AlertDigestEntry entity.
// If the AlertDigestEntry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertDigestEntryMutation) OldAlertID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAlertID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAlertID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAlertID: %w", err)
	}
	return oldValue.AlertID, nil
}

// ClearAlertID clears the value of the "alert_id" field.
func (m *AlertDigestEntryMutation) ClearAlertID() {
	m.alert_id = nil
	m.clearedFields[alertdigestentry.FieldAlertID] = struct{}{}
}

// AlertIDCleared returns if the "alert_id" field was cleared in this mutation.
func (m *AlertDigestEntryMutation) AlertIDCleared() bool {
	_, ok := m.clearedFields[alertdigestentry.FieldAlertID]
	return ok
}

// ResetAlertID resets all changes to the "alert_id" field.
func (m *AlertDigestEntryMutation) ResetAlertID() {
	m.alert_id = nil
	delete(m.clearedFields, alertdigestentry.FieldAlertID)
}

// SetRuleID sets the "rule_id" field.
func (m *AlertDigestEntryMutation) SetRuleID(s string) {
	m.rule_id = &s
}

// RuleID returns the value of the "rule_id" field in the mutation.
func (m *AlertDigestEntryMutation) RuleID() (r string, exists bool) {
	v := m.rule_id
	if v == nil {
		return
	}
	return *v, true
}

// OldRuleID returns the old "rule_id" field's value of the AlertDigestEntry entity.
// If the AlertDigestEntry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertDigestEntryMutation) OldRuleID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRuleID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRuleID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRuleID: %w", err)
	}
	return oldValue.RuleID, nil
}

// ResetRuleID resets all changes to the "rule_id" field.
func (m *AlertDigestEntryMutation) ResetRuleID() {
	m.rule_id = nil
}

// SetChannelID sets the "channel_id" field.
func (m *AlertDigestEntryMutation) SetChannelID(s string) {
	m.channel_id = &s
}

// ChannelID returns the value of the "channel_id" field in the mutation.
func (m *AlertDigestEntryMutation) ChannelID() (r string, exists bool) {
	v := m.channel_id
	if v == nil {
		return
	}
	return *v, true
}

// OldChannelID returns the old "channel_id" field's value of the AlertDigestEntry entity.
// If the AlertDigestEntry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertDigestEntryMutation) OldChannelID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChannelID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChannelID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChannelID: %w", err)
	}
	return oldValue.ChannelID, nil
}

// ResetChannelID resets all changes to the "channel_id" field.
func (m *AlertDigestEntryMutation) ResetChannelID() {
	m.channel_id = nil
}

// SetChannelType sets the "channel_type" field.
func (m *AlertDigestEntryMutation) SetChannelType(s string) {
	m.channel_type = &s
}

// ChannelType returns the value of the "channel_type" field in the mutation.
func (m *AlertDigestEntryMutation) ChannelType() (r string, exists bool) {
	v := m.channel_type
	if v == nil {
		return
	}
	return *v, true
}

// OldChannelType returns the old "channel_type" field's value of the AlertDigestEntry entity.
// If the AlertDigestEntry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertDigestEntryMutation) OldChannelType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChannelType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChannelType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChannelType: %w", err)
	}
	return oldValue.ChannelType, nil
}

// ResetChannelType resets all changes to the "channel_type" field.
func (m *AlertDigestEntryMutation) ResetChannelType() {
	m.channel_type = nil
}

// SetSeverity sets the "severity" field.
func (m *AlertDigestEntryMutation) SetSeverity(a alertdigestentry.Severity) {
	m.severity = &a
}

// Severity returns the value of the "severity" field in the mutation.
func (m *AlertDigestEntryMutation) Severity() (r alertdigestentry.Severity, exists bool) {
	v := m.severity
	if v == nil {
		return
	}
	return *v, true
}

// OldSeverity returns the old "severity" field's value of the AlertDigestEntry entity.
// If the AlertDigestEntry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertDigestEntryMutation) OldSeverity(ctx context.Context) (v alertdigestentry.Severity, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSeverity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSeverity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSeverity: %w", err)
	}
	return oldValue.Severity, nil
}

// ResetSeverity resets all changes to the "severity" field.
func (m *AlertDigestEntryMutation) ResetSeverity() {
	m.severity = nil
}

// SetEventType sets the "event_type" field.
func (m *AlertDigestEntryMutation) SetEventType(s string) {
	m.event_type = &s
}

// EventType returns the value of the "event_type" field in the mutation.
func (m *AlertDigestEntryMutation) EventType() (r string, exists bool) {
	v := m.event_type
	if v == nil {
		return
	}
	return *v, true
}

// OldEventType returns the old "event_type" field's value of the AlertDigestEntry entity.
// If the AlertDigestEntry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertDigestEntryMutation) OldEventType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEventType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEventType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEventType: %w", err)
	}
	return oldValue.EventType, nil
}

// ResetEventType resets all changes to the "event_type" field.
func (m *AlertDigestEntryMutation) ResetEventType() {
	m.event_type = nil
}

// SetTitle sets the "title" field.
func (m *AlertDigestEntryMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *AlertDigestEntryMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the AlertDigestEntry entity.
// If the AlertDigestEntry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertDigestEntryMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *AlertDigestEntryMutation) ResetTitle() {
	m.title = nil
}

// SetMessage sets the "message" field.
func (m *AlertDigestEntryMutation) SetMessage(s string) {
	m.message = &s
}

// Message returns the value of the "message" field in the mutation.
func (m *AlertDigestEntryMutation) Message() (r string, exists bool) {
	v := m.message
	if v == nil {
		return
	}
	return *v, true
}

// OldMessage returns the old "message" field's value of the AlertDigestEntry entity.
// If the AlertDigestEntry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertDigestEntryMutation) OldMessage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMessage: %w", err)
	}
	return oldValue.Message, nil
}

// ResetMessage resets all changes to the "message" field.
func (m *AlertDigestEntryMutation) ResetMessage() {
	m.message = nil
}

// SetData sets the "data" field.
func (m *AlertDigestEntryMutation) SetData(value map[string]interface{}) {
	m.data = &value
}

// Data returns the value of the "data" field in the mutation.
func (m *AlertDigestEntryMutation) Data() (r map[string]interface{}, exists bool) {
	v := m.data
	if v == nil {
		return
	}
	return *v, true
}

// OldData returns the old "data" field's value of the AlertDigestEntry entity.
// If the AlertDigestEntry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertDigestEntryMutation) OldData(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldData is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldData requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldData: %w", err)
	}
	return oldValue.Data, nil
}

// ClearData clears the value of the "data" field.
func (m *AlertDigestEntryMutation) ClearData() {
	m.data = nil
	m.clearedFields[alertdigestentry.FieldData] = struct{}{}
}

// DataCleared returns if the "data" field was cleared in this mutation.
func (m *AlertDigestEntryMutation) DataCleared() bool {
	_, ok := m.clearedFields[alertdigestentry.FieldData]
	return ok
}

// ResetData resets all changes to the "data" field.
func (m *AlertDigestEntryMutation) ResetData() {
	m.data = nil
	delete(m.clearedFields, alertdigestentry.FieldData)
}

// SetQueuedAt sets the "queued_at" field.
func (m *AlertDigestEntryMutation) SetQueuedAt(t time.Time) {
	m.queued_at = &t
}

// QueuedAt returns the value of the "queued_at" field in the mutation.
func (m *AlertDigestEntryMutation) QueuedAt() (r time.Time, exists bool) {
	v := m.queued_at
	if v == nil {
		return
	}
	return *v, true
}

// OldQueuedAt returns the old "queued_at" field's value of the AlertDigestEntry entity.
// If the AlertDigestEntry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertDigestEntryMutation) OldQueuedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQueuedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQueuedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQueuedAt: %w", err)
	}
	return oldValue.QueuedAt, nil
}

// ResetQueuedAt resets all changes to the "queued_at" field.
func (m *AlertDigestEntryMutation) ResetQueuedAt() {
	m.queued_at = nil
}

// SetDeliveredAt sets the "delivered_at" field.
func (m *AlertDigestEntryMutation) SetDeliveredAt(t time.Time) {
	m.delivered_at = &t
}

// DeliveredAt returns the value of the "delivered_at" field in the mutation.
func (m *AlertDigestEntryMutation) DeliveredAt() (r time.Time, exists bool) {
	v := m.delivered_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeliveredAt returns the old "delivered_at" field's value of the AlertDigestEntry entity.
// If the AlertDigestEntry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertDigestEntryMutation) OldDeliveredAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeliveredAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeliveredAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeliveredAt: %w", err)
	}
	return oldValue.DeliveredAt, nil
}

// ClearDeliveredAt clears the value of the "delivered_at" field.
func (m *AlertDigestEntryMutation) ClearDeliveredAt() {
	m.delivered_at = nil
	m.clearedFields[alertdigestentry.FieldDeliveredAt] = struct{}{}
}

// DeliveredAtCleared returns if the "delivered_at" field was cleared in this mutation.
func (m *AlertDigestEntryMutation) DeliveredAtCleared() bool {
	_, ok := m.clearedFields[alertdigestentry.FieldDeliveredAt]
	return ok
}

// ResetDeliveredAt resets all changes to the "delivered_at" field.
func (m *AlertDigestEntryMutation) ResetDeliveredAt() {
	m.delivered_at = nil
	delete(m.clearedFields, alertdigestentry.FieldDeliveredAt)
}

// SetDigestID sets the "digest_id" field.
func (m *AlertDigestEntryMutation) SetDigestID(s string) {
	m.digest_id = &s
}

// DigestID returns the value of the "digest_id" field in the mutation.
func (m *AlertDigestEntryMutation) DigestID() (r string, exists bool) {
	v := m.digest_id
	if v == nil {
		return
	}
	return *v, true
}

// OldDigestID returns the old "digest_id" field's value of the AlertDigestEntry entity.
// If the AlertDigestEntry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertDigestEntryMutation) OldDigestID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDigestID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDigestID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDigestID: %w", err)
	}
	return oldValue.DigestID, nil
}

// ClearDigestID clears the value of the "digest_id" field.
func (m *AlertDigestEntryMutation) ClearDigestID() {
	m.digest_id = nil
	m.clearedFields[alertdigestentry.FieldDigestID] = struct{}{}
}

// DigestIDCleared returns if the "digest_id" field was cleared in this mutation.
func (m *AlertDigestEntryMutation) DigestIDCleared() bool {
	_, ok := m.clearedFields[alertdigestentry.FieldDigestID]
	return ok
}

// ResetDigestID resets all changes to the "digest_id" field.
func (m *AlertDigestEntryMutation) ResetDigestID() {
	m.digest_id = nil
	delete(m.clearedFields, alertdigestentry.FieldDigestID)
}

// SetBypassSent sets the "bypass_sent" field.
func (m *AlertDigestEntryMutation) SetBypassSent(b bool) {
	m.bypass_sent = &b
}

// BypassSent returns the value of the "bypass_sent" field in the mutation.
func (m *AlertDigestEntryMutation) BypassSent() (r bool, exists bool) {
	v := m.bypass_sent
	if v == nil {
		return
	}
	return *v, true
}

// OldBypassSent returns the old "bypass_sent" field's value of the AlertDigestEntry entity.
// If the AlertDigestEntry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertDigestEntryMutation) OldBypassSent(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBypassSent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBypassSent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBypassSent: %w", err)
	}
	return oldValue.BypassSent, nil
}

// ResetBypassSent resets all changes to the "bypass_sent" field.
func (m *AlertDigestEntryMutation) ResetBypassSent() {
	m.bypass_sent = nil
}

// Where appends a list predicates to the AlertDigestEntryMutation builder.
func (m *AlertDigestEntryMutation) Where(ps ...predicate.AlertDigestEntry) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AlertDigestEntryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AlertDigestEntryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AlertDigestEntry, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AlertDigestEntryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AlertDigestEntryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AlertDigestEntry).
func (m *AlertDigestEntryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AlertDigestEntryMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.alert_id != nil {
		fields = append(fields, alertdigestentry.FieldAlertID)
	}
	if m.rule_id != nil {
		fields = append(fields, alertdigestentry.FieldRuleID)
	}
	if m.channel_id != nil {
		fields = append(fields, alertdigestentry.FieldChannelID)
	}
	if m.channel_type != nil {
		fields = append(fields, alertdigestentry.FieldChannelType)
	}
	if m.severity != nil {
		fields = append(fields, alertdigestentry.FieldSeverity)
	}
	if m.event_type != nil {
		fields = append(fields, alertdigestentry.FieldEventType)
	}
	if m.title != nil {
		fields = append(fields, alertdigestentry.FieldTitle)
	}
	if m.message != nil {
		fields = append(fields, alertdigestentry.FieldMessage)
	}
	if m.data != nil {
		fields = append(fields, alertdigestentry.FieldData)
	}
	if m.queued_at != nil {
		fields = append(fields, alertdigestentry.FieldQueuedAt)
	}
	if m.delivered_at != nil {
		fields = append(fields, alertdigestentry.FieldDeliveredAt)
	}
	if m.digest_id != nil {
		fields = append(fields, alertdigestentry.FieldDigestID)
	}
	if m.bypass_sent != nil {
		fields = append(fields, alertdigestentry.FieldBypassSent)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AlertDigestEntryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case alertdigestentry.FieldAlertID:
		return m.AlertID()
	case alertdigestentry.FieldRuleID:
		return m.RuleID()
	case alertdigestentry.FieldChannelID:
		return m.ChannelID()
	case alertdigestentry.FieldChannelType:
		return m.ChannelType()
	case alertdigestentry.FieldSeverity:
		return m.Severity()
	case alertdigestentry.FieldEventType:
		return m.EventType()
	case alertdigestentry.FieldTitle:
		return m.Title()
	case alertdigestentry.FieldMessage:
		return m.Message()
	case alertdigestentry.FieldData:
		return m.Data()
	case alertdigestentry.FieldQueuedAt:
		return m.QueuedAt()
	case alertdigestentry.FieldDeliveredAt:
		return m.DeliveredAt()
	case alertdigestentry.FieldDigestID:
		return m.DigestID()
	case alertdigestentry.FieldBypassSent:
		return m.BypassSent()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AlertDigestEntryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case alertdigestentry.FieldAlertID:
		return m.OldAlertID(ctx)
	case alertdigestentry.FieldRuleID:
		return m.OldRuleID(ctx)
	case alertdigestentry.FieldChannelID:
		return m.OldChannelID(ctx)
	case alertdigestentry.FieldChannelType:
		return m.OldChannelType(ctx)
	case alertdigestentry.FieldSeverity:
		return m.OldSeverity(ctx)
	case alertdigestentry.FieldEventType:
		return m.OldEventType(ctx)
	case alertdigestentry.FieldTitle:
		return m.OldTitle(ctx)
	case alertdigestentry.FieldMessage:
		return m.OldMessage(ctx)
	case alertdigestentry.FieldData:
		return m.OldData(ctx)
	case alertdigestentry.FieldQueuedAt:
		return m.OldQueuedAt(ctx)
	case alertdigestentry.FieldDeliveredAt:
		return m.OldDeliveredAt(ctx)
	case alertdigestentry.FieldDigestID:
		return m.OldDigestID(ctx)
	case alertdigestentry.FieldBypassSent:
		return m.OldBypassSent(ctx)
	}
	return nil, fmt.Errorf("unknown AlertDigestEntry field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AlertDigestEntryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case alertdigestentry.FieldAlertID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAlertID(v)
		return nil
	case alertdigestentry.FieldRuleID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRuleID(v)
		return nil
	case alertdigestentry.FieldChannelID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChannelID(v)
		return nil
	case alertdigestentry.FieldChannelType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChannelType(v)
		return nil
	case alertdigestentry.FieldSeverity:
		v, ok := value.(alertdigestentry.Severity)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSeverity(v)
		return nil
	case alertdigestentry.FieldEventType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEventType(v)
		return nil
	case alertdigestentry.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case alertdigestentry.FieldMessage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMessage(v)
		return nil
	case alertdigestentry.FieldData:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetData(v)
		return nil
	case alertdigestentry.FieldQueuedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQueuedAt(v)
		return nil
	case alertdigestentry.FieldDeliveredAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeliveredAt(v)
		return nil
	case alertdigestentry.FieldDigestID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDigestID(v)
		return nil
	case alertdigestentry.FieldBypassSent:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBypassSent(v)
		return nil
	}
	return fmt.Errorf("unknown AlertDigestEntry field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AlertDigestEntryMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AlertDigestEntryMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AlertDigestEntryMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown AlertDigestEntry numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AlertDigestEntryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(alertdigestentry.FieldAlertID) {
		fields = append(fields, alertdigestentry.FieldAlertID)
	}
	if m.FieldCleared(alertdigestentry.FieldData) {
		fields = append(fields, alertdigestentry.FieldData)
	}
	if m.FieldCleared(alertdigestentry.FieldDeliveredAt) {
		fields = append(fields, alertdigestentry.FieldDeliveredAt)
	}
	if m.FieldCleared(alertdigestentry.FieldDigestID) {
		fields = append(fields, alertdigestentry.FieldDigestID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AlertDigestEntryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AlertDigestEntryMutation) ClearField(name string) error {
	switch name {
	case alertdigestentry.FieldAlertID:
		m.ClearAlertID()
		return nil
	case alertdigestentry.FieldData:
		m.ClearData()
		return nil
	case alertdigestentry.FieldDeliveredAt:
		m.ClearDeliveredAt()
		return nil
	case alertdigestentry.FieldDigestID:
		m.ClearDigestID()
		return nil
	}
	return fmt.Errorf("unknown AlertDigestEntry nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AlertDigestEntryMutation) ResetField(name string) error {
	switch name {
	case alertdigestentry.FieldAlertID:
		m.ResetAlertID()
		return nil
	case alertdigestentry.FieldRuleID:
		m.ResetRuleID()
		return nil
	case alertdigestentry.FieldChannelID:
		m.ResetChannelID()
		return nil
	case alertdigestentry.FieldChannelType:
		m.ResetChannelType()
		return nil
	case alertdigestentry.FieldSeverity:
		m.ResetSeverity()
		return nil
	case alertdigestentry.FieldEventType:
		m.ResetEventType()
		return nil
	case alertdigestentry.FieldTitle:
		m.ResetTitle()
		return nil
	case alertdigestentry.FieldMessage:
		m.ResetMessage()
		return nil
	case alertdigestentry.FieldData:
		m.ResetData()
		return nil
	case alertdigestentry.FieldQueuedAt:
		m.ResetQueuedAt()
		return nil
	case alertdigestentry.FieldDeliveredAt:
		m.ResetDeliveredAt()
		return nil
	case alertdigestentry.FieldDigestID:
		m.ResetDigestID()
		return nil
	case alertdigestentry.FieldBypassSent:
		m.ResetBypassSent()
		return nil
	}
	return fmt.Errorf("unknown AlertDigestEntry field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AlertDigestEntryMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AlertDigestEntryMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AlertDigestEntryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AlertDigestEntryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AlertDigestEntryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AlertDigestEntryMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AlertDigestEntryMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown AlertDigestEntry unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AlertDigestEntryMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown AlertDigestEntry edge %s", name)
}

// AlertEscalationMutation represents an operation that mutates the AlertEscalation nodes in the graph.
type AlertEscalationMutation struct {
	config
	op                            Op
	typ                           string
	id                            *string
	current_level                 *int
	addcurrent_level              *int
	max_level                     *int
	addmax_level                  *int
	status                        *alertescalation.Status
	next_escalation_at            *time.Time
	escalation_delay_seconds      *int
	addescalation_delay_seconds   *int
	repeat_interval_seconds       *[]int
	appendrepeat_interval_seconds []int
	additional_channels           *[]string
	appendadditional_channels     []string
	resolved_at                   *time.Time
	resolved_by                   *string
	created_at                    *time.Time
	updated_at                    *time.Time
	clearedFields                 map[string]struct{}
	alert                         *string
	clearedalert                  bool
	rule                          *string
	clearedrule                   bool
	done                          bool
	oldValue                      func(context.Context) (*AlertEscalation, error)
	predicates                    []predicate.AlertEscalation
}

var _ ent.Mutation = (*AlertEscalationMutation)(nil)

// alertescalationOption allows management of the mutation configuration using functional options.
type alertescalationOption func(*AlertEscalationMutation)

// newAlertEscalationMutation creates new mutation for the AlertEscalation entity.
func newAlertEscalationMutation(c config, op Op, opts ...alertescalationOption) *AlertEscalationMutation {
	m := &AlertEscalationMutation{
		config:        c,
		op:            op,
		typ:           TypeAlertEscalation,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAlertEscalationID sets the ID field of the mutation.
func withAlertEscalationID(id string) alertescalationOption {
	return func(m *AlertEscalationMutation) {
		var (
			err   error
			once  sync.Once
			value *AlertEscalation
		)
		m.oldValue = func(ctx context.Context) (*AlertEscalation, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AlertEscalation.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAlertEscalation sets the old AlertEscalation of the mutation.
func withAlertEscalation(node *AlertEscalation) alertescalationOption {
	return func(m *AlertEscalationMutation) {
		m.oldValue = func(context.Context) (*AlertEscalation, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AlertEscalationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AlertEscalationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AlertEscalation entities.
func (m *AlertEscalationMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AlertEscalationMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AlertEscalationMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AlertEscalation.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetAlertID sets the "alert_id" field.
func (m *AlertEscalationMutation) SetAlertID(s string) {
	m.alert = &s
}

// AlertID returns the value of the "alert_id" field in the mutation.
func (m *AlertEscalationMutation) AlertID() (r string, exists bool) {
	v := m.alert
	if v == nil {
		return
	}
	return *v, true
}

// OldAlertID returns the old "alert_id" field's value of the AlertEscalation entity.
// If the AlertEscalation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertEscalationMutation) OldAlertID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAlertID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAlertID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAlertID: %w", err)
	}
	return oldValue.AlertID, nil
}

// ResetAlertID resets all changes to the "alert_id" field.
func (m *AlertEscalationMutation) ResetAlertID() {
	m.alert = nil
}

// SetRuleID sets the "rule_id" field.
func (m *AlertEscalationMutation) SetRuleID(s string) {
	m.rule = &s
}

// RuleID returns the value of the "rule_id" field in the mutation.
func (m *AlertEscalationMutation) RuleID() (r string, exists bool) {
	v := m.rule
	if v == nil {
		return
	}
	return *v, true
}

// OldRuleID returns the old "rule_id" field's value of the AlertEscalation entity.
// If the AlertEscalation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertEscalationMutation) OldRuleID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRuleID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRuleID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRuleID: %w", err)
	}
	return oldValue.RuleID, nil
}

// ResetRuleID resets all changes to the "rule_id" field.
func (m *AlertEscalationMutation) ResetRuleID() {
	m.rule = nil
}

// SetCurrentLevel sets the "current_level" field.
func (m *AlertEscalationMutation) SetCurrentLevel(i int) {
	m.current_level = &i
	m.addcurrent_level = nil
}

// CurrentLevel returns the value of the "current_level" field in the mutation.
func (m *AlertEscalationMutation) CurrentLevel() (r int, exists bool) {
	v := m.current_level
	if v == nil {
		return
	}
	return *v, true
}

// OldCurrentLevel returns the old "current_level" field's value of the AlertEscalation entity.
// If the AlertEscalation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertEscalationMutation) OldCurrentLevel(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCurrentLevel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCurrentLevel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCurrentLevel: %w", err)
	}
	return oldValue.CurrentLevel, nil
}

// AddCurrentLevel adds i to the "current_level" field.
func (m *AlertEscalationMutation) AddCurrentLevel(i int) {
	if m.addcurrent_level != nil {
		*m.addcurrent_level += i
	} else {
		m.addcurrent_level = &i
	}
}

// AddedCurrentLevel returns the value that was added to the "current_level" field in this mutation.
func (m *AlertEscalationMutation) AddedCurrentLevel() (r int, exists bool) {
	v := m.addcurrent_level
	if v == nil {
		return
	}
	return *v, true
}

// ResetCurrentLevel resets all changes to the "current_level" field.
func (m *AlertEscalationMutation) ResetCurrentLevel() {
	m.current_level = nil
	m.addcurrent_level = nil
}

// SetMaxLevel sets the "max_level" field.
func (m *AlertEscalationMutation) SetMaxLevel(i int) {
	m.max_level = &i
	m.addmax_level = nil
}

// MaxLevel returns the value of the "max_level" field in the mutation.
func (m *AlertEscalationMutation) MaxLevel() (r int, exists bool) {
	v := m.max_level
	if v == nil {
		return
	}
	return *v, true
}

// OldMaxLevel returns the old "max_level" field's value of the AlertEscalation entity.
// If the AlertEscalation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertEscalationMutation) OldMaxLevel(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMaxLevel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMaxLevel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaxLevel: %w", err)
	}
	return oldValue.MaxLevel, nil
}

// AddMaxLevel adds i to the "max_level" field.
func (m *AlertEscalationMutation) AddMaxLevel(i int) {
	if m.addmax_level != nil {
		*m.addmax_level += i
	} else {
		m.addmax_level = &i
	}
}

// AddedMaxLevel returns the value that was added to the "max_level" field in this mutation.
func (m *AlertEscalationMutation) AddedMaxLevel() (r int, exists bool) {
	v := m.addmax_level
	if v == nil {
		return
	}
	return *v, true
}

// ResetMaxLevel resets all changes to the "max_level" field.
func (m *AlertEscalationMutation) ResetMaxLevel() {
	m.max_level = nil
	m.addmax_level = nil
}

// SetStatus sets the "status" field.
func (m *AlertEscalationMutation) SetStatus(a alertescalation.Status) {
	m.status = &a
}

// Status returns the value of the "status" field in the mutation.
func (m *AlertEscalationMutation) Status() (r alertescalation.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the AlertEscalation entity.
// If the AlertEscalation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertEscalationMutation) OldStatus(ctx context.Context) (v alertescalation.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *AlertEscalationMutation) ResetStatus() {
	m.status = nil
}

// SetNextEscalationAt sets the "next_escalation_at" field.
func (m *AlertEscalationMutation) SetNextEscalationAt(t time.Time) {
	m.next_escalation_at = &t
}

// NextEscalationAt returns the value of the "next_escalation_at" field in the mutation.
func (m *AlertEscalationMutation) NextEscalationAt() (r time.Time, exists bool) {
	v := m.next_escalation_at
	if v == nil {
		return
	}
	return *v, true
}

// OldNextEscalationAt returns the old "next_escalation_at" field's value of the AlertEscalation entity.
// If the AlertEscalation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertEscalationMutation) OldNextEscalationAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNextEscalationAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNextEscalationAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNextEscalationAt: %w", err)
	}
	return oldValue.NextEscalationAt, nil
}

// ClearNextEscalationAt clears the value of the "next_escalation_at" field.
func (m *AlertEscalationMutation) ClearNextEscalationAt() {
	m.next_escalation_at = nil
	m.clearedFields[alertescalation.FieldNextEscalationAt] = struct{}{}
}

// NextEscalationAtCleared returns if the "next_escalation_at" field was cleared in this mutation.
func (m *AlertEscalationMutation) NextEscalationAtCleared() bool {
	_, ok := m.clearedFields[alertescalation.FieldNextEscalationAt]
	return ok
}

// ResetNextEscalationAt resets all changes to the "next_escalation_at" field.
func (m *AlertEscalationMutation) ResetNextEscalationAt() {
	m.next_escalation_at = nil
	delete(m.clearedFields, alertescalation.FieldNextEscalationAt)
}

// SetEscalationDelaySeconds sets the "escalation_delay_seconds" field.
func (m *AlertEscalationMutation) SetEscalationDelaySeconds(i int) {
	m.escalation_delay_seconds = &i
	m.addescalation_delay_seconds = nil
}

// EscalationDelaySeconds returns the value of the "escalation_delay_seconds" field in the mutation.
func (m *AlertEscalationMutation) EscalationDelaySeconds() (r int, exists bool) {
	v := m.escalation_delay_seconds
	if v == nil {
		return
	}
	return *v, true
}

// OldEscalationDelaySeconds returns the old "escalation_delay_seconds" field's value of the AlertEscalation entity.
// If the AlertEscalation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertEscalationMutation) OldEscalationDelaySeconds(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEscalationDelaySeconds is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEscalationDelaySeconds requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEscalationDelaySeconds: %w", err)
	}
	return oldValue.EscalationDelaySeconds, nil
}

// AddEscalationDelaySeconds adds i to the "escalation_delay_seconds" field.
func (m *AlertEscalationMutation) AddEscalationDelaySeconds(i int) {
	if m.addescalation_delay_seconds != nil {
		*m.addescalation_delay_seconds += i
	} else {
		m.addescalation_delay_seconds = &i
	}
}

// AddedEscalationDelaySeconds returns the value that was added to the "escalation_delay_seconds" field in this mutation.
func (m *AlertEscalationMutation) AddedEscalationDelaySeconds() (r int, exists bool) {
	v := m.addescalation_delay_seconds
	if v == nil {
		return
	}
	return *v, true
}

// ResetEscalationDelaySeconds resets all changes to the "escalation_delay_seconds" field.
func (m *AlertEscalationMutation) ResetEscalationDelaySeconds() {
	m.escalation_delay_seconds = nil
	m.addescalation_delay_seconds = nil
}

// SetRepeatIntervalSeconds sets the "repeat_interval_seconds" field.
func (m *AlertEscalationMutation) SetRepeatIntervalSeconds(i []int) {
	m.repeat_interval_seconds = &i
	m.appendrepeat_interval_seconds = nil
}

// RepeatIntervalSeconds returns the value of the "repeat_interval_seconds" field in the mutation.
func (m *AlertEscalationMutation) RepeatIntervalSeconds() (r []int, exists bool) {
	v := m.repeat_interval_seconds
	if v == nil {
		return
	}
	return *v, true
}

// OldRepeatIntervalSeconds returns the old "repeat_interval_seconds" field's value of the AlertEscalation entity.
// If the AlertEscalation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertEscalationMutation) OldRepeatIntervalSeconds(ctx context.Context) (v []int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRepeatIntervalSeconds is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRepeatIntervalSeconds requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRepeatIntervalSeconds: %w", err)
	}
	return oldValue.RepeatIntervalSeconds, nil
}

// AppendRepeatIntervalSeconds adds i to the "repeat_interval_seconds" field.
func (m *AlertEscalationMutation) AppendRepeatIntervalSeconds(i []int) {
	m.appendrepeat_interval_seconds = append(m.appendrepeat_interval_seconds, i...)
}

// AppendedRepeatIntervalSeconds returns the list of values that were appended to the "repeat_interval_seconds" field in this mutation.
func (m *AlertEscalationMutation) AppendedRepeatIntervalSeconds() ([]int, bool) {
	if len(m.appendrepeat_interval_seconds) == 0 {
		return nil, false
	}
	return m.appendrepeat_interval_seconds, true
}

// ResetRepeatIntervalSeconds resets all changes to the "repeat_interval_seconds" field.
func (m *AlertEscalationMutation) ResetRepeatIntervalSeconds() {
	m.repeat_interval_seconds = nil
	m.appendrepeat_interval_seconds = nil
}

// SetAdditionalChannels sets the "additional_channels" field.
func (m *AlertEscalationMutation) SetAdditionalChannels(s []string) {
	m.additional_channels = &s
	m.appendadditional_channels = nil
}

// AdditionalChannels returns the value of the "additional_channels" field in the mutation.
func (m *AlertEscalationMutation) AdditionalChannels() (r []string, exists bool) {
	v := m.additional_channels
	if v == nil {
		return
	}
	return *v, true
}

// OldAdditionalChannels returns the old "additional_channels" field's value of the AlertEscalation entity.
// If the AlertEscalation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertEscalationMutation) OldAdditionalChannels(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAdditionalChannels is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAdditionalChannels requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAdditionalChannels: %w", err)
	}
	return oldValue.AdditionalChannels, nil
}

// AppendAdditionalChannels adds s to the "additional_channels" field.
func (m *AlertEscalationMutation) AppendAdditionalChannels(s []string) {
	m.appendadditional_channels = append(m.appendadditional_channels, s...)
}

// AppendedAdditionalChannels returns the list of values that were appended to the "additional_channels" field in this mutation.
func (m *AlertEscalationMutation) AppendedAdditionalChannels() ([]string, bool) {
	if len(m.appendadditional_channels) == 0 {
		return nil, false
	}
	return m.appendadditional_channels, true
}

// ResetAdditionalChannels resets all changes to the "additional_channels" field.
func (m *AlertEscalationMutation) ResetAdditionalChannels() {
	m.additional_channels = nil
	m.appendadditional_channels = nil
}

// SetResolvedAt sets the "resolved_at" field.
func (m *AlertEscalationMutation) SetResolvedAt(t time.Time) {
	m.resolved_at = &t
}

// ResolvedAt returns the value of the "resolved_at" field in the mutation.
func (m *AlertEscalationMutation) ResolvedAt() (r time.Time, exists bool) {
	v := m.resolved_at
	if v == nil {
		return
	}
	return *v, true
}

// OldResolvedAt returns the old "resolved_at" field's value of the AlertEscalation entity.
// If the AlertEscalation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertEscalationMutation) OldResolvedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResolvedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResolvedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResolvedAt: %w", err)
	}
	return oldValue.ResolvedAt, nil
}

// ClearResolvedAt clears the value of the "resolved_at" field.
func (m *AlertEscalationMutation) ClearResolvedAt() {
	m.resolved_at = nil
	m.clearedFields[alertescalation.FieldResolvedAt] = struct{}{}
}

// ResolvedAtCleared returns if the "resolved_at" field was cleared in this mutation.
func (m *AlertEscalationMutation) ResolvedAtCleared() bool {
	_, ok := m.clearedFields[alertescalation.FieldResolvedAt]
	return ok
}

// ResetResolvedAt resets all changes to the "resolved_at" field.
func (m *AlertEscalationMutation) ResetResolvedAt() {
	m.resolved_at = nil
	delete(m.clearedFields, alertescalation.FieldResolvedAt)
}

// SetResolvedBy sets the "resolved_by" field.
func (m *AlertEscalationMutation) SetResolvedBy(s string) {
	m.resolved_by = &s
}

// ResolvedBy returns the value of the "resolved_by" field in the mutation.
func (m *AlertEscalationMutation) ResolvedBy() (r string, exists bool) {
	v := m.resolved_by
	if v == nil {
		return
	}
	return *v, true
}

// OldResolvedBy returns the old "resolved_by" field's value of the AlertEscalation entity.
// If the AlertEscalation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertEscalationMutation) OldResolvedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResolvedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResolvedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResolvedBy: %w", err)
	}
	return oldValue.ResolvedBy, nil
}

// ClearResolvedBy clears the value of the "resolved_by" field.
func (m *AlertEscalationMutation) ClearResolvedBy() {
	m.resolved_by = nil
	m.clearedFields[alertescalation.FieldResolvedBy] = struct{}{}
}

// ResolvedByCleared returns if the "resolved_by" field was cleared in this mutation.
func (m *AlertEscalationMutation) ResolvedByCleared() bool {
	_, ok := m.clearedFields[alertescalation.FieldResolvedBy]
	return ok
}

// ResetResolvedBy resets all changes to the "resolved_by" field.
func (m *AlertEscalationMutation) ResetResolvedBy() {
	m.resolved_by = nil
	delete(m.clearedFields, alertescalation.FieldResolvedBy)
}

// SetCreatedAt sets the "created_at" field.
func (m *AlertEscalationMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AlertEscalationMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the AlertEscalation entity.
// If the AlertEscalation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertEscalationMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AlertEscalationMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AlertEscalationMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AlertEscalationMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the AlertEscalation entity.
// If the AlertEscalation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertEscalationMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AlertEscalationMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearAlert clears the "alert" edge to the Alert entity.
func (m *AlertEscalationMutation) ClearAlert() {
	m.clearedalert = true
	m.clearedFields[alertescalation.FieldAlertID] = struct{}{}
}

// AlertCleared reports if the "alert" edge to the Alert entity was cleared.
func (m *AlertEscalationMutation) AlertCleared() bool {
	return m.clearedalert
}

// AlertIDs returns the "alert" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AlertID instead. It exists only for internal usage by the builders.
func (m *AlertEscalationMutation) AlertIDs() (ids []string) {
	if id := m.alert; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAlert resets all changes to the "alert" edge.
func (m *AlertEscalationMutation) ResetAlert() {
	m.alert = nil
	m.clearedalert = false
}

// ClearRule clears the "rule" edge to the AlertRule entity.
func (m *AlertEscalationMutation) ClearRule() {
	m.clearedrule = true
	m.clearedFields[alertescalation.FieldRuleID] = struct{}{}
}

// RuleCleared reports if the "rule" edge to the AlertRule entity was cleared.
func (m *AlertEscalationMutation) RuleCleared() bool {
	return m.clearedrule
}

// RuleIDs returns the "rule" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RuleID instead. It exists only for internal usage by the builders.
func (m *AlertEscalationMutation) RuleIDs() (ids []string) {
	if id := m.rule; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRule resets all changes to the "rule" edge.
func (m *AlertEscalationMutation) ResetRule() {
	m.rule = nil
	m.clearedrule = false
}

// Where appends a list predicates to the AlertEscalationMutation builder.
func (m *AlertEscalationMutation) Where(ps ...predicate.AlertEscalation) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AlertEscalationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AlertEscalationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AlertEscalation, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AlertEscalationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AlertEscalationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AlertEscalation).
func (m *AlertEscalationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AlertEscalationMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.alert != nil {
		fields = append(fields, alertescalation.FieldAlertID)
	}
	if m.rule != nil {
		fields = append(fields, alertescalation.FieldRuleID)
	}
	if m.current_level != nil {
		fields = append(fields, alertescalation.FieldCurrentLevel)
	}
	if m.max_level != nil {
		fields = append(fields, alertescalation.FieldMaxLevel)
	}
	if m.status != nil {
		fields = append(fields, alertescalation.FieldStatus)
	}
	if m.next_escalation_at != nil {
		fields = append(fields, alertescalation.FieldNextEscalationAt)
	}
	if m.escalation_delay_seconds != nil {
		fields = append(fields, alertescalation.FieldEscalationDelaySeconds)
	}
	if m.repeat_interval_seconds != nil {
		fields = append(fields, alertescalation.FieldRepeatIntervalSeconds)
	}
	if m.additional_channels != nil {
		fields = append(fields, alertescalation.FieldAdditionalChannels)
	}
	if m.resolved_at != nil {
		fields = append(fields, alertescalation.FieldResolvedAt)
	}
	if m.resolved_by != nil {
		fields = append(fields, alertescalation.FieldResolvedBy)
	}
	if m.created_at != nil {
		fields = append(fields, alertescalation.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, alertescalation.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AlertEscalationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case alertescalation.FieldAlertID:
		return m.AlertID()
	case alertescalation.FieldRuleID:
		return m.RuleID()
	case alertescalation.FieldCurrentLevel:
		return m.CurrentLevel()
	case alertescalation.FieldMaxLevel:
		return m.MaxLevel()
	case alertescalation.FieldStatus:
		return m.Status()
	case alertescalation.FieldNextEscalationAt:
		return m.NextEscalationAt()
	case alertescalation.FieldEscalationDelaySeconds:
		return m.EscalationDelaySeconds()
	case alertescalation.FieldRepeatIntervalSeconds:
		return m.RepeatIntervalSeconds()
	case alertescalation.FieldAdditionalChannels:
		return m.AdditionalChannels()
	case alertescalation.FieldResolvedAt:
		return m.ResolvedAt()
	case alertescalation.FieldResolvedBy:
		return m.ResolvedBy()
	case alertescalation.FieldCreatedAt:
		return m.CreatedAt()
	case alertescalation.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AlertEscalationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case alertescalation.FieldAlertID:
		return m.OldAlertID(ctx)
	case alertescalation.FieldRuleID:
		return m.OldRuleID(ctx)
	case alertescalation.FieldCurrentLevel:
		return m.OldCurrentLevel(ctx)
	case alertescalation.FieldMaxLevel:
		return m.OldMaxLevel(ctx)
	case alertescalation.FieldStatus:
		return m.OldStatus(ctx)
	case alertescalation.FieldNextEscalationAt:
		return m.OldNextEscalationAt(ctx)
	case alertescalation.FieldEscalationDelaySeconds:
		return m.OldEscalationDelaySeconds(ctx)
	case alertescalation.FieldRepeatIntervalSeconds:
		return m.OldRepeatIntervalSeconds(ctx)
	case alertescalation.FieldAdditionalChannels:
		return m.OldAdditionalChannels(ctx)
	case alertescalation.FieldResolvedAt:
		return m.OldResolvedAt(ctx)
	case alertescalation.FieldResolvedBy:
		return m.OldResolvedBy(ctx)
	case alertescalation.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case alertescalation.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown AlertEscalation field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AlertEscalationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case alertescalation.FieldAlertID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAlertID(v)
		return nil
	case alertescalation.FieldRuleID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRuleID(v)
		return nil
	case alertescalation.FieldCurrentLevel:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCurrentLevel(v)
		return nil
	case alertescalation.FieldMaxLevel:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaxLevel(v)
		return nil
	case alertescalation.FieldStatus:
		v, ok := value.(alertescalation.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case alertescalation.FieldNextEscalationAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNextEscalationAt(v)
		return nil
	case alertescalation.FieldEscalationDelaySeconds:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEscalationDelaySeconds(v)
		return nil
	case alertescalation.FieldRepeatIntervalSeconds:
		v, ok := value.([]int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRepeatIntervalSeconds(v)
		return nil
	case alertescalation.FieldAdditionalChannels:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAdditionalChannels(v)
		return nil
	case alertescalation.FieldResolvedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResolvedAt(v)
		return nil
	case alertescalation.FieldResolvedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResolvedBy(v)
		return nil
	case alertescalation.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case alertescalation.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown AlertEscalation field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AlertEscalationMutation) AddedFields() []string {
	var fields []string
	if m.addcurrent_level != nil {
		fields = append(fields, alertescalation.FieldCurrentLevel)
	}
	if m.addmax_level != nil {
		fields = append(fields, alertescalation.FieldMaxLevel)
	}
	if m.addescalation_delay_seconds != nil {
		fields = append(fields, alertescalation.FieldEscalationDelaySeconds)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AlertEscalationMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case alertescalation.FieldCurrentLevel:
		return m.AddedCurrentLevel()
	case alertescalation.FieldMaxLevel:
		return m.AddedMaxLevel()
	case alertescalation.FieldEscalationDelaySeconds:
		return m.AddedEscalationDelaySeconds()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AlertEscalationMutation) AddField(name string, value ent.Value) error {
	switch name {
	case alertescalation.FieldCurrentLevel:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCurrentLevel(v)
		return nil
	case alertescalation.FieldMaxLevel:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMaxLevel(v)
		return nil
	case alertescalation.FieldEscalationDelaySeconds:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddEscalationDelaySeconds(v)
		return nil
	}
	return fmt.Errorf("unknown AlertEscalation numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AlertEscalationMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(alertescalation.FieldNextEscalationAt) {
		fields = append(fields, alertescalation.FieldNextEscalationAt)
	}
	if m.FieldCleared(alertescalation.FieldResolvedAt) {
		fields = append(fields, alertescalation.FieldResolvedAt)
	}
	if m.FieldCleared(alertescalation.FieldResolvedBy) {
		fields = append(fields, alertescalation.FieldResolvedBy)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AlertEscalationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AlertEscalationMutation) ClearField(name string) error {
	switch name {
	case alertescalation.FieldNextEscalationAt:
		m.ClearNextEscalationAt()
		return nil
	case alertescalation.FieldResolvedAt:
		m.ClearResolvedAt()
		return nil
	case alertescalation.FieldResolvedBy:
		m.ClearResolvedBy()
		return nil
	}
	return fmt.Errorf("unknown AlertEscalation nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AlertEscalationMutation) ResetField(name string) error {
	switch name {
	case alertescalation.FieldAlertID:
		m.ResetAlertID()
		return nil
	case alertescalation.FieldRuleID:
		m.ResetRuleID()
		return nil
	case alertescalation.FieldCurrentLevel:
		m.ResetCurrentLevel()
		return nil
	case alertescalation.FieldMaxLevel:
		m.ResetMaxLevel()
		return nil
	case alertescalation.FieldStatus:
		m.ResetStatus()
		return nil
	case alertescalation.FieldNextEscalationAt:
		m.ResetNextEscalationAt()
		return nil
	case alertescalation.FieldEscalationDelaySeconds:
		m.ResetEscalationDelaySeconds()
		return nil
	case alertescalation.FieldRepeatIntervalSeconds:
		m.ResetRepeatIntervalSeconds()
		return nil
	case alertescalation.FieldAdditionalChannels:
		m.ResetAdditionalChannels()
		return nil
	case alertescalation.FieldResolvedAt:
		m.ResetResolvedAt()
		return nil
	case alertescalation.FieldResolvedBy:
		m.ResetResolvedBy()
		return nil
	case alertescalation.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case alertescalation.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown AlertEscalation field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AlertEscalationMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.alert != nil {
		edges = append(edges, alertescalation.EdgeAlert)
	}
	if m.rule != nil {
		edges = append(edges, alertescalation.EdgeRule)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AlertEscalationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case alertescalation.EdgeAlert:
		if id := m.alert; id != nil {
			return []ent.Value{*id}
		}
	case alertescalation.EdgeRule:
		if id := m.rule; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AlertEscalationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AlertEscalationMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AlertEscalationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedalert {
		edges = append(edges, alertescalation.EdgeAlert)
	}
	if m.clearedrule {
		edges = append(edges, alertescalation.EdgeRule)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AlertEscalationMutation) EdgeCleared(name string) bool {
	switch name {
	case alertescalation.EdgeAlert:
		return m.clearedalert
	case alertescalation.EdgeRule:
		return m.clearedrule
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AlertEscalationMutation) ClearEdge(name string) error {
	switch name {
	case alertescalation.EdgeAlert:
		m.ClearAlert()
		return nil
	case alertescalation.EdgeRule:
		m.ClearRule()
		return nil
	}
	return fmt.Errorf("unknown AlertEscalation unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AlertEscalationMutation) ResetEdge(name string) error {
	switch name {
	case alertescalation.EdgeAlert:
		m.ResetAlert()
		return nil
	case alertescalation.EdgeRule:
		m.ResetRule()
		return nil
	}
	return fmt.Errorf("unknown AlertEscalation edge %s", name)
}

// AlertRuleMutation represents an operation that mutates the AlertRule nodes in the graph.
type AlertRuleMutation struct {
	config
	op                 Op
	typ                string
	id                 *string
	name               *string
	description        *string
	event_type         *string
	conditions         *[]map[string]interface{}
	appendconditions   []map[string]interface{}
	severity           *alertrule.Severity
	channels           *[]string
	appendchannels     []string
	throttle           *map[string]interface{}
	quiet_hours        *map[string]interface{}
	escalation         *map[string]interface{}
	device_id          *string
	enabled            *bool
	created_at         *time.Time
	updated_at         *time.Time
	clearedFields      map[string]struct{}
	alerts             map[string]struct{}
	removedalerts      map[string]struct{}
	clearedalerts      bool
	escalations        map[string]struct{}
	removedescalations map[string]struct{}
	clearedescalations bool
	done               bool
	oldValue           func(context.Context) (*AlertRule, error)
	predicates         []predicate.AlertRule
}

var _ ent.Mutation = (*AlertRuleMutation)(nil)

// alertruleOption allows management of the mutation configuration using functional options.
type alertruleOption func(*AlertRuleMutation)

// newAlertRuleMutation creates new mutation for the AlertRule entity.
func newAlertRuleMutation(c config, op Op, opts ...alertruleOption) *AlertRuleMutation {
	m := &AlertRuleMutation{
		config:        c,
		op:            op,
		typ:           TypeAlertRule,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAlertRuleID sets the ID field of the mutation.
func withAlertRuleID(id string) alertruleOption {
	return func(m *AlertRuleMutation) {
		var (
			err   error
			once  sync.Once
			value *AlertRule
		)
		m.oldValue = func(ctx context.Context) (*AlertRule, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AlertRule.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAlertRule sets the old AlertRule of the mutation.
func withAlertRule(node *AlertRule) alertruleOption {
	return func(m *AlertRuleMutation) {
		m.oldValue = func(context.Context) (*AlertRule, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AlertRuleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AlertRuleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AlertRule entities.
func (m *AlertRuleMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AlertRuleMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AlertRuleMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AlertRule.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *AlertRuleMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *AlertRuleMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the AlertRule entity.
// If the AlertRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertRuleMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *AlertRuleMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *AlertRuleMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *AlertRuleMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the AlertRule entity.
// If the AlertRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertRuleMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *AlertRuleMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[alertrule.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *AlertRuleMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[alertrule.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *AlertRuleMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, alertrule.FieldDescription)
}

// SetEventType sets the "event_type" field.
func (m *AlertRuleMutation) SetEventType(s string) {
	m.event_type = &s
}

// EventType returns the value of the "event_type" field in the mutation.
func (m *AlertRuleMutation) EventType() (r string, exists bool) {
	v := m.event_type
	if v == nil {
		return
	}
	return *v, true
}

// OldEventType returns the old "event_type" field's value of the AlertRule entity.
// If the AlertRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertRuleMutation) OldEventType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEventType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEventType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEventType: %w", err)
	}
	return oldValue.EventType, nil
}

// ResetEventType resets all changes to the "event_type" field.
func (m *AlertRuleMutation) ResetEventType() {
	m.event_type = nil
}

// SetConditions sets the "conditions" field.
func (m *AlertRuleMutation) SetConditions(value []map[string]interface{}) {
	m.conditions = &value
	m.appendconditions = nil
}

// Conditions returns the value of the "conditions" field in the mutation.
func (m *AlertRuleMutation) Conditions() (r []map[string]interface{}, exists bool) {
	v := m.conditions
	if v == nil {
		return
	}
	return *v, true
}

// OldConditions returns the old "conditions" field's value of the AlertRule entity.
// If the AlertRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertRuleMutation) OldConditions(ctx context.Context) (v []map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConditions is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConditions requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConditions: %w", err)
	}
	return oldValue.Conditions, nil
}

// AppendConditions adds value to the "conditions" field.
func (m *AlertRuleMutation) AppendConditions(value []map[string]interface{}) {
	m.appendconditions = append(m.appendconditions, value...)
}

// AppendedConditions returns the list of values that were appended to the "conditions" field in this mutation.
func (m *AlertRuleMutation) AppendedConditions() ([]map[string]interface{}, bool) {
	if len(m.appendconditions) == 0 {
		return nil, false
	}
	return m.appendconditions, true
}

// ClearConditions clears the value of the "conditions" field.
func (m *AlertRuleMutation) ClearConditions() {
	m.conditions = nil
	m.appendconditions = nil
	m.clearedFields[alertrule.FieldConditions] = struct{}{}
}

// ConditionsCleared returns if the "conditions" field was cleared in this mutation.
func (m *AlertRuleMutation) ConditionsCleared() bool {
	_, ok := m.clearedFields[alertrule.FieldConditions]
	return ok
}

// ResetConditions resets all changes to the "conditions" field.
func (m *AlertRuleMutation) ResetConditions() {
	m.conditions = nil
	m.appendconditions = nil
	delete(m.clearedFields, alertrule.FieldConditions)
}

// SetSeverity sets the "severity" field.
func (m *AlertRuleMutation) SetSeverity(a alertrule.Severity) {
	m.severity = &a
}

// Severity returns the value of the "severity" field in the mutation.
func (m *AlertRuleMutation) Severity() (r alertrule.Severity, exists bool) {
	v := m.severity
	if v == nil {
		return
	}
	return *v, true
}

// OldSeverity returns the old "severity" field's value of the AlertRule entity.
// If the AlertRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertRuleMutation) OldSeverity(ctx context.Context) (v alertrule.Severity, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSeverity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSeverity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSeverity: %w", err)
	}
	return oldValue.Severity, nil
}

// ResetSeverity resets all changes to the "severity" field.
func (m *AlertRuleMutation) ResetSeverity() {
	m.severity = nil
}

// SetChannels sets the "channels" field.
func (m *AlertRuleMutation) SetChannels(s []string) {
	m.channels = &s
	m.appendchannels = nil
}

// Channels returns the value of the "channels" field in the mutation.
func (m *AlertRuleMutation) Channels() (r []string, exists bool) {
	v := m.channels
	if v == nil {
		return
	}
	return *v, true
}

// OldChannels returns the old "channels" field's value of the AlertRule entity.
// If the AlertRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertRuleMutation) OldChannels(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChannels is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChannels requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChannels: %w", err)
	}
	return oldValue.Channels, nil
}

// AppendChannels adds s to the "channels" field.
func (m *AlertRuleMutation) AppendChannels(s []string) {
	m.appendchannels = append(m.appendchannels, s...)
}

// AppendedChannels returns the list of values that were appended to the "channels" field in this mutation.
func (m *AlertRuleMutation) AppendedChannels() ([]string, bool) {
	if len(m.appendchannels) == 0 {
		return nil, false
	}
	return m.appendchannels, true
}

// ResetChannels resets all changes to the "channels" field.
func (m *AlertRuleMutation) ResetChannels() {
	m.channels = nil
	m.appendchannels = nil
}

// SetThrottle sets the "throttle" field.
func (m *AlertRuleMutation) SetThrottle(value map[string]interface{}) {
	m.throttle = &value
}

// Throttle returns the value of the "throttle" field in the mutation.
func (m *AlertRuleMutation) Throttle() (r map[string]interface{}, exists bool) {
	v := m.throttle
	if v == nil {
		return
	}
	return *v, true
}

// OldThrottle returns the old "throttle" field's value of the AlertRule entity.
// If the AlertRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertRuleMutation) OldThrottle(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldThrottle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldThrottle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldThrottle: %w", err)
	}
	return oldValue.Throttle, nil
}

// ClearThrottle clears the value of the "throttle" field.
func (m *AlertRuleMutation) ClearThrottle() {
	m.throttle = nil
	m.clearedFields[alertrule.FieldThrottle] = struct{}{}
}

// ThrottleCleared returns if the "throttle" field was cleared in this mutation.
func (m *AlertRuleMutation) ThrottleCleared() bool {
	_, ok := m.clearedFields[alertrule.FieldThrottle]
	return ok
}

// ResetThrottle resets all changes to the "throttle" field.
func (m *AlertRuleMutation) ResetThrottle() {
	m.throttle = nil
	delete(m.clearedFields, alertrule.FieldThrottle)
}

// SetQuietHours sets the "quiet_hours" field.
func (m *AlertRuleMutation) SetQuietHours(value map[string]interface{}) {
	m.quiet_hours = &value
}

// QuietHours returns the value of the "quiet_hours" field in the mutation.
func (m *AlertRuleMutation) QuietHours() (r map[string]interface{}, exists bool) {
	v := m.quiet_hours
	if v == nil {
		return
	}
	return *v, true
}

// OldQuietHours returns the old "quiet_hours" field's value of the AlertRule entity.
// If the AlertRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertRuleMutation) OldQuietHours(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQuietHours is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQuietHours requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQuietHours: %w", err)
	}
	return oldValue.QuietHours, nil
}

// ClearQuietHours clears the value of the "quiet_hours" field.
func (m *AlertRuleMutation) ClearQuietHours() {
	m.quiet_hours = nil
	m.clearedFields[alertrule.FieldQuietHours] = struct{}{}
}

// QuietHoursCleared returns if the "quiet_hours" field was cleared in this mutation.
func (m *AlertRuleMutation) QuietHoursCleared() bool {
	_, ok := m.clearedFields[alertrule.FieldQuietHours]
	return ok
}

// ResetQuietHours resets all changes to the "quiet_hours" field.
func (m *AlertRuleMutation) ResetQuietHours() {
	m.quiet_hours = nil
	delete(m.clearedFields, alertrule.FieldQuietHours)
}

// SetEscalation sets the "escalation" field.
func (m *AlertRuleMutation) SetEscalation(value map[string]interface{}) {
	m.escalation = &value
}

// Escalation returns the value of the "escalation" field in the mutation.
func (m *AlertRuleMutation) Escalation() (r map[string]interface{}, exists bool) {
	v := m.escalation
	if v == nil {
		return
	}
	return *v, true
}

// OldEscalation returns the old "escalation" field's value of the AlertRule entity.
// If the AlertRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertRuleMutation) OldEscalation(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEscalation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEscalation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEscalation: %w", err)
	}
	return oldValue.Escalation, nil
}

// ClearEscalation clears the value of the "escalation" field.
func (m *AlertRuleMutation) ClearEscalation() {
	m.escalation = nil
	m.clearedFields[alertrule.FieldEscalation] = struct{}{}
}

// EscalationCleared returns if the "escalation" field was cleared in this mutation.
func (m *AlertRuleMutation) EscalationCleared() bool {
	_, ok := m.clearedFields[alertrule.FieldEscalation]
	return ok
}

// ResetEscalation resets all changes to the "escalation" field.
func (m *AlertRuleMutation) ResetEscalation() {
	m.escalation = nil
	delete(m.clearedFields, alertrule.FieldEscalation)
}

// SetDeviceID sets the "device_id" field.
func (m *AlertRuleMutation) SetDeviceID(s string) {
	m.device_id = &s
}

// DeviceID returns the value of the "device_id" field in the mutation.
func (m *AlertRuleMutation) DeviceID() (r string, exists bool) {
	v := m.device_id
	if v == nil {
		return
	}
	return *v, true
}

// OldDeviceID returns the old "device_id" field's value of the AlertRule entity.
// If the AlertRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertRuleMutation) OldDeviceID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeviceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeviceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeviceID: %w", err)
	}
	return oldValue.DeviceID, nil
}

// ClearDeviceID clears the value of the "device_id" field.
func (m *AlertRuleMutation) ClearDeviceID() {
	m.device_id = nil
	m.clearedFields[alertrule.FieldDeviceID] = struct{}{}
}

// DeviceIDCleared returns if the "device_id" field was cleared in this mutation.
func (m *AlertRuleMutation) DeviceIDCleared() bool {
	_, ok := m.clearedFields[alertrule.FieldDeviceID]
	return ok
}

// ResetDeviceID resets all changes to the "device_id" field.
func (m *AlertRuleMutation) ResetDeviceID() {
	m.device_id = nil
	delete(m.clearedFields, alertrule.FieldDeviceID)
}

// SetEnabled sets the "enabled" field.
func (m *AlertRuleMutation) SetEnabled(b bool) {
	m.enabled = &b
}

// Enabled returns the value of the "enabled" field in the mutation.
func (m *AlertRuleMutation) Enabled() (r bool, exists bool) {
	v := m.enabled
	if v == nil {
		return
	}
	return *v, true
}

// OldEnabled returns the old "enabled" field's value of the AlertRule entity.
// If the AlertRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertRuleMutation) OldEnabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnabled: %w", err)
	}
	return oldValue.Enabled, nil
}

// ResetEnabled resets all changes to the "enabled" field.
func (m *AlertRuleMutation) ResetEnabled() {
	m.enabled = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *AlertRuleMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AlertRuleMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the AlertRule entity.
// If the AlertRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertRuleMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AlertRuleMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AlertRuleMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AlertRuleMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the AlertRule entity.
// If the AlertRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertRuleMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AlertRuleMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// AddAlertIDs adds the "alerts" edge to the Alert entity by ids.
func (m *AlertRuleMutation) AddAlertIDs(ids ...string) {
	if m.alerts == nil {
		m.alerts = make(map[string]struct{})
	}
	for i := range ids {
		m.alerts[ids[i]] = struct{}{}
	}
}

// ClearAlerts clears the "alerts" edge to the Alert entity.
func (m *AlertRuleMutation) ClearAlerts() {
	m.clearedalerts = true
}

// AlertsCleared reports if the "alerts" edge to the Alert entity was cleared.
func (m *AlertRuleMutation) AlertsCleared() bool {
	return m.clearedalerts
}

// RemoveAlertIDs removes the "alerts" edge to the Alert entity by IDs.
func (m *AlertRuleMutation) RemoveAlertIDs(ids ...string) {
	if m.removedalerts == nil {
		m.removedalerts = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.alerts, ids[i])
		m.removedalerts[ids[i]] = struct{}{}
	}
}

// RemovedAlerts returns the removed IDs of the "alerts" edge to the Alert entity.
func (m *AlertRuleMutation) RemovedAlertsIDs() (ids []string) {
	for id := range m.removedalerts {
		ids = append(ids, id)
	}
	return
}

// AlertsIDs returns the "alerts" edge IDs in the mutation.
func (m *AlertRuleMutation) AlertsIDs() (ids []string) {
	for id := range m.alerts {
		ids = append(ids, id)
	}
	return
}

// ResetAlerts resets all changes to the "alerts" edge.
func (m *AlertRuleMutation) ResetAlerts() {
	m.alerts = nil
	m.clearedalerts = false
	m.removedalerts = nil
}

// AddEscalationIDs adds the "escalations" edge to the AlertEscalation entity by ids.
func (m *AlertRuleMutation) AddEscalationIDs(ids ...string) {
	if m.escalations == nil {
		m.escalations = make(map[string]struct{})
	}
	for i := range ids {
		m.escalations[ids[i]] = struct{}{}
	}
}

// ClearEscalations clears the "escalations" edge to the AlertEscalation entity.
func (m *AlertRuleMutation) ClearEscalations() {
	m.clearedescalations = true
}

// EscalationsCleared reports if the "escalations" edge to the AlertEscalation entity was cleared.
func (m *AlertRuleMutation) EscalationsCleared() bool {
	return m.clearedescalations
}

// RemoveEscalationIDs removes the "escalations" edge to the AlertEscalation entity by IDs.
func (m *AlertRuleMutation) RemoveEscalationIDs(ids ...string) {
	if m.removedescalations == nil {
		m.removedescalations = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.escalations, ids[i])
		m.removedescalations[ids[i]] = struct{}{}
	}
}

// RemovedEscalations returns the removed IDs of the "escalations" edge to the AlertEscalation entity.
func (m *AlertRuleMutation) RemovedEscalationsIDs() (ids []string) {
	for id := range m.removedescalations {
		ids = append(ids, id)
	}
	return
}

// EscalationsIDs returns the "escalations" edge IDs in the mutation.
func (m *AlertRuleMutation) EscalationsIDs() (ids []string) {
	for id := range m.escalations {
		ids = append(ids, id)
	}
	return
}

// ResetEscalations resets all changes to the "escalations" edge.
func (m *AlertRuleMutation) ResetEscalations() {
	m.escalations = nil
	m.clearedescalations = false
	m.removedescalations = nil
}

// Where appends a list predicates to the AlertRuleMutation builder.
func (m *AlertRuleMutation) Where(ps ...predicate.AlertRule) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AlertRuleMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AlertRuleMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AlertRule, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AlertRuleMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AlertRuleMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AlertRule).
func (m *AlertRuleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AlertRuleMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.name != nil {
		fields = append(fields, alertrule.FieldName)
	}
	if m.description != nil {
		fields = append(fields, alertrule.FieldDescription)
	}
	if m.event_type != nil {
		fields = append(fields, alertrule.FieldEventType)
	}
	if m.conditions != nil {
		fields = append(fields, alertrule.FieldConditions)
	}
	if m.severity != nil {
		fields = append(fields, alertrule.FieldSeverity)
	}
	if m.channels != nil {
		fields = append(fields, alertrule.FieldChannels)
	}
	if m.throttle != nil {
		fields = append(fields, alertrule.FieldThrottle)
	}
	if m.quiet_hours != nil {
		fields = append(fields, alertrule.FieldQuietHours)
	}
	if m.escalation != nil {
		fields = append(fields, alertrule.FieldEscalation)
	}
	if m.device_id != nil {
		fields = append(fields, alertrule.FieldDeviceID)
	}
	if m.enabled != nil {
		fields = append(fields, alertrule.FieldEnabled)
	}
	if m.created_at != nil {
		fields = append(fields, alertrule.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, alertrule.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AlertRuleMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case alertrule.FieldName:
		return m.Name()
	case alertrule.FieldDescription:
		return m.Description()
	case alertrule.FieldEventType:
		return m.EventType()
	case alertrule.FieldConditions:
		return m.Conditions()
	case alertrule.FieldSeverity:
		return m.Severity()
	case alertrule.FieldChannels:
		return m.Channels()
	case alertrule.FieldThrottle:
		return m.Throttle()
	case alertrule.FieldQuietHours:
		return m.QuietHours()
	case alertrule.FieldEscalation:
		return m.Escalation()
	case alertrule.FieldDeviceID:
		return m.DeviceID()
	case alertrule.FieldEnabled:
		return m.Enabled()
	case alertrule.FieldCreatedAt:
		return m.CreatedAt()
	case alertrule.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AlertRuleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case alertrule.FieldName:
		return m.OldName(ctx)
	case alertrule.FieldDescription:
		return m.OldDescription(ctx)
	case alertrule.FieldEventType:
		return m.OldEventType(ctx)
	case alertrule.FieldConditions:
		return m.OldConditions(ctx)
	case alertrule.FieldSeverity:
		return m.OldSeverity(ctx)
	case alertrule.FieldChannels:
		return m.OldChannels(ctx)
	case alertrule.FieldThrottle:
		return m.OldThrottle(ctx)
	case alertrule.FieldQuietHours:
		return m.OldQuietHours(ctx)
	case alertrule.FieldEscalation:
		return m.OldEscalation(ctx)
	case alertrule.FieldDeviceID:
		return m.OldDeviceID(ctx)
	case alertrule.FieldEnabled:
		return m.OldEnabled(ctx)
	case alertrule.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case alertrule.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown AlertRule field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AlertRuleMutation) SetField(name string, value ent.Value) error {
	switch name {
	case alertrule.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case alertrule.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case alertrule.FieldEventType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEventType(v)
		return nil
	case alertrule.FieldConditions:
		v, ok := value.([]map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConditions(v)
		return nil
	case alertrule.FieldSeverity:
		v, ok := value.(alertrule.Severity)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSeverity(v)
		return nil
	case alertrule.FieldChannels:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChannels(v)
		return nil
	case alertrule.FieldThrottle:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetThrottle(v)
		return nil
	case alertrule.FieldQuietHours:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQuietHours(v)
		return nil
	case alertrule.FieldEscalation:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEscalation(v)
		return nil
	case alertrule.FieldDeviceID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeviceID(v)
		return nil
	case alertrule.FieldEnabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnabled(v)
		return nil
	case alertrule.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case alertrule.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown AlertRule field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AlertRuleMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AlertRuleMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AlertRuleMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown AlertRule numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AlertRuleMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(alertrule.FieldDescription) {
		fields = append(fields, alertrule.FieldDescription)
	}
	if m.FieldCleared(alertrule.FieldConditions) {
		fields = append(fields, alertrule.FieldConditions)
	}
	if m.FieldCleared(alertrule.FieldThrottle) {
		fields = append(fields, alertrule.FieldThrottle)
	}
	if m.FieldCleared(alertrule.FieldQuietHours) {
		fields = append(fields, alertrule.FieldQuietHours)
	}
	if m.FieldCleared(alertrule.FieldEscalation) {
		fields = append(fields, alertrule.FieldEscalation)
	}
	if m.FieldCleared(alertrule.FieldDeviceID) {
		fields = append(fields, alertrule.FieldDeviceID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AlertRuleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AlertRuleMutation) ClearField(name string) error {
	switch name {
	case alertrule.FieldDescription:
		m.ClearDescription()
		return nil
	case alertrule.FieldConditions:
		m.ClearConditions()
		return nil
	case alertrule.FieldThrottle:
		m.ClearThrottle()
		return nil
	case alertrule.FieldQuietHours:
		m.ClearQuietHours()
		return nil
	case alertrule.FieldEscalation:
		m.ClearEscalation()
		return nil
	case alertrule.FieldDeviceID:
		m.ClearDeviceID()
		return nil
	}
	return fmt.Errorf("unknown AlertRule nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AlertRuleMutation) ResetField(name string) error {
	switch name {
	case alertrule.FieldName:
		m.ResetName()
		return nil
	case alertrule.FieldDescription:
		m.ResetDescription()
		return nil
	case alertrule.FieldEventType:
		m.ResetEventType()
		return nil
	case alertrule.FieldConditions:
		m.ResetConditions()
		return nil
	case alertrule.FieldSeverity:
		m.ResetSeverity()
		return nil
	case alertrule.FieldChannels:
		m.ResetChannels()
		return nil
	case alertrule.FieldThrottle:
		m.ResetThrottle()
		return nil
	case alertrule.FieldQuietHours:
		m.ResetQuietHours()
		return nil
	case alertrule.FieldEscalation:
		m.ResetEscalation()
		return nil
	case alertrule.FieldDeviceID:
		m.ResetDeviceID()
		return nil
	case alertrule.FieldEnabled:
		m.ResetEnabled()
		return nil
	case alertrule.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case alertrule.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown AlertRule field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AlertRuleMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.alerts != nil {
		edges = append(edges, alertrule.EdgeAlerts)
	}
	if m.escalations != nil {
		edges = append(edges, alertrule.EdgeEscalations)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AlertRuleMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case alertrule.EdgeAlerts:
		ids := make([]ent.Value, 0, len(m.alerts))
		for id := range m.alerts {
			ids = append(ids, id)
		}
		return ids
	case alertrule.EdgeEscalations:
		ids := make([]ent.Value, 0, len(m.escalations))
		for id := range m.escalations {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AlertRuleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedalerts != nil {
		edges = append(edges, alertrule.EdgeAlerts)
	}
	if m.removedescalations != nil {
		edges = append(edges, alertrule.EdgeEscalations)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AlertRuleMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case alertrule.EdgeAlerts:
		ids := make([]ent.Value, 0, len(m.removedalerts))
		for id := range m.removedalerts {
			ids = append(ids, id)
		}
		return ids
	case alertrule.EdgeEscalations:
		ids := make([]ent.Value, 0, len(m.removedescalations))
		for id := range m.removedescalations {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AlertRuleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedalerts {
		edges = append(edges, alertrule.EdgeAlerts)
	}
	if m.clearedescalations {
		edges = append(edges, alertrule.EdgeEscalations)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AlertRuleMutation) EdgeCleared(name string) bool {
	switch name {
	case alertrule.EdgeAlerts:
		return m.clearedalerts
	case alertrule.EdgeEscalations:
		return m.clearedescalations
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AlertRuleMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown AlertRule unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AlertRuleMutation) ResetEdge(name string) error {
	switch name {
	case alertrule.EdgeAlerts:
		m.ResetAlerts()
		return nil
	case alertrule.EdgeEscalations:
		m.ResetEscalations()
		return nil
	}
	return fmt.Errorf("unknown AlertRule edge %s", name)
}

// AlertRuleTemplateMutation represents an operation that mutates the AlertRuleTemplate nodes in the graph.
type AlertRuleTemplateMutation struct {
	config
	op               Op
	typ              string
	id               *string
	name             *string
	description      *string
	category         *alertruletemplate.Category
	event_type       *string
	severity         *alertruletemplate.Severity
	variables        *[]map[string]interface{}
	appendvariables  []map[string]interface{}
	conditions       *[]map[string]interface{}
	appendconditions []map[string]interface{}
	throttle         *map[string]interface{}
	channels         *[]string
	appendchannels   []string
	is_built_in      *bool
	version          *string
	usage_count      *int
	addusage_count   *int
	created_at       *time.Time
	updated_at       *time.Time
	clearedFields    map[string]struct{}
	done             bool
	oldValue         func(context.Context) (*AlertRuleTemplate, error)
	predicates       []predicate.AlertRuleTemplate
}

var _ ent.Mutation = (*AlertRuleTemplateMutation)(nil)

// alertruletemplateOption allows management of the mutation configuration using functional options.
type alertruletemplateOption func(*AlertRuleTemplateMutation)

// newAlertRuleTemplateMutation creates new mutation for the AlertRuleTemplate entity.
func newAlertRuleTemplateMutation(c config, op Op, opts ...alertruletemplateOption) *AlertRuleTemplateMutation {
	m := &AlertRuleTemplateMutation{
		config:        c,
		op:            op,
		typ:           TypeAlertRuleTemplate,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAlertRuleTemplateID sets the ID field of the mutation.
func withAlertRuleTemplateID(id string) alertruletemplateOption {
	return func(m *AlertRuleTemplateMutation) {
		var (
			err   error
			once  sync.Once
			value *AlertRuleTemplate
		)
		m.oldValue = func(ctx context.Context) (*AlertRuleTemplate, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AlertRuleTemplate.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAlertRuleTemplate sets the old AlertRuleTemplate of the mutation.
func withAlertRuleTemplate(node *AlertRuleTemplate) alertruletemplateOption {
	return func(m *AlertRuleTemplateMutation) {
		m.oldValue = func(context.Context) (*AlertRuleTemplate, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AlertRuleTemplateMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AlertRuleTemplateMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AlertRuleTemplate entities.
func (m *AlertRuleTemplateMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AlertRuleTemplateMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AlertRuleTemplateMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AlertRuleTemplate.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *AlertRuleTemplateMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *AlertRuleTemplateMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the AlertRuleTemplate entity.
// If the AlertRuleTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertRuleTemplateMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *AlertRuleTemplateMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *AlertRuleTemplateMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *AlertRuleTemplateMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the AlertRuleTemplate entity.
// If the AlertRuleTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertRuleTemplateMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *AlertRuleTemplateMutation) ResetDescription() {
	m.description = nil
}

// SetCategory sets the "category" field.
func (m *AlertRuleTemplateMutation) SetCategory(a alertruletemplate.Category) {
	m.category = &a
}

// Category returns the value of the "category" field in the mutation.
func (m *AlertRuleTemplateMutation) Category() (r alertruletemplate.Category, exists bool) {
	v := m.category
	if v == nil {
		return
	}
	return *v, true
}

// OldCategory returns the old "category" field's value of the AlertRuleTemplate entity.
// If the AlertRuleTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertRuleTemplateMutation) OldCategory(ctx context.Context) (v alertruletemplate.Category, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategory: %w", err)
	}
	return oldValue.Category, nil
}

// ResetCategory resets all changes to the "category" field.
func (m *AlertRuleTemplateMutation) ResetCategory() {
	m.category = nil
}

// SetEventType sets the "event_type" field.
func (m *AlertRuleTemplateMutation) SetEventType(s string) {
	m.event_type = &s
}

// EventType returns the value of the "event_type" field in the mutation.
func (m *AlertRuleTemplateMutation) EventType() (r string, exists bool) {
	v := m.event_type
	if v == nil {
		return
	}
	return *v, true
}

// OldEventType returns the old "event_type" field's value of the AlertRuleTemplate entity.
// If the AlertRuleTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertRuleTemplateMutation) OldEventType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEventType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEventType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEventType: %w", err)
	}
	return oldValue.EventType, nil
}

// ResetEventType resets all changes to the "event_type" field.
func (m *AlertRuleTemplateMutation) ResetEventType() {
	m.event_type = nil
}

// SetSeverity sets the "severity" field.
func (m *AlertRuleTemplateMutation) SetSeverity(a alertruletemplate.Severity) {
	m.severity = &a
}

// Severity returns the value of the "severity" field in the mutation.
func (m *AlertRuleTemplateMutation) Severity() (r alertruletemplate.Severity, exists bool) {
	v := m.severity
	if v == nil {
		return
	}
	return *v, true
}

// OldSeverity returns the old "severity" field's value of the AlertRuleTemplate entity.
// If the AlertRuleTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertRuleTemplateMutation) OldSeverity(ctx context.Context) (v alertruletemplate.Severity, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSeverity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSeverity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSeverity: %w", err)
	}
	return oldValue.Severity, nil
}

// ResetSeverity resets all changes to the "severity" field.
func (m *AlertRuleTemplateMutation) ResetSeverity() {
	m.severity = nil
}

// SetVariables sets the "variables" field.
func (m *AlertRuleTemplateMutation) SetVariables(value []map[string]interface{}) {
	m.variables = &value
	m.appendvariables = nil
}

// Variables returns the value of the "variables" field in the mutation.
func (m *AlertRuleTemplateMutation) Variables() (r []map[string]interface{}, exists bool) {
	v := m.variables
	if v == nil {
		return
	}
	return *v, true
}

// OldVariables returns the old "variables" field's value of the AlertRuleTemplate entity.
// If the AlertRuleTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertRuleTemplateMutation) OldVariables(ctx context.Context) (v []map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVariables is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVariables requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVariables: %w", err)
	}
	return oldValue.Variables, nil
}

// AppendVariables adds value to the "variables" field.
func (m *AlertRuleTemplateMutation) AppendVariables(value []map[string]interface{}) {
	m.appendvariables = append(m.appendvariables, value...)
}

// AppendedVariables returns the list of values that were appended to the "variables" field in this mutation.
func (m *AlertRuleTemplateMutation) AppendedVariables() ([]map[string]interface{}, bool) {
	if len(m.appendvariables) == 0 {
		return nil, false
	}
	return m.appendvariables, true
}

// ClearVariables clears the value of the "variables" field.
func (m *AlertRuleTemplateMutation) ClearVariables() {
	m.variables = nil
	m.appendvariables = nil
	m.clearedFields[alertruletemplate.FieldVariables] = struct{}{}
}

// VariablesCleared returns if the "variables" field was cleared in this mutation.
func (m *AlertRuleTemplateMutation) VariablesCleared() bool {
	_, ok := m.clearedFields[alertruletemplate.FieldVariables]
	return ok
}

// ResetVariables resets all changes to the "variables" field.
func (m *AlertRuleTemplateMutation) ResetVariables() {
	m.variables = nil
	m.appendvariables = nil
	delete(m.clearedFields, alertruletemplate.FieldVariables)
}

// SetConditions sets the "conditions" field.
func (m *AlertRuleTemplateMutation) SetConditions(value []map[string]interface{}) {
	m.conditions = &value
	m.appendconditions = nil
}

// Conditions returns the value of the "conditions" field in the mutation.
func (m *AlertRuleTemplateMutation) Conditions() (r []map[string]interface{}, exists bool) {
	v := m.conditions
	if v == nil {
		return
	}
	return *v, true
}

// OldConditions returns the old "conditions" field's value of the AlertRuleTemplate entity.
// If the AlertRuleTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertRuleTemplateMutation) OldConditions(ctx context.Context) (v []map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConditions is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConditions requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConditions: %w", err)
	}
	return oldValue.Conditions, nil
}

// AppendConditions adds value to the "conditions" field.
func (m *AlertRuleTemplateMutation) AppendConditions(value []map[string]interface{}) {
	m.appendconditions = append(m.appendconditions, value...)
}

// AppendedConditions returns the list of values that were appended to the "conditions" field in this mutation.
func (m *AlertRuleTemplateMutation) AppendedConditions() ([]map[string]interface{}, bool) {
	if len(m.appendconditions) == 0 {
		return nil, false
	}
	return m.appendconditions, true
}

// ClearConditions clears the value of the "conditions" field.
func (m *AlertRuleTemplateMutation) ClearConditions() {
	m.conditions = nil
	m.appendconditions = nil
	m.clearedFields[alertruletemplate.FieldConditions] = struct{}{}
}

// ConditionsCleared returns if the "conditions" field was cleared in this mutation.
func (m *AlertRuleTemplateMutation) ConditionsCleared() bool {
	_, ok := m.clearedFields[alertruletemplate.FieldConditions]
	return ok
}

// ResetConditions resets all changes to the "conditions" field.
func (m *AlertRuleTemplateMutation) ResetConditions() {
	m.conditions = nil
	m.appendconditions = nil
	delete(m.clearedFields, alertruletemplate.FieldConditions)
}

// SetThrottle sets the "throttle" field.
func (m *AlertRuleTemplateMutation) SetThrottle(value map[string]interface{}) {
	m.throttle = &value
}

// Throttle returns the value of the "throttle" field in the mutation.
func (m *AlertRuleTemplateMutation) Throttle() (r map[string]interface{}, exists bool) {
	v := m.throttle
	if v == nil {
		return
	}
	return *v, true
}

// OldThrottle returns the old "throttle" field's value of the AlertRuleTemplate entity.
// If the AlertRuleTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertRuleTemplateMutation) OldThrottle(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldThrottle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldThrottle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldThrottle: %w", err)
	}
	return oldValue.Throttle, nil
}

// ClearThrottle clears the value of the "throttle" field.
func (m *AlertRuleTemplateMutation) ClearThrottle() {
	m.throttle = nil
	m.clearedFields[alertruletemplate.FieldThrottle] = struct{}{}
}

// ThrottleCleared returns if the "throttle" field was cleared in this mutation.
func (m *AlertRuleTemplateMutation) ThrottleCleared() bool {
	_, ok := m.clearedFields[alertruletemplate.FieldThrottle]
	return ok
}

// ResetThrottle resets all changes to the "throttle" field.
func (m *AlertRuleTemplateMutation) ResetThrottle() {
	m.throttle = nil
	delete(m.clearedFields, alertruletemplate.FieldThrottle)
}

// SetChannels sets the "channels" field.
func (m *AlertRuleTemplateMutation) SetChannels(s []string) {
	m.channels = &s
	m.appendchannels = nil
}

// Channels returns the value of the "channels" field in the mutation.
func (m *AlertRuleTemplateMutation) Channels() (r []string, exists bool) {
	v := m.channels
	if v == nil {
		return
	}
	return *v, true
}

// OldChannels returns the old "channels" field's value of the AlertRuleTemplate entity.
// If the AlertRuleTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertRuleTemplateMutation) OldChannels(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChannels is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChannels requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChannels: %w", err)
	}
	return oldValue.Channels, nil
}

// AppendChannels adds s to the "channels" field.
func (m *AlertRuleTemplateMutation) AppendChannels(s []string) {
	m.appendchannels = append(m.appendchannels, s...)
}

// AppendedChannels returns the list of values that were appended to the "channels" field in this mutation.
func (m *AlertRuleTemplateMutation) AppendedChannels() ([]string, bool) {
	if len(m.appendchannels) == 0 {
		return nil, false
	}
	return m.appendchannels, true
}

// ResetChannels resets all changes to the "channels" field.
func (m *AlertRuleTemplateMutation) ResetChannels() {
	m.channels = nil
	m.appendchannels = nil
}

// SetIsBuiltIn sets the "is_built_in" field.
func (m *AlertRuleTemplateMutation) SetIsBuiltIn(b bool) {
	m.is_built_in = &b
}

// IsBuiltIn returns the value of the "is_built_in" field in the mutation.
func (m *AlertRuleTemplateMutation) IsBuiltIn() (r bool, exists bool) {
	v := m.is_built_in
	if v == nil {
		return
	}
	return *v, true
}

// OldIsBuiltIn returns the old "is_built_in" field's value of the AlertRuleTemplate entity.
// If the AlertRuleTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertRuleTemplateMutation) OldIsBuiltIn(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsBuiltIn is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsBuiltIn requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsBuiltIn: %w", err)
	}
	return oldValue.IsBuiltIn, nil
}

// ResetIsBuiltIn resets all changes to the "is_built_in" field.
func (m *AlertRuleTemplateMutation) ResetIsBuiltIn() {
	m.is_built_in = nil
}

// SetVersion sets the "version" field.
func (m *AlertRuleTemplateMutation) SetVersion(s string) {
	m.version = &s
}

// Version returns the value of the "version" field in the mutation.
func (m *AlertRuleTemplateMutation) Version() (r string, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the AlertRuleTemplate entity.
// If the AlertRuleTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertRuleTemplateMutation) OldVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// ResetVersion resets all changes to the "version" field.
func (m *AlertRuleTemplateMutation) ResetVersion() {
	m.version = nil
}

// SetUsageCount sets the "usage_count" field.
func (m *AlertRuleTemplateMutation) SetUsageCount(i int) {
	m.usage_count = &i
	m.addusage_count = nil
}

// UsageCount returns the value of the "usage_count" field in the mutation.
func (m *AlertRuleTemplateMutation) UsageCount() (r int, exists bool) {
	v := m.usage_count
	if v == nil {
		return
	}
	return *v, true
}

// OldUsageCount returns the old "usage_count" field's value of the AlertRuleTemplate entity.
// If the AlertRuleTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertRuleTemplateMutation) OldUsageCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsageCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsageCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsageCount: %w", err)
	}
	return oldValue.UsageCount, nil
}

// AddUsageCount adds i to the "usage_count" field.
func (m *AlertRuleTemplateMutation) AddUsageCount(i int) {
	if m.addusage_count != nil {
		*m.addusage_count += i
	} else {
		m.addusage_count = &i
	}
}

// AddedUsageCount returns the value that was added to the "usage_count" field in this mutation.
func (m *AlertRuleTemplateMutation) AddedUsageCount() (r int, exists bool) {
	v := m.addusage_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetUsageCount resets all changes to the "usage_count" field.
func (m *AlertRuleTemplateMutation) ResetUsageCount() {
	m.usage_count = nil
	m.addusage_count = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *AlertRuleTemplateMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AlertRuleTemplateMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the AlertRuleTemplate entity.
// If the AlertRuleTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertRuleTemplateMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AlertRuleTemplateMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AlertRuleTemplateMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AlertRuleTemplateMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the AlertRuleTemplate entity.
// If the AlertRuleTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertRuleTemplateMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AlertRuleTemplateMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// Where appends a list predicates to the AlertRuleTemplateMutation builder.
func (m *AlertRuleTemplateMutation) Where(ps ...predicate.AlertRuleTemplate) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AlertRuleTemplateMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AlertRuleTemplateMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AlertRuleTemplate, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AlertRuleTemplateMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AlertRuleTemplateMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AlertRuleTemplate).
func (m *AlertRuleTemplateMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AlertRuleTemplateMutation) Fields() []string {
	fields := make([]string, 0, 14)
	if m.name != nil {
		fields = append(fields, alertruletemplate.FieldName)
	}
	if m.description != nil {
		fields = append(fields, alertruletemplate.FieldDescription)
	}
	if m.category != nil {
		fields = append(fields, alertruletemplate.FieldCategory)
	}
	if m.event_type != nil {
		fields = append(fields, alertruletemplate.FieldEventType)
	}
	if m.severity != nil {
		fields = append(fields, alertruletemplate.FieldSeverity)
	}
	if m.variables != nil {
		fields = append(fields, alertruletemplate.FieldVariables)
	}
	if m.conditions != nil {
		fields = append(fields, alertruletemplate.FieldConditions)
	}
	if m.throttle != nil {
		fields = append(fields, alertruletemplate.FieldThrottle)
	}
	if m.channels != nil {
		fields = append(fields, alertruletemplate.FieldChannels)
	}
	if m.is_built_in != nil {
		fields = append(fields, alertruletemplate.FieldIsBuiltIn)
	}
	if m.version != nil {
		fields = append(fields, alertruletemplate.FieldVersion)
	}
	if m.usage_count != nil {
		fields = append(fields, alertruletemplate.FieldUsageCount)
	}
	if m.created_at != nil {
		fields = append(fields, alertruletemplate.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, alertruletemplate.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AlertRuleTemplateMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case alertruletemplate.FieldName:
		return m.Name()
	case alertruletemplate.FieldDescription:
		return m.Description()
	case alertruletemplate.FieldCategory:
		return m.Category()
	case alertruletemplate.FieldEventType:
		return m.EventType()
	case alertruletemplate.FieldSeverity:
		return m.Severity()
	case alertruletemplate.FieldVariables:
		return m.Variables()
	case alertruletemplate.FieldConditions:
		return m.Conditions()
	case alertruletemplate.FieldThrottle:
		return m.Throttle()
	case alertruletemplate.FieldChannels:
		return m.Channels()
	case alertruletemplate.FieldIsBuiltIn:
		return m.IsBuiltIn()
	case alertruletemplate.FieldVersion:
		return m.Version()
	case alertruletemplate.FieldUsageCount:
		return m.UsageCount()
	case alertruletemplate.FieldCreatedAt:
		return m.CreatedAt()
	case alertruletemplate.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AlertRuleTemplateMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case alertruletemplate.FieldName:
		return m.OldName(ctx)
	case alertruletemplate.FieldDescription:
		return m.OldDescription(ctx)
	case alertruletemplate.FieldCategory:
		return m.OldCategory(ctx)
	case alertruletemplate.FieldEventType:
		return m.OldEventType(ctx)
	case alertruletemplate.FieldSeverity:
		return m.OldSeverity(ctx)
	case alertruletemplate.FieldVariables:
		return m.OldVariables(ctx)
	case alertruletemplate.FieldConditions:
		return m.OldConditions(ctx)
	case alertruletemplate.FieldThrottle:
		return m.OldThrottle(ctx)
	case alertruletemplate.FieldChannels:
		return m.OldChannels(ctx)
	case alertruletemplate.FieldIsBuiltIn:
		return m.OldIsBuiltIn(ctx)
	case alertruletemplate.FieldVersion:
		return m.OldVersion(ctx)
	case alertruletemplate.FieldUsageCount:
		return m.OldUsageCount(ctx)
	case alertruletemplate.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case alertruletemplate.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown AlertRuleTemplate field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AlertRuleTemplateMutation) SetField(name string, value ent.Value) error {
	switch name {
	case alertruletemplate.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case alertruletemplate.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case alertruletemplate.FieldCategory:
		v, ok := value.(alertruletemplate.Category)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategory(v)
		return nil
	case alertruletemplate.FieldEventType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEventType(v)
		return nil
	case alertruletemplate.FieldSeverity:
		v, ok := value.(alertruletemplate.Severity)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSeverity(v)
		return nil
	case alertruletemplate.FieldVariables:
		v, ok := value.([]map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVariables(v)
		return nil
	case alertruletemplate.FieldConditions:
		v, ok := value.([]map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConditions(v)
		return nil
	case alertruletemplate.FieldThrottle:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetThrottle(v)
		return nil
	case alertruletemplate.FieldChannels:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChannels(v)
		return nil
	case alertruletemplate.FieldIsBuiltIn:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsBuiltIn(v)
		return nil
	case alertruletemplate.FieldVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case alertruletemplate.FieldUsageCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsageCount(v)
		return nil
	case alertruletemplate.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case alertruletemplate.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown AlertRuleTemplate field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AlertRuleTemplateMutation) AddedFields() []string {
	var fields []string
	if m.addusage_count != nil {
		fields = append(fields, alertruletemplate.FieldUsageCount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AlertRuleTemplateMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case alertruletemplate.FieldUsageCount:
		return m.AddedUsageCount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AlertRuleTemplateMutation) AddField(name string, value ent.Value) error {
	switch name {
	case alertruletemplate.FieldUsageCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUsageCount(v)
		return nil
	}
	return fmt.Errorf("unknown AlertRuleTemplate numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AlertRuleTemplateMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(alertruletemplate.FieldVariables) {
		fields = append(fields, alertruletemplate.FieldVariables)
	}
	if m.FieldCleared(alertruletemplate.FieldConditions) {
		fields = append(fields, alertruletemplate.FieldConditions)
	}
	if m.FieldCleared(alertruletemplate.FieldThrottle) {
		fields = append(fields, alertruletemplate.FieldThrottle)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AlertRuleTemplateMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AlertRuleTemplateMutation) ClearField(name string) error {
	switch name {
	case alertruletemplate.FieldVariables:
		m.ClearVariables()
		return nil
	case alertruletemplate.FieldConditions:
		m.ClearConditions()
		return nil
	case alertruletemplate.FieldThrottle:
		m.ClearThrottle()
		return nil
	}
	return fmt.Errorf("unknown AlertRuleTemplate nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AlertRuleTemplateMutation) ResetField(name string) error {
	switch name {
	case alertruletemplate.FieldName:
		m.ResetName()
		return nil
	case alertruletemplate.FieldDescription:
		m.ResetDescription()
		return nil
	case alertruletemplate.FieldCategory:
		m.ResetCategory()
		return nil
	case alertruletemplate.FieldEventType:
		m.ResetEventType()
		return nil
	case alertruletemplate.FieldSeverity:
		m.ResetSeverity()
		return nil
	case alertruletemplate.FieldVariables:
		m.ResetVariables()
		return nil
	case alertruletemplate.FieldConditions:
		m.ResetConditions()
		return nil
	case alertruletemplate.FieldThrottle:
		m.ResetThrottle()
		return nil
	case alertruletemplate.FieldChannels:
		m.ResetChannels()
		return nil
	case alertruletemplate.FieldIsBuiltIn:
		m.ResetIsBuiltIn()
		return nil
	case alertruletemplate.FieldVersion:
		m.ResetVersion()
		return nil
	case alertruletemplate.FieldUsageCount:
		m.ResetUsageCount()
		return nil
	case alertruletemplate.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case alertruletemplate.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown AlertRuleTemplate field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AlertRuleTemplateMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AlertRuleTemplateMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AlertRuleTemplateMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AlertRuleTemplateMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AlertRuleTemplateMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AlertRuleTemplateMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AlertRuleTemplateMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown AlertRuleTemplate unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AlertRuleTemplateMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown AlertRuleTemplate edge %s", name)
}

// AlertTemplateMutation represents an operation that mutates the AlertTemplate nodes in the graph.
type AlertTemplateMutation struct {
	config
	op               Op
	typ              string
	id               *string
	event_type       *string
	channel          *alerttemplate.Channel
	subject_template *string
	body_template    *string
	is_default       *bool
	created_at       *time.Time
	updated_at       *time.Time
	clearedFields    map[string]struct{}
	done             bool
	oldValue         func(context.Context) (*AlertTemplate, error)
	predicates       []predicate.AlertTemplate
}

var _ ent.Mutation = (*AlertTemplateMutation)(nil)

// alerttemplateOption allows management of the mutation configuration using functional options.
type alerttemplateOption func(*AlertTemplateMutation)

// newAlertTemplateMutation creates new mutation for the AlertTemplate entity.
func newAlertTemplateMutation(c config, op Op, opts ...alerttemplateOption) *AlertTemplateMutation {
	m := &AlertTemplateMutation{
		config:        c,
		op:            op,
		typ:           TypeAlertTemplate,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAlertTemplateID sets the ID field of the mutation.
func withAlertTemplateID(id string) alerttemplateOption {
	return func(m *AlertTemplateMutation) {
		var (
			err   error
			once  sync.Once
			value *AlertTemplate
		)
		m.oldValue = func(ctx context.Context) (*AlertTemplate, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AlertTemplate.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAlertTemplate sets the old AlertTemplate of the mutation.
func withAlertTemplate(node *AlertTemplate) alerttemplateOption {
	return func(m *AlertTemplateMutation) {
		m.oldValue = func(context.Context) (*AlertTemplate, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AlertTemplateMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AlertTemplateMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AlertTemplate entities.
func (m *AlertTemplateMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AlertTemplateMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AlertTemplateMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AlertTemplate.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetEventType sets the "event_type" field.
func (m *AlertTemplateMutation) SetEventType(s string) {
	m.event_type = &s
}

// EventType returns the value of the "event_type" field in the mutation.
func (m *AlertTemplateMutation) EventType() (r string, exists bool) {
	v := m.event_type
	if v == nil {
		return
	}
	return *v, true
}

// OldEventType returns the old "event_type" field's value of the AlertTemplate entity.
// If the AlertTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertTemplateMutation) OldEventType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEventType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEventType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEventType: %w", err)
	}
	return oldValue.EventType, nil
}

// ResetEventType resets all changes to the "event_type" field.
func (m *AlertTemplateMutation) ResetEventType() {
	m.event_type = nil
}

// SetChannel sets the "channel" field.
func (m *AlertTemplateMutation) SetChannel(a alerttemplate.Channel) {
	m.channel = &a
}

// Channel returns the value of the "channel" field in the mutation.
func (m *AlertTemplateMutation) Channel() (r alerttemplate.Channel, exists bool) {
	v := m.channel
	if v == nil {
		return
	}
	return *v, true
}

// OldChannel returns the old "channel" field's value of the AlertTemplate entity.
// If the AlertTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertTemplateMutation) OldChannel(ctx context.Context) (v alerttemplate.Channel, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChannel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChannel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChannel: %w", err)
	}
	return oldValue.Channel, nil
}

// ResetChannel resets all changes to the "channel" field.
func (m *AlertTemplateMutation) ResetChannel() {
	m.channel = nil
}

// SetSubjectTemplate sets the "subject_template" field.
func (m *AlertTemplateMutation) SetSubjectTemplate(s string) {
	m.subject_template = &s
}

// SubjectTemplate returns the value of the "subject_template" field in the mutation.
func (m *AlertTemplateMutation) SubjectTemplate() (r string, exists bool) {
	v := m.subject_template
	if v == nil {
		return
	}
	return *v, true
}

// OldSubjectTemplate returns the old "subject_template" field's value of the AlertTemplate entity.
// If the AlertTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertTemplateMutation) OldSubjectTemplate(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSubjectTemplate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSubjectTemplate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubjectTemplate: %w", err)
	}
	return oldValue.SubjectTemplate, nil
}

// ClearSubjectTemplate clears the value of the "subject_template" field.
func (m *AlertTemplateMutation) ClearSubjectTemplate() {
	m.subject_template = nil
	m.clearedFields[alerttemplate.FieldSubjectTemplate] = struct{}{}
}

// SubjectTemplateCleared returns if the "subject_template" field was cleared in this mutation.
func (m *AlertTemplateMutation) SubjectTemplateCleared() bool {
	_, ok := m.clearedFields[alerttemplate.FieldSubjectTemplate]
	return ok
}

// ResetSubjectTemplate resets all changes to the "subject_template" field.
func (m *AlertTemplateMutation) ResetSubjectTemplate() {
	m.subject_template = nil
	delete(m.clearedFields, alerttemplate.FieldSubjectTemplate)
}

// SetBodyTemplate sets the "body_template" field.
func (m *AlertTemplateMutation) SetBodyTemplate(s string) {
	m.body_template = &s
}

// BodyTemplate returns the value of the "body_template" field in the mutation.
func (m *AlertTemplateMutation) BodyTemplate() (r string, exists bool) {
	v := m.body_template
	if v == nil {
		return
	}
	return *v, true
}

// OldBodyTemplate returns the old "body_template" field's value of the AlertTemplate entity.
// If the AlertTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertTemplateMutation) OldBodyTemplate(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBodyTemplate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBodyTemplate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBodyTemplate: %w", err)
	}
	return oldValue.BodyTemplate, nil
}

// ResetBodyTemplate resets all changes to the "body_template" field.
func (m *AlertTemplateMutation) ResetBodyTemplate() {
	m.body_template = nil
}

// SetIsDefault sets the "is_default" field.
func (m *AlertTemplateMutation) SetIsDefault(b bool) {
	m.is_default = &b
}

// IsDefault returns the value of the "is_default" field in the mutation.
func (m *AlertTemplateMutation) IsDefault() (r bool, exists bool) {
	v := m.is_default
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDefault returns the old "is_default" field's value of the AlertTemplate entity.
// If the AlertTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertTemplateMutation) OldIsDefault(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsDefault is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsDefault requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDefault: %w", err)
	}
	return oldValue.IsDefault, nil
}

// ResetIsDefault resets all changes to the "is_default" field.
func (m *AlertTemplateMutation) ResetIsDefault() {
	m.is_default = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *AlertTemplateMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AlertTemplateMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the AlertTemplate entity.
// If the AlertTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertTemplateMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AlertTemplateMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AlertTemplateMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AlertTemplateMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the AlertTemplate entity.
// If the AlertTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertTemplateMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AlertTemplateMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// Where appends a list predicates to the AlertTemplateMutation builder.
func (m *AlertTemplateMutation) Where(ps ...predicate.AlertTemplate) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AlertTemplateMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AlertTemplateMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AlertTemplate, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AlertTemplateMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AlertTemplateMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AlertTemplate).
func (m *AlertTemplateMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AlertTemplateMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.event_type != nil {
		fields = append(fields, alerttemplate.FieldEventType)
	}
	if m.channel != nil {
		fields = append(fields, alerttemplate.FieldChannel)
	}
	if m.subject_template != nil {
		fields = append(fields, alerttemplate.FieldSubjectTemplate)
	}
	if m.body_template != nil {
		fields = append(fields, alerttemplate.FieldBodyTemplate)
	}
	if m.is_default != nil {
		fields = append(fields, alerttemplate.FieldIsDefault)
	}
	if m.created_at != nil {
		fields = append(fields, alerttemplate.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, alerttemplate.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AlertTemplateMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case alerttemplate.FieldEventType:
		return m.EventType()
	case alerttemplate.FieldChannel:
		return m.Channel()
	case alerttemplate.FieldSubjectTemplate:
		return m.SubjectTemplate()
	case alerttemplate.FieldBodyTemplate:
		return m.BodyTemplate()
	case alerttemplate.FieldIsDefault:
		return m.IsDefault()
	case alerttemplate.FieldCreatedAt:
		return m.CreatedAt()
	case alerttemplate.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AlertTemplateMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case alerttemplate.FieldEventType:
		return m.OldEventType(ctx)
	case alerttemplate.FieldChannel:
		return m.OldChannel(ctx)
	case alerttemplate.FieldSubjectTemplate:
		return m.OldSubjectTemplate(ctx)
	case alerttemplate.FieldBodyTemplate:
		return m.OldBodyTemplate(ctx)
	case alerttemplate.FieldIsDefault:
		return m.OldIsDefault(ctx)
	case alerttemplate.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case alerttemplate.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown AlertTemplate field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AlertTemplateMutation) SetField(name string, value ent.Value) error {
	switch name {
	case alerttemplate.FieldEventType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEventType(v)
		return nil
	case alerttemplate.FieldChannel:
		v, ok := value.(alerttemplate.Channel)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChannel(v)
		return nil
	case alerttemplate.FieldSubjectTemplate:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubjectTemplate(v)
		return nil
	case alerttemplate.FieldBodyTemplate:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBodyTemplate(v)
		return nil
	case alerttemplate.FieldIsDefault:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDefault(v)
		return nil
	case alerttemplate.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case alerttemplate.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown AlertTemplate field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AlertTemplateMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AlertTemplateMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AlertTemplateMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown AlertTemplate numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AlertTemplateMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(alerttemplate.FieldSubjectTemplate) {
		fields = append(fields, alerttemplate.FieldSubjectTemplate)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AlertTemplateMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AlertTemplateMutation) ClearField(name string) error {
	switch name {
	case alerttemplate.FieldSubjectTemplate:
		m.ClearSubjectTemplate()
		return nil
	}
	return fmt.Errorf("unknown AlertTemplate nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AlertTemplateMutation) ResetField(name string) error {
	switch name {
	case alerttemplate.FieldEventType:
		m.ResetEventType()
		return nil
	case alerttemplate.FieldChannel:
		m.ResetChannel()
		return nil
	case alerttemplate.FieldSubjectTemplate:
		m.ResetSubjectTemplate()
		return nil
	case alerttemplate.FieldBodyTemplate:
		m.ResetBodyTemplate()
		return nil
	case alerttemplate.FieldIsDefault:
		m.ResetIsDefault()
		return nil
	case alerttemplate.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case alerttemplate.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown AlertTemplate field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AlertTemplateMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AlertTemplateMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AlertTemplateMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AlertTemplateMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AlertTemplateMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AlertTemplateMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AlertTemplateMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown AlertTemplate unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AlertTemplateMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown AlertTemplate edge %s", name)
}

// ConfigSnapshotMutation represents an operation that mutates the ConfigSnapshot nodes in the graph.
type ConfigSnapshotMutation struct {
	config
	op              Op
	typ             string
	id              *string
	name            *string
	description     *string
	snapshot_type   *configsnapshot.SnapshotType
	configuration   *map[string]interface{}
	resource_counts *map[string]int
	ros_version     *string
	router_model    *string
	checksum        *string
	size_bytes      *int64
	addsize_bytes   *int64
	tags            *[]string
	appendtags      []string
	pinned          *bool
	created_by      *string
	created_at      *time.Time
	expires_at      *time.Time
	clearedFields   map[string]struct{}
	done            bool
	oldValue        func(context.Context) (*ConfigSnapshot, error)
	predicates      []predicate.ConfigSnapshot
}

var _ ent.Mutation = (*ConfigSnapshotMutation)(nil)

// configsnapshotOption allows management of the mutation configuration using functional options.
type configsnapshotOption func(*ConfigSnapshotMutation)

// newConfigSnapshotMutation creates new mutation for the ConfigSnapshot entity.
func newConfigSnapshotMutation(c config, op Op, opts ...configsnapshotOption) *ConfigSnapshotMutation {
	m := &ConfigSnapshotMutation{
		config:        c,
		op:            op,
		typ:           TypeConfigSnapshot,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withConfigSnapshotID sets the ID field of the mutation.
func withConfigSnapshotID(id string) configsnapshotOption {
	return func(m *ConfigSnapshotMutation) {
		var (
			err   error
			once  sync.Once
			value *ConfigSnapshot
		)
		m.oldValue = func(ctx context.Context) (*ConfigSnapshot, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ConfigSnapshot.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withConfigSnapshot sets the old ConfigSnapshot of the mutation.
func withConfigSnapshot(node *ConfigSnapshot) configsnapshotOption {
	return func(m *ConfigSnapshotMutation) {
		m.oldValue = func(context.Context) (*ConfigSnapshot, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ConfigSnapshotMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ConfigSnapshotMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ConfigSnapshot entities.
func (m *ConfigSnapshotMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ConfigSnapshotMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ConfigSnapshotMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ConfigSnapshot.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *ConfigSnapshotMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ConfigSnapshotMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the ConfigSnapshot entity.
// If the ConfigSnapshot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConfigSnapshotMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ConfigSnapshotMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *ConfigSnapshotMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ConfigSnapshotMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the ConfigSnapshot entity.
// If the ConfigSnapshot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConfigSnapshotMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *ConfigSnapshotMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[configsnapshot.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *ConfigSnapshotMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[configsnapshot.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *ConfigSnapshotMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, configsnapshot.FieldDescription)
}

// SetSnapshotType sets the "snapshot_type" field.
func (m *ConfigSnapshotMutation) SetSnapshotType(ct configsnapshot.SnapshotType) {
	m.snapshot_type = &ct
}

// SnapshotType returns the value of the "snapshot_type" field in the mutation.
func (m *ConfigSnapshotMutation) SnapshotType() (r configsnapshot.SnapshotType, exists bool) {
	v := m.snapshot_type
	if v == nil {
		return
	}
	return *v, true
}

// OldSnapshotType returns the old "snapshot_type" field's value of the ConfigSnapshot entity.
// If the ConfigSnapshot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConfigSnapshotMutation) OldSnapshotType(ctx context.Context) (v configsnapshot.SnapshotType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSnapshotType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSnapshotType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSnapshotType: %w", err)
	}
	return oldValue.SnapshotType, nil
}

// ResetSnapshotType resets all changes to the "snapshot_type" field.
func (m *ConfigSnapshotMutation) ResetSnapshotType() {
	m.snapshot_type = nil
}

// SetConfiguration sets the "configuration" field.
func (m *ConfigSnapshotMutation) SetConfiguration(value map[string]interface{}) {
	m.configuration = &value
}

// Configuration returns the value of the "configuration" field in the mutation.
func (m *ConfigSnapshotMutation) Configuration() (r map[string]interface{}, exists bool) {
	v := m.configuration
	if v == nil {
		return
	}
	return *v, true
}

// OldConfiguration returns the old "configuration" field's value of the ConfigSnapshot entity.
// If the ConfigSnapshot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConfigSnapshotMutation) OldConfiguration(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConfiguration is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConfiguration requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConfiguration: %w", err)
	}
	return oldValue.Configuration, nil
}

// ResetConfiguration resets all changes to the "configuration" field.
func (m *ConfigSnapshotMutation) ResetConfiguration() {
	m.configuration = nil
}

// SetResourceCounts sets the "resource_counts" field.
func (m *ConfigSnapshotMutation) SetResourceCounts(value map[string]int) {
	m.resource_counts = &value
}

// ResourceCounts returns the value of the "resource_counts" field in the mutation.
func (m *ConfigSnapshotMutation) ResourceCounts() (r map[string]int, exists bool) {
	v := m.resource_counts
	if v == nil {
		return
	}
	return *v, true
}

// OldResourceCounts returns the old "resource_counts" field's value of the ConfigSnapshot entity.
// If the ConfigSnapshot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConfigSnapshotMutation) OldResourceCounts(ctx context.Context) (v map[string]int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResourceCounts is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResourceCounts requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResourceCounts: %w", err)
	}
	return oldValue.ResourceCounts, nil
}

// ClearResourceCounts clears the value of the "resource_counts" field.
func (m *ConfigSnapshotMutation) ClearResourceCounts() {
	m.resource_counts = nil
	m.clearedFields[configsnapshot.FieldResourceCounts] = struct{}{}
}

// ResourceCountsCleared returns if the "resource_counts" field was cleared in this mutation.
func (m *ConfigSnapshotMutation) ResourceCountsCleared() bool {
	_, ok := m.clearedFields[configsnapshot.FieldResourceCounts]
	return ok
}

// ResetResourceCounts resets all changes to the "resource_counts" field.
func (m *ConfigSnapshotMutation) ResetResourceCounts() {
	m.resource_counts = nil
	delete(m.clearedFields, configsnapshot.FieldResourceCounts)
}

// SetRosVersion sets the "ros_version" field.
func (m *ConfigSnapshotMutation) SetRosVersion(s string) {
	m.ros_version = &s
}

// RosVersion returns the value of the "ros_version" field in the mutation.
func (m *ConfigSnapshotMutation) RosVersion() (r string, exists bool) {
	v := m.ros_version
	if v == nil {
		return
	}
	return *v, true
}

// OldRosVersion returns the old "ros_version" field's value of the ConfigSnapshot entity.
// If the ConfigSnapshot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConfigSnapshotMutation) OldRosVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRosVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRosVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRosVersion: %w", err)
	}
	return oldValue.RosVersion, nil
}

// ClearRosVersion clears the value of the "ros_version" field.
func (m *ConfigSnapshotMutation) ClearRosVersion() {
	m.ros_version = nil
	m.clearedFields[configsnapshot.FieldRosVersion] = struct{}{}
}

// RosVersionCleared returns if the "ros_version" field was cleared in this mutation.
func (m *ConfigSnapshotMutation) RosVersionCleared() bool {
	_, ok := m.clearedFields[configsnapshot.FieldRosVersion]
	return ok
}

// ResetRosVersion resets all changes to the "ros_version" field.
func (m *ConfigSnapshotMutation) ResetRosVersion() {
	m.ros_version = nil
	delete(m.clearedFields, configsnapshot.FieldRosVersion)
}

// SetRouterModel sets the "router_model" field.
func (m *ConfigSnapshotMutation) SetRouterModel(s string) {
	m.router_model = &s
}

// RouterModel returns the value of the "router_model" field in the mutation.
func (m *ConfigSnapshotMutation) RouterModel() (r string, exists bool) {
	v := m.router_model
	if v == nil {
		return
	}
	return *v, true
}

// OldRouterModel returns the old "router_model" field's value of the ConfigSnapshot entity.
// If the ConfigSnapshot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConfigSnapshotMutation) OldRouterModel(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRouterModel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRouterModel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRouterModel: %w", err)
	}
	return oldValue.RouterModel, nil
}

// ClearRouterModel clears the value of the "router_model" field.
func (m *ConfigSnapshotMutation) ClearRouterModel() {
	m.router_model = nil
	m.clearedFields[configsnapshot.FieldRouterModel] = struct{}{}
}

// RouterModelCleared returns if the "router_model" field was cleared in this mutation.
func (m *ConfigSnapshotMutation) RouterModelCleared() bool {
	_, ok := m.clearedFields[configsnapshot.FieldRouterModel]
	return ok
}

// ResetRouterModel resets all changes to the "router_model" field.
func (m *ConfigSnapshotMutation) ResetRouterModel() {
	m.router_model = nil
	delete(m.clearedFields, configsnapshot.FieldRouterModel)
}

// SetChecksum sets the "checksum" field.
func (m *ConfigSnapshotMutation) SetChecksum(s string) {
	m.checksum = &s
}

// Checksum returns the value of the "checksum" field in the mutation.
func (m *ConfigSnapshotMutation) Checksum() (r string, exists bool) {
	v := m.checksum
	if v == nil {
		return
	}
	return *v, true
}

// OldChecksum returns the old "checksum" field's value of the ConfigSnapshot entity.
// If the ConfigSnapshot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConfigSnapshotMutation) OldChecksum(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChecksum is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChecksum requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChecksum: %w", err)
	}
	return oldValue.Checksum, nil
}

// ClearChecksum clears the value of the "checksum" field.
func (m *ConfigSnapshotMutation) ClearChecksum() {
	m.checksum = nil
	m.clearedFields[configsnapshot.FieldChecksum] = struct{}{}
}

// ChecksumCleared returns if the "checksum" field was cleared in this mutation.
func (m *ConfigSnapshotMutation) ChecksumCleared() bool {
	_, ok := m.clearedFields[configsnapshot.FieldChecksum]
	return ok
}

// ResetChecksum resets all changes to the "checksum" field.
func (m *ConfigSnapshotMutation) ResetChecksum() {
	m.checksum = nil
	delete(m.clearedFields, configsnapshot.FieldChecksum)
}

// SetSizeBytes sets the "size_bytes" field.
func (m *ConfigSnapshotMutation) SetSizeBytes(i int64) {
	m.size_bytes = &i
	m.addsize_bytes = nil
}

// SizeBytes returns the value of the "size_bytes" field in the mutation.
func (m *ConfigSnapshotMutation) SizeBytes() (r int64, exists bool) {
	v := m.size_bytes
	if v == nil {
		return
	}
	return *v, true
}

// OldSizeBytes returns the old "size_bytes" field's value of the ConfigSnapshot entity.
// If the ConfigSnapshot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConfigSnapshotMutation) OldSizeBytes(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSizeBytes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSizeBytes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSizeBytes: %w", err)
	}
	return oldValue.SizeBytes, nil
}

// AddSizeBytes adds i to the "size_bytes" field.
func (m *ConfigSnapshotMutation) AddSizeBytes(i int64) {
	if m.addsize_bytes != nil {
		*m.addsize_bytes += i
	} else {
		m.addsize_bytes = &i
	}
}

// AddedSizeBytes returns the value that was added to the "size_bytes" field in this mutation.
func (m *ConfigSnapshotMutation) AddedSizeBytes() (r int64, exists bool) {
	v := m.addsize_bytes
	if v == nil {
		return
	}
	return *v, true
}

// ClearSizeBytes clears the value of the "size_bytes" field.
func (m *ConfigSnapshotMutation) ClearSizeBytes() {
	m.size_bytes = nil
	m.addsize_bytes = nil
	m.clearedFields[configsnapshot.FieldSizeBytes] = struct{}{}
}

// SizeBytesCleared returns if the "size_bytes" field was cleared in this mutation.
func (m *ConfigSnapshotMutation) SizeBytesCleared() bool {
	_, ok := m.clearedFields[configsnapshot.FieldSizeBytes]
	return ok
}

// ResetSizeBytes resets all changes to the "size_bytes" field.
func (m *ConfigSnapshotMutation) ResetSizeBytes() {
	m.size_bytes = nil
	m.addsize_bytes = nil
	delete(m.clearedFields, configsnapshot.FieldSizeBytes)
}

// SetTags sets the "tags" field.
func (m *ConfigSnapshotMutation) SetTags(s []string) {
	m.tags = &s
	m.appendtags = nil
}

// Tags returns the value of the "tags" field in the mutation.
func (m *ConfigSnapshotMutation) Tags() (r []string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the ConfigSnapshot entity.
// If the ConfigSnapshot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConfigSnapshotMutation) OldTags(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// AppendTags adds s to the "tags" field.
func (m *ConfigSnapshotMutation) AppendTags(s []string) {
	m.appendtags = append(m.appendtags, s...)
}

// AppendedTags returns the list of values that were appended to the "tags" field in this mutation.
func (m *ConfigSnapshotMutation) AppendedTags() ([]string, bool) {
	if len(m.appendtags) == 0 {
		return nil, false
	}
	return m.appendtags, true
}

// ClearTags clears the value of the "tags" field.
func (m *ConfigSnapshotMutation) ClearTags() {
	m.tags = nil
	m.appendtags = nil
	m.clearedFields[configsnapshot.FieldTags] = struct{}{}
}

// TagsCleared returns if the "tags" field was cleared in this mutation.
func (m *ConfigSnapshotMutation) TagsCleared() bool {
	_, ok := m.clearedFields[configsnapshot.FieldTags]
	return ok
}

// ResetTags resets all changes to the "tags" field.
func (m *ConfigSnapshotMutation) ResetTags() {
	m.tags = nil
	m.appendtags = nil
	delete(m.clearedFields, configsnapshot.FieldTags)
}

// SetPinned sets the "pinned" field.
func (m *ConfigSnapshotMutation) SetPinned(b bool) {
	m.pinned = &b
}

// Pinned returns the value of the "pinned" field in the mutation.
func (m *ConfigSnapshotMutation) Pinned() (r bool, exists bool) {
	v := m.pinned
	if v == nil {
		return
	}
	return *v, true
}

// OldPinned returns the old "pinned" field's value of the ConfigSnapshot entity.
// If the ConfigSnapshot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConfigSnapshotMutation) OldPinned(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPinned is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPinned requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPinned: %w", err)
	}
	return oldValue.Pinned, nil
}

// ResetPinned resets all changes to the "pinned" field.
func (m *ConfigSnapshotMutation) ResetPinned() {
	m.pinned = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *ConfigSnapshotMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *ConfigSnapshotMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the ConfigSnapshot entity.
// If the ConfigSnapshot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConfigSnapshotMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *ConfigSnapshotMutation) ResetCreatedBy() {
	m.created_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ConfigSnapshotMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ConfigSnapshotMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ConfigSnapshot entity.
// If the ConfigSnapshot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConfigSnapshotMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ConfigSnapshotMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetExpiresAt sets the "expires_at" field.
func (m *ConfigSnapshotMutation) SetExpiresAt(t time.Time) {
	m.expires_at = &t
}

// ExpiresAt returns the value of the "expires_at" field in the mutation.
func (m *ConfigSnapshotMutation) ExpiresAt() (r time.Time, exists bool) {
	v := m.expires_at
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiresAt returns the old "expires_at" field's value of the ConfigSnapshot entity.
// If the ConfigSnapshot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConfigSnapshotMutation) OldExpiresAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiresAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiresAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiresAt: %w", err)
	}
	return oldValue.ExpiresAt, nil
}

// ClearExpiresAt clears the value of the "expires_at" field.
func (m *ConfigSnapshotMutation) ClearExpiresAt() {
	m.expires_at = nil
	m.clearedFields[configsnapshot.FieldExpiresAt] = struct{}{}
}

// ExpiresAtCleared returns if the "expires_at" field was cleared in this mutation.
func (m *ConfigSnapshotMutation) ExpiresAtCleared() bool {
	_, ok := m.clearedFields[configsnapshot.FieldExpiresAt]
	return ok
}

// ResetExpiresAt resets all changes to the "expires_at" field.
func (m *ConfigSnapshotMutation) ResetExpiresAt() {
	m.expires_at = nil
	delete(m.clearedFields, configsnapshot.FieldExpiresAt)
}

// Where appends a list predicates to the ConfigSnapshotMutation builder.
func (m *ConfigSnapshotMutation) Where(ps ...predicate.ConfigSnapshot) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ConfigSnapshotMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ConfigSnapshotMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ConfigSnapshot, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ConfigSnapshotMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ConfigSnapshotMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ConfigSnapshot).
func (m *ConfigSnapshotMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ConfigSnapshotMutation) Fields() []string {
	fields := make([]string, 0, 14)
	if m.name != nil {
		fields = append(fields, configsnapshot.FieldName)
	}
	if m.description != nil {
		fields = append(fields, configsnapshot.FieldDescription)
	}
	if m.snapshot_type != nil {
		fields = append(fields, configsnapshot.FieldSnapshotType)
	}
	if m.configuration != nil {
		fields = append(fields, configsnapshot.FieldConfiguration)
	}
	if m.resource_counts != nil {
		fields = append(fields, configsnapshot.FieldResourceCounts)
	}
	if m.ros_version != nil {
		fields = append(fields, configsnapshot.FieldRosVersion)
	}
	if m.router_model != nil {
		fields = append(fields, configsnapshot.FieldRouterModel)
	}
	if m.checksum != nil {
		fields = append(fields, configsnapshot.FieldChecksum)
	}
	if m.size_bytes != nil {
		fields = append(fields, configsnapshot.FieldSizeBytes)
	}
	if m.tags != nil {
		fields = append(fields, configsnapshot.FieldTags)
	}
	if m.pinned != nil {
		fields = append(fields, configsnapshot.FieldPinned)
	}
	if m.created_by != nil {
		fields = append(fields, configsnapshot.FieldCreatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, configsnapshot.FieldCreatedAt)
	}
	if m.expires_at != nil {
		fields = append(fields, configsnapshot.FieldExpiresAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ConfigSnapshotMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case configsnapshot.FieldName:
		return m.Name()
	case configsnapshot.FieldDescription:
		return m.Description()
	case configsnapshot.FieldSnapshotType:
		return m.SnapshotType()
	case configsnapshot.FieldConfiguration:
		return m.Configuration()
	case configsnapshot.FieldResourceCounts:
		return m.ResourceCounts()
	case configsnapshot.FieldRosVersion:
		return m.RosVersion()
	case configsnapshot.FieldRouterModel:
		return m.RouterModel()
	case configsnapshot.FieldChecksum:
		return m.Checksum()
	case configsnapshot.FieldSizeBytes:
		return m.SizeBytes()
	case configsnapshot.FieldTags:
		return m.Tags()
	case configsnapshot.FieldPinned:
		return m.Pinned()
	case configsnapshot.FieldCreatedBy:
		return m.CreatedBy()
	case configsnapshot.FieldCreatedAt:
		return m.CreatedAt()
	case configsnapshot.FieldExpiresAt:
		return m.ExpiresAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ConfigSnapshotMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case configsnapshot.FieldName:
		return m.OldName(ctx)
	case configsnapshot.FieldDescription:
		return m.OldDescription(ctx)
	case configsnapshot.FieldSnapshotType:
		return m.OldSnapshotType(ctx)
	case configsnapshot.FieldConfiguration:
		return m.OldConfiguration(ctx)
	case configsnapshot.FieldResourceCounts:
		return m.OldResourceCounts(ctx)
	case configsnapshot.FieldRosVersion:
		return m.OldRosVersion(ctx)
	case configsnapshot.FieldRouterModel:
		return m.OldRouterModel(ctx)
	case configsnapshot.FieldChecksum:
		return m.OldChecksum(ctx)
	case configsnapshot.FieldSizeBytes:
		return m.OldSizeBytes(ctx)
	case configsnapshot.FieldTags:
		return m.OldTags(ctx)
	case configsnapshot.FieldPinned:
		return m.OldPinned(ctx)
	case configsnapshot.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case configsnapshot.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case configsnapshot.FieldExpiresAt:
		return m.OldExpiresAt(ctx)
	}
	return nil, fmt.Errorf("unknown ConfigSnapshot field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ConfigSnapshotMutation) SetField(name string, value ent.Value) error {
	switch name {
	case configsnapshot.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case configsnapshot.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case configsnapshot.FieldSnapshotType:
		v, ok := value.(configsnapshot.SnapshotType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSnapshotType(v)
		return nil
	case configsnapshot.FieldConfiguration:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConfiguration(v)
		return nil
	case configsnapshot.FieldResourceCounts:
		v, ok := value.(map[string]int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResourceCounts(v)
		return nil
	case configsnapshot.FieldRosVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRosVersion(v)
		return nil
	case configsnapshot.FieldRouterModel:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRouterModel(v)
		return nil
	case configsnapshot.FieldChecksum:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChecksum(v)
		return nil
	case configsnapshot.FieldSizeBytes:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSizeBytes(v)
		return nil
	case configsnapshot.FieldTags:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	case configsnapshot.FieldPinned:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPinned(v)
		return nil
	case configsnapshot.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case configsnapshot.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case configsnapshot.FieldExpiresAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiresAt(v)
		return nil
	}
	return fmt.Errorf("unknown ConfigSnapshot field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ConfigSnapshotMutation) AddedFields() []string {
	var fields []string
	if m.addsize_bytes != nil {
		fields = append(fields, configsnapshot.FieldSizeBytes)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ConfigSnapshotMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case configsnapshot.FieldSizeBytes:
		return m.AddedSizeBytes()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ConfigSnapshotMutation) AddField(name string, value ent.Value) error {
	switch name {
	case configsnapshot.FieldSizeBytes:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSizeBytes(v)
		return nil
	}
	return fmt.Errorf("unknown ConfigSnapshot numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ConfigSnapshotMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(configsnapshot.FieldDescription) {
		fields = append(fields, configsnapshot.FieldDescription)
	}
	if m.FieldCleared(configsnapshot.FieldResourceCounts) {
		fields = append(fields, configsnapshot.FieldResourceCounts)
	}
	if m.FieldCleared(configsnapshot.FieldRosVersion) {
		fields = append(fields, configsnapshot.FieldRosVersion)
	}
	if m.FieldCleared(configsnapshot.FieldRouterModel) {
		fields = append(fields, configsnapshot.FieldRouterModel)
	}
	if m.FieldCleared(configsnapshot.FieldChecksum) {
		fields = append(fields, configsnapshot.FieldChecksum)
	}
	if m.FieldCleared(configsnapshot.FieldSizeBytes) {
		fields = append(fields, configsnapshot.FieldSizeBytes)
	}
	if m.FieldCleared(configsnapshot.FieldTags) {
		fields = append(fields, configsnapshot.FieldTags)
	}
	if m.FieldCleared(configsnapshot.FieldExpiresAt) {
		fields = append(fields, configsnapshot.FieldExpiresAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ConfigSnapshotMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ConfigSnapshotMutation) ClearField(name string) error {
	switch name {
	case configsnapshot.FieldDescription:
		m.ClearDescription()
		return nil
	case configsnapshot.FieldResourceCounts:
		m.ClearResourceCounts()
		return nil
	case configsnapshot.FieldRosVersion:
		m.ClearRosVersion()
		return nil
	case configsnapshot.FieldRouterModel:
		m.ClearRouterModel()
		return nil
	case configsnapshot.FieldChecksum:
		m.ClearChecksum()
		return nil
	case configsnapshot.FieldSizeBytes:
		m.ClearSizeBytes()
		return nil
	case configsnapshot.FieldTags:
		m.ClearTags()
		return nil
	case configsnapshot.FieldExpiresAt:
		m.ClearExpiresAt()
		return nil
	}
	return fmt.Errorf("unknown ConfigSnapshot nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ConfigSnapshotMutation) ResetField(name string) error {
	switch name {
	case configsnapshot.FieldName:
		m.ResetName()
		return nil
	case configsnapshot.FieldDescription:
		m.ResetDescription()
		return nil
	case configsnapshot.FieldSnapshotType:
		m.ResetSnapshotType()
		return nil
	case configsnapshot.FieldConfiguration:
		m.ResetConfiguration()
		return nil
	case configsnapshot.FieldResourceCounts:
		m.ResetResourceCounts()
		return nil
	case configsnapshot.FieldRosVersion:
		m.ResetRosVersion()
		return nil
	case configsnapshot.FieldRouterModel:
		m.ResetRouterModel()
		return nil
	case configsnapshot.FieldChecksum:
		m.ResetChecksum()
		return nil
	case configsnapshot.FieldSizeBytes:
		m.ResetSizeBytes()
		return nil
	case configsnapshot.FieldTags:
		m.ResetTags()
		return nil
	case configsnapshot.FieldPinned:
		m.ResetPinned()
		return nil
	case configsnapshot.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case configsnapshot.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case configsnapshot.FieldExpiresAt:
		m.ResetExpiresAt()
		return nil
	}
	return fmt.Errorf("unknown ConfigSnapshot field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ConfigSnapshotMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ConfigSnapshotMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ConfigSnapshotMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ConfigSnapshotMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ConfigSnapshotMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ConfigSnapshotMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ConfigSnapshotMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown ConfigSnapshot unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ConfigSnapshotMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown ConfigSnapshot edge %s", name)
}

// GlobalSettingsMutation represents an operation that mutates the GlobalSettings nodes in the graph.
type GlobalSettingsMutation struct {
	config
	op               Op
	typ              string
	id               *string
	namespace        *string
	key              *string
	value            *map[string]interface{}
	value_type       *globalsettings.ValueType
	description      *string
	editable         *bool
	requires_restart *bool
	sensitive        *bool
	created_at       *time.Time
	updated_at       *time.Time
	clearedFields    map[string]struct{}
	done             bool
	oldValue         func(context.Context) (*GlobalSettings, error)
	predicates       []predicate.GlobalSettings
}

var _ ent.Mutation = (*GlobalSettingsMutation)(nil)

// globalsettingsOption allows management of the mutation configuration using functional options.
type globalsettingsOption func(*GlobalSettingsMutation)

// newGlobalSettingsMutation creates new mutation for the GlobalSettings entity.
func newGlobalSettingsMutation(c config, op Op, opts ...globalsettingsOption) *GlobalSettingsMutation {
	m := &GlobalSettingsMutation{
		config:        c,
		op:            op,
		typ:           TypeGlobalSettings,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withGlobalSettingsID sets the ID field of the mutation.
func withGlobalSettingsID(id string) globalsettingsOption {
	return func(m *GlobalSettingsMutation) {
		var (
			err   error
			once  sync.Once
			value *GlobalSettings
		)
		m.oldValue = func(ctx context.Context) (*GlobalSettings, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().GlobalSettings.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withGlobalSettings sets the old GlobalSettings of the mutation.
func withGlobalSettings(node *GlobalSettings) globalsettingsOption {
	return func(m *GlobalSettingsMutation) {
		m.oldValue = func(context.Context) (*GlobalSettings, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m GlobalSettingsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m GlobalSettingsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of GlobalSettings entities.
func (m *GlobalSettingsMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *GlobalSettingsMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *GlobalSettingsMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().GlobalSettings.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetNamespace sets the "namespace" field.
func (m *GlobalSettingsMutation) SetNamespace(s string) {
	m.namespace = &s
}

// Namespace returns the value of the "namespace" field in the mutation.
func (m *GlobalSettingsMutation) Namespace() (r string, exists bool) {
	v := m.namespace
	if v == nil {
		return
	}
	return *v, true
}

// OldNamespace returns the old "namespace" field's value of the GlobalSettings entity.
// If the GlobalSettings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GlobalSettingsMutation) OldNamespace(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNamespace is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNamespace requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNamespace: %w", err)
	}
	return oldValue.Namespace, nil
}

// ResetNamespace resets all changes to the "namespace" field.
func (m *GlobalSettingsMutation) ResetNamespace() {
	m.namespace = nil
}

// SetKey sets the "key" field.
func (m *GlobalSettingsMutation) SetKey(s string) {
	m.key = &s
}

// Key returns the value of the "key" field in the mutation.
func (m *GlobalSettingsMutation) Key() (r string, exists bool) {
	v := m.key
	if v == nil {
		return
	}
	return *v, true
}

// OldKey returns the old "key" field's value of the GlobalSettings entity.
// If the GlobalSettings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GlobalSettingsMutation) OldKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKey: %w", err)
	}
	return oldValue.Key, nil
}

// ResetKey resets all changes to the "key" field.
func (m *GlobalSettingsMutation) ResetKey() {
	m.key = nil
}

// SetValue sets the "value" field.
func (m *GlobalSettingsMutation) SetValue(value map[string]interface{}) {
	m.value = &value
}

// Value returns the value of the "value" field in the mutation.
func (m *GlobalSettingsMutation) Value() (r map[string]interface{}, exists bool) {
	v := m.value
	if v == nil {
		return
	}
	return *v, true
}

// OldValue returns the old "value" field's value of the GlobalSettings entity.
// If the GlobalSettings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GlobalSettingsMutation) OldValue(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValue: %w", err)
	}
	return oldValue.Value, nil
}

// ResetValue resets all changes to the "value" field.
func (m *GlobalSettingsMutation) ResetValue() {
	m.value = nil
}

// SetValueType sets the "value_type" field.
func (m *GlobalSettingsMutation) SetValueType(gt globalsettings.ValueType) {
	m.value_type = &gt
}

// ValueType returns the value of the "value_type" field in the mutation.
func (m *GlobalSettingsMutation) ValueType() (r globalsettings.ValueType, exists bool) {
	v := m.value_type
	if v == nil {
		return
	}
	return *v, true
}

// OldValueType returns the old "value_type" field's value of the GlobalSettings entity.
// If the GlobalSettings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GlobalSettingsMutation) OldValueType(ctx context.Context) (v globalsettings.ValueType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValueType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValueType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValueType: %w", err)
	}
	return oldValue.ValueType, nil
}

// ResetValueType resets all changes to the "value_type" field.
func (m *GlobalSettingsMutation) ResetValueType() {
	m.value_type = nil
}

// SetDescription sets the "description" field.
func (m *GlobalSettingsMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *GlobalSettingsMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the GlobalSettings entity.
// If the GlobalSettings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GlobalSettingsMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *GlobalSettingsMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[globalsettings.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *GlobalSettingsMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[globalsettings.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *GlobalSettingsMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, globalsettings.FieldDescription)
}

// SetEditable sets the "editable" field.
func (m *GlobalSettingsMutation) SetEditable(b bool) {
	m.editable = &b
}

// Editable returns the value of the "editable" field in the mutation.
func (m *GlobalSettingsMutation) Editable() (r bool, exists bool) {
	v := m.editable
	if v == nil {
		return
	}
	return *v, true
}

// OldEditable returns the old "editable" field's value of the GlobalSettings entity.
// If the GlobalSettings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GlobalSettingsMutation) OldEditable(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEditable is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEditable requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEditable: %w", err)
	}
	return oldValue.Editable, nil
}

// ResetEditable resets all changes to the "editable" field.
func (m *GlobalSettingsMutation) ResetEditable() {
	m.editable = nil
}

// SetRequiresRestart sets the "requires_restart" field.
func (m *GlobalSettingsMutation) SetRequiresRestart(b bool) {
	m.requires_restart = &b
}

// RequiresRestart returns the value of the "requires_restart" field in the mutation.
func (m *GlobalSettingsMutation) RequiresRestart() (r bool, exists bool) {
	v := m.requires_restart
	if v == nil {
		return
	}
	return *v, true
}

// OldRequiresRestart returns the old "requires_restart" field's value of the GlobalSettings entity.
// If the GlobalSettings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GlobalSettingsMutation) OldRequiresRestart(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRequiresRestart is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRequiresRestart requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRequiresRestart: %w", err)
	}
	return oldValue.RequiresRestart, nil
}

// ResetRequiresRestart resets all changes to the "requires_restart" field.
func (m *GlobalSettingsMutation) ResetRequiresRestart() {
	m.requires_restart = nil
}

// SetSensitive sets the "sensitive" field.
func (m *GlobalSettingsMutation) SetSensitive(b bool) {
	m.sensitive = &b
}

// Sensitive returns the value of the "sensitive" field in the mutation.
func (m *GlobalSettingsMutation) Sensitive() (r bool, exists bool) {
	v := m.sensitive
	if v == nil {
		return
	}
	return *v, true
}

// OldSensitive returns the old "sensitive" field's value of the GlobalSettings entity.
// If the GlobalSettings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GlobalSettingsMutation) OldSensitive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSensitive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSensitive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSensitive: %w", err)
	}
	return oldValue.Sensitive, nil
}

// ResetSensitive resets all changes to the "sensitive" field.
func (m *GlobalSettingsMutation) ResetSensitive() {
	m.sensitive = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *GlobalSettingsMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *GlobalSettingsMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the GlobalSettings entity.
// If the GlobalSettings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GlobalSettingsMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *GlobalSettingsMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *GlobalSettingsMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *GlobalSettingsMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the GlobalSettings entity.
// If the GlobalSettings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GlobalSettingsMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *GlobalSettingsMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// Where appends a list predicates to the GlobalSettingsMutation builder.
func (m *GlobalSettingsMutation) Where(ps ...predicate.GlobalSettings) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the GlobalSettingsMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *GlobalSettingsMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.GlobalSettings, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *GlobalSettingsMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *GlobalSettingsMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (GlobalSettings).
func (m *GlobalSettingsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *GlobalSettingsMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.namespace != nil {
		fields = append(fields, globalsettings.FieldNamespace)
	}
	if m.key != nil {
		fields = append(fields, globalsettings.FieldKey)
	}
	if m.value != nil {
		fields = append(fields, globalsettings.FieldValue)
	}
	if m.value_type != nil {
		fields = append(fields, globalsettings.FieldValueType)
	}
	if m.description != nil {
		fields = append(fields, globalsettings.FieldDescription)
	}
	if m.editable != nil {
		fields = append(fields, globalsettings.FieldEditable)
	}
	if m.requires_restart != nil {
		fields = append(fields, globalsettings.FieldRequiresRestart)
	}
	if m.sensitive != nil {
		fields = append(fields, globalsettings.FieldSensitive)
	}
	if m.created_at != nil {
		fields = append(fields, globalsettings.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, globalsettings.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *GlobalSettingsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case globalsettings.FieldNamespace:
		return m.Namespace()
	case globalsettings.FieldKey:
		return m.Key()
	case globalsettings.FieldValue:
		return m.Value()
	case globalsettings.FieldValueType:
		return m.ValueType()
	case globalsettings.FieldDescription:
		return m.Description()
	case globalsettings.FieldEditable:
		return m.Editable()
	case globalsettings.FieldRequiresRestart:
		return m.RequiresRestart()
	case globalsettings.FieldSensitive:
		return m.Sensitive()
	case globalsettings.FieldCreatedAt:
		return m.CreatedAt()
	case globalsettings.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *GlobalSettingsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case globalsettings.FieldNamespace:
		return m.OldNamespace(ctx)
	case globalsettings.FieldKey:
		return m.OldKey(ctx)
	case globalsettings.FieldValue:
		return m.OldValue(ctx)
	case globalsettings.FieldValueType:
		return m.OldValueType(ctx)
	case globalsettings.FieldDescription:
		return m.OldDescription(ctx)
	case globalsettings.FieldEditable:
		return m.OldEditable(ctx)
	case globalsettings.FieldRequiresRestart:
		return m.OldRequiresRestart(ctx)
	case globalsettings.FieldSensitive:
		return m.OldSensitive(ctx)
	case globalsettings.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case globalsettings.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown GlobalSettings field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GlobalSettingsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case globalsettings.FieldNamespace:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNamespace(v)
		return nil
	case globalsettings.FieldKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKey(v)
		return nil
	case globalsettings.FieldValue:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValue(v)
		return nil
	case globalsettings.FieldValueType:
		v, ok := value.(globalsettings.ValueType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValueType(v)
		return nil
	case globalsettings.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case globalsettings.FieldEditable:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEditable(v)
		return nil
	case globalsettings.FieldRequiresRestart:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRequiresRestart(v)
		return nil
	case globalsettings.FieldSensitive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSensitive(v)
		return nil
	case globalsettings.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case globalsettings.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown GlobalSettings field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *GlobalSettingsMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *GlobalSettingsMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GlobalSettingsMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown GlobalSettings numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *GlobalSettingsMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(globalsettings.FieldDescription) {
		fields = append(fields, globalsettings.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *GlobalSettingsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *GlobalSettingsMutation) ClearField(name string) error {
	switch name {
	case globalsettings.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown GlobalSettings nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *GlobalSettingsMutation) ResetField(name string) error {
	switch name {
	case globalsettings.FieldNamespace:
		m.ResetNamespace()
		return nil
	case globalsettings.FieldKey:
		m.ResetKey()
		return nil
	case globalsettings.FieldValue:
		m.ResetValue()
		return nil
	case globalsettings.FieldValueType:
		m.ResetValueType()
		return nil
	case globalsettings.FieldDescription:
		m.ResetDescription()
		return nil
	case globalsettings.FieldEditable:
		m.ResetEditable()
		return nil
	case globalsettings.FieldRequiresRestart:
		m.ResetRequiresRestart()
		return nil
	case globalsettings.FieldSensitive:
		m.ResetSensitive()
		return nil
	case globalsettings.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case globalsettings.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown GlobalSettings field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *GlobalSettingsMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *GlobalSettingsMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *GlobalSettingsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *GlobalSettingsMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *GlobalSettingsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *GlobalSettingsMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *GlobalSettingsMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown GlobalSettings unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *GlobalSettingsMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown GlobalSettings edge %s", name)
}

// NotificationChannelConfigMutation represents an operation that mutates the NotificationChannelConfig nodes in the graph.
type NotificationChannelConfigMutation struct {
	config
	op                Op
	typ               string
	id                *string
	create_time       *time.Time
	update_time       *time.Time
	channel_type      *notificationchannelconfig.ChannelType
	name              *string
	description       *string
	enabled           *bool
	is_default        *bool
	config_encrypted  *[]byte
	encryption_key_id *string
	created_by        *string
	updated_by        *string
	deleted_at        *time.Time
	clearedFields     map[string]struct{}
	done              bool
	oldValue          func(context.Context) (*NotificationChannelConfig, error)
	predicates        []predicate.NotificationChannelConfig
}

var _ ent.Mutation = (*NotificationChannelConfigMutation)(nil)

// notificationchannelconfigOption allows management of the mutation configuration using functional options.
type notificationchannelconfigOption func(*NotificationChannelConfigMutation)

// newNotificationChannelConfigMutation creates new mutation for the NotificationChannelConfig entity.
func newNotificationChannelConfigMutation(c config, op Op, opts ...notificationchannelconfigOption) *NotificationChannelConfigMutation {
	m := &NotificationChannelConfigMutation{
		config:        c,
		op:            op,
		typ:           TypeNotificationChannelConfig,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withNotificationChannelConfigID sets the ID field of the mutation.
func withNotificationChannelConfigID(id string) notificationchannelconfigOption {
	return func(m *NotificationChannelConfigMutation) {
		var (
			err   error
			once  sync.Once
			value *NotificationChannelConfig
		)
		m.oldValue = func(ctx context.Context) (*NotificationChannelConfig, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().NotificationChannelConfig.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withNotificationChannelConfig sets the old NotificationChannelConfig of the mutation.
func withNotificationChannelConfig(node *NotificationChannelConfig) notificationchannelconfigOption {
	return func(m *NotificationChannelConfigMutation) {
		m.oldValue = func(context.Context) (*NotificationChannelConfig, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m NotificationChannelConfigMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m NotificationChannelConfigMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of NotificationChannelConfig entities.
func (m *NotificationChannelConfigMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *NotificationChannelConfigMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *NotificationChannelConfigMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().NotificationChannelConfig.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *NotificationChannelConfigMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *NotificationChannelConfigMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the NotificationChannelConfig entity.
// If the NotificationChannelConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationChannelConfigMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *NotificationChannelConfigMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *NotificationChannelConfigMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *NotificationChannelConfigMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the NotificationChannelConfig entity.
// If the NotificationChannelConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationChannelConfigMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *NotificationChannelConfigMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetChannelType sets the "channel_type" field.
func (m *NotificationChannelConfigMutation) SetChannelType(nt notificationchannelconfig.ChannelType) {
	m.channel_type = &nt
}

// ChannelType returns the value of the "channel_type" field in the mutation.
func (m *NotificationChannelConfigMutation) ChannelType() (r notificationchannelconfig.ChannelType, exists bool) {
	v := m.channel_type
	if v == nil {
		return
	}
	return *v, true
}

// OldChannelType returns the old "channel_type" field's value of the NotificationChannelConfig entity.
// If the NotificationChannelConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationChannelConfigMutation) OldChannelType(ctx context.Context) (v notificationchannelconfig.ChannelType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChannelType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChannelType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChannelType: %w", err)
	}
	return oldValue.ChannelType, nil
}

// ResetChannelType resets all changes to the "channel_type" field.
func (m *NotificationChannelConfigMutation) ResetChannelType() {
	m.channel_type = nil
}

// SetName sets the "name" field.
func (m *NotificationChannelConfigMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *NotificationChannelConfigMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the NotificationChannelConfig entity.
// If the NotificationChannelConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationChannelConfigMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *NotificationChannelConfigMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *NotificationChannelConfigMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *NotificationChannelConfigMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the NotificationChannelConfig entity.
// If the NotificationChannelConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationChannelConfigMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *NotificationChannelConfigMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[notificationchannelconfig.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *NotificationChannelConfigMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[notificationchannelconfig.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *NotificationChannelConfigMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, notificationchannelconfig.FieldDescription)
}

// SetEnabled sets the "enabled" field.
func (m *NotificationChannelConfigMutation) SetEnabled(b bool) {
	m.enabled = &b
}

// Enabled returns the value of the "enabled" field in the mutation.
func (m *NotificationChannelConfigMutation) Enabled() (r bool, exists bool) {
	v := m.enabled
	if v == nil {
		return
	}
	return *v, true
}

// OldEnabled returns the old "enabled" field's value of the NotificationChannelConfig entity.
// If the NotificationChannelConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationChannelConfigMutation) OldEnabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnabled: %w", err)
	}
	return oldValue.Enabled, nil
}

// ResetEnabled resets all changes to the "enabled" field.
func (m *NotificationChannelConfigMutation) ResetEnabled() {
	m.enabled = nil
}

// SetIsDefault sets the "is_default" field.
func (m *NotificationChannelConfigMutation) SetIsDefault(b bool) {
	m.is_default = &b
}

// IsDefault returns the value of the "is_default" field in the mutation.
func (m *NotificationChannelConfigMutation) IsDefault() (r bool, exists bool) {
	v := m.is_default
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDefault returns the old "is_default" field's value of the NotificationChannelConfig entity.
// If the NotificationChannelConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationChannelConfigMutation) OldIsDefault(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsDefault is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsDefault requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDefault: %w", err)
	}
	return oldValue.IsDefault, nil
}

// ResetIsDefault resets all changes to the "is_default" field.
func (m *NotificationChannelConfigMutation) ResetIsDefault() {
	m.is_default = nil
}

// SetConfigEncrypted sets the "config_encrypted" field.
func (m *NotificationChannelConfigMutation) SetConfigEncrypted(b []byte) {
	m.config_encrypted = &b
}

// ConfigEncrypted returns the value of the "config_encrypted" field in the mutation.
func (m *NotificationChannelConfigMutation) ConfigEncrypted() (r []byte, exists bool) {
	v := m.config_encrypted
	if v == nil {
		return
	}
	return *v, true
}

// OldConfigEncrypted returns the old "config_encrypted" field's value of the NotificationChannelConfig entity.
// If the NotificationChannelConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationChannelConfigMutation) OldConfigEncrypted(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConfigEncrypted is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConfigEncrypted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConfigEncrypted: %w", err)
	}
	return oldValue.ConfigEncrypted, nil
}

// ResetConfigEncrypted resets all changes to the "config_encrypted" field.
func (m *NotificationChannelConfigMutation) ResetConfigEncrypted() {
	m.config_encrypted = nil
}

// SetEncryptionKeyID sets the "encryption_key_id" field.
func (m *NotificationChannelConfigMutation) SetEncryptionKeyID(s string) {
	m.encryption_key_id = &s
}

// EncryptionKeyID returns the value of the "encryption_key_id" field in the mutation.
func (m *NotificationChannelConfigMutation) EncryptionKeyID() (r string, exists bool) {
	v := m.encryption_key_id
	if v == nil {
		return
	}
	return *v, true
}

// OldEncryptionKeyID returns the old "encryption_key_id" field's value of the NotificationChannelConfig entity.
// If the NotificationChannelConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationChannelConfigMutation) OldEncryptionKeyID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEncryptionKeyID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEncryptionKeyID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEncryptionKeyID: %w", err)
	}
	return oldValue.EncryptionKeyID, nil
}

// ResetEncryptionKeyID resets all changes to the "encryption_key_id" field.
func (m *NotificationChannelConfigMutation) ResetEncryptionKeyID() {
	m.encryption_key_id = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *NotificationChannelConfigMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *NotificationChannelConfigMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the NotificationChannelConfig entity.
// If the NotificationChannelConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationChannelConfigMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *NotificationChannelConfigMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[notificationchannelconfig.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *NotificationChannelConfigMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[notificationchannelconfig.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *NotificationChannelConfigMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, notificationchannelconfig.FieldCreatedBy)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *NotificationChannelConfigMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *NotificationChannelConfigMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the NotificationChannelConfig entity.
// If the NotificationChannelConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationChannelConfigMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *NotificationChannelConfigMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[notificationchannelconfig.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *NotificationChannelConfigMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[notificationchannelconfig.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *NotificationChannelConfigMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, notificationchannelconfig.FieldUpdatedBy)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *NotificationChannelConfigMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *NotificationChannelConfigMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the NotificationChannelConfig entity.
// If the NotificationChannelConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationChannelConfigMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *NotificationChannelConfigMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[notificationchannelconfig.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *NotificationChannelConfigMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[notificationchannelconfig.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *NotificationChannelConfigMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, notificationchannelconfig.FieldDeletedAt)
}

// Where appends a list predicates to the NotificationChannelConfigMutation builder.
func (m *NotificationChannelConfigMutation) Where(ps ...predicate.NotificationChannelConfig) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the NotificationChannelConfigMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *NotificationChannelConfigMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.NotificationChannelConfig, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *NotificationChannelConfigMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *NotificationChannelConfigMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (NotificationChannelConfig).
func (m *NotificationChannelConfigMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *NotificationChannelConfigMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.create_time != nil {
		fields = append(fields, notificationchannelconfig.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, notificationchannelconfig.FieldUpdateTime)
	}
	if m.channel_type != nil {
		fields = append(fields, notificationchannelconfig.FieldChannelType)
	}
	if m.name != nil {
		fields = append(fields, notificationchannelconfig.FieldName)
	}
	if m.description != nil {
		fields = append(fields, notificationchannelconfig.FieldDescription)
	}
	if m.enabled != nil {
		fields = append(fields, notificationchannelconfig.FieldEnabled)
	}
	if m.is_default != nil {
		fields = append(fields, notificationchannelconfig.FieldIsDefault)
	}
	if m.config_encrypted != nil {
		fields = append(fields, notificationchannelconfig.FieldConfigEncrypted)
	}
	if m.encryption_key_id != nil {
		fields = append(fields, notificationchannelconfig.FieldEncryptionKeyID)
	}
	if m.created_by != nil {
		fields = append(fields, notificationchannelconfig.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, notificationchannelconfig.FieldUpdatedBy)
	}
	if m.deleted_at != nil {
		fields = append(fields, notificationchannelconfig.FieldDeletedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *NotificationChannelConfigMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case notificationchannelconfig.FieldCreateTime:
		return m.CreateTime()
	case notificationchannelconfig.FieldUpdateTime:
		return m.UpdateTime()
	case notificationchannelconfig.FieldChannelType:
		return m.ChannelType()
	case notificationchannelconfig.FieldName:
		return m.Name()
	case notificationchannelconfig.FieldDescription:
		return m.Description()
	case notificationchannelconfig.FieldEnabled:
		return m.Enabled()
	case notificationchannelconfig.FieldIsDefault:
		return m.IsDefault()
	case notificationchannelconfig.FieldConfigEncrypted:
		return m.ConfigEncrypted()
	case notificationchannelconfig.FieldEncryptionKeyID:
		return m.EncryptionKeyID()
	case notificationchannelconfig.FieldCreatedBy:
		return m.CreatedBy()
	case notificationchannelconfig.FieldUpdatedBy:
		return m.UpdatedBy()
	case notificationchannelconfig.FieldDeletedAt:
		return m.DeletedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *NotificationChannelConfigMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case notificationchannelconfig.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case notificationchannelconfig.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case notificationchannelconfig.FieldChannelType:
		return m.OldChannelType(ctx)
	case notificationchannelconfig.FieldName:
		return m.OldName(ctx)
	case notificationchannelconfig.FieldDescription:
		return m.OldDescription(ctx)
	case notificationchannelconfig.FieldEnabled:
		return m.OldEnabled(ctx)
	case notificationchannelconfig.FieldIsDefault:
		return m.OldIsDefault(ctx)
	case notificationchannelconfig.FieldConfigEncrypted:
		return m.OldConfigEncrypted(ctx)
	case notificationchannelconfig.FieldEncryptionKeyID:
		return m.OldEncryptionKeyID(ctx)
	case notificationchannelconfig.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case notificationchannelconfig.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case notificationchannelconfig.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	}
	return nil, fmt.Errorf("unknown NotificationChannelConfig field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NotificationChannelConfigMutation) SetField(name string, value ent.Value) error {
	switch name {
	case notificationchannelconfig.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case notificationchannelconfig.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case notificationchannelconfig.FieldChannelType:
		v, ok := value.(notificationchannelconfig.ChannelType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChannelType(v)
		return nil
	case notificationchannelconfig.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case notificationchannelconfig.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case notificationchannelconfig.FieldEnabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnabled(v)
		return nil
	case notificationchannelconfig.FieldIsDefault:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDefault(v)
		return nil
	case notificationchannelconfig.FieldConfigEncrypted:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConfigEncrypted(v)
		return nil
	case notificationchannelconfig.FieldEncryptionKeyID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEncryptionKeyID(v)
		return nil
	case notificationchannelconfig.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case notificationchannelconfig.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case notificationchannelconfig.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown NotificationChannelConfig field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *NotificationChannelConfigMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *NotificationChannelConfigMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NotificationChannelConfigMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown NotificationChannelConfig numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *NotificationChannelConfigMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(notificationchannelconfig.FieldDescription) {
		fields = append(fields, notificationchannelconfig.FieldDescription)
	}
	if m.FieldCleared(notificationchannelconfig.FieldCreatedBy) {
		fields = append(fields, notificationchannelconfig.FieldCreatedBy)
	}
	if m.FieldCleared(notificationchannelconfig.FieldUpdatedBy) {
		fields = append(fields, notificationchannelconfig.FieldUpdatedBy)
	}
	if m.FieldCleared(notificationchannelconfig.FieldDeletedAt) {
		fields = append(fields, notificationchannelconfig.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *NotificationChannelConfigMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *NotificationChannelConfigMutation) ClearField(name string) error {
	switch name {
	case notificationchannelconfig.FieldDescription:
		m.ClearDescription()
		return nil
	case notificationchannelconfig.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case notificationchannelconfig.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case notificationchannelconfig.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown NotificationChannelConfig nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *NotificationChannelConfigMutation) ResetField(name string) error {
	switch name {
	case notificationchannelconfig.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case notificationchannelconfig.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case notificationchannelconfig.FieldChannelType:
		m.ResetChannelType()
		return nil
	case notificationchannelconfig.FieldName:
		m.ResetName()
		return nil
	case notificationchannelconfig.FieldDescription:
		m.ResetDescription()
		return nil
	case notificationchannelconfig.FieldEnabled:
		m.ResetEnabled()
		return nil
	case notificationchannelconfig.FieldIsDefault:
		m.ResetIsDefault()
		return nil
	case notificationchannelconfig.FieldConfigEncrypted:
		m.ResetConfigEncrypted()
		return nil
	case notificationchannelconfig.FieldEncryptionKeyID:
		m.ResetEncryptionKeyID()
		return nil
	case notificationchannelconfig.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case notificationchannelconfig.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case notificationchannelconfig.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown NotificationChannelConfig field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *NotificationChannelConfigMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *NotificationChannelConfigMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *NotificationChannelConfigMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *NotificationChannelConfigMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *NotificationChannelConfigMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *NotificationChannelConfigMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *NotificationChannelConfigMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown NotificationChannelConfig unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *NotificationChannelConfigMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown NotificationChannelConfig edge %s", name)
}

// NotificationLogMutation represents an operation that mutates the NotificationLog nodes in the graph.
type NotificationLogMutation struct {
	config
	op                Op
	typ               string
	id                *string
	channel           *notificationlog.Channel
	status            *notificationlog.Status
	attempt_number    *int
	addattempt_number *int
	response_code     *int
	addresponse_code  *int
	response_body     *string
	error_message     *string
	request_metadata  *map[string]interface{}
	created_at        *time.Time
	completed_at      *time.Time
	clearedFields     map[string]struct{}
	alert             *string
	clearedalert      bool
	webhook           *string
	clearedwebhook    bool
	done              bool
	oldValue          func(context.Context) (*NotificationLog, error)
	predicates        []predicate.NotificationLog
}

var _ ent.Mutation = (*NotificationLogMutation)(nil)

// notificationlogOption allows management of the mutation configuration using functional options.
type notificationlogOption func(*NotificationLogMutation)

// newNotificationLogMutation creates new mutation for the NotificationLog entity.
func newNotificationLogMutation(c config, op Op, opts ...notificationlogOption) *NotificationLogMutation {
	m := &NotificationLogMutation{
		config:        c,
		op:            op,
		typ:           TypeNotificationLog,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withNotificationLogID sets the ID field of the mutation.
func withNotificationLogID(id string) notificationlogOption {
	return func(m *NotificationLogMutation) {
		var (
			err   error
			once  sync.Once
			value *NotificationLog
		)
		m.oldValue = func(ctx context.Context) (*NotificationLog, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().NotificationLog.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withNotificationLog sets the old NotificationLog of the mutation.
func withNotificationLog(node *NotificationLog) notificationlogOption {
	return func(m *NotificationLogMutation) {
		m.oldValue = func(context.Context) (*NotificationLog, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m NotificationLogMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m NotificationLogMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of NotificationLog entities.
func (m *NotificationLogMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *NotificationLogMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *NotificationLogMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().NotificationLog.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetChannel sets the "channel" field.
func (m *NotificationLogMutation) SetChannel(n notificationlog.Channel) {
	m.channel = &n
}

// Channel returns the value of the "channel" field in the mutation.
func (m *NotificationLogMutation) Channel() (r notificationlog.Channel, exists bool) {
	v := m.channel
	if v == nil {
		return
	}
	return *v, true
}

// OldChannel returns the old "channel" field's value of the NotificationLog entity.
// If the NotificationLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationLogMutation) OldChannel(ctx context.Context) (v notificationlog.Channel, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChannel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChannel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChannel: %w", err)
	}
	return oldValue.Channel, nil
}

// ResetChannel resets all changes to the "channel" field.
func (m *NotificationLogMutation) ResetChannel() {
	m.channel = nil
}

// SetAlertID sets the "alert_id" field.
func (m *NotificationLogMutation) SetAlertID(s string) {
	m.alert = &s
}

// AlertID returns the value of the "alert_id" field in the mutation.
func (m *NotificationLogMutation) AlertID() (r string, exists bool) {
	v := m.alert
	if v == nil {
		return
	}
	return *v, true
}

// OldAlertID returns the old "alert_id" field's value of the NotificationLog entity.
// If the NotificationLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationLogMutation) OldAlertID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAlertID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAlertID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAlertID: %w", err)
	}
	return oldValue.AlertID, nil
}

// ResetAlertID resets all changes to the "alert_id" field.
func (m *NotificationLogMutation) ResetAlertID() {
	m.alert = nil
}

// SetWebhookID sets the "webhook_id" field.
func (m *NotificationLogMutation) SetWebhookID(s string) {
	m.webhook = &s
}

// WebhookID returns the value of the "webhook_id" field in the mutation.
func (m *NotificationLogMutation) WebhookID() (r string, exists bool) {
	v := m.webhook
	if v == nil {
		return
	}
	return *v, true
}

// OldWebhookID returns the old "webhook_id" field's value of the NotificationLog entity.
// If the NotificationLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationLogMutation) OldWebhookID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWebhookID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWebhookID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWebhookID: %w", err)
	}
	return oldValue.WebhookID, nil
}

// ClearWebhookID clears the value of the "webhook_id" field.
func (m *NotificationLogMutation) ClearWebhookID() {
	m.webhook = nil
	m.clearedFields[notificationlog.FieldWebhookID] = struct{}{}
}

// WebhookIDCleared returns if the "webhook_id" field was cleared in this mutation.
func (m *NotificationLogMutation) WebhookIDCleared() bool {
	_, ok := m.clearedFields[notificationlog.FieldWebhookID]
	return ok
}

// ResetWebhookID resets all changes to the "webhook_id" field.
func (m *NotificationLogMutation) ResetWebhookID() {
	m.webhook = nil
	delete(m.clearedFields, notificationlog.FieldWebhookID)
}

// SetStatus sets the "status" field.
func (m *NotificationLogMutation) SetStatus(n notificationlog.Status) {
	m.status = &n
}

// Status returns the value of the "status" field in the mutation.
func (m *NotificationLogMutation) Status() (r notificationlog.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the NotificationLog entity.
// If the NotificationLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationLogMutation) OldStatus(ctx context.Context) (v notificationlog.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *NotificationLogMutation) ResetStatus() {
	m.status = nil
}

// SetAttemptNumber sets the "attempt_number" field.
func (m *NotificationLogMutation) SetAttemptNumber(i int) {
	m.attempt_number = &i
	m.addattempt_number = nil
}

// AttemptNumber returns the value of the "attempt_number" field in the mutation.
func (m *NotificationLogMutation) AttemptNumber() (r int, exists bool) {
	v := m.attempt_number
	if v == nil {
		return
	}
	return *v, true
}

// OldAttemptNumber returns the old "attempt_number" field's value of the NotificationLog entity.
// If the NotificationLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationLogMutation) OldAttemptNumber(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAttemptNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAttemptNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAttemptNumber: %w", err)
	}
	return oldValue.AttemptNumber, nil
}

// AddAttemptNumber adds i to the "attempt_number" field.
func (m *NotificationLogMutation) AddAttemptNumber(i int) {
	if m.addattempt_number != nil {
		*m.addattempt_number += i
	} else {
		m.addattempt_number = &i
	}
}

// AddedAttemptNumber returns the value that was added to the "attempt_number" field in this mutation.
func (m *NotificationLogMutation) AddedAttemptNumber() (r int, exists bool) {
	v := m.addattempt_number
	if v == nil {
		return
	}
	return *v, true
}

// ResetAttemptNumber resets all changes to the "attempt_number" field.
func (m *NotificationLogMutation) ResetAttemptNumber() {
	m.attempt_number = nil
	m.addattempt_number = nil
}

// SetResponseCode sets the "response_code" field.
func (m *NotificationLogMutation) SetResponseCode(i int) {
	m.response_code = &i
	m.addresponse_code = nil
}

// ResponseCode returns the value of the "response_code" field in the mutation.
func (m *NotificationLogMutation) ResponseCode() (r int, exists bool) {
	v := m.response_code
	if v == nil {
		return
	}
	return *v, true
}

// OldResponseCode returns the old "response_code" field's value of the NotificationLog entity.
// If the NotificationLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationLogMutation) OldResponseCode(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResponseCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResponseCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResponseCode: %w", err)
	}
	return oldValue.ResponseCode, nil
}

// AddResponseCode adds i to the "response_code" field.
func (m *NotificationLogMutation) AddResponseCode(i int) {
	if m.addresponse_code != nil {
		*m.addresponse_code += i
	} else {
		m.addresponse_code = &i
	}
}

// AddedResponseCode returns the value that was added to the "response_code" field in this mutation.
func (m *NotificationLogMutation) AddedResponseCode() (r int, exists bool) {
	v := m.addresponse_code
	if v == nil {
		return
	}
	return *v, true
}

// ClearResponseCode clears the value of the "response_code" field.
func (m *NotificationLogMutation) ClearResponseCode() {
	m.response_code = nil
	m.addresponse_code = nil
	m.clearedFields[notificationlog.FieldResponseCode] = struct{}{}
}

// ResponseCodeCleared returns if the "response_code" field was cleared in this mutation.
func (m *NotificationLogMutation) ResponseCodeCleared() bool {
	_, ok := m.clearedFields[notificationlog.FieldResponseCode]
	return ok
}

// ResetResponseCode resets all changes to the "response_code" field.
func (m *NotificationLogMutation) ResetResponseCode() {
	m.response_code = nil
	m.addresponse_code = nil
	delete(m.clearedFields, notificationlog.FieldResponseCode)
}

// SetResponseBody sets the "response_body" field.
func (m *NotificationLogMutation) SetResponseBody(s string) {
	m.response_body = &s
}

// ResponseBody returns the value of the "response_body" field in the mutation.
func (m *NotificationLogMutation) ResponseBody() (r string, exists bool) {
	v := m.response_body
	if v == nil {
		return
	}
	return *v, true
}

// OldResponseBody returns the old "response_body" field's value of the NotificationLog entity.
// If the NotificationLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationLogMutation) OldResponseBody(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResponseBody is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResponseBody requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResponseBody: %w", err)
	}
	return oldValue.ResponseBody, nil
}

// ClearResponseBody clears the value of the "response_body" field.
func (m *NotificationLogMutation) ClearResponseBody() {
	m.response_body = nil
	m.clearedFields[notificationlog.FieldResponseBody] = struct{}{}
}

// ResponseBodyCleared returns if the "response_body" field was cleared in this mutation.
func (m *NotificationLogMutation) ResponseBodyCleared() bool {
	_, ok := m.clearedFields[notificationlog.FieldResponseBody]
	return ok
}

// ResetResponseBody resets all changes to the "response_body" field.
func (m *NotificationLogMutation) ResetResponseBody() {
	m.response_body = nil
	delete(m.clearedFields, notificationlog.FieldResponseBody)
}

// SetErrorMessage sets the "error_message" field.
func (m *NotificationLogMutation) SetErrorMessage(s string) {
	m.error_message = &s
}

// ErrorMessage returns the value of the "error_message" field in the mutation.
func (m *NotificationLogMutation) ErrorMessage() (r string, exists bool) {
	v := m.error_message
	if v == nil {
		return
	}
	return *v, true
}

// OldErrorMessage returns the old "error_message" field's value of the NotificationLog entity.
// If the NotificationLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationLogMutation) OldErrorMessage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldErrorMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldErrorMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldErrorMessage: %w", err)
	}
	return oldValue.ErrorMessage, nil
}

// ClearErrorMessage clears the value of the "error_message" field.
func (m *NotificationLogMutation) ClearErrorMessage() {
	m.error_message = nil
	m.clearedFields[notificationlog.FieldErrorMessage] = struct{}{}
}

// ErrorMessageCleared returns if the "error_message" field was cleared in this mutation.
func (m *NotificationLogMutation) ErrorMessageCleared() bool {
	_, ok := m.clearedFields[notificationlog.FieldErrorMessage]
	return ok
}

// ResetErrorMessage resets all changes to the "error_message" field.
func (m *NotificationLogMutation) ResetErrorMessage() {
	m.error_message = nil
	delete(m.clearedFields, notificationlog.FieldErrorMessage)
}

// SetRequestMetadata sets the "request_metadata" field.
func (m *NotificationLogMutation) SetRequestMetadata(value map[string]interface{}) {
	m.request_metadata = &value
}

// RequestMetadata returns the value of the "request_metadata" field in the mutation.
func (m *NotificationLogMutation) RequestMetadata() (r map[string]interface{}, exists bool) {
	v := m.request_metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldRequestMetadata returns the old "request_metadata" field's value of the NotificationLog entity.
// If the NotificationLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationLogMutation) OldRequestMetadata(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRequestMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRequestMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRequestMetadata: %w", err)
	}
	return oldValue.RequestMetadata, nil
}

// ClearRequestMetadata clears the value of the "request_metadata" field.
func (m *NotificationLogMutation) ClearRequestMetadata() {
	m.request_metadata = nil
	m.clearedFields[notificationlog.FieldRequestMetadata] = struct{}{}
}

// RequestMetadataCleared returns if the "request_metadata" field was cleared in this mutation.
func (m *NotificationLogMutation) RequestMetadataCleared() bool {
	_, ok := m.clearedFields[notificationlog.FieldRequestMetadata]
	return ok
}

// ResetRequestMetadata resets all changes to the "request_metadata" field.
func (m *NotificationLogMutation) ResetRequestMetadata() {
	m.request_metadata = nil
	delete(m.clearedFields, notificationlog.FieldRequestMetadata)
}

// SetCreatedAt sets the "created_at" field.
func (m *NotificationLogMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *NotificationLogMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the NotificationLog entity.
// If the NotificationLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationLogMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *NotificationLogMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetCompletedAt sets the "completed_at" field.
func (m *NotificationLogMutation) SetCompletedAt(t time.Time) {
	m.completed_at = &t
}

// CompletedAt returns the value of the "completed_at" field in the mutation.
func (m *NotificationLogMutation) CompletedAt() (r time.Time, exists bool) {
	v := m.completed_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCompletedAt returns the old "completed_at" field's value of the NotificationLog entity.
// If the NotificationLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationLogMutation) OldCompletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompletedAt: %w", err)
	}
	return oldValue.CompletedAt, nil
}

// ClearCompletedAt clears the value of the "completed_at" field.
func (m *NotificationLogMutation) ClearCompletedAt() {
	m.completed_at = nil
	m.clearedFields[notificationlog.FieldCompletedAt] = struct{}{}
}

// CompletedAtCleared returns if the "completed_at" field was cleared in this mutation.
func (m *NotificationLogMutation) CompletedAtCleared() bool {
	_, ok := m.clearedFields[notificationlog.FieldCompletedAt]
	return ok
}

// ResetCompletedAt resets all changes to the "completed_at" field.
func (m *NotificationLogMutation) ResetCompletedAt() {
	m.completed_at = nil
	delete(m.clearedFields, notificationlog.FieldCompletedAt)
}

// ClearAlert clears the "alert" edge to the Alert entity.
func (m *NotificationLogMutation) ClearAlert() {
	m.clearedalert = true
	m.clearedFields[notificationlog.FieldAlertID] = struct{}{}
}

// AlertCleared reports if the "alert" edge to the Alert entity was cleared.
func (m *NotificationLogMutation) AlertCleared() bool {
	return m.clearedalert
}

// AlertIDs returns the "alert" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AlertID instead. It exists only for internal usage by the builders.
func (m *NotificationLogMutation) AlertIDs() (ids []string) {
	if id := m.alert; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAlert resets all changes to the "alert" edge.
func (m *NotificationLogMutation) ResetAlert() {
	m.alert = nil
	m.clearedalert = false
}

// ClearWebhook clears the "webhook" edge to the Webhook entity.
func (m *NotificationLogMutation) ClearWebhook() {
	m.clearedwebhook = true
	m.clearedFields[notificationlog.FieldWebhookID] = struct{}{}
}

// WebhookCleared reports if the "webhook" edge to the Webhook entity was cleared.
func (m *NotificationLogMutation) WebhookCleared() bool {
	return m.WebhookIDCleared() || m.clearedwebhook
}

// WebhookIDs returns the "webhook" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// WebhookID instead. It exists only for internal usage by the builders.
func (m *NotificationLogMutation) WebhookIDs() (ids []string) {
	if id := m.webhook; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetWebhook resets all changes to the "webhook" edge.
func (m *NotificationLogMutation) ResetWebhook() {
	m.webhook = nil
	m.clearedwebhook = false
}

// Where appends a list predicates to the NotificationLogMutation builder.
func (m *NotificationLogMutation) Where(ps ...predicate.NotificationLog) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the NotificationLogMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *NotificationLogMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.NotificationLog, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *NotificationLogMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *NotificationLogMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (NotificationLog).
func (m *NotificationLogMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *NotificationLogMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.channel != nil {
		fields = append(fields, notificationlog.FieldChannel)
	}
	if m.alert != nil {
		fields = append(fields, notificationlog.FieldAlertID)
	}
	if m.webhook != nil {
		fields = append(fields, notificationlog.FieldWebhookID)
	}
	if m.status != nil {
		fields = append(fields, notificationlog.FieldStatus)
	}
	if m.attempt_number != nil {
		fields = append(fields, notificationlog.FieldAttemptNumber)
	}
	if m.response_code != nil {
		fields = append(fields, notificationlog.FieldResponseCode)
	}
	if m.response_body != nil {
		fields = append(fields, notificationlog.FieldResponseBody)
	}
	if m.error_message != nil {
		fields = append(fields, notificationlog.FieldErrorMessage)
	}
	if m.request_metadata != nil {
		fields = append(fields, notificationlog.FieldRequestMetadata)
	}
	if m.created_at != nil {
		fields = append(fields, notificationlog.FieldCreatedAt)
	}
	if m.completed_at != nil {
		fields = append(fields, notificationlog.FieldCompletedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *NotificationLogMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case notificationlog.FieldChannel:
		return m.Channel()
	case notificationlog.FieldAlertID:
		return m.AlertID()
	case notificationlog.FieldWebhookID:
		return m.WebhookID()
	case notificationlog.FieldStatus:
		return m.Status()
	case notificationlog.FieldAttemptNumber:
		return m.AttemptNumber()
	case notificationlog.FieldResponseCode:
		return m.ResponseCode()
	case notificationlog.FieldResponseBody:
		return m.ResponseBody()
	case notificationlog.FieldErrorMessage:
		return m.ErrorMessage()
	case notificationlog.FieldRequestMetadata:
		return m.RequestMetadata()
	case notificationlog.FieldCreatedAt:
		return m.CreatedAt()
	case notificationlog.FieldCompletedAt:
		return m.CompletedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *NotificationLogMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case notificationlog.FieldChannel:
		return m.OldChannel(ctx)
	case notificationlog.FieldAlertID:
		return m.OldAlertID(ctx)
	case notificationlog.FieldWebhookID:
		return m.OldWebhookID(ctx)
	case notificationlog.FieldStatus:
		return m.OldStatus(ctx)
	case notificationlog.FieldAttemptNumber:
		return m.OldAttemptNumber(ctx)
	case notificationlog.FieldResponseCode:
		return m.OldResponseCode(ctx)
	case notificationlog.FieldResponseBody:
		return m.OldResponseBody(ctx)
	case notificationlog.FieldErrorMessage:
		return m.OldErrorMessage(ctx)
	case notificationlog.FieldRequestMetadata:
		return m.OldRequestMetadata(ctx)
	case notificationlog.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case notificationlog.FieldCompletedAt:
		return m.OldCompletedAt(ctx)
	}
	return nil, fmt.Errorf("unknown NotificationLog field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NotificationLogMutation) SetField(name string, value ent.Value) error {
	switch name {
	case notificationlog.FieldChannel:
		v, ok := value.(notificationlog.Channel)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChannel(v)
		return nil
	case notificationlog.FieldAlertID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAlertID(v)
		return nil
	case notificationlog.FieldWebhookID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWebhookID(v)
		return nil
	case notificationlog.FieldStatus:
		v, ok := value.(notificationlog.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case notificationlog.FieldAttemptNumber:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAttemptNumber(v)
		return nil
	case notificationlog.FieldResponseCode:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResponseCode(v)
		return nil
	case notificationlog.FieldResponseBody:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResponseBody(v)
		return nil
	case notificationlog.FieldErrorMessage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetErrorMessage(v)
		return nil
	case notificationlog.FieldRequestMetadata:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRequestMetadata(v)
		return nil
	case notificationlog.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case notificationlog.FieldCompletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown NotificationLog field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *NotificationLogMutation) AddedFields() []string {
	var fields []string
	if m.addattempt_number != nil {
		fields = append(fields, notificationlog.FieldAttemptNumber)
	}
	if m.addresponse_code != nil {
		fields = append(fields, notificationlog.FieldResponseCode)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *NotificationLogMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case notificationlog.FieldAttemptNumber:
		return m.AddedAttemptNumber()
	case notificationlog.FieldResponseCode:
		return m.AddedResponseCode()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NotificationLogMutation) AddField(name string, value ent.Value) error {
	switch name {
	case notificationlog.FieldAttemptNumber:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAttemptNumber(v)
		return nil
	case notificationlog.FieldResponseCode:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddResponseCode(v)
		return nil
	}
	return fmt.Errorf("unknown NotificationLog numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *NotificationLogMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(notificationlog.FieldWebhookID) {
		fields = append(fields, notificationlog.FieldWebhookID)
	}
	if m.FieldCleared(notificationlog.FieldResponseCode) {
		fields = append(fields, notificationlog.FieldResponseCode)
	}
	if m.FieldCleared(notificationlog.FieldResponseBody) {
		fields = append(fields, notificationlog.FieldResponseBody)
	}
	if m.FieldCleared(notificationlog.FieldErrorMessage) {
		fields = append(fields, notificationlog.FieldErrorMessage)
	}
	if m.FieldCleared(notificationlog.FieldRequestMetadata) {
		fields = append(fields, notificationlog.FieldRequestMetadata)
	}
	if m.FieldCleared(notificationlog.FieldCompletedAt) {
		fields = append(fields, notificationlog.FieldCompletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *NotificationLogMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *NotificationLogMutation) ClearField(name string) error {
	switch name {
	case notificationlog.FieldWebhookID:
		m.ClearWebhookID()
		return nil
	case notificationlog.FieldResponseCode:
		m.ClearResponseCode()
		return nil
	case notificationlog.FieldResponseBody:
		m.ClearResponseBody()
		return nil
	case notificationlog.FieldErrorMessage:
		m.ClearErrorMessage()
		return nil
	case notificationlog.FieldRequestMetadata:
		m.ClearRequestMetadata()
		return nil
	case notificationlog.FieldCompletedAt:
		m.ClearCompletedAt()
		return nil
	}
	return fmt.Errorf("unknown NotificationLog nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *NotificationLogMutation) ResetField(name string) error {
	switch name {
	case notificationlog.FieldChannel:
		m.ResetChannel()
		return nil
	case notificationlog.FieldAlertID:
		m.ResetAlertID()
		return nil
	case notificationlog.FieldWebhookID:
		m.ResetWebhookID()
		return nil
	case notificationlog.FieldStatus:
		m.ResetStatus()
		return nil
	case notificationlog.FieldAttemptNumber:
		m.ResetAttemptNumber()
		return nil
	case notificationlog.FieldResponseCode:
		m.ResetResponseCode()
		return nil
	case notificationlog.FieldResponseBody:
		m.ResetResponseBody()
		return nil
	case notificationlog.FieldErrorMessage:
		m.ResetErrorMessage()
		return nil
	case notificationlog.FieldRequestMetadata:
		m.ResetRequestMetadata()
		return nil
	case notificationlog.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case notificationlog.FieldCompletedAt:
		m.ResetCompletedAt()
		return nil
	}
	return fmt.Errorf("unknown NotificationLog field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *NotificationLogMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.alert != nil {
		edges = append(edges, notificationlog.EdgeAlert)
	}
	if m.webhook != nil {
		edges = append(edges, notificationlog.EdgeWebhook)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *NotificationLogMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case notificationlog.EdgeAlert:
		if id := m.alert; id != nil {
			return []ent.Value{*id}
		}
	case notificationlog.EdgeWebhook:
		if id := m.webhook; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *NotificationLogMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *NotificationLogMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *NotificationLogMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedalert {
		edges = append(edges, notificationlog.EdgeAlert)
	}
	if m.clearedwebhook {
		edges = append(edges, notificationlog.EdgeWebhook)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *NotificationLogMutation) EdgeCleared(name string) bool {
	switch name {
	case notificationlog.EdgeAlert:
		return m.clearedalert
	case notificationlog.EdgeWebhook:
		return m.clearedwebhook
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *NotificationLogMutation) ClearEdge(name string) error {
	switch name {
	case notificationlog.EdgeAlert:
		m.ClearAlert()
		return nil
	case notificationlog.EdgeWebhook:
		m.ClearWebhook()
		return nil
	}
	return fmt.Errorf("unknown NotificationLog unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *NotificationLogMutation) ResetEdge(name string) error {
	switch name {
	case notificationlog.EdgeAlert:
		m.ResetAlert()
		return nil
	case notificationlog.EdgeWebhook:
		m.ResetWebhook()
		return nil
	}
	return fmt.Errorf("unknown NotificationLog edge %s", name)
}

// NotificationSettingsMutation represents an operation that mutates the NotificationSettings nodes in the graph.
type NotificationSettingsMutation struct {
	config
	op                    Op
	typ                   string
	id                    *string
	channel               *notificationsettings.Channel
	credentials_encrypted *[]byte
	nonce                 *[]byte
	enabled               *bool
	test_status           *notificationsettings.TestStatus
	test_message          *string
	tested_at             *time.Time
	created_at            *time.Time
	updated_at            *time.Time
	clearedFields         map[string]struct{}
	done                  bool
	oldValue              func(context.Context) (*NotificationSettings, error)
	predicates            []predicate.NotificationSettings
}

var _ ent.Mutation = (*NotificationSettingsMutation)(nil)

// notificationsettingsOption allows management of the mutation configuration using functional options.
type notificationsettingsOption func(*NotificationSettingsMutation)

// newNotificationSettingsMutation creates new mutation for the NotificationSettings entity.
func newNotificationSettingsMutation(c config, op Op, opts ...notificationsettingsOption) *NotificationSettingsMutation {
	m := &NotificationSettingsMutation{
		config:        c,
		op:            op,
		typ:           TypeNotificationSettings,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withNotificationSettingsID sets the ID field of the mutation.
func withNotificationSettingsID(id string) notificationsettingsOption {
	return func(m *NotificationSettingsMutation) {
		var (
			err   error
			once  sync.Once
			value *NotificationSettings
		)
		m.oldValue = func(ctx context.Context) (*NotificationSettings, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().NotificationSettings.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withNotificationSettings sets the old NotificationSettings of the mutation.
func withNotificationSettings(node *NotificationSettings) notificationsettingsOption {
	return func(m *NotificationSettingsMutation) {
		m.oldValue = func(context.Context) (*NotificationSettings, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m NotificationSettingsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m NotificationSettingsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of NotificationSettings entities.
func (m *NotificationSettingsMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *NotificationSettingsMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *NotificationSettingsMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().NotificationSettings.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetChannel sets the "channel" field.
func (m *NotificationSettingsMutation) SetChannel(n notificationsettings.Channel) {
	m.channel = &n
}

// Channel returns the value of the "channel" field in the mutation.
func (m *NotificationSettingsMutation) Channel() (r notificationsettings.Channel, exists bool) {
	v := m.channel
	if v == nil {
		return
	}
	return *v, true
}

// OldChannel returns the old "channel" field's value of the NotificationSettings entity.
// If the NotificationSettings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationSettingsMutation) OldChannel(ctx context.Context) (v notificationsettings.Channel, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChannel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChannel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChannel: %w", err)
	}
	return oldValue.Channel, nil
}

// ResetChannel resets all changes to the "channel" field.
func (m *NotificationSettingsMutation) ResetChannel() {
	m.channel = nil
}

// SetCredentialsEncrypted sets the "credentials_encrypted" field.
func (m *NotificationSettingsMutation) SetCredentialsEncrypted(b []byte) {
	m.credentials_encrypted = &b
}

// CredentialsEncrypted returns the value of the "credentials_encrypted" field in the mutation.
func (m *NotificationSettingsMutation) CredentialsEncrypted() (r []byte, exists bool) {
	v := m.credentials_encrypted
	if v == nil {
		return
	}
	return *v, true
}

// OldCredentialsEncrypted returns the old "credentials_encrypted" field's value of the NotificationSettings entity.
// If the NotificationSettings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationSettingsMutation) OldCredentialsEncrypted(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCredentialsEncrypted is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCredentialsEncrypted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCredentialsEncrypted: %w", err)
	}
	return oldValue.CredentialsEncrypted, nil
}

// ResetCredentialsEncrypted resets all changes to the "credentials_encrypted" field.
func (m *NotificationSettingsMutation) ResetCredentialsEncrypted() {
	m.credentials_encrypted = nil
}

// SetNonce sets the "nonce" field.
func (m *NotificationSettingsMutation) SetNonce(b []byte) {
	m.nonce = &b
}

// Nonce returns the value of the "nonce" field in the mutation.
func (m *NotificationSettingsMutation) Nonce() (r []byte, exists bool) {
	v := m.nonce
	if v == nil {
		return
	}
	return *v, true
}

// OldNonce returns the old "nonce" field's value of the NotificationSettings entity.
// If the NotificationSettings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationSettingsMutation) OldNonce(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNonce is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNonce requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNonce: %w", err)
	}
	return oldValue.Nonce, nil
}

// ResetNonce resets all changes to the "nonce" field.
func (m *NotificationSettingsMutation) ResetNonce() {
	m.nonce = nil
}

// SetEnabled sets the "enabled" field.
func (m *NotificationSettingsMutation) SetEnabled(b bool) {
	m.enabled = &b
}

// Enabled returns the value of the "enabled" field in the mutation.
func (m *NotificationSettingsMutation) Enabled() (r bool, exists bool) {
	v := m.enabled
	if v == nil {
		return
	}
	return *v, true
}

// OldEnabled returns the old "enabled" field's value of the NotificationSettings entity.
// If the NotificationSettings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationSettingsMutation) OldEnabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnabled: %w", err)
	}
	return oldValue.Enabled, nil
}

// ResetEnabled resets all changes to the "enabled" field.
func (m *NotificationSettingsMutation) ResetEnabled() {
	m.enabled = nil
}

// SetTestStatus sets the "test_status" field.
func (m *NotificationSettingsMutation) SetTestStatus(ns notificationsettings.TestStatus) {
	m.test_status = &ns
}

// TestStatus returns the value of the "test_status" field in the mutation.
func (m *NotificationSettingsMutation) TestStatus() (r notificationsettings.TestStatus, exists bool) {
	v := m.test_status
	if v == nil {
		return
	}
	return *v, true
}

// OldTestStatus returns the old "test_status" field's value of the NotificationSettings entity.
// If the NotificationSettings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationSettingsMutation) OldTestStatus(ctx context.Context) (v notificationsettings.TestStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTestStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTestStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTestStatus: %w", err)
	}
	return oldValue.TestStatus, nil
}

// ResetTestStatus resets all changes to the "test_status" field.
func (m *NotificationSettingsMutation) ResetTestStatus() {
	m.test_status = nil
}

// SetTestMessage sets the "test_message" field.
func (m *NotificationSettingsMutation) SetTestMessage(s string) {
	m.test_message = &s
}

// TestMessage returns the value of the "test_message" field in the mutation.
func (m *NotificationSettingsMutation) TestMessage() (r string, exists bool) {
	v := m.test_message
	if v == nil {
		return
	}
	return *v, true
}

// OldTestMessage returns the old "test_message" field's value of the NotificationSettings entity.
// If the NotificationSettings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationSettingsMutation) OldTestMessage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTestMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTestMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTestMessage: %w", err)
	}
	return oldValue.TestMessage, nil
}

// ClearTestMessage clears the value of the "test_message" field.
func (m *NotificationSettingsMutation) ClearTestMessage() {
	m.test_message = nil
	m.clearedFields[notificationsettings.FieldTestMessage] = struct{}{}
}

// TestMessageCleared returns if the "test_message" field was cleared in this mutation.
func (m *NotificationSettingsMutation) TestMessageCleared() bool {
	_, ok := m.clearedFields[notificationsettings.FieldTestMessage]
	return ok
}

// ResetTestMessage resets all changes to the "test_message" field.
func (m *NotificationSettingsMutation) ResetTestMessage() {
	m.test_message = nil
	delete(m.clearedFields, notificationsettings.FieldTestMessage)
}

// SetTestedAt sets the "tested_at" field.
func (m *NotificationSettingsMutation) SetTestedAt(t time.Time) {
	m.tested_at = &t
}

// TestedAt returns the value of the "tested_at" field in the mutation.
func (m *NotificationSettingsMutation) TestedAt() (r time.Time, exists bool) {
	v := m.tested_at
	if v == nil {
		return
	}
	return *v, true
}

// OldTestedAt returns the old "tested_at" field's value of the NotificationSettings entity.
// If the NotificationSettings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationSettingsMutation) OldTestedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTestedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTestedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTestedAt: %w", err)
	}
	return oldValue.TestedAt, nil
}

// ClearTestedAt clears the value of the "tested_at" field.
func (m *NotificationSettingsMutation) ClearTestedAt() {
	m.tested_at = nil
	m.clearedFields[notificationsettings.FieldTestedAt] = struct{}{}
}

// TestedAtCleared returns if the "tested_at" field was cleared in this mutation.
func (m *NotificationSettingsMutation) TestedAtCleared() bool {
	_, ok := m.clearedFields[notificationsettings.FieldTestedAt]
	return ok
}

// ResetTestedAt resets all changes to the "tested_at" field.
func (m *NotificationSettingsMutation) ResetTestedAt() {
	m.tested_at = nil
	delete(m.clearedFields, notificationsettings.FieldTestedAt)
}

// SetCreatedAt sets the "created_at" field.
func (m *NotificationSettingsMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *NotificationSettingsMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the NotificationSettings entity.
// If the NotificationSettings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationSettingsMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *NotificationSettingsMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *NotificationSettingsMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *NotificationSettingsMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the NotificationSettings entity.
// If the NotificationSettings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationSettingsMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *NotificationSettingsMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// Where appends a list predicates to the NotificationSettingsMutation builder.
func (m *NotificationSettingsMutation) Where(ps ...predicate.NotificationSettings) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the NotificationSettingsMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *NotificationSettingsMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.NotificationSettings, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *NotificationSettingsMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *NotificationSettingsMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (NotificationSettings).
func (m *NotificationSettingsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *NotificationSettingsMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.channel != nil {
		fields = append(fields, notificationsettings.FieldChannel)
	}
	if m.credentials_encrypted != nil {
		fields = append(fields, notificationsettings.FieldCredentialsEncrypted)
	}
	if m.nonce != nil {
		fields = append(fields, notificationsettings.FieldNonce)
	}
	if m.enabled != nil {
		fields = append(fields, notificationsettings.FieldEnabled)
	}
	if m.test_status != nil {
		fields = append(fields, notificationsettings.FieldTestStatus)
	}
	if m.test_message != nil {
		fields = append(fields, notificationsettings.FieldTestMessage)
	}
	if m.tested_at != nil {
		fields = append(fields, notificationsettings.FieldTestedAt)
	}
	if m.created_at != nil {
		fields = append(fields, notificationsettings.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, notificationsettings.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *NotificationSettingsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case notificationsettings.FieldChannel:
		return m.Channel()
	case notificationsettings.FieldCredentialsEncrypted:
		return m.CredentialsEncrypted()
	case notificationsettings.FieldNonce:
		return m.Nonce()
	case notificationsettings.FieldEnabled:
		return m.Enabled()
	case notificationsettings.FieldTestStatus:
		return m.TestStatus()
	case notificationsettings.FieldTestMessage:
		return m.TestMessage()
	case notificationsettings.FieldTestedAt:
		return m.TestedAt()
	case notificationsettings.FieldCreatedAt:
		return m.CreatedAt()
	case notificationsettings.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *NotificationSettingsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case notificationsettings.FieldChannel:
		return m.OldChannel(ctx)
	case notificationsettings.FieldCredentialsEncrypted:
		return m.OldCredentialsEncrypted(ctx)
	case notificationsettings.FieldNonce:
		return m.OldNonce(ctx)
	case notificationsettings.FieldEnabled:
		return m.OldEnabled(ctx)
	case notificationsettings.FieldTestStatus:
		return m.OldTestStatus(ctx)
	case notificationsettings.FieldTestMessage:
		return m.OldTestMessage(ctx)
	case notificationsettings.FieldTestedAt:
		return m.OldTestedAt(ctx)
	case notificationsettings.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case notificationsettings.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown NotificationSettings field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NotificationSettingsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case notificationsettings.FieldChannel:
		v, ok := value.(notificationsettings.Channel)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChannel(v)
		return nil
	case notificationsettings.FieldCredentialsEncrypted:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCredentialsEncrypted(v)
		return nil
	case notificationsettings.FieldNonce:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNonce(v)
		return nil
	case notificationsettings.FieldEnabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnabled(v)
		return nil
	case notificationsettings.FieldTestStatus:
		v, ok := value.(notificationsettings.TestStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTestStatus(v)
		return nil
	case notificationsettings.FieldTestMessage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTestMessage(v)
		return nil
	case notificationsettings.FieldTestedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTestedAt(v)
		return nil
	case notificationsettings.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case notificationsettings.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown NotificationSettings field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *NotificationSettingsMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *NotificationSettingsMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NotificationSettingsMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown NotificationSettings numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *NotificationSettingsMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(notificationsettings.FieldTestMessage) {
		fields = append(fields, notificationsettings.FieldTestMessage)
	}
	if m.FieldCleared(notificationsettings.FieldTestedAt) {
		fields = append(fields, notificationsettings.FieldTestedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *NotificationSettingsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *NotificationSettingsMutation) ClearField(name string) error {
	switch name {
	case notificationsettings.FieldTestMessage:
		m.ClearTestMessage()
		return nil
	case notificationsettings.FieldTestedAt:
		m.ClearTestedAt()
		return nil
	}
	return fmt.Errorf("unknown NotificationSettings nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *NotificationSettingsMutation) ResetField(name string) error {
	switch name {
	case notificationsettings.FieldChannel:
		m.ResetChannel()
		return nil
	case notificationsettings.FieldCredentialsEncrypted:
		m.ResetCredentialsEncrypted()
		return nil
	case notificationsettings.FieldNonce:
		m.ResetNonce()
		return nil
	case notificationsettings.FieldEnabled:
		m.ResetEnabled()
		return nil
	case notificationsettings.FieldTestStatus:
		m.ResetTestStatus()
		return nil
	case notificationsettings.FieldTestMessage:
		m.ResetTestMessage()
		return nil
	case notificationsettings.FieldTestedAt:
		m.ResetTestedAt()
		return nil
	case notificationsettings.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case notificationsettings.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown NotificationSettings field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *NotificationSettingsMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *NotificationSettingsMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *NotificationSettingsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *NotificationSettingsMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *NotificationSettingsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *NotificationSettingsMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *NotificationSettingsMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown NotificationSettings unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *NotificationSettingsMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown NotificationSettings edge %s", name)
}

// PortKnockSequenceMutation represents an operation that mutates the PortKnockSequence nodes in the graph.
type PortKnockSequenceMutation struct {
	config
	op                       Op
	typ                      string
	id                       *string
	name                     *string
	knock_ports              *[]map[string]interface{}
	appendknock_ports        []map[string]interface{}
	protected_port           *int
	addprotected_port        *int
	protected_protocol       *portknocksequence.ProtectedProtocol
	access_timeout           *string
	knock_timeout            *string
	enabled                  *bool
	generated_rule_ids       *[]string
	appendgenerated_rule_ids []string
	recent_access_count      *int
	addrecent_access_count   *int
	last_accessed_at         *time.Time
	created_at               *time.Time
	updated_at               *time.Time
	clearedFields            map[string]struct{}
	router                   *string
	clearedrouter            bool
	done                     bool
	oldValue                 func(context.Context) (*PortKnockSequence, error)
	predicates               []predicate.PortKnockSequence
}

var _ ent.Mutation = (*PortKnockSequenceMutation)(nil)

// portknocksequenceOption allows management of the mutation configuration using functional options.
type portknocksequenceOption func(*PortKnockSequenceMutation)

// newPortKnockSequenceMutation creates new mutation for the PortKnockSequence entity.
func newPortKnockSequenceMutation(c config, op Op, opts ...portknocksequenceOption) *PortKnockSequenceMutation {
	m := &PortKnockSequenceMutation{
		config:        c,
		op:            op,
		typ:           TypePortKnockSequence,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPortKnockSequenceID sets the ID field of the mutation.
func withPortKnockSequenceID(id string) portknocksequenceOption {
	return func(m *PortKnockSequenceMutation) {
		var (
			err   error
			once  sync.Once
			value *PortKnockSequence
		)
		m.oldValue = func(ctx context.Context) (*PortKnockSequence, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PortKnockSequence.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPortKnockSequence sets the old PortKnockSequence of the mutation.
func withPortKnockSequence(node *PortKnockSequence) portknocksequenceOption {
	return func(m *PortKnockSequenceMutation) {
		m.oldValue = func(context.Context) (*PortKnockSequence, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PortKnockSequenceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PortKnockSequenceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of PortKnockSequence entities.
func (m *PortKnockSequenceMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PortKnockSequenceMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PortKnockSequenceMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PortKnockSequence.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *PortKnockSequenceMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *PortKnockSequenceMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the PortKnockSequence entity.
// If the PortKnockSequence object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PortKnockSequenceMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *PortKnockSequenceMutation) ResetName() {
	m.name = nil
}

// SetKnockPorts sets the "knock_ports" field.
func (m *PortKnockSequenceMutation) SetKnockPorts(value []map[string]interface{}) {
	m.knock_ports = &value
	m.appendknock_ports = nil
}

// KnockPorts returns the value of the "knock_ports" field in the mutation.
func (m *PortKnockSequenceMutation) KnockPorts() (r []map[string]interface{}, exists bool) {
	v := m.knock_ports
	if v == nil {
		return
	}
	return *v, true
}

// OldKnockPorts returns the old "knock_ports" field's value of the PortKnockSequence entity.
// If the PortKnockSequence object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PortKnockSequenceMutation) OldKnockPorts(ctx context.Context) (v []map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKnockPorts is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKnockPorts requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKnockPorts: %w", err)
	}
	return oldValue.KnockPorts, nil
}

// AppendKnockPorts adds value to the "knock_ports" field.
func (m *PortKnockSequenceMutation) AppendKnockPorts(value []map[string]interface{}) {
	m.appendknock_ports = append(m.appendknock_ports, value...)
}

// AppendedKnockPorts returns the list of values that were appended to the "knock_ports" field in this mutation.
func (m *PortKnockSequenceMutation) AppendedKnockPorts() ([]map[string]interface{}, bool) {
	if len(m.appendknock_ports) == 0 {
		return nil, false
	}
	return m.appendknock_ports, true
}

// ResetKnockPorts resets all changes to the "knock_ports" field.
func (m *PortKnockSequenceMutation) ResetKnockPorts() {
	m.knock_ports = nil
	m.appendknock_ports = nil
}

// SetProtectedPort sets the "protected_port" field.
func (m *PortKnockSequenceMutation) SetProtectedPort(i int) {
	m.protected_port = &i
	m.addprotected_port = nil
}

// ProtectedPort returns the value of the "protected_port" field in the mutation.
func (m *PortKnockSequenceMutation) ProtectedPort() (r int, exists bool) {
	v := m.protected_port
	if v == nil {
		return
	}
	return *v, true
}

// OldProtectedPort returns the old "protected_port" field's value of the PortKnockSequence entity.
// If the PortKnockSequence object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PortKnockSequenceMutation) OldProtectedPort(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProtectedPort is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProtectedPort requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProtectedPort: %w", err)
	}
	return oldValue.ProtectedPort, nil
}

// AddProtectedPort adds i to the "protected_port" field.
func (m *PortKnockSequenceMutation) AddProtectedPort(i int) {
	if m.addprotected_port != nil {
		*m.addprotected_port += i
	} else {
		m.addprotected_port = &i
	}
}

// AddedProtectedPort returns the value that was added to the "protected_port" field in this mutation.
func (m *PortKnockSequenceMutation) AddedProtectedPort() (r int, exists bool) {
	v := m.addprotected_port
	if v == nil {
		return
	}
	return *v, true
}

// ResetProtectedPort resets all changes to the "protected_port" field.
func (m *PortKnockSequenceMutation) ResetProtectedPort() {
	m.protected_port = nil
	m.addprotected_port = nil
}

// SetProtectedProtocol sets the "protected_protocol" field.
func (m *PortKnockSequenceMutation) SetProtectedProtocol(pp portknocksequence.ProtectedProtocol) {
	m.protected_protocol = &pp
}

// ProtectedProtocol returns the value of the "protected_protocol" field in the mutation.
func (m *PortKnockSequenceMutation) ProtectedProtocol() (r portknocksequence.ProtectedProtocol, exists bool) {
	v := m.protected_protocol
	if v == nil {
		return
	}
	return *v, true
}

// OldProtectedProtocol returns the old "protected_protocol" field's value of the PortKnockSequence entity.
// If the PortKnockSequence object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PortKnockSequenceMutation) OldProtectedProtocol(ctx context.Context) (v portknocksequence.ProtectedProtocol, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProtectedProtocol is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProtectedProtocol requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProtectedProtocol: %w", err)
	}
	return oldValue.ProtectedProtocol, nil
}

// ResetProtectedProtocol resets all changes to the "protected_protocol" field.
func (m *PortKnockSequenceMutation) ResetProtectedProtocol() {
	m.protected_protocol = nil
}

// SetAccessTimeout sets the "access_timeout" field.
func (m *PortKnockSequenceMutation) SetAccessTimeout(s string) {
	m.access_timeout = &s
}

// AccessTimeout returns the value of the "access_timeout" field in the mutation.
func (m *PortKnockSequenceMutation) AccessTimeout() (r string, exists bool) {
	v := m.access_timeout
	if v == nil {
		return
	}
	return *v, true
}

// OldAccessTimeout returns the old "access_timeout" field's value of the PortKnockSequence entity.
// If the PortKnockSequence object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PortKnockSequenceMutation) OldAccessTimeout(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccessTimeout is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccessTimeout requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccessTimeout: %w", err)
	}
	return oldValue.AccessTimeout, nil
}

// ResetAccessTimeout resets all changes to the "access_timeout" field.
func (m *PortKnockSequenceMutation) ResetAccessTimeout() {
	m.access_timeout = nil
}

// SetKnockTimeout sets the "knock_timeout" field.
func (m *PortKnockSequenceMutation) SetKnockTimeout(s string) {
	m.knock_timeout = &s
}

// KnockTimeout returns the value of the "knock_timeout" field in the mutation.
func (m *PortKnockSequenceMutation) KnockTimeout() (r string, exists bool) {
	v := m.knock_timeout
	if v == nil {
		return
	}
	return *v, true
}

// OldKnockTimeout returns the old "knock_timeout" field's value of the PortKnockSequence entity.
// If the PortKnockSequence object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PortKnockSequenceMutation) OldKnockTimeout(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKnockTimeout is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKnockTimeout requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKnockTimeout: %w", err)
	}
	return oldValue.KnockTimeout, nil
}

// ResetKnockTimeout resets all changes to the "knock_timeout" field.
func (m *PortKnockSequenceMutation) ResetKnockTimeout() {
	m.knock_timeout = nil
}

// SetEnabled sets the "enabled" field.
func (m *PortKnockSequenceMutation) SetEnabled(b bool) {
	m.enabled = &b
}

// Enabled returns the value of the "enabled" field in the mutation.
func (m *PortKnockSequenceMutation) Enabled() (r bool, exists bool) {
	v := m.enabled
	if v == nil {
		return
	}
	return *v, true
}

// OldEnabled returns the old "enabled" field's value of the PortKnockSequence entity.
// If the PortKnockSequence object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PortKnockSequenceMutation) OldEnabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnabled: %w", err)
	}
	return oldValue.Enabled, nil
}

// ResetEnabled resets all changes to the "enabled" field.
func (m *PortKnockSequenceMutation) ResetEnabled() {
	m.enabled = nil
}

// SetRouterID sets the "router_id" field.
func (m *PortKnockSequenceMutation) SetRouterID(s string) {
	m.router = &s
}

// RouterID returns the value of the "router_id" field in the mutation.
func (m *PortKnockSequenceMutation) RouterID() (r string, exists bool) {
	v := m.router
	if v == nil {
		return
	}
	return *v, true
}

// OldRouterID returns the old "router_id" field's value of the PortKnockSequence entity.
// If the PortKnockSequence object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PortKnockSequenceMutation) OldRouterID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRouterID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRouterID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRouterID: %w", err)
	}
	return oldValue.RouterID, nil
}

// ResetRouterID resets all changes to the "router_id" field.
func (m *PortKnockSequenceMutation) ResetRouterID() {
	m.router = nil
}

// SetGeneratedRuleIds sets the "generated_rule_ids" field.
func (m *PortKnockSequenceMutation) SetGeneratedRuleIds(s []string) {
	m.generated_rule_ids = &s
	m.appendgenerated_rule_ids = nil
}

// GeneratedRuleIds returns the value of the "generated_rule_ids" field in the mutation.
func (m *PortKnockSequenceMutation) GeneratedRuleIds() (r []string, exists bool) {
	v := m.generated_rule_ids
	if v == nil {
		return
	}
	return *v, true
}

// OldGeneratedRuleIds returns the old "generated_rule_ids" field's value of the PortKnockSequence entity.
// If the PortKnockSequence object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PortKnockSequenceMutation) OldGeneratedRuleIds(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGeneratedRuleIds is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGeneratedRuleIds requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGeneratedRuleIds: %w", err)
	}
	return oldValue.GeneratedRuleIds, nil
}

// AppendGeneratedRuleIds adds s to the "generated_rule_ids" field.
func (m *PortKnockSequenceMutation) AppendGeneratedRuleIds(s []string) {
	m.appendgenerated_rule_ids = append(m.appendgenerated_rule_ids, s...)
}

// AppendedGeneratedRuleIds returns the list of values that were appended to the "generated_rule_ids" field in this mutation.
func (m *PortKnockSequenceMutation) AppendedGeneratedRuleIds() ([]string, bool) {
	if len(m.appendgenerated_rule_ids) == 0 {
		return nil, false
	}
	return m.appendgenerated_rule_ids, true
}

// ClearGeneratedRuleIds clears the value of the "generated_rule_ids" field.
func (m *PortKnockSequenceMutation) ClearGeneratedRuleIds() {
	m.generated_rule_ids = nil
	m.appendgenerated_rule_ids = nil
	m.clearedFields[portknocksequence.FieldGeneratedRuleIds] = struct{}{}
}

// GeneratedRuleIdsCleared returns if the "generated_rule_ids" field was cleared in this mutation.
func (m *PortKnockSequenceMutation) GeneratedRuleIdsCleared() bool {
	_, ok := m.clearedFields[portknocksequence.FieldGeneratedRuleIds]
	return ok
}

// ResetGeneratedRuleIds resets all changes to the "generated_rule_ids" field.
func (m *PortKnockSequenceMutation) ResetGeneratedRuleIds() {
	m.generated_rule_ids = nil
	m.appendgenerated_rule_ids = nil
	delete(m.clearedFields, portknocksequence.FieldGeneratedRuleIds)
}

// SetRecentAccessCount sets the "recent_access_count" field.
func (m *PortKnockSequenceMutation) SetRecentAccessCount(i int) {
	m.recent_access_count = &i
	m.addrecent_access_count = nil
}

// RecentAccessCount returns the value of the "recent_access_count" field in the mutation.
func (m *PortKnockSequenceMutation) RecentAccessCount() (r int, exists bool) {
	v := m.recent_access_count
	if v == nil {
		return
	}
	return *v, true
}

// OldRecentAccessCount returns the old "recent_access_count" field's value of the PortKnockSequence entity.
// If the PortKnockSequence object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PortKnockSequenceMutation) OldRecentAccessCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRecentAccessCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRecentAccessCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRecentAccessCount: %w", err)
	}
	return oldValue.RecentAccessCount, nil
}

// AddRecentAccessCount adds i to the "recent_access_count" field.
func (m *PortKnockSequenceMutation) AddRecentAccessCount(i int) {
	if m.addrecent_access_count != nil {
		*m.addrecent_access_count += i
	} else {
		m.addrecent_access_count = &i
	}
}

// AddedRecentAccessCount returns the value that was added to the "recent_access_count" field in this mutation.
func (m *PortKnockSequenceMutation) AddedRecentAccessCount() (r int, exists bool) {
	v := m.addrecent_access_count
	if v == nil {
		return
	}
	return *v, true
}

// ClearRecentAccessCount clears the value of the "recent_access_count" field.
func (m *PortKnockSequenceMutation) ClearRecentAccessCount() {
	m.recent_access_count = nil
	m.addrecent_access_count = nil
	m.clearedFields[portknocksequence.FieldRecentAccessCount] = struct{}{}
}

// RecentAccessCountCleared returns if the "recent_access_count" field was cleared in this mutation.
func (m *PortKnockSequenceMutation) RecentAccessCountCleared() bool {
	_, ok := m.clearedFields[portknocksequence.FieldRecentAccessCount]
	return ok
}

// ResetRecentAccessCount resets all changes to the "recent_access_count" field.
func (m *PortKnockSequenceMutation) ResetRecentAccessCount() {
	m.recent_access_count = nil
	m.addrecent_access_count = nil
	delete(m.clearedFields, portknocksequence.FieldRecentAccessCount)
}

// SetLastAccessedAt sets the "last_accessed_at" field.
func (m *PortKnockSequenceMutation) SetLastAccessedAt(t time.Time) {
	m.last_accessed_at = &t
}

// LastAccessedAt returns the value of the "last_accessed_at" field in the mutation.
func (m *PortKnockSequenceMutation) LastAccessedAt() (r time.Time, exists bool) {
	v := m.last_accessed_at
	if v == nil {
		return
	}
	return *v, true
}

// OldLastAccessedAt returns the old "last_accessed_at" field's value of the PortKnockSequence entity.
// If the PortKnockSequence object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PortKnockSequenceMutation) OldLastAccessedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastAccessedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastAccessedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastAccessedAt: %w", err)
	}
	return oldValue.LastAccessedAt, nil
}

// ClearLastAccessedAt clears the value of the "last_accessed_at" field.
func (m *PortKnockSequenceMutation) ClearLastAccessedAt() {
	m.last_accessed_at = nil
	m.clearedFields[portknocksequence.FieldLastAccessedAt] = struct{}{}
}

// LastAccessedAtCleared returns if the "last_accessed_at" field was cleared in this mutation.
func (m *PortKnockSequenceMutation) LastAccessedAtCleared() bool {
	_, ok := m.clearedFields[portknocksequence.FieldLastAccessedAt]
	return ok
}

// ResetLastAccessedAt resets all changes to the "last_accessed_at" field.
func (m *PortKnockSequenceMutation) ResetLastAccessedAt() {
	m.last_accessed_at = nil
	delete(m.clearedFields, portknocksequence.FieldLastAccessedAt)
}

// SetCreatedAt sets the "created_at" field.
func (m *PortKnockSequenceMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PortKnockSequenceMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the PortKnockSequence entity.
// If the PortKnockSequence object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PortKnockSequenceMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PortKnockSequenceMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PortKnockSequenceMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PortKnockSequenceMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the PortKnockSequence entity.
// If the PortKnockSequence object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PortKnockSequenceMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PortKnockSequenceMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearRouter clears the "router" edge to the Router entity.
func (m *PortKnockSequenceMutation) ClearRouter() {
	m.clearedrouter = true
	m.clearedFields[portknocksequence.FieldRouterID] = struct{}{}
}

// RouterCleared reports if the "router" edge to the Router entity was cleared.
func (m *PortKnockSequenceMutation) RouterCleared() bool {
	return m.clearedrouter
}

// RouterIDs returns the "router" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RouterID instead. It exists only for internal usage by the builders.
func (m *PortKnockSequenceMutation) RouterIDs() (ids []string) {
	if id := m.router; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRouter resets all changes to the "router" edge.
func (m *PortKnockSequenceMutation) ResetRouter() {
	m.router = nil
	m.clearedrouter = false
}

// Where appends a list predicates to the PortKnockSequenceMutation builder.
func (m *PortKnockSequenceMutation) Where(ps ...predicate.PortKnockSequence) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PortKnockSequenceMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PortKnockSequenceMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PortKnockSequence, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PortKnockSequenceMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PortKnockSequenceMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PortKnockSequence).
func (m *PortKnockSequenceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PortKnockSequenceMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.name != nil {
		fields = append(fields, portknocksequence.FieldName)
	}
	if m.knock_ports != nil {
		fields = append(fields, portknocksequence.FieldKnockPorts)
	}
	if m.protected_port != nil {
		fields = append(fields, portknocksequence.FieldProtectedPort)
	}
	if m.protected_protocol != nil {
		fields = append(fields, portknocksequence.FieldProtectedProtocol)
	}
	if m.access_timeout != nil {
		fields = append(fields, portknocksequence.FieldAccessTimeout)
	}
	if m.knock_timeout != nil {
		fields = append(fields, portknocksequence.FieldKnockTimeout)
	}
	if m.enabled != nil {
		fields = append(fields, portknocksequence.FieldEnabled)
	}
	if m.router != nil {
		fields = append(fields, portknocksequence.FieldRouterID)
	}
	if m.generated_rule_ids != nil {
		fields = append(fields, portknocksequence.FieldGeneratedRuleIds)
	}
	if m.recent_access_count != nil {
		fields = append(fields, portknocksequence.FieldRecentAccessCount)
	}
	if m.last_accessed_at != nil {
		fields = append(fields, portknocksequence.FieldLastAccessedAt)
	}
	if m.created_at != nil {
		fields = append(fields, portknocksequence.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, portknocksequence.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PortKnockSequenceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case portknocksequence.FieldName:
		return m.Name()
	case portknocksequence.FieldKnockPorts:
		return m.KnockPorts()
	case portknocksequence.FieldProtectedPort:
		return m.ProtectedPort()
	case portknocksequence.FieldProtectedProtocol:
		return m.ProtectedProtocol()
	case portknocksequence.FieldAccessTimeout:
		return m.AccessTimeout()
	case portknocksequence.FieldKnockTimeout:
		return m.KnockTimeout()
	case portknocksequence.FieldEnabled:
		return m.Enabled()
	case portknocksequence.FieldRouterID:
		return m.RouterID()
	case portknocksequence.FieldGeneratedRuleIds:
		return m.GeneratedRuleIds()
	case portknocksequence.FieldRecentAccessCount:
		return m.RecentAccessCount()
	case portknocksequence.FieldLastAccessedAt:
		return m.LastAccessedAt()
	case portknocksequence.FieldCreatedAt:
		return m.CreatedAt()
	case portknocksequence.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PortKnockSequenceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case portknocksequence.FieldName:
		return m.OldName(ctx)
	case portknocksequence.FieldKnockPorts:
		return m.OldKnockPorts(ctx)
	case portknocksequence.FieldProtectedPort:
		return m.OldProtectedPort(ctx)
	case portknocksequence.FieldProtectedProtocol:
		return m.OldProtectedProtocol(ctx)
	case portknocksequence.FieldAccessTimeout:
		return m.OldAccessTimeout(ctx)
	case portknocksequence.FieldKnockTimeout:
		return m.OldKnockTimeout(ctx)
	case portknocksequence.FieldEnabled:
		return m.OldEnabled(ctx)
	case portknocksequence.FieldRouterID:
		return m.OldRouterID(ctx)
	case portknocksequence.FieldGeneratedRuleIds:
		return m.OldGeneratedRuleIds(ctx)
	case portknocksequence.FieldRecentAccessCount:
		return m.OldRecentAccessCount(ctx)
	case portknocksequence.FieldLastAccessedAt:
		return m.OldLastAccessedAt(ctx)
	case portknocksequence.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case portknocksequence.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown PortKnockSequence field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PortKnockSequenceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case portknocksequence.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case portknocksequence.FieldKnockPorts:
		v, ok := value.([]map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKnockPorts(v)
		return nil
	case portknocksequence.FieldProtectedPort:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProtectedPort(v)
		return nil
	case portknocksequence.FieldProtectedProtocol:
		v, ok := value.(portknocksequence.ProtectedProtocol)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProtectedProtocol(v)
		return nil
	case portknocksequence.FieldAccessTimeout:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccessTimeout(v)
		return nil
	case portknocksequence.FieldKnockTimeout:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKnockTimeout(v)
		return nil
	case portknocksequence.FieldEnabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnabled(v)
		return nil
	case portknocksequence.FieldRouterID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRouterID(v)
		return nil
	case portknocksequence.FieldGeneratedRuleIds:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGeneratedRuleIds(v)
		return nil
	case portknocksequence.FieldRecentAccessCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRecentAccessCount(v)
		return nil
	case portknocksequence.FieldLastAccessedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastAccessedAt(v)
		return nil
	case portknocksequence.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case portknocksequence.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown PortKnockSequence field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PortKnockSequenceMutation) AddedFields() []string {
	var fields []string
	if m.addprotected_port != nil {
		fields = append(fields, portknocksequence.FieldProtectedPort)
	}
	if m.addrecent_access_count != nil {
		fields = append(fields, portknocksequence.FieldRecentAccessCount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PortKnockSequenceMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case portknocksequence.FieldProtectedPort:
		return m.AddedProtectedPort()
	case portknocksequence.FieldRecentAccessCount:
		return m.AddedRecentAccessCount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PortKnockSequenceMutation) AddField(name string, value ent.Value) error {
	switch name {
	case portknocksequence.FieldProtectedPort:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddProtectedPort(v)
		return nil
	case portknocksequence.FieldRecentAccessCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRecentAccessCount(v)
		return nil
	}
	return fmt.Errorf("unknown PortKnockSequence numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PortKnockSequenceMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(portknocksequence.FieldGeneratedRuleIds) {
		fields = append(fields, portknocksequence.FieldGeneratedRuleIds)
	}
	if m.FieldCleared(portknocksequence.FieldRecentAccessCount) {
		fields = append(fields, portknocksequence.FieldRecentAccessCount)
	}
	if m.FieldCleared(portknocksequence.FieldLastAccessedAt) {
		fields = append(fields, portknocksequence.FieldLastAccessedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PortKnockSequenceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PortKnockSequenceMutation) ClearField(name string) error {
	switch name {
	case portknocksequence.FieldGeneratedRuleIds:
		m.ClearGeneratedRuleIds()
		return nil
	case portknocksequence.FieldRecentAccessCount:
		m.ClearRecentAccessCount()
		return nil
	case portknocksequence.FieldLastAccessedAt:
		m.ClearLastAccessedAt()
		return nil
	}
	return fmt.Errorf("unknown PortKnockSequence nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PortKnockSequenceMutation) ResetField(name string) error {
	switch name {
	case portknocksequence.FieldName:
		m.ResetName()
		return nil
	case portknocksequence.FieldKnockPorts:
		m.ResetKnockPorts()
		return nil
	case portknocksequence.FieldProtectedPort:
		m.ResetProtectedPort()
		return nil
	case portknocksequence.FieldProtectedProtocol:
		m.ResetProtectedProtocol()
		return nil
	case portknocksequence.FieldAccessTimeout:
		m.ResetAccessTimeout()
		return nil
	case portknocksequence.FieldKnockTimeout:
		m.ResetKnockTimeout()
		return nil
	case portknocksequence.FieldEnabled:
		m.ResetEnabled()
		return nil
	case portknocksequence.FieldRouterID:
		m.ResetRouterID()
		return nil
	case portknocksequence.FieldGeneratedRuleIds:
		m.ResetGeneratedRuleIds()
		return nil
	case portknocksequence.FieldRecentAccessCount:
		m.ResetRecentAccessCount()
		return nil
	case portknocksequence.FieldLastAccessedAt:
		m.ResetLastAccessedAt()
		return nil
	case portknocksequence.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case portknocksequence.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown PortKnockSequence field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PortKnockSequenceMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.router != nil {
		edges = append(edges, portknocksequence.EdgeRouter)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PortKnockSequenceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case portknocksequence.EdgeRouter:
		if id := m.router; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PortKnockSequenceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PortKnockSequenceMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PortKnockSequenceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedrouter {
		edges = append(edges, portknocksequence.EdgeRouter)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PortKnockSequenceMutation) EdgeCleared(name string) bool {
	switch name {
	case portknocksequence.EdgeRouter:
		return m.clearedrouter
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PortKnockSequenceMutation) ClearEdge(name string) error {
	switch name {
	case portknocksequence.EdgeRouter:
		m.ClearRouter()
		return nil
	}
	return fmt.Errorf("unknown PortKnockSequence unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PortKnockSequenceMutation) ResetEdge(name string) error {
	switch name {
	case portknocksequence.EdgeRouter:
		m.ResetRouter()
		return nil
	}
	return fmt.Errorf("unknown PortKnockSequence edge %s", name)
}

// ResourceMutation represents an operation that mutates the Resource nodes in the graph.
type ResourceMutation struct {
	config
	op                 Op
	typ                string
	id                 *string
	_type              *string
	category           *string
	ros_id             *string
	configuration      *map[string]interface{}
	validation         *map[string]interface{}
	deployment         *map[string]interface{}
	runtime            *map[string]interface{}
	telemetry          *map[string]interface{}
	metadata           *map[string]interface{}
	relationships      *map[string]interface{}
	platform           *map[string]interface{}
	sync_status        *resource.SyncStatus
	enabled            *bool
	managed            *bool
	version            *int64
	addversion         *int64
	created_at         *time.Time
	updated_at         *time.Time
	synced_at          *time.Time
	router_modified_at *time.Time
	clearedFields      map[string]struct{}
	events             map[string]struct{}
	removedevents      map[string]struct{}
	clearedevents      bool
	done               bool
	oldValue           func(context.Context) (*Resource, error)
	predicates         []predicate.Resource
}

var _ ent.Mutation = (*ResourceMutation)(nil)

// resourceOption allows management of the mutation configuration using functional options.
type resourceOption func(*ResourceMutation)

// newResourceMutation creates new mutation for the Resource entity.
func newResourceMutation(c config, op Op, opts ...resourceOption) *ResourceMutation {
	m := &ResourceMutation{
		config:        c,
		op:            op,
		typ:           TypeResource,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withResourceID sets the ID field of the mutation.
func withResourceID(id string) resourceOption {
	return func(m *ResourceMutation) {
		var (
			err   error
			once  sync.Once
			value *Resource
		)
		m.oldValue = func(ctx context.Context) (*Resource, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Resource.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withResource sets the old Resource of the mutation.
func withResource(node *Resource) resourceOption {
	return func(m *ResourceMutation) {
		m.oldValue = func(context.Context) (*Resource, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ResourceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ResourceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Resource entities.
func (m *ResourceMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ResourceMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ResourceMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Resource.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetType sets the "type" field.
func (m *ResourceMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *ResourceMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Resource entity.
// If the Resource object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *ResourceMutation) ResetType() {
	m._type = nil
}

// SetCategory sets the "category" field.
func (m *ResourceMutation) SetCategory(s string) {
	m.category = &s
}

// Category returns the value of the "category" field in the mutation.
func (m *ResourceMutation) Category() (r string, exists bool) {
	v := m.category
	if v == nil {
		return
	}
	return *v, true
}

// OldCategory returns the old "category" field's value of the Resource entity.
// If the Resource object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceMutation) OldCategory(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategory: %w", err)
	}
	return oldValue.Category, nil
}

// ResetCategory resets all changes to the "category" field.
func (m *ResourceMutation) ResetCategory() {
	m.category = nil
}

// SetRosID sets the "ros_id" field.
func (m *ResourceMutation) SetRosID(s string) {
	m.ros_id = &s
}

// RosID returns the value of the "ros_id" field in the mutation.
func (m *ResourceMutation) RosID() (r string, exists bool) {
	v := m.ros_id
	if v == nil {
		return
	}
	return *v, true
}

// OldRosID returns the old "ros_id" field's value of the Resource entity.
// If the Resource object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceMutation) OldRosID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRosID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRosID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRosID: %w", err)
	}
	return oldValue.RosID, nil
}

// ClearRosID clears the value of the "ros_id" field.
func (m *ResourceMutation) ClearRosID() {
	m.ros_id = nil
	m.clearedFields[resource.FieldRosID] = struct{}{}
}

// RosIDCleared returns if the "ros_id" field was cleared in this mutation.
func (m *ResourceMutation) RosIDCleared() bool {
	_, ok := m.clearedFields[resource.FieldRosID]
	return ok
}

// ResetRosID resets all changes to the "ros_id" field.
func (m *ResourceMutation) ResetRosID() {
	m.ros_id = nil
	delete(m.clearedFields, resource.FieldRosID)
}

// SetConfiguration sets the "configuration" field.
func (m *ResourceMutation) SetConfiguration(value map[string]interface{}) {
	m.configuration = &value
}

// Configuration returns the value of the "configuration" field in the mutation.
func (m *ResourceMutation) Configuration() (r map[string]interface{}, exists bool) {
	v := m.configuration
	if v == nil {
		return
	}
	return *v, true
}

// OldConfiguration returns the old "configuration" field's value of the Resource entity.
// If the Resource object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceMutation) OldConfiguration(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConfiguration is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConfiguration requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConfiguration: %w", err)
	}
	return oldValue.Configuration, nil
}

// ResetConfiguration resets all changes to the "configuration" field.
func (m *ResourceMutation) ResetConfiguration() {
	m.configuration = nil
}

// SetValidation sets the "validation" field.
func (m *ResourceMutation) SetValidation(value map[string]interface{}) {
	m.validation = &value
}

// Validation returns the value of the "validation" field in the mutation.
func (m *ResourceMutation) Validation() (r map[string]interface{}, exists bool) {
	v := m.validation
	if v == nil {
		return
	}
	return *v, true
}

// OldValidation returns the old "validation" field's value of the Resource entity.
// If the Resource object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceMutation) OldValidation(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValidation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValidation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValidation: %w", err)
	}
	return oldValue.Validation, nil
}

// ClearValidation clears the value of the "validation" field.
func (m *ResourceMutation) ClearValidation() {
	m.validation = nil
	m.clearedFields[resource.FieldValidation] = struct{}{}
}

// ValidationCleared returns if the "validation" field was cleared in this mutation.
func (m *ResourceMutation) ValidationCleared() bool {
	_, ok := m.clearedFields[resource.FieldValidation]
	return ok
}

// ResetValidation resets all changes to the "validation" field.
func (m *ResourceMutation) ResetValidation() {
	m.validation = nil
	delete(m.clearedFields, resource.FieldValidation)
}

// SetDeployment sets the "deployment" field.
func (m *ResourceMutation) SetDeployment(value map[string]interface{}) {
	m.deployment = &value
}

// Deployment returns the value of the "deployment" field in the mutation.
func (m *ResourceMutation) Deployment() (r map[string]interface{}, exists bool) {
	v := m.deployment
	if v == nil {
		return
	}
	return *v, true
}

// OldDeployment returns the old "deployment" field's value of the Resource entity.
// If the Resource object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceMutation) OldDeployment(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeployment is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeployment requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeployment: %w", err)
	}
	return oldValue.Deployment, nil
}

// ClearDeployment clears the value of the "deployment" field.
func (m *ResourceMutation) ClearDeployment() {
	m.deployment = nil
	m.clearedFields[resource.FieldDeployment] = struct{}{}
}

// DeploymentCleared returns if the "deployment" field was cleared in this mutation.
func (m *ResourceMutation) DeploymentCleared() bool {
	_, ok := m.clearedFields[resource.FieldDeployment]
	return ok
}

// ResetDeployment resets all changes to the "deployment" field.
func (m *ResourceMutation) ResetDeployment() {
	m.deployment = nil
	delete(m.clearedFields, resource.FieldDeployment)
}

// SetRuntime sets the "runtime" field.
func (m *ResourceMutation) SetRuntime(value map[string]interface{}) {
	m.runtime = &value
}

// Runtime returns the value of the "runtime" field in the mutation.
func (m *ResourceMutation) Runtime() (r map[string]interface{}, exists bool) {
	v := m.runtime
	if v == nil {
		return
	}
	return *v, true
}

// OldRuntime returns the old "runtime" field's value of the Resource entity.
// If the Resource object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceMutation) OldRuntime(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRuntime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRuntime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRuntime: %w", err)
	}
	return oldValue.Runtime, nil
}

// ClearRuntime clears the value of the "runtime" field.
func (m *ResourceMutation) ClearRuntime() {
	m.runtime = nil
	m.clearedFields[resource.FieldRuntime] = struct{}{}
}

// RuntimeCleared returns if the "runtime" field was cleared in this mutation.
func (m *ResourceMutation) RuntimeCleared() bool {
	_, ok := m.clearedFields[resource.FieldRuntime]
	return ok
}

// ResetRuntime resets all changes to the "runtime" field.
func (m *ResourceMutation) ResetRuntime() {
	m.runtime = nil
	delete(m.clearedFields, resource.FieldRuntime)
}

// SetTelemetry sets the "telemetry" field.
func (m *ResourceMutation) SetTelemetry(value map[string]interface{}) {
	m.telemetry = &value
}

// Telemetry returns the value of the "telemetry" field in the mutation.
func (m *ResourceMutation) Telemetry() (r map[string]interface{}, exists bool) {
	v := m.telemetry
	if v == nil {
		return
	}
	return *v, true
}

// OldTelemetry returns the old "telemetry" field's value of the Resource entity.
// If the Resource object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceMutation) OldTelemetry(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTelemetry is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTelemetry requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTelemetry: %w", err)
	}
	return oldValue.Telemetry, nil
}

// ClearTelemetry clears the value of the "telemetry" field.
func (m *ResourceMutation) ClearTelemetry() {
	m.telemetry = nil
	m.clearedFields[resource.FieldTelemetry] = struct{}{}
}

// TelemetryCleared returns if the "telemetry" field was cleared in this mutation.
func (m *ResourceMutation) TelemetryCleared() bool {
	_, ok := m.clearedFields[resource.FieldTelemetry]
	return ok
}

// ResetTelemetry resets all changes to the "telemetry" field.
func (m *ResourceMutation) ResetTelemetry() {
	m.telemetry = nil
	delete(m.clearedFields, resource.FieldTelemetry)
}

// SetMetadata sets the "metadata" field.
func (m *ResourceMutation) SetMetadata(value map[string]interface{}) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *ResourceMutation) Metadata() (r map[string]interface{}, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the Resource entity.
// If the Resource object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceMutation) OldMetadata(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *ResourceMutation) ResetMetadata() {
	m.metadata = nil
}

// SetRelationships sets the "relationships" field.
func (m *ResourceMutation) SetRelationships(value map[string]interface{}) {
	m.relationships = &value
}

// Relationships returns the value of the "relationships" field in the mutation.
func (m *ResourceMutation) Relationships() (r map[string]interface{}, exists bool) {
	v := m.relationships
	if v == nil {
		return
	}
	return *v, true
}

// OldRelationships returns the old "relationships" field's value of the Resource entity.
// If the Resource object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceMutation) OldRelationships(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRelationships is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRelationships requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRelationships: %w", err)
	}
	return oldValue.Relationships, nil
}

// ClearRelationships clears the value of the "relationships" field.
func (m *ResourceMutation) ClearRelationships() {
	m.relationships = nil
	m.clearedFields[resource.FieldRelationships] = struct{}{}
}

// RelationshipsCleared returns if the "relationships" field was cleared in this mutation.
func (m *ResourceMutation) RelationshipsCleared() bool {
	_, ok := m.clearedFields[resource.FieldRelationships]
	return ok
}

// ResetRelationships resets all changes to the "relationships" field.
func (m *ResourceMutation) ResetRelationships() {
	m.relationships = nil
	delete(m.clearedFields, resource.FieldRelationships)
}

// SetPlatform sets the "platform" field.
func (m *ResourceMutation) SetPlatform(value map[string]interface{}) {
	m.platform = &value
}

// Platform returns the value of the "platform" field in the mutation.
func (m *ResourceMutation) Platform() (r map[string]interface{}, exists bool) {
	v := m.platform
	if v == nil {
		return
	}
	return *v, true
}

// OldPlatform returns the old "platform" field's value of the Resource entity.
// If the Resource object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceMutation) OldPlatform(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPlatform is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPlatform requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPlatform: %w", err)
	}
	return oldValue.Platform, nil
}

// ClearPlatform clears the value of the "platform" field.
func (m *ResourceMutation) ClearPlatform() {
	m.platform = nil
	m.clearedFields[resource.FieldPlatform] = struct{}{}
}

// PlatformCleared returns if the "platform" field was cleared in this mutation.
func (m *ResourceMutation) PlatformCleared() bool {
	_, ok := m.clearedFields[resource.FieldPlatform]
	return ok
}

// ResetPlatform resets all changes to the "platform" field.
func (m *ResourceMutation) ResetPlatform() {
	m.platform = nil
	delete(m.clearedFields, resource.FieldPlatform)
}

// SetSyncStatus sets the "sync_status" field.
func (m *ResourceMutation) SetSyncStatus(rs resource.SyncStatus) {
	m.sync_status = &rs
}

// SyncStatus returns the value of the "sync_status" field in the mutation.
func (m *ResourceMutation) SyncStatus() (r resource.SyncStatus, exists bool) {
	v := m.sync_status
	if v == nil {
		return
	}
	return *v, true
}

// OldSyncStatus returns the old "sync_status" field's value of the Resource entity.
// If the Resource object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceMutation) OldSyncStatus(ctx context.Context) (v resource.SyncStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSyncStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSyncStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSyncStatus: %w", err)
	}
	return oldValue.SyncStatus, nil
}

// ResetSyncStatus resets all changes to the "sync_status" field.
func (m *ResourceMutation) ResetSyncStatus() {
	m.sync_status = nil
}

// SetEnabled sets the "enabled" field.
func (m *ResourceMutation) SetEnabled(b bool) {
	m.enabled = &b
}

// Enabled returns the value of the "enabled" field in the mutation.
func (m *ResourceMutation) Enabled() (r bool, exists bool) {
	v := m.enabled
	if v == nil {
		return
	}
	return *v, true
}

// OldEnabled returns the old "enabled" field's value of the Resource entity.
// If the Resource object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceMutation) OldEnabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnabled: %w", err)
	}
	return oldValue.Enabled, nil
}

// ResetEnabled resets all changes to the "enabled" field.
func (m *ResourceMutation) ResetEnabled() {
	m.enabled = nil
}

// SetManaged sets the "managed" field.
func (m *ResourceMutation) SetManaged(b bool) {
	m.managed = &b
}

// Managed returns the value of the "managed" field in the mutation.
func (m *ResourceMutation) Managed() (r bool, exists bool) {
	v := m.managed
	if v == nil {
		return
	}
	return *v, true
}

// OldManaged returns the old "managed" field's value of the Resource entity.
// If the Resource object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceMutation) OldManaged(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldManaged is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldManaged requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldManaged: %w", err)
	}
	return oldValue.Managed, nil
}

// ResetManaged resets all changes to the "managed" field.
func (m *ResourceMutation) ResetManaged() {
	m.managed = nil
}

// SetVersion sets the "version" field.
func (m *ResourceMutation) SetVersion(i int64) {
	m.version = &i
	m.addversion = nil
}

// Version returns the value of the "version" field in the mutation.
func (m *ResourceMutation) Version() (r int64, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the Resource entity.
// If the Resource object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceMutation) OldVersion(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// AddVersion adds i to the "version" field.
func (m *ResourceMutation) AddVersion(i int64) {
	if m.addversion != nil {
		*m.addversion += i
	} else {
		m.addversion = &i
	}
}

// AddedVersion returns the value that was added to the "version" field in this mutation.
func (m *ResourceMutation) AddedVersion() (r int64, exists bool) {
	v := m.addversion
	if v == nil {
		return
	}
	return *v, true
}

// ResetVersion resets all changes to the "version" field.
func (m *ResourceMutation) ResetVersion() {
	m.version = nil
	m.addversion = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ResourceMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ResourceMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Resource entity.
// If the Resource object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ResourceMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ResourceMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ResourceMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Resource entity.
// If the Resource object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ResourceMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetSyncedAt sets the "synced_at" field.
func (m *ResourceMutation) SetSyncedAt(t time.Time) {
	m.synced_at = &t
}

// SyncedAt returns the value of the "synced_at" field in the mutation.
func (m *ResourceMutation) SyncedAt() (r time.Time, exists bool) {
	v := m.synced_at
	if v == nil {
		return
	}
	return *v, true
}

// OldSyncedAt returns the old "synced_at" field's value of the Resource entity.
// If the Resource object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceMutation) OldSyncedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSyncedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSyncedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSyncedAt: %w", err)
	}
	return oldValue.SyncedAt, nil
}

// ClearSyncedAt clears the value of the "synced_at" field.
func (m *ResourceMutation) ClearSyncedAt() {
	m.synced_at = nil
	m.clearedFields[resource.FieldSyncedAt] = struct{}{}
}

// SyncedAtCleared returns if the "synced_at" field was cleared in this mutation.
func (m *ResourceMutation) SyncedAtCleared() bool {
	_, ok := m.clearedFields[resource.FieldSyncedAt]
	return ok
}

// ResetSyncedAt resets all changes to the "synced_at" field.
func (m *ResourceMutation) ResetSyncedAt() {
	m.synced_at = nil
	delete(m.clearedFields, resource.FieldSyncedAt)
}

// SetRouterModifiedAt sets the "router_modified_at" field.
func (m *ResourceMutation) SetRouterModifiedAt(t time.Time) {
	m.router_modified_at = &t
}

// RouterModifiedAt returns the value of the "router_modified_at" field in the mutation.
func (m *ResourceMutation) RouterModifiedAt() (r time.Time, exists bool) {
	v := m.router_modified_at
	if v == nil {
		return
	}
	return *v, true
}

// OldRouterModifiedAt returns the old "router_modified_at" field's value of the Resource entity.
// If the Resource object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceMutation) OldRouterModifiedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRouterModifiedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRouterModifiedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRouterModifiedAt: %w", err)
	}
	return oldValue.RouterModifiedAt, nil
}

// ClearRouterModifiedAt clears the value of the "router_modified_at" field.
func (m *ResourceMutation) ClearRouterModifiedAt() {
	m.router_modified_at = nil
	m.clearedFields[resource.FieldRouterModifiedAt] = struct{}{}
}

// RouterModifiedAtCleared returns if the "router_modified_at" field was cleared in this mutation.
func (m *ResourceMutation) RouterModifiedAtCleared() bool {
	_, ok := m.clearedFields[resource.FieldRouterModifiedAt]
	return ok
}

// ResetRouterModifiedAt resets all changes to the "router_modified_at" field.
func (m *ResourceMutation) ResetRouterModifiedAt() {
	m.router_modified_at = nil
	delete(m.clearedFields, resource.FieldRouterModifiedAt)
}

// AddEventIDs adds the "events" edge to the ResourceEvent entity by ids.
func (m *ResourceMutation) AddEventIDs(ids ...string) {
	if m.events == nil {
		m.events = make(map[string]struct{})
	}
	for i := range ids {
		m.events[ids[i]] = struct{}{}
	}
}

// ClearEvents clears the "events" edge to the ResourceEvent entity.
func (m *ResourceMutation) ClearEvents() {
	m.clearedevents = true
}

// EventsCleared reports if the "events" edge to the ResourceEvent entity was cleared.
func (m *ResourceMutation) EventsCleared() bool {
	return m.clearedevents
}

// RemoveEventIDs removes the "events" edge to the ResourceEvent entity by IDs.
func (m *ResourceMutation) RemoveEventIDs(ids ...string) {
	if m.removedevents == nil {
		m.removedevents = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.events, ids[i])
		m.removedevents[ids[i]] = struct{}{}
	}
}

// RemovedEvents returns the removed IDs of the "events" edge to the ResourceEvent entity.
func (m *ResourceMutation) RemovedEventsIDs() (ids []string) {
	for id := range m.removedevents {
		ids = append(ids, id)
	}
	return
}

// EventsIDs returns the "events" edge IDs in the mutation.
func (m *ResourceMutation) EventsIDs() (ids []string) {
	for id := range m.events {
		ids = append(ids, id)
	}
	return
}

// ResetEvents resets all changes to the "events" edge.
func (m *ResourceMutation) ResetEvents() {
	m.events = nil
	m.clearedevents = false
	m.removedevents = nil
}

// Where appends a list predicates to the ResourceMutation builder.
func (m *ResourceMutation) Where(ps ...predicate.Resource) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ResourceMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ResourceMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Resource, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ResourceMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ResourceMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Resource).
func (m *ResourceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ResourceMutation) Fields() []string {
	fields := make([]string, 0, 19)
	if m._type != nil {
		fields = append(fields, resource.FieldType)
	}
	if m.category != nil {
		fields = append(fields, resource.FieldCategory)
	}
	if m.ros_id != nil {
		fields = append(fields, resource.FieldRosID)
	}
	if m.configuration != nil {
		fields = append(fields, resource.FieldConfiguration)
	}
	if m.validation != nil {
		fields = append(fields, resource.FieldValidation)
	}
	if m.deployment != nil {
		fields = append(fields, resource.FieldDeployment)
	}
	if m.runtime != nil {
		fields = append(fields, resource.FieldRuntime)
	}
	if m.telemetry != nil {
		fields = append(fields, resource.FieldTelemetry)
	}
	if m.metadata != nil {
		fields = append(fields, resource.FieldMetadata)
	}
	if m.relationships != nil {
		fields = append(fields, resource.FieldRelationships)
	}
	if m.platform != nil {
		fields = append(fields, resource.FieldPlatform)
	}
	if m.sync_status != nil {
		fields = append(fields, resource.FieldSyncStatus)
	}
	if m.enabled != nil {
		fields = append(fields, resource.FieldEnabled)
	}
	if m.managed != nil {
		fields = append(fields, resource.FieldManaged)
	}
	if m.version != nil {
		fields = append(fields, resource.FieldVersion)
	}
	if m.created_at != nil {
		fields = append(fields, resource.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, resource.FieldUpdatedAt)
	}
	if m.synced_at != nil {
		fields = append(fields, resource.FieldSyncedAt)
	}
	if m.router_modified_at != nil {
		fields = append(fields, resource.FieldRouterModifiedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ResourceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case resource.FieldType:
		return m.GetType()
	case resource.FieldCategory:
		return m.Category()
	case resource.FieldRosID:
		return m.RosID()
	case resource.FieldConfiguration:
		return m.Configuration()
	case resource.FieldValidation:
		return m.Validation()
	case resource.FieldDeployment:
		return m.Deployment()
	case resource.FieldRuntime:
		return m.Runtime()
	case resource.FieldTelemetry:
		return m.Telemetry()
	case resource.FieldMetadata:
		return m.Metadata()
	case resource.FieldRelationships:
		return m.Relationships()
	case resource.FieldPlatform:
		return m.Platform()
	case resource.FieldSyncStatus:
		return m.SyncStatus()
	case resource.FieldEnabled:
		return m.Enabled()
	case resource.FieldManaged:
		return m.Managed()
	case resource.FieldVersion:
		return m.Version()
	case resource.FieldCreatedAt:
		return m.CreatedAt()
	case resource.FieldUpdatedAt:
		return m.UpdatedAt()
	case resource.FieldSyncedAt:
		return m.SyncedAt()
	case resource.FieldRouterModifiedAt:
		return m.RouterModifiedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ResourceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case resource.FieldType:
		return m.OldType(ctx)
	case resource.FieldCategory:
		return m.OldCategory(ctx)
	case resource.FieldRosID:
		return m.OldRosID(ctx)
	case resource.FieldConfiguration:
		return m.OldConfiguration(ctx)
	case resource.FieldValidation:
		return m.OldValidation(ctx)
	case resource.FieldDeployment:
		return m.OldDeployment(ctx)
	case resource.FieldRuntime:
		return m.OldRuntime(ctx)
	case resource.FieldTelemetry:
		return m.OldTelemetry(ctx)
	case resource.FieldMetadata:
		return m.OldMetadata(ctx)
	case resource.FieldRelationships:
		return m.OldRelationships(ctx)
	case resource.FieldPlatform:
		return m.OldPlatform(ctx)
	case resource.FieldSyncStatus:
		return m.OldSyncStatus(ctx)
	case resource.FieldEnabled:
		return m.OldEnabled(ctx)
	case resource.FieldManaged:
		return m.OldManaged(ctx)
	case resource.FieldVersion:
		return m.OldVersion(ctx)
	case resource.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case resource.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case resource.FieldSyncedAt:
		return m.OldSyncedAt(ctx)
	case resource.FieldRouterModifiedAt:
		return m.OldRouterModifiedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Resource field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ResourceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case resource.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case resource.FieldCategory:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategory(v)
		return nil
	case resource.FieldRosID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRosID(v)
		return nil
	case resource.FieldConfiguration:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConfiguration(v)
		return nil
	case resource.FieldValidation:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValidation(v)
		return nil
	case resource.FieldDeployment:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeployment(v)
		return nil
	case resource.FieldRuntime:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRuntime(v)
		return nil
	case resource.FieldTelemetry:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTelemetry(v)
		return nil
	case resource.FieldMetadata:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	case resource.FieldRelationships:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRelationships(v)
		return nil
	case resource.FieldPlatform:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPlatform(v)
		return nil
	case resource.FieldSyncStatus:
		v, ok := value.(resource.SyncStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSyncStatus(v)
		return nil
	case resource.FieldEnabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnabled(v)
		return nil
	case resource.FieldManaged:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetManaged(v)
		return nil
	case resource.FieldVersion:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case resource.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case resource.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case resource.FieldSyncedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSyncedAt(v)
		return nil
	case resource.FieldRouterModifiedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRouterModifiedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Resource field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ResourceMutation) AddedFields() []string {
	var fields []string
	if m.addversion != nil {
		fields = append(fields, resource.FieldVersion)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ResourceMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case resource.FieldVersion:
		return m.AddedVersion()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ResourceMutation) AddField(name string, value ent.Value) error {
	switch name {
	case resource.FieldVersion:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVersion(v)
		return nil
	}
	return fmt.Errorf("unknown Resource numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ResourceMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(resource.FieldRosID) {
		fields = append(fields, resource.FieldRosID)
	}
	if m.FieldCleared(resource.FieldValidation) {
		fields = append(fields, resource.FieldValidation)
	}
	if m.FieldCleared(resource.FieldDeployment) {
		fields = append(fields, resource.FieldDeployment)
	}
	if m.FieldCleared(resource.FieldRuntime) {
		fields = append(fields, resource.FieldRuntime)
	}
	if m.FieldCleared(resource.FieldTelemetry) {
		fields = append(fields, resource.FieldTelemetry)
	}
	if m.FieldCleared(resource.FieldRelationships) {
		fields = append(fields, resource.FieldRelationships)
	}
	if m.FieldCleared(resource.FieldPlatform) {
		fields = append(fields, resource.FieldPlatform)
	}
	if m.FieldCleared(resource.FieldSyncedAt) {
		fields = append(fields, resource.FieldSyncedAt)
	}
	if m.FieldCleared(resource.FieldRouterModifiedAt) {
		fields = append(fields, resource.FieldRouterModifiedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ResourceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ResourceMutation) ClearField(name string) error {
	switch name {
	case resource.FieldRosID:
		m.ClearRosID()
		return nil
	case resource.FieldValidation:
		m.ClearValidation()
		return nil
	case resource.FieldDeployment:
		m.ClearDeployment()
		return nil
	case resource.FieldRuntime:
		m.ClearRuntime()
		return nil
	case resource.FieldTelemetry:
		m.ClearTelemetry()
		return nil
	case resource.FieldRelationships:
		m.ClearRelationships()
		return nil
	case resource.FieldPlatform:
		m.ClearPlatform()
		return nil
	case resource.FieldSyncedAt:
		m.ClearSyncedAt()
		return nil
	case resource.FieldRouterModifiedAt:
		m.ClearRouterModifiedAt()
		return nil
	}
	return fmt.Errorf("unknown Resource nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ResourceMutation) ResetField(name string) error {
	switch name {
	case resource.FieldType:
		m.ResetType()
		return nil
	case resource.FieldCategory:
		m.ResetCategory()
		return nil
	case resource.FieldRosID:
		m.ResetRosID()
		return nil
	case resource.FieldConfiguration:
		m.ResetConfiguration()
		return nil
	case resource.FieldValidation:
		m.ResetValidation()
		return nil
	case resource.FieldDeployment:
		m.ResetDeployment()
		return nil
	case resource.FieldRuntime:
		m.ResetRuntime()
		return nil
	case resource.FieldTelemetry:
		m.ResetTelemetry()
		return nil
	case resource.FieldMetadata:
		m.ResetMetadata()
		return nil
	case resource.FieldRelationships:
		m.ResetRelationships()
		return nil
	case resource.FieldPlatform:
		m.ResetPlatform()
		return nil
	case resource.FieldSyncStatus:
		m.ResetSyncStatus()
		return nil
	case resource.FieldEnabled:
		m.ResetEnabled()
		return nil
	case resource.FieldManaged:
		m.ResetManaged()
		return nil
	case resource.FieldVersion:
		m.ResetVersion()
		return nil
	case resource.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case resource.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case resource.FieldSyncedAt:
		m.ResetSyncedAt()
		return nil
	case resource.FieldRouterModifiedAt:
		m.ResetRouterModifiedAt()
		return nil
	}
	return fmt.Errorf("unknown Resource field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ResourceMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.events != nil {
		edges = append(edges, resource.EdgeEvents)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ResourceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case resource.EdgeEvents:
		ids := make([]ent.Value, 0, len(m.events))
		for id := range m.events {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ResourceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedevents != nil {
		edges = append(edges, resource.EdgeEvents)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ResourceMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case resource.EdgeEvents:
		ids := make([]ent.Value, 0, len(m.removedevents))
		for id := range m.removedevents {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ResourceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedevents {
		edges = append(edges, resource.EdgeEvents)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ResourceMutation) EdgeCleared(name string) bool {
	switch name {
	case resource.EdgeEvents:
		return m.clearedevents
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ResourceMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Resource unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ResourceMutation) ResetEdge(name string) error {
	switch name {
	case resource.EdgeEvents:
		m.ResetEvents()
		return nil
	}
	return fmt.Errorf("unknown Resource edge %s", name)
}

// ResourceEventMutation represents an operation that mutates the ResourceEvent nodes in the graph.
type ResourceEventMutation struct {
	config
	op              Op
	typ             string
	id              *string
	event_type      *resourceevent.EventType
	actor           *string
	previous_state  *map[string]interface{}
	new_state       *map[string]interface{}
	diff            *map[string]interface{}
	metadata        *map[string]interface{}
	error_message   *string
	source          *resourceevent.Source
	reversible      *bool
	created_at      *time.Time
	clearedFields   map[string]struct{}
	resource        *string
	clearedresource bool
	done            bool
	oldValue        func(context.Context) (*ResourceEvent, error)
	predicates      []predicate.ResourceEvent
}

var _ ent.Mutation = (*ResourceEventMutation)(nil)

// resourceeventOption allows management of the mutation configuration using functional options.
type resourceeventOption func(*ResourceEventMutation)

// newResourceEventMutation creates new mutation for the ResourceEvent entity.
func newResourceEventMutation(c config, op Op, opts ...resourceeventOption) *ResourceEventMutation {
	m := &ResourceEventMutation{
		config:        c,
		op:            op,
		typ:           TypeResourceEvent,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withResourceEventID sets the ID field of the mutation.
func withResourceEventID(id string) resourceeventOption {
	return func(m *ResourceEventMutation) {
		var (
			err   error
			once  sync.Once
			value *ResourceEvent
		)
		m.oldValue = func(ctx context.Context) (*ResourceEvent, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ResourceEvent.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withResourceEvent sets the old ResourceEvent of the mutation.
func withResourceEvent(node *ResourceEvent) resourceeventOption {
	return func(m *ResourceEventMutation) {
		m.oldValue = func(context.Context) (*ResourceEvent, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ResourceEventMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ResourceEventMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ResourceEvent entities.
func (m *ResourceEventMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ResourceEventMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ResourceEventMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ResourceEvent.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetResourceID sets the "resource_id" field.
func (m *ResourceEventMutation) SetResourceID(s string) {
	m.resource = &s
}

// ResourceID returns the value of the "resource_id" field in the mutation.
func (m *ResourceEventMutation) ResourceID() (r string, exists bool) {
	v := m.resource
	if v == nil {
		return
	}
	return *v, true
}

// OldResourceID returns the old "resource_id" field's value of the ResourceEvent entity.
// If the ResourceEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceEventMutation) OldResourceID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResourceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResourceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResourceID: %w", err)
	}
	return oldValue.ResourceID, nil
}

// ResetResourceID resets all changes to the "resource_id" field.
func (m *ResourceEventMutation) ResetResourceID() {
	m.resource = nil
}

// SetEventType sets the "event_type" field.
func (m *ResourceEventMutation) SetEventType(rt resourceevent.EventType) {
	m.event_type = &rt
}

// EventType returns the value of the "event_type" field in the mutation.
func (m *ResourceEventMutation) EventType() (r resourceevent.EventType, exists bool) {
	v := m.event_type
	if v == nil {
		return
	}
	return *v, true
}

// OldEventType returns the old "event_type" field's value of the ResourceEvent entity.
// If the ResourceEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceEventMutation) OldEventType(ctx context.Context) (v resourceevent.EventType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEventType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEventType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEventType: %w", err)
	}
	return oldValue.EventType, nil
}

// ResetEventType resets all changes to the "event_type" field.
func (m *ResourceEventMutation) ResetEventType() {
	m.event_type = nil
}

// SetActor sets the "actor" field.
func (m *ResourceEventMutation) SetActor(s string) {
	m.actor = &s
}

// Actor returns the value of the "actor" field in the mutation.
func (m *ResourceEventMutation) Actor() (r string, exists bool) {
	v := m.actor
	if v == nil {
		return
	}
	return *v, true
}

// OldActor returns the old "actor" field's value of the ResourceEvent entity.
// If the ResourceEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceEventMutation) OldActor(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActor: %w", err)
	}
	return oldValue.Actor, nil
}

// ResetActor resets all changes to the "actor" field.
func (m *ResourceEventMutation) ResetActor() {
	m.actor = nil
}

// SetPreviousState sets the "previous_state" field.
func (m *ResourceEventMutation) SetPreviousState(value map[string]interface{}) {
	m.previous_state = &value
}

// PreviousState returns the value of the "previous_state" field in the mutation.
func (m *ResourceEventMutation) PreviousState() (r map[string]interface{}, exists bool) {
	v := m.previous_state
	if v == nil {
		return
	}
	return *v, true
}

// OldPreviousState returns the old "previous_state" field's value of the ResourceEvent entity.
// If the ResourceEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceEventMutation) OldPreviousState(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPreviousState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPreviousState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPreviousState: %w", err)
	}
	return oldValue.PreviousState, nil
}

// ClearPreviousState clears the value of the "previous_state" field.
func (m *ResourceEventMutation) ClearPreviousState() {
	m.previous_state = nil
	m.clearedFields[resourceevent.FieldPreviousState] = struct{}{}
}

// PreviousStateCleared returns if the "previous_state" field was cleared in this mutation.
func (m *ResourceEventMutation) PreviousStateCleared() bool {
	_, ok := m.clearedFields[resourceevent.FieldPreviousState]
	return ok
}

// ResetPreviousState resets all changes to the "previous_state" field.
func (m *ResourceEventMutation) ResetPreviousState() {
	m.previous_state = nil
	delete(m.clearedFields, resourceevent.FieldPreviousState)
}

// SetNewState sets the "new_state" field.
func (m *ResourceEventMutation) SetNewState(value map[string]interface{}) {
	m.new_state = &value
}

// NewState returns the value of the "new_state" field in the mutation.
func (m *ResourceEventMutation) NewState() (r map[string]interface{}, exists bool) {
	v := m.new_state
	if v == nil {
		return
	}
	return *v, true
}

// OldNewState returns the old "new_state" field's value of the ResourceEvent entity.
// If the ResourceEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceEventMutation) OldNewState(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNewState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNewState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNewState: %w", err)
	}
	return oldValue.NewState, nil
}

// ClearNewState clears the value of the "new_state" field.
func (m *ResourceEventMutation) ClearNewState() {
	m.new_state = nil
	m.clearedFields[resourceevent.FieldNewState] = struct{}{}
}

// NewStateCleared returns if the "new_state" field was cleared in this mutation.
func (m *ResourceEventMutation) NewStateCleared() bool {
	_, ok := m.clearedFields[resourceevent.FieldNewState]
	return ok
}

// ResetNewState resets all changes to the "new_state" field.
func (m *ResourceEventMutation) ResetNewState() {
	m.new_state = nil
	delete(m.clearedFields, resourceevent.FieldNewState)
}

// SetDiff sets the "diff" field.
func (m *ResourceEventMutation) SetDiff(value map[string]interface{}) {
	m.diff = &value
}

// Diff returns the value of the "diff" field in the mutation.
func (m *ResourceEventMutation) Diff() (r map[string]interface{}, exists bool) {
	v := m.diff
	if v == nil {
		return
	}
	return *v, true
}

// OldDiff returns the old "diff" field's value of the ResourceEvent entity.
// If the ResourceEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceEventMutation) OldDiff(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDiff is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDiff requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDiff: %w", err)
	}
	return oldValue.Diff, nil
}

// ClearDiff clears the value of the "diff" field.
func (m *ResourceEventMutation) ClearDiff() {
	m.diff = nil
	m.clearedFields[resourceevent.FieldDiff] = struct{}{}
}

// DiffCleared returns if the "diff" field was cleared in this mutation.
func (m *ResourceEventMutation) DiffCleared() bool {
	_, ok := m.clearedFields[resourceevent.FieldDiff]
	return ok
}

// ResetDiff resets all changes to the "diff" field.
func (m *ResourceEventMutation) ResetDiff() {
	m.diff = nil
	delete(m.clearedFields, resourceevent.FieldDiff)
}

// SetMetadata sets the "metadata" field.
func (m *ResourceEventMutation) SetMetadata(value map[string]interface{}) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *ResourceEventMutation) Metadata() (r map[string]interface{}, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the ResourceEvent entity.
// If the ResourceEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceEventMutation) OldMetadata(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *ResourceEventMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[resourceevent.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *ResourceEventMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[resourceevent.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *ResourceEventMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, resourceevent.FieldMetadata)
}

// SetErrorMessage sets the "error_message" field.
func (m *ResourceEventMutation) SetErrorMessage(s string) {
	m.error_message = &s
}

// ErrorMessage returns the value of the "error_message" field in the mutation.
func (m *ResourceEventMutation) ErrorMessage() (r string, exists bool) {
	v := m.error_message
	if v == nil {
		return
	}
	return *v, true
}

// OldErrorMessage returns the old "error_message" field's value of the ResourceEvent entity.
// If the ResourceEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceEventMutation) OldErrorMessage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldErrorMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldErrorMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldErrorMessage: %w", err)
	}
	return oldValue.ErrorMessage, nil
}

// ClearErrorMessage clears the value of the "error_message" field.
func (m *ResourceEventMutation) ClearErrorMessage() {
	m.error_message = nil
	m.clearedFields[resourceevent.FieldErrorMessage] = struct{}{}
}

// ErrorMessageCleared returns if the "error_message" field was cleared in this mutation.
func (m *ResourceEventMutation) ErrorMessageCleared() bool {
	_, ok := m.clearedFields[resourceevent.FieldErrorMessage]
	return ok
}

// ResetErrorMessage resets all changes to the "error_message" field.
func (m *ResourceEventMutation) ResetErrorMessage() {
	m.error_message = nil
	delete(m.clearedFields, resourceevent.FieldErrorMessage)
}

// SetSource sets the "source" field.
func (m *ResourceEventMutation) SetSource(r resourceevent.Source) {
	m.source = &r
}

// Source returns the value of the "source" field in the mutation.
func (m *ResourceEventMutation) Source() (r resourceevent.Source, exists bool) {
	v := m.source
	if v == nil {
		return
	}
	return *v, true
}

// OldSource returns the old "source" field's value of the ResourceEvent entity.
// If the ResourceEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceEventMutation) OldSource(ctx context.Context) (v resourceevent.Source, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSource is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSource requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSource: %w", err)
	}
	return oldValue.Source, nil
}

// ResetSource resets all changes to the "source" field.
func (m *ResourceEventMutation) ResetSource() {
	m.source = nil
}

// SetReversible sets the "reversible" field.
func (m *ResourceEventMutation) SetReversible(b bool) {
	m.reversible = &b
}

// Reversible returns the value of the "reversible" field in the mutation.
func (m *ResourceEventMutation) Reversible() (r bool, exists bool) {
	v := m.reversible
	if v == nil {
		return
	}
	return *v, true
}

// OldReversible returns the old "reversible" field's value of the ResourceEvent entity.
// If the ResourceEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceEventMutation) OldReversible(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReversible is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReversible requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReversible: %w", err)
	}
	return oldValue.Reversible, nil
}

// ResetReversible resets all changes to the "reversible" field.
func (m *ResourceEventMutation) ResetReversible() {
	m.reversible = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ResourceEventMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ResourceEventMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ResourceEvent entity.
// If the ResourceEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceEventMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ResourceEventMutation) ResetCreatedAt() {
	m.created_at = nil
}

// ClearResource clears the "resource" edge to the Resource entity.
func (m *ResourceEventMutation) ClearResource() {
	m.clearedresource = true
	m.clearedFields[resourceevent.FieldResourceID] = struct{}{}
}

// ResourceCleared reports if the "resource" edge to the Resource entity was cleared.
func (m *ResourceEventMutation) ResourceCleared() bool {
	return m.clearedresource
}

// ResourceIDs returns the "resource" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ResourceID instead. It exists only for internal usage by the builders.
func (m *ResourceEventMutation) ResourceIDs() (ids []string) {
	if id := m.resource; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetResource resets all changes to the "resource" edge.
func (m *ResourceEventMutation) ResetResource() {
	m.resource = nil
	m.clearedresource = false
}

// Where appends a list predicates to the ResourceEventMutation builder.
func (m *ResourceEventMutation) Where(ps ...predicate.ResourceEvent) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ResourceEventMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ResourceEventMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ResourceEvent, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ResourceEventMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ResourceEventMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ResourceEvent).
func (m *ResourceEventMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ResourceEventMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.resource != nil {
		fields = append(fields, resourceevent.FieldResourceID)
	}
	if m.event_type != nil {
		fields = append(fields, resourceevent.FieldEventType)
	}
	if m.actor != nil {
		fields = append(fields, resourceevent.FieldActor)
	}
	if m.previous_state != nil {
		fields = append(fields, resourceevent.FieldPreviousState)
	}
	if m.new_state != nil {
		fields = append(fields, resourceevent.FieldNewState)
	}
	if m.diff != nil {
		fields = append(fields, resourceevent.FieldDiff)
	}
	if m.metadata != nil {
		fields = append(fields, resourceevent.FieldMetadata)
	}
	if m.error_message != nil {
		fields = append(fields, resourceevent.FieldErrorMessage)
	}
	if m.source != nil {
		fields = append(fields, resourceevent.FieldSource)
	}
	if m.reversible != nil {
		fields = append(fields, resourceevent.FieldReversible)
	}
	if m.created_at != nil {
		fields = append(fields, resourceevent.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ResourceEventMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case resourceevent.FieldResourceID:
		return m.ResourceID()
	case resourceevent.FieldEventType:
		return m.EventType()
	case resourceevent.FieldActor:
		return m.Actor()
	case resourceevent.FieldPreviousState:
		return m.PreviousState()
	case resourceevent.FieldNewState:
		return m.NewState()
	case resourceevent.FieldDiff:
		return m.Diff()
	case resourceevent.FieldMetadata:
		return m.Metadata()
	case resourceevent.FieldErrorMessage:
		return m.ErrorMessage()
	case resourceevent.FieldSource:
		return m.Source()
	case resourceevent.FieldReversible:
		return m.Reversible()
	case resourceevent.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ResourceEventMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case resourceevent.FieldResourceID:
		return m.OldResourceID(ctx)
	case resourceevent.FieldEventType:
		return m.OldEventType(ctx)
	case resourceevent.FieldActor:
		return m.OldActor(ctx)
	case resourceevent.FieldPreviousState:
		return m.OldPreviousState(ctx)
	case resourceevent.FieldNewState:
		return m.OldNewState(ctx)
	case resourceevent.FieldDiff:
		return m.OldDiff(ctx)
	case resourceevent.FieldMetadata:
		return m.OldMetadata(ctx)
	case resourceevent.FieldErrorMessage:
		return m.OldErrorMessage(ctx)
	case resourceevent.FieldSource:
		return m.OldSource(ctx)
	case resourceevent.FieldReversible:
		return m.OldReversible(ctx)
	case resourceevent.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown ResourceEvent field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ResourceEventMutation) SetField(name string, value ent.Value) error {
	switch name {
	case resourceevent.FieldResourceID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResourceID(v)
		return nil
	case resourceevent.FieldEventType:
		v, ok := value.(resourceevent.EventType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEventType(v)
		return nil
	case resourceevent.FieldActor:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActor(v)
		return nil
	case resourceevent.FieldPreviousState:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPreviousState(v)
		return nil
	case resourceevent.FieldNewState:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNewState(v)
		return nil
	case resourceevent.FieldDiff:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDiff(v)
		return nil
	case resourceevent.FieldMetadata:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	case resourceevent.FieldErrorMessage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetErrorMessage(v)
		return nil
	case resourceevent.FieldSource:
		v, ok := value.(resourceevent.Source)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSource(v)
		return nil
	case resourceevent.FieldReversible:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReversible(v)
		return nil
	case resourceevent.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown ResourceEvent field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ResourceEventMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ResourceEventMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ResourceEventMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ResourceEvent numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ResourceEventMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(resourceevent.FieldPreviousState) {
		fields = append(fields, resourceevent.FieldPreviousState)
	}
	if m.FieldCleared(resourceevent.FieldNewState) {
		fields = append(fields, resourceevent.FieldNewState)
	}
	if m.FieldCleared(resourceevent.FieldDiff) {
		fields = append(fields, resourceevent.FieldDiff)
	}
	if m.FieldCleared(resourceevent.FieldMetadata) {
		fields = append(fields, resourceevent.FieldMetadata)
	}
	if m.FieldCleared(resourceevent.FieldErrorMessage) {
		fields = append(fields, resourceevent.FieldErrorMessage)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ResourceEventMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ResourceEventMutation) ClearField(name string) error {
	switch name {
	case resourceevent.FieldPreviousState:
		m.ClearPreviousState()
		return nil
	case resourceevent.FieldNewState:
		m.ClearNewState()
		return nil
	case resourceevent.FieldDiff:
		m.ClearDiff()
		return nil
	case resourceevent.FieldMetadata:
		m.ClearMetadata()
		return nil
	case resourceevent.FieldErrorMessage:
		m.ClearErrorMessage()
		return nil
	}
	return fmt.Errorf("unknown ResourceEvent nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ResourceEventMutation) ResetField(name string) error {
	switch name {
	case resourceevent.FieldResourceID:
		m.ResetResourceID()
		return nil
	case resourceevent.FieldEventType:
		m.ResetEventType()
		return nil
	case resourceevent.FieldActor:
		m.ResetActor()
		return nil
	case resourceevent.FieldPreviousState:
		m.ResetPreviousState()
		return nil
	case resourceevent.FieldNewState:
		m.ResetNewState()
		return nil
	case resourceevent.FieldDiff:
		m.ResetDiff()
		return nil
	case resourceevent.FieldMetadata:
		m.ResetMetadata()
		return nil
	case resourceevent.FieldErrorMessage:
		m.ResetErrorMessage()
		return nil
	case resourceevent.FieldSource:
		m.ResetSource()
		return nil
	case resourceevent.FieldReversible:
		m.ResetReversible()
		return nil
	case resourceevent.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown ResourceEvent field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ResourceEventMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.resource != nil {
		edges = append(edges, resourceevent.EdgeResource)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ResourceEventMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case resourceevent.EdgeResource:
		if id := m.resource; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ResourceEventMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ResourceEventMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ResourceEventMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedresource {
		edges = append(edges, resourceevent.EdgeResource)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ResourceEventMutation) EdgeCleared(name string) bool {
	switch name {
	case resourceevent.EdgeResource:
		return m.clearedresource
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ResourceEventMutation) ClearEdge(name string) error {
	switch name {
	case resourceevent.EdgeResource:
		m.ClearResource()
		return nil
	}
	return fmt.Errorf("unknown ResourceEvent unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ResourceEventMutation) ResetEdge(name string) error {
	switch name {
	case resourceevent.EdgeResource:
		m.ResetResource()
		return nil
	}
	return fmt.Errorf("unknown ResourceEvent edge %s", name)
}

// RouterMutation represents an operation that mutates the Router nodes in the graph.
type RouterMutation struct {
	config
	op                          Op
	typ                         string
	id                          *string
	name                        *string
	host                        *string
	port                        *int
	addport                     *int
	platform                    *router.Platform
	model                       *string
	version                     *string
	status                      *router.Status
	last_seen                   *time.Time
	created_at                  *time.Time
	updated_at                  *time.Time
	clearedFields               map[string]struct{}
	secrets                     *string
	clearedsecrets              bool
	port_knock_sequences        map[string]struct{}
	removedport_knock_sequences map[string]struct{}
	clearedport_knock_sequences bool
	service_instances           map[string]struct{}
	removedservice_instances    map[string]struct{}
	clearedservice_instances    bool
	done                        bool
	oldValue                    func(context.Context) (*Router, error)
	predicates                  []predicate.Router
}

var _ ent.Mutation = (*RouterMutation)(nil)

// routerOption allows management of the mutation configuration using functional options.
type routerOption func(*RouterMutation)

// newRouterMutation creates new mutation for the Router entity.
func newRouterMutation(c config, op Op, opts ...routerOption) *RouterMutation {
	m := &RouterMutation{
		config:        c,
		op:            op,
		typ:           TypeRouter,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRouterID sets the ID field of the mutation.
func withRouterID(id string) routerOption {
	return func(m *RouterMutation) {
		var (
			err   error
			once  sync.Once
			value *Router
		)
		m.oldValue = func(ctx context.Context) (*Router, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Router.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRouter sets the old Router of the mutation.
func withRouter(node *Router) routerOption {
	return func(m *RouterMutation) {
		m.oldValue = func(context.Context) (*Router, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RouterMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RouterMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Router entities.
func (m *RouterMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RouterMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RouterMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Router.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *RouterMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *RouterMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Router entity.
// If the Router object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RouterMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *RouterMutation) ResetName() {
	m.name = nil
}

// SetHost sets the "host" field.
func (m *RouterMutation) SetHost(s string) {
	m.host = &s
}

// Host returns the value of the "host" field in the mutation.
func (m *RouterMutation) Host() (r string, exists bool) {
	v := m.host
	if v == nil {
		return
	}
	return *v, true
}

// OldHost returns the old "host" field's value of the Router entity.
// If the Router object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RouterMutation) OldHost(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHost is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHost requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHost: %w", err)
	}
	return oldValue.Host, nil
}

// ResetHost resets all changes to the "host" field.
func (m *RouterMutation) ResetHost() {
	m.host = nil
}

// SetPort sets the "port" field.
func (m *RouterMutation) SetPort(i int) {
	m.port = &i
	m.addport = nil
}

// Port returns the value of the "port" field in the mutation.
func (m *RouterMutation) Port() (r int, exists bool) {
	v := m.port
	if v == nil {
		return
	}
	return *v, true
}

// OldPort returns the old "port" field's value of the Router entity.
// If the Router object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RouterMutation) OldPort(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPort is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPort requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPort: %w", err)
	}
	return oldValue.Port, nil
}

// AddPort adds i to the "port" field.
func (m *RouterMutation) AddPort(i int) {
	if m.addport != nil {
		*m.addport += i
	} else {
		m.addport = &i
	}
}

// AddedPort returns the value that was added to the "port" field in this mutation.
func (m *RouterMutation) AddedPort() (r int, exists bool) {
	v := m.addport
	if v == nil {
		return
	}
	return *v, true
}

// ResetPort resets all changes to the "port" field.
func (m *RouterMutation) ResetPort() {
	m.port = nil
	m.addport = nil
}

// SetPlatform sets the "platform" field.
func (m *RouterMutation) SetPlatform(r router.Platform) {
	m.platform = &r
}

// Platform returns the value of the "platform" field in the mutation.
func (m *RouterMutation) Platform() (r router.Platform, exists bool) {
	v := m.platform
	if v == nil {
		return
	}
	return *v, true
}

// OldPlatform returns the old "platform" field's value of the Router entity.
// If the Router object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RouterMutation) OldPlatform(ctx context.Context) (v router.Platform, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPlatform is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPlatform requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPlatform: %w", err)
	}
	return oldValue.Platform, nil
}

// ResetPlatform resets all changes to the "platform" field.
func (m *RouterMutation) ResetPlatform() {
	m.platform = nil
}

// SetModel sets the "model" field.
func (m *RouterMutation) SetModel(s string) {
	m.model = &s
}

// Model returns the value of the "model" field in the mutation.
func (m *RouterMutation) Model() (r string, exists bool) {
	v := m.model
	if v == nil {
		return
	}
	return *v, true
}

// OldModel returns the old "model" field's value of the Router entity.
// If the Router object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RouterMutation) OldModel(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldModel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldModel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModel: %w", err)
	}
	return oldValue.Model, nil
}

// ClearModel clears the value of the "model" field.
func (m *RouterMutation) ClearModel() {
	m.model = nil
	m.clearedFields[router.FieldModel] = struct{}{}
}

// ModelCleared returns if the "model" field was cleared in this mutation.
func (m *RouterMutation) ModelCleared() bool {
	_, ok := m.clearedFields[router.FieldModel]
	return ok
}

// ResetModel resets all changes to the "model" field.
func (m *RouterMutation) ResetModel() {
	m.model = nil
	delete(m.clearedFields, router.FieldModel)
}

// SetVersion sets the "version" field.
func (m *RouterMutation) SetVersion(s string) {
	m.version = &s
}

// Version returns the value of the "version" field in the mutation.
func (m *RouterMutation) Version() (r string, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the Router entity.
// If the Router object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RouterMutation) OldVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// ClearVersion clears the value of the "version" field.
func (m *RouterMutation) ClearVersion() {
	m.version = nil
	m.clearedFields[router.FieldVersion] = struct{}{}
}

// VersionCleared returns if the "version" field was cleared in this mutation.
func (m *RouterMutation) VersionCleared() bool {
	_, ok := m.clearedFields[router.FieldVersion]
	return ok
}

// ResetVersion resets all changes to the "version" field.
func (m *RouterMutation) ResetVersion() {
	m.version = nil
	delete(m.clearedFields, router.FieldVersion)
}

// SetStatus sets the "status" field.
func (m *RouterMutation) SetStatus(r router.Status) {
	m.status = &r
}

// Status returns the value of the "status" field in the mutation.
func (m *RouterMutation) Status() (r router.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Router entity.
// If the Router object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RouterMutation) OldStatus(ctx context.Context) (v router.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *RouterMutation) ResetStatus() {
	m.status = nil
}

// SetLastSeen sets the "last_seen" field.
func (m *RouterMutation) SetLastSeen(t time.Time) {
	m.last_seen = &t
}

// LastSeen returns the value of the "last_seen" field in the mutation.
func (m *RouterMutation) LastSeen() (r time.Time, exists bool) {
	v := m.last_seen
	if v == nil {
		return
	}
	return *v, true
}

// OldLastSeen returns the old "last_seen" field's value of the Router entity.
// If the Router object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RouterMutation) OldLastSeen(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastSeen is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastSeen requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastSeen: %w", err)
	}
	return oldValue.LastSeen, nil
}

// ClearLastSeen clears the value of the "last_seen" field.
func (m *RouterMutation) ClearLastSeen() {
	m.last_seen = nil
	m.clearedFields[router.FieldLastSeen] = struct{}{}
}

// LastSeenCleared returns if the "last_seen" field was cleared in this mutation.
func (m *RouterMutation) LastSeenCleared() bool {
	_, ok := m.clearedFields[router.FieldLastSeen]
	return ok
}

// ResetLastSeen resets all changes to the "last_seen" field.
func (m *RouterMutation) ResetLastSeen() {
	m.last_seen = nil
	delete(m.clearedFields, router.FieldLastSeen)
}

// SetCreatedAt sets the "created_at" field.
func (m *RouterMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *RouterMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Router entity.
// If the Router object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RouterMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *RouterMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *RouterMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *RouterMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Router entity.
// If the Router object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RouterMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *RouterMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetSecretsID sets the "secrets" edge to the RouterSecret entity by id.
func (m *RouterMutation) SetSecretsID(id string) {
	m.secrets = &id
}

// ClearSecrets clears the "secrets" edge to the RouterSecret entity.
func (m *RouterMutation) ClearSecrets() {
	m.clearedsecrets = true
}

// SecretsCleared reports if the "secrets" edge to the RouterSecret entity was cleared.
func (m *RouterMutation) SecretsCleared() bool {
	return m.clearedsecrets
}

// SecretsID returns the "secrets" edge ID in the mutation.
func (m *RouterMutation) SecretsID() (id string, exists bool) {
	if m.secrets != nil {
		return *m.secrets, true
	}
	return
}

// SecretsIDs returns the "secrets" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SecretsID instead. It exists only for internal usage by the builders.
func (m *RouterMutation) SecretsIDs() (ids []string) {
	if id := m.secrets; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSecrets resets all changes to the "secrets" edge.
func (m *RouterMutation) ResetSecrets() {
	m.secrets = nil
	m.clearedsecrets = false
}

// AddPortKnockSequenceIDs adds the "port_knock_sequences" edge to the PortKnockSequence entity by ids.
func (m *RouterMutation) AddPortKnockSequenceIDs(ids ...string) {
	if m.port_knock_sequences == nil {
		m.port_knock_sequences = make(map[string]struct{})
	}
	for i := range ids {
		m.port_knock_sequences[ids[i]] = struct{}{}
	}
}

// ClearPortKnockSequences clears the "port_knock_sequences" edge to the PortKnockSequence entity.
func (m *RouterMutation) ClearPortKnockSequences() {
	m.clearedport_knock_sequences = true
}

// PortKnockSequencesCleared reports if the "port_knock_sequences" edge to the PortKnockSequence entity was cleared.
func (m *RouterMutation) PortKnockSequencesCleared() bool {
	return m.clearedport_knock_sequences
}

// RemovePortKnockSequenceIDs removes the "port_knock_sequences" edge to the PortKnockSequence entity by IDs.
func (m *RouterMutation) RemovePortKnockSequenceIDs(ids ...string) {
	if m.removedport_knock_sequences == nil {
		m.removedport_knock_sequences = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.port_knock_sequences, ids[i])
		m.removedport_knock_sequences[ids[i]] = struct{}{}
	}
}

// RemovedPortKnockSequences returns the removed IDs of the "port_knock_sequences" edge to the PortKnockSequence entity.
func (m *RouterMutation) RemovedPortKnockSequencesIDs() (ids []string) {
	for id := range m.removedport_knock_sequences {
		ids = append(ids, id)
	}
	return
}

// PortKnockSequencesIDs returns the "port_knock_sequences" edge IDs in the mutation.
func (m *RouterMutation) PortKnockSequencesIDs() (ids []string) {
	for id := range m.port_knock_sequences {
		ids = append(ids, id)
	}
	return
}

// ResetPortKnockSequences resets all changes to the "port_knock_sequences" edge.
func (m *RouterMutation) ResetPortKnockSequences() {
	m.port_knock_sequences = nil
	m.clearedport_knock_sequences = false
	m.removedport_knock_sequences = nil
}

// AddServiceInstanceIDs adds the "service_instances" edge to the ServiceInstance entity by ids.
func (m *RouterMutation) AddServiceInstanceIDs(ids ...string) {
	if m.service_instances == nil {
		m.service_instances = make(map[string]struct{})
	}
	for i := range ids {
		m.service_instances[ids[i]] = struct{}{}
	}
}

// ClearServiceInstances clears the "service_instances" edge to the ServiceInstance entity.
func (m *RouterMutation) ClearServiceInstances() {
	m.clearedservice_instances = true
}

// ServiceInstancesCleared reports if the "service_instances" edge to the ServiceInstance entity was cleared.
func (m *RouterMutation) ServiceInstancesCleared() bool {
	return m.clearedservice_instances
}

// RemoveServiceInstanceIDs removes the "service_instances" edge to the ServiceInstance entity by IDs.
func (m *RouterMutation) RemoveServiceInstanceIDs(ids ...string) {
	if m.removedservice_instances == nil {
		m.removedservice_instances = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.service_instances, ids[i])
		m.removedservice_instances[ids[i]] = struct{}{}
	}
}

// RemovedServiceInstances returns the removed IDs of the "service_instances" edge to the ServiceInstance entity.
func (m *RouterMutation) RemovedServiceInstancesIDs() (ids []string) {
	for id := range m.removedservice_instances {
		ids = append(ids, id)
	}
	return
}

// ServiceInstancesIDs returns the "service_instances" edge IDs in the mutation.
func (m *RouterMutation) ServiceInstancesIDs() (ids []string) {
	for id := range m.service_instances {
		ids = append(ids, id)
	}
	return
}

// ResetServiceInstances resets all changes to the "service_instances" edge.
func (m *RouterMutation) ResetServiceInstances() {
	m.service_instances = nil
	m.clearedservice_instances = false
	m.removedservice_instances = nil
}

// Where appends a list predicates to the RouterMutation builder.
func (m *RouterMutation) Where(ps ...predicate.Router) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RouterMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RouterMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Router, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RouterMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RouterMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Router).
func (m *RouterMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RouterMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.name != nil {
		fields = append(fields, router.FieldName)
	}
	if m.host != nil {
		fields = append(fields, router.FieldHost)
	}
	if m.port != nil {
		fields = append(fields, router.FieldPort)
	}
	if m.platform != nil {
		fields = append(fields, router.FieldPlatform)
	}
	if m.model != nil {
		fields = append(fields, router.FieldModel)
	}
	if m.version != nil {
		fields = append(fields, router.FieldVersion)
	}
	if m.status != nil {
		fields = append(fields, router.FieldStatus)
	}
	if m.last_seen != nil {
		fields = append(fields, router.FieldLastSeen)
	}
	if m.created_at != nil {
		fields = append(fields, router.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, router.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RouterMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case router.FieldName:
		return m.Name()
	case router.FieldHost:
		return m.Host()
	case router.FieldPort:
		return m.Port()
	case router.FieldPlatform:
		return m.Platform()
	case router.FieldModel:
		return m.Model()
	case router.FieldVersion:
		return m.Version()
	case router.FieldStatus:
		return m.Status()
	case router.FieldLastSeen:
		return m.LastSeen()
	case router.FieldCreatedAt:
		return m.CreatedAt()
	case router.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RouterMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case router.FieldName:
		return m.OldName(ctx)
	case router.FieldHost:
		return m.OldHost(ctx)
	case router.FieldPort:
		return m.OldPort(ctx)
	case router.FieldPlatform:
		return m.OldPlatform(ctx)
	case router.FieldModel:
		return m.OldModel(ctx)
	case router.FieldVersion:
		return m.OldVersion(ctx)
	case router.FieldStatus:
		return m.OldStatus(ctx)
	case router.FieldLastSeen:
		return m.OldLastSeen(ctx)
	case router.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case router.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Router field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RouterMutation) SetField(name string, value ent.Value) error {
	switch name {
	case router.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case router.FieldHost:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHost(v)
		return nil
	case router.FieldPort:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPort(v)
		return nil
	case router.FieldPlatform:
		v, ok := value.(router.Platform)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPlatform(v)
		return nil
	case router.FieldModel:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModel(v)
		return nil
	case router.FieldVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case router.FieldStatus:
		v, ok := value.(router.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case router.FieldLastSeen:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastSeen(v)
		return nil
	case router.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case router.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Router field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RouterMutation) AddedFields() []string {
	var fields []string
	if m.addport != nil {
		fields = append(fields, router.FieldPort)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RouterMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case router.FieldPort:
		return m.AddedPort()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RouterMutation) AddField(name string, value ent.Value) error {
	switch name {
	case router.FieldPort:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPort(v)
		return nil
	}
	return fmt.Errorf("unknown Router numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RouterMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(router.FieldModel) {
		fields = append(fields, router.FieldModel)
	}
	if m.FieldCleared(router.FieldVersion) {
		fields = append(fields, router.FieldVersion)
	}
	if m.FieldCleared(router.FieldLastSeen) {
		fields = append(fields, router.FieldLastSeen)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RouterMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RouterMutation) ClearField(name string) error {
	switch name {
	case router.FieldModel:
		m.ClearModel()
		return nil
	case router.FieldVersion:
		m.ClearVersion()
		return nil
	case router.FieldLastSeen:
		m.ClearLastSeen()
		return nil
	}
	return fmt.Errorf("unknown Router nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RouterMutation) ResetField(name string) error {
	switch name {
	case router.FieldName:
		m.ResetName()
		return nil
	case router.FieldHost:
		m.ResetHost()
		return nil
	case router.FieldPort:
		m.ResetPort()
		return nil
	case router.FieldPlatform:
		m.ResetPlatform()
		return nil
	case router.FieldModel:
		m.ResetModel()
		return nil
	case router.FieldVersion:
		m.ResetVersion()
		return nil
	case router.FieldStatus:
		m.ResetStatus()
		return nil
	case router.FieldLastSeen:
		m.ResetLastSeen()
		return nil
	case router.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case router.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Router field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RouterMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.secrets != nil {
		edges = append(edges, router.EdgeSecrets)
	}
	if m.port_knock_sequences != nil {
		edges = append(edges, router.EdgePortKnockSequences)
	}
	if m.service_instances != nil {
		edges = append(edges, router.EdgeServiceInstances)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RouterMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case router.EdgeSecrets:
		if id := m.secrets; id != nil {
			return []ent.Value{*id}
		}
	case router.EdgePortKnockSequences:
		ids := make([]ent.Value, 0, len(m.port_knock_sequences))
		for id := range m.port_knock_sequences {
			ids = append(ids, id)
		}
		return ids
	case router.EdgeServiceInstances:
		ids := make([]ent.Value, 0, len(m.service_instances))
		for id := range m.service_instances {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RouterMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedport_knock_sequences != nil {
		edges = append(edges, router.EdgePortKnockSequences)
	}
	if m.removedservice_instances != nil {
		edges = append(edges, router.EdgeServiceInstances)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RouterMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case router.EdgePortKnockSequences:
		ids := make([]ent.Value, 0, len(m.removedport_knock_sequences))
		for id := range m.removedport_knock_sequences {
			ids = append(ids, id)
		}
		return ids
	case router.EdgeServiceInstances:
		ids := make([]ent.Value, 0, len(m.removedservice_instances))
		for id := range m.removedservice_instances {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RouterMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedsecrets {
		edges = append(edges, router.EdgeSecrets)
	}
	if m.clearedport_knock_sequences {
		edges = append(edges, router.EdgePortKnockSequences)
	}
	if m.clearedservice_instances {
		edges = append(edges, router.EdgeServiceInstances)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RouterMutation) EdgeCleared(name string) bool {
	switch name {
	case router.EdgeSecrets:
		return m.clearedsecrets
	case router.EdgePortKnockSequences:
		return m.clearedport_knock_sequences
	case router.EdgeServiceInstances:
		return m.clearedservice_instances
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RouterMutation) ClearEdge(name string) error {
	switch name {
	case router.EdgeSecrets:
		m.ClearSecrets()
		return nil
	}
	return fmt.Errorf("unknown Router unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RouterMutation) ResetEdge(name string) error {
	switch name {
	case router.EdgeSecrets:
		m.ResetSecrets()
		return nil
	case router.EdgePortKnockSequences:
		m.ResetPortKnockSequences()
		return nil
	case router.EdgeServiceInstances:
		m.ResetServiceInstances()
		return nil
	}
	return fmt.Errorf("unknown Router edge %s", name)
}

// RouterCapabilityMutation represents an operation that mutates the RouterCapability nodes in the graph.
type RouterCapabilityMutation struct {
	config
	op                             Op
	typ                            string
	id                             *string
	architecture                   *string
	model                          *string
	board_name                     *string
	total_memory                   *int64
	addtotal_memory                *int64
	available_storage              *int64
	addavailable_storage           *int64
	cpu_count                      *int
	addcpu_count                   *int
	has_wireless_chip              *bool
	has_lte_module                 *bool
	version_raw                    *string
	version_major                  *int
	addversion_major               *int
	version_minor                  *int
	addversion_minor               *int
	version_patch                  *int
	addversion_patch               *int
	installed_packages             *[]string
	appendinstalled_packages       []string
	license_level                  *int
	addlicense_level               *int
	update_channel                 *string
	container_package_installed    *bool
	container_enabled              *bool
	container_registry_configured  *bool
	container_storage_available    *int64
	addcontainer_storage_available *int64
	supports_network_namespace     *bool
	max_containers                 *int
	addmax_containers              *int
	capability_entries             *map[string]interface{}
	detected_at                    *time.Time
	expires_at                     *time.Time
	is_refreshing                  *bool
	created_at                     *time.Time
	updated_at                     *time.Time
	clearedFields                  map[string]struct{}
	done                           bool
	oldValue                       func(context.Context) (*RouterCapability, error)
	predicates                     []predicate.RouterCapability
}

var _ ent.Mutation = (*RouterCapabilityMutation)(nil)

// routercapabilityOption allows management of the mutation configuration using functional options.
type routercapabilityOption func(*RouterCapabilityMutation)

// newRouterCapabilityMutation creates new mutation for the RouterCapability entity.
func newRouterCapabilityMutation(c config, op Op, opts ...routercapabilityOption) *RouterCapabilityMutation {
	m := &RouterCapabilityMutation{
		config:        c,
		op:            op,
		typ:           TypeRouterCapability,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRouterCapabilityID sets the ID field of the mutation.
func withRouterCapabilityID(id string) routercapabilityOption {
	return func(m *RouterCapabilityMutation) {
		var (
			err   error
			once  sync.Once
			value *RouterCapability
		)
		m.oldValue = func(ctx context.Context) (*RouterCapability, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().RouterCapability.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRouterCapability sets the old RouterCapability of the mutation.
func withRouterCapability(node *RouterCapability) routercapabilityOption {
	return func(m *RouterCapabilityMutation) {
		m.oldValue = func(context.Context) (*RouterCapability, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RouterCapabilityMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RouterCapabilityMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of RouterCapability entities.
func (m *RouterCapabilityMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RouterCapabilityMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RouterCapabilityMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().RouterCapability.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetArchitecture sets the "architecture" field.
func (m *RouterCapabilityMutation) SetArchitecture(s string) {
	m.architecture = &s
}

// Architecture returns the value of the "architecture" field in the mutation.
func (m *RouterCapabilityMutation) Architecture() (r string, exists bool) {
	v := m.architecture
	if v == nil {
		return
	}
	return *v, true
}

// OldArchitecture returns the old "architecture" field's value of the RouterCapability entity.
// If the RouterCapability object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RouterCapabilityMutation) OldArchitecture(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldArchitecture is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldArchitecture requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldArchitecture: %w", err)
	}
	return oldValue.Architecture, nil
}

// ResetArchitecture resets all changes to the "architecture" field.
func (m *RouterCapabilityMutation) ResetArchitecture() {
	m.architecture = nil
}

// SetModel sets the "model" field.
func (m *RouterCapabilityMutation) SetModel(s string) {
	m.model = &s
}

// Model returns the value of the "model" field in the mutation.
func (m *RouterCapabilityMutation) Model() (r string, exists bool) {
	v := m.model
	if v == nil {
		return
	}
	return *v, true
}

// OldModel returns the old "model" field's value of the RouterCapability entity.
// If the RouterCapability object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RouterCapabilityMutation) OldModel(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldModel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldModel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModel: %w", err)
	}
	return oldValue.Model, nil
}

// ClearModel clears the value of the "model" field.
func (m *RouterCapabilityMutation) ClearModel() {
	m.model = nil
	m.clearedFields[routercapability.FieldModel] = struct{}{}
}

// ModelCleared returns if the "model" field was cleared in this mutation.
func (m *RouterCapabilityMutation) ModelCleared() bool {
	_, ok := m.clearedFields[routercapability.FieldModel]
	return ok
}

// ResetModel resets all changes to the "model" field.
func (m *RouterCapabilityMutation) ResetModel() {
	m.model = nil
	delete(m.clearedFields, routercapability.FieldModel)
}

// SetBoardName sets the "board_name" field.
func (m *RouterCapabilityMutation) SetBoardName(s string) {
	m.board_name = &s
}

// BoardName returns the value of the "board_name" field in the mutation.
func (m *RouterCapabilityMutation) BoardName() (r string, exists bool) {
	v := m.board_name
	if v == nil {
		return
	}
	return *v, true
}

// OldBoardName returns the old "board_name" field's value of the RouterCapability entity.
// If the RouterCapability object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RouterCapabilityMutation) OldBoardName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBoardName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBoardName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBoardName: %w", err)
	}
	return oldValue.BoardName, nil
}

// ClearBoardName clears the value of the "board_name" field.
func (m *RouterCapabilityMutation) ClearBoardName() {
	m.board_name = nil
	m.clearedFields[routercapability.FieldBoardName] = struct{}{}
}

// BoardNameCleared returns if the "board_name" field was cleared in this mutation.
func (m *RouterCapabilityMutation) BoardNameCleared() bool {
	_, ok := m.clearedFields[routercapability.FieldBoardName]
	return ok
}

// ResetBoardName resets all changes to the "board_name" field.
func (m *RouterCapabilityMutation) ResetBoardName() {
	m.board_name = nil
	delete(m.clearedFields, routercapability.FieldBoardName)
}

// SetTotalMemory sets the "total_memory" field.
func (m *RouterCapabilityMutation) SetTotalMemory(i int64) {
	m.total_memory = &i
	m.addtotal_memory = nil
}

// TotalMemory returns the value of the "total_memory" field in the mutation.
func (m *RouterCapabilityMutation) TotalMemory() (r int64, exists bool) {
	v := m.total_memory
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalMemory returns the old "total_memory" field's value of the RouterCapability entity.
// If the RouterCapability object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RouterCapabilityMutation) OldTotalMemory(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalMemory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalMemory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalMemory: %w", err)
	}
	return oldValue.TotalMemory, nil
}

// AddTotalMemory adds i to the "total_memory" field.
func (m *RouterCapabilityMutation) AddTotalMemory(i int64) {
	if m.addtotal_memory != nil {
		*m.addtotal_memory += i
	} else {
		m.addtotal_memory = &i
	}
}

// AddedTotalMemory returns the value that was added to the "total_memory" field in this mutation.
func (m *RouterCapabilityMutation) AddedTotalMemory() (r int64, exists bool) {
	v := m.addtotal_memory
	if v == nil {
		return
	}
	return *v, true
}

// ResetTotalMemory resets all changes to the "total_memory" field.
func (m *RouterCapabilityMutation) ResetTotalMemory() {
	m.total_memory = nil
	m.addtotal_memory = nil
}

// SetAvailableStorage sets the "available_storage" field.
func (m *RouterCapabilityMutation) SetAvailableStorage(i int64) {
	m.available_storage = &i
	m.addavailable_storage = nil
}

// AvailableStorage returns the value of the "available_storage" field in the mutation.
func (m *RouterCapabilityMutation) AvailableStorage() (r int64, exists bool) {
	v := m.available_storage
	if v == nil {
		return
	}
	return *v, true
}

// OldAvailableStorage returns the old "available_storage" field's value of the RouterCapability entity.
// If the RouterCapability object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RouterCapabilityMutation) OldAvailableStorage(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAvailableStorage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAvailableStorage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAvailableStorage: %w", err)
	}
	return oldValue.AvailableStorage, nil
}

// AddAvailableStorage adds i to the "available_storage" field.
func (m *RouterCapabilityMutation) AddAvailableStorage(i int64) {
	if m.addavailable_storage != nil {
		*m.addavailable_storage += i
	} else {
		m.addavailable_storage = &i
	}
}

// AddedAvailableStorage returns the value that was added to the "available_storage" field in this mutation.
func (m *RouterCapabilityMutation) AddedAvailableStorage() (r int64, exists bool) {
	v := m.addavailable_storage
	if v == nil {
		return
	}
	return *v, true
}

// ResetAvailableStorage resets all changes to the "available_storage" field.
func (m *RouterCapabilityMutation) ResetAvailableStorage() {
	m.available_storage = nil
	m.addavailable_storage = nil
}

// SetCPUCount sets the "cpu_count" field.
func (m *RouterCapabilityMutation) SetCPUCount(i int) {
	m.cpu_count = &i
	m.addcpu_count = nil
}

// CPUCount returns the value of the "cpu_count" field in the mutation.
func (m *RouterCapabilityMutation) CPUCount() (r int, exists bool) {
	v := m.cpu_count
	if v == nil {
		return
	}
	return *v, true
}

// OldCPUCount returns the old "cpu_count" field's value of the RouterCapability entity.
// If the RouterCapability object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RouterCapabilityMutation) OldCPUCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCPUCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCPUCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCPUCount: %w", err)
	}
	return oldValue.CPUCount, nil
}

// AddCPUCount adds i to the "cpu_count" field.
func (m *RouterCapabilityMutation) AddCPUCount(i int) {
	if m.addcpu_count != nil {
		*m.addcpu_count += i
	} else {
		m.addcpu_count = &i
	}
}

// AddedCPUCount returns the value that was added to the "cpu_count" field in this mutation.
func (m *RouterCapabilityMutation) AddedCPUCount() (r int, exists bool) {
	v := m.addcpu_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetCPUCount resets all changes to the "cpu_count" field.
func (m *RouterCapabilityMutation) ResetCPUCount() {
	m.cpu_count = nil
	m.addcpu_count = nil
}

// SetHasWirelessChip sets the "has_wireless_chip" field.
func (m *RouterCapabilityMutation) SetHasWirelessChip(b bool) {
	m.has_wireless_chip = &b
}

// HasWirelessChip returns the value of the "has_wireless_chip" field in the mutation.
func (m *RouterCapabilityMutation) HasWirelessChip() (r bool, exists bool) {
	v := m.has_wireless_chip
	if v == nil {
		return
	}
	return *v, true
}

// OldHasWirelessChip returns the old "has_wireless_chip" field's value of the RouterCapability entity.
// If the RouterCapability object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RouterCapabilityMutation) OldHasWirelessChip(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHasWirelessChip is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHasWirelessChip requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHasWirelessChip: %w", err)
	}
	return oldValue.HasWirelessChip, nil
}

// ResetHasWirelessChip resets all changes to the "has_wireless_chip" field.
func (m *RouterCapabilityMutation) ResetHasWirelessChip() {
	m.has_wireless_chip = nil
}

// SetHasLteModule sets the "has_lte_module" field.
func (m *RouterCapabilityMutation) SetHasLteModule(b bool) {
	m.has_lte_module = &b
}

// HasLteModule returns the value of the "has_lte_module" field in the mutation.
func (m *RouterCapabilityMutation) HasLteModule() (r bool, exists bool) {
	v := m.has_lte_module
	if v == nil {
		return
	}
	return *v, true
}

// OldHasLteModule returns the old "has_lte_module" field's value of the RouterCapability entity.
// If the RouterCapability object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RouterCapabilityMutation) OldHasLteModule(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHasLteModule is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHasLteModule requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHasLteModule: %w", err)
	}
	return oldValue.HasLteModule, nil
}

// ResetHasLteModule resets all changes to the "has_lte_module" field.
func (m *RouterCapabilityMutation) ResetHasLteModule() {
	m.has_lte_module = nil
}

// SetVersionRaw sets the "version_raw" field.
func (m *RouterCapabilityMutation) SetVersionRaw(s string) {
	m.version_raw = &s
}

// VersionRaw returns the value of the "version_raw" field in the mutation.
func (m *RouterCapabilityMutation) VersionRaw() (r string, exists bool) {
	v := m.version_raw
	if v == nil {
		return
	}
	return *v, true
}

// OldVersionRaw returns the old "version_raw" field's value of the RouterCapability entity.
// If the RouterCapability object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RouterCapabilityMutation) OldVersionRaw(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersionRaw is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersionRaw requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersionRaw: %w", err)
	}
	return oldValue.VersionRaw, nil
}

// ResetVersionRaw resets all changes to the "version_raw" field.
func (m *RouterCapabilityMutation) ResetVersionRaw() {
	m.version_raw = nil
}

// SetVersionMajor sets the "version_major" field.
func (m *RouterCapabilityMutation) SetVersionMajor(i int) {
	m.version_major = &i
	m.addversion_major = nil
}

// VersionMajor returns the value of the "version_major" field in the mutation.
func (m *RouterCapabilityMutation) VersionMajor() (r int, exists bool) {
	v := m.version_major
	if v == nil {
		return
	}
	return *v, true
}

// OldVersionMajor returns the old "version_major" field's value of the RouterCapability entity.
// If the RouterCapability object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RouterCapabilityMutation) OldVersionMajor(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersionMajor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersionMajor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersionMajor: %w", err)
	}
	return oldValue.VersionMajor, nil
}

// AddVersionMajor adds i to the "version_major" field.
func (m *RouterCapabilityMutation) AddVersionMajor(i int) {
	if m.addversion_major != nil {
		*m.addversion_major += i
	} else {
		m.addversion_major = &i
	}
}

// AddedVersionMajor returns the value that was added to the "version_major" field in this mutation.
func (m *RouterCapabilityMutation) AddedVersionMajor() (r int, exists bool) {
	v := m.addversion_major
	if v == nil {
		return
	}
	return *v, true
}

// ResetVersionMajor resets all changes to the "version_major" field.
func (m *RouterCapabilityMutation) ResetVersionMajor() {
	m.version_major = nil
	m.addversion_major = nil
}

// SetVersionMinor sets the "version_minor" field.
func (m *RouterCapabilityMutation) SetVersionMinor(i int) {
	m.version_minor = &i
	m.addversion_minor = nil
}

// VersionMinor returns the value of the "version_minor" field in the mutation.
func (m *RouterCapabilityMutation) VersionMinor() (r int, exists bool) {
	v := m.version_minor
	if v == nil {
		return
	}
	return *v, true
}

// OldVersionMinor returns the old "version_minor" field's value of the RouterCapability entity.
// If the RouterCapability object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RouterCapabilityMutation) OldVersionMinor(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersionMinor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersionMinor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersionMinor: %w", err)
	}
	return oldValue.VersionMinor, nil
}

// AddVersionMinor adds i to the "version_minor" field.
func (m *RouterCapabilityMutation) AddVersionMinor(i int) {
	if m.addversion_minor != nil {
		*m.addversion_minor += i
	} else {
		m.addversion_minor = &i
	}
}

// AddedVersionMinor returns the value that was added to the "version_minor" field in this mutation.
func (m *RouterCapabilityMutation) AddedVersionMinor() (r int, exists bool) {
	v := m.addversion_minor
	if v == nil {
		return
	}
	return *v, true
}

// ResetVersionMinor resets all changes to the "version_minor" field.
func (m *RouterCapabilityMutation) ResetVersionMinor() {
	m.version_minor = nil
	m.addversion_minor = nil
}

// SetVersionPatch sets the "version_patch" field.
func (m *RouterCapabilityMutation) SetVersionPatch(i int) {
	m.version_patch = &i
	m.addversion_patch = nil
}

// VersionPatch returns the value of the "version_patch" field in the mutation.
func (m *RouterCapabilityMutation) VersionPatch() (r int, exists bool) {
	v := m.version_patch
	if v == nil {
		return
	}
	return *v, true
}

// OldVersionPatch returns the old "version_patch" field's value of the RouterCapability entity.
// If the RouterCapability object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RouterCapabilityMutation) OldVersionPatch(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersionPatch is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersionPatch requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersionPatch: %w", err)
	}
	return oldValue.VersionPatch, nil
}

// AddVersionPatch adds i to the "version_patch" field.
func (m *RouterCapabilityMutation) AddVersionPatch(i int) {
	if m.addversion_patch != nil {
		*m.addversion_patch += i
	} else {
		m.addversion_patch = &i
	}
}

// AddedVersionPatch returns the value that was added to the "version_patch" field in this mutation.
func (m *RouterCapabilityMutation) AddedVersionPatch() (r int, exists bool) {
	v := m.addversion_patch
	if v == nil {
		return
	}
	return *v, true
}

// ResetVersionPatch resets all changes to the "version_patch" field.
func (m *RouterCapabilityMutation) ResetVersionPatch() {
	m.version_patch = nil
	m.addversion_patch = nil
}

// SetInstalledPackages sets the "installed_packages" field.
func (m *RouterCapabilityMutation) SetInstalledPackages(s []string) {
	m.installed_packages = &s
	m.appendinstalled_packages = nil
}

// InstalledPackages returns the value of the "installed_packages" field in the mutation.
func (m *RouterCapabilityMutation) InstalledPackages() (r []string, exists bool) {
	v := m.installed_packages
	if v == nil {
		return
	}
	return *v, true
}

// OldInstalledPackages returns the old "installed_packages" field's value of the RouterCapability entity.
// If the RouterCapability object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RouterCapabilityMutation) OldInstalledPackages(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInstalledPackages is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInstalledPackages requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInstalledPackages: %w", err)
	}
	return oldValue.InstalledPackages, nil
}

// AppendInstalledPackages adds s to the "installed_packages" field.
func (m *RouterCapabilityMutation) AppendInstalledPackages(s []string) {
	m.appendinstalled_packages = append(m.appendinstalled_packages, s...)
}

// AppendedInstalledPackages returns the list of values that were appended to the "installed_packages" field in this mutation.
func (m *RouterCapabilityMutation) AppendedInstalledPackages() ([]string, bool) {
	if len(m.appendinstalled_packages) == 0 {
		return nil, false
	}
	return m.appendinstalled_packages, true
}

// ResetInstalledPackages resets all changes to the "installed_packages" field.
func (m *RouterCapabilityMutation) ResetInstalledPackages() {
	m.installed_packages = nil
	m.appendinstalled_packages = nil
}

// SetLicenseLevel sets the "license_level" field.
func (m *RouterCapabilityMutation) SetLicenseLevel(i int) {
	m.license_level = &i
	m.addlicense_level = nil
}

// LicenseLevel returns the value of the "license_level" field in the mutation.
func (m *RouterCapabilityMutation) LicenseLevel() (r int, exists bool) {
	v := m.license_level
	if v == nil {
		return
	}
	return *v, true
}

// OldLicenseLevel returns the old "license_level" field's value of the RouterCapability entity.
// If the RouterCapability object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RouterCapabilityMutation) OldLicenseLevel(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLicenseLevel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLicenseLevel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLicenseLevel: %w", err)
	}
	return oldValue.LicenseLevel, nil
}

// AddLicenseLevel adds i to the "license_level" field.
func (m *RouterCapabilityMutation) AddLicenseLevel(i int) {
	if m.addlicense_level != nil {
		*m.addlicense_level += i
	} else {
		m.addlicense_level = &i
	}
}

// AddedLicenseLevel returns the value that was added to the "license_level" field in this mutation.
func (m *RouterCapabilityMutation) AddedLicenseLevel() (r int, exists bool) {
	v := m.addlicense_level
	if v == nil {
		return
	}
	return *v, true
}

// ResetLicenseLevel resets all changes to the "license_level" field.
func (m *RouterCapabilityMutation) ResetLicenseLevel() {
	m.license_level = nil
	m.addlicense_level = nil
}

// SetUpdateChannel sets the "update_channel" field.
func (m *RouterCapabilityMutation) SetUpdateChannel(s string) {
	m.update_channel = &s
}

// UpdateChannel returns the value of the "update_channel" field in the mutation.
func (m *RouterCapabilityMutation) UpdateChannel() (r string, exists bool) {
	v := m.update_channel
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateChannel returns the old "update_channel" field's value of the RouterCapability entity.
// If the RouterCapability object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RouterCapabilityMutation) OldUpdateChannel(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateChannel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateChannel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateChannel: %w", err)
	}
	return oldValue.UpdateChannel, nil
}

// ClearUpdateChannel clears the value of the "update_channel" field.
func (m *RouterCapabilityMutation) ClearUpdateChannel() {
	m.update_channel = nil
	m.clearedFields[routercapability.FieldUpdateChannel] = struct{}{}
}

// UpdateChannelCleared returns if the "update_channel" field was cleared in this mutation.
func (m *RouterCapabilityMutation) UpdateChannelCleared() bool {
	_, ok := m.clearedFields[routercapability.FieldUpdateChannel]
	return ok
}

// ResetUpdateChannel resets all changes to the "update_channel" field.
func (m *RouterCapabilityMutation) ResetUpdateChannel() {
	m.update_channel = nil
	delete(m.clearedFields, routercapability.FieldUpdateChannel)
}

// SetContainerPackageInstalled sets the "container_package_installed" field.
func (m *RouterCapabilityMutation) SetContainerPackageInstalled(b bool) {
	m.container_package_installed = &b
}

// ContainerPackageInstalled returns the value of the "container_package_installed" field in the mutation.
func (m *RouterCapabilityMutation) ContainerPackageInstalled() (r bool, exists bool) {
	v := m.container_package_installed
	if v == nil {
		return
	}
	return *v, true
}

// OldContainerPackageInstalled returns the old "container_package_installed" field's value of the RouterCapability entity.
// If the RouterCapability object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RouterCapabilityMutation) OldContainerPackageInstalled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContainerPackageInstalled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContainerPackageInstalled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContainerPackageInstalled: %w", err)
	}
	return oldValue.ContainerPackageInstalled, nil
}

// ResetContainerPackageInstalled resets all changes to the "container_package_installed" field.
func (m *RouterCapabilityMutation) ResetContainerPackageInstalled() {
	m.container_package_installed = nil
}

// SetContainerEnabled sets the "container_enabled" field.
func (m *RouterCapabilityMutation) SetContainerEnabled(b bool) {
	m.container_enabled = &b
}

// ContainerEnabled returns the value of the "container_enabled" field in the mutation.
func (m *RouterCapabilityMutation) ContainerEnabled() (r bool, exists bool) {
	v := m.container_enabled
	if v == nil {
		return
	}
	return *v, true
}

// OldContainerEnabled returns the old "container_enabled" field's value of the RouterCapability entity.
// If the RouterCapability object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RouterCapabilityMutation) OldContainerEnabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContainerEnabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContainerEnabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContainerEnabled: %w", err)
	}
	return oldValue.ContainerEnabled, nil
}

// ResetContainerEnabled resets all changes to the "container_enabled" field.
func (m *RouterCapabilityMutation) ResetContainerEnabled() {
	m.container_enabled = nil
}

// SetContainerRegistryConfigured sets the "container_registry_configured" field.
func (m *RouterCapabilityMutation) SetContainerRegistryConfigured(b bool) {
	m.container_registry_configured = &b
}

// ContainerRegistryConfigured returns the value of the "container_registry_configured" field in the mutation.
func (m *RouterCapabilityMutation) ContainerRegistryConfigured() (r bool, exists bool) {
	v := m.container_registry_configured
	if v == nil {
		return
	}
	return *v, true
}

// OldContainerRegistryConfigured returns the old "container_registry_configured" field's value of the RouterCapability entity.
// If the RouterCapability object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RouterCapabilityMutation) OldContainerRegistryConfigured(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContainerRegistryConfigured is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContainerRegistryConfigured requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContainerRegistryConfigured: %w", err)
	}
	return oldValue.ContainerRegistryConfigured, nil
}

// ResetContainerRegistryConfigured resets all changes to the "container_registry_configured" field.
func (m *RouterCapabilityMutation) ResetContainerRegistryConfigured() {
	m.container_registry_configured = nil
}

// SetContainerStorageAvailable sets the "container_storage_available" field.
func (m *RouterCapabilityMutation) SetContainerStorageAvailable(i int64) {
	m.container_storage_available = &i
	m.addcontainer_storage_available = nil
}

// ContainerStorageAvailable returns the value of the "container_storage_available" field in the mutation.
func (m *RouterCapabilityMutation) ContainerStorageAvailable() (r int64, exists bool) {
	v := m.container_storage_available
	if v == nil {
		return
	}
	return *v, true
}

// OldContainerStorageAvailable returns the old "container_storage_available" field's value of the RouterCapability entity.
// If the RouterCapability object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RouterCapabilityMutation) OldContainerStorageAvailable(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContainerStorageAvailable is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContainerStorageAvailable requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContainerStorageAvailable: %w", err)
	}
	return oldValue.ContainerStorageAvailable, nil
}

// AddContainerStorageAvailable adds i to the "container_storage_available" field.
func (m *RouterCapabilityMutation) AddContainerStorageAvailable(i int64) {
	if m.addcontainer_storage_available != nil {
		*m.addcontainer_storage_available += i
	} else {
		m.addcontainer_storage_available = &i
	}
}

// AddedContainerStorageAvailable returns the value that was added to the "container_storage_available" field in this mutation.
func (m *RouterCapabilityMutation) AddedContainerStorageAvailable() (r int64, exists bool) {
	v := m.addcontainer_storage_available
	if v == nil {
		return
	}
	return *v, true
}

// ResetContainerStorageAvailable resets all changes to the "container_storage_available" field.
func (m *RouterCapabilityMutation) ResetContainerStorageAvailable() {
	m.container_storage_available = nil
	m.addcontainer_storage_available = nil
}

// SetSupportsNetworkNamespace sets the "supports_network_namespace" field.
func (m *RouterCapabilityMutation) SetSupportsNetworkNamespace(b bool) {
	m.supports_network_namespace = &b
}

// SupportsNetworkNamespace returns the value of the "supports_network_namespace" field in the mutation.
func (m *RouterCapabilityMutation) SupportsNetworkNamespace() (r bool, exists bool) {
	v := m.supports_network_namespace
	if v == nil {
		return
	}
	return *v, true
}

// OldSupportsNetworkNamespace returns the old "supports_network_namespace" field's value of the RouterCapability entity.
// If the RouterCapability object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RouterCapabilityMutation) OldSupportsNetworkNamespace(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSupportsNetworkNamespace is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSupportsNetworkNamespace requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSupportsNetworkNamespace: %w", err)
	}
	return oldValue.SupportsNetworkNamespace, nil
}

// ResetSupportsNetworkNamespace resets all changes to the "supports_network_namespace" field.
func (m *RouterCapabilityMutation) ResetSupportsNetworkNamespace() {
	m.supports_network_namespace = nil
}

// SetMaxContainers sets the "max_containers" field.
func (m *RouterCapabilityMutation) SetMaxContainers(i int) {
	m.max_containers = &i
	m.addmax_containers = nil
}

// MaxContainers returns the value of the "max_containers" field in the mutation.
func (m *RouterCapabilityMutation) MaxContainers() (r int, exists bool) {
	v := m.max_containers
	if v == nil {
		return
	}
	return *v, true
}

// OldMaxContainers returns the old "max_containers" field's value of the RouterCapability entity.
// If the RouterCapability object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RouterCapabilityMutation) OldMaxContainers(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMaxContainers is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMaxContainers requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaxContainers: %w", err)
	}
	return oldValue.MaxContainers, nil
}

// AddMaxContainers adds i to the "max_containers" field.
func (m *RouterCapabilityMutation) AddMaxContainers(i int) {
	if m.addmax_containers != nil {
		*m.addmax_containers += i
	} else {
		m.addmax_containers = &i
	}
}

// AddedMaxContainers returns the value that was added to the "max_containers" field in this mutation.
func (m *RouterCapabilityMutation) AddedMaxContainers() (r int, exists bool) {
	v := m.addmax_containers
	if v == nil {
		return
	}
	return *v, true
}

// ResetMaxContainers resets all changes to the "max_containers" field.
func (m *RouterCapabilityMutation) ResetMaxContainers() {
	m.max_containers = nil
	m.addmax_containers = nil
}

// SetCapabilityEntries sets the "capability_entries" field.
func (m *RouterCapabilityMutation) SetCapabilityEntries(value map[string]interface{}) {
	m.capability_entries = &value
}

// CapabilityEntries returns the value of the "capability_entries" field in the mutation.
func (m *RouterCapabilityMutation) CapabilityEntries() (r map[string]interface{}, exists bool) {
	v := m.capability_entries
	if v == nil {
		return
	}
	return *v, true
}

// OldCapabilityEntries returns the old "capability_entries" field's value of the RouterCapability entity.
// If the RouterCapability object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RouterCapabilityMutation) OldCapabilityEntries(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCapabilityEntries is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCapabilityEntries requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCapabilityEntries: %w", err)
	}
	return oldValue.CapabilityEntries, nil
}

// ResetCapabilityEntries resets all changes to the "capability_entries" field.
func (m *RouterCapabilityMutation) ResetCapabilityEntries() {
	m.capability_entries = nil
}

// SetDetectedAt sets the "detected_at" field.
func (m *RouterCapabilityMutation) SetDetectedAt(t time.Time) {
	m.detected_at = &t
}

// DetectedAt returns the value of the "detected_at" field in the mutation.
func (m *RouterCapabilityMutation) DetectedAt() (r time.Time, exists bool) {
	v := m.detected_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDetectedAt returns the old "detected_at" field's value of the RouterCapability entity.
// If the RouterCapability object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RouterCapabilityMutation) OldDetectedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDetectedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDetectedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDetectedAt: %w", err)
	}
	return oldValue.DetectedAt, nil
}

// ResetDetectedAt resets all changes to the "detected_at" field.
func (m *RouterCapabilityMutation) ResetDetectedAt() {
	m.detected_at = nil
}

// SetExpiresAt sets the "expires_at" field.
func (m *RouterCapabilityMutation) SetExpiresAt(t time.Time) {
	m.expires_at = &t
}

// ExpiresAt returns the value of the "expires_at" field in the mutation.
func (m *RouterCapabilityMutation) ExpiresAt() (r time.Time, exists bool) {
	v := m.expires_at
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiresAt returns the old "expires_at" field's value of the RouterCapability entity.
// If the RouterCapability object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RouterCapabilityMutation) OldExpiresAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiresAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiresAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiresAt: %w", err)
	}
	return oldValue.ExpiresAt, nil
}

// ResetExpiresAt resets all changes to the "expires_at" field.
func (m *RouterCapabilityMutation) ResetExpiresAt() {
	m.expires_at = nil
}

// SetIsRefreshing sets the "is_refreshing" field.
func (m *RouterCapabilityMutation) SetIsRefreshing(b bool) {
	m.is_refreshing = &b
}

// IsRefreshing returns the value of the "is_refreshing" field in the mutation.
func (m *RouterCapabilityMutation) IsRefreshing() (r bool, exists bool) {
	v := m.is_refreshing
	if v == nil {
		return
	}
	return *v, true
}

// OldIsRefreshing returns the old "is_refreshing" field's value of the RouterCapability entity.
// If the RouterCapability object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RouterCapabilityMutation) OldIsRefreshing(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsRefreshing is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsRefreshing requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsRefreshing: %w", err)
	}
	return oldValue.IsRefreshing, nil
}

// ResetIsRefreshing resets all changes to the "is_refreshing" field.
func (m *RouterCapabilityMutation) ResetIsRefreshing() {
	m.is_refreshing = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *RouterCapabilityMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *RouterCapabilityMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the RouterCapability entity.
// If the RouterCapability object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RouterCapabilityMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *RouterCapabilityMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *RouterCapabilityMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *RouterCapabilityMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the RouterCapability entity.
// If the RouterCapability object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RouterCapabilityMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *RouterCapabilityMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// Where appends a list predicates to the RouterCapabilityMutation builder.
func (m *RouterCapabilityMutation) Where(ps ...predicate.RouterCapability) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RouterCapabilityMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RouterCapabilityMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.RouterCapability, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RouterCapabilityMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RouterCapabilityMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (RouterCapability).
func (m *RouterCapabilityMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RouterCapabilityMutation) Fields() []string {
	fields := make([]string, 0, 27)
	if m.architecture != nil {
		fields = append(fields, routercapability.FieldArchitecture)
	}
	if m.model != nil {
		fields = append(fields, routercapability.FieldModel)
	}
	if m.board_name != nil {
		fields = append(fields, routercapability.FieldBoardName)
	}
	if m.total_memory != nil {
		fields = append(fields, routercapability.FieldTotalMemory)
	}
	if m.available_storage != nil {
		fields = append(fields, routercapability.FieldAvailableStorage)
	}
	if m.cpu_count != nil {
		fields = append(fields, routercapability.FieldCPUCount)
	}
	if m.has_wireless_chip != nil {
		fields = append(fields, routercapability.FieldHasWirelessChip)
	}
	if m.has_lte_module != nil {
		fields = append(fields, routercapability.FieldHasLteModule)
	}
	if m.version_raw != nil {
		fields = append(fields, routercapability.FieldVersionRaw)
	}
	if m.version_major != nil {
		fields = append(fields, routercapability.FieldVersionMajor)
	}
	if m.version_minor != nil {
		fields = append(fields, routercapability.FieldVersionMinor)
	}
	if m.version_patch != nil {
		fields = append(fields, routercapability.FieldVersionPatch)
	}
	if m.installed_packages != nil {
		fields = append(fields, routercapability.FieldInstalledPackages)
	}
	if m.license_level != nil {
		fields = append(fields, routercapability.FieldLicenseLevel)
	}
	if m.update_channel != nil {
		fields = append(fields, routercapability.FieldUpdateChannel)
	}
	if m.container_package_installed != nil {
		fields = append(fields, routercapability.FieldContainerPackageInstalled)
	}
	if m.container_enabled != nil {
		fields = append(fields, routercapability.FieldContainerEnabled)
	}
	if m.container_registry_configured != nil {
		fields = append(fields, routercapability.FieldContainerRegistryConfigured)
	}
	if m.container_storage_available != nil {
		fields = append(fields, routercapability.FieldContainerStorageAvailable)
	}
	if m.supports_network_namespace != nil {
		fields = append(fields, routercapability.FieldSupportsNetworkNamespace)
	}
	if m.max_containers != nil {
		fields = append(fields, routercapability.FieldMaxContainers)
	}
	if m.capability_entries != nil {
		fields = append(fields, routercapability.FieldCapabilityEntries)
	}
	if m.detected_at != nil {
		fields = append(fields, routercapability.FieldDetectedAt)
	}
	if m.expires_at != nil {
		fields = append(fields, routercapability.FieldExpiresAt)
	}
	if m.is_refreshing != nil {
		fields = append(fields, routercapability.FieldIsRefreshing)
	}
	if m.created_at != nil {
		fields = append(fields, routercapability.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, routercapability.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RouterCapabilityMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case routercapability.FieldArchitecture:
		return m.Architecture()
	case routercapability.FieldModel:
		return m.Model()
	case routercapability.FieldBoardName:
		return m.BoardName()
	case routercapability.FieldTotalMemory:
		return m.TotalMemory()
	case routercapability.FieldAvailableStorage:
		return m.AvailableStorage()
	case routercapability.FieldCPUCount:
		return m.CPUCount()
	case routercapability.FieldHasWirelessChip:
		return m.HasWirelessChip()
	case routercapability.FieldHasLteModule:
		return m.HasLteModule()
	case routercapability.FieldVersionRaw:
		return m.VersionRaw()
	case routercapability.FieldVersionMajor:
		return m.VersionMajor()
	case routercapability.FieldVersionMinor:
		return m.VersionMinor()
	case routercapability.FieldVersionPatch:
		return m.VersionPatch()
	case routercapability.FieldInstalledPackages:
		return m.InstalledPackages()
	case routercapability.FieldLicenseLevel:
		return m.LicenseLevel()
	case routercapability.FieldUpdateChannel:
		return m.UpdateChannel()
	case routercapability.FieldContainerPackageInstalled:
		return m.ContainerPackageInstalled()
	case routercapability.FieldContainerEnabled:
		return m.ContainerEnabled()
	case routercapability.FieldContainerRegistryConfigured:
		return m.ContainerRegistryConfigured()
	case routercapability.FieldContainerStorageAvailable:
		return m.ContainerStorageAvailable()
	case routercapability.FieldSupportsNetworkNamespace:
		return m.SupportsNetworkNamespace()
	case routercapability.FieldMaxContainers:
		return m.MaxContainers()
	case routercapability.FieldCapabilityEntries:
		return m.CapabilityEntries()
	case routercapability.FieldDetectedAt:
		return m.DetectedAt()
	case routercapability.FieldExpiresAt:
		return m.ExpiresAt()
	case routercapability.FieldIsRefreshing:
		return m.IsRefreshing()
	case routercapability.FieldCreatedAt:
		return m.CreatedAt()
	case routercapability.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RouterCapabilityMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case routercapability.FieldArchitecture:
		return m.OldArchitecture(ctx)
	case routercapability.FieldModel:
		return m.OldModel(ctx)
	case routercapability.FieldBoardName:
		return m.OldBoardName(ctx)
	case routercapability.FieldTotalMemory:
		return m.OldTotalMemory(ctx)
	case routercapability.FieldAvailableStorage:
		return m.OldAvailableStorage(ctx)
	case routercapability.FieldCPUCount:
		return m.OldCPUCount(ctx)
	case routercapability.FieldHasWirelessChip:
		return m.OldHasWirelessChip(ctx)
	case routercapability.FieldHasLteModule:
		return m.OldHasLteModule(ctx)
	case routercapability.FieldVersionRaw:
		return m.OldVersionRaw(ctx)
	case routercapability.FieldVersionMajor:
		return m.OldVersionMajor(ctx)
	case routercapability.FieldVersionMinor:
		return m.OldVersionMinor(ctx)
	case routercapability.FieldVersionPatch:
		return m.OldVersionPatch(ctx)
	case routercapability.FieldInstalledPackages:
		return m.OldInstalledPackages(ctx)
	case routercapability.FieldLicenseLevel:
		return m.OldLicenseLevel(ctx)
	case routercapability.FieldUpdateChannel:
		return m.OldUpdateChannel(ctx)
	case routercapability.FieldContainerPackageInstalled:
		return m.OldContainerPackageInstalled(ctx)
	case routercapability.FieldContainerEnabled:
		return m.OldContainerEnabled(ctx)
	case routercapability.FieldContainerRegistryConfigured:
		return m.OldContainerRegistryConfigured(ctx)
	case routercapability.FieldContainerStorageAvailable:
		return m.OldContainerStorageAvailable(ctx)
	case routercapability.FieldSupportsNetworkNamespace:
		return m.OldSupportsNetworkNamespace(ctx)
	case routercapability.FieldMaxContainers:
		return m.OldMaxContainers(ctx)
	case routercapability.FieldCapabilityEntries:
		return m.OldCapabilityEntries(ctx)
	case routercapability.FieldDetectedAt:
		return m.OldDetectedAt(ctx)
	case routercapability.FieldExpiresAt:
		return m.OldExpiresAt(ctx)
	case routercapability.FieldIsRefreshing:
		return m.OldIsRefreshing(ctx)
	case routercapability.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case routercapability.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown RouterCapability field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RouterCapabilityMutation) SetField(name string, value ent.Value) error {
	switch name {
	case routercapability.FieldArchitecture:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetArchitecture(v)
		return nil
	case routercapability.FieldModel:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModel(v)
		return nil
	case routercapability.FieldBoardName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBoardName(v)
		return nil
	case routercapability.FieldTotalMemory:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalMemory(v)
		return nil
	case routercapability.FieldAvailableStorage:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAvailableStorage(v)
		return nil
	case routercapability.FieldCPUCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCPUCount(v)
		return nil
	case routercapability.FieldHasWirelessChip:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHasWirelessChip(v)
		return nil
	case routercapability.FieldHasLteModule:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHasLteModule(v)
		return nil
	case routercapability.FieldVersionRaw:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersionRaw(v)
		return nil
	case routercapability.FieldVersionMajor:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersionMajor(v)
		return nil
	case routercapability.FieldVersionMinor:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersionMinor(v)
		return nil
	case routercapability.FieldVersionPatch:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersionPatch(v)
		return nil
	case routercapability.FieldInstalledPackages:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInstalledPackages(v)
		return nil
	case routercapability.FieldLicenseLevel:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLicenseLevel(v)
		return nil
	case routercapability.FieldUpdateChannel:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateChannel(v)
		return nil
	case routercapability.FieldContainerPackageInstalled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContainerPackageInstalled(v)
		return nil
	case routercapability.FieldContainerEnabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContainerEnabled(v)
		return nil
	case routercapability.FieldContainerRegistryConfigured:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContainerRegistryConfigured(v)
		return nil
	case routercapability.FieldContainerStorageAvailable:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContainerStorageAvailable(v)
		return nil
	case routercapability.FieldSupportsNetworkNamespace:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSupportsNetworkNamespace(v)
		return nil
	case routercapability.FieldMaxContainers:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaxContainers(v)
		return nil
	case routercapability.FieldCapabilityEntries:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCapabilityEntries(v)
		return nil
	case routercapability.FieldDetectedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDetectedAt(v)
		return nil
	case routercapability.FieldExpiresAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiresAt(v)
		return nil
	case routercapability.FieldIsRefreshing:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsRefreshing(v)
		return nil
	case routercapability.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case routercapability.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown RouterCapability field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RouterCapabilityMutation) AddedFields() []string {
	var fields []string
	if m.addtotal_memory != nil {
		fields = append(fields, routercapability.FieldTotalMemory)
	}
	if m.addavailable_storage != nil {
		fields = append(fields, routercapability.FieldAvailableStorage)
	}
	if m.addcpu_count != nil {
		fields = append(fields, routercapability.FieldCPUCount)
	}
	if m.addversion_major != nil {
		fields = append(fields, routercapability.FieldVersionMajor)
	}
	if m.addversion_minor != nil {
		fields = append(fields, routercapability.FieldVersionMinor)
	}
	if m.addversion_patch != nil {
		fields = append(fields, routercapability.FieldVersionPatch)
	}
	if m.addlicense_level != nil {
		fields = append(fields, routercapability.FieldLicenseLevel)
	}
	if m.addcontainer_storage_available != nil {
		fields = append(fields, routercapability.FieldContainerStorageAvailable)
	}
	if m.addmax_containers != nil {
		fields = append(fields, routercapability.FieldMaxContainers)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RouterCapabilityMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case routercapability.FieldTotalMemory:
		return m.AddedTotalMemory()
	case routercapability.FieldAvailableStorage:
		return m.AddedAvailableStorage()
	case routercapability.FieldCPUCount:
		return m.AddedCPUCount()
	case routercapability.FieldVersionMajor:
		return m.AddedVersionMajor()
	case routercapability.FieldVersionMinor:
		return m.AddedVersionMinor()
	case routercapability.FieldVersionPatch:
		return m.AddedVersionPatch()
	case routercapability.FieldLicenseLevel:
		return m.AddedLicenseLevel()
	case routercapability.FieldContainerStorageAvailable:
		return m.AddedContainerStorageAvailable()
	case routercapability.FieldMaxContainers:
		return m.AddedMaxContainers()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RouterCapabilityMutation) AddField(name string, value ent.Value) error {
	switch name {
	case routercapability.FieldTotalMemory:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotalMemory(v)
		return nil
	case routercapability.FieldAvailableStorage:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAvailableStorage(v)
		return nil
	case routercapability.FieldCPUCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCPUCount(v)
		return nil
	case routercapability.FieldVersionMajor:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVersionMajor(v)
		return nil
	case routercapability.FieldVersionMinor:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVersionMinor(v)
		return nil
	case routercapability.FieldVersionPatch:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVersionPatch(v)
		return nil
	case routercapability.FieldLicenseLevel:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLicenseLevel(v)
		return nil
	case routercapability.FieldContainerStorageAvailable:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddContainerStorageAvailable(v)
		return nil
	case routercapability.FieldMaxContainers:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMaxContainers(v)
		return nil
	}
	return fmt.Errorf("unknown RouterCapability numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RouterCapabilityMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(routercapability.FieldModel) {
		fields = append(fields, routercapability.FieldModel)
	}
	if m.FieldCleared(routercapability.FieldBoardName) {
		fields = append(fields, routercapability.FieldBoardName)
	}
	if m.FieldCleared(routercapability.FieldUpdateChannel) {
		fields = append(fields, routercapability.FieldUpdateChannel)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RouterCapabilityMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RouterCapabilityMutation) ClearField(name string) error {
	switch name {
	case routercapability.FieldModel:
		m.ClearModel()
		return nil
	case routercapability.FieldBoardName:
		m.ClearBoardName()
		return nil
	case routercapability.FieldUpdateChannel:
		m.ClearUpdateChannel()
		return nil
	}
	return fmt.Errorf("unknown RouterCapability nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RouterCapabilityMutation) ResetField(name string) error {
	switch name {
	case routercapability.FieldArchitecture:
		m.ResetArchitecture()
		return nil
	case routercapability.FieldModel:
		m.ResetModel()
		return nil
	case routercapability.FieldBoardName:
		m.ResetBoardName()
		return nil
	case routercapability.FieldTotalMemory:
		m.ResetTotalMemory()
		return nil
	case routercapability.FieldAvailableStorage:
		m.ResetAvailableStorage()
		return nil
	case routercapability.FieldCPUCount:
		m.ResetCPUCount()
		return nil
	case routercapability.FieldHasWirelessChip:
		m.ResetHasWirelessChip()
		return nil
	case routercapability.FieldHasLteModule:
		m.ResetHasLteModule()
		return nil
	case routercapability.FieldVersionRaw:
		m.ResetVersionRaw()
		return nil
	case routercapability.FieldVersionMajor:
		m.ResetVersionMajor()
		return nil
	case routercapability.FieldVersionMinor:
		m.ResetVersionMinor()
		return nil
	case routercapability.FieldVersionPatch:
		m.ResetVersionPatch()
		return nil
	case routercapability.FieldInstalledPackages:
		m.ResetInstalledPackages()
		return nil
	case routercapability.FieldLicenseLevel:
		m.ResetLicenseLevel()
		return nil
	case routercapability.FieldUpdateChannel:
		m.ResetUpdateChannel()
		return nil
	case routercapability.FieldContainerPackageInstalled:
		m.ResetContainerPackageInstalled()
		return nil
	case routercapability.FieldContainerEnabled:
		m.ResetContainerEnabled()
		return nil
	case routercapability.FieldContainerRegistryConfigured:
		m.ResetContainerRegistryConfigured()
		return nil
	case routercapability.FieldContainerStorageAvailable:
		m.ResetContainerStorageAvailable()
		return nil
	case routercapability.FieldSupportsNetworkNamespace:
		m.ResetSupportsNetworkNamespace()
		return nil
	case routercapability.FieldMaxContainers:
		m.ResetMaxContainers()
		return nil
	case routercapability.FieldCapabilityEntries:
		m.ResetCapabilityEntries()
		return nil
	case routercapability.FieldDetectedAt:
		m.ResetDetectedAt()
		return nil
	case routercapability.FieldExpiresAt:
		m.ResetExpiresAt()
		return nil
	case routercapability.FieldIsRefreshing:
		m.ResetIsRefreshing()
		return nil
	case routercapability.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case routercapability.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown RouterCapability field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RouterCapabilityMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RouterCapabilityMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RouterCapabilityMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RouterCapabilityMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RouterCapabilityMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RouterCapabilityMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RouterCapabilityMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown RouterCapability unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RouterCapabilityMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown RouterCapability edge %s", name)
}

// RouterSecretMutation represents an operation that mutates the RouterSecret nodes in the graph.
type RouterSecretMutation struct {
	config
	op                 Op
	typ                string
	id                 *string
	encrypted_username *[]byte
	encrypted_password *[]byte
	encryption_nonce   *[]byte
	key_version        *int
	addkey_version     *int
	created_at         *time.Time
	updated_at         *time.Time
	clearedFields      map[string]struct{}
	router             *string
	clearedrouter      bool
	done               bool
	oldValue           func(context.Context) (*RouterSecret, error)
	predicates         []predicate.RouterSecret
}

var _ ent.Mutation = (*RouterSecretMutation)(nil)

// routersecretOption allows management of the mutation configuration using functional options.
type routersecretOption func(*RouterSecretMutation)

// newRouterSecretMutation creates new mutation for the RouterSecret entity.
func newRouterSecretMutation(c config, op Op, opts ...routersecretOption) *RouterSecretMutation {
	m := &RouterSecretMutation{
		config:        c,
		op:            op,
		typ:           TypeRouterSecret,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRouterSecretID sets the ID field of the mutation.
func withRouterSecretID(id string) routersecretOption {
	return func(m *RouterSecretMutation) {
		var (
			err   error
			once  sync.Once
			value *RouterSecret
		)
		m.oldValue = func(ctx context.Context) (*RouterSecret, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().RouterSecret.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRouterSecret sets the old RouterSecret of the mutation.
func withRouterSecret(node *RouterSecret) routersecretOption {
	return func(m *RouterSecretMutation) {
		m.oldValue = func(context.Context) (*RouterSecret, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RouterSecretMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RouterSecretMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of RouterSecret entities.
func (m *RouterSecretMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RouterSecretMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RouterSecretMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().RouterSecret.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetRouterID sets the "router_id" field.
func (m *RouterSecretMutation) SetRouterID(s string) {
	m.router = &s
}

// RouterID returns the value of the "router_id" field in the mutation.
func (m *RouterSecretMutation) RouterID() (r string, exists bool) {
	v := m.router
	if v == nil {
		return
	}
	return *v, true
}

// OldRouterID returns the old "router_id" field's value of the RouterSecret entity.
// If the RouterSecret object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RouterSecretMutation) OldRouterID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRouterID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRouterID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRouterID: %w", err)
	}
	return oldValue.RouterID, nil
}

// ResetRouterID resets all changes to the "router_id" field.
func (m *RouterSecretMutation) ResetRouterID() {
	m.router = nil
}

// SetEncryptedUsername sets the "encrypted_username" field.
func (m *RouterSecretMutation) SetEncryptedUsername(b []byte) {
	m.encrypted_username = &b
}

// EncryptedUsername returns the value of the "encrypted_username" field in the mutation.
func (m *RouterSecretMutation) EncryptedUsername() (r []byte, exists bool) {
	v := m.encrypted_username
	if v == nil {
		return
	}
	return *v, true
}

// OldEncryptedUsername returns the old "encrypted_username" field's value of the RouterSecret entity.
// If the RouterSecret object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RouterSecretMutation) OldEncryptedUsername(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEncryptedUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEncryptedUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEncryptedUsername: %w", err)
	}
	return oldValue.EncryptedUsername, nil
}

// ResetEncryptedUsername resets all changes to the "encrypted_username" field.
func (m *RouterSecretMutation) ResetEncryptedUsername() {
	m.encrypted_username = nil
}

// SetEncryptedPassword sets the "encrypted_password" field.
func (m *RouterSecretMutation) SetEncryptedPassword(b []byte) {
	m.encrypted_password = &b
}

// EncryptedPassword returns the value of the "encrypted_password" field in the mutation.
func (m *RouterSecretMutation) EncryptedPassword() (r []byte, exists bool) {
	v := m.encrypted_password
	if v == nil {
		return
	}
	return *v, true
}

// OldEncryptedPassword returns the old "encrypted_password" field's value of the RouterSecret entity.
// If the RouterSecret object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RouterSecretMutation) OldEncryptedPassword(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEncryptedPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEncryptedPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEncryptedPassword: %w", err)
	}
	return oldValue.EncryptedPassword, nil
}

// ResetEncryptedPassword resets all changes to the "encrypted_password" field.
func (m *RouterSecretMutation) ResetEncryptedPassword() {
	m.encrypted_password = nil
}

// SetEncryptionNonce sets the "encryption_nonce" field.
func (m *RouterSecretMutation) SetEncryptionNonce(b []byte) {
	m.encryption_nonce = &b
}

// EncryptionNonce returns the value of the "encryption_nonce" field in the mutation.
func (m *RouterSecretMutation) EncryptionNonce() (r []byte, exists bool) {
	v := m.encryption_nonce
	if v == nil {
		return
	}
	return *v, true
}

// OldEncryptionNonce returns the old "encryption_nonce" field's value of the RouterSecret entity.
// If the RouterSecret object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RouterSecretMutation) OldEncryptionNonce(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEncryptionNonce is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEncryptionNonce requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEncryptionNonce: %w", err)
	}
	return oldValue.EncryptionNonce, nil
}

// ResetEncryptionNonce resets all changes to the "encryption_nonce" field.
func (m *RouterSecretMutation) ResetEncryptionNonce() {
	m.encryption_nonce = nil
}

// SetKeyVersion sets the "key_version" field.
func (m *RouterSecretMutation) SetKeyVersion(i int) {
	m.key_version = &i
	m.addkey_version = nil
}

// KeyVersion returns the value of the "key_version" field in the mutation.
func (m *RouterSecretMutation) KeyVersion() (r int, exists bool) {
	v := m.key_version
	if v == nil {
		return
	}
	return *v, true
}

// OldKeyVersion returns the old "key_version" field's value of the RouterSecret entity.
// If the RouterSecret object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RouterSecretMutation) OldKeyVersion(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKeyVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKeyVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKeyVersion: %w", err)
	}
	return oldValue.KeyVersion, nil
}

// AddKeyVersion adds i to the "key_version" field.
func (m *RouterSecretMutation) AddKeyVersion(i int) {
	if m.addkey_version != nil {
		*m.addkey_version += i
	} else {
		m.addkey_version = &i
	}
}

// AddedKeyVersion returns the value that was added to the "key_version" field in this mutation.
func (m *RouterSecretMutation) AddedKeyVersion() (r int, exists bool) {
	v := m.addkey_version
	if v == nil {
		return
	}
	return *v, true
}

// ResetKeyVersion resets all changes to the "key_version" field.
func (m *RouterSecretMutation) ResetKeyVersion() {
	m.key_version = nil
	m.addkey_version = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *RouterSecretMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *RouterSecretMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the RouterSecret entity.
// If the RouterSecret object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RouterSecretMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *RouterSecretMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *RouterSecretMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *RouterSecretMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the RouterSecret entity.
// If the RouterSecret object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RouterSecretMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *RouterSecretMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearRouter clears the "router" edge to the Router entity.
func (m *RouterSecretMutation) ClearRouter() {
	m.clearedrouter = true
	m.clearedFields[routersecret.FieldRouterID] = struct{}{}
}

// RouterCleared reports if the "router" edge to the Router entity was cleared.
func (m *RouterSecretMutation) RouterCleared() bool {
	return m.clearedrouter
}

// RouterIDs returns the "router" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RouterID instead. It exists only for internal usage by the builders.
func (m *RouterSecretMutation) RouterIDs() (ids []string) {
	if id := m.router; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRouter resets all changes to the "router" edge.
func (m *RouterSecretMutation) ResetRouter() {
	m.router = nil
	m.clearedrouter = false
}

// Where appends a list predicates to the RouterSecretMutation builder.
func (m *RouterSecretMutation) Where(ps ...predicate.RouterSecret) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RouterSecretMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RouterSecretMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.RouterSecret, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RouterSecretMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RouterSecretMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (RouterSecret).
func (m *RouterSecretMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RouterSecretMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.router != nil {
		fields = append(fields, routersecret.FieldRouterID)
	}
	if m.encrypted_username != nil {
		fields = append(fields, routersecret.FieldEncryptedUsername)
	}
	if m.encrypted_password != nil {
		fields = append(fields, routersecret.FieldEncryptedPassword)
	}
	if m.encryption_nonce != nil {
		fields = append(fields, routersecret.FieldEncryptionNonce)
	}
	if m.key_version != nil {
		fields = append(fields, routersecret.FieldKeyVersion)
	}
	if m.created_at != nil {
		fields = append(fields, routersecret.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, routersecret.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RouterSecretMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case routersecret.FieldRouterID:
		return m.RouterID()
	case routersecret.FieldEncryptedUsername:
		return m.EncryptedUsername()
	case routersecret.FieldEncryptedPassword:
		return m.EncryptedPassword()
	case routersecret.FieldEncryptionNonce:
		return m.EncryptionNonce()
	case routersecret.FieldKeyVersion:
		return m.KeyVersion()
	case routersecret.FieldCreatedAt:
		return m.CreatedAt()
	case routersecret.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RouterSecretMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case routersecret.FieldRouterID:
		return m.OldRouterID(ctx)
	case routersecret.FieldEncryptedUsername:
		return m.OldEncryptedUsername(ctx)
	case routersecret.FieldEncryptedPassword:
		return m.OldEncryptedPassword(ctx)
	case routersecret.FieldEncryptionNonce:
		return m.OldEncryptionNonce(ctx)
	case routersecret.FieldKeyVersion:
		return m.OldKeyVersion(ctx)
	case routersecret.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case routersecret.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown RouterSecret field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RouterSecretMutation) SetField(name string, value ent.Value) error {
	switch name {
	case routersecret.FieldRouterID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRouterID(v)
		return nil
	case routersecret.FieldEncryptedUsername:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEncryptedUsername(v)
		return nil
	case routersecret.FieldEncryptedPassword:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEncryptedPassword(v)
		return nil
	case routersecret.FieldEncryptionNonce:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEncryptionNonce(v)
		return nil
	case routersecret.FieldKeyVersion:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKeyVersion(v)
		return nil
	case routersecret.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case routersecret.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown RouterSecret field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RouterSecretMutation) AddedFields() []string {
	var fields []string
	if m.addkey_version != nil {
		fields = append(fields, routersecret.FieldKeyVersion)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RouterSecretMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case routersecret.FieldKeyVersion:
		return m.AddedKeyVersion()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RouterSecretMutation) AddField(name string, value ent.Value) error {
	switch name {
	case routersecret.FieldKeyVersion:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddKeyVersion(v)
		return nil
	}
	return fmt.Errorf("unknown RouterSecret numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RouterSecretMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RouterSecretMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RouterSecretMutation) ClearField(name string) error {
	return fmt.Errorf("unknown RouterSecret nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RouterSecretMutation) ResetField(name string) error {
	switch name {
	case routersecret.FieldRouterID:
		m.ResetRouterID()
		return nil
	case routersecret.FieldEncryptedUsername:
		m.ResetEncryptedUsername()
		return nil
	case routersecret.FieldEncryptedPassword:
		m.ResetEncryptedPassword()
		return nil
	case routersecret.FieldEncryptionNonce:
		m.ResetEncryptionNonce()
		return nil
	case routersecret.FieldKeyVersion:
		m.ResetKeyVersion()
		return nil
	case routersecret.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case routersecret.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown RouterSecret field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RouterSecretMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.router != nil {
		edges = append(edges, routersecret.EdgeRouter)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RouterSecretMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case routersecret.EdgeRouter:
		if id := m.router; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RouterSecretMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RouterSecretMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RouterSecretMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedrouter {
		edges = append(edges, routersecret.EdgeRouter)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RouterSecretMutation) EdgeCleared(name string) bool {
	switch name {
	case routersecret.EdgeRouter:
		return m.clearedrouter
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RouterSecretMutation) ClearEdge(name string) error {
	switch name {
	case routersecret.EdgeRouter:
		m.ClearRouter()
		return nil
	}
	return fmt.Errorf("unknown RouterSecret unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RouterSecretMutation) ResetEdge(name string) error {
	switch name {
	case routersecret.EdgeRouter:
		m.ResetRouter()
		return nil
	}
	return fmt.Errorf("unknown RouterSecret edge %s", name)
}

// SchemaVersionMutation represents an operation that mutates the SchemaVersion nodes in the graph.
type SchemaVersionMutation struct {
	config
	op                   Op
	typ                  string
	id                   *string
	version              *int64
	addversion           *int64
	name                 *string
	checksum             *string
	applied              *bool
	error_message        *string
	execution_time_ms    *int64
	addexecution_time_ms *int64
	applied_at           *time.Time
	clearedFields        map[string]struct{}
	done                 bool
	oldValue             func(context.Context) (*SchemaVersion, error)
	predicates           []predicate.SchemaVersion
}

var _ ent.Mutation = (*SchemaVersionMutation)(nil)

// schemaversionOption allows management of the mutation configuration using functional options.
type schemaversionOption func(*SchemaVersionMutation)

// newSchemaVersionMutation creates new mutation for the SchemaVersion entity.
func newSchemaVersionMutation(c config, op Op, opts ...schemaversionOption) *SchemaVersionMutation {
	m := &SchemaVersionMutation{
		config:        c,
		op:            op,
		typ:           TypeSchemaVersion,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSchemaVersionID sets the ID field of the mutation.
func withSchemaVersionID(id string) schemaversionOption {
	return func(m *SchemaVersionMutation) {
		var (
			err   error
			once  sync.Once
			value *SchemaVersion
		)
		m.oldValue = func(ctx context.Context) (*SchemaVersion, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SchemaVersion.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSchemaVersion sets the old SchemaVersion of the mutation.
func withSchemaVersion(node *SchemaVersion) schemaversionOption {
	return func(m *SchemaVersionMutation) {
		m.oldValue = func(context.Context) (*SchemaVersion, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SchemaVersionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SchemaVersionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of SchemaVersion entities.
func (m *SchemaVersionMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SchemaVersionMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SchemaVersionMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SchemaVersion.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetVersion sets the "version" field.
func (m *SchemaVersionMutation) SetVersion(i int64) {
	m.version = &i
	m.addversion = nil
}

// Version returns the value of the "version" field in the mutation.
func (m *SchemaVersionMutation) Version() (r int64, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the SchemaVersion entity.
// If the SchemaVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SchemaVersionMutation) OldVersion(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// AddVersion adds i to the "version" field.
func (m *SchemaVersionMutation) AddVersion(i int64) {
	if m.addversion != nil {
		*m.addversion += i
	} else {
		m.addversion = &i
	}
}

// AddedVersion returns the value that was added to the "version" field in this mutation.
func (m *SchemaVersionMutation) AddedVersion() (r int64, exists bool) {
	v := m.addversion
	if v == nil {
		return
	}
	return *v, true
}

// ResetVersion resets all changes to the "version" field.
func (m *SchemaVersionMutation) ResetVersion() {
	m.version = nil
	m.addversion = nil
}

// SetName sets the "name" field.
func (m *SchemaVersionMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *SchemaVersionMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the SchemaVersion entity.
// If the SchemaVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SchemaVersionMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *SchemaVersionMutation) ResetName() {
	m.name = nil
}

// SetChecksum sets the "checksum" field.
func (m *SchemaVersionMutation) SetChecksum(s string) {
	m.checksum = &s
}

// Checksum returns the value of the "checksum" field in the mutation.
func (m *SchemaVersionMutation) Checksum() (r string, exists bool) {
	v := m.checksum
	if v == nil {
		return
	}
	return *v, true
}

// OldChecksum returns the old "checksum" field's value of the SchemaVersion entity.
// If the SchemaVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SchemaVersionMutation) OldChecksum(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChecksum is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChecksum requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChecksum: %w", err)
	}
	return oldValue.Checksum, nil
}

// ResetChecksum resets all changes to the "checksum" field.
func (m *SchemaVersionMutation) ResetChecksum() {
	m.checksum = nil
}

// SetApplied sets the "applied" field.
func (m *SchemaVersionMutation) SetApplied(b bool) {
	m.applied = &b
}

// Applied returns the value of the "applied" field in the mutation.
func (m *SchemaVersionMutation) Applied() (r bool, exists bool) {
	v := m.applied
	if v == nil {
		return
	}
	return *v, true
}

// OldApplied returns the old "applied" field's value of the SchemaVersion entity.
// If the SchemaVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SchemaVersionMutation) OldApplied(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldApplied is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldApplied requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldApplied: %w", err)
	}
	return oldValue.Applied, nil
}

// ResetApplied resets all changes to the "applied" field.
func (m *SchemaVersionMutation) ResetApplied() {
	m.applied = nil
}

// SetErrorMessage sets the "error_message" field.
func (m *SchemaVersionMutation) SetErrorMessage(s string) {
	m.error_message = &s
}

// ErrorMessage returns the value of the "error_message" field in the mutation.
func (m *SchemaVersionMutation) ErrorMessage() (r string, exists bool) {
	v := m.error_message
	if v == nil {
		return
	}
	return *v, true
}

// OldErrorMessage returns the old "error_message" field's value of the SchemaVersion entity.
// If the SchemaVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SchemaVersionMutation) OldErrorMessage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldErrorMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldErrorMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldErrorMessage: %w", err)
	}
	return oldValue.ErrorMessage, nil
}

// ClearErrorMessage clears the value of the "error_message" field.
func (m *SchemaVersionMutation) ClearErrorMessage() {
	m.error_message = nil
	m.clearedFields[schemaversion.FieldErrorMessage] = struct{}{}
}

// ErrorMessageCleared returns if the "error_message" field was cleared in this mutation.
func (m *SchemaVersionMutation) ErrorMessageCleared() bool {
	_, ok := m.clearedFields[schemaversion.FieldErrorMessage]
	return ok
}

// ResetErrorMessage resets all changes to the "error_message" field.
func (m *SchemaVersionMutation) ResetErrorMessage() {
	m.error_message = nil
	delete(m.clearedFields, schemaversion.FieldErrorMessage)
}

// SetExecutionTimeMs sets the "execution_time_ms" field.
func (m *SchemaVersionMutation) SetExecutionTimeMs(i int64) {
	m.execution_time_ms = &i
	m.addexecution_time_ms = nil
}

// ExecutionTimeMs returns the value of the "execution_time_ms" field in the mutation.
func (m *SchemaVersionMutation) ExecutionTimeMs() (r int64, exists bool) {
	v := m.execution_time_ms
	if v == nil {
		return
	}
	return *v, true
}

// OldExecutionTimeMs returns the old "execution_time_ms" field's value of the SchemaVersion entity.
// If the SchemaVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SchemaVersionMutation) OldExecutionTimeMs(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExecutionTimeMs is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExecutionTimeMs requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExecutionTimeMs: %w", err)
	}
	return oldValue.ExecutionTimeMs, nil
}

// AddExecutionTimeMs adds i to the "execution_time_ms" field.
func (m *SchemaVersionMutation) AddExecutionTimeMs(i int64) {
	if m.addexecution_time_ms != nil {
		*m.addexecution_time_ms += i
	} else {
		m.addexecution_time_ms = &i
	}
}

// AddedExecutionTimeMs returns the value that was added to the "execution_time_ms" field in this mutation.
func (m *SchemaVersionMutation) AddedExecutionTimeMs() (r int64, exists bool) {
	v := m.addexecution_time_ms
	if v == nil {
		return
	}
	return *v, true
}

// ClearExecutionTimeMs clears the value of the "execution_time_ms" field.
func (m *SchemaVersionMutation) ClearExecutionTimeMs() {
	m.execution_time_ms = nil
	m.addexecution_time_ms = nil
	m.clearedFields[schemaversion.FieldExecutionTimeMs] = struct{}{}
}

// ExecutionTimeMsCleared returns if the "execution_time_ms" field was cleared in this mutation.
func (m *SchemaVersionMutation) ExecutionTimeMsCleared() bool {
	_, ok := m.clearedFields[schemaversion.FieldExecutionTimeMs]
	return ok
}

// ResetExecutionTimeMs resets all changes to the "execution_time_ms" field.
func (m *SchemaVersionMutation) ResetExecutionTimeMs() {
	m.execution_time_ms = nil
	m.addexecution_time_ms = nil
	delete(m.clearedFields, schemaversion.FieldExecutionTimeMs)
}

// SetAppliedAt sets the "applied_at" field.
func (m *SchemaVersionMutation) SetAppliedAt(t time.Time) {
	m.applied_at = &t
}

// AppliedAt returns the value of the "applied_at" field in the mutation.
func (m *SchemaVersionMutation) AppliedAt() (r time.Time, exists bool) {
	v := m.applied_at
	if v == nil {
		return
	}
	return *v, true
}

// OldAppliedAt returns the old "applied_at" field's value of the SchemaVersion entity.
// If the SchemaVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SchemaVersionMutation) OldAppliedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppliedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppliedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppliedAt: %w", err)
	}
	return oldValue.AppliedAt, nil
}

// ResetAppliedAt resets all changes to the "applied_at" field.
func (m *SchemaVersionMutation) ResetAppliedAt() {
	m.applied_at = nil
}

// Where appends a list predicates to the SchemaVersionMutation builder.
func (m *SchemaVersionMutation) Where(ps ...predicate.SchemaVersion) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SchemaVersionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SchemaVersionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.SchemaVersion, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SchemaVersionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SchemaVersionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (SchemaVersion).
func (m *SchemaVersionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SchemaVersionMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.version != nil {
		fields = append(fields, schemaversion.FieldVersion)
	}
	if m.name != nil {
		fields = append(fields, schemaversion.FieldName)
	}
	if m.checksum != nil {
		fields = append(fields, schemaversion.FieldChecksum)
	}
	if m.applied != nil {
		fields = append(fields, schemaversion.FieldApplied)
	}
	if m.error_message != nil {
		fields = append(fields, schemaversion.FieldErrorMessage)
	}
	if m.execution_time_ms != nil {
		fields = append(fields, schemaversion.FieldExecutionTimeMs)
	}
	if m.applied_at != nil {
		fields = append(fields, schemaversion.FieldAppliedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SchemaVersionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case schemaversion.FieldVersion:
		return m.Version()
	case schemaversion.FieldName:
		return m.Name()
	case schemaversion.FieldChecksum:
		return m.Checksum()
	case schemaversion.FieldApplied:
		return m.Applied()
	case schemaversion.FieldErrorMessage:
		return m.ErrorMessage()
	case schemaversion.FieldExecutionTimeMs:
		return m.ExecutionTimeMs()
	case schemaversion.FieldAppliedAt:
		return m.AppliedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SchemaVersionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case schemaversion.FieldVersion:
		return m.OldVersion(ctx)
	case schemaversion.FieldName:
		return m.OldName(ctx)
	case schemaversion.FieldChecksum:
		return m.OldChecksum(ctx)
	case schemaversion.FieldApplied:
		return m.OldApplied(ctx)
	case schemaversion.FieldErrorMessage:
		return m.OldErrorMessage(ctx)
	case schemaversion.FieldExecutionTimeMs:
		return m.OldExecutionTimeMs(ctx)
	case schemaversion.FieldAppliedAt:
		return m.OldAppliedAt(ctx)
	}
	return nil, fmt.Errorf("unknown SchemaVersion field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SchemaVersionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case schemaversion.FieldVersion:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case schemaversion.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case schemaversion.FieldChecksum:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChecksum(v)
		return nil
	case schemaversion.FieldApplied:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetApplied(v)
		return nil
	case schemaversion.FieldErrorMessage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetErrorMessage(v)
		return nil
	case schemaversion.FieldExecutionTimeMs:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExecutionTimeMs(v)
		return nil
	case schemaversion.FieldAppliedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppliedAt(v)
		return nil
	}
	return fmt.Errorf("unknown SchemaVersion field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SchemaVersionMutation) AddedFields() []string {
	var fields []string
	if m.addversion != nil {
		fields = append(fields, schemaversion.FieldVersion)
	}
	if m.addexecution_time_ms != nil {
		fields = append(fields, schemaversion.FieldExecutionTimeMs)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SchemaVersionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case schemaversion.FieldVersion:
		return m.AddedVersion()
	case schemaversion.FieldExecutionTimeMs:
		return m.AddedExecutionTimeMs()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SchemaVersionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case schemaversion.FieldVersion:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVersion(v)
		return nil
	case schemaversion.FieldExecutionTimeMs:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddExecutionTimeMs(v)
		return nil
	}
	return fmt.Errorf("unknown SchemaVersion numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SchemaVersionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(schemaversion.FieldErrorMessage) {
		fields = append(fields, schemaversion.FieldErrorMessage)
	}
	if m.FieldCleared(schemaversion.FieldExecutionTimeMs) {
		fields = append(fields, schemaversion.FieldExecutionTimeMs)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SchemaVersionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SchemaVersionMutation) ClearField(name string) error {
	switch name {
	case schemaversion.FieldErrorMessage:
		m.ClearErrorMessage()
		return nil
	case schemaversion.FieldExecutionTimeMs:
		m.ClearExecutionTimeMs()
		return nil
	}
	return fmt.Errorf("unknown SchemaVersion nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SchemaVersionMutation) ResetField(name string) error {
	switch name {
	case schemaversion.FieldVersion:
		m.ResetVersion()
		return nil
	case schemaversion.FieldName:
		m.ResetName()
		return nil
	case schemaversion.FieldChecksum:
		m.ResetChecksum()
		return nil
	case schemaversion.FieldApplied:
		m.ResetApplied()
		return nil
	case schemaversion.FieldErrorMessage:
		m.ResetErrorMessage()
		return nil
	case schemaversion.FieldExecutionTimeMs:
		m.ResetExecutionTimeMs()
		return nil
	case schemaversion.FieldAppliedAt:
		m.ResetAppliedAt()
		return nil
	}
	return fmt.Errorf("unknown SchemaVersion field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SchemaVersionMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SchemaVersionMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SchemaVersionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SchemaVersionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SchemaVersionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SchemaVersionMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SchemaVersionMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown SchemaVersion unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SchemaVersionMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown SchemaVersion edge %s", name)
}

// ServiceInstanceMutation represents an operation that mutates the ServiceInstance nodes in the graph.
type ServiceInstanceMutation struct {
	config
	op              Op
	typ             string
	id              *string
	feature_id      *string
	instance_name   *string
	status          *serviceinstance.Status
	vlan_id         *int
	addvlan_id      *int
	bind_ip         *string
	ports           *[]int
	appendports     []int
	_config         *map[string]interface{}
	binary_path     *string
	binary_version  *string
	binary_checksum *string
	created_at      *time.Time
	updated_at      *time.Time
	clearedFields   map[string]struct{}
	router          *string
	clearedrouter   bool
	done            bool
	oldValue        func(context.Context) (*ServiceInstance, error)
	predicates      []predicate.ServiceInstance
}

var _ ent.Mutation = (*ServiceInstanceMutation)(nil)

// serviceinstanceOption allows management of the mutation configuration using functional options.
type serviceinstanceOption func(*ServiceInstanceMutation)

// newServiceInstanceMutation creates new mutation for the ServiceInstance entity.
func newServiceInstanceMutation(c config, op Op, opts ...serviceinstanceOption) *ServiceInstanceMutation {
	m := &ServiceInstanceMutation{
		config:        c,
		op:            op,
		typ:           TypeServiceInstance,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withServiceInstanceID sets the ID field of the mutation.
func withServiceInstanceID(id string) serviceinstanceOption {
	return func(m *ServiceInstanceMutation) {
		var (
			err   error
			once  sync.Once
			value *ServiceInstance
		)
		m.oldValue = func(ctx context.Context) (*ServiceInstance, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ServiceInstance.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withServiceInstance sets the old ServiceInstance of the mutation.
func withServiceInstance(node *ServiceInstance) serviceinstanceOption {
	return func(m *ServiceInstanceMutation) {
		m.oldValue = func(context.Context) (*ServiceInstance, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ServiceInstanceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ServiceInstanceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ServiceInstance entities.
func (m *ServiceInstanceMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ServiceInstanceMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ServiceInstanceMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ServiceInstance.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetFeatureID sets the "feature_id" field.
func (m *ServiceInstanceMutation) SetFeatureID(s string) {
	m.feature_id = &s
}

// FeatureID returns the value of the "feature_id" field in the mutation.
func (m *ServiceInstanceMutation) FeatureID() (r string, exists bool) {
	v := m.feature_id
	if v == nil {
		return
	}
	return *v, true
}

// OldFeatureID returns the old "feature_id" field's value of the ServiceInstance entity.
// If the ServiceInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceInstanceMutation) OldFeatureID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFeatureID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFeatureID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFeatureID: %w", err)
	}
	return oldValue.FeatureID, nil
}

// ResetFeatureID resets all changes to the "feature_id" field.
func (m *ServiceInstanceMutation) ResetFeatureID() {
	m.feature_id = nil
}

// SetInstanceName sets the "instance_name" field.
func (m *ServiceInstanceMutation) SetInstanceName(s string) {
	m.instance_name = &s
}

// InstanceName returns the value of the "instance_name" field in the mutation.
func (m *ServiceInstanceMutation) InstanceName() (r string, exists bool) {
	v := m.instance_name
	if v == nil {
		return
	}
	return *v, true
}

// OldInstanceName returns the old "instance_name" field's value of the ServiceInstance entity.
// If the ServiceInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceInstanceMutation) OldInstanceName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInstanceName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInstanceName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInstanceName: %w", err)
	}
	return oldValue.InstanceName, nil
}

// ResetInstanceName resets all changes to the "instance_name" field.
func (m *ServiceInstanceMutation) ResetInstanceName() {
	m.instance_name = nil
}

// SetRouterID sets the "router_id" field.
func (m *ServiceInstanceMutation) SetRouterID(s string) {
	m.router = &s
}

// RouterID returns the value of the "router_id" field in the mutation.
func (m *ServiceInstanceMutation) RouterID() (r string, exists bool) {
	v := m.router
	if v == nil {
		return
	}
	return *v, true
}

// OldRouterID returns the old "router_id" field's value of the ServiceInstance entity.
// If the ServiceInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceInstanceMutation) OldRouterID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRouterID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRouterID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRouterID: %w", err)
	}
	return oldValue.RouterID, nil
}

// ResetRouterID resets all changes to the "router_id" field.
func (m *ServiceInstanceMutation) ResetRouterID() {
	m.router = nil
}

// SetStatus sets the "status" field.
func (m *ServiceInstanceMutation) SetStatus(s serviceinstance.Status) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *ServiceInstanceMutation) Status() (r serviceinstance.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the ServiceInstance entity.
// If the ServiceInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceInstanceMutation) OldStatus(ctx context.Context) (v serviceinstance.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *ServiceInstanceMutation) ResetStatus() {
	m.status = nil
}

// SetVlanID sets the "vlan_id" field.
func (m *ServiceInstanceMutation) SetVlanID(i int) {
	m.vlan_id = &i
	m.addvlan_id = nil
}

// VlanID returns the value of the "vlan_id" field in the mutation.
func (m *ServiceInstanceMutation) VlanID() (r int, exists bool) {
	v := m.vlan_id
	if v == nil {
		return
	}
	return *v, true
}

// OldVlanID returns the old "vlan_id" field's value of the ServiceInstance entity.
// If the ServiceInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceInstanceMutation) OldVlanID(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVlanID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVlanID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVlanID: %w", err)
	}
	return oldValue.VlanID, nil
}

// AddVlanID adds i to the "vlan_id" field.
func (m *ServiceInstanceMutation) AddVlanID(i int) {
	if m.addvlan_id != nil {
		*m.addvlan_id += i
	} else {
		m.addvlan_id = &i
	}
}

// AddedVlanID returns the value that was added to the "vlan_id" field in this mutation.
func (m *ServiceInstanceMutation) AddedVlanID() (r int, exists bool) {
	v := m.addvlan_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearVlanID clears the value of the "vlan_id" field.
func (m *ServiceInstanceMutation) ClearVlanID() {
	m.vlan_id = nil
	m.addvlan_id = nil
	m.clearedFields[serviceinstance.FieldVlanID] = struct{}{}
}

// VlanIDCleared returns if the "vlan_id" field was cleared in this mutation.
func (m *ServiceInstanceMutation) VlanIDCleared() bool {
	_, ok := m.clearedFields[serviceinstance.FieldVlanID]
	return ok
}

// ResetVlanID resets all changes to the "vlan_id" field.
func (m *ServiceInstanceMutation) ResetVlanID() {
	m.vlan_id = nil
	m.addvlan_id = nil
	delete(m.clearedFields, serviceinstance.FieldVlanID)
}

// SetBindIP sets the "bind_ip" field.
func (m *ServiceInstanceMutation) SetBindIP(s string) {
	m.bind_ip = &s
}

// BindIP returns the value of the "bind_ip" field in the mutation.
func (m *ServiceInstanceMutation) BindIP() (r string, exists bool) {
	v := m.bind_ip
	if v == nil {
		return
	}
	return *v, true
}

// OldBindIP returns the old "bind_ip" field's value of the ServiceInstance entity.
// If the ServiceInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceInstanceMutation) OldBindIP(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBindIP is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBindIP requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBindIP: %w", err)
	}
	return oldValue.BindIP, nil
}

// ClearBindIP clears the value of the "bind_ip" field.
func (m *ServiceInstanceMutation) ClearBindIP() {
	m.bind_ip = nil
	m.clearedFields[serviceinstance.FieldBindIP] = struct{}{}
}

// BindIPCleared returns if the "bind_ip" field was cleared in this mutation.
func (m *ServiceInstanceMutation) BindIPCleared() bool {
	_, ok := m.clearedFields[serviceinstance.FieldBindIP]
	return ok
}

// ResetBindIP resets all changes to the "bind_ip" field.
func (m *ServiceInstanceMutation) ResetBindIP() {
	m.bind_ip = nil
	delete(m.clearedFields, serviceinstance.FieldBindIP)
}

// SetPorts sets the "ports" field.
func (m *ServiceInstanceMutation) SetPorts(i []int) {
	m.ports = &i
	m.appendports = nil
}

// Ports returns the value of the "ports" field in the mutation.
func (m *ServiceInstanceMutation) Ports() (r []int, exists bool) {
	v := m.ports
	if v == nil {
		return
	}
	return *v, true
}

// OldPorts returns the old "ports" field's value of the ServiceInstance entity.
// If the ServiceInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceInstanceMutation) OldPorts(ctx context.Context) (v []int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPorts is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPorts requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPorts: %w", err)
	}
	return oldValue.Ports, nil
}

// AppendPorts adds i to the "ports" field.
func (m *ServiceInstanceMutation) AppendPorts(i []int) {
	m.appendports = append(m.appendports, i...)
}

// AppendedPorts returns the list of values that were appended to the "ports" field in this mutation.
func (m *ServiceInstanceMutation) AppendedPorts() ([]int, bool) {
	if len(m.appendports) == 0 {
		return nil, false
	}
	return m.appendports, true
}

// ClearPorts clears the value of the "ports" field.
func (m *ServiceInstanceMutation) ClearPorts() {
	m.ports = nil
	m.appendports = nil
	m.clearedFields[serviceinstance.FieldPorts] = struct{}{}
}

// PortsCleared returns if the "ports" field was cleared in this mutation.
func (m *ServiceInstanceMutation) PortsCleared() bool {
	_, ok := m.clearedFields[serviceinstance.FieldPorts]
	return ok
}

// ResetPorts resets all changes to the "ports" field.
func (m *ServiceInstanceMutation) ResetPorts() {
	m.ports = nil
	m.appendports = nil
	delete(m.clearedFields, serviceinstance.FieldPorts)
}

// SetConfig sets the "config" field.
func (m *ServiceInstanceMutation) SetConfig(value map[string]interface{}) {
	m._config = &value
}

// Config returns the value of the "config" field in the mutation.
func (m *ServiceInstanceMutation) Config() (r map[string]interface{}, exists bool) {
	v := m._config
	if v == nil {
		return
	}
	return *v, true
}

// OldConfig returns the old "config" field's value of the ServiceInstance entity.
// If the ServiceInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceInstanceMutation) OldConfig(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConfig is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConfig requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConfig: %w", err)
	}
	return oldValue.Config, nil
}

// ClearConfig clears the value of the "config" field.
func (m *ServiceInstanceMutation) ClearConfig() {
	m._config = nil
	m.clearedFields[serviceinstance.FieldConfig] = struct{}{}
}

// ConfigCleared returns if the "config" field was cleared in this mutation.
func (m *ServiceInstanceMutation) ConfigCleared() bool {
	_, ok := m.clearedFields[serviceinstance.FieldConfig]
	return ok
}

// ResetConfig resets all changes to the "config" field.
func (m *ServiceInstanceMutation) ResetConfig() {
	m._config = nil
	delete(m.clearedFields, serviceinstance.FieldConfig)
}

// SetBinaryPath sets the "binary_path" field.
func (m *ServiceInstanceMutation) SetBinaryPath(s string) {
	m.binary_path = &s
}

// BinaryPath returns the value of the "binary_path" field in the mutation.
func (m *ServiceInstanceMutation) BinaryPath() (r string, exists bool) {
	v := m.binary_path
	if v == nil {
		return
	}
	return *v, true
}

// OldBinaryPath returns the old "binary_path" field's value of the ServiceInstance entity.
// If the ServiceInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceInstanceMutation) OldBinaryPath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBinaryPath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBinaryPath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBinaryPath: %w", err)
	}
	return oldValue.BinaryPath, nil
}

// ClearBinaryPath clears the value of the "binary_path" field.
func (m *ServiceInstanceMutation) ClearBinaryPath() {
	m.binary_path = nil
	m.clearedFields[serviceinstance.FieldBinaryPath] = struct{}{}
}

// BinaryPathCleared returns if the "binary_path" field was cleared in this mutation.
func (m *ServiceInstanceMutation) BinaryPathCleared() bool {
	_, ok := m.clearedFields[serviceinstance.FieldBinaryPath]
	return ok
}

// ResetBinaryPath resets all changes to the "binary_path" field.
func (m *ServiceInstanceMutation) ResetBinaryPath() {
	m.binary_path = nil
	delete(m.clearedFields, serviceinstance.FieldBinaryPath)
}

// SetBinaryVersion sets the "binary_version" field.
func (m *ServiceInstanceMutation) SetBinaryVersion(s string) {
	m.binary_version = &s
}

// BinaryVersion returns the value of the "binary_version" field in the mutation.
func (m *ServiceInstanceMutation) BinaryVersion() (r string, exists bool) {
	v := m.binary_version
	if v == nil {
		return
	}
	return *v, true
}

// OldBinaryVersion returns the old "binary_version" field's value of the ServiceInstance entity.
// If the ServiceInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceInstanceMutation) OldBinaryVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBinaryVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBinaryVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBinaryVersion: %w", err)
	}
	return oldValue.BinaryVersion, nil
}

// ClearBinaryVersion clears the value of the "binary_version" field.
func (m *ServiceInstanceMutation) ClearBinaryVersion() {
	m.binary_version = nil
	m.clearedFields[serviceinstance.FieldBinaryVersion] = struct{}{}
}

// BinaryVersionCleared returns if the "binary_version" field was cleared in this mutation.
func (m *ServiceInstanceMutation) BinaryVersionCleared() bool {
	_, ok := m.clearedFields[serviceinstance.FieldBinaryVersion]
	return ok
}

// ResetBinaryVersion resets all changes to the "binary_version" field.
func (m *ServiceInstanceMutation) ResetBinaryVersion() {
	m.binary_version = nil
	delete(m.clearedFields, serviceinstance.FieldBinaryVersion)
}

// SetBinaryChecksum sets the "binary_checksum" field.
func (m *ServiceInstanceMutation) SetBinaryChecksum(s string) {
	m.binary_checksum = &s
}

// BinaryChecksum returns the value of the "binary_checksum" field in the mutation.
func (m *ServiceInstanceMutation) BinaryChecksum() (r string, exists bool) {
	v := m.binary_checksum
	if v == nil {
		return
	}
	return *v, true
}

// OldBinaryChecksum returns the old "binary_checksum" field's value of the ServiceInstance entity.
// If the ServiceInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceInstanceMutation) OldBinaryChecksum(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBinaryChecksum is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBinaryChecksum requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBinaryChecksum: %w", err)
	}
	return oldValue.BinaryChecksum, nil
}

// ClearBinaryChecksum clears the value of the "binary_checksum" field.
func (m *ServiceInstanceMutation) ClearBinaryChecksum() {
	m.binary_checksum = nil
	m.clearedFields[serviceinstance.FieldBinaryChecksum] = struct{}{}
}

// BinaryChecksumCleared returns if the "binary_checksum" field was cleared in this mutation.
func (m *ServiceInstanceMutation) BinaryChecksumCleared() bool {
	_, ok := m.clearedFields[serviceinstance.FieldBinaryChecksum]
	return ok
}

// ResetBinaryChecksum resets all changes to the "binary_checksum" field.
func (m *ServiceInstanceMutation) ResetBinaryChecksum() {
	m.binary_checksum = nil
	delete(m.clearedFields, serviceinstance.FieldBinaryChecksum)
}

// SetCreatedAt sets the "created_at" field.
func (m *ServiceInstanceMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ServiceInstanceMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ServiceInstance entity.
// If the ServiceInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceInstanceMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ServiceInstanceMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ServiceInstanceMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ServiceInstanceMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ServiceInstance entity.
// If the ServiceInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceInstanceMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ServiceInstanceMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearRouter clears the "router" edge to the Router entity.
func (m *ServiceInstanceMutation) ClearRouter() {
	m.clearedrouter = true
	m.clearedFields[serviceinstance.FieldRouterID] = struct{}{}
}

// RouterCleared reports if the "router" edge to the Router entity was cleared.
func (m *ServiceInstanceMutation) RouterCleared() bool {
	return m.clearedrouter
}

// RouterIDs returns the "router" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RouterID instead. It exists only for internal usage by the builders.
func (m *ServiceInstanceMutation) RouterIDs() (ids []string) {
	if id := m.router; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRouter resets all changes to the "router" edge.
func (m *ServiceInstanceMutation) ResetRouter() {
	m.router = nil
	m.clearedrouter = false
}

// Where appends a list predicates to the ServiceInstanceMutation builder.
func (m *ServiceInstanceMutation) Where(ps ...predicate.ServiceInstance) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ServiceInstanceMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ServiceInstanceMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ServiceInstance, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ServiceInstanceMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ServiceInstanceMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ServiceInstance).
func (m *ServiceInstanceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ServiceInstanceMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.feature_id != nil {
		fields = append(fields, serviceinstance.FieldFeatureID)
	}
	if m.instance_name != nil {
		fields = append(fields, serviceinstance.FieldInstanceName)
	}
	if m.router != nil {
		fields = append(fields, serviceinstance.FieldRouterID)
	}
	if m.status != nil {
		fields = append(fields, serviceinstance.FieldStatus)
	}
	if m.vlan_id != nil {
		fields = append(fields, serviceinstance.FieldVlanID)
	}
	if m.bind_ip != nil {
		fields = append(fields, serviceinstance.FieldBindIP)
	}
	if m.ports != nil {
		fields = append(fields, serviceinstance.FieldPorts)
	}
	if m._config != nil {
		fields = append(fields, serviceinstance.FieldConfig)
	}
	if m.binary_path != nil {
		fields = append(fields, serviceinstance.FieldBinaryPath)
	}
	if m.binary_version != nil {
		fields = append(fields, serviceinstance.FieldBinaryVersion)
	}
	if m.binary_checksum != nil {
		fields = append(fields, serviceinstance.FieldBinaryChecksum)
	}
	if m.created_at != nil {
		fields = append(fields, serviceinstance.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, serviceinstance.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ServiceInstanceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case serviceinstance.FieldFeatureID:
		return m.FeatureID()
	case serviceinstance.FieldInstanceName:
		return m.InstanceName()
	case serviceinstance.FieldRouterID:
		return m.RouterID()
	case serviceinstance.FieldStatus:
		return m.Status()
	case serviceinstance.FieldVlanID:
		return m.VlanID()
	case serviceinstance.FieldBindIP:
		return m.BindIP()
	case serviceinstance.FieldPorts:
		return m.Ports()
	case serviceinstance.FieldConfig:
		return m.Config()
	case serviceinstance.FieldBinaryPath:
		return m.BinaryPath()
	case serviceinstance.FieldBinaryVersion:
		return m.BinaryVersion()
	case serviceinstance.FieldBinaryChecksum:
		return m.BinaryChecksum()
	case serviceinstance.FieldCreatedAt:
		return m.CreatedAt()
	case serviceinstance.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ServiceInstanceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case serviceinstance.FieldFeatureID:
		return m.OldFeatureID(ctx)
	case serviceinstance.FieldInstanceName:
		return m.OldInstanceName(ctx)
	case serviceinstance.FieldRouterID:
		return m.OldRouterID(ctx)
	case serviceinstance.FieldStatus:
		return m.OldStatus(ctx)
	case serviceinstance.FieldVlanID:
		return m.OldVlanID(ctx)
	case serviceinstance.FieldBindIP:
		return m.OldBindIP(ctx)
	case serviceinstance.FieldPorts:
		return m.OldPorts(ctx)
	case serviceinstance.FieldConfig:
		return m.OldConfig(ctx)
	case serviceinstance.FieldBinaryPath:
		return m.OldBinaryPath(ctx)
	case serviceinstance.FieldBinaryVersion:
		return m.OldBinaryVersion(ctx)
	case serviceinstance.FieldBinaryChecksum:
		return m.OldBinaryChecksum(ctx)
	case serviceinstance.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case serviceinstance.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown ServiceInstance field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ServiceInstanceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case serviceinstance.FieldFeatureID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFeatureID(v)
		return nil
	case serviceinstance.FieldInstanceName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInstanceName(v)
		return nil
	case serviceinstance.FieldRouterID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRouterID(v)
		return nil
	case serviceinstance.FieldStatus:
		v, ok := value.(serviceinstance.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case serviceinstance.FieldVlanID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVlanID(v)
		return nil
	case serviceinstance.FieldBindIP:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBindIP(v)
		return nil
	case serviceinstance.FieldPorts:
		v, ok := value.([]int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPorts(v)
		return nil
	case serviceinstance.FieldConfig:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConfig(v)
		return nil
	case serviceinstance.FieldBinaryPath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBinaryPath(v)
		return nil
	case serviceinstance.FieldBinaryVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBinaryVersion(v)
		return nil
	case serviceinstance.FieldBinaryChecksum:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBinaryChecksum(v)
		return nil
	case serviceinstance.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case serviceinstance.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown ServiceInstance field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ServiceInstanceMutation) AddedFields() []string {
	var fields []string
	if m.addvlan_id != nil {
		fields = append(fields, serviceinstance.FieldVlanID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ServiceInstanceMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case serviceinstance.FieldVlanID:
		return m.AddedVlanID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ServiceInstanceMutation) AddField(name string, value ent.Value) error {
	switch name {
	case serviceinstance.FieldVlanID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVlanID(v)
		return nil
	}
	return fmt.Errorf("unknown ServiceInstance numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ServiceInstanceMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(serviceinstance.FieldVlanID) {
		fields = append(fields, serviceinstance.FieldVlanID)
	}
	if m.FieldCleared(serviceinstance.FieldBindIP) {
		fields = append(fields, serviceinstance.FieldBindIP)
	}
	if m.FieldCleared(serviceinstance.FieldPorts) {
		fields = append(fields, serviceinstance.FieldPorts)
	}
	if m.FieldCleared(serviceinstance.FieldConfig) {
		fields = append(fields, serviceinstance.FieldConfig)
	}
	if m.FieldCleared(serviceinstance.FieldBinaryPath) {
		fields = append(fields, serviceinstance.FieldBinaryPath)
	}
	if m.FieldCleared(serviceinstance.FieldBinaryVersion) {
		fields = append(fields, serviceinstance.FieldBinaryVersion)
	}
	if m.FieldCleared(serviceinstance.FieldBinaryChecksum) {
		fields = append(fields, serviceinstance.FieldBinaryChecksum)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ServiceInstanceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ServiceInstanceMutation) ClearField(name string) error {
	switch name {
	case serviceinstance.FieldVlanID:
		m.ClearVlanID()
		return nil
	case serviceinstance.FieldBindIP:
		m.ClearBindIP()
		return nil
	case serviceinstance.FieldPorts:
		m.ClearPorts()
		return nil
	case serviceinstance.FieldConfig:
		m.ClearConfig()
		return nil
	case serviceinstance.FieldBinaryPath:
		m.ClearBinaryPath()
		return nil
	case serviceinstance.FieldBinaryVersion:
		m.ClearBinaryVersion()
		return nil
	case serviceinstance.FieldBinaryChecksum:
		m.ClearBinaryChecksum()
		return nil
	}
	return fmt.Errorf("unknown ServiceInstance nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ServiceInstanceMutation) ResetField(name string) error {
	switch name {
	case serviceinstance.FieldFeatureID:
		m.ResetFeatureID()
		return nil
	case serviceinstance.FieldInstanceName:
		m.ResetInstanceName()
		return nil
	case serviceinstance.FieldRouterID:
		m.ResetRouterID()
		return nil
	case serviceinstance.FieldStatus:
		m.ResetStatus()
		return nil
	case serviceinstance.FieldVlanID:
		m.ResetVlanID()
		return nil
	case serviceinstance.FieldBindIP:
		m.ResetBindIP()
		return nil
	case serviceinstance.FieldPorts:
		m.ResetPorts()
		return nil
	case serviceinstance.FieldConfig:
		m.ResetConfig()
		return nil
	case serviceinstance.FieldBinaryPath:
		m.ResetBinaryPath()
		return nil
	case serviceinstance.FieldBinaryVersion:
		m.ResetBinaryVersion()
		return nil
	case serviceinstance.FieldBinaryChecksum:
		m.ResetBinaryChecksum()
		return nil
	case serviceinstance.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case serviceinstance.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown ServiceInstance field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ServiceInstanceMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.router != nil {
		edges = append(edges, serviceinstance.EdgeRouter)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ServiceInstanceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case serviceinstance.EdgeRouter:
		if id := m.router; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ServiceInstanceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ServiceInstanceMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ServiceInstanceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedrouter {
		edges = append(edges, serviceinstance.EdgeRouter)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ServiceInstanceMutation) EdgeCleared(name string) bool {
	switch name {
	case serviceinstance.EdgeRouter:
		return m.clearedrouter
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ServiceInstanceMutation) ClearEdge(name string) error {
	switch name {
	case serviceinstance.EdgeRouter:
		m.ClearRouter()
		return nil
	}
	return fmt.Errorf("unknown ServiceInstance unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ServiceInstanceMutation) ResetEdge(name string) error {
	switch name {
	case serviceinstance.EdgeRouter:
		m.ResetRouter()
		return nil
	}
	return fmt.Errorf("unknown ServiceInstance edge %s", name)
}

// SessionMutation represents an operation that mutates the Session nodes in the graph.
type SessionMutation struct {
	config
	op             Op
	typ            string
	id             *string
	token_id       *string
	token_family   *string
	user_agent     *string
	ip_address     *string
	expires_at     *time.Time
	last_activity  *time.Time
	revoked        *bool
	revoked_at     *time.Time
	revoked_reason *string
	created_at     *time.Time
	clearedFields  map[string]struct{}
	user           *string
	cleareduser    bool
	done           bool
	oldValue       func(context.Context) (*Session, error)
	predicates     []predicate.Session
}

var _ ent.Mutation = (*SessionMutation)(nil)

// sessionOption allows management of the mutation configuration using functional options.
type sessionOption func(*SessionMutation)

// newSessionMutation creates new mutation for the Session entity.
func newSessionMutation(c config, op Op, opts ...sessionOption) *SessionMutation {
	m := &SessionMutation{
		config:        c,
		op:            op,
		typ:           TypeSession,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSessionID sets the ID field of the mutation.
func withSessionID(id string) sessionOption {
	return func(m *SessionMutation) {
		var (
			err   error
			once  sync.Once
			value *Session
		)
		m.oldValue = func(ctx context.Context) (*Session, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Session.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSession sets the old Session of the mutation.
func withSession(node *Session) sessionOption {
	return func(m *SessionMutation) {
		m.oldValue = func(context.Context) (*Session, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SessionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SessionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Session entities.
func (m *SessionMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SessionMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SessionMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Session.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserID sets the "user_id" field.
func (m *SessionMutation) SetUserID(s string) {
	m.user = &s
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *SessionMutation) UserID() (r string, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldUserID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *SessionMutation) ResetUserID() {
	m.user = nil
}

// SetTokenID sets the "token_id" field.
func (m *SessionMutation) SetTokenID(s string) {
	m.token_id = &s
}

// TokenID returns the value of the "token_id" field in the mutation.
func (m *SessionMutation) TokenID() (r string, exists bool) {
	v := m.token_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTokenID returns the old "token_id" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldTokenID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTokenID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTokenID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTokenID: %w", err)
	}
	return oldValue.TokenID, nil
}

// ResetTokenID resets all changes to the "token_id" field.
func (m *SessionMutation) ResetTokenID() {
	m.token_id = nil
}

// SetTokenFamily sets the "token_family" field.
func (m *SessionMutation) SetTokenFamily(s string) {
	m.token_family = &s
}

// TokenFamily returns the value of the "token_family" field in the mutation.
func (m *SessionMutation) TokenFamily() (r string, exists bool) {
	v := m.token_family
	if v == nil {
		return
	}
	return *v, true
}

// OldTokenFamily returns the old "token_family" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldTokenFamily(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTokenFamily is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTokenFamily requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTokenFamily: %w", err)
	}
	return oldValue.TokenFamily, nil
}

// ClearTokenFamily clears the value of the "token_family" field.
func (m *SessionMutation) ClearTokenFamily() {
	m.token_family = nil
	m.clearedFields[session.FieldTokenFamily] = struct{}{}
}

// TokenFamilyCleared returns if the "token_family" field was cleared in this mutation.
func (m *SessionMutation) TokenFamilyCleared() bool {
	_, ok := m.clearedFields[session.FieldTokenFamily]
	return ok
}

// ResetTokenFamily resets all changes to the "token_family" field.
func (m *SessionMutation) ResetTokenFamily() {
	m.token_family = nil
	delete(m.clearedFields, session.FieldTokenFamily)
}

// SetUserAgent sets the "user_agent" field.
func (m *SessionMutation) SetUserAgent(s string) {
	m.user_agent = &s
}

// UserAgent returns the value of the "user_agent" field in the mutation.
func (m *SessionMutation) UserAgent() (r string, exists bool) {
	v := m.user_agent
	if v == nil {
		return
	}
	return *v, true
}

// OldUserAgent returns the old "user_agent" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldUserAgent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserAgent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserAgent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserAgent: %w", err)
	}
	return oldValue.UserAgent, nil
}

// ClearUserAgent clears the value of the "user_agent" field.
func (m *SessionMutation) ClearUserAgent() {
	m.user_agent = nil
	m.clearedFields[session.FieldUserAgent] = struct{}{}
}

// UserAgentCleared returns if the "user_agent" field was cleared in this mutation.
func (m *SessionMutation) UserAgentCleared() bool {
	_, ok := m.clearedFields[session.FieldUserAgent]
	return ok
}

// ResetUserAgent resets all changes to the "user_agent" field.
func (m *SessionMutation) ResetUserAgent() {
	m.user_agent = nil
	delete(m.clearedFields, session.FieldUserAgent)
}

// SetIPAddress sets the "ip_address" field.
func (m *SessionMutation) SetIPAddress(s string) {
	m.ip_address = &s
}

// IPAddress returns the value of the "ip_address" field in the mutation.
func (m *SessionMutation) IPAddress() (r string, exists bool) {
	v := m.ip_address
	if v == nil {
		return
	}
	return *v, true
}

// OldIPAddress returns the old "ip_address" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldIPAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIPAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIPAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIPAddress: %w", err)
	}
	return oldValue.IPAddress, nil
}

// ClearIPAddress clears the value of the "ip_address" field.
func (m *SessionMutation) ClearIPAddress() {
	m.ip_address = nil
	m.clearedFields[session.FieldIPAddress] = struct{}{}
}

// IPAddressCleared returns if the "ip_address" field was cleared in this mutation.
func (m *SessionMutation) IPAddressCleared() bool {
	_, ok := m.clearedFields[session.FieldIPAddress]
	return ok
}

// ResetIPAddress resets all changes to the "ip_address" field.
func (m *SessionMutation) ResetIPAddress() {
	m.ip_address = nil
	delete(m.clearedFields, session.FieldIPAddress)
}

// SetExpiresAt sets the "expires_at" field.
func (m *SessionMutation) SetExpiresAt(t time.Time) {
	m.expires_at = &t
}

// ExpiresAt returns the value of the "expires_at" field in the mutation.
func (m *SessionMutation) ExpiresAt() (r time.Time, exists bool) {
	v := m.expires_at
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiresAt returns the old "expires_at" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldExpiresAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiresAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiresAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiresAt: %w", err)
	}
	return oldValue.ExpiresAt, nil
}

// ResetExpiresAt resets all changes to the "expires_at" field.
func (m *SessionMutation) ResetExpiresAt() {
	m.expires_at = nil
}

// SetLastActivity sets the "last_activity" field.
func (m *SessionMutation) SetLastActivity(t time.Time) {
	m.last_activity = &t
}

// LastActivity returns the value of the "last_activity" field in the mutation.
func (m *SessionMutation) LastActivity() (r time.Time, exists bool) {
	v := m.last_activity
	if v == nil {
		return
	}
	return *v, true
}

// OldLastActivity returns the old "last_activity" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldLastActivity(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastActivity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastActivity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastActivity: %w", err)
	}
	return oldValue.LastActivity, nil
}

// ResetLastActivity resets all changes to the "last_activity" field.
func (m *SessionMutation) ResetLastActivity() {
	m.last_activity = nil
}

// SetRevoked sets the "revoked" field.
func (m *SessionMutation) SetRevoked(b bool) {
	m.revoked = &b
}

// Revoked returns the value of the "revoked" field in the mutation.
func (m *SessionMutation) Revoked() (r bool, exists bool) {
	v := m.revoked
	if v == nil {
		return
	}
	return *v, true
}

// OldRevoked returns the old "revoked" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldRevoked(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRevoked is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRevoked requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRevoked: %w", err)
	}
	return oldValue.Revoked, nil
}

// ResetRevoked resets all changes to the "revoked" field.
func (m *SessionMutation) ResetRevoked() {
	m.revoked = nil
}

// SetRevokedAt sets the "revoked_at" field.
func (m *SessionMutation) SetRevokedAt(t time.Time) {
	m.revoked_at = &t
}

// RevokedAt returns the value of the "revoked_at" field in the mutation.
func (m *SessionMutation) RevokedAt() (r time.Time, exists bool) {
	v := m.revoked_at
	if v == nil {
		return
	}
	return *v, true
}

// OldRevokedAt returns the old "revoked_at" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldRevokedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRevokedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRevokedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRevokedAt: %w", err)
	}
	return oldValue.RevokedAt, nil
}

// ClearRevokedAt clears the value of the "revoked_at" field.
func (m *SessionMutation) ClearRevokedAt() {
	m.revoked_at = nil
	m.clearedFields[session.FieldRevokedAt] = struct{}{}
}

// RevokedAtCleared returns if the "revoked_at" field was cleared in this mutation.
func (m *SessionMutation) RevokedAtCleared() bool {
	_, ok := m.clearedFields[session.FieldRevokedAt]
	return ok
}

// ResetRevokedAt resets all changes to the "revoked_at" field.
func (m *SessionMutation) ResetRevokedAt() {
	m.revoked_at = nil
	delete(m.clearedFields, session.FieldRevokedAt)
}

// SetRevokedReason sets the "revoked_reason" field.
func (m *SessionMutation) SetRevokedReason(s string) {
	m.revoked_reason = &s
}

// RevokedReason returns the value of the "revoked_reason" field in the mutation.
func (m *SessionMutation) RevokedReason() (r string, exists bool) {
	v := m.revoked_reason
	if v == nil {
		return
	}
	return *v, true
}

// OldRevokedReason returns the old "revoked_reason" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldRevokedReason(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRevokedReason is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRevokedReason requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRevokedReason: %w", err)
	}
	return oldValue.RevokedReason, nil
}

// ClearRevokedReason clears the value of the "revoked_reason" field.
func (m *SessionMutation) ClearRevokedReason() {
	m.revoked_reason = nil
	m.clearedFields[session.FieldRevokedReason] = struct{}{}
}

// RevokedReasonCleared returns if the "revoked_reason" field was cleared in this mutation.
func (m *SessionMutation) RevokedReasonCleared() bool {
	_, ok := m.clearedFields[session.FieldRevokedReason]
	return ok
}

// ResetRevokedReason resets all changes to the "revoked_reason" field.
func (m *SessionMutation) ResetRevokedReason() {
	m.revoked_reason = nil
	delete(m.clearedFields, session.FieldRevokedReason)
}

// SetCreatedAt sets the "created_at" field.
func (m *SessionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SessionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SessionMutation) ResetCreatedAt() {
	m.created_at = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *SessionMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[session.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *SessionMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *SessionMutation) UserIDs() (ids []string) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *SessionMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the SessionMutation builder.
func (m *SessionMutation) Where(ps ...predicate.Session) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SessionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SessionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Session, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SessionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SessionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Session).
func (m *SessionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SessionMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.user != nil {
		fields = append(fields, session.FieldUserID)
	}
	if m.token_id != nil {
		fields = append(fields, session.FieldTokenID)
	}
	if m.token_family != nil {
		fields = append(fields, session.FieldTokenFamily)
	}
	if m.user_agent != nil {
		fields = append(fields, session.FieldUserAgent)
	}
	if m.ip_address != nil {
		fields = append(fields, session.FieldIPAddress)
	}
	if m.expires_at != nil {
		fields = append(fields, session.FieldExpiresAt)
	}
	if m.last_activity != nil {
		fields = append(fields, session.FieldLastActivity)
	}
	if m.revoked != nil {
		fields = append(fields, session.FieldRevoked)
	}
	if m.revoked_at != nil {
		fields = append(fields, session.FieldRevokedAt)
	}
	if m.revoked_reason != nil {
		fields = append(fields, session.FieldRevokedReason)
	}
	if m.created_at != nil {
		fields = append(fields, session.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SessionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case session.FieldUserID:
		return m.UserID()
	case session.FieldTokenID:
		return m.TokenID()
	case session.FieldTokenFamily:
		return m.TokenFamily()
	case session.FieldUserAgent:
		return m.UserAgent()
	case session.FieldIPAddress:
		return m.IPAddress()
	case session.FieldExpiresAt:
		return m.ExpiresAt()
	case session.FieldLastActivity:
		return m.LastActivity()
	case session.FieldRevoked:
		return m.Revoked()
	case session.FieldRevokedAt:
		return m.RevokedAt()
	case session.FieldRevokedReason:
		return m.RevokedReason()
	case session.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SessionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case session.FieldUserID:
		return m.OldUserID(ctx)
	case session.FieldTokenID:
		return m.OldTokenID(ctx)
	case session.FieldTokenFamily:
		return m.OldTokenFamily(ctx)
	case session.FieldUserAgent:
		return m.OldUserAgent(ctx)
	case session.FieldIPAddress:
		return m.OldIPAddress(ctx)
	case session.FieldExpiresAt:
		return m.OldExpiresAt(ctx)
	case session.FieldLastActivity:
		return m.OldLastActivity(ctx)
	case session.FieldRevoked:
		return m.OldRevoked(ctx)
	case session.FieldRevokedAt:
		return m.OldRevokedAt(ctx)
	case session.FieldRevokedReason:
		return m.OldRevokedReason(ctx)
	case session.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Session field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SessionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case session.FieldUserID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case session.FieldTokenID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTokenID(v)
		return nil
	case session.FieldTokenFamily:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTokenFamily(v)
		return nil
	case session.FieldUserAgent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserAgent(v)
		return nil
	case session.FieldIPAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIPAddress(v)
		return nil
	case session.FieldExpiresAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiresAt(v)
		return nil
	case session.FieldLastActivity:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastActivity(v)
		return nil
	case session.FieldRevoked:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRevoked(v)
		return nil
	case session.FieldRevokedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRevokedAt(v)
		return nil
	case session.FieldRevokedReason:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRevokedReason(v)
		return nil
	case session.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Session field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SessionMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SessionMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SessionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Session numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SessionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(session.FieldTokenFamily) {
		fields = append(fields, session.FieldTokenFamily)
	}
	if m.FieldCleared(session.FieldUserAgent) {
		fields = append(fields, session.FieldUserAgent)
	}
	if m.FieldCleared(session.FieldIPAddress) {
		fields = append(fields, session.FieldIPAddress)
	}
	if m.FieldCleared(session.FieldRevokedAt) {
		fields = append(fields, session.FieldRevokedAt)
	}
	if m.FieldCleared(session.FieldRevokedReason) {
		fields = append(fields, session.FieldRevokedReason)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SessionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SessionMutation) ClearField(name string) error {
	switch name {
	case session.FieldTokenFamily:
		m.ClearTokenFamily()
		return nil
	case session.FieldUserAgent:
		m.ClearUserAgent()
		return nil
	case session.FieldIPAddress:
		m.ClearIPAddress()
		return nil
	case session.FieldRevokedAt:
		m.ClearRevokedAt()
		return nil
	case session.FieldRevokedReason:
		m.ClearRevokedReason()
		return nil
	}
	return fmt.Errorf("unknown Session nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SessionMutation) ResetField(name string) error {
	switch name {
	case session.FieldUserID:
		m.ResetUserID()
		return nil
	case session.FieldTokenID:
		m.ResetTokenID()
		return nil
	case session.FieldTokenFamily:
		m.ResetTokenFamily()
		return nil
	case session.FieldUserAgent:
		m.ResetUserAgent()
		return nil
	case session.FieldIPAddress:
		m.ResetIPAddress()
		return nil
	case session.FieldExpiresAt:
		m.ResetExpiresAt()
		return nil
	case session.FieldLastActivity:
		m.ResetLastActivity()
		return nil
	case session.FieldRevoked:
		m.ResetRevoked()
		return nil
	case session.FieldRevokedAt:
		m.ResetRevokedAt()
		return nil
	case session.FieldRevokedReason:
		m.ResetRevokedReason()
		return nil
	case session.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown Session field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SessionMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, session.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SessionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case session.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SessionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SessionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SessionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, session.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SessionMutation) EdgeCleared(name string) bool {
	switch name {
	case session.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SessionMutation) ClearEdge(name string) error {
	switch name {
	case session.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown Session unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SessionMutation) ResetEdge(name string) error {
	switch name {
	case session.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown Session edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op                  Op
	typ                 string
	id                  *string
	username            *string
	email               *string
	display_name        *string
	password_hash       *string
	role                *user.Role
	active              *bool
	mfa_enabled         *bool
	mfa_secret          *string
	last_login          *time.Time
	password_changed_at *time.Time
	created_at          *time.Time
	updated_at          *time.Time
	clearedFields       map[string]struct{}
	sessions            map[string]struct{}
	removedsessions     map[string]struct{}
	clearedsessions     bool
	api_keys            map[string]struct{}
	removedapi_keys     map[string]struct{}
	clearedapi_keys     bool
	done                bool
	oldValue            func(context.Context) (*User, error)
	predicates          []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id string) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of User entities.
func (m *UserMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUsername sets the "username" field.
func (m *UserMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *UserMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ResetUsername resets all changes to the "username" field.
func (m *UserMutation) ResetUsername() {
	m.username = nil
}

// SetEmail sets the "email" field.
func (m *UserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *UserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ClearEmail clears the value of the "email" field.
func (m *UserMutation) ClearEmail() {
	m.email = nil
	m.clearedFields[user.FieldEmail] = struct{}{}
}

// EmailCleared returns if the "email" field was cleared in this mutation.
func (m *UserMutation) EmailCleared() bool {
	_, ok := m.clearedFields[user.FieldEmail]
	return ok
}

// ResetEmail resets all changes to the "email" field.
func (m *UserMutation) ResetEmail() {
	m.email = nil
	delete(m.clearedFields, user.FieldEmail)
}

// SetDisplayName sets the "display_name" field.
func (m *UserMutation) SetDisplayName(s string) {
	m.display_name = &s
}

// DisplayName returns the value of the "display_name" field in the mutation.
func (m *UserMutation) DisplayName() (r string, exists bool) {
	v := m.display_name
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplayName returns the old "display_name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldDisplayName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplayName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplayName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplayName: %w", err)
	}
	return oldValue.DisplayName, nil
}

// ClearDisplayName clears the value of the "display_name" field.
func (m *UserMutation) ClearDisplayName() {
	m.display_name = nil
	m.clearedFields[user.FieldDisplayName] = struct{}{}
}

// DisplayNameCleared returns if the "display_name" field was cleared in this mutation.
func (m *UserMutation) DisplayNameCleared() bool {
	_, ok := m.clearedFields[user.FieldDisplayName]
	return ok
}

// ResetDisplayName resets all changes to the "display_name" field.
func (m *UserMutation) ResetDisplayName() {
	m.display_name = nil
	delete(m.clearedFields, user.FieldDisplayName)
}

// SetPasswordHash sets the "password_hash" field.
func (m *UserMutation) SetPasswordHash(s string) {
	m.password_hash = &s
}

// PasswordHash returns the value of the "password_hash" field in the mutation.
func (m *UserMutation) PasswordHash() (r string, exists bool) {
	v := m.password_hash
	if v == nil {
		return
	}
	return *v, true
}

// OldPasswordHash returns the old "password_hash" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPasswordHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPasswordHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPasswordHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPasswordHash: %w", err)
	}
	return oldValue.PasswordHash, nil
}

// ResetPasswordHash resets all changes to the "password_hash" field.
func (m *UserMutation) ResetPasswordHash() {
	m.password_hash = nil
}

// SetRole sets the "role" field.
func (m *UserMutation) SetRole(u user.Role) {
	m.role = &u
}

// Role returns the value of the "role" field in the mutation.
func (m *UserMutation) Role() (r user.Role, exists bool) {
	v := m.role
	if v == nil {
		return
	}
	return *v, true
}

// OldRole returns the old "role" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldRole(ctx context.Context) (v user.Role, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRole is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRole requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRole: %w", err)
	}
	return oldValue.Role, nil
}

// ResetRole resets all changes to the "role" field.
func (m *UserMutation) ResetRole() {
	m.role = nil
}

// SetActive sets the "active" field.
func (m *UserMutation) SetActive(b bool) {
	m.active = &b
}

// Active returns the value of the "active" field in the mutation.
func (m *UserMutation) Active() (r bool, exists bool) {
	v := m.active
	if v == nil {
		return
	}
	return *v, true
}

// OldActive returns the old "active" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActive: %w", err)
	}
	return oldValue.Active, nil
}

// ResetActive resets all changes to the "active" field.
func (m *UserMutation) ResetActive() {
	m.active = nil
}

// SetMfaEnabled sets the "mfa_enabled" field.
func (m *UserMutation) SetMfaEnabled(b bool) {
	m.mfa_enabled = &b
}

// MfaEnabled returns the value of the "mfa_enabled" field in the mutation.
func (m *UserMutation) MfaEnabled() (r bool, exists bool) {
	v := m.mfa_enabled
	if v == nil {
		return
	}
	return *v, true
}

// OldMfaEnabled returns the old "mfa_enabled" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldMfaEnabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMfaEnabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMfaEnabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMfaEnabled: %w", err)
	}
	return oldValue.MfaEnabled, nil
}

// ResetMfaEnabled resets all changes to the "mfa_enabled" field.
func (m *UserMutation) ResetMfaEnabled() {
	m.mfa_enabled = nil
}

// SetMfaSecret sets the "mfa_secret" field.
func (m *UserMutation) SetMfaSecret(s string) {
	m.mfa_secret = &s
}

// MfaSecret returns the value of the "mfa_secret" field in the mutation.
func (m *UserMutation) MfaSecret() (r string, exists bool) {
	v := m.mfa_secret
	if v == nil {
		return
	}
	return *v, true
}

// OldMfaSecret returns the old "mfa_secret" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldMfaSecret(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMfaSecret is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMfaSecret requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMfaSecret: %w", err)
	}
	return oldValue.MfaSecret, nil
}

// ClearMfaSecret clears the value of the "mfa_secret" field.
func (m *UserMutation) ClearMfaSecret() {
	m.mfa_secret = nil
	m.clearedFields[user.FieldMfaSecret] = struct{}{}
}

// MfaSecretCleared returns if the "mfa_secret" field was cleared in this mutation.
func (m *UserMutation) MfaSecretCleared() bool {
	_, ok := m.clearedFields[user.FieldMfaSecret]
	return ok
}

// ResetMfaSecret resets all changes to the "mfa_secret" field.
func (m *UserMutation) ResetMfaSecret() {
	m.mfa_secret = nil
	delete(m.clearedFields, user.FieldMfaSecret)
}

// SetLastLogin sets the "last_login" field.
func (m *UserMutation) SetLastLogin(t time.Time) {
	m.last_login = &t
}

// LastLogin returns the value of the "last_login" field in the mutation.
func (m *UserMutation) LastLogin() (r time.Time, exists bool) {
	v := m.last_login
	if v == nil {
		return
	}
	return *v, true
}

// OldLastLogin returns the old "last_login" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldLastLogin(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastLogin is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastLogin requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastLogin: %w", err)
	}
	return oldValue.LastLogin, nil
}

// ClearLastLogin clears the value of the "last_login" field.
func (m *UserMutation) ClearLastLogin() {
	m.last_login = nil
	m.clearedFields[user.FieldLastLogin] = struct{}{}
}

// LastLoginCleared returns if the "last_login" field was cleared in this mutation.
func (m *UserMutation) LastLoginCleared() bool {
	_, ok := m.clearedFields[user.FieldLastLogin]
	return ok
}

// ResetLastLogin resets all changes to the "last_login" field.
func (m *UserMutation) ResetLastLogin() {
	m.last_login = nil
	delete(m.clearedFields, user.FieldLastLogin)
}

// SetPasswordChangedAt sets the "password_changed_at" field.
func (m *UserMutation) SetPasswordChangedAt(t time.Time) {
	m.password_changed_at = &t
}

// PasswordChangedAt returns the value of the "password_changed_at" field in the mutation.
func (m *UserMutation) PasswordChangedAt() (r time.Time, exists bool) {
	v := m.password_changed_at
	if v == nil {
		return
	}
	return *v, true
}

// OldPasswordChangedAt returns the old "password_changed_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPasswordChangedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPasswordChangedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPasswordChangedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPasswordChangedAt: %w", err)
	}
	return oldValue.PasswordChangedAt, nil
}

// ResetPasswordChangedAt resets all changes to the "password_changed_at" field.
func (m *UserMutation) ResetPasswordChangedAt() {
	m.password_changed_at = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *UserMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// AddSessionIDs adds the "sessions" edge to the Session entity by ids.
func (m *UserMutation) AddSessionIDs(ids ...string) {
	if m.sessions == nil {
		m.sessions = make(map[string]struct{})
	}
	for i := range ids {
		m.sessions[ids[i]] = struct{}{}
	}
}

// ClearSessions clears the "sessions" edge to the Session entity.
func (m *UserMutation) ClearSessions() {
	m.clearedsessions = true
}

// SessionsCleared reports if the "sessions" edge to the Session entity was cleared.
func (m *UserMutation) SessionsCleared() bool {
	return m.clearedsessions
}

// RemoveSessionIDs removes the "sessions" edge to the Session entity by IDs.
func (m *UserMutation) RemoveSessionIDs(ids ...string) {
	if m.removedsessions == nil {
		m.removedsessions = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.sessions, ids[i])
		m.removedsessions[ids[i]] = struct{}{}
	}
}

// RemovedSessions returns the removed IDs of the "sessions" edge to the Session entity.
func (m *UserMutation) RemovedSessionsIDs() (ids []string) {
	for id := range m.removedsessions {
		ids = append(ids, id)
	}
	return
}

// SessionsIDs returns the "sessions" edge IDs in the mutation.
func (m *UserMutation) SessionsIDs() (ids []string) {
	for id := range m.sessions {
		ids = append(ids, id)
	}
	return
}

// ResetSessions resets all changes to the "sessions" edge.
func (m *UserMutation) ResetSessions() {
	m.sessions = nil
	m.clearedsessions = false
	m.removedsessions = nil
}

// AddAPIKeyIDs adds the "api_keys" edge to the APIKey entity by ids.
func (m *UserMutation) AddAPIKeyIDs(ids ...string) {
	if m.api_keys == nil {
		m.api_keys = make(map[string]struct{})
	}
	for i := range ids {
		m.api_keys[ids[i]] = struct{}{}
	}
}

// ClearAPIKeys clears the "api_keys" edge to the APIKey entity.
func (m *UserMutation) ClearAPIKeys() {
	m.clearedapi_keys = true
}

// APIKeysCleared reports if the "api_keys" edge to the APIKey entity was cleared.
func (m *UserMutation) APIKeysCleared() bool {
	return m.clearedapi_keys
}

// RemoveAPIKeyIDs removes the "api_keys" edge to the APIKey entity by IDs.
func (m *UserMutation) RemoveAPIKeyIDs(ids ...string) {
	if m.removedapi_keys == nil {
		m.removedapi_keys = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.api_keys, ids[i])
		m.removedapi_keys[ids[i]] = struct{}{}
	}
}

// RemovedAPIKeys returns the removed IDs of the "api_keys" edge to the APIKey entity.
func (m *UserMutation) RemovedAPIKeysIDs() (ids []string) {
	for id := range m.removedapi_keys {
		ids = append(ids, id)
	}
	return
}

// APIKeysIDs returns the "api_keys" edge IDs in the mutation.
func (m *UserMutation) APIKeysIDs() (ids []string) {
	for id := range m.api_keys {
		ids = append(ids, id)
	}
	return
}

// ResetAPIKeys resets all changes to the "api_keys" edge.
func (m *UserMutation) ResetAPIKeys() {
	m.api_keys = nil
	m.clearedapi_keys = false
	m.removedapi_keys = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.username != nil {
		fields = append(fields, user.FieldUsername)
	}
	if m.email != nil {
		fields = append(fields, user.FieldEmail)
	}
	if m.display_name != nil {
		fields = append(fields, user.FieldDisplayName)
	}
	if m.password_hash != nil {
		fields = append(fields, user.FieldPasswordHash)
	}
	if m.role != nil {
		fields = append(fields, user.FieldRole)
	}
	if m.active != nil {
		fields = append(fields, user.FieldActive)
	}
	if m.mfa_enabled != nil {
		fields = append(fields, user.FieldMfaEnabled)
	}
	if m.mfa_secret != nil {
		fields = append(fields, user.FieldMfaSecret)
	}
	if m.last_login != nil {
		fields = append(fields, user.FieldLastLogin)
	}
	if m.password_changed_at != nil {
		fields = append(fields, user.FieldPasswordChangedAt)
	}
	if m.created_at != nil {
		fields = append(fields, user.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, user.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldUsername:
		return m.Username()
	case user.FieldEmail:
		return m.Email()
	case user.FieldDisplayName:
		return m.DisplayName()
	case user.FieldPasswordHash:
		return m.PasswordHash()
	case user.FieldRole:
		return m.Role()
	case user.FieldActive:
		return m.Active()
	case user.FieldMfaEnabled:
		return m.MfaEnabled()
	case user.FieldMfaSecret:
		return m.MfaSecret()
	case user.FieldLastLogin:
		return m.LastLogin()
	case user.FieldPasswordChangedAt:
		return m.PasswordChangedAt()
	case user.FieldCreatedAt:
		return m.CreatedAt()
	case user.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldUsername:
		return m.OldUsername(ctx)
	case user.FieldEmail:
		return m.OldEmail(ctx)
	case user.FieldDisplayName:
		return m.OldDisplayName(ctx)
	case user.FieldPasswordHash:
		return m.OldPasswordHash(ctx)
	case user.FieldRole:
		return m.OldRole(ctx)
	case user.FieldActive:
		return m.OldActive(ctx)
	case user.FieldMfaEnabled:
		return m.OldMfaEnabled(ctx)
	case user.FieldMfaSecret:
		return m.OldMfaSecret(ctx)
	case user.FieldLastLogin:
		return m.OldLastLogin(ctx)
	case user.FieldPasswordChangedAt:
		return m.OldPasswordChangedAt(ctx)
	case user.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case user.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case user.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case user.FieldDisplayName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplayName(v)
		return nil
	case user.FieldPasswordHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPasswordHash(v)
		return nil
	case user.FieldRole:
		v, ok := value.(user.Role)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRole(v)
		return nil
	case user.FieldActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActive(v)
		return nil
	case user.FieldMfaEnabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMfaEnabled(v)
		return nil
	case user.FieldMfaSecret:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMfaSecret(v)
		return nil
	case user.FieldLastLogin:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastLogin(v)
		return nil
	case user.FieldPasswordChangedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPasswordChangedAt(v)
		return nil
	case user.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case user.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(user.FieldEmail) {
		fields = append(fields, user.FieldEmail)
	}
	if m.FieldCleared(user.FieldDisplayName) {
		fields = append(fields, user.FieldDisplayName)
	}
	if m.FieldCleared(user.FieldMfaSecret) {
		fields = append(fields, user.FieldMfaSecret)
	}
	if m.FieldCleared(user.FieldLastLogin) {
		fields = append(fields, user.FieldLastLogin)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	switch name {
	case user.FieldEmail:
		m.ClearEmail()
		return nil
	case user.FieldDisplayName:
		m.ClearDisplayName()
		return nil
	case user.FieldMfaSecret:
		m.ClearMfaSecret()
		return nil
	case user.FieldLastLogin:
		m.ClearLastLogin()
		return nil
	}
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldUsername:
		m.ResetUsername()
		return nil
	case user.FieldEmail:
		m.ResetEmail()
		return nil
	case user.FieldDisplayName:
		m.ResetDisplayName()
		return nil
	case user.FieldPasswordHash:
		m.ResetPasswordHash()
		return nil
	case user.FieldRole:
		m.ResetRole()
		return nil
	case user.FieldActive:
		m.ResetActive()
		return nil
	case user.FieldMfaEnabled:
		m.ResetMfaEnabled()
		return nil
	case user.FieldMfaSecret:
		m.ResetMfaSecret()
		return nil
	case user.FieldLastLogin:
		m.ResetLastLogin()
		return nil
	case user.FieldPasswordChangedAt:
		m.ResetPasswordChangedAt()
		return nil
	case user.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case user.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.sessions != nil {
		edges = append(edges, user.EdgeSessions)
	}
	if m.api_keys != nil {
		edges = append(edges, user.EdgeAPIKeys)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeSessions:
		ids := make([]ent.Value, 0, len(m.sessions))
		for id := range m.sessions {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeAPIKeys:
		ids := make([]ent.Value, 0, len(m.api_keys))
		for id := range m.api_keys {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedsessions != nil {
		edges = append(edges, user.EdgeSessions)
	}
	if m.removedapi_keys != nil {
		edges = append(edges, user.EdgeAPIKeys)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeSessions:
		ids := make([]ent.Value, 0, len(m.removedsessions))
		for id := range m.removedsessions {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeAPIKeys:
		ids := make([]ent.Value, 0, len(m.removedapi_keys))
		for id := range m.removedapi_keys {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedsessions {
		edges = append(edges, user.EdgeSessions)
	}
	if m.clearedapi_keys {
		edges = append(edges, user.EdgeAPIKeys)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeSessions:
		return m.clearedsessions
	case user.EdgeAPIKeys:
		return m.clearedapi_keys
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeSessions:
		m.ResetSessions()
		return nil
	case user.EdgeAPIKeys:
		m.ResetAPIKeys()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}

// WebhookMutation represents an operation that mutates the Webhook nodes in the graph.
type WebhookMutation struct {
	config
	op                       Op
	typ                      string
	id                       *string
	name                     *string
	url                      *string
	auth_type                *webhook.AuthType
	auth_value_encrypted     *[]byte
	auth_nonce               *[]byte
	signing_secret_encrypted *[]byte
	signing_nonce            *[]byte
	headers                  *map[string]string
	template                 *webhook.Template
	custom_template          *string
	enabled                  *bool
	success_count            *int
	addsuccess_count         *int
	failure_count            *int
	addfailure_count         *int
	last_success_at          *time.Time
	last_failure_at          *time.Time
	created_at               *time.Time
	updated_at               *time.Time
	clearedFields            map[string]struct{}
	logs                     map[string]struct{}
	removedlogs              map[string]struct{}
	clearedlogs              bool
	done                     bool
	oldValue                 func(context.Context) (*Webhook, error)
	predicates               []predicate.Webhook
}

var _ ent.Mutation = (*WebhookMutation)(nil)

// webhookOption allows management of the mutation configuration using functional options.
type webhookOption func(*WebhookMutation)

// newWebhookMutation creates new mutation for the Webhook entity.
func newWebhookMutation(c config, op Op, opts ...webhookOption) *WebhookMutation {
	m := &WebhookMutation{
		config:        c,
		op:            op,
		typ:           TypeWebhook,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withWebhookID sets the ID field of the mutation.
func withWebhookID(id string) webhookOption {
	return func(m *WebhookMutation) {
		var (
			err   error
			once  sync.Once
			value *Webhook
		)
		m.oldValue = func(ctx context.Context) (*Webhook, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Webhook.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withWebhook sets the old Webhook of the mutation.
func withWebhook(node *Webhook) webhookOption {
	return func(m *WebhookMutation) {
		m.oldValue = func(context.Context) (*Webhook, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m WebhookMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m WebhookMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Webhook entities.
func (m *WebhookMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *WebhookMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *WebhookMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Webhook.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *WebhookMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *WebhookMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Webhook entity.
// If the Webhook object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebhookMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *WebhookMutation) ResetName() {
	m.name = nil
}

// SetURL sets the "url" field.
func (m *WebhookMutation) SetURL(s string) {
	m.url = &s
}

// URL returns the value of the "url" field in the mutation.
func (m *WebhookMutation) URL() (r string, exists bool) {
	v := m.url
	if v == nil {
		return
	}
	return *v, true
}

// OldURL returns the old "url" field's value of the Webhook entity.
// If the Webhook object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebhookMutation) OldURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldURL: %w", err)
	}
	return oldValue.URL, nil
}

// ResetURL resets all changes to the "url" field.
func (m *WebhookMutation) ResetURL() {
	m.url = nil
}

// SetAuthType sets the "auth_type" field.
func (m *WebhookMutation) SetAuthType(wt webhook.AuthType) {
	m.auth_type = &wt
}

// AuthType returns the value of the "auth_type" field in the mutation.
func (m *WebhookMutation) AuthType() (r webhook.AuthType, exists bool) {
	v := m.auth_type
	if v == nil {
		return
	}
	return *v, true
}

// OldAuthType returns the old "auth_type" field's value of the Webhook entity.
// If the Webhook object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebhookMutation) OldAuthType(ctx context.Context) (v webhook.AuthType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAuthType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAuthType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAuthType: %w", err)
	}
	return oldValue.AuthType, nil
}

// ResetAuthType resets all changes to the "auth_type" field.
func (m *WebhookMutation) ResetAuthType() {
	m.auth_type = nil
}

// SetAuthValueEncrypted sets the "auth_value_encrypted" field.
func (m *WebhookMutation) SetAuthValueEncrypted(b []byte) {
	m.auth_value_encrypted = &b
}

// AuthValueEncrypted returns the value of the "auth_value_encrypted" field in the mutation.
func (m *WebhookMutation) AuthValueEncrypted() (r []byte, exists bool) {
	v := m.auth_value_encrypted
	if v == nil {
		return
	}
	return *v, true
}

// OldAuthValueEncrypted returns the old "auth_value_encrypted" field's value of the Webhook entity.
// If the Webhook object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebhookMutation) OldAuthValueEncrypted(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAuthValueEncrypted is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAuthValueEncrypted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAuthValueEncrypted: %w", err)
	}
	return oldValue.AuthValueEncrypted, nil
}

// ClearAuthValueEncrypted clears the value of the "auth_value_encrypted" field.
func (m *WebhookMutation) ClearAuthValueEncrypted() {
	m.auth_value_encrypted = nil
	m.clearedFields[webhook.FieldAuthValueEncrypted] = struct{}{}
}

// AuthValueEncryptedCleared returns if the "auth_value_encrypted" field was cleared in this mutation.
func (m *WebhookMutation) AuthValueEncryptedCleared() bool {
	_, ok := m.clearedFields[webhook.FieldAuthValueEncrypted]
	return ok
}

// ResetAuthValueEncrypted resets all changes to the "auth_value_encrypted" field.
func (m *WebhookMutation) ResetAuthValueEncrypted() {
	m.auth_value_encrypted = nil
	delete(m.clearedFields, webhook.FieldAuthValueEncrypted)
}

// SetAuthNonce sets the "auth_nonce" field.
func (m *WebhookMutation) SetAuthNonce(b []byte) {
	m.auth_nonce = &b
}

// AuthNonce returns the value of the "auth_nonce" field in the mutation.
func (m *WebhookMutation) AuthNonce() (r []byte, exists bool) {
	v := m.auth_nonce
	if v == nil {
		return
	}
	return *v, true
}

// OldAuthNonce returns the old "auth_nonce" field's value of the Webhook entity.
// If the Webhook object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebhookMutation) OldAuthNonce(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAuthNonce is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAuthNonce requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAuthNonce: %w", err)
	}
	return oldValue.AuthNonce, nil
}

// ClearAuthNonce clears the value of the "auth_nonce" field.
func (m *WebhookMutation) ClearAuthNonce() {
	m.auth_nonce = nil
	m.clearedFields[webhook.FieldAuthNonce] = struct{}{}
}

// AuthNonceCleared returns if the "auth_nonce" field was cleared in this mutation.
func (m *WebhookMutation) AuthNonceCleared() bool {
	_, ok := m.clearedFields[webhook.FieldAuthNonce]
	return ok
}

// ResetAuthNonce resets all changes to the "auth_nonce" field.
func (m *WebhookMutation) ResetAuthNonce() {
	m.auth_nonce = nil
	delete(m.clearedFields, webhook.FieldAuthNonce)
}

// SetSigningSecretEncrypted sets the "signing_secret_encrypted" field.
func (m *WebhookMutation) SetSigningSecretEncrypted(b []byte) {
	m.signing_secret_encrypted = &b
}

// SigningSecretEncrypted returns the value of the "signing_secret_encrypted" field in the mutation.
func (m *WebhookMutation) SigningSecretEncrypted() (r []byte, exists bool) {
	v := m.signing_secret_encrypted
	if v == nil {
		return
	}
	return *v, true
}

// OldSigningSecretEncrypted returns the old "signing_secret_encrypted" field's value of the Webhook entity.
// If the Webhook object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebhookMutation) OldSigningSecretEncrypted(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSigningSecretEncrypted is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSigningSecretEncrypted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSigningSecretEncrypted: %w", err)
	}
	return oldValue.SigningSecretEncrypted, nil
}

// ClearSigningSecretEncrypted clears the value of the "signing_secret_encrypted" field.
func (m *WebhookMutation) ClearSigningSecretEncrypted() {
	m.signing_secret_encrypted = nil
	m.clearedFields[webhook.FieldSigningSecretEncrypted] = struct{}{}
}

// SigningSecretEncryptedCleared returns if the "signing_secret_encrypted" field was cleared in this mutation.
func (m *WebhookMutation) SigningSecretEncryptedCleared() bool {
	_, ok := m.clearedFields[webhook.FieldSigningSecretEncrypted]
	return ok
}

// ResetSigningSecretEncrypted resets all changes to the "signing_secret_encrypted" field.
func (m *WebhookMutation) ResetSigningSecretEncrypted() {
	m.signing_secret_encrypted = nil
	delete(m.clearedFields, webhook.FieldSigningSecretEncrypted)
}

// SetSigningNonce sets the "signing_nonce" field.
func (m *WebhookMutation) SetSigningNonce(b []byte) {
	m.signing_nonce = &b
}

// SigningNonce returns the value of the "signing_nonce" field in the mutation.
func (m *WebhookMutation) SigningNonce() (r []byte, exists bool) {
	v := m.signing_nonce
	if v == nil {
		return
	}
	return *v, true
}

// OldSigningNonce returns the old "signing_nonce" field's value of the Webhook entity.
// If the Webhook object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebhookMutation) OldSigningNonce(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSigningNonce is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSigningNonce requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSigningNonce: %w", err)
	}
	return oldValue.SigningNonce, nil
}

// ClearSigningNonce clears the value of the "signing_nonce" field.
func (m *WebhookMutation) ClearSigningNonce() {
	m.signing_nonce = nil
	m.clearedFields[webhook.FieldSigningNonce] = struct{}{}
}

// SigningNonceCleared returns if the "signing_nonce" field was cleared in this mutation.
func (m *WebhookMutation) SigningNonceCleared() bool {
	_, ok := m.clearedFields[webhook.FieldSigningNonce]
	return ok
}

// ResetSigningNonce resets all changes to the "signing_nonce" field.
func (m *WebhookMutation) ResetSigningNonce() {
	m.signing_nonce = nil
	delete(m.clearedFields, webhook.FieldSigningNonce)
}

// SetHeaders sets the "headers" field.
func (m *WebhookMutation) SetHeaders(value map[string]string) {
	m.headers = &value
}

// Headers returns the value of the "headers" field in the mutation.
func (m *WebhookMutation) Headers() (r map[string]string, exists bool) {
	v := m.headers
	if v == nil {
		return
	}
	return *v, true
}

// OldHeaders returns the old "headers" field's value of the Webhook entity.
// If the Webhook object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebhookMutation) OldHeaders(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHeaders is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHeaders requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHeaders: %w", err)
	}
	return oldValue.Headers, nil
}

// ClearHeaders clears the value of the "headers" field.
func (m *WebhookMutation) ClearHeaders() {
	m.headers = nil
	m.clearedFields[webhook.FieldHeaders] = struct{}{}
}

// HeadersCleared returns if the "headers" field was cleared in this mutation.
func (m *WebhookMutation) HeadersCleared() bool {
	_, ok := m.clearedFields[webhook.FieldHeaders]
	return ok
}

// ResetHeaders resets all changes to the "headers" field.
func (m *WebhookMutation) ResetHeaders() {
	m.headers = nil
	delete(m.clearedFields, webhook.FieldHeaders)
}

// SetTemplate sets the "template" field.
func (m *WebhookMutation) SetTemplate(w webhook.Template) {
	m.template = &w
}

// Template returns the value of the "template" field in the mutation.
func (m *WebhookMutation) Template() (r webhook.Template, exists bool) {
	v := m.template
	if v == nil {
		return
	}
	return *v, true
}

// OldTemplate returns the old "template" field's value of the Webhook entity.
// If the Webhook object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebhookMutation) OldTemplate(ctx context.Context) (v webhook.Template, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTemplate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTemplate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTemplate: %w", err)
	}
	return oldValue.Template, nil
}

// ResetTemplate resets all changes to the "template" field.
func (m *WebhookMutation) ResetTemplate() {
	m.template = nil
}

// SetCustomTemplate sets the "custom_template" field.
func (m *WebhookMutation) SetCustomTemplate(s string) {
	m.custom_template = &s
}

// CustomTemplate returns the value of the "custom_template" field in the mutation.
func (m *WebhookMutation) CustomTemplate() (r string, exists bool) {
	v := m.custom_template
	if v == nil {
		return
	}
	return *v, true
}

// OldCustomTemplate returns the old "custom_template" field's value of the Webhook entity.
// If the Webhook object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebhookMutation) OldCustomTemplate(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCustomTemplate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCustomTemplate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCustomTemplate: %w", err)
	}
	return oldValue.CustomTemplate, nil
}

// ClearCustomTemplate clears the value of the "custom_template" field.
func (m *WebhookMutation) ClearCustomTemplate() {
	m.custom_template = nil
	m.clearedFields[webhook.FieldCustomTemplate] = struct{}{}
}

// CustomTemplateCleared returns if the "custom_template" field was cleared in this mutation.
func (m *WebhookMutation) CustomTemplateCleared() bool {
	_, ok := m.clearedFields[webhook.FieldCustomTemplate]
	return ok
}

// ResetCustomTemplate resets all changes to the "custom_template" field.
func (m *WebhookMutation) ResetCustomTemplate() {
	m.custom_template = nil
	delete(m.clearedFields, webhook.FieldCustomTemplate)
}

// SetEnabled sets the "enabled" field.
func (m *WebhookMutation) SetEnabled(b bool) {
	m.enabled = &b
}

// Enabled returns the value of the "enabled" field in the mutation.
func (m *WebhookMutation) Enabled() (r bool, exists bool) {
	v := m.enabled
	if v == nil {
		return
	}
	return *v, true
}

// OldEnabled returns the old "enabled" field's value of the Webhook entity.
// If the Webhook object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebhookMutation) OldEnabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnabled: %w", err)
	}
	return oldValue.Enabled, nil
}

// ResetEnabled resets all changes to the "enabled" field.
func (m *WebhookMutation) ResetEnabled() {
	m.enabled = nil
}

// SetSuccessCount sets the "success_count" field.
func (m *WebhookMutation) SetSuccessCount(i int) {
	m.success_count = &i
	m.addsuccess_count = nil
}

// SuccessCount returns the value of the "success_count" field in the mutation.
func (m *WebhookMutation) SuccessCount() (r int, exists bool) {
	v := m.success_count
	if v == nil {
		return
	}
	return *v, true
}

// OldSuccessCount returns the old "success_count" field's value of the Webhook entity.
// If the Webhook object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebhookMutation) OldSuccessCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSuccessCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSuccessCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSuccessCount: %w", err)
	}
	return oldValue.SuccessCount, nil
}

// AddSuccessCount adds i to the "success_count" field.
func (m *WebhookMutation) AddSuccessCount(i int) {
	if m.addsuccess_count != nil {
		*m.addsuccess_count += i
	} else {
		m.addsuccess_count = &i
	}
}

// AddedSuccessCount returns the value that was added to the "success_count" field in this mutation.
func (m *WebhookMutation) AddedSuccessCount() (r int, exists bool) {
	v := m.addsuccess_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetSuccessCount resets all changes to the "success_count" field.
func (m *WebhookMutation) ResetSuccessCount() {
	m.success_count = nil
	m.addsuccess_count = nil
}

// SetFailureCount sets the "failure_count" field.
func (m *WebhookMutation) SetFailureCount(i int) {
	m.failure_count = &i
	m.addfailure_count = nil
}

// FailureCount returns the value of the "failure_count" field in the mutation.
func (m *WebhookMutation) FailureCount() (r int, exists bool) {
	v := m.failure_count
	if v == nil {
		return
	}
	return *v, true
}

// OldFailureCount returns the old "failure_count" field's value of the Webhook entity.
// If the Webhook object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebhookMutation) OldFailureCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFailureCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFailureCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFailureCount: %w", err)
	}
	return oldValue.FailureCount, nil
}

// AddFailureCount adds i to the "failure_count" field.
func (m *WebhookMutation) AddFailureCount(i int) {
	if m.addfailure_count != nil {
		*m.addfailure_count += i
	} else {
		m.addfailure_count = &i
	}
}

// AddedFailureCount returns the value that was added to the "failure_count" field in this mutation.
func (m *WebhookMutation) AddedFailureCount() (r int, exists bool) {
	v := m.addfailure_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetFailureCount resets all changes to the "failure_count" field.
func (m *WebhookMutation) ResetFailureCount() {
	m.failure_count = nil
	m.addfailure_count = nil
}

// SetLastSuccessAt sets the "last_success_at" field.
func (m *WebhookMutation) SetLastSuccessAt(t time.Time) {
	m.last_success_at = &t
}

// LastSuccessAt returns the value of the "last_success_at" field in the mutation.
func (m *WebhookMutation) LastSuccessAt() (r time.Time, exists bool) {
	v := m.last_success_at
	if v == nil {
		return
	}
	return *v, true
}

// OldLastSuccessAt returns the old "last_success_at" field's value of the Webhook entity.
// If the Webhook object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebhookMutation) OldLastSuccessAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastSuccessAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastSuccessAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastSuccessAt: %w", err)
	}
	return oldValue.LastSuccessAt, nil
}

// ClearLastSuccessAt clears the value of the "last_success_at" field.
func (m *WebhookMutation) ClearLastSuccessAt() {
	m.last_success_at = nil
	m.clearedFields[webhook.FieldLastSuccessAt] = struct{}{}
}

// LastSuccessAtCleared returns if the "last_success_at" field was cleared in this mutation.
func (m *WebhookMutation) LastSuccessAtCleared() bool {
	_, ok := m.clearedFields[webhook.FieldLastSuccessAt]
	return ok
}

// ResetLastSuccessAt resets all changes to the "last_success_at" field.
func (m *WebhookMutation) ResetLastSuccessAt() {
	m.last_success_at = nil
	delete(m.clearedFields, webhook.FieldLastSuccessAt)
}

// SetLastFailureAt sets the "last_failure_at" field.
func (m *WebhookMutation) SetLastFailureAt(t time.Time) {
	m.last_failure_at = &t
}

// LastFailureAt returns the value of the "last_failure_at" field in the mutation.
func (m *WebhookMutation) LastFailureAt() (r time.Time, exists bool) {
	v := m.last_failure_at
	if v == nil {
		return
	}
	return *v, true
}

// OldLastFailureAt returns the old "last_failure_at" field's value of the Webhook entity.
// If the Webhook object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebhookMutation) OldLastFailureAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastFailureAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastFailureAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastFailureAt: %w", err)
	}
	return oldValue.LastFailureAt, nil
}

// ClearLastFailureAt clears the value of the "last_failure_at" field.
func (m *WebhookMutation) ClearLastFailureAt() {
	m.last_failure_at = nil
	m.clearedFields[webhook.FieldLastFailureAt] = struct{}{}
}

// LastFailureAtCleared returns if the "last_failure_at" field was cleared in this mutation.
func (m *WebhookMutation) LastFailureAtCleared() bool {
	_, ok := m.clearedFields[webhook.FieldLastFailureAt]
	return ok
}

// ResetLastFailureAt resets all changes to the "last_failure_at" field.
func (m *WebhookMutation) ResetLastFailureAt() {
	m.last_failure_at = nil
	delete(m.clearedFields, webhook.FieldLastFailureAt)
}

// SetCreatedAt sets the "created_at" field.
func (m *WebhookMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *WebhookMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Webhook entity.
// If the Webhook object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebhookMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *WebhookMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *WebhookMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *WebhookMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Webhook entity.
// If the Webhook object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebhookMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *WebhookMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// AddLogIDs adds the "logs" edge to the NotificationLog entity by ids.
func (m *WebhookMutation) AddLogIDs(ids ...string) {
	if m.logs == nil {
		m.logs = make(map[string]struct{})
	}
	for i := range ids {
		m.logs[ids[i]] = struct{}{}
	}
}

// ClearLogs clears the "logs" edge to the NotificationLog entity.
func (m *WebhookMutation) ClearLogs() {
	m.clearedlogs = true
}

// LogsCleared reports if the "logs" edge to the NotificationLog entity was cleared.
func (m *WebhookMutation) LogsCleared() bool {
	return m.clearedlogs
}

// RemoveLogIDs removes the "logs" edge to the NotificationLog entity by IDs.
func (m *WebhookMutation) RemoveLogIDs(ids ...string) {
	if m.removedlogs == nil {
		m.removedlogs = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.logs, ids[i])
		m.removedlogs[ids[i]] = struct{}{}
	}
}

// RemovedLogs returns the removed IDs of the "logs" edge to the NotificationLog entity.
func (m *WebhookMutation) RemovedLogsIDs() (ids []string) {
	for id := range m.removedlogs {
		ids = append(ids, id)
	}
	return
}

// LogsIDs returns the "logs" edge IDs in the mutation.
func (m *WebhookMutation) LogsIDs() (ids []string) {
	for id := range m.logs {
		ids = append(ids, id)
	}
	return
}

// ResetLogs resets all changes to the "logs" edge.
func (m *WebhookMutation) ResetLogs() {
	m.logs = nil
	m.clearedlogs = false
	m.removedlogs = nil
}

// Where appends a list predicates to the WebhookMutation builder.
func (m *WebhookMutation) Where(ps ...predicate.Webhook) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the WebhookMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *WebhookMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Webhook, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *WebhookMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *WebhookMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Webhook).
func (m *WebhookMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *WebhookMutation) Fields() []string {
	fields := make([]string, 0, 17)
	if m.name != nil {
		fields = append(fields, webhook.FieldName)
	}
	if m.url != nil {
		fields = append(fields, webhook.FieldURL)
	}
	if m.auth_type != nil {
		fields = append(fields, webhook.FieldAuthType)
	}
	if m.auth_value_encrypted != nil {
		fields = append(fields, webhook.FieldAuthValueEncrypted)
	}
	if m.auth_nonce != nil {
		fields = append(fields, webhook.FieldAuthNonce)
	}
	if m.signing_secret_encrypted != nil {
		fields = append(fields, webhook.FieldSigningSecretEncrypted)
	}
	if m.signing_nonce != nil {
		fields = append(fields, webhook.FieldSigningNonce)
	}
	if m.headers != nil {
		fields = append(fields, webhook.FieldHeaders)
	}
	if m.template != nil {
		fields = append(fields, webhook.FieldTemplate)
	}
	if m.custom_template != nil {
		fields = append(fields, webhook.FieldCustomTemplate)
	}
	if m.enabled != nil {
		fields = append(fields, webhook.FieldEnabled)
	}
	if m.success_count != nil {
		fields = append(fields, webhook.FieldSuccessCount)
	}
	if m.failure_count != nil {
		fields = append(fields, webhook.FieldFailureCount)
	}
	if m.last_success_at != nil {
		fields = append(fields, webhook.FieldLastSuccessAt)
	}
	if m.last_failure_at != nil {
		fields = append(fields, webhook.FieldLastFailureAt)
	}
	if m.created_at != nil {
		fields = append(fields, webhook.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, webhook.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *WebhookMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case webhook.FieldName:
		return m.Name()
	case webhook.FieldURL:
		return m.URL()
	case webhook.FieldAuthType:
		return m.AuthType()
	case webhook.FieldAuthValueEncrypted:
		return m.AuthValueEncrypted()
	case webhook.FieldAuthNonce:
		return m.AuthNonce()
	case webhook.FieldSigningSecretEncrypted:
		return m.SigningSecretEncrypted()
	case webhook.FieldSigningNonce:
		return m.SigningNonce()
	case webhook.FieldHeaders:
		return m.Headers()
	case webhook.FieldTemplate:
		return m.Template()
	case webhook.FieldCustomTemplate:
		return m.CustomTemplate()
	case webhook.FieldEnabled:
		return m.Enabled()
	case webhook.FieldSuccessCount:
		return m.SuccessCount()
	case webhook.FieldFailureCount:
		return m.FailureCount()
	case webhook.FieldLastSuccessAt:
		return m.LastSuccessAt()
	case webhook.FieldLastFailureAt:
		return m.LastFailureAt()
	case webhook.FieldCreatedAt:
		return m.CreatedAt()
	case webhook.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *WebhookMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case webhook.FieldName:
		return m.OldName(ctx)
	case webhook.FieldURL:
		return m.OldURL(ctx)
	case webhook.FieldAuthType:
		return m.OldAuthType(ctx)
	case webhook.FieldAuthValueEncrypted:
		return m.OldAuthValueEncrypted(ctx)
	case webhook.FieldAuthNonce:
		return m.OldAuthNonce(ctx)
	case webhook.FieldSigningSecretEncrypted:
		return m.OldSigningSecretEncrypted(ctx)
	case webhook.FieldSigningNonce:
		return m.OldSigningNonce(ctx)
	case webhook.FieldHeaders:
		return m.OldHeaders(ctx)
	case webhook.FieldTemplate:
		return m.OldTemplate(ctx)
	case webhook.FieldCustomTemplate:
		return m.OldCustomTemplate(ctx)
	case webhook.FieldEnabled:
		return m.OldEnabled(ctx)
	case webhook.FieldSuccessCount:
		return m.OldSuccessCount(ctx)
	case webhook.FieldFailureCount:
		return m.OldFailureCount(ctx)
	case webhook.FieldLastSuccessAt:
		return m.OldLastSuccessAt(ctx)
	case webhook.FieldLastFailureAt:
		return m.OldLastFailureAt(ctx)
	case webhook.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case webhook.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Webhook field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WebhookMutation) SetField(name string, value ent.Value) error {
	switch name {
	case webhook.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case webhook.FieldURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetURL(v)
		return nil
	case webhook.FieldAuthType:
		v, ok := value.(webhook.AuthType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAuthType(v)
		return nil
	case webhook.FieldAuthValueEncrypted:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAuthValueEncrypted(v)
		return nil
	case webhook.FieldAuthNonce:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAuthNonce(v)
		return nil
	case webhook.FieldSigningSecretEncrypted:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSigningSecretEncrypted(v)
		return nil
	case webhook.FieldSigningNonce:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSigningNonce(v)
		return nil
	case webhook.FieldHeaders:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHeaders(v)
		return nil
	case webhook.FieldTemplate:
		v, ok := value.(webhook.Template)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTemplate(v)
		return nil
	case webhook.FieldCustomTemplate:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCustomTemplate(v)
		return nil
	case webhook.FieldEnabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnabled(v)
		return nil
	case webhook.FieldSuccessCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSuccessCount(v)
		return nil
	case webhook.FieldFailureCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFailureCount(v)
		return nil
	case webhook.FieldLastSuccessAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastSuccessAt(v)
		return nil
	case webhook.FieldLastFailureAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastFailureAt(v)
		return nil
	case webhook.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case webhook.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Webhook field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *WebhookMutation) AddedFields() []string {
	var fields []string
	if m.addsuccess_count != nil {
		fields = append(fields, webhook.FieldSuccessCount)
	}
	if m.addfailure_count != nil {
		fields = append(fields, webhook.FieldFailureCount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *WebhookMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case webhook.FieldSuccessCount:
		return m.AddedSuccessCount()
	case webhook.FieldFailureCount:
		return m.AddedFailureCount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WebhookMutation) AddField(name string, value ent.Value) error {
	switch name {
	case webhook.FieldSuccessCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSuccessCount(v)
		return nil
	case webhook.FieldFailureCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFailureCount(v)
		return nil
	}
	return fmt.Errorf("unknown Webhook numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *WebhookMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(webhook.FieldAuthValueEncrypted) {
		fields = append(fields, webhook.FieldAuthValueEncrypted)
	}
	if m.FieldCleared(webhook.FieldAuthNonce) {
		fields = append(fields, webhook.FieldAuthNonce)
	}
	if m.FieldCleared(webhook.FieldSigningSecretEncrypted) {
		fields = append(fields, webhook.FieldSigningSecretEncrypted)
	}
	if m.FieldCleared(webhook.FieldSigningNonce) {
		fields = append(fields, webhook.FieldSigningNonce)
	}
	if m.FieldCleared(webhook.FieldHeaders) {
		fields = append(fields, webhook.FieldHeaders)
	}
	if m.FieldCleared(webhook.FieldCustomTemplate) {
		fields = append(fields, webhook.FieldCustomTemplate)
	}
	if m.FieldCleared(webhook.FieldLastSuccessAt) {
		fields = append(fields, webhook.FieldLastSuccessAt)
	}
	if m.FieldCleared(webhook.FieldLastFailureAt) {
		fields = append(fields, webhook.FieldLastFailureAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *WebhookMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *WebhookMutation) ClearField(name string) error {
	switch name {
	case webhook.FieldAuthValueEncrypted:
		m.ClearAuthValueEncrypted()
		return nil
	case webhook.FieldAuthNonce:
		m.ClearAuthNonce()
		return nil
	case webhook.FieldSigningSecretEncrypted:
		m.ClearSigningSecretEncrypted()
		return nil
	case webhook.FieldSigningNonce:
		m.ClearSigningNonce()
		return nil
	case webhook.FieldHeaders:
		m.ClearHeaders()
		return nil
	case webhook.FieldCustomTemplate:
		m.ClearCustomTemplate()
		return nil
	case webhook.FieldLastSuccessAt:
		m.ClearLastSuccessAt()
		return nil
	case webhook.FieldLastFailureAt:
		m.ClearLastFailureAt()
		return nil
	}
	return fmt.Errorf("unknown Webhook nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *WebhookMutation) ResetField(name string) error {
	switch name {
	case webhook.FieldName:
		m.ResetName()
		return nil
	case webhook.FieldURL:
		m.ResetURL()
		return nil
	case webhook.FieldAuthType:
		m.ResetAuthType()
		return nil
	case webhook.FieldAuthValueEncrypted:
		m.ResetAuthValueEncrypted()
		return nil
	case webhook.FieldAuthNonce:
		m.ResetAuthNonce()
		return nil
	case webhook.FieldSigningSecretEncrypted:
		m.ResetSigningSecretEncrypted()
		return nil
	case webhook.FieldSigningNonce:
		m.ResetSigningNonce()
		return nil
	case webhook.FieldHeaders:
		m.ResetHeaders()
		return nil
	case webhook.FieldTemplate:
		m.ResetTemplate()
		return nil
	case webhook.FieldCustomTemplate:
		m.ResetCustomTemplate()
		return nil
	case webhook.FieldEnabled:
		m.ResetEnabled()
		return nil
	case webhook.FieldSuccessCount:
		m.ResetSuccessCount()
		return nil
	case webhook.FieldFailureCount:
		m.ResetFailureCount()
		return nil
	case webhook.FieldLastSuccessAt:
		m.ResetLastSuccessAt()
		return nil
	case webhook.FieldLastFailureAt:
		m.ResetLastFailureAt()
		return nil
	case webhook.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case webhook.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Webhook field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *WebhookMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.logs != nil {
		edges = append(edges, webhook.EdgeLogs)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *WebhookMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case webhook.EdgeLogs:
		ids := make([]ent.Value, 0, len(m.logs))
		for id := range m.logs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *WebhookMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedlogs != nil {
		edges = append(edges, webhook.EdgeLogs)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *WebhookMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case webhook.EdgeLogs:
		ids := make([]ent.Value, 0, len(m.removedlogs))
		for id := range m.removedlogs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *WebhookMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedlogs {
		edges = append(edges, webhook.EdgeLogs)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *WebhookMutation) EdgeCleared(name string) bool {
	switch name {
	case webhook.EdgeLogs:
		return m.clearedlogs
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *WebhookMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Webhook unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *WebhookMutation) ResetEdge(name string) error {
	switch name {
	case webhook.EdgeLogs:
		m.ResetLogs()
		return nil
	}
	return fmt.Errorf("unknown Webhook edge %s", name)
}
