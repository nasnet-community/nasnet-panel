// Code generated by ent, DO NOT EDIT.

package ent

import (
	"backend/generated/ent/alert"
	"backend/generated/ent/alertdigestentry"
	"backend/generated/ent/alertescalation"
	"backend/generated/ent/alertrule"
	"backend/generated/ent/alertruletemplate"
	"backend/generated/ent/alerttemplate"
	"backend/generated/ent/apikey"
	"backend/generated/ent/chainhop"
	"backend/generated/ent/configsnapshot"
	"backend/generated/ent/devicerouting"
	"backend/generated/ent/diagnosticresult"
	"backend/generated/ent/globalsettings"
	"backend/generated/ent/notificationchannelconfig"
	"backend/generated/ent/notificationlog"
	"backend/generated/ent/notificationsettings"
	"backend/generated/ent/portallocation"
	"backend/generated/ent/portknocksequence"
	"backend/generated/ent/predicate"
	"backend/generated/ent/resource"
	"backend/generated/ent/resourceevent"
	"backend/generated/ent/router"
	"backend/generated/ent/routercapability"
	"backend/generated/ent/routersecret"
	"backend/generated/ent/routingchain"
	"backend/generated/ent/routingschedule"
	"backend/generated/ent/schemaversion"
	"backend/generated/ent/servicedependency"
	"backend/generated/ent/serviceinstance"
	"backend/generated/ent/servicetemplate"
	"backend/generated/ent/servicetraffichourly"
	"backend/generated/ent/session"
	"backend/generated/ent/user"
	"backend/generated/ent/virtualinterface"
	"backend/generated/ent/vlanallocation"
	"backend/generated/ent/webhook"
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/google/uuid"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAPIKey                    = "APIKey"
	TypeAlert                     = "Alert"
	TypeAlertDigestEntry          = "AlertDigestEntry"
	TypeAlertEscalation           = "AlertEscalation"
	TypeAlertRule                 = "AlertRule"
	TypeAlertRuleTemplate         = "AlertRuleTemplate"
	TypeAlertTemplate             = "AlertTemplate"
	TypeChainHop                  = "ChainHop"
	TypeConfigSnapshot            = "ConfigSnapshot"
	TypeDeviceRouting             = "DeviceRouting"
	TypeDiagnosticResult          = "DiagnosticResult"
	TypeGlobalSettings            = "GlobalSettings"
	TypeNotificationChannelConfig = "NotificationChannelConfig"
	TypeNotificationLog           = "NotificationLog"
	TypeNotificationSettings      = "NotificationSettings"
	TypePortAllocation            = "PortAllocation"
	TypePortKnockSequence         = "PortKnockSequence"
	TypeResource                  = "Resource"
	TypeResourceEvent             = "ResourceEvent"
	TypeRouter                    = "Router"
	TypeRouterCapability          = "RouterCapability"
	TypeRouterSecret              = "RouterSecret"
	TypeRoutingChain              = "RoutingChain"
	TypeRoutingSchedule           = "RoutingSchedule"
	TypeSchemaVersion             = "SchemaVersion"
	TypeServiceDependency         = "ServiceDependency"
	TypeServiceInstance           = "ServiceInstance"
	TypeServiceTemplate           = "ServiceTemplate"
	TypeServiceTrafficHourly      = "ServiceTrafficHourly"
	TypeSession                   = "Session"
	TypeUser                      = "User"
	TypeVLANAllocation            = "VLANAllocation"
	TypeVirtualInterface          = "VirtualInterface"
	TypeWebhook                   = "Webhook"
)

// APIKeyMutation represents an operation that mutates the APIKey nodes in the graph.
type APIKeyMutation struct {
	config
	op                    Op
	typ                   string
	id                    *string
	name                  *string
	prefix                *string
	key_hash              *string
	scopes                *[]string
	appendscopes          []string
	allowed_routers       *[]string
	appendallowed_routers []string
	expires_at            *time.Time
	last_used_at          *time.Time
	usage_count           *int
	addusage_count        *int
	active                *bool
	revoked_at            *time.Time
	created_at            *time.Time
	updated_at            *time.Time
	clearedFields         map[string]struct{}
	user                  *string
	cleareduser           bool
	done                  bool
	oldValue              func(context.Context) (*APIKey, error)
	predicates            []predicate.APIKey
}

var _ ent.Mutation = (*APIKeyMutation)(nil)

// apikeyOption allows management of the mutation configuration using functional options.
type apikeyOption func(*APIKeyMutation)

// newAPIKeyMutation creates new mutation for the APIKey entity.
func newAPIKeyMutation(c config, op Op, opts ...apikeyOption) *APIKeyMutation {
	m := &APIKeyMutation{
		config:        c,
		op:            op,
		typ:           TypeAPIKey,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAPIKeyID sets the ID field of the mutation.
func withAPIKeyID(id string) apikeyOption {
	return func(m *APIKeyMutation) {
		var (
			err   error
			once  sync.Once
			value *APIKey
		)
		m.oldValue = func(ctx context.Context) (*APIKey, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().APIKey.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAPIKey sets the old APIKey of the mutation.
func withAPIKey(node *APIKey) apikeyOption {
	return func(m *APIKeyMutation) {
		m.oldValue = func(context.Context) (*APIKey, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m APIKeyMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m APIKeyMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of APIKey entities.
func (m *APIKeyMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *APIKeyMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *APIKeyMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().APIKey.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserID sets the "user_id" field.
func (m *APIKeyMutation) SetUserID(s string) {
	m.user = &s
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *APIKeyMutation) UserID() (r string, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the APIKey entity.
// If the APIKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIKeyMutation) OldUserID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *APIKeyMutation) ResetUserID() {
	m.user = nil
}

// SetName sets the "name" field.
func (m *APIKeyMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *APIKeyMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the APIKey entity.
// If the APIKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIKeyMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *APIKeyMutation) ResetName() {
	m.name = nil
}

// SetPrefix sets the "prefix" field.
func (m *APIKeyMutation) SetPrefix(s string) {
	m.prefix = &s
}

// Prefix returns the value of the "prefix" field in the mutation.
func (m *APIKeyMutation) Prefix() (r string, exists bool) {
	v := m.prefix
	if v == nil {
		return
	}
	return *v, true
}

// OldPrefix returns the old "prefix" field's value of the APIKey entity.
// If the APIKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIKeyMutation) OldPrefix(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrefix is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrefix requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrefix: %w", err)
	}
	return oldValue.Prefix, nil
}

// ResetPrefix resets all changes to the "prefix" field.
func (m *APIKeyMutation) ResetPrefix() {
	m.prefix = nil
}

// SetKeyHash sets the "key_hash" field.
func (m *APIKeyMutation) SetKeyHash(s string) {
	m.key_hash = &s
}

// KeyHash returns the value of the "key_hash" field in the mutation.
func (m *APIKeyMutation) KeyHash() (r string, exists bool) {
	v := m.key_hash
	if v == nil {
		return
	}
	return *v, true
}

// OldKeyHash returns the old "key_hash" field's value of the APIKey entity.
// If the APIKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIKeyMutation) OldKeyHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKeyHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKeyHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKeyHash: %w", err)
	}
	return oldValue.KeyHash, nil
}

// ResetKeyHash resets all changes to the "key_hash" field.
func (m *APIKeyMutation) ResetKeyHash() {
	m.key_hash = nil
}

// SetScopes sets the "scopes" field.
func (m *APIKeyMutation) SetScopes(s []string) {
	m.scopes = &s
	m.appendscopes = nil
}

// Scopes returns the value of the "scopes" field in the mutation.
func (m *APIKeyMutation) Scopes() (r []string, exists bool) {
	v := m.scopes
	if v == nil {
		return
	}
	return *v, true
}

// OldScopes returns the old "scopes" field's value of the APIKey entity.
// If the APIKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIKeyMutation) OldScopes(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScopes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScopes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScopes: %w", err)
	}
	return oldValue.Scopes, nil
}

// AppendScopes adds s to the "scopes" field.
func (m *APIKeyMutation) AppendScopes(s []string) {
	m.appendscopes = append(m.appendscopes, s...)
}

// AppendedScopes returns the list of values that were appended to the "scopes" field in this mutation.
func (m *APIKeyMutation) AppendedScopes() ([]string, bool) {
	if len(m.appendscopes) == 0 {
		return nil, false
	}
	return m.appendscopes, true
}

// ResetScopes resets all changes to the "scopes" field.
func (m *APIKeyMutation) ResetScopes() {
	m.scopes = nil
	m.appendscopes = nil
}

// SetAllowedRouters sets the "allowed_routers" field.
func (m *APIKeyMutation) SetAllowedRouters(s []string) {
	m.allowed_routers = &s
	m.appendallowed_routers = nil
}

// AllowedRouters returns the value of the "allowed_routers" field in the mutation.
func (m *APIKeyMutation) AllowedRouters() (r []string, exists bool) {
	v := m.allowed_routers
	if v == nil {
		return
	}
	return *v, true
}

// OldAllowedRouters returns the old "allowed_routers" field's value of the APIKey entity.
// If the APIKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIKeyMutation) OldAllowedRouters(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAllowedRouters is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAllowedRouters requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAllowedRouters: %w", err)
	}
	return oldValue.AllowedRouters, nil
}

// AppendAllowedRouters adds s to the "allowed_routers" field.
func (m *APIKeyMutation) AppendAllowedRouters(s []string) {
	m.appendallowed_routers = append(m.appendallowed_routers, s...)
}

// AppendedAllowedRouters returns the list of values that were appended to the "allowed_routers" field in this mutation.
func (m *APIKeyMutation) AppendedAllowedRouters() ([]string, bool) {
	if len(m.appendallowed_routers) == 0 {
		return nil, false
	}
	return m.appendallowed_routers, true
}

// ClearAllowedRouters clears the value of the "allowed_routers" field.
func (m *APIKeyMutation) ClearAllowedRouters() {
	m.allowed_routers = nil
	m.appendallowed_routers = nil
	m.clearedFields[apikey.FieldAllowedRouters] = struct{}{}
}

// AllowedRoutersCleared returns if the "allowed_routers" field was cleared in this mutation.
func (m *APIKeyMutation) AllowedRoutersCleared() bool {
	_, ok := m.clearedFields[apikey.FieldAllowedRouters]
	return ok
}

// ResetAllowedRouters resets all changes to the "allowed_routers" field.
func (m *APIKeyMutation) ResetAllowedRouters() {
	m.allowed_routers = nil
	m.appendallowed_routers = nil
	delete(m.clearedFields, apikey.FieldAllowedRouters)
}

// SetExpiresAt sets the "expires_at" field.
func (m *APIKeyMutation) SetExpiresAt(t time.Time) {
	m.expires_at = &t
}

// ExpiresAt returns the value of the "expires_at" field in the mutation.
func (m *APIKeyMutation) ExpiresAt() (r time.Time, exists bool) {
	v := m.expires_at
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiresAt returns the old "expires_at" field's value of the APIKey entity.
// If the APIKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIKeyMutation) OldExpiresAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiresAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiresAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiresAt: %w", err)
	}
	return oldValue.ExpiresAt, nil
}

// ClearExpiresAt clears the value of the "expires_at" field.
func (m *APIKeyMutation) ClearExpiresAt() {
	m.expires_at = nil
	m.clearedFields[apikey.FieldExpiresAt] = struct{}{}
}

// ExpiresAtCleared returns if the "expires_at" field was cleared in this mutation.
func (m *APIKeyMutation) ExpiresAtCleared() bool {
	_, ok := m.clearedFields[apikey.FieldExpiresAt]
	return ok
}

// ResetExpiresAt resets all changes to the "expires_at" field.
func (m *APIKeyMutation) ResetExpiresAt() {
	m.expires_at = nil
	delete(m.clearedFields, apikey.FieldExpiresAt)
}

// SetLastUsedAt sets the "last_used_at" field.
func (m *APIKeyMutation) SetLastUsedAt(t time.Time) {
	m.last_used_at = &t
}

// LastUsedAt returns the value of the "last_used_at" field in the mutation.
func (m *APIKeyMutation) LastUsedAt() (r time.Time, exists bool) {
	v := m.last_used_at
	if v == nil {
		return
	}
	return *v, true
}

// OldLastUsedAt returns the old "last_used_at" field's value of the APIKey entity.
// If the APIKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIKeyMutation) OldLastUsedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastUsedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastUsedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastUsedAt: %w", err)
	}
	return oldValue.LastUsedAt, nil
}

// ClearLastUsedAt clears the value of the "last_used_at" field.
func (m *APIKeyMutation) ClearLastUsedAt() {
	m.last_used_at = nil
	m.clearedFields[apikey.FieldLastUsedAt] = struct{}{}
}

// LastUsedAtCleared returns if the "last_used_at" field was cleared in this mutation.
func (m *APIKeyMutation) LastUsedAtCleared() bool {
	_, ok := m.clearedFields[apikey.FieldLastUsedAt]
	return ok
}

// ResetLastUsedAt resets all changes to the "last_used_at" field.
func (m *APIKeyMutation) ResetLastUsedAt() {
	m.last_used_at = nil
	delete(m.clearedFields, apikey.FieldLastUsedAt)
}

// SetUsageCount sets the "usage_count" field.
func (m *APIKeyMutation) SetUsageCount(i int) {
	m.usage_count = &i
	m.addusage_count = nil
}

// UsageCount returns the value of the "usage_count" field in the mutation.
func (m *APIKeyMutation) UsageCount() (r int, exists bool) {
	v := m.usage_count
	if v == nil {
		return
	}
	return *v, true
}

// OldUsageCount returns the old "usage_count" field's value of the APIKey entity.
// If the APIKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIKeyMutation) OldUsageCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsageCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsageCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsageCount: %w", err)
	}
	return oldValue.UsageCount, nil
}

// AddUsageCount adds i to the "usage_count" field.
func (m *APIKeyMutation) AddUsageCount(i int) {
	if m.addusage_count != nil {
		*m.addusage_count += i
	} else {
		m.addusage_count = &i
	}
}

// AddedUsageCount returns the value that was added to the "usage_count" field in this mutation.
func (m *APIKeyMutation) AddedUsageCount() (r int, exists bool) {
	v := m.addusage_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetUsageCount resets all changes to the "usage_count" field.
func (m *APIKeyMutation) ResetUsageCount() {
	m.usage_count = nil
	m.addusage_count = nil
}

// SetActive sets the "active" field.
func (m *APIKeyMutation) SetActive(b bool) {
	m.active = &b
}

// Active returns the value of the "active" field in the mutation.
func (m *APIKeyMutation) Active() (r bool, exists bool) {
	v := m.active
	if v == nil {
		return
	}
	return *v, true
}

// OldActive returns the old "active" field's value of the APIKey entity.
// If the APIKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIKeyMutation) OldActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActive: %w", err)
	}
	return oldValue.Active, nil
}

// ResetActive resets all changes to the "active" field.
func (m *APIKeyMutation) ResetActive() {
	m.active = nil
}

// SetRevokedAt sets the "revoked_at" field.
func (m *APIKeyMutation) SetRevokedAt(t time.Time) {
	m.revoked_at = &t
}

// RevokedAt returns the value of the "revoked_at" field in the mutation.
func (m *APIKeyMutation) RevokedAt() (r time.Time, exists bool) {
	v := m.revoked_at
	if v == nil {
		return
	}
	return *v, true
}

// OldRevokedAt returns the old "revoked_at" field's value of the APIKey entity.
// If the APIKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIKeyMutation) OldRevokedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRevokedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRevokedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRevokedAt: %w", err)
	}
	return oldValue.RevokedAt, nil
}

// ClearRevokedAt clears the value of the "revoked_at" field.
func (m *APIKeyMutation) ClearRevokedAt() {
	m.revoked_at = nil
	m.clearedFields[apikey.FieldRevokedAt] = struct{}{}
}

// RevokedAtCleared returns if the "revoked_at" field was cleared in this mutation.
func (m *APIKeyMutation) RevokedAtCleared() bool {
	_, ok := m.clearedFields[apikey.FieldRevokedAt]
	return ok
}

// ResetRevokedAt resets all changes to the "revoked_at" field.
func (m *APIKeyMutation) ResetRevokedAt() {
	m.revoked_at = nil
	delete(m.clearedFields, apikey.FieldRevokedAt)
}

// SetCreatedAt sets the "created_at" field.
func (m *APIKeyMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *APIKeyMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the APIKey entity.
// If the APIKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIKeyMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *APIKeyMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *APIKeyMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *APIKeyMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the APIKey entity.
// If the APIKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIKeyMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *APIKeyMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *APIKeyMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[apikey.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *APIKeyMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *APIKeyMutation) UserIDs() (ids []string) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *APIKeyMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the APIKeyMutation builder.
func (m *APIKeyMutation) Where(ps ...predicate.APIKey) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the APIKeyMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *APIKeyMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.APIKey, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *APIKeyMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *APIKeyMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (APIKey).
func (m *APIKeyMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *APIKeyMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.user != nil {
		fields = append(fields, apikey.FieldUserID)
	}
	if m.name != nil {
		fields = append(fields, apikey.FieldName)
	}
	if m.prefix != nil {
		fields = append(fields, apikey.FieldPrefix)
	}
	if m.key_hash != nil {
		fields = append(fields, apikey.FieldKeyHash)
	}
	if m.scopes != nil {
		fields = append(fields, apikey.FieldScopes)
	}
	if m.allowed_routers != nil {
		fields = append(fields, apikey.FieldAllowedRouters)
	}
	if m.expires_at != nil {
		fields = append(fields, apikey.FieldExpiresAt)
	}
	if m.last_used_at != nil {
		fields = append(fields, apikey.FieldLastUsedAt)
	}
	if m.usage_count != nil {
		fields = append(fields, apikey.FieldUsageCount)
	}
	if m.active != nil {
		fields = append(fields, apikey.FieldActive)
	}
	if m.revoked_at != nil {
		fields = append(fields, apikey.FieldRevokedAt)
	}
	if m.created_at != nil {
		fields = append(fields, apikey.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, apikey.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *APIKeyMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case apikey.FieldUserID:
		return m.UserID()
	case apikey.FieldName:
		return m.Name()
	case apikey.FieldPrefix:
		return m.Prefix()
	case apikey.FieldKeyHash:
		return m.KeyHash()
	case apikey.FieldScopes:
		return m.Scopes()
	case apikey.FieldAllowedRouters:
		return m.AllowedRouters()
	case apikey.FieldExpiresAt:
		return m.ExpiresAt()
	case apikey.FieldLastUsedAt:
		return m.LastUsedAt()
	case apikey.FieldUsageCount:
		return m.UsageCount()
	case apikey.FieldActive:
		return m.Active()
	case apikey.FieldRevokedAt:
		return m.RevokedAt()
	case apikey.FieldCreatedAt:
		return m.CreatedAt()
	case apikey.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *APIKeyMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case apikey.FieldUserID:
		return m.OldUserID(ctx)
	case apikey.FieldName:
		return m.OldName(ctx)
	case apikey.FieldPrefix:
		return m.OldPrefix(ctx)
	case apikey.FieldKeyHash:
		return m.OldKeyHash(ctx)
	case apikey.FieldScopes:
		return m.OldScopes(ctx)
	case apikey.FieldAllowedRouters:
		return m.OldAllowedRouters(ctx)
	case apikey.FieldExpiresAt:
		return m.OldExpiresAt(ctx)
	case apikey.FieldLastUsedAt:
		return m.OldLastUsedAt(ctx)
	case apikey.FieldUsageCount:
		return m.OldUsageCount(ctx)
	case apikey.FieldActive:
		return m.OldActive(ctx)
	case apikey.FieldRevokedAt:
		return m.OldRevokedAt(ctx)
	case apikey.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case apikey.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown APIKey field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *APIKeyMutation) SetField(name string, value ent.Value) error {
	switch name {
	case apikey.FieldUserID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case apikey.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case apikey.FieldPrefix:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrefix(v)
		return nil
	case apikey.FieldKeyHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKeyHash(v)
		return nil
	case apikey.FieldScopes:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScopes(v)
		return nil
	case apikey.FieldAllowedRouters:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAllowedRouters(v)
		return nil
	case apikey.FieldExpiresAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiresAt(v)
		return nil
	case apikey.FieldLastUsedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastUsedAt(v)
		return nil
	case apikey.FieldUsageCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsageCount(v)
		return nil
	case apikey.FieldActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActive(v)
		return nil
	case apikey.FieldRevokedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRevokedAt(v)
		return nil
	case apikey.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case apikey.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown APIKey field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *APIKeyMutation) AddedFields() []string {
	var fields []string
	if m.addusage_count != nil {
		fields = append(fields, apikey.FieldUsageCount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *APIKeyMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case apikey.FieldUsageCount:
		return m.AddedUsageCount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *APIKeyMutation) AddField(name string, value ent.Value) error {
	switch name {
	case apikey.FieldUsageCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUsageCount(v)
		return nil
	}
	return fmt.Errorf("unknown APIKey numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *APIKeyMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(apikey.FieldAllowedRouters) {
		fields = append(fields, apikey.FieldAllowedRouters)
	}
	if m.FieldCleared(apikey.FieldExpiresAt) {
		fields = append(fields, apikey.FieldExpiresAt)
	}
	if m.FieldCleared(apikey.FieldLastUsedAt) {
		fields = append(fields, apikey.FieldLastUsedAt)
	}
	if m.FieldCleared(apikey.FieldRevokedAt) {
		fields = append(fields, apikey.FieldRevokedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *APIKeyMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *APIKeyMutation) ClearField(name string) error {
	switch name {
	case apikey.FieldAllowedRouters:
		m.ClearAllowedRouters()
		return nil
	case apikey.FieldExpiresAt:
		m.ClearExpiresAt()
		return nil
	case apikey.FieldLastUsedAt:
		m.ClearLastUsedAt()
		return nil
	case apikey.FieldRevokedAt:
		m.ClearRevokedAt()
		return nil
	}
	return fmt.Errorf("unknown APIKey nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *APIKeyMutation) ResetField(name string) error {
	switch name {
	case apikey.FieldUserID:
		m.ResetUserID()
		return nil
	case apikey.FieldName:
		m.ResetName()
		return nil
	case apikey.FieldPrefix:
		m.ResetPrefix()
		return nil
	case apikey.FieldKeyHash:
		m.ResetKeyHash()
		return nil
	case apikey.FieldScopes:
		m.ResetScopes()
		return nil
	case apikey.FieldAllowedRouters:
		m.ResetAllowedRouters()
		return nil
	case apikey.FieldExpiresAt:
		m.ResetExpiresAt()
		return nil
	case apikey.FieldLastUsedAt:
		m.ResetLastUsedAt()
		return nil
	case apikey.FieldUsageCount:
		m.ResetUsageCount()
		return nil
	case apikey.FieldActive:
		m.ResetActive()
		return nil
	case apikey.FieldRevokedAt:
		m.ResetRevokedAt()
		return nil
	case apikey.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case apikey.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown APIKey field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *APIKeyMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, apikey.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *APIKeyMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case apikey.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *APIKeyMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *APIKeyMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *APIKeyMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, apikey.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *APIKeyMutation) EdgeCleared(name string) bool {
	switch name {
	case apikey.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *APIKeyMutation) ClearEdge(name string) error {
	switch name {
	case apikey.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown APIKey unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *APIKeyMutation) ResetEdge(name string) error {
	switch name {
	case apikey.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown APIKey edge %s", name)
}

// AlertMutation represents an operation that mutates the Alert nodes in the graph.
type AlertMutation struct {
	config
	op                       Op
	typ                      string
	id                       *string
	event_type               *string
	source_type              *string
	source_id                *string
	severity                 *alert.Severity
	title                    *string
	message                  *string
	data                     *map[string]interface{}
	device_id                *string
	acknowledged_at          *time.Time
	acknowledged_by          *string
	suppressed_count         *int
	addsuppressed_count      *int
	suppress_reason          *string
	delivery_status          *map[string]interface{}
	triggered_at             *time.Time
	updated_at               *time.Time
	clearedFields            map[string]struct{}
	rule                     *string
	clearedrule              bool
	escalations              map[string]struct{}
	removedescalations       map[string]struct{}
	clearedescalations       bool
	notification_logs        map[string]struct{}
	removednotification_logs map[string]struct{}
	clearednotification_logs bool
	done                     bool
	oldValue                 func(context.Context) (*Alert, error)
	predicates               []predicate.Alert
}

var _ ent.Mutation = (*AlertMutation)(nil)

// alertOption allows management of the mutation configuration using functional options.
type alertOption func(*AlertMutation)

// newAlertMutation creates new mutation for the Alert entity.
func newAlertMutation(c config, op Op, opts ...alertOption) *AlertMutation {
	m := &AlertMutation{
		config:        c,
		op:            op,
		typ:           TypeAlert,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAlertID sets the ID field of the mutation.
func withAlertID(id string) alertOption {
	return func(m *AlertMutation) {
		var (
			err   error
			once  sync.Once
			value *Alert
		)
		m.oldValue = func(ctx context.Context) (*Alert, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Alert.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAlert sets the old Alert of the mutation.
func withAlert(node *Alert) alertOption {
	return func(m *AlertMutation) {
		m.oldValue = func(context.Context) (*Alert, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AlertMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AlertMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Alert entities.
func (m *AlertMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AlertMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AlertMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Alert.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetRuleID sets the "rule_id" field.
func (m *AlertMutation) SetRuleID(s string) {
	m.rule = &s
}

// RuleID returns the value of the "rule_id" field in the mutation.
func (m *AlertMutation) RuleID() (r string, exists bool) {
	v := m.rule
	if v == nil {
		return
	}
	return *v, true
}

// OldRuleID returns the old "rule_id" field's value of the Alert entity.
// If the Alert object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertMutation) OldRuleID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRuleID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRuleID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRuleID: %w", err)
	}
	return oldValue.RuleID, nil
}

// ResetRuleID resets all changes to the "rule_id" field.
func (m *AlertMutation) ResetRuleID() {
	m.rule = nil
}

// SetEventType sets the "event_type" field.
func (m *AlertMutation) SetEventType(s string) {
	m.event_type = &s
}

// EventType returns the value of the "event_type" field in the mutation.
func (m *AlertMutation) EventType() (r string, exists bool) {
	v := m.event_type
	if v == nil {
		return
	}
	return *v, true
}

// OldEventType returns the old "event_type" field's value of the Alert entity.
// If the Alert object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertMutation) OldEventType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEventType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEventType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEventType: %w", err)
	}
	return oldValue.EventType, nil
}

// ResetEventType resets all changes to the "event_type" field.
func (m *AlertMutation) ResetEventType() {
	m.event_type = nil
}

// SetSourceType sets the "source_type" field.
func (m *AlertMutation) SetSourceType(s string) {
	m.source_type = &s
}

// SourceType returns the value of the "source_type" field in the mutation.
func (m *AlertMutation) SourceType() (r string, exists bool) {
	v := m.source_type
	if v == nil {
		return
	}
	return *v, true
}

// OldSourceType returns the old "source_type" field's value of the Alert entity.
// If the Alert object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertMutation) OldSourceType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSourceType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSourceType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSourceType: %w", err)
	}
	return oldValue.SourceType, nil
}

// ClearSourceType clears the value of the "source_type" field.
func (m *AlertMutation) ClearSourceType() {
	m.source_type = nil
	m.clearedFields[alert.FieldSourceType] = struct{}{}
}

// SourceTypeCleared returns if the "source_type" field was cleared in this mutation.
func (m *AlertMutation) SourceTypeCleared() bool {
	_, ok := m.clearedFields[alert.FieldSourceType]
	return ok
}

// ResetSourceType resets all changes to the "source_type" field.
func (m *AlertMutation) ResetSourceType() {
	m.source_type = nil
	delete(m.clearedFields, alert.FieldSourceType)
}

// SetSourceID sets the "source_id" field.
func (m *AlertMutation) SetSourceID(s string) {
	m.source_id = &s
}

// SourceID returns the value of the "source_id" field in the mutation.
func (m *AlertMutation) SourceID() (r string, exists bool) {
	v := m.source_id
	if v == nil {
		return
	}
	return *v, true
}

// OldSourceID returns the old "source_id" field's value of the Alert entity.
// If the Alert object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertMutation) OldSourceID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSourceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSourceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSourceID: %w", err)
	}
	return oldValue.SourceID, nil
}

// ClearSourceID clears the value of the "source_id" field.
func (m *AlertMutation) ClearSourceID() {
	m.source_id = nil
	m.clearedFields[alert.FieldSourceID] = struct{}{}
}

// SourceIDCleared returns if the "source_id" field was cleared in this mutation.
func (m *AlertMutation) SourceIDCleared() bool {
	_, ok := m.clearedFields[alert.FieldSourceID]
	return ok
}

// ResetSourceID resets all changes to the "source_id" field.
func (m *AlertMutation) ResetSourceID() {
	m.source_id = nil
	delete(m.clearedFields, alert.FieldSourceID)
}

// SetSeverity sets the "severity" field.
func (m *AlertMutation) SetSeverity(a alert.Severity) {
	m.severity = &a
}

// Severity returns the value of the "severity" field in the mutation.
func (m *AlertMutation) Severity() (r alert.Severity, exists bool) {
	v := m.severity
	if v == nil {
		return
	}
	return *v, true
}

// OldSeverity returns the old "severity" field's value of the Alert entity.
// If the Alert object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertMutation) OldSeverity(ctx context.Context) (v alert.Severity, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSeverity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSeverity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSeverity: %w", err)
	}
	return oldValue.Severity, nil
}

// ResetSeverity resets all changes to the "severity" field.
func (m *AlertMutation) ResetSeverity() {
	m.severity = nil
}

// SetTitle sets the "title" field.
func (m *AlertMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *AlertMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Alert entity.
// If the Alert object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *AlertMutation) ResetTitle() {
	m.title = nil
}

// SetMessage sets the "message" field.
func (m *AlertMutation) SetMessage(s string) {
	m.message = &s
}

// Message returns the value of the "message" field in the mutation.
func (m *AlertMutation) Message() (r string, exists bool) {
	v := m.message
	if v == nil {
		return
	}
	return *v, true
}

// OldMessage returns the old "message" field's value of the Alert entity.
// If the Alert object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertMutation) OldMessage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMessage: %w", err)
	}
	return oldValue.Message, nil
}

// ResetMessage resets all changes to the "message" field.
func (m *AlertMutation) ResetMessage() {
	m.message = nil
}

// SetData sets the "data" field.
func (m *AlertMutation) SetData(value map[string]interface{}) {
	m.data = &value
}

// Data returns the value of the "data" field in the mutation.
func (m *AlertMutation) Data() (r map[string]interface{}, exists bool) {
	v := m.data
	if v == nil {
		return
	}
	return *v, true
}

// OldData returns the old "data" field's value of the Alert entity.
// If the Alert object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertMutation) OldData(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldData is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldData requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldData: %w", err)
	}
	return oldValue.Data, nil
}

// ClearData clears the value of the "data" field.
func (m *AlertMutation) ClearData() {
	m.data = nil
	m.clearedFields[alert.FieldData] = struct{}{}
}

// DataCleared returns if the "data" field was cleared in this mutation.
func (m *AlertMutation) DataCleared() bool {
	_, ok := m.clearedFields[alert.FieldData]
	return ok
}

// ResetData resets all changes to the "data" field.
func (m *AlertMutation) ResetData() {
	m.data = nil
	delete(m.clearedFields, alert.FieldData)
}

// SetDeviceID sets the "device_id" field.
func (m *AlertMutation) SetDeviceID(s string) {
	m.device_id = &s
}

// DeviceID returns the value of the "device_id" field in the mutation.
func (m *AlertMutation) DeviceID() (r string, exists bool) {
	v := m.device_id
	if v == nil {
		return
	}
	return *v, true
}

// OldDeviceID returns the old "device_id" field's value of the Alert entity.
// If the Alert object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertMutation) OldDeviceID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeviceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeviceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeviceID: %w", err)
	}
	return oldValue.DeviceID, nil
}

// ClearDeviceID clears the value of the "device_id" field.
func (m *AlertMutation) ClearDeviceID() {
	m.device_id = nil
	m.clearedFields[alert.FieldDeviceID] = struct{}{}
}

// DeviceIDCleared returns if the "device_id" field was cleared in this mutation.
func (m *AlertMutation) DeviceIDCleared() bool {
	_, ok := m.clearedFields[alert.FieldDeviceID]
	return ok
}

// ResetDeviceID resets all changes to the "device_id" field.
func (m *AlertMutation) ResetDeviceID() {
	m.device_id = nil
	delete(m.clearedFields, alert.FieldDeviceID)
}

// SetAcknowledgedAt sets the "acknowledged_at" field.
func (m *AlertMutation) SetAcknowledgedAt(t time.Time) {
	m.acknowledged_at = &t
}

// AcknowledgedAt returns the value of the "acknowledged_at" field in the mutation.
func (m *AlertMutation) AcknowledgedAt() (r time.Time, exists bool) {
	v := m.acknowledged_at
	if v == nil {
		return
	}
	return *v, true
}

// OldAcknowledgedAt returns the old "acknowledged_at" field's value of the Alert entity.
// If the Alert object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertMutation) OldAcknowledgedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAcknowledgedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAcknowledgedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAcknowledgedAt: %w", err)
	}
	return oldValue.AcknowledgedAt, nil
}

// ClearAcknowledgedAt clears the value of the "acknowledged_at" field.
func (m *AlertMutation) ClearAcknowledgedAt() {
	m.acknowledged_at = nil
	m.clearedFields[alert.FieldAcknowledgedAt] = struct{}{}
}

// AcknowledgedAtCleared returns if the "acknowledged_at" field was cleared in this mutation.
func (m *AlertMutation) AcknowledgedAtCleared() bool {
	_, ok := m.clearedFields[alert.FieldAcknowledgedAt]
	return ok
}

// ResetAcknowledgedAt resets all changes to the "acknowledged_at" field.
func (m *AlertMutation) ResetAcknowledgedAt() {
	m.acknowledged_at = nil
	delete(m.clearedFields, alert.FieldAcknowledgedAt)
}

// SetAcknowledgedBy sets the "acknowledged_by" field.
func (m *AlertMutation) SetAcknowledgedBy(s string) {
	m.acknowledged_by = &s
}

// AcknowledgedBy returns the value of the "acknowledged_by" field in the mutation.
func (m *AlertMutation) AcknowledgedBy() (r string, exists bool) {
	v := m.acknowledged_by
	if v == nil {
		return
	}
	return *v, true
}

// OldAcknowledgedBy returns the old "acknowledged_by" field's value of the Alert entity.
// If the Alert object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertMutation) OldAcknowledgedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAcknowledgedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAcknowledgedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAcknowledgedBy: %w", err)
	}
	return oldValue.AcknowledgedBy, nil
}

// ClearAcknowledgedBy clears the value of the "acknowledged_by" field.
func (m *AlertMutation) ClearAcknowledgedBy() {
	m.acknowledged_by = nil
	m.clearedFields[alert.FieldAcknowledgedBy] = struct{}{}
}

// AcknowledgedByCleared returns if the "acknowledged_by" field was cleared in this mutation.
func (m *AlertMutation) AcknowledgedByCleared() bool {
	_, ok := m.clearedFields[alert.FieldAcknowledgedBy]
	return ok
}

// ResetAcknowledgedBy resets all changes to the "acknowledged_by" field.
func (m *AlertMutation) ResetAcknowledgedBy() {
	m.acknowledged_by = nil
	delete(m.clearedFields, alert.FieldAcknowledgedBy)
}

// SetSuppressedCount sets the "suppressed_count" field.
func (m *AlertMutation) SetSuppressedCount(i int) {
	m.suppressed_count = &i
	m.addsuppressed_count = nil
}

// SuppressedCount returns the value of the "suppressed_count" field in the mutation.
func (m *AlertMutation) SuppressedCount() (r int, exists bool) {
	v := m.suppressed_count
	if v == nil {
		return
	}
	return *v, true
}

// OldSuppressedCount returns the old "suppressed_count" field's value of the Alert entity.
// If the Alert object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertMutation) OldSuppressedCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSuppressedCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSuppressedCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSuppressedCount: %w", err)
	}
	return oldValue.SuppressedCount, nil
}

// AddSuppressedCount adds i to the "suppressed_count" field.
func (m *AlertMutation) AddSuppressedCount(i int) {
	if m.addsuppressed_count != nil {
		*m.addsuppressed_count += i
	} else {
		m.addsuppressed_count = &i
	}
}

// AddedSuppressedCount returns the value that was added to the "suppressed_count" field in this mutation.
func (m *AlertMutation) AddedSuppressedCount() (r int, exists bool) {
	v := m.addsuppressed_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetSuppressedCount resets all changes to the "suppressed_count" field.
func (m *AlertMutation) ResetSuppressedCount() {
	m.suppressed_count = nil
	m.addsuppressed_count = nil
}

// SetSuppressReason sets the "suppress_reason" field.
func (m *AlertMutation) SetSuppressReason(s string) {
	m.suppress_reason = &s
}

// SuppressReason returns the value of the "suppress_reason" field in the mutation.
func (m *AlertMutation) SuppressReason() (r string, exists bool) {
	v := m.suppress_reason
	if v == nil {
		return
	}
	return *v, true
}

// OldSuppressReason returns the old "suppress_reason" field's value of the Alert entity.
// If the Alert object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertMutation) OldSuppressReason(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSuppressReason is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSuppressReason requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSuppressReason: %w", err)
	}
	return oldValue.SuppressReason, nil
}

// ClearSuppressReason clears the value of the "suppress_reason" field.
func (m *AlertMutation) ClearSuppressReason() {
	m.suppress_reason = nil
	m.clearedFields[alert.FieldSuppressReason] = struct{}{}
}

// SuppressReasonCleared returns if the "suppress_reason" field was cleared in this mutation.
func (m *AlertMutation) SuppressReasonCleared() bool {
	_, ok := m.clearedFields[alert.FieldSuppressReason]
	return ok
}

// ResetSuppressReason resets all changes to the "suppress_reason" field.
func (m *AlertMutation) ResetSuppressReason() {
	m.suppress_reason = nil
	delete(m.clearedFields, alert.FieldSuppressReason)
}

// SetDeliveryStatus sets the "delivery_status" field.
func (m *AlertMutation) SetDeliveryStatus(value map[string]interface{}) {
	m.delivery_status = &value
}

// DeliveryStatus returns the value of the "delivery_status" field in the mutation.
func (m *AlertMutation) DeliveryStatus() (r map[string]interface{}, exists bool) {
	v := m.delivery_status
	if v == nil {
		return
	}
	return *v, true
}

// OldDeliveryStatus returns the old "delivery_status" field's value of the Alert entity.
// If the Alert object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertMutation) OldDeliveryStatus(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeliveryStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeliveryStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeliveryStatus: %w", err)
	}
	return oldValue.DeliveryStatus, nil
}

// ClearDeliveryStatus clears the value of the "delivery_status" field.
func (m *AlertMutation) ClearDeliveryStatus() {
	m.delivery_status = nil
	m.clearedFields[alert.FieldDeliveryStatus] = struct{}{}
}

// DeliveryStatusCleared returns if the "delivery_status" field was cleared in this mutation.
func (m *AlertMutation) DeliveryStatusCleared() bool {
	_, ok := m.clearedFields[alert.FieldDeliveryStatus]
	return ok
}

// ResetDeliveryStatus resets all changes to the "delivery_status" field.
func (m *AlertMutation) ResetDeliveryStatus() {
	m.delivery_status = nil
	delete(m.clearedFields, alert.FieldDeliveryStatus)
}

// SetTriggeredAt sets the "triggered_at" field.
func (m *AlertMutation) SetTriggeredAt(t time.Time) {
	m.triggered_at = &t
}

// TriggeredAt returns the value of the "triggered_at" field in the mutation.
func (m *AlertMutation) TriggeredAt() (r time.Time, exists bool) {
	v := m.triggered_at
	if v == nil {
		return
	}
	return *v, true
}

// OldTriggeredAt returns the old "triggered_at" field's value of the Alert entity.
// If the Alert object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertMutation) OldTriggeredAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTriggeredAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTriggeredAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTriggeredAt: %w", err)
	}
	return oldValue.TriggeredAt, nil
}

// ResetTriggeredAt resets all changes to the "triggered_at" field.
func (m *AlertMutation) ResetTriggeredAt() {
	m.triggered_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AlertMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AlertMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Alert entity.
// If the Alert object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AlertMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearRule clears the "rule" edge to the AlertRule entity.
func (m *AlertMutation) ClearRule() {
	m.clearedrule = true
	m.clearedFields[alert.FieldRuleID] = struct{}{}
}

// RuleCleared reports if the "rule" edge to the AlertRule entity was cleared.
func (m *AlertMutation) RuleCleared() bool {
	return m.clearedrule
}

// RuleIDs returns the "rule" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RuleID instead. It exists only for internal usage by the builders.
func (m *AlertMutation) RuleIDs() (ids []string) {
	if id := m.rule; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRule resets all changes to the "rule" edge.
func (m *AlertMutation) ResetRule() {
	m.rule = nil
	m.clearedrule = false
}

// AddEscalationIDs adds the "escalations" edge to the AlertEscalation entity by ids.
func (m *AlertMutation) AddEscalationIDs(ids ...string) {
	if m.escalations == nil {
		m.escalations = make(map[string]struct{})
	}
	for i := range ids {
		m.escalations[ids[i]] = struct{}{}
	}
}

// ClearEscalations clears the "escalations" edge to the AlertEscalation entity.
func (m *AlertMutation) ClearEscalations() {
	m.clearedescalations = true
}

// EscalationsCleared reports if the "escalations" edge to the AlertEscalation entity was cleared.
func (m *AlertMutation) EscalationsCleared() bool {
	return m.clearedescalations
}

// RemoveEscalationIDs removes the "escalations" edge to the AlertEscalation entity by IDs.
func (m *AlertMutation) RemoveEscalationIDs(ids ...string) {
	if m.removedescalations == nil {
		m.removedescalations = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.escalations, ids[i])
		m.removedescalations[ids[i]] = struct{}{}
	}
}

// RemovedEscalations returns the removed IDs of the "escalations" edge to the AlertEscalation entity.
func (m *AlertMutation) RemovedEscalationsIDs() (ids []string) {
	for id := range m.removedescalations {
		ids = append(ids, id)
	}
	return
}

// EscalationsIDs returns the "escalations" edge IDs in the mutation.
func (m *AlertMutation) EscalationsIDs() (ids []string) {
	for id := range m.escalations {
		ids = append(ids, id)
	}
	return
}

// ResetEscalations resets all changes to the "escalations" edge.
func (m *AlertMutation) ResetEscalations() {
	m.escalations = nil
	m.clearedescalations = false
	m.removedescalations = nil
}

// AddNotificationLogIDs adds the "notification_logs" edge to the NotificationLog entity by ids.
func (m *AlertMutation) AddNotificationLogIDs(ids ...string) {
	if m.notification_logs == nil {
		m.notification_logs = make(map[string]struct{})
	}
	for i := range ids {
		m.notification_logs[ids[i]] = struct{}{}
	}
}

// ClearNotificationLogs clears the "notification_logs" edge to the NotificationLog entity.
func (m *AlertMutation) ClearNotificationLogs() {
	m.clearednotification_logs = true
}

// NotificationLogsCleared reports if the "notification_logs" edge to the NotificationLog entity was cleared.
func (m *AlertMutation) NotificationLogsCleared() bool {
	return m.clearednotification_logs
}

// RemoveNotificationLogIDs removes the "notification_logs" edge to the NotificationLog entity by IDs.
func (m *AlertMutation) RemoveNotificationLogIDs(ids ...string) {
	if m.removednotification_logs == nil {
		m.removednotification_logs = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.notification_logs, ids[i])
		m.removednotification_logs[ids[i]] = struct{}{}
	}
}

// RemovedNotificationLogs returns the removed IDs of the "notification_logs" edge to the NotificationLog entity.
func (m *AlertMutation) RemovedNotificationLogsIDs() (ids []string) {
	for id := range m.removednotification_logs {
		ids = append(ids, id)
	}
	return
}

// NotificationLogsIDs returns the "notification_logs" edge IDs in the mutation.
func (m *AlertMutation) NotificationLogsIDs() (ids []string) {
	for id := range m.notification_logs {
		ids = append(ids, id)
	}
	return
}

// ResetNotificationLogs resets all changes to the "notification_logs" edge.
func (m *AlertMutation) ResetNotificationLogs() {
	m.notification_logs = nil
	m.clearednotification_logs = false
	m.removednotification_logs = nil
}

// Where appends a list predicates to the AlertMutation builder.
func (m *AlertMutation) Where(ps ...predicate.Alert) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AlertMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AlertMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Alert, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AlertMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AlertMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Alert).
func (m *AlertMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AlertMutation) Fields() []string {
	fields := make([]string, 0, 16)
	if m.rule != nil {
		fields = append(fields, alert.FieldRuleID)
	}
	if m.event_type != nil {
		fields = append(fields, alert.FieldEventType)
	}
	if m.source_type != nil {
		fields = append(fields, alert.FieldSourceType)
	}
	if m.source_id != nil {
		fields = append(fields, alert.FieldSourceID)
	}
	if m.severity != nil {
		fields = append(fields, alert.FieldSeverity)
	}
	if m.title != nil {
		fields = append(fields, alert.FieldTitle)
	}
	if m.message != nil {
		fields = append(fields, alert.FieldMessage)
	}
	if m.data != nil {
		fields = append(fields, alert.FieldData)
	}
	if m.device_id != nil {
		fields = append(fields, alert.FieldDeviceID)
	}
	if m.acknowledged_at != nil {
		fields = append(fields, alert.FieldAcknowledgedAt)
	}
	if m.acknowledged_by != nil {
		fields = append(fields, alert.FieldAcknowledgedBy)
	}
	if m.suppressed_count != nil {
		fields = append(fields, alert.FieldSuppressedCount)
	}
	if m.suppress_reason != nil {
		fields = append(fields, alert.FieldSuppressReason)
	}
	if m.delivery_status != nil {
		fields = append(fields, alert.FieldDeliveryStatus)
	}
	if m.triggered_at != nil {
		fields = append(fields, alert.FieldTriggeredAt)
	}
	if m.updated_at != nil {
		fields = append(fields, alert.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AlertMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case alert.FieldRuleID:
		return m.RuleID()
	case alert.FieldEventType:
		return m.EventType()
	case alert.FieldSourceType:
		return m.SourceType()
	case alert.FieldSourceID:
		return m.SourceID()
	case alert.FieldSeverity:
		return m.Severity()
	case alert.FieldTitle:
		return m.Title()
	case alert.FieldMessage:
		return m.Message()
	case alert.FieldData:
		return m.Data()
	case alert.FieldDeviceID:
		return m.DeviceID()
	case alert.FieldAcknowledgedAt:
		return m.AcknowledgedAt()
	case alert.FieldAcknowledgedBy:
		return m.AcknowledgedBy()
	case alert.FieldSuppressedCount:
		return m.SuppressedCount()
	case alert.FieldSuppressReason:
		return m.SuppressReason()
	case alert.FieldDeliveryStatus:
		return m.DeliveryStatus()
	case alert.FieldTriggeredAt:
		return m.TriggeredAt()
	case alert.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AlertMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case alert.FieldRuleID:
		return m.OldRuleID(ctx)
	case alert.FieldEventType:
		return m.OldEventType(ctx)
	case alert.FieldSourceType:
		return m.OldSourceType(ctx)
	case alert.FieldSourceID:
		return m.OldSourceID(ctx)
	case alert.FieldSeverity:
		return m.OldSeverity(ctx)
	case alert.FieldTitle:
		return m.OldTitle(ctx)
	case alert.FieldMessage:
		return m.OldMessage(ctx)
	case alert.FieldData:
		return m.OldData(ctx)
	case alert.FieldDeviceID:
		return m.OldDeviceID(ctx)
	case alert.FieldAcknowledgedAt:
		return m.OldAcknowledgedAt(ctx)
	case alert.FieldAcknowledgedBy:
		return m.OldAcknowledgedBy(ctx)
	case alert.FieldSuppressedCount:
		return m.OldSuppressedCount(ctx)
	case alert.FieldSuppressReason:
		return m.OldSuppressReason(ctx)
	case alert.FieldDeliveryStatus:
		return m.OldDeliveryStatus(ctx)
	case alert.FieldTriggeredAt:
		return m.OldTriggeredAt(ctx)
	case alert.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Alert field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AlertMutation) SetField(name string, value ent.Value) error {
	switch name {
	case alert.FieldRuleID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRuleID(v)
		return nil
	case alert.FieldEventType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEventType(v)
		return nil
	case alert.FieldSourceType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSourceType(v)
		return nil
	case alert.FieldSourceID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSourceID(v)
		return nil
	case alert.FieldSeverity:
		v, ok := value.(alert.Severity)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSeverity(v)
		return nil
	case alert.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case alert.FieldMessage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMessage(v)
		return nil
	case alert.FieldData:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetData(v)
		return nil
	case alert.FieldDeviceID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeviceID(v)
		return nil
	case alert.FieldAcknowledgedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAcknowledgedAt(v)
		return nil
	case alert.FieldAcknowledgedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAcknowledgedBy(v)
		return nil
	case alert.FieldSuppressedCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSuppressedCount(v)
		return nil
	case alert.FieldSuppressReason:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSuppressReason(v)
		return nil
	case alert.FieldDeliveryStatus:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeliveryStatus(v)
		return nil
	case alert.FieldTriggeredAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTriggeredAt(v)
		return nil
	case alert.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Alert field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AlertMutation) AddedFields() []string {
	var fields []string
	if m.addsuppressed_count != nil {
		fields = append(fields, alert.FieldSuppressedCount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AlertMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case alert.FieldSuppressedCount:
		return m.AddedSuppressedCount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AlertMutation) AddField(name string, value ent.Value) error {
	switch name {
	case alert.FieldSuppressedCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSuppressedCount(v)
		return nil
	}
	return fmt.Errorf("unknown Alert numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AlertMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(alert.FieldSourceType) {
		fields = append(fields, alert.FieldSourceType)
	}
	if m.FieldCleared(alert.FieldSourceID) {
		fields = append(fields, alert.FieldSourceID)
	}
	if m.FieldCleared(alert.FieldData) {
		fields = append(fields, alert.FieldData)
	}
	if m.FieldCleared(alert.FieldDeviceID) {
		fields = append(fields, alert.FieldDeviceID)
	}
	if m.FieldCleared(alert.FieldAcknowledgedAt) {
		fields = append(fields, alert.FieldAcknowledgedAt)
	}
	if m.FieldCleared(alert.FieldAcknowledgedBy) {
		fields = append(fields, alert.FieldAcknowledgedBy)
	}
	if m.FieldCleared(alert.FieldSuppressReason) {
		fields = append(fields, alert.FieldSuppressReason)
	}
	if m.FieldCleared(alert.FieldDeliveryStatus) {
		fields = append(fields, alert.FieldDeliveryStatus)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AlertMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AlertMutation) ClearField(name string) error {
	switch name {
	case alert.FieldSourceType:
		m.ClearSourceType()
		return nil
	case alert.FieldSourceID:
		m.ClearSourceID()
		return nil
	case alert.FieldData:
		m.ClearData()
		return nil
	case alert.FieldDeviceID:
		m.ClearDeviceID()
		return nil
	case alert.FieldAcknowledgedAt:
		m.ClearAcknowledgedAt()
		return nil
	case alert.FieldAcknowledgedBy:
		m.ClearAcknowledgedBy()
		return nil
	case alert.FieldSuppressReason:
		m.ClearSuppressReason()
		return nil
	case alert.FieldDeliveryStatus:
		m.ClearDeliveryStatus()
		return nil
	}
	return fmt.Errorf("unknown Alert nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AlertMutation) ResetField(name string) error {
	switch name {
	case alert.FieldRuleID:
		m.ResetRuleID()
		return nil
	case alert.FieldEventType:
		m.ResetEventType()
		return nil
	case alert.FieldSourceType:
		m.ResetSourceType()
		return nil
	case alert.FieldSourceID:
		m.ResetSourceID()
		return nil
	case alert.FieldSeverity:
		m.ResetSeverity()
		return nil
	case alert.FieldTitle:
		m.ResetTitle()
		return nil
	case alert.FieldMessage:
		m.ResetMessage()
		return nil
	case alert.FieldData:
		m.ResetData()
		return nil
	case alert.FieldDeviceID:
		m.ResetDeviceID()
		return nil
	case alert.FieldAcknowledgedAt:
		m.ResetAcknowledgedAt()
		return nil
	case alert.FieldAcknowledgedBy:
		m.ResetAcknowledgedBy()
		return nil
	case alert.FieldSuppressedCount:
		m.ResetSuppressedCount()
		return nil
	case alert.FieldSuppressReason:
		m.ResetSuppressReason()
		return nil
	case alert.FieldDeliveryStatus:
		m.ResetDeliveryStatus()
		return nil
	case alert.FieldTriggeredAt:
		m.ResetTriggeredAt()
		return nil
	case alert.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Alert field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AlertMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.rule != nil {
		edges = append(edges, alert.EdgeRule)
	}
	if m.escalations != nil {
		edges = append(edges, alert.EdgeEscalations)
	}
	if m.notification_logs != nil {
		edges = append(edges, alert.EdgeNotificationLogs)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AlertMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case alert.EdgeRule:
		if id := m.rule; id != nil {
			return []ent.Value{*id}
		}
	case alert.EdgeEscalations:
		ids := make([]ent.Value, 0, len(m.escalations))
		for id := range m.escalations {
			ids = append(ids, id)
		}
		return ids
	case alert.EdgeNotificationLogs:
		ids := make([]ent.Value, 0, len(m.notification_logs))
		for id := range m.notification_logs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AlertMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedescalations != nil {
		edges = append(edges, alert.EdgeEscalations)
	}
	if m.removednotification_logs != nil {
		edges = append(edges, alert.EdgeNotificationLogs)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AlertMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case alert.EdgeEscalations:
		ids := make([]ent.Value, 0, len(m.removedescalations))
		for id := range m.removedescalations {
			ids = append(ids, id)
		}
		return ids
	case alert.EdgeNotificationLogs:
		ids := make([]ent.Value, 0, len(m.removednotification_logs))
		for id := range m.removednotification_logs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AlertMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedrule {
		edges = append(edges, alert.EdgeRule)
	}
	if m.clearedescalations {
		edges = append(edges, alert.EdgeEscalations)
	}
	if m.clearednotification_logs {
		edges = append(edges, alert.EdgeNotificationLogs)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AlertMutation) EdgeCleared(name string) bool {
	switch name {
	case alert.EdgeRule:
		return m.clearedrule
	case alert.EdgeEscalations:
		return m.clearedescalations
	case alert.EdgeNotificationLogs:
		return m.clearednotification_logs
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AlertMutation) ClearEdge(name string) error {
	switch name {
	case alert.EdgeRule:
		m.ClearRule()
		return nil
	}
	return fmt.Errorf("unknown Alert unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AlertMutation) ResetEdge(name string) error {
	switch name {
	case alert.EdgeRule:
		m.ResetRule()
		return nil
	case alert.EdgeEscalations:
		m.ResetEscalations()
		return nil
	case alert.EdgeNotificationLogs:
		m.ResetNotificationLogs()
		return nil
	}
	return fmt.Errorf("unknown Alert edge %s", name)
}

// AlertDigestEntryMutation represents an operation that mutates the AlertDigestEntry nodes in the graph.
type AlertDigestEntryMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	alert_id      *string
	rule_id       *string
	channel_id    *string
	channel_type  *string
	severity      *alertdigestentry.Severity
	event_type    *string
	title         *string
	message       *string
	data          *map[string]interface{}
	queued_at     *time.Time
	delivered_at  *time.Time
	digest_id     *string
	bypass_sent   *bool
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*AlertDigestEntry, error)
	predicates    []predicate.AlertDigestEntry
}

var _ ent.Mutation = (*AlertDigestEntryMutation)(nil)

// alertdigestentryOption allows management of the mutation configuration using functional options.
type alertdigestentryOption func(*AlertDigestEntryMutation)

// newAlertDigestEntryMutation creates new mutation for the AlertDigestEntry entity.
func newAlertDigestEntryMutation(c config, op Op, opts ...alertdigestentryOption) *AlertDigestEntryMutation {
	m := &AlertDigestEntryMutation{
		config:        c,
		op:            op,
		typ:           TypeAlertDigestEntry,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAlertDigestEntryID sets the ID field of the mutation.
func withAlertDigestEntryID(id uuid.UUID) alertdigestentryOption {
	return func(m *AlertDigestEntryMutation) {
		var (
			err   error
			once  sync.Once
			value *AlertDigestEntry
		)
		m.oldValue = func(ctx context.Context) (*AlertDigestEntry, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AlertDigestEntry.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAlertDigestEntry sets the old AlertDigestEntry of the mutation.
func withAlertDigestEntry(node *AlertDigestEntry) alertdigestentryOption {
	return func(m *AlertDigestEntryMutation) {
		m.oldValue = func(context.Context) (*AlertDigestEntry, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AlertDigestEntryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AlertDigestEntryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AlertDigestEntry entities.
func (m *AlertDigestEntryMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AlertDigestEntryMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AlertDigestEntryMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AlertDigestEntry.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetAlertID sets the "alert_id" field.
func (m *AlertDigestEntryMutation) SetAlertID(s string) {
	m.alert_id = &s
}

// AlertID returns the value of the "alert_id" field in the mutation.
func (m *AlertDigestEntryMutation) AlertID() (r string, exists bool) {
	v := m.alert_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAlertID returns the old "alert_id" field's value of the AlertDigestEntry entity.
// If the AlertDigestEntry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertDigestEntryMutation) OldAlertID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAlertID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAlertID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAlertID: %w", err)
	}
	return oldValue.AlertID, nil
}

// ClearAlertID clears the value of the "alert_id" field.
func (m *AlertDigestEntryMutation) ClearAlertID() {
	m.alert_id = nil
	m.clearedFields[alertdigestentry.FieldAlertID] = struct{}{}
}

// AlertIDCleared returns if the "alert_id" field was cleared in this mutation.
func (m *AlertDigestEntryMutation) AlertIDCleared() bool {
	_, ok := m.clearedFields[alertdigestentry.FieldAlertID]
	return ok
}

// ResetAlertID resets all changes to the "alert_id" field.
func (m *AlertDigestEntryMutation) ResetAlertID() {
	m.alert_id = nil
	delete(m.clearedFields, alertdigestentry.FieldAlertID)
}

// SetRuleID sets the "rule_id" field.
func (m *AlertDigestEntryMutation) SetRuleID(s string) {
	m.rule_id = &s
}

// RuleID returns the value of the "rule_id" field in the mutation.
func (m *AlertDigestEntryMutation) RuleID() (r string, exists bool) {
	v := m.rule_id
	if v == nil {
		return
	}
	return *v, true
}

// OldRuleID returns the old "rule_id" field's value of the AlertDigestEntry entity.
// If the AlertDigestEntry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertDigestEntryMutation) OldRuleID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRuleID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRuleID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRuleID: %w", err)
	}
	return oldValue.RuleID, nil
}

// ResetRuleID resets all changes to the "rule_id" field.
func (m *AlertDigestEntryMutation) ResetRuleID() {
	m.rule_id = nil
}

// SetChannelID sets the "channel_id" field.
func (m *AlertDigestEntryMutation) SetChannelID(s string) {
	m.channel_id = &s
}

// ChannelID returns the value of the "channel_id" field in the mutation.
func (m *AlertDigestEntryMutation) ChannelID() (r string, exists bool) {
	v := m.channel_id
	if v == nil {
		return
	}
	return *v, true
}

// OldChannelID returns the old "channel_id" field's value of the AlertDigestEntry entity.
// If the AlertDigestEntry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertDigestEntryMutation) OldChannelID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChannelID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChannelID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChannelID: %w", err)
	}
	return oldValue.ChannelID, nil
}

// ResetChannelID resets all changes to the "channel_id" field.
func (m *AlertDigestEntryMutation) ResetChannelID() {
	m.channel_id = nil
}

// SetChannelType sets the "channel_type" field.
func (m *AlertDigestEntryMutation) SetChannelType(s string) {
	m.channel_type = &s
}

// ChannelType returns the value of the "channel_type" field in the mutation.
func (m *AlertDigestEntryMutation) ChannelType() (r string, exists bool) {
	v := m.channel_type
	if v == nil {
		return
	}
	return *v, true
}

// OldChannelType returns the old "channel_type" field's value of the AlertDigestEntry entity.
// If the AlertDigestEntry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertDigestEntryMutation) OldChannelType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChannelType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChannelType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChannelType: %w", err)
	}
	return oldValue.ChannelType, nil
}

// ResetChannelType resets all changes to the "channel_type" field.
func (m *AlertDigestEntryMutation) ResetChannelType() {
	m.channel_type = nil
}

// SetSeverity sets the "severity" field.
func (m *AlertDigestEntryMutation) SetSeverity(a alertdigestentry.Severity) {
	m.severity = &a
}

// Severity returns the value of the "severity" field in the mutation.
func (m *AlertDigestEntryMutation) Severity() (r alertdigestentry.Severity, exists bool) {
	v := m.severity
	if v == nil {
		return
	}
	return *v, true
}

// OldSeverity returns the old "severity" field's value of the AlertDigestEntry entity.
// If the AlertDigestEntry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertDigestEntryMutation) OldSeverity(ctx context.Context) (v alertdigestentry.Severity, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSeverity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSeverity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSeverity: %w", err)
	}
	return oldValue.Severity, nil
}

// ResetSeverity resets all changes to the "severity" field.
func (m *AlertDigestEntryMutation) ResetSeverity() {
	m.severity = nil
}

// SetEventType sets the "event_type" field.
func (m *AlertDigestEntryMutation) SetEventType(s string) {
	m.event_type = &s
}

// EventType returns the value of the "event_type" field in the mutation.
func (m *AlertDigestEntryMutation) EventType() (r string, exists bool) {
	v := m.event_type
	if v == nil {
		return
	}
	return *v, true
}

// OldEventType returns the old "event_type" field's value of the AlertDigestEntry entity.
// If the AlertDigestEntry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertDigestEntryMutation) OldEventType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEventType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEventType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEventType: %w", err)
	}
	return oldValue.EventType, nil
}

// ResetEventType resets all changes to the "event_type" field.
func (m *AlertDigestEntryMutation) ResetEventType() {
	m.event_type = nil
}

// SetTitle sets the "title" field.
func (m *AlertDigestEntryMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *AlertDigestEntryMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the AlertDigestEntry entity.
// If the AlertDigestEntry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertDigestEntryMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *AlertDigestEntryMutation) ResetTitle() {
	m.title = nil
}

// SetMessage sets the "message" field.
func (m *AlertDigestEntryMutation) SetMessage(s string) {
	m.message = &s
}

// Message returns the value of the "message" field in the mutation.
func (m *AlertDigestEntryMutation) Message() (r string, exists bool) {
	v := m.message
	if v == nil {
		return
	}
	return *v, true
}

// OldMessage returns the old "message" field's value of the AlertDigestEntry entity.
// If the AlertDigestEntry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertDigestEntryMutation) OldMessage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMessage: %w", err)
	}
	return oldValue.Message, nil
}

// ResetMessage resets all changes to the "message" field.
func (m *AlertDigestEntryMutation) ResetMessage() {
	m.message = nil
}

// SetData sets the "data" field.
func (m *AlertDigestEntryMutation) SetData(value map[string]interface{}) {
	m.data = &value
}

// Data returns the value of the "data" field in the mutation.
func (m *AlertDigestEntryMutation) Data() (r map[string]interface{}, exists bool) {
	v := m.data
	if v == nil {
		return
	}
	return *v, true
}

// OldData returns the old "data" field's value of the AlertDigestEntry entity.
// If the AlertDigestEntry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertDigestEntryMutation) OldData(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldData is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldData requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldData: %w", err)
	}
	return oldValue.Data, nil
}

// ClearData clears the value of the "data" field.
func (m *AlertDigestEntryMutation) ClearData() {
	m.data = nil
	m.clearedFields[alertdigestentry.FieldData] = struct{}{}
}

// DataCleared returns if the "data" field was cleared in this mutation.
func (m *AlertDigestEntryMutation) DataCleared() bool {
	_, ok := m.clearedFields[alertdigestentry.FieldData]
	return ok
}

// ResetData resets all changes to the "data" field.
func (m *AlertDigestEntryMutation) ResetData() {
	m.data = nil
	delete(m.clearedFields, alertdigestentry.FieldData)
}

// SetQueuedAt sets the "queued_at" field.
func (m *AlertDigestEntryMutation) SetQueuedAt(t time.Time) {
	m.queued_at = &t
}

// QueuedAt returns the value of the "queued_at" field in the mutation.
func (m *AlertDigestEntryMutation) QueuedAt() (r time.Time, exists bool) {
	v := m.queued_at
	if v == nil {
		return
	}
	return *v, true
}

// OldQueuedAt returns the old "queued_at" field's value of the AlertDigestEntry entity.
// If the AlertDigestEntry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertDigestEntryMutation) OldQueuedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQueuedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQueuedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQueuedAt: %w", err)
	}
	return oldValue.QueuedAt, nil
}

// ResetQueuedAt resets all changes to the "queued_at" field.
func (m *AlertDigestEntryMutation) ResetQueuedAt() {
	m.queued_at = nil
}

// SetDeliveredAt sets the "delivered_at" field.
func (m *AlertDigestEntryMutation) SetDeliveredAt(t time.Time) {
	m.delivered_at = &t
}

// DeliveredAt returns the value of the "delivered_at" field in the mutation.
func (m *AlertDigestEntryMutation) DeliveredAt() (r time.Time, exists bool) {
	v := m.delivered_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeliveredAt returns the old "delivered_at" field's value of the AlertDigestEntry entity.
// If the AlertDigestEntry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertDigestEntryMutation) OldDeliveredAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeliveredAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeliveredAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeliveredAt: %w", err)
	}
	return oldValue.DeliveredAt, nil
}

// ClearDeliveredAt clears the value of the "delivered_at" field.
func (m *AlertDigestEntryMutation) ClearDeliveredAt() {
	m.delivered_at = nil
	m.clearedFields[alertdigestentry.FieldDeliveredAt] = struct{}{}
}

// DeliveredAtCleared returns if the "delivered_at" field was cleared in this mutation.
func (m *AlertDigestEntryMutation) DeliveredAtCleared() bool {
	_, ok := m.clearedFields[alertdigestentry.FieldDeliveredAt]
	return ok
}

// ResetDeliveredAt resets all changes to the "delivered_at" field.
func (m *AlertDigestEntryMutation) ResetDeliveredAt() {
	m.delivered_at = nil
	delete(m.clearedFields, alertdigestentry.FieldDeliveredAt)
}

// SetDigestID sets the "digest_id" field.
func (m *AlertDigestEntryMutation) SetDigestID(s string) {
	m.digest_id = &s
}

// DigestID returns the value of the "digest_id" field in the mutation.
func (m *AlertDigestEntryMutation) DigestID() (r string, exists bool) {
	v := m.digest_id
	if v == nil {
		return
	}
	return *v, true
}

// OldDigestID returns the old "digest_id" field's value of the AlertDigestEntry entity.
// If the AlertDigestEntry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertDigestEntryMutation) OldDigestID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDigestID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDigestID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDigestID: %w", err)
	}
	return oldValue.DigestID, nil
}

// ClearDigestID clears the value of the "digest_id" field.
func (m *AlertDigestEntryMutation) ClearDigestID() {
	m.digest_id = nil
	m.clearedFields[alertdigestentry.FieldDigestID] = struct{}{}
}

// DigestIDCleared returns if the "digest_id" field was cleared in this mutation.
func (m *AlertDigestEntryMutation) DigestIDCleared() bool {
	_, ok := m.clearedFields[alertdigestentry.FieldDigestID]
	return ok
}

// ResetDigestID resets all changes to the "digest_id" field.
func (m *AlertDigestEntryMutation) ResetDigestID() {
	m.digest_id = nil
	delete(m.clearedFields, alertdigestentry.FieldDigestID)
}

// SetBypassSent sets the "bypass_sent" field.
func (m *AlertDigestEntryMutation) SetBypassSent(b bool) {
	m.bypass_sent = &b
}

// BypassSent returns the value of the "bypass_sent" field in the mutation.
func (m *AlertDigestEntryMutation) BypassSent() (r bool, exists bool) {
	v := m.bypass_sent
	if v == nil {
		return
	}
	return *v, true
}

// OldBypassSent returns the old "bypass_sent" field's value of the AlertDigestEntry entity.
// If the AlertDigestEntry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertDigestEntryMutation) OldBypassSent(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBypassSent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBypassSent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBypassSent: %w", err)
	}
	return oldValue.BypassSent, nil
}

// ResetBypassSent resets all changes to the "bypass_sent" field.
func (m *AlertDigestEntryMutation) ResetBypassSent() {
	m.bypass_sent = nil
}

// Where appends a list predicates to the AlertDigestEntryMutation builder.
func (m *AlertDigestEntryMutation) Where(ps ...predicate.AlertDigestEntry) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AlertDigestEntryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AlertDigestEntryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AlertDigestEntry, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AlertDigestEntryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AlertDigestEntryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AlertDigestEntry).
func (m *AlertDigestEntryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AlertDigestEntryMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.alert_id != nil {
		fields = append(fields, alertdigestentry.FieldAlertID)
	}
	if m.rule_id != nil {
		fields = append(fields, alertdigestentry.FieldRuleID)
	}
	if m.channel_id != nil {
		fields = append(fields, alertdigestentry.FieldChannelID)
	}
	if m.channel_type != nil {
		fields = append(fields, alertdigestentry.FieldChannelType)
	}
	if m.severity != nil {
		fields = append(fields, alertdigestentry.FieldSeverity)
	}
	if m.event_type != nil {
		fields = append(fields, alertdigestentry.FieldEventType)
	}
	if m.title != nil {
		fields = append(fields, alertdigestentry.FieldTitle)
	}
	if m.message != nil {
		fields = append(fields, alertdigestentry.FieldMessage)
	}
	if m.data != nil {
		fields = append(fields, alertdigestentry.FieldData)
	}
	if m.queued_at != nil {
		fields = append(fields, alertdigestentry.FieldQueuedAt)
	}
	if m.delivered_at != nil {
		fields = append(fields, alertdigestentry.FieldDeliveredAt)
	}
	if m.digest_id != nil {
		fields = append(fields, alertdigestentry.FieldDigestID)
	}
	if m.bypass_sent != nil {
		fields = append(fields, alertdigestentry.FieldBypassSent)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AlertDigestEntryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case alertdigestentry.FieldAlertID:
		return m.AlertID()
	case alertdigestentry.FieldRuleID:
		return m.RuleID()
	case alertdigestentry.FieldChannelID:
		return m.ChannelID()
	case alertdigestentry.FieldChannelType:
		return m.ChannelType()
	case alertdigestentry.FieldSeverity:
		return m.Severity()
	case alertdigestentry.FieldEventType:
		return m.EventType()
	case alertdigestentry.FieldTitle:
		return m.Title()
	case alertdigestentry.FieldMessage:
		return m.Message()
	case alertdigestentry.FieldData:
		return m.Data()
	case alertdigestentry.FieldQueuedAt:
		return m.QueuedAt()
	case alertdigestentry.FieldDeliveredAt:
		return m.DeliveredAt()
	case alertdigestentry.FieldDigestID:
		return m.DigestID()
	case alertdigestentry.FieldBypassSent:
		return m.BypassSent()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AlertDigestEntryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case alertdigestentry.FieldAlertID:
		return m.OldAlertID(ctx)
	case alertdigestentry.FieldRuleID:
		return m.OldRuleID(ctx)
	case alertdigestentry.FieldChannelID:
		return m.OldChannelID(ctx)
	case alertdigestentry.FieldChannelType:
		return m.OldChannelType(ctx)
	case alertdigestentry.FieldSeverity:
		return m.OldSeverity(ctx)
	case alertdigestentry.FieldEventType:
		return m.OldEventType(ctx)
	case alertdigestentry.FieldTitle:
		return m.OldTitle(ctx)
	case alertdigestentry.FieldMessage:
		return m.OldMessage(ctx)
	case alertdigestentry.FieldData:
		return m.OldData(ctx)
	case alertdigestentry.FieldQueuedAt:
		return m.OldQueuedAt(ctx)
	case alertdigestentry.FieldDeliveredAt:
		return m.OldDeliveredAt(ctx)
	case alertdigestentry.FieldDigestID:
		return m.OldDigestID(ctx)
	case alertdigestentry.FieldBypassSent:
		return m.OldBypassSent(ctx)
	}
	return nil, fmt.Errorf("unknown AlertDigestEntry field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AlertDigestEntryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case alertdigestentry.FieldAlertID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAlertID(v)
		return nil
	case alertdigestentry.FieldRuleID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRuleID(v)
		return nil
	case alertdigestentry.FieldChannelID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChannelID(v)
		return nil
	case alertdigestentry.FieldChannelType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChannelType(v)
		return nil
	case alertdigestentry.FieldSeverity:
		v, ok := value.(alertdigestentry.Severity)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSeverity(v)
		return nil
	case alertdigestentry.FieldEventType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEventType(v)
		return nil
	case alertdigestentry.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case alertdigestentry.FieldMessage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMessage(v)
		return nil
	case alertdigestentry.FieldData:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetData(v)
		return nil
	case alertdigestentry.FieldQueuedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQueuedAt(v)
		return nil
	case alertdigestentry.FieldDeliveredAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeliveredAt(v)
		return nil
	case alertdigestentry.FieldDigestID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDigestID(v)
		return nil
	case alertdigestentry.FieldBypassSent:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBypassSent(v)
		return nil
	}
	return fmt.Errorf("unknown AlertDigestEntry field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AlertDigestEntryMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AlertDigestEntryMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AlertDigestEntryMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown AlertDigestEntry numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AlertDigestEntryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(alertdigestentry.FieldAlertID) {
		fields = append(fields, alertdigestentry.FieldAlertID)
	}
	if m.FieldCleared(alertdigestentry.FieldData) {
		fields = append(fields, alertdigestentry.FieldData)
	}
	if m.FieldCleared(alertdigestentry.FieldDeliveredAt) {
		fields = append(fields, alertdigestentry.FieldDeliveredAt)
	}
	if m.FieldCleared(alertdigestentry.FieldDigestID) {
		fields = append(fields, alertdigestentry.FieldDigestID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AlertDigestEntryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AlertDigestEntryMutation) ClearField(name string) error {
	switch name {
	case alertdigestentry.FieldAlertID:
		m.ClearAlertID()
		return nil
	case alertdigestentry.FieldData:
		m.ClearData()
		return nil
	case alertdigestentry.FieldDeliveredAt:
		m.ClearDeliveredAt()
		return nil
	case alertdigestentry.FieldDigestID:
		m.ClearDigestID()
		return nil
	}
	return fmt.Errorf("unknown AlertDigestEntry nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AlertDigestEntryMutation) ResetField(name string) error {
	switch name {
	case alertdigestentry.FieldAlertID:
		m.ResetAlertID()
		return nil
	case alertdigestentry.FieldRuleID:
		m.ResetRuleID()
		return nil
	case alertdigestentry.FieldChannelID:
		m.ResetChannelID()
		return nil
	case alertdigestentry.FieldChannelType:
		m.ResetChannelType()
		return nil
	case alertdigestentry.FieldSeverity:
		m.ResetSeverity()
		return nil
	case alertdigestentry.FieldEventType:
		m.ResetEventType()
		return nil
	case alertdigestentry.FieldTitle:
		m.ResetTitle()
		return nil
	case alertdigestentry.FieldMessage:
		m.ResetMessage()
		return nil
	case alertdigestentry.FieldData:
		m.ResetData()
		return nil
	case alertdigestentry.FieldQueuedAt:
		m.ResetQueuedAt()
		return nil
	case alertdigestentry.FieldDeliveredAt:
		m.ResetDeliveredAt()
		return nil
	case alertdigestentry.FieldDigestID:
		m.ResetDigestID()
		return nil
	case alertdigestentry.FieldBypassSent:
		m.ResetBypassSent()
		return nil
	}
	return fmt.Errorf("unknown AlertDigestEntry field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AlertDigestEntryMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AlertDigestEntryMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AlertDigestEntryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AlertDigestEntryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AlertDigestEntryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AlertDigestEntryMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AlertDigestEntryMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown AlertDigestEntry unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AlertDigestEntryMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown AlertDigestEntry edge %s", name)
}

// AlertEscalationMutation represents an operation that mutates the AlertEscalation nodes in the graph.
type AlertEscalationMutation struct {
	config
	op                            Op
	typ                           string
	id                            *string
	current_level                 *int
	addcurrent_level              *int
	max_level                     *int
	addmax_level                  *int
	status                        *alertescalation.Status
	next_escalation_at            *time.Time
	escalation_delay_seconds      *int
	addescalation_delay_seconds   *int
	repeat_interval_seconds       *[]int
	appendrepeat_interval_seconds []int
	additional_channels           *[]string
	appendadditional_channels     []string
	resolved_at                   *time.Time
	resolved_by                   *string
	created_at                    *time.Time
	updated_at                    *time.Time
	clearedFields                 map[string]struct{}
	alert                         *string
	clearedalert                  bool
	rule                          *string
	clearedrule                   bool
	done                          bool
	oldValue                      func(context.Context) (*AlertEscalation, error)
	predicates                    []predicate.AlertEscalation
}

var _ ent.Mutation = (*AlertEscalationMutation)(nil)

// alertescalationOption allows management of the mutation configuration using functional options.
type alertescalationOption func(*AlertEscalationMutation)

// newAlertEscalationMutation creates new mutation for the AlertEscalation entity.
func newAlertEscalationMutation(c config, op Op, opts ...alertescalationOption) *AlertEscalationMutation {
	m := &AlertEscalationMutation{
		config:        c,
		op:            op,
		typ:           TypeAlertEscalation,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAlertEscalationID sets the ID field of the mutation.
func withAlertEscalationID(id string) alertescalationOption {
	return func(m *AlertEscalationMutation) {
		var (
			err   error
			once  sync.Once
			value *AlertEscalation
		)
		m.oldValue = func(ctx context.Context) (*AlertEscalation, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AlertEscalation.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAlertEscalation sets the old AlertEscalation of the mutation.
func withAlertEscalation(node *AlertEscalation) alertescalationOption {
	return func(m *AlertEscalationMutation) {
		m.oldValue = func(context.Context) (*AlertEscalation, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AlertEscalationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AlertEscalationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AlertEscalation entities.
func (m *AlertEscalationMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AlertEscalationMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AlertEscalationMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AlertEscalation.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetAlertID sets the "alert_id" field.
func (m *AlertEscalationMutation) SetAlertID(s string) {
	m.alert = &s
}

// AlertID returns the value of the "alert_id" field in the mutation.
func (m *AlertEscalationMutation) AlertID() (r string, exists bool) {
	v := m.alert
	if v == nil {
		return
	}
	return *v, true
}

// OldAlertID returns the old "alert_id" field's value of the AlertEscalation entity.
// If the AlertEscalation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertEscalationMutation) OldAlertID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAlertID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAlertID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAlertID: %w", err)
	}
	return oldValue.AlertID, nil
}

// ResetAlertID resets all changes to the "alert_id" field.
func (m *AlertEscalationMutation) ResetAlertID() {
	m.alert = nil
}

// SetRuleID sets the "rule_id" field.
func (m *AlertEscalationMutation) SetRuleID(s string) {
	m.rule = &s
}

// RuleID returns the value of the "rule_id" field in the mutation.
func (m *AlertEscalationMutation) RuleID() (r string, exists bool) {
	v := m.rule
	if v == nil {
		return
	}
	return *v, true
}

// OldRuleID returns the old "rule_id" field's value of the AlertEscalation entity.
// If the AlertEscalation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertEscalationMutation) OldRuleID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRuleID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRuleID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRuleID: %w", err)
	}
	return oldValue.RuleID, nil
}

// ResetRuleID resets all changes to the "rule_id" field.
func (m *AlertEscalationMutation) ResetRuleID() {
	m.rule = nil
}

// SetCurrentLevel sets the "current_level" field.
func (m *AlertEscalationMutation) SetCurrentLevel(i int) {
	m.current_level = &i
	m.addcurrent_level = nil
}

// CurrentLevel returns the value of the "current_level" field in the mutation.
func (m *AlertEscalationMutation) CurrentLevel() (r int, exists bool) {
	v := m.current_level
	if v == nil {
		return
	}
	return *v, true
}

// OldCurrentLevel returns the old "current_level" field's value of the AlertEscalation entity.
// If the AlertEscalation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertEscalationMutation) OldCurrentLevel(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCurrentLevel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCurrentLevel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCurrentLevel: %w", err)
	}
	return oldValue.CurrentLevel, nil
}

// AddCurrentLevel adds i to the "current_level" field.
func (m *AlertEscalationMutation) AddCurrentLevel(i int) {
	if m.addcurrent_level != nil {
		*m.addcurrent_level += i
	} else {
		m.addcurrent_level = &i
	}
}

// AddedCurrentLevel returns the value that was added to the "current_level" field in this mutation.
func (m *AlertEscalationMutation) AddedCurrentLevel() (r int, exists bool) {
	v := m.addcurrent_level
	if v == nil {
		return
	}
	return *v, true
}

// ResetCurrentLevel resets all changes to the "current_level" field.
func (m *AlertEscalationMutation) ResetCurrentLevel() {
	m.current_level = nil
	m.addcurrent_level = nil
}

// SetMaxLevel sets the "max_level" field.
func (m *AlertEscalationMutation) SetMaxLevel(i int) {
	m.max_level = &i
	m.addmax_level = nil
}

// MaxLevel returns the value of the "max_level" field in the mutation.
func (m *AlertEscalationMutation) MaxLevel() (r int, exists bool) {
	v := m.max_level
	if v == nil {
		return
	}
	return *v, true
}

// OldMaxLevel returns the old "max_level" field's value of the AlertEscalation entity.
// If the AlertEscalation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertEscalationMutation) OldMaxLevel(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMaxLevel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMaxLevel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaxLevel: %w", err)
	}
	return oldValue.MaxLevel, nil
}

// AddMaxLevel adds i to the "max_level" field.
func (m *AlertEscalationMutation) AddMaxLevel(i int) {
	if m.addmax_level != nil {
		*m.addmax_level += i
	} else {
		m.addmax_level = &i
	}
}

// AddedMaxLevel returns the value that was added to the "max_level" field in this mutation.
func (m *AlertEscalationMutation) AddedMaxLevel() (r int, exists bool) {
	v := m.addmax_level
	if v == nil {
		return
	}
	return *v, true
}

// ResetMaxLevel resets all changes to the "max_level" field.
func (m *AlertEscalationMutation) ResetMaxLevel() {
	m.max_level = nil
	m.addmax_level = nil
}

// SetStatus sets the "status" field.
func (m *AlertEscalationMutation) SetStatus(a alertescalation.Status) {
	m.status = &a
}

// Status returns the value of the "status" field in the mutation.
func (m *AlertEscalationMutation) Status() (r alertescalation.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the AlertEscalation entity.
// If the AlertEscalation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertEscalationMutation) OldStatus(ctx context.Context) (v alertescalation.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *AlertEscalationMutation) ResetStatus() {
	m.status = nil
}

// SetNextEscalationAt sets the "next_escalation_at" field.
func (m *AlertEscalationMutation) SetNextEscalationAt(t time.Time) {
	m.next_escalation_at = &t
}

// NextEscalationAt returns the value of the "next_escalation_at" field in the mutation.
func (m *AlertEscalationMutation) NextEscalationAt() (r time.Time, exists bool) {
	v := m.next_escalation_at
	if v == nil {
		return
	}
	return *v, true
}

// OldNextEscalationAt returns the old "next_escalation_at" field's value of the AlertEscalation entity.
// If the AlertEscalation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertEscalationMutation) OldNextEscalationAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNextEscalationAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNextEscalationAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNextEscalationAt: %w", err)
	}
	return oldValue.NextEscalationAt, nil
}

// ClearNextEscalationAt clears the value of the "next_escalation_at" field.
func (m *AlertEscalationMutation) ClearNextEscalationAt() {
	m.next_escalation_at = nil
	m.clearedFields[alertescalation.FieldNextEscalationAt] = struct{}{}
}

// NextEscalationAtCleared returns if the "next_escalation_at" field was cleared in this mutation.
func (m *AlertEscalationMutation) NextEscalationAtCleared() bool {
	_, ok := m.clearedFields[alertescalation.FieldNextEscalationAt]
	return ok
}

// ResetNextEscalationAt resets all changes to the "next_escalation_at" field.
func (m *AlertEscalationMutation) ResetNextEscalationAt() {
	m.next_escalation_at = nil
	delete(m.clearedFields, alertescalation.FieldNextEscalationAt)
}

// SetEscalationDelaySeconds sets the "escalation_delay_seconds" field.
func (m *AlertEscalationMutation) SetEscalationDelaySeconds(i int) {
	m.escalation_delay_seconds = &i
	m.addescalation_delay_seconds = nil
}

// EscalationDelaySeconds returns the value of the "escalation_delay_seconds" field in the mutation.
func (m *AlertEscalationMutation) EscalationDelaySeconds() (r int, exists bool) {
	v := m.escalation_delay_seconds
	if v == nil {
		return
	}
	return *v, true
}

// OldEscalationDelaySeconds returns the old "escalation_delay_seconds" field's value of the AlertEscalation entity.
// If the AlertEscalation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertEscalationMutation) OldEscalationDelaySeconds(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEscalationDelaySeconds is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEscalationDelaySeconds requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEscalationDelaySeconds: %w", err)
	}
	return oldValue.EscalationDelaySeconds, nil
}

// AddEscalationDelaySeconds adds i to the "escalation_delay_seconds" field.
func (m *AlertEscalationMutation) AddEscalationDelaySeconds(i int) {
	if m.addescalation_delay_seconds != nil {
		*m.addescalation_delay_seconds += i
	} else {
		m.addescalation_delay_seconds = &i
	}
}

// AddedEscalationDelaySeconds returns the value that was added to the "escalation_delay_seconds" field in this mutation.
func (m *AlertEscalationMutation) AddedEscalationDelaySeconds() (r int, exists bool) {
	v := m.addescalation_delay_seconds
	if v == nil {
		return
	}
	return *v, true
}

// ResetEscalationDelaySeconds resets all changes to the "escalation_delay_seconds" field.
func (m *AlertEscalationMutation) ResetEscalationDelaySeconds() {
	m.escalation_delay_seconds = nil
	m.addescalation_delay_seconds = nil
}

// SetRepeatIntervalSeconds sets the "repeat_interval_seconds" field.
func (m *AlertEscalationMutation) SetRepeatIntervalSeconds(i []int) {
	m.repeat_interval_seconds = &i
	m.appendrepeat_interval_seconds = nil
}

// RepeatIntervalSeconds returns the value of the "repeat_interval_seconds" field in the mutation.
func (m *AlertEscalationMutation) RepeatIntervalSeconds() (r []int, exists bool) {
	v := m.repeat_interval_seconds
	if v == nil {
		return
	}
	return *v, true
}

// OldRepeatIntervalSeconds returns the old "repeat_interval_seconds" field's value of the AlertEscalation entity.
// If the AlertEscalation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertEscalationMutation) OldRepeatIntervalSeconds(ctx context.Context) (v []int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRepeatIntervalSeconds is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRepeatIntervalSeconds requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRepeatIntervalSeconds: %w", err)
	}
	return oldValue.RepeatIntervalSeconds, nil
}

// AppendRepeatIntervalSeconds adds i to the "repeat_interval_seconds" field.
func (m *AlertEscalationMutation) AppendRepeatIntervalSeconds(i []int) {
	m.appendrepeat_interval_seconds = append(m.appendrepeat_interval_seconds, i...)
}

// AppendedRepeatIntervalSeconds returns the list of values that were appended to the "repeat_interval_seconds" field in this mutation.
func (m *AlertEscalationMutation) AppendedRepeatIntervalSeconds() ([]int, bool) {
	if len(m.appendrepeat_interval_seconds) == 0 {
		return nil, false
	}
	return m.appendrepeat_interval_seconds, true
}

// ResetRepeatIntervalSeconds resets all changes to the "repeat_interval_seconds" field.
func (m *AlertEscalationMutation) ResetRepeatIntervalSeconds() {
	m.repeat_interval_seconds = nil
	m.appendrepeat_interval_seconds = nil
}

// SetAdditionalChannels sets the "additional_channels" field.
func (m *AlertEscalationMutation) SetAdditionalChannels(s []string) {
	m.additional_channels = &s
	m.appendadditional_channels = nil
}

// AdditionalChannels returns the value of the "additional_channels" field in the mutation.
func (m *AlertEscalationMutation) AdditionalChannels() (r []string, exists bool) {
	v := m.additional_channels
	if v == nil {
		return
	}
	return *v, true
}

// OldAdditionalChannels returns the old "additional_channels" field's value of the AlertEscalation entity.
// If the AlertEscalation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertEscalationMutation) OldAdditionalChannels(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAdditionalChannels is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAdditionalChannels requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAdditionalChannels: %w", err)
	}
	return oldValue.AdditionalChannels, nil
}

// AppendAdditionalChannels adds s to the "additional_channels" field.
func (m *AlertEscalationMutation) AppendAdditionalChannels(s []string) {
	m.appendadditional_channels = append(m.appendadditional_channels, s...)
}

// AppendedAdditionalChannels returns the list of values that were appended to the "additional_channels" field in this mutation.
func (m *AlertEscalationMutation) AppendedAdditionalChannels() ([]string, bool) {
	if len(m.appendadditional_channels) == 0 {
		return nil, false
	}
	return m.appendadditional_channels, true
}

// ResetAdditionalChannels resets all changes to the "additional_channels" field.
func (m *AlertEscalationMutation) ResetAdditionalChannels() {
	m.additional_channels = nil
	m.appendadditional_channels = nil
}

// SetResolvedAt sets the "resolved_at" field.
func (m *AlertEscalationMutation) SetResolvedAt(t time.Time) {
	m.resolved_at = &t
}

// ResolvedAt returns the value of the "resolved_at" field in the mutation.
func (m *AlertEscalationMutation) ResolvedAt() (r time.Time, exists bool) {
	v := m.resolved_at
	if v == nil {
		return
	}
	return *v, true
}

// OldResolvedAt returns the old "resolved_at" field's value of the AlertEscalation entity.
// If the AlertEscalation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertEscalationMutation) OldResolvedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResolvedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResolvedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResolvedAt: %w", err)
	}
	return oldValue.ResolvedAt, nil
}

// ClearResolvedAt clears the value of the "resolved_at" field.
func (m *AlertEscalationMutation) ClearResolvedAt() {
	m.resolved_at = nil
	m.clearedFields[alertescalation.FieldResolvedAt] = struct{}{}
}

// ResolvedAtCleared returns if the "resolved_at" field was cleared in this mutation.
func (m *AlertEscalationMutation) ResolvedAtCleared() bool {
	_, ok := m.clearedFields[alertescalation.FieldResolvedAt]
	return ok
}

// ResetResolvedAt resets all changes to the "resolved_at" field.
func (m *AlertEscalationMutation) ResetResolvedAt() {
	m.resolved_at = nil
	delete(m.clearedFields, alertescalation.FieldResolvedAt)
}

// SetResolvedBy sets the "resolved_by" field.
func (m *AlertEscalationMutation) SetResolvedBy(s string) {
	m.resolved_by = &s
}

// ResolvedBy returns the value of the "resolved_by" field in the mutation.
func (m *AlertEscalationMutation) ResolvedBy() (r string, exists bool) {
	v := m.resolved_by
	if v == nil {
		return
	}
	return *v, true
}

// OldResolvedBy returns the old "resolved_by" field's value of the AlertEscalation entity.
// If the AlertEscalation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertEscalationMutation) OldResolvedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResolvedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResolvedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResolvedBy: %w", err)
	}
	return oldValue.ResolvedBy, nil
}

// ClearResolvedBy clears the value of the "resolved_by" field.
func (m *AlertEscalationMutation) ClearResolvedBy() {
	m.resolved_by = nil
	m.clearedFields[alertescalation.FieldResolvedBy] = struct{}{}
}

// ResolvedByCleared returns if the "resolved_by" field was cleared in this mutation.
func (m *AlertEscalationMutation) ResolvedByCleared() bool {
	_, ok := m.clearedFields[alertescalation.FieldResolvedBy]
	return ok
}

// ResetResolvedBy resets all changes to the "resolved_by" field.
func (m *AlertEscalationMutation) ResetResolvedBy() {
	m.resolved_by = nil
	delete(m.clearedFields, alertescalation.FieldResolvedBy)
}

// SetCreatedAt sets the "created_at" field.
func (m *AlertEscalationMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AlertEscalationMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the AlertEscalation entity.
// If the AlertEscalation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertEscalationMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AlertEscalationMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AlertEscalationMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AlertEscalationMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the AlertEscalation entity.
// If the AlertEscalation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertEscalationMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AlertEscalationMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearAlert clears the "alert" edge to the Alert entity.
func (m *AlertEscalationMutation) ClearAlert() {
	m.clearedalert = true
	m.clearedFields[alertescalation.FieldAlertID] = struct{}{}
}

// AlertCleared reports if the "alert" edge to the Alert entity was cleared.
func (m *AlertEscalationMutation) AlertCleared() bool {
	return m.clearedalert
}

// AlertIDs returns the "alert" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AlertID instead. It exists only for internal usage by the builders.
func (m *AlertEscalationMutation) AlertIDs() (ids []string) {
	if id := m.alert; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAlert resets all changes to the "alert" edge.
func (m *AlertEscalationMutation) ResetAlert() {
	m.alert = nil
	m.clearedalert = false
}

// ClearRule clears the "rule" edge to the AlertRule entity.
func (m *AlertEscalationMutation) ClearRule() {
	m.clearedrule = true
	m.clearedFields[alertescalation.FieldRuleID] = struct{}{}
}

// RuleCleared reports if the "rule" edge to the AlertRule entity was cleared.
func (m *AlertEscalationMutation) RuleCleared() bool {
	return m.clearedrule
}

// RuleIDs returns the "rule" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RuleID instead. It exists only for internal usage by the builders.
func (m *AlertEscalationMutation) RuleIDs() (ids []string) {
	if id := m.rule; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRule resets all changes to the "rule" edge.
func (m *AlertEscalationMutation) ResetRule() {
	m.rule = nil
	m.clearedrule = false
}

// Where appends a list predicates to the AlertEscalationMutation builder.
func (m *AlertEscalationMutation) Where(ps ...predicate.AlertEscalation) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AlertEscalationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AlertEscalationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AlertEscalation, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AlertEscalationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AlertEscalationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AlertEscalation).
func (m *AlertEscalationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AlertEscalationMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.alert != nil {
		fields = append(fields, alertescalation.FieldAlertID)
	}
	if m.rule != nil {
		fields = append(fields, alertescalation.FieldRuleID)
	}
	if m.current_level != nil {
		fields = append(fields, alertescalation.FieldCurrentLevel)
	}
	if m.max_level != nil {
		fields = append(fields, alertescalation.FieldMaxLevel)
	}
	if m.status != nil {
		fields = append(fields, alertescalation.FieldStatus)
	}
	if m.next_escalation_at != nil {
		fields = append(fields, alertescalation.FieldNextEscalationAt)
	}
	if m.escalation_delay_seconds != nil {
		fields = append(fields, alertescalation.FieldEscalationDelaySeconds)
	}
	if m.repeat_interval_seconds != nil {
		fields = append(fields, alertescalation.FieldRepeatIntervalSeconds)
	}
	if m.additional_channels != nil {
		fields = append(fields, alertescalation.FieldAdditionalChannels)
	}
	if m.resolved_at != nil {
		fields = append(fields, alertescalation.FieldResolvedAt)
	}
	if m.resolved_by != nil {
		fields = append(fields, alertescalation.FieldResolvedBy)
	}
	if m.created_at != nil {
		fields = append(fields, alertescalation.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, alertescalation.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AlertEscalationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case alertescalation.FieldAlertID:
		return m.AlertID()
	case alertescalation.FieldRuleID:
		return m.RuleID()
	case alertescalation.FieldCurrentLevel:
		return m.CurrentLevel()
	case alertescalation.FieldMaxLevel:
		return m.MaxLevel()
	case alertescalation.FieldStatus:
		return m.Status()
	case alertescalation.FieldNextEscalationAt:
		return m.NextEscalationAt()
	case alertescalation.FieldEscalationDelaySeconds:
		return m.EscalationDelaySeconds()
	case alertescalation.FieldRepeatIntervalSeconds:
		return m.RepeatIntervalSeconds()
	case alertescalation.FieldAdditionalChannels:
		return m.AdditionalChannels()
	case alertescalation.FieldResolvedAt:
		return m.ResolvedAt()
	case alertescalation.FieldResolvedBy:
		return m.ResolvedBy()
	case alertescalation.FieldCreatedAt:
		return m.CreatedAt()
	case alertescalation.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AlertEscalationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case alertescalation.FieldAlertID:
		return m.OldAlertID(ctx)
	case alertescalation.FieldRuleID:
		return m.OldRuleID(ctx)
	case alertescalation.FieldCurrentLevel:
		return m.OldCurrentLevel(ctx)
	case alertescalation.FieldMaxLevel:
		return m.OldMaxLevel(ctx)
	case alertescalation.FieldStatus:
		return m.OldStatus(ctx)
	case alertescalation.FieldNextEscalationAt:
		return m.OldNextEscalationAt(ctx)
	case alertescalation.FieldEscalationDelaySeconds:
		return m.OldEscalationDelaySeconds(ctx)
	case alertescalation.FieldRepeatIntervalSeconds:
		return m.OldRepeatIntervalSeconds(ctx)
	case alertescalation.FieldAdditionalChannels:
		return m.OldAdditionalChannels(ctx)
	case alertescalation.FieldResolvedAt:
		return m.OldResolvedAt(ctx)
	case alertescalation.FieldResolvedBy:
		return m.OldResolvedBy(ctx)
	case alertescalation.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case alertescalation.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown AlertEscalation field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AlertEscalationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case alertescalation.FieldAlertID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAlertID(v)
		return nil
	case alertescalation.FieldRuleID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRuleID(v)
		return nil
	case alertescalation.FieldCurrentLevel:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCurrentLevel(v)
		return nil
	case alertescalation.FieldMaxLevel:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaxLevel(v)
		return nil
	case alertescalation.FieldStatus:
		v, ok := value.(alertescalation.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case alertescalation.FieldNextEscalationAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNextEscalationAt(v)
		return nil
	case alertescalation.FieldEscalationDelaySeconds:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEscalationDelaySeconds(v)
		return nil
	case alertescalation.FieldRepeatIntervalSeconds:
		v, ok := value.([]int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRepeatIntervalSeconds(v)
		return nil
	case alertescalation.FieldAdditionalChannels:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAdditionalChannels(v)
		return nil
	case alertescalation.FieldResolvedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResolvedAt(v)
		return nil
	case alertescalation.FieldResolvedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResolvedBy(v)
		return nil
	case alertescalation.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case alertescalation.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown AlertEscalation field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AlertEscalationMutation) AddedFields() []string {
	var fields []string
	if m.addcurrent_level != nil {
		fields = append(fields, alertescalation.FieldCurrentLevel)
	}
	if m.addmax_level != nil {
		fields = append(fields, alertescalation.FieldMaxLevel)
	}
	if m.addescalation_delay_seconds != nil {
		fields = append(fields, alertescalation.FieldEscalationDelaySeconds)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AlertEscalationMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case alertescalation.FieldCurrentLevel:
		return m.AddedCurrentLevel()
	case alertescalation.FieldMaxLevel:
		return m.AddedMaxLevel()
	case alertescalation.FieldEscalationDelaySeconds:
		return m.AddedEscalationDelaySeconds()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AlertEscalationMutation) AddField(name string, value ent.Value) error {
	switch name {
	case alertescalation.FieldCurrentLevel:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCurrentLevel(v)
		return nil
	case alertescalation.FieldMaxLevel:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMaxLevel(v)
		return nil
	case alertescalation.FieldEscalationDelaySeconds:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddEscalationDelaySeconds(v)
		return nil
	}
	return fmt.Errorf("unknown AlertEscalation numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AlertEscalationMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(alertescalation.FieldNextEscalationAt) {
		fields = append(fields, alertescalation.FieldNextEscalationAt)
	}
	if m.FieldCleared(alertescalation.FieldResolvedAt) {
		fields = append(fields, alertescalation.FieldResolvedAt)
	}
	if m.FieldCleared(alertescalation.FieldResolvedBy) {
		fields = append(fields, alertescalation.FieldResolvedBy)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AlertEscalationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AlertEscalationMutation) ClearField(name string) error {
	switch name {
	case alertescalation.FieldNextEscalationAt:
		m.ClearNextEscalationAt()
		return nil
	case alertescalation.FieldResolvedAt:
		m.ClearResolvedAt()
		return nil
	case alertescalation.FieldResolvedBy:
		m.ClearResolvedBy()
		return nil
	}
	return fmt.Errorf("unknown AlertEscalation nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AlertEscalationMutation) ResetField(name string) error {
	switch name {
	case alertescalation.FieldAlertID:
		m.ResetAlertID()
		return nil
	case alertescalation.FieldRuleID:
		m.ResetRuleID()
		return nil
	case alertescalation.FieldCurrentLevel:
		m.ResetCurrentLevel()
		return nil
	case alertescalation.FieldMaxLevel:
		m.ResetMaxLevel()
		return nil
	case alertescalation.FieldStatus:
		m.ResetStatus()
		return nil
	case alertescalation.FieldNextEscalationAt:
		m.ResetNextEscalationAt()
		return nil
	case alertescalation.FieldEscalationDelaySeconds:
		m.ResetEscalationDelaySeconds()
		return nil
	case alertescalation.FieldRepeatIntervalSeconds:
		m.ResetRepeatIntervalSeconds()
		return nil
	case alertescalation.FieldAdditionalChannels:
		m.ResetAdditionalChannels()
		return nil
	case alertescalation.FieldResolvedAt:
		m.ResetResolvedAt()
		return nil
	case alertescalation.FieldResolvedBy:
		m.ResetResolvedBy()
		return nil
	case alertescalation.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case alertescalation.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown AlertEscalation field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AlertEscalationMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.alert != nil {
		edges = append(edges, alertescalation.EdgeAlert)
	}
	if m.rule != nil {
		edges = append(edges, alertescalation.EdgeRule)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AlertEscalationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case alertescalation.EdgeAlert:
		if id := m.alert; id != nil {
			return []ent.Value{*id}
		}
	case alertescalation.EdgeRule:
		if id := m.rule; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AlertEscalationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AlertEscalationMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AlertEscalationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedalert {
		edges = append(edges, alertescalation.EdgeAlert)
	}
	if m.clearedrule {
		edges = append(edges, alertescalation.EdgeRule)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AlertEscalationMutation) EdgeCleared(name string) bool {
	switch name {
	case alertescalation.EdgeAlert:
		return m.clearedalert
	case alertescalation.EdgeRule:
		return m.clearedrule
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AlertEscalationMutation) ClearEdge(name string) error {
	switch name {
	case alertescalation.EdgeAlert:
		m.ClearAlert()
		return nil
	case alertescalation.EdgeRule:
		m.ClearRule()
		return nil
	}
	return fmt.Errorf("unknown AlertEscalation unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AlertEscalationMutation) ResetEdge(name string) error {
	switch name {
	case alertescalation.EdgeAlert:
		m.ResetAlert()
		return nil
	case alertescalation.EdgeRule:
		m.ResetRule()
		return nil
	}
	return fmt.Errorf("unknown AlertEscalation edge %s", name)
}

// AlertRuleMutation represents an operation that mutates the AlertRule nodes in the graph.
type AlertRuleMutation struct {
	config
	op                 Op
	typ                string
	id                 *string
	name               *string
	description        *string
	event_type         *string
	conditions         *[]map[string]interface{}
	appendconditions   []map[string]interface{}
	severity           *alertrule.Severity
	channels           *[]string
	appendchannels     []string
	throttle           *map[string]interface{}
	quiet_hours        *map[string]interface{}
	escalation         *map[string]interface{}
	device_id          *string
	enabled            *bool
	created_at         *time.Time
	updated_at         *time.Time
	clearedFields      map[string]struct{}
	alerts             map[string]struct{}
	removedalerts      map[string]struct{}
	clearedalerts      bool
	escalations        map[string]struct{}
	removedescalations map[string]struct{}
	clearedescalations bool
	done               bool
	oldValue           func(context.Context) (*AlertRule, error)
	predicates         []predicate.AlertRule
}

var _ ent.Mutation = (*AlertRuleMutation)(nil)

// alertruleOption allows management of the mutation configuration using functional options.
type alertruleOption func(*AlertRuleMutation)

// newAlertRuleMutation creates new mutation for the AlertRule entity.
func newAlertRuleMutation(c config, op Op, opts ...alertruleOption) *AlertRuleMutation {
	m := &AlertRuleMutation{
		config:        c,
		op:            op,
		typ:           TypeAlertRule,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAlertRuleID sets the ID field of the mutation.
func withAlertRuleID(id string) alertruleOption {
	return func(m *AlertRuleMutation) {
		var (
			err   error
			once  sync.Once
			value *AlertRule
		)
		m.oldValue = func(ctx context.Context) (*AlertRule, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AlertRule.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAlertRule sets the old AlertRule of the mutation.
func withAlertRule(node *AlertRule) alertruleOption {
	return func(m *AlertRuleMutation) {
		m.oldValue = func(context.Context) (*AlertRule, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AlertRuleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AlertRuleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AlertRule entities.
func (m *AlertRuleMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AlertRuleMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AlertRuleMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AlertRule.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *AlertRuleMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *AlertRuleMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the AlertRule entity.
// If the AlertRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertRuleMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *AlertRuleMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *AlertRuleMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *AlertRuleMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the AlertRule entity.
// If the AlertRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertRuleMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *AlertRuleMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[alertrule.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *AlertRuleMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[alertrule.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *AlertRuleMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, alertrule.FieldDescription)
}

// SetEventType sets the "event_type" field.
func (m *AlertRuleMutation) SetEventType(s string) {
	m.event_type = &s
}

// EventType returns the value of the "event_type" field in the mutation.
func (m *AlertRuleMutation) EventType() (r string, exists bool) {
	v := m.event_type
	if v == nil {
		return
	}
	return *v, true
}

// OldEventType returns the old "event_type" field's value of the AlertRule entity.
// If the AlertRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertRuleMutation) OldEventType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEventType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEventType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEventType: %w", err)
	}
	return oldValue.EventType, nil
}

// ResetEventType resets all changes to the "event_type" field.
func (m *AlertRuleMutation) ResetEventType() {
	m.event_type = nil
}

// SetConditions sets the "conditions" field.
func (m *AlertRuleMutation) SetConditions(value []map[string]interface{}) {
	m.conditions = &value
	m.appendconditions = nil
}

// Conditions returns the value of the "conditions" field in the mutation.
func (m *AlertRuleMutation) Conditions() (r []map[string]interface{}, exists bool) {
	v := m.conditions
	if v == nil {
		return
	}
	return *v, true
}

// OldConditions returns the old "conditions" field's value of the AlertRule entity.
// If the AlertRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertRuleMutation) OldConditions(ctx context.Context) (v []map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConditions is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConditions requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConditions: %w", err)
	}
	return oldValue.Conditions, nil
}

// AppendConditions adds value to the "conditions" field.
func (m *AlertRuleMutation) AppendConditions(value []map[string]interface{}) {
	m.appendconditions = append(m.appendconditions, value...)
}

// AppendedConditions returns the list of values that were appended to the "conditions" field in this mutation.
func (m *AlertRuleMutation) AppendedConditions() ([]map[string]interface{}, bool) {
	if len(m.appendconditions) == 0 {
		return nil, false
	}
	return m.appendconditions, true
}

// ClearConditions clears the value of the "conditions" field.
func (m *AlertRuleMutation) ClearConditions() {
	m.conditions = nil
	m.appendconditions = nil
	m.clearedFields[alertrule.FieldConditions] = struct{}{}
}

// ConditionsCleared returns if the "conditions" field was cleared in this mutation.
func (m *AlertRuleMutation) ConditionsCleared() bool {
	_, ok := m.clearedFields[alertrule.FieldConditions]
	return ok
}

// ResetConditions resets all changes to the "conditions" field.
func (m *AlertRuleMutation) ResetConditions() {
	m.conditions = nil
	m.appendconditions = nil
	delete(m.clearedFields, alertrule.FieldConditions)
}

// SetSeverity sets the "severity" field.
func (m *AlertRuleMutation) SetSeverity(a alertrule.Severity) {
	m.severity = &a
}

// Severity returns the value of the "severity" field in the mutation.
func (m *AlertRuleMutation) Severity() (r alertrule.Severity, exists bool) {
	v := m.severity
	if v == nil {
		return
	}
	return *v, true
}

// OldSeverity returns the old "severity" field's value of the AlertRule entity.
// If the AlertRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertRuleMutation) OldSeverity(ctx context.Context) (v alertrule.Severity, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSeverity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSeverity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSeverity: %w", err)
	}
	return oldValue.Severity, nil
}

// ResetSeverity resets all changes to the "severity" field.
func (m *AlertRuleMutation) ResetSeverity() {
	m.severity = nil
}

// SetChannels sets the "channels" field.
func (m *AlertRuleMutation) SetChannels(s []string) {
	m.channels = &s
	m.appendchannels = nil
}

// Channels returns the value of the "channels" field in the mutation.
func (m *AlertRuleMutation) Channels() (r []string, exists bool) {
	v := m.channels
	if v == nil {
		return
	}
	return *v, true
}

// OldChannels returns the old "channels" field's value of the AlertRule entity.
// If the AlertRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertRuleMutation) OldChannels(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChannels is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChannels requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChannels: %w", err)
	}
	return oldValue.Channels, nil
}

// AppendChannels adds s to the "channels" field.
func (m *AlertRuleMutation) AppendChannels(s []string) {
	m.appendchannels = append(m.appendchannels, s...)
}

// AppendedChannels returns the list of values that were appended to the "channels" field in this mutation.
func (m *AlertRuleMutation) AppendedChannels() ([]string, bool) {
	if len(m.appendchannels) == 0 {
		return nil, false
	}
	return m.appendchannels, true
}

// ResetChannels resets all changes to the "channels" field.
func (m *AlertRuleMutation) ResetChannels() {
	m.channels = nil
	m.appendchannels = nil
}

// SetThrottle sets the "throttle" field.
func (m *AlertRuleMutation) SetThrottle(value map[string]interface{}) {
	m.throttle = &value
}

// Throttle returns the value of the "throttle" field in the mutation.
func (m *AlertRuleMutation) Throttle() (r map[string]interface{}, exists bool) {
	v := m.throttle
	if v == nil {
		return
	}
	return *v, true
}

// OldThrottle returns the old "throttle" field's value of the AlertRule entity.
// If the AlertRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertRuleMutation) OldThrottle(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldThrottle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldThrottle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldThrottle: %w", err)
	}
	return oldValue.Throttle, nil
}

// ClearThrottle clears the value of the "throttle" field.
func (m *AlertRuleMutation) ClearThrottle() {
	m.throttle = nil
	m.clearedFields[alertrule.FieldThrottle] = struct{}{}
}

// ThrottleCleared returns if the "throttle" field was cleared in this mutation.
func (m *AlertRuleMutation) ThrottleCleared() bool {
	_, ok := m.clearedFields[alertrule.FieldThrottle]
	return ok
}

// ResetThrottle resets all changes to the "throttle" field.
func (m *AlertRuleMutation) ResetThrottle() {
	m.throttle = nil
	delete(m.clearedFields, alertrule.FieldThrottle)
}

// SetQuietHours sets the "quiet_hours" field.
func (m *AlertRuleMutation) SetQuietHours(value map[string]interface{}) {
	m.quiet_hours = &value
}

// QuietHours returns the value of the "quiet_hours" field in the mutation.
func (m *AlertRuleMutation) QuietHours() (r map[string]interface{}, exists bool) {
	v := m.quiet_hours
	if v == nil {
		return
	}
	return *v, true
}

// OldQuietHours returns the old "quiet_hours" field's value of the AlertRule entity.
// If the AlertRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertRuleMutation) OldQuietHours(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQuietHours is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQuietHours requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQuietHours: %w", err)
	}
	return oldValue.QuietHours, nil
}

// ClearQuietHours clears the value of the "quiet_hours" field.
func (m *AlertRuleMutation) ClearQuietHours() {
	m.quiet_hours = nil
	m.clearedFields[alertrule.FieldQuietHours] = struct{}{}
}

// QuietHoursCleared returns if the "quiet_hours" field was cleared in this mutation.
func (m *AlertRuleMutation) QuietHoursCleared() bool {
	_, ok := m.clearedFields[alertrule.FieldQuietHours]
	return ok
}

// ResetQuietHours resets all changes to the "quiet_hours" field.
func (m *AlertRuleMutation) ResetQuietHours() {
	m.quiet_hours = nil
	delete(m.clearedFields, alertrule.FieldQuietHours)
}

// SetEscalation sets the "escalation" field.
func (m *AlertRuleMutation) SetEscalation(value map[string]interface{}) {
	m.escalation = &value
}

// Escalation returns the value of the "escalation" field in the mutation.
func (m *AlertRuleMutation) Escalation() (r map[string]interface{}, exists bool) {
	v := m.escalation
	if v == nil {
		return
	}
	return *v, true
}

// OldEscalation returns the old "escalation" field's value of the AlertRule entity.
// If the AlertRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertRuleMutation) OldEscalation(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEscalation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEscalation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEscalation: %w", err)
	}
	return oldValue.Escalation, nil
}

// ClearEscalation clears the value of the "escalation" field.
func (m *AlertRuleMutation) ClearEscalation() {
	m.escalation = nil
	m.clearedFields[alertrule.FieldEscalation] = struct{}{}
}

// EscalationCleared returns if the "escalation" field was cleared in this mutation.
func (m *AlertRuleMutation) EscalationCleared() bool {
	_, ok := m.clearedFields[alertrule.FieldEscalation]
	return ok
}

// ResetEscalation resets all changes to the "escalation" field.
func (m *AlertRuleMutation) ResetEscalation() {
	m.escalation = nil
	delete(m.clearedFields, alertrule.FieldEscalation)
}

// SetDeviceID sets the "device_id" field.
func (m *AlertRuleMutation) SetDeviceID(s string) {
	m.device_id = &s
}

// DeviceID returns the value of the "device_id" field in the mutation.
func (m *AlertRuleMutation) DeviceID() (r string, exists bool) {
	v := m.device_id
	if v == nil {
		return
	}
	return *v, true
}

// OldDeviceID returns the old "device_id" field's value of the AlertRule entity.
// If the AlertRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertRuleMutation) OldDeviceID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeviceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeviceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeviceID: %w", err)
	}
	return oldValue.DeviceID, nil
}

// ClearDeviceID clears the value of the "device_id" field.
func (m *AlertRuleMutation) ClearDeviceID() {
	m.device_id = nil
	m.clearedFields[alertrule.FieldDeviceID] = struct{}{}
}

// DeviceIDCleared returns if the "device_id" field was cleared in this mutation.
func (m *AlertRuleMutation) DeviceIDCleared() bool {
	_, ok := m.clearedFields[alertrule.FieldDeviceID]
	return ok
}

// ResetDeviceID resets all changes to the "device_id" field.
func (m *AlertRuleMutation) ResetDeviceID() {
	m.device_id = nil
	delete(m.clearedFields, alertrule.FieldDeviceID)
}

// SetEnabled sets the "enabled" field.
func (m *AlertRuleMutation) SetEnabled(b bool) {
	m.enabled = &b
}

// Enabled returns the value of the "enabled" field in the mutation.
func (m *AlertRuleMutation) Enabled() (r bool, exists bool) {
	v := m.enabled
	if v == nil {
		return
	}
	return *v, true
}

// OldEnabled returns the old "enabled" field's value of the AlertRule entity.
// If the AlertRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertRuleMutation) OldEnabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnabled: %w", err)
	}
	return oldValue.Enabled, nil
}

// ResetEnabled resets all changes to the "enabled" field.
func (m *AlertRuleMutation) ResetEnabled() {
	m.enabled = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *AlertRuleMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AlertRuleMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the AlertRule entity.
// If the AlertRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertRuleMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AlertRuleMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AlertRuleMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AlertRuleMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the AlertRule entity.
// If the AlertRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertRuleMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AlertRuleMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// AddAlertIDs adds the "alerts" edge to the Alert entity by ids.
func (m *AlertRuleMutation) AddAlertIDs(ids ...string) {
	if m.alerts == nil {
		m.alerts = make(map[string]struct{})
	}
	for i := range ids {
		m.alerts[ids[i]] = struct{}{}
	}
}

// ClearAlerts clears the "alerts" edge to the Alert entity.
func (m *AlertRuleMutation) ClearAlerts() {
	m.clearedalerts = true
}

// AlertsCleared reports if the "alerts" edge to the Alert entity was cleared.
func (m *AlertRuleMutation) AlertsCleared() bool {
	return m.clearedalerts
}

// RemoveAlertIDs removes the "alerts" edge to the Alert entity by IDs.
func (m *AlertRuleMutation) RemoveAlertIDs(ids ...string) {
	if m.removedalerts == nil {
		m.removedalerts = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.alerts, ids[i])
		m.removedalerts[ids[i]] = struct{}{}
	}
}

// RemovedAlerts returns the removed IDs of the "alerts" edge to the Alert entity.
func (m *AlertRuleMutation) RemovedAlertsIDs() (ids []string) {
	for id := range m.removedalerts {
		ids = append(ids, id)
	}
	return
}

// AlertsIDs returns the "alerts" edge IDs in the mutation.
func (m *AlertRuleMutation) AlertsIDs() (ids []string) {
	for id := range m.alerts {
		ids = append(ids, id)
	}
	return
}

// ResetAlerts resets all changes to the "alerts" edge.
func (m *AlertRuleMutation) ResetAlerts() {
	m.alerts = nil
	m.clearedalerts = false
	m.removedalerts = nil
}

// AddEscalationIDs adds the "escalations" edge to the AlertEscalation entity by ids.
func (m *AlertRuleMutation) AddEscalationIDs(ids ...string) {
	if m.escalations == nil {
		m.escalations = make(map[string]struct{})
	}
	for i := range ids {
		m.escalations[ids[i]] = struct{}{}
	}
}

// ClearEscalations clears the "escalations" edge to the AlertEscalation entity.
func (m *AlertRuleMutation) ClearEscalations() {
	m.clearedescalations = true
}

// EscalationsCleared reports if the "escalations" edge to the AlertEscalation entity was cleared.
func (m *AlertRuleMutation) EscalationsCleared() bool {
	return m.clearedescalations
}

// RemoveEscalationIDs removes the "escalations" edge to the AlertEscalation entity by IDs.
func (m *AlertRuleMutation) RemoveEscalationIDs(ids ...string) {
	if m.removedescalations == nil {
		m.removedescalations = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.escalations, ids[i])
		m.removedescalations[ids[i]] = struct{}{}
	}
}

// RemovedEscalations returns the removed IDs of the "escalations" edge to the AlertEscalation entity.
func (m *AlertRuleMutation) RemovedEscalationsIDs() (ids []string) {
	for id := range m.removedescalations {
		ids = append(ids, id)
	}
	return
}

// EscalationsIDs returns the "escalations" edge IDs in the mutation.
func (m *AlertRuleMutation) EscalationsIDs() (ids []string) {
	for id := range m.escalations {
		ids = append(ids, id)
	}
	return
}

// ResetEscalations resets all changes to the "escalations" edge.
func (m *AlertRuleMutation) ResetEscalations() {
	m.escalations = nil
	m.clearedescalations = false
	m.removedescalations = nil
}

// Where appends a list predicates to the AlertRuleMutation builder.
func (m *AlertRuleMutation) Where(ps ...predicate.AlertRule) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AlertRuleMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AlertRuleMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AlertRule, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AlertRuleMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AlertRuleMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AlertRule).
func (m *AlertRuleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AlertRuleMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.name != nil {
		fields = append(fields, alertrule.FieldName)
	}
	if m.description != nil {
		fields = append(fields, alertrule.FieldDescription)
	}
	if m.event_type != nil {
		fields = append(fields, alertrule.FieldEventType)
	}
	if m.conditions != nil {
		fields = append(fields, alertrule.FieldConditions)
	}
	if m.severity != nil {
		fields = append(fields, alertrule.FieldSeverity)
	}
	if m.channels != nil {
		fields = append(fields, alertrule.FieldChannels)
	}
	if m.throttle != nil {
		fields = append(fields, alertrule.FieldThrottle)
	}
	if m.quiet_hours != nil {
		fields = append(fields, alertrule.FieldQuietHours)
	}
	if m.escalation != nil {
		fields = append(fields, alertrule.FieldEscalation)
	}
	if m.device_id != nil {
		fields = append(fields, alertrule.FieldDeviceID)
	}
	if m.enabled != nil {
		fields = append(fields, alertrule.FieldEnabled)
	}
	if m.created_at != nil {
		fields = append(fields, alertrule.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, alertrule.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AlertRuleMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case alertrule.FieldName:
		return m.Name()
	case alertrule.FieldDescription:
		return m.Description()
	case alertrule.FieldEventType:
		return m.EventType()
	case alertrule.FieldConditions:
		return m.Conditions()
	case alertrule.FieldSeverity:
		return m.Severity()
	case alertrule.FieldChannels:
		return m.Channels()
	case alertrule.FieldThrottle:
		return m.Throttle()
	case alertrule.FieldQuietHours:
		return m.QuietHours()
	case alertrule.FieldEscalation:
		return m.Escalation()
	case alertrule.FieldDeviceID:
		return m.DeviceID()
	case alertrule.FieldEnabled:
		return m.Enabled()
	case alertrule.FieldCreatedAt:
		return m.CreatedAt()
	case alertrule.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AlertRuleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case alertrule.FieldName:
		return m.OldName(ctx)
	case alertrule.FieldDescription:
		return m.OldDescription(ctx)
	case alertrule.FieldEventType:
		return m.OldEventType(ctx)
	case alertrule.FieldConditions:
		return m.OldConditions(ctx)
	case alertrule.FieldSeverity:
		return m.OldSeverity(ctx)
	case alertrule.FieldChannels:
		return m.OldChannels(ctx)
	case alertrule.FieldThrottle:
		return m.OldThrottle(ctx)
	case alertrule.FieldQuietHours:
		return m.OldQuietHours(ctx)
	case alertrule.FieldEscalation:
		return m.OldEscalation(ctx)
	case alertrule.FieldDeviceID:
		return m.OldDeviceID(ctx)
	case alertrule.FieldEnabled:
		return m.OldEnabled(ctx)
	case alertrule.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case alertrule.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown AlertRule field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AlertRuleMutation) SetField(name string, value ent.Value) error {
	switch name {
	case alertrule.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case alertrule.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case alertrule.FieldEventType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEventType(v)
		return nil
	case alertrule.FieldConditions:
		v, ok := value.([]map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConditions(v)
		return nil
	case alertrule.FieldSeverity:
		v, ok := value.(alertrule.Severity)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSeverity(v)
		return nil
	case alertrule.FieldChannels:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChannels(v)
		return nil
	case alertrule.FieldThrottle:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetThrottle(v)
		return nil
	case alertrule.FieldQuietHours:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQuietHours(v)
		return nil
	case alertrule.FieldEscalation:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEscalation(v)
		return nil
	case alertrule.FieldDeviceID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeviceID(v)
		return nil
	case alertrule.FieldEnabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnabled(v)
		return nil
	case alertrule.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case alertrule.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown AlertRule field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AlertRuleMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AlertRuleMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AlertRuleMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown AlertRule numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AlertRuleMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(alertrule.FieldDescription) {
		fields = append(fields, alertrule.FieldDescription)
	}
	if m.FieldCleared(alertrule.FieldConditions) {
		fields = append(fields, alertrule.FieldConditions)
	}
	if m.FieldCleared(alertrule.FieldThrottle) {
		fields = append(fields, alertrule.FieldThrottle)
	}
	if m.FieldCleared(alertrule.FieldQuietHours) {
		fields = append(fields, alertrule.FieldQuietHours)
	}
	if m.FieldCleared(alertrule.FieldEscalation) {
		fields = append(fields, alertrule.FieldEscalation)
	}
	if m.FieldCleared(alertrule.FieldDeviceID) {
		fields = append(fields, alertrule.FieldDeviceID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AlertRuleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AlertRuleMutation) ClearField(name string) error {
	switch name {
	case alertrule.FieldDescription:
		m.ClearDescription()
		return nil
	case alertrule.FieldConditions:
		m.ClearConditions()
		return nil
	case alertrule.FieldThrottle:
		m.ClearThrottle()
		return nil
	case alertrule.FieldQuietHours:
		m.ClearQuietHours()
		return nil
	case alertrule.FieldEscalation:
		m.ClearEscalation()
		return nil
	case alertrule.FieldDeviceID:
		m.ClearDeviceID()
		return nil
	}
	return fmt.Errorf("unknown AlertRule nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AlertRuleMutation) ResetField(name string) error {
	switch name {
	case alertrule.FieldName:
		m.ResetName()
		return nil
	case alertrule.FieldDescription:
		m.ResetDescription()
		return nil
	case alertrule.FieldEventType:
		m.ResetEventType()
		return nil
	case alertrule.FieldConditions:
		m.ResetConditions()
		return nil
	case alertrule.FieldSeverity:
		m.ResetSeverity()
		return nil
	case alertrule.FieldChannels:
		m.ResetChannels()
		return nil
	case alertrule.FieldThrottle:
		m.ResetThrottle()
		return nil
	case alertrule.FieldQuietHours:
		m.ResetQuietHours()
		return nil
	case alertrule.FieldEscalation:
		m.ResetEscalation()
		return nil
	case alertrule.FieldDeviceID:
		m.ResetDeviceID()
		return nil
	case alertrule.FieldEnabled:
		m.ResetEnabled()
		return nil
	case alertrule.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case alertrule.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown AlertRule field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AlertRuleMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.alerts != nil {
		edges = append(edges, alertrule.EdgeAlerts)
	}
	if m.escalations != nil {
		edges = append(edges, alertrule.EdgeEscalations)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AlertRuleMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case alertrule.EdgeAlerts:
		ids := make([]ent.Value, 0, len(m.alerts))
		for id := range m.alerts {
			ids = append(ids, id)
		}
		return ids
	case alertrule.EdgeEscalations:
		ids := make([]ent.Value, 0, len(m.escalations))
		for id := range m.escalations {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AlertRuleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedalerts != nil {
		edges = append(edges, alertrule.EdgeAlerts)
	}
	if m.removedescalations != nil {
		edges = append(edges, alertrule.EdgeEscalations)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AlertRuleMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case alertrule.EdgeAlerts:
		ids := make([]ent.Value, 0, len(m.removedalerts))
		for id := range m.removedalerts {
			ids = append(ids, id)
		}
		return ids
	case alertrule.EdgeEscalations:
		ids := make([]ent.Value, 0, len(m.removedescalations))
		for id := range m.removedescalations {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AlertRuleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedalerts {
		edges = append(edges, alertrule.EdgeAlerts)
	}
	if m.clearedescalations {
		edges = append(edges, alertrule.EdgeEscalations)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AlertRuleMutation) EdgeCleared(name string) bool {
	switch name {
	case alertrule.EdgeAlerts:
		return m.clearedalerts
	case alertrule.EdgeEscalations:
		return m.clearedescalations
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AlertRuleMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown AlertRule unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AlertRuleMutation) ResetEdge(name string) error {
	switch name {
	case alertrule.EdgeAlerts:
		m.ResetAlerts()
		return nil
	case alertrule.EdgeEscalations:
		m.ResetEscalations()
		return nil
	}
	return fmt.Errorf("unknown AlertRule edge %s", name)
}

// AlertRuleTemplateMutation represents an operation that mutates the AlertRuleTemplate nodes in the graph.
type AlertRuleTemplateMutation struct {
	config
	op               Op
	typ              string
	id               *string
	name             *string
	description      *string
	category         *alertruletemplate.Category
	event_type       *string
	severity         *alertruletemplate.Severity
	variables        *[]map[string]interface{}
	appendvariables  []map[string]interface{}
	conditions       *[]map[string]interface{}
	appendconditions []map[string]interface{}
	throttle         *map[string]interface{}
	channels         *[]string
	appendchannels   []string
	is_built_in      *bool
	version          *string
	usage_count      *int
	addusage_count   *int
	created_at       *time.Time
	updated_at       *time.Time
	clearedFields    map[string]struct{}
	done             bool
	oldValue         func(context.Context) (*AlertRuleTemplate, error)
	predicates       []predicate.AlertRuleTemplate
}

var _ ent.Mutation = (*AlertRuleTemplateMutation)(nil)

// alertruletemplateOption allows management of the mutation configuration using functional options.
type alertruletemplateOption func(*AlertRuleTemplateMutation)

// newAlertRuleTemplateMutation creates new mutation for the AlertRuleTemplate entity.
func newAlertRuleTemplateMutation(c config, op Op, opts ...alertruletemplateOption) *AlertRuleTemplateMutation {
	m := &AlertRuleTemplateMutation{
		config:        c,
		op:            op,
		typ:           TypeAlertRuleTemplate,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAlertRuleTemplateID sets the ID field of the mutation.
func withAlertRuleTemplateID(id string) alertruletemplateOption {
	return func(m *AlertRuleTemplateMutation) {
		var (
			err   error
			once  sync.Once
			value *AlertRuleTemplate
		)
		m.oldValue = func(ctx context.Context) (*AlertRuleTemplate, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AlertRuleTemplate.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAlertRuleTemplate sets the old AlertRuleTemplate of the mutation.
func withAlertRuleTemplate(node *AlertRuleTemplate) alertruletemplateOption {
	return func(m *AlertRuleTemplateMutation) {
		m.oldValue = func(context.Context) (*AlertRuleTemplate, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AlertRuleTemplateMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AlertRuleTemplateMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AlertRuleTemplate entities.
func (m *AlertRuleTemplateMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AlertRuleTemplateMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AlertRuleTemplateMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AlertRuleTemplate.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *AlertRuleTemplateMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *AlertRuleTemplateMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the AlertRuleTemplate entity.
// If the AlertRuleTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertRuleTemplateMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *AlertRuleTemplateMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *AlertRuleTemplateMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *AlertRuleTemplateMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the AlertRuleTemplate entity.
// If the AlertRuleTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertRuleTemplateMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *AlertRuleTemplateMutation) ResetDescription() {
	m.description = nil
}

// SetCategory sets the "category" field.
func (m *AlertRuleTemplateMutation) SetCategory(a alertruletemplate.Category) {
	m.category = &a
}

// Category returns the value of the "category" field in the mutation.
func (m *AlertRuleTemplateMutation) Category() (r alertruletemplate.Category, exists bool) {
	v := m.category
	if v == nil {
		return
	}
	return *v, true
}

// OldCategory returns the old "category" field's value of the AlertRuleTemplate entity.
// If the AlertRuleTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertRuleTemplateMutation) OldCategory(ctx context.Context) (v alertruletemplate.Category, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategory: %w", err)
	}
	return oldValue.Category, nil
}

// ResetCategory resets all changes to the "category" field.
func (m *AlertRuleTemplateMutation) ResetCategory() {
	m.category = nil
}

// SetEventType sets the "event_type" field.
func (m *AlertRuleTemplateMutation) SetEventType(s string) {
	m.event_type = &s
}

// EventType returns the value of the "event_type" field in the mutation.
func (m *AlertRuleTemplateMutation) EventType() (r string, exists bool) {
	v := m.event_type
	if v == nil {
		return
	}
	return *v, true
}

// OldEventType returns the old "event_type" field's value of the AlertRuleTemplate entity.
// If the AlertRuleTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertRuleTemplateMutation) OldEventType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEventType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEventType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEventType: %w", err)
	}
	return oldValue.EventType, nil
}

// ResetEventType resets all changes to the "event_type" field.
func (m *AlertRuleTemplateMutation) ResetEventType() {
	m.event_type = nil
}

// SetSeverity sets the "severity" field.
func (m *AlertRuleTemplateMutation) SetSeverity(a alertruletemplate.Severity) {
	m.severity = &a
}

// Severity returns the value of the "severity" field in the mutation.
func (m *AlertRuleTemplateMutation) Severity() (r alertruletemplate.Severity, exists bool) {
	v := m.severity
	if v == nil {
		return
	}
	return *v, true
}

// OldSeverity returns the old "severity" field's value of the AlertRuleTemplate entity.
// If the AlertRuleTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertRuleTemplateMutation) OldSeverity(ctx context.Context) (v alertruletemplate.Severity, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSeverity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSeverity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSeverity: %w", err)
	}
	return oldValue.Severity, nil
}

// ResetSeverity resets all changes to the "severity" field.
func (m *AlertRuleTemplateMutation) ResetSeverity() {
	m.severity = nil
}

// SetVariables sets the "variables" field.
func (m *AlertRuleTemplateMutation) SetVariables(value []map[string]interface{}) {
	m.variables = &value
	m.appendvariables = nil
}

// Variables returns the value of the "variables" field in the mutation.
func (m *AlertRuleTemplateMutation) Variables() (r []map[string]interface{}, exists bool) {
	v := m.variables
	if v == nil {
		return
	}
	return *v, true
}

// OldVariables returns the old "variables" field's value of the AlertRuleTemplate entity.
// If the AlertRuleTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertRuleTemplateMutation) OldVariables(ctx context.Context) (v []map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVariables is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVariables requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVariables: %w", err)
	}
	return oldValue.Variables, nil
}

// AppendVariables adds value to the "variables" field.
func (m *AlertRuleTemplateMutation) AppendVariables(value []map[string]interface{}) {
	m.appendvariables = append(m.appendvariables, value...)
}

// AppendedVariables returns the list of values that were appended to the "variables" field in this mutation.
func (m *AlertRuleTemplateMutation) AppendedVariables() ([]map[string]interface{}, bool) {
	if len(m.appendvariables) == 0 {
		return nil, false
	}
	return m.appendvariables, true
}

// ClearVariables clears the value of the "variables" field.
func (m *AlertRuleTemplateMutation) ClearVariables() {
	m.variables = nil
	m.appendvariables = nil
	m.clearedFields[alertruletemplate.FieldVariables] = struct{}{}
}

// VariablesCleared returns if the "variables" field was cleared in this mutation.
func (m *AlertRuleTemplateMutation) VariablesCleared() bool {
	_, ok := m.clearedFields[alertruletemplate.FieldVariables]
	return ok
}

// ResetVariables resets all changes to the "variables" field.
func (m *AlertRuleTemplateMutation) ResetVariables() {
	m.variables = nil
	m.appendvariables = nil
	delete(m.clearedFields, alertruletemplate.FieldVariables)
}

// SetConditions sets the "conditions" field.
func (m *AlertRuleTemplateMutation) SetConditions(value []map[string]interface{}) {
	m.conditions = &value
	m.appendconditions = nil
}

// Conditions returns the value of the "conditions" field in the mutation.
func (m *AlertRuleTemplateMutation) Conditions() (r []map[string]interface{}, exists bool) {
	v := m.conditions
	if v == nil {
		return
	}
	return *v, true
}

// OldConditions returns the old "conditions" field's value of the AlertRuleTemplate entity.
// If the AlertRuleTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertRuleTemplateMutation) OldConditions(ctx context.Context) (v []map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConditions is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConditions requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConditions: %w", err)
	}
	return oldValue.Conditions, nil
}

// AppendConditions adds value to the "conditions" field.
func (m *AlertRuleTemplateMutation) AppendConditions(value []map[string]interface{}) {
	m.appendconditions = append(m.appendconditions, value...)
}

// AppendedConditions returns the list of values that were appended to the "conditions" field in this mutation.
func (m *AlertRuleTemplateMutation) AppendedConditions() ([]map[string]interface{}, bool) {
	if len(m.appendconditions) == 0 {
		return nil, false
	}
	return m.appendconditions, true
}

// ClearConditions clears the value of the "conditions" field.
func (m *AlertRuleTemplateMutation) ClearConditions() {
	m.conditions = nil
	m.appendconditions = nil
	m.clearedFields[alertruletemplate.FieldConditions] = struct{}{}
}

// ConditionsCleared returns if the "conditions" field was cleared in this mutation.
func (m *AlertRuleTemplateMutation) ConditionsCleared() bool {
	_, ok := m.clearedFields[alertruletemplate.FieldConditions]
	return ok
}

// ResetConditions resets all changes to the "conditions" field.
func (m *AlertRuleTemplateMutation) ResetConditions() {
	m.conditions = nil
	m.appendconditions = nil
	delete(m.clearedFields, alertruletemplate.FieldConditions)
}

// SetThrottle sets the "throttle" field.
func (m *AlertRuleTemplateMutation) SetThrottle(value map[string]interface{}) {
	m.throttle = &value
}

// Throttle returns the value of the "throttle" field in the mutation.
func (m *AlertRuleTemplateMutation) Throttle() (r map[string]interface{}, exists bool) {
	v := m.throttle
	if v == nil {
		return
	}
	return *v, true
}

// OldThrottle returns the old "throttle" field's value of the AlertRuleTemplate entity.
// If the AlertRuleTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertRuleTemplateMutation) OldThrottle(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldThrottle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldThrottle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldThrottle: %w", err)
	}
	return oldValue.Throttle, nil
}

// ClearThrottle clears the value of the "throttle" field.
func (m *AlertRuleTemplateMutation) ClearThrottle() {
	m.throttle = nil
	m.clearedFields[alertruletemplate.FieldThrottle] = struct{}{}
}

// ThrottleCleared returns if the "throttle" field was cleared in this mutation.
func (m *AlertRuleTemplateMutation) ThrottleCleared() bool {
	_, ok := m.clearedFields[alertruletemplate.FieldThrottle]
	return ok
}

// ResetThrottle resets all changes to the "throttle" field.
func (m *AlertRuleTemplateMutation) ResetThrottle() {
	m.throttle = nil
	delete(m.clearedFields, alertruletemplate.FieldThrottle)
}

// SetChannels sets the "channels" field.
func (m *AlertRuleTemplateMutation) SetChannels(s []string) {
	m.channels = &s
	m.appendchannels = nil
}

// Channels returns the value of the "channels" field in the mutation.
func (m *AlertRuleTemplateMutation) Channels() (r []string, exists bool) {
	v := m.channels
	if v == nil {
		return
	}
	return *v, true
}

// OldChannels returns the old "channels" field's value of the AlertRuleTemplate entity.
// If the AlertRuleTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertRuleTemplateMutation) OldChannels(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChannels is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChannels requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChannels: %w", err)
	}
	return oldValue.Channels, nil
}

// AppendChannels adds s to the "channels" field.
func (m *AlertRuleTemplateMutation) AppendChannels(s []string) {
	m.appendchannels = append(m.appendchannels, s...)
}

// AppendedChannels returns the list of values that were appended to the "channels" field in this mutation.
func (m *AlertRuleTemplateMutation) AppendedChannels() ([]string, bool) {
	if len(m.appendchannels) == 0 {
		return nil, false
	}
	return m.appendchannels, true
}

// ResetChannels resets all changes to the "channels" field.
func (m *AlertRuleTemplateMutation) ResetChannels() {
	m.channels = nil
	m.appendchannels = nil
}

// SetIsBuiltIn sets the "is_built_in" field.
func (m *AlertRuleTemplateMutation) SetIsBuiltIn(b bool) {
	m.is_built_in = &b
}

// IsBuiltIn returns the value of the "is_built_in" field in the mutation.
func (m *AlertRuleTemplateMutation) IsBuiltIn() (r bool, exists bool) {
	v := m.is_built_in
	if v == nil {
		return
	}
	return *v, true
}

// OldIsBuiltIn returns the old "is_built_in" field's value of the AlertRuleTemplate entity.
// If the AlertRuleTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertRuleTemplateMutation) OldIsBuiltIn(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsBuiltIn is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsBuiltIn requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsBuiltIn: %w", err)
	}
	return oldValue.IsBuiltIn, nil
}

// ResetIsBuiltIn resets all changes to the "is_built_in" field.
func (m *AlertRuleTemplateMutation) ResetIsBuiltIn() {
	m.is_built_in = nil
}

// SetVersion sets the "version" field.
func (m *AlertRuleTemplateMutation) SetVersion(s string) {
	m.version = &s
}

// Version returns the value of the "version" field in the mutation.
func (m *AlertRuleTemplateMutation) Version() (r string, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the AlertRuleTemplate entity.
// If the AlertRuleTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertRuleTemplateMutation) OldVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// ResetVersion resets all changes to the "version" field.
func (m *AlertRuleTemplateMutation) ResetVersion() {
	m.version = nil
}

// SetUsageCount sets the "usage_count" field.
func (m *AlertRuleTemplateMutation) SetUsageCount(i int) {
	m.usage_count = &i
	m.addusage_count = nil
}

// UsageCount returns the value of the "usage_count" field in the mutation.
func (m *AlertRuleTemplateMutation) UsageCount() (r int, exists bool) {
	v := m.usage_count
	if v == nil {
		return
	}
	return *v, true
}

// OldUsageCount returns the old "usage_count" field's value of the AlertRuleTemplate entity.
// If the AlertRuleTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertRuleTemplateMutation) OldUsageCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsageCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsageCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsageCount: %w", err)
	}
	return oldValue.UsageCount, nil
}

// AddUsageCount adds i to the "usage_count" field.
func (m *AlertRuleTemplateMutation) AddUsageCount(i int) {
	if m.addusage_count != nil {
		*m.addusage_count += i
	} else {
		m.addusage_count = &i
	}
}

// AddedUsageCount returns the value that was added to the "usage_count" field in this mutation.
func (m *AlertRuleTemplateMutation) AddedUsageCount() (r int, exists bool) {
	v := m.addusage_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetUsageCount resets all changes to the "usage_count" field.
func (m *AlertRuleTemplateMutation) ResetUsageCount() {
	m.usage_count = nil
	m.addusage_count = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *AlertRuleTemplateMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AlertRuleTemplateMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the AlertRuleTemplate entity.
// If the AlertRuleTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertRuleTemplateMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AlertRuleTemplateMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AlertRuleTemplateMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AlertRuleTemplateMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the AlertRuleTemplate entity.
// If the AlertRuleTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertRuleTemplateMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AlertRuleTemplateMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// Where appends a list predicates to the AlertRuleTemplateMutation builder.
func (m *AlertRuleTemplateMutation) Where(ps ...predicate.AlertRuleTemplate) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AlertRuleTemplateMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AlertRuleTemplateMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AlertRuleTemplate, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AlertRuleTemplateMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AlertRuleTemplateMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AlertRuleTemplate).
func (m *AlertRuleTemplateMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AlertRuleTemplateMutation) Fields() []string {
	fields := make([]string, 0, 14)
	if m.name != nil {
		fields = append(fields, alertruletemplate.FieldName)
	}
	if m.description != nil {
		fields = append(fields, alertruletemplate.FieldDescription)
	}
	if m.category != nil {
		fields = append(fields, alertruletemplate.FieldCategory)
	}
	if m.event_type != nil {
		fields = append(fields, alertruletemplate.FieldEventType)
	}
	if m.severity != nil {
		fields = append(fields, alertruletemplate.FieldSeverity)
	}
	if m.variables != nil {
		fields = append(fields, alertruletemplate.FieldVariables)
	}
	if m.conditions != nil {
		fields = append(fields, alertruletemplate.FieldConditions)
	}
	if m.throttle != nil {
		fields = append(fields, alertruletemplate.FieldThrottle)
	}
	if m.channels != nil {
		fields = append(fields, alertruletemplate.FieldChannels)
	}
	if m.is_built_in != nil {
		fields = append(fields, alertruletemplate.FieldIsBuiltIn)
	}
	if m.version != nil {
		fields = append(fields, alertruletemplate.FieldVersion)
	}
	if m.usage_count != nil {
		fields = append(fields, alertruletemplate.FieldUsageCount)
	}
	if m.created_at != nil {
		fields = append(fields, alertruletemplate.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, alertruletemplate.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AlertRuleTemplateMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case alertruletemplate.FieldName:
		return m.Name()
	case alertruletemplate.FieldDescription:
		return m.Description()
	case alertruletemplate.FieldCategory:
		return m.Category()
	case alertruletemplate.FieldEventType:
		return m.EventType()
	case alertruletemplate.FieldSeverity:
		return m.Severity()
	case alertruletemplate.FieldVariables:
		return m.Variables()
	case alertruletemplate.FieldConditions:
		return m.Conditions()
	case alertruletemplate.FieldThrottle:
		return m.Throttle()
	case alertruletemplate.FieldChannels:
		return m.Channels()
	case alertruletemplate.FieldIsBuiltIn:
		return m.IsBuiltIn()
	case alertruletemplate.FieldVersion:
		return m.Version()
	case alertruletemplate.FieldUsageCount:
		return m.UsageCount()
	case alertruletemplate.FieldCreatedAt:
		return m.CreatedAt()
	case alertruletemplate.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AlertRuleTemplateMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case alertruletemplate.FieldName:
		return m.OldName(ctx)
	case alertruletemplate.FieldDescription:
		return m.OldDescription(ctx)
	case alertruletemplate.FieldCategory:
		return m.OldCategory(ctx)
	case alertruletemplate.FieldEventType:
		return m.OldEventType(ctx)
	case alertruletemplate.FieldSeverity:
		return m.OldSeverity(ctx)
	case alertruletemplate.FieldVariables:
		return m.OldVariables(ctx)
	case alertruletemplate.FieldConditions:
		return m.OldConditions(ctx)
	case alertruletemplate.FieldThrottle:
		return m.OldThrottle(ctx)
	case alertruletemplate.FieldChannels:
		return m.OldChannels(ctx)
	case alertruletemplate.FieldIsBuiltIn:
		return m.OldIsBuiltIn(ctx)
	case alertruletemplate.FieldVersion:
		return m.OldVersion(ctx)
	case alertruletemplate.FieldUsageCount:
		return m.OldUsageCount(ctx)
	case alertruletemplate.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case alertruletemplate.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown AlertRuleTemplate field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AlertRuleTemplateMutation) SetField(name string, value ent.Value) error {
	switch name {
	case alertruletemplate.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case alertruletemplate.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case alertruletemplate.FieldCategory:
		v, ok := value.(alertruletemplate.Category)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategory(v)
		return nil
	case alertruletemplate.FieldEventType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEventType(v)
		return nil
	case alertruletemplate.FieldSeverity:
		v, ok := value.(alertruletemplate.Severity)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSeverity(v)
		return nil
	case alertruletemplate.FieldVariables:
		v, ok := value.([]map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVariables(v)
		return nil
	case alertruletemplate.FieldConditions:
		v, ok := value.([]map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConditions(v)
		return nil
	case alertruletemplate.FieldThrottle:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetThrottle(v)
		return nil
	case alertruletemplate.FieldChannels:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChannels(v)
		return nil
	case alertruletemplate.FieldIsBuiltIn:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsBuiltIn(v)
		return nil
	case alertruletemplate.FieldVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case alertruletemplate.FieldUsageCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsageCount(v)
		return nil
	case alertruletemplate.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case alertruletemplate.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown AlertRuleTemplate field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AlertRuleTemplateMutation) AddedFields() []string {
	var fields []string
	if m.addusage_count != nil {
		fields = append(fields, alertruletemplate.FieldUsageCount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AlertRuleTemplateMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case alertruletemplate.FieldUsageCount:
		return m.AddedUsageCount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AlertRuleTemplateMutation) AddField(name string, value ent.Value) error {
	switch name {
	case alertruletemplate.FieldUsageCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUsageCount(v)
		return nil
	}
	return fmt.Errorf("unknown AlertRuleTemplate numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AlertRuleTemplateMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(alertruletemplate.FieldVariables) {
		fields = append(fields, alertruletemplate.FieldVariables)
	}
	if m.FieldCleared(alertruletemplate.FieldConditions) {
		fields = append(fields, alertruletemplate.FieldConditions)
	}
	if m.FieldCleared(alertruletemplate.FieldThrottle) {
		fields = append(fields, alertruletemplate.FieldThrottle)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AlertRuleTemplateMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AlertRuleTemplateMutation) ClearField(name string) error {
	switch name {
	case alertruletemplate.FieldVariables:
		m.ClearVariables()
		return nil
	case alertruletemplate.FieldConditions:
		m.ClearConditions()
		return nil
	case alertruletemplate.FieldThrottle:
		m.ClearThrottle()
		return nil
	}
	return fmt.Errorf("unknown AlertRuleTemplate nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AlertRuleTemplateMutation) ResetField(name string) error {
	switch name {
	case alertruletemplate.FieldName:
		m.ResetName()
		return nil
	case alertruletemplate.FieldDescription:
		m.ResetDescription()
		return nil
	case alertruletemplate.FieldCategory:
		m.ResetCategory()
		return nil
	case alertruletemplate.FieldEventType:
		m.ResetEventType()
		return nil
	case alertruletemplate.FieldSeverity:
		m.ResetSeverity()
		return nil
	case alertruletemplate.FieldVariables:
		m.ResetVariables()
		return nil
	case alertruletemplate.FieldConditions:
		m.ResetConditions()
		return nil
	case alertruletemplate.FieldThrottle:
		m.ResetThrottle()
		return nil
	case alertruletemplate.FieldChannels:
		m.ResetChannels()
		return nil
	case alertruletemplate.FieldIsBuiltIn:
		m.ResetIsBuiltIn()
		return nil
	case alertruletemplate.FieldVersion:
		m.ResetVersion()
		return nil
	case alertruletemplate.FieldUsageCount:
		m.ResetUsageCount()
		return nil
	case alertruletemplate.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case alertruletemplate.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown AlertRuleTemplate field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AlertRuleTemplateMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AlertRuleTemplateMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AlertRuleTemplateMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AlertRuleTemplateMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AlertRuleTemplateMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AlertRuleTemplateMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AlertRuleTemplateMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown AlertRuleTemplate unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AlertRuleTemplateMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown AlertRuleTemplate edge %s", name)
}

// AlertTemplateMutation represents an operation that mutates the AlertTemplate nodes in the graph.
type AlertTemplateMutation struct {
	config
	op               Op
	typ              string
	id               *string
	event_type       *string
	channel          *alerttemplate.Channel
	subject_template *string
	body_template    *string
	is_default       *bool
	created_at       *time.Time
	updated_at       *time.Time
	clearedFields    map[string]struct{}
	done             bool
	oldValue         func(context.Context) (*AlertTemplate, error)
	predicates       []predicate.AlertTemplate
}

var _ ent.Mutation = (*AlertTemplateMutation)(nil)

// alerttemplateOption allows management of the mutation configuration using functional options.
type alerttemplateOption func(*AlertTemplateMutation)

// newAlertTemplateMutation creates new mutation for the AlertTemplate entity.
func newAlertTemplateMutation(c config, op Op, opts ...alerttemplateOption) *AlertTemplateMutation {
	m := &AlertTemplateMutation{
		config:        c,
		op:            op,
		typ:           TypeAlertTemplate,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAlertTemplateID sets the ID field of the mutation.
func withAlertTemplateID(id string) alerttemplateOption {
	return func(m *AlertTemplateMutation) {
		var (
			err   error
			once  sync.Once
			value *AlertTemplate
		)
		m.oldValue = func(ctx context.Context) (*AlertTemplate, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AlertTemplate.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAlertTemplate sets the old AlertTemplate of the mutation.
func withAlertTemplate(node *AlertTemplate) alerttemplateOption {
	return func(m *AlertTemplateMutation) {
		m.oldValue = func(context.Context) (*AlertTemplate, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AlertTemplateMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AlertTemplateMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AlertTemplate entities.
func (m *AlertTemplateMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AlertTemplateMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AlertTemplateMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AlertTemplate.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetEventType sets the "event_type" field.
func (m *AlertTemplateMutation) SetEventType(s string) {
	m.event_type = &s
}

// EventType returns the value of the "event_type" field in the mutation.
func (m *AlertTemplateMutation) EventType() (r string, exists bool) {
	v := m.event_type
	if v == nil {
		return
	}
	return *v, true
}

// OldEventType returns the old "event_type" field's value of the AlertTemplate entity.
// If the AlertTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertTemplateMutation) OldEventType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEventType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEventType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEventType: %w", err)
	}
	return oldValue.EventType, nil
}

// ResetEventType resets all changes to the "event_type" field.
func (m *AlertTemplateMutation) ResetEventType() {
	m.event_type = nil
}

// SetChannel sets the "channel" field.
func (m *AlertTemplateMutation) SetChannel(a alerttemplate.Channel) {
	m.channel = &a
}

// Channel returns the value of the "channel" field in the mutation.
func (m *AlertTemplateMutation) Channel() (r alerttemplate.Channel, exists bool) {
	v := m.channel
	if v == nil {
		return
	}
	return *v, true
}

// OldChannel returns the old "channel" field's value of the AlertTemplate entity.
// If the AlertTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertTemplateMutation) OldChannel(ctx context.Context) (v alerttemplate.Channel, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChannel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChannel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChannel: %w", err)
	}
	return oldValue.Channel, nil
}

// ResetChannel resets all changes to the "channel" field.
func (m *AlertTemplateMutation) ResetChannel() {
	m.channel = nil
}

// SetSubjectTemplate sets the "subject_template" field.
func (m *AlertTemplateMutation) SetSubjectTemplate(s string) {
	m.subject_template = &s
}

// SubjectTemplate returns the value of the "subject_template" field in the mutation.
func (m *AlertTemplateMutation) SubjectTemplate() (r string, exists bool) {
	v := m.subject_template
	if v == nil {
		return
	}
	return *v, true
}

// OldSubjectTemplate returns the old "subject_template" field's value of the AlertTemplate entity.
// If the AlertTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertTemplateMutation) OldSubjectTemplate(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSubjectTemplate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSubjectTemplate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubjectTemplate: %w", err)
	}
	return oldValue.SubjectTemplate, nil
}

// ClearSubjectTemplate clears the value of the "subject_template" field.
func (m *AlertTemplateMutation) ClearSubjectTemplate() {
	m.subject_template = nil
	m.clearedFields[alerttemplate.FieldSubjectTemplate] = struct{}{}
}

// SubjectTemplateCleared returns if the "subject_template" field was cleared in this mutation.
func (m *AlertTemplateMutation) SubjectTemplateCleared() bool {
	_, ok := m.clearedFields[alerttemplate.FieldSubjectTemplate]
	return ok
}

// ResetSubjectTemplate resets all changes to the "subject_template" field.
func (m *AlertTemplateMutation) ResetSubjectTemplate() {
	m.subject_template = nil
	delete(m.clearedFields, alerttemplate.FieldSubjectTemplate)
}

// SetBodyTemplate sets the "body_template" field.
func (m *AlertTemplateMutation) SetBodyTemplate(s string) {
	m.body_template = &s
}

// BodyTemplate returns the value of the "body_template" field in the mutation.
func (m *AlertTemplateMutation) BodyTemplate() (r string, exists bool) {
	v := m.body_template
	if v == nil {
		return
	}
	return *v, true
}

// OldBodyTemplate returns the old "body_template" field's value of the AlertTemplate entity.
// If the AlertTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertTemplateMutation) OldBodyTemplate(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBodyTemplate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBodyTemplate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBodyTemplate: %w", err)
	}
	return oldValue.BodyTemplate, nil
}

// ResetBodyTemplate resets all changes to the "body_template" field.
func (m *AlertTemplateMutation) ResetBodyTemplate() {
	m.body_template = nil
}

// SetIsDefault sets the "is_default" field.
func (m *AlertTemplateMutation) SetIsDefault(b bool) {
	m.is_default = &b
}

// IsDefault returns the value of the "is_default" field in the mutation.
func (m *AlertTemplateMutation) IsDefault() (r bool, exists bool) {
	v := m.is_default
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDefault returns the old "is_default" field's value of the AlertTemplate entity.
// If the AlertTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertTemplateMutation) OldIsDefault(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsDefault is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsDefault requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDefault: %w", err)
	}
	return oldValue.IsDefault, nil
}

// ResetIsDefault resets all changes to the "is_default" field.
func (m *AlertTemplateMutation) ResetIsDefault() {
	m.is_default = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *AlertTemplateMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AlertTemplateMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the AlertTemplate entity.
// If the AlertTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertTemplateMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AlertTemplateMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AlertTemplateMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AlertTemplateMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the AlertTemplate entity.
// If the AlertTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertTemplateMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AlertTemplateMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// Where appends a list predicates to the AlertTemplateMutation builder.
func (m *AlertTemplateMutation) Where(ps ...predicate.AlertTemplate) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AlertTemplateMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AlertTemplateMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AlertTemplate, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AlertTemplateMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AlertTemplateMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AlertTemplate).
func (m *AlertTemplateMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AlertTemplateMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.event_type != nil {
		fields = append(fields, alerttemplate.FieldEventType)
	}
	if m.channel != nil {
		fields = append(fields, alerttemplate.FieldChannel)
	}
	if m.subject_template != nil {
		fields = append(fields, alerttemplate.FieldSubjectTemplate)
	}
	if m.body_template != nil {
		fields = append(fields, alerttemplate.FieldBodyTemplate)
	}
	if m.is_default != nil {
		fields = append(fields, alerttemplate.FieldIsDefault)
	}
	if m.created_at != nil {
		fields = append(fields, alerttemplate.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, alerttemplate.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AlertTemplateMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case alerttemplate.FieldEventType:
		return m.EventType()
	case alerttemplate.FieldChannel:
		return m.Channel()
	case alerttemplate.FieldSubjectTemplate:
		return m.SubjectTemplate()
	case alerttemplate.FieldBodyTemplate:
		return m.BodyTemplate()
	case alerttemplate.FieldIsDefault:
		return m.IsDefault()
	case alerttemplate.FieldCreatedAt:
		return m.CreatedAt()
	case alerttemplate.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AlertTemplateMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case alerttemplate.FieldEventType:
		return m.OldEventType(ctx)
	case alerttemplate.FieldChannel:
		return m.OldChannel(ctx)
	case alerttemplate.FieldSubjectTemplate:
		return m.OldSubjectTemplate(ctx)
	case alerttemplate.FieldBodyTemplate:
		return m.OldBodyTemplate(ctx)
	case alerttemplate.FieldIsDefault:
		return m.OldIsDefault(ctx)
	case alerttemplate.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case alerttemplate.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown AlertTemplate field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AlertTemplateMutation) SetField(name string, value ent.Value) error {
	switch name {
	case alerttemplate.FieldEventType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEventType(v)
		return nil
	case alerttemplate.FieldChannel:
		v, ok := value.(alerttemplate.Channel)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChannel(v)
		return nil
	case alerttemplate.FieldSubjectTemplate:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubjectTemplate(v)
		return nil
	case alerttemplate.FieldBodyTemplate:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBodyTemplate(v)
		return nil
	case alerttemplate.FieldIsDefault:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDefault(v)
		return nil
	case alerttemplate.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case alerttemplate.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown AlertTemplate field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AlertTemplateMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AlertTemplateMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AlertTemplateMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown AlertTemplate numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AlertTemplateMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(alerttemplate.FieldSubjectTemplate) {
		fields = append(fields, alerttemplate.FieldSubjectTemplate)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AlertTemplateMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AlertTemplateMutation) ClearField(name string) error {
	switch name {
	case alerttemplate.FieldSubjectTemplate:
		m.ClearSubjectTemplate()
		return nil
	}
	return fmt.Errorf("unknown AlertTemplate nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AlertTemplateMutation) ResetField(name string) error {
	switch name {
	case alerttemplate.FieldEventType:
		m.ResetEventType()
		return nil
	case alerttemplate.FieldChannel:
		m.ResetChannel()
		return nil
	case alerttemplate.FieldSubjectTemplate:
		m.ResetSubjectTemplate()
		return nil
	case alerttemplate.FieldBodyTemplate:
		m.ResetBodyTemplate()
		return nil
	case alerttemplate.FieldIsDefault:
		m.ResetIsDefault()
		return nil
	case alerttemplate.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case alerttemplate.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown AlertTemplate field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AlertTemplateMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AlertTemplateMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AlertTemplateMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AlertTemplateMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AlertTemplateMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AlertTemplateMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AlertTemplateMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown AlertTemplate unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AlertTemplateMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown AlertTemplate edge %s", name)
}

// ChainHopMutation represents an operation that mutates the ChainHop nodes in the graph.
type ChainHopMutation struct {
	config
	op                  Op
	typ                 string
	id                  *string
	hop_order           *int
	addhop_order        *int
	routing_mark        *string
	mangle_rule_id      *string
	route_table_name    *string
	route_id            *string
	kill_switch_rule_id *string
	kill_switch_active  *bool
	created_at          *time.Time
	clearedFields       map[string]struct{}
	chain               *string
	clearedchain        bool
	_interface          *string
	cleared_interface   bool
	done                bool
	oldValue            func(context.Context) (*ChainHop, error)
	predicates          []predicate.ChainHop
}

var _ ent.Mutation = (*ChainHopMutation)(nil)

// chainhopOption allows management of the mutation configuration using functional options.
type chainhopOption func(*ChainHopMutation)

// newChainHopMutation creates new mutation for the ChainHop entity.
func newChainHopMutation(c config, op Op, opts ...chainhopOption) *ChainHopMutation {
	m := &ChainHopMutation{
		config:        c,
		op:            op,
		typ:           TypeChainHop,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withChainHopID sets the ID field of the mutation.
func withChainHopID(id string) chainhopOption {
	return func(m *ChainHopMutation) {
		var (
			err   error
			once  sync.Once
			value *ChainHop
		)
		m.oldValue = func(ctx context.Context) (*ChainHop, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ChainHop.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withChainHop sets the old ChainHop of the mutation.
func withChainHop(node *ChainHop) chainhopOption {
	return func(m *ChainHopMutation) {
		m.oldValue = func(context.Context) (*ChainHop, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ChainHopMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ChainHopMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ChainHop entities.
func (m *ChainHopMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ChainHopMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ChainHopMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ChainHop.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetChainID sets the "chain_id" field.
func (m *ChainHopMutation) SetChainID(s string) {
	m.chain = &s
}

// ChainID returns the value of the "chain_id" field in the mutation.
func (m *ChainHopMutation) ChainID() (r string, exists bool) {
	v := m.chain
	if v == nil {
		return
	}
	return *v, true
}

// OldChainID returns the old "chain_id" field's value of the ChainHop entity.
// If the ChainHop object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChainHopMutation) OldChainID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChainID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChainID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChainID: %w", err)
	}
	return oldValue.ChainID, nil
}

// ResetChainID resets all changes to the "chain_id" field.
func (m *ChainHopMutation) ResetChainID() {
	m.chain = nil
}

// SetHopOrder sets the "hop_order" field.
func (m *ChainHopMutation) SetHopOrder(i int) {
	m.hop_order = &i
	m.addhop_order = nil
}

// HopOrder returns the value of the "hop_order" field in the mutation.
func (m *ChainHopMutation) HopOrder() (r int, exists bool) {
	v := m.hop_order
	if v == nil {
		return
	}
	return *v, true
}

// OldHopOrder returns the old "hop_order" field's value of the ChainHop entity.
// If the ChainHop object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChainHopMutation) OldHopOrder(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHopOrder is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHopOrder requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHopOrder: %w", err)
	}
	return oldValue.HopOrder, nil
}

// AddHopOrder adds i to the "hop_order" field.
func (m *ChainHopMutation) AddHopOrder(i int) {
	if m.addhop_order != nil {
		*m.addhop_order += i
	} else {
		m.addhop_order = &i
	}
}

// AddedHopOrder returns the value that was added to the "hop_order" field in this mutation.
func (m *ChainHopMutation) AddedHopOrder() (r int, exists bool) {
	v := m.addhop_order
	if v == nil {
		return
	}
	return *v, true
}

// ResetHopOrder resets all changes to the "hop_order" field.
func (m *ChainHopMutation) ResetHopOrder() {
	m.hop_order = nil
	m.addhop_order = nil
}

// SetInterfaceID sets the "interface_id" field.
func (m *ChainHopMutation) SetInterfaceID(s string) {
	m._interface = &s
}

// InterfaceID returns the value of the "interface_id" field in the mutation.
func (m *ChainHopMutation) InterfaceID() (r string, exists bool) {
	v := m._interface
	if v == nil {
		return
	}
	return *v, true
}

// OldInterfaceID returns the old "interface_id" field's value of the ChainHop entity.
// If the ChainHop object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChainHopMutation) OldInterfaceID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInterfaceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInterfaceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInterfaceID: %w", err)
	}
	return oldValue.InterfaceID, nil
}

// ResetInterfaceID resets all changes to the "interface_id" field.
func (m *ChainHopMutation) ResetInterfaceID() {
	m._interface = nil
}

// SetRoutingMark sets the "routing_mark" field.
func (m *ChainHopMutation) SetRoutingMark(s string) {
	m.routing_mark = &s
}

// RoutingMark returns the value of the "routing_mark" field in the mutation.
func (m *ChainHopMutation) RoutingMark() (r string, exists bool) {
	v := m.routing_mark
	if v == nil {
		return
	}
	return *v, true
}

// OldRoutingMark returns the old "routing_mark" field's value of the ChainHop entity.
// If the ChainHop object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChainHopMutation) OldRoutingMark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRoutingMark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRoutingMark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRoutingMark: %w", err)
	}
	return oldValue.RoutingMark, nil
}

// ResetRoutingMark resets all changes to the "routing_mark" field.
func (m *ChainHopMutation) ResetRoutingMark() {
	m.routing_mark = nil
}

// SetMangleRuleID sets the "mangle_rule_id" field.
func (m *ChainHopMutation) SetMangleRuleID(s string) {
	m.mangle_rule_id = &s
}

// MangleRuleID returns the value of the "mangle_rule_id" field in the mutation.
func (m *ChainHopMutation) MangleRuleID() (r string, exists bool) {
	v := m.mangle_rule_id
	if v == nil {
		return
	}
	return *v, true
}

// OldMangleRuleID returns the old "mangle_rule_id" field's value of the ChainHop entity.
// If the ChainHop object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChainHopMutation) OldMangleRuleID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMangleRuleID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMangleRuleID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMangleRuleID: %w", err)
	}
	return oldValue.MangleRuleID, nil
}

// ClearMangleRuleID clears the value of the "mangle_rule_id" field.
func (m *ChainHopMutation) ClearMangleRuleID() {
	m.mangle_rule_id = nil
	m.clearedFields[chainhop.FieldMangleRuleID] = struct{}{}
}

// MangleRuleIDCleared returns if the "mangle_rule_id" field was cleared in this mutation.
func (m *ChainHopMutation) MangleRuleIDCleared() bool {
	_, ok := m.clearedFields[chainhop.FieldMangleRuleID]
	return ok
}

// ResetMangleRuleID resets all changes to the "mangle_rule_id" field.
func (m *ChainHopMutation) ResetMangleRuleID() {
	m.mangle_rule_id = nil
	delete(m.clearedFields, chainhop.FieldMangleRuleID)
}

// SetRouteTableName sets the "route_table_name" field.
func (m *ChainHopMutation) SetRouteTableName(s string) {
	m.route_table_name = &s
}

// RouteTableName returns the value of the "route_table_name" field in the mutation.
func (m *ChainHopMutation) RouteTableName() (r string, exists bool) {
	v := m.route_table_name
	if v == nil {
		return
	}
	return *v, true
}

// OldRouteTableName returns the old "route_table_name" field's value of the ChainHop entity.
// If the ChainHop object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChainHopMutation) OldRouteTableName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRouteTableName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRouteTableName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRouteTableName: %w", err)
	}
	return oldValue.RouteTableName, nil
}

// ResetRouteTableName resets all changes to the "route_table_name" field.
func (m *ChainHopMutation) ResetRouteTableName() {
	m.route_table_name = nil
}

// SetRouteID sets the "route_id" field.
func (m *ChainHopMutation) SetRouteID(s string) {
	m.route_id = &s
}

// RouteID returns the value of the "route_id" field in the mutation.
func (m *ChainHopMutation) RouteID() (r string, exists bool) {
	v := m.route_id
	if v == nil {
		return
	}
	return *v, true
}

// OldRouteID returns the old "route_id" field's value of the ChainHop entity.
// If the ChainHop object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChainHopMutation) OldRouteID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRouteID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRouteID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRouteID: %w", err)
	}
	return oldValue.RouteID, nil
}

// ClearRouteID clears the value of the "route_id" field.
func (m *ChainHopMutation) ClearRouteID() {
	m.route_id = nil
	m.clearedFields[chainhop.FieldRouteID] = struct{}{}
}

// RouteIDCleared returns if the "route_id" field was cleared in this mutation.
func (m *ChainHopMutation) RouteIDCleared() bool {
	_, ok := m.clearedFields[chainhop.FieldRouteID]
	return ok
}

// ResetRouteID resets all changes to the "route_id" field.
func (m *ChainHopMutation) ResetRouteID() {
	m.route_id = nil
	delete(m.clearedFields, chainhop.FieldRouteID)
}

// SetKillSwitchRuleID sets the "kill_switch_rule_id" field.
func (m *ChainHopMutation) SetKillSwitchRuleID(s string) {
	m.kill_switch_rule_id = &s
}

// KillSwitchRuleID returns the value of the "kill_switch_rule_id" field in the mutation.
func (m *ChainHopMutation) KillSwitchRuleID() (r string, exists bool) {
	v := m.kill_switch_rule_id
	if v == nil {
		return
	}
	return *v, true
}

// OldKillSwitchRuleID returns the old "kill_switch_rule_id" field's value of the ChainHop entity.
// If the ChainHop object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChainHopMutation) OldKillSwitchRuleID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKillSwitchRuleID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKillSwitchRuleID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKillSwitchRuleID: %w", err)
	}
	return oldValue.KillSwitchRuleID, nil
}

// ClearKillSwitchRuleID clears the value of the "kill_switch_rule_id" field.
func (m *ChainHopMutation) ClearKillSwitchRuleID() {
	m.kill_switch_rule_id = nil
	m.clearedFields[chainhop.FieldKillSwitchRuleID] = struct{}{}
}

// KillSwitchRuleIDCleared returns if the "kill_switch_rule_id" field was cleared in this mutation.
func (m *ChainHopMutation) KillSwitchRuleIDCleared() bool {
	_, ok := m.clearedFields[chainhop.FieldKillSwitchRuleID]
	return ok
}

// ResetKillSwitchRuleID resets all changes to the "kill_switch_rule_id" field.
func (m *ChainHopMutation) ResetKillSwitchRuleID() {
	m.kill_switch_rule_id = nil
	delete(m.clearedFields, chainhop.FieldKillSwitchRuleID)
}

// SetKillSwitchActive sets the "kill_switch_active" field.
func (m *ChainHopMutation) SetKillSwitchActive(b bool) {
	m.kill_switch_active = &b
}

// KillSwitchActive returns the value of the "kill_switch_active" field in the mutation.
func (m *ChainHopMutation) KillSwitchActive() (r bool, exists bool) {
	v := m.kill_switch_active
	if v == nil {
		return
	}
	return *v, true
}

// OldKillSwitchActive returns the old "kill_switch_active" field's value of the ChainHop entity.
// If the ChainHop object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChainHopMutation) OldKillSwitchActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKillSwitchActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKillSwitchActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKillSwitchActive: %w", err)
	}
	return oldValue.KillSwitchActive, nil
}

// ResetKillSwitchActive resets all changes to the "kill_switch_active" field.
func (m *ChainHopMutation) ResetKillSwitchActive() {
	m.kill_switch_active = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ChainHopMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ChainHopMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ChainHop entity.
// If the ChainHop object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChainHopMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ChainHopMutation) ResetCreatedAt() {
	m.created_at = nil
}

// ClearChain clears the "chain" edge to the RoutingChain entity.
func (m *ChainHopMutation) ClearChain() {
	m.clearedchain = true
	m.clearedFields[chainhop.FieldChainID] = struct{}{}
}

// ChainCleared reports if the "chain" edge to the RoutingChain entity was cleared.
func (m *ChainHopMutation) ChainCleared() bool {
	return m.clearedchain
}

// ChainIDs returns the "chain" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ChainID instead. It exists only for internal usage by the builders.
func (m *ChainHopMutation) ChainIDs() (ids []string) {
	if id := m.chain; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetChain resets all changes to the "chain" edge.
func (m *ChainHopMutation) ResetChain() {
	m.chain = nil
	m.clearedchain = false
}

// ClearInterface clears the "interface" edge to the VirtualInterface entity.
func (m *ChainHopMutation) ClearInterface() {
	m.cleared_interface = true
	m.clearedFields[chainhop.FieldInterfaceID] = struct{}{}
}

// InterfaceCleared reports if the "interface" edge to the VirtualInterface entity was cleared.
func (m *ChainHopMutation) InterfaceCleared() bool {
	return m.cleared_interface
}

// InterfaceIDs returns the "interface" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// InterfaceID instead. It exists only for internal usage by the builders.
func (m *ChainHopMutation) InterfaceIDs() (ids []string) {
	if id := m._interface; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetInterface resets all changes to the "interface" edge.
func (m *ChainHopMutation) ResetInterface() {
	m._interface = nil
	m.cleared_interface = false
}

// Where appends a list predicates to the ChainHopMutation builder.
func (m *ChainHopMutation) Where(ps ...predicate.ChainHop) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ChainHopMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ChainHopMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ChainHop, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ChainHopMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ChainHopMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ChainHop).
func (m *ChainHopMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ChainHopMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.chain != nil {
		fields = append(fields, chainhop.FieldChainID)
	}
	if m.hop_order != nil {
		fields = append(fields, chainhop.FieldHopOrder)
	}
	if m._interface != nil {
		fields = append(fields, chainhop.FieldInterfaceID)
	}
	if m.routing_mark != nil {
		fields = append(fields, chainhop.FieldRoutingMark)
	}
	if m.mangle_rule_id != nil {
		fields = append(fields, chainhop.FieldMangleRuleID)
	}
	if m.route_table_name != nil {
		fields = append(fields, chainhop.FieldRouteTableName)
	}
	if m.route_id != nil {
		fields = append(fields, chainhop.FieldRouteID)
	}
	if m.kill_switch_rule_id != nil {
		fields = append(fields, chainhop.FieldKillSwitchRuleID)
	}
	if m.kill_switch_active != nil {
		fields = append(fields, chainhop.FieldKillSwitchActive)
	}
	if m.created_at != nil {
		fields = append(fields, chainhop.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ChainHopMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case chainhop.FieldChainID:
		return m.ChainID()
	case chainhop.FieldHopOrder:
		return m.HopOrder()
	case chainhop.FieldInterfaceID:
		return m.InterfaceID()
	case chainhop.FieldRoutingMark:
		return m.RoutingMark()
	case chainhop.FieldMangleRuleID:
		return m.MangleRuleID()
	case chainhop.FieldRouteTableName:
		return m.RouteTableName()
	case chainhop.FieldRouteID:
		return m.RouteID()
	case chainhop.FieldKillSwitchRuleID:
		return m.KillSwitchRuleID()
	case chainhop.FieldKillSwitchActive:
		return m.KillSwitchActive()
	case chainhop.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ChainHopMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case chainhop.FieldChainID:
		return m.OldChainID(ctx)
	case chainhop.FieldHopOrder:
		return m.OldHopOrder(ctx)
	case chainhop.FieldInterfaceID:
		return m.OldInterfaceID(ctx)
	case chainhop.FieldRoutingMark:
		return m.OldRoutingMark(ctx)
	case chainhop.FieldMangleRuleID:
		return m.OldMangleRuleID(ctx)
	case chainhop.FieldRouteTableName:
		return m.OldRouteTableName(ctx)
	case chainhop.FieldRouteID:
		return m.OldRouteID(ctx)
	case chainhop.FieldKillSwitchRuleID:
		return m.OldKillSwitchRuleID(ctx)
	case chainhop.FieldKillSwitchActive:
		return m.OldKillSwitchActive(ctx)
	case chainhop.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown ChainHop field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ChainHopMutation) SetField(name string, value ent.Value) error {
	switch name {
	case chainhop.FieldChainID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChainID(v)
		return nil
	case chainhop.FieldHopOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHopOrder(v)
		return nil
	case chainhop.FieldInterfaceID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInterfaceID(v)
		return nil
	case chainhop.FieldRoutingMark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRoutingMark(v)
		return nil
	case chainhop.FieldMangleRuleID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMangleRuleID(v)
		return nil
	case chainhop.FieldRouteTableName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRouteTableName(v)
		return nil
	case chainhop.FieldRouteID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRouteID(v)
		return nil
	case chainhop.FieldKillSwitchRuleID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKillSwitchRuleID(v)
		return nil
	case chainhop.FieldKillSwitchActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKillSwitchActive(v)
		return nil
	case chainhop.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown ChainHop field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ChainHopMutation) AddedFields() []string {
	var fields []string
	if m.addhop_order != nil {
		fields = append(fields, chainhop.FieldHopOrder)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ChainHopMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case chainhop.FieldHopOrder:
		return m.AddedHopOrder()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ChainHopMutation) AddField(name string, value ent.Value) error {
	switch name {
	case chainhop.FieldHopOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddHopOrder(v)
		return nil
	}
	return fmt.Errorf("unknown ChainHop numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ChainHopMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(chainhop.FieldMangleRuleID) {
		fields = append(fields, chainhop.FieldMangleRuleID)
	}
	if m.FieldCleared(chainhop.FieldRouteID) {
		fields = append(fields, chainhop.FieldRouteID)
	}
	if m.FieldCleared(chainhop.FieldKillSwitchRuleID) {
		fields = append(fields, chainhop.FieldKillSwitchRuleID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ChainHopMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ChainHopMutation) ClearField(name string) error {
	switch name {
	case chainhop.FieldMangleRuleID:
		m.ClearMangleRuleID()
		return nil
	case chainhop.FieldRouteID:
		m.ClearRouteID()
		return nil
	case chainhop.FieldKillSwitchRuleID:
		m.ClearKillSwitchRuleID()
		return nil
	}
	return fmt.Errorf("unknown ChainHop nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ChainHopMutation) ResetField(name string) error {
	switch name {
	case chainhop.FieldChainID:
		m.ResetChainID()
		return nil
	case chainhop.FieldHopOrder:
		m.ResetHopOrder()
		return nil
	case chainhop.FieldInterfaceID:
		m.ResetInterfaceID()
		return nil
	case chainhop.FieldRoutingMark:
		m.ResetRoutingMark()
		return nil
	case chainhop.FieldMangleRuleID:
		m.ResetMangleRuleID()
		return nil
	case chainhop.FieldRouteTableName:
		m.ResetRouteTableName()
		return nil
	case chainhop.FieldRouteID:
		m.ResetRouteID()
		return nil
	case chainhop.FieldKillSwitchRuleID:
		m.ResetKillSwitchRuleID()
		return nil
	case chainhop.FieldKillSwitchActive:
		m.ResetKillSwitchActive()
		return nil
	case chainhop.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown ChainHop field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ChainHopMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.chain != nil {
		edges = append(edges, chainhop.EdgeChain)
	}
	if m._interface != nil {
		edges = append(edges, chainhop.EdgeInterface)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ChainHopMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case chainhop.EdgeChain:
		if id := m.chain; id != nil {
			return []ent.Value{*id}
		}
	case chainhop.EdgeInterface:
		if id := m._interface; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ChainHopMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ChainHopMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ChainHopMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedchain {
		edges = append(edges, chainhop.EdgeChain)
	}
	if m.cleared_interface {
		edges = append(edges, chainhop.EdgeInterface)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ChainHopMutation) EdgeCleared(name string) bool {
	switch name {
	case chainhop.EdgeChain:
		return m.clearedchain
	case chainhop.EdgeInterface:
		return m.cleared_interface
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ChainHopMutation) ClearEdge(name string) error {
	switch name {
	case chainhop.EdgeChain:
		m.ClearChain()
		return nil
	case chainhop.EdgeInterface:
		m.ClearInterface()
		return nil
	}
	return fmt.Errorf("unknown ChainHop unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ChainHopMutation) ResetEdge(name string) error {
	switch name {
	case chainhop.EdgeChain:
		m.ResetChain()
		return nil
	case chainhop.EdgeInterface:
		m.ResetInterface()
		return nil
	}
	return fmt.Errorf("unknown ChainHop edge %s", name)
}

// ConfigSnapshotMutation represents an operation that mutates the ConfigSnapshot nodes in the graph.
type ConfigSnapshotMutation struct {
	config
	op              Op
	typ             string
	id              *string
	name            *string
	description     *string
	snapshot_type   *configsnapshot.SnapshotType
	configuration   *map[string]interface{}
	resource_counts *map[string]int
	ros_version     *string
	router_model    *string
	checksum        *string
	size_bytes      *int64
	addsize_bytes   *int64
	tags            *[]string
	appendtags      []string
	pinned          *bool
	created_by      *string
	created_at      *time.Time
	expires_at      *time.Time
	clearedFields   map[string]struct{}
	done            bool
	oldValue        func(context.Context) (*ConfigSnapshot, error)
	predicates      []predicate.ConfigSnapshot
}

var _ ent.Mutation = (*ConfigSnapshotMutation)(nil)

// configsnapshotOption allows management of the mutation configuration using functional options.
type configsnapshotOption func(*ConfigSnapshotMutation)

// newConfigSnapshotMutation creates new mutation for the ConfigSnapshot entity.
func newConfigSnapshotMutation(c config, op Op, opts ...configsnapshotOption) *ConfigSnapshotMutation {
	m := &ConfigSnapshotMutation{
		config:        c,
		op:            op,
		typ:           TypeConfigSnapshot,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withConfigSnapshotID sets the ID field of the mutation.
func withConfigSnapshotID(id string) configsnapshotOption {
	return func(m *ConfigSnapshotMutation) {
		var (
			err   error
			once  sync.Once
			value *ConfigSnapshot
		)
		m.oldValue = func(ctx context.Context) (*ConfigSnapshot, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ConfigSnapshot.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withConfigSnapshot sets the old ConfigSnapshot of the mutation.
func withConfigSnapshot(node *ConfigSnapshot) configsnapshotOption {
	return func(m *ConfigSnapshotMutation) {
		m.oldValue = func(context.Context) (*ConfigSnapshot, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ConfigSnapshotMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ConfigSnapshotMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ConfigSnapshot entities.
func (m *ConfigSnapshotMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ConfigSnapshotMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ConfigSnapshotMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ConfigSnapshot.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *ConfigSnapshotMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ConfigSnapshotMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the ConfigSnapshot entity.
// If the ConfigSnapshot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConfigSnapshotMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ConfigSnapshotMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *ConfigSnapshotMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ConfigSnapshotMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the ConfigSnapshot entity.
// If the ConfigSnapshot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConfigSnapshotMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *ConfigSnapshotMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[configsnapshot.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *ConfigSnapshotMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[configsnapshot.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *ConfigSnapshotMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, configsnapshot.FieldDescription)
}

// SetSnapshotType sets the "snapshot_type" field.
func (m *ConfigSnapshotMutation) SetSnapshotType(ct configsnapshot.SnapshotType) {
	m.snapshot_type = &ct
}

// SnapshotType returns the value of the "snapshot_type" field in the mutation.
func (m *ConfigSnapshotMutation) SnapshotType() (r configsnapshot.SnapshotType, exists bool) {
	v := m.snapshot_type
	if v == nil {
		return
	}
	return *v, true
}

// OldSnapshotType returns the old "snapshot_type" field's value of the ConfigSnapshot entity.
// If the ConfigSnapshot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConfigSnapshotMutation) OldSnapshotType(ctx context.Context) (v configsnapshot.SnapshotType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSnapshotType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSnapshotType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSnapshotType: %w", err)
	}
	return oldValue.SnapshotType, nil
}

// ResetSnapshotType resets all changes to the "snapshot_type" field.
func (m *ConfigSnapshotMutation) ResetSnapshotType() {
	m.snapshot_type = nil
}

// SetConfiguration sets the "configuration" field.
func (m *ConfigSnapshotMutation) SetConfiguration(value map[string]interface{}) {
	m.configuration = &value
}

// Configuration returns the value of the "configuration" field in the mutation.
func (m *ConfigSnapshotMutation) Configuration() (r map[string]interface{}, exists bool) {
	v := m.configuration
	if v == nil {
		return
	}
	return *v, true
}

// OldConfiguration returns the old "configuration" field's value of the ConfigSnapshot entity.
// If the ConfigSnapshot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConfigSnapshotMutation) OldConfiguration(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConfiguration is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConfiguration requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConfiguration: %w", err)
	}
	return oldValue.Configuration, nil
}

// ResetConfiguration resets all changes to the "configuration" field.
func (m *ConfigSnapshotMutation) ResetConfiguration() {
	m.configuration = nil
}

// SetResourceCounts sets the "resource_counts" field.
func (m *ConfigSnapshotMutation) SetResourceCounts(value map[string]int) {
	m.resource_counts = &value
}

// ResourceCounts returns the value of the "resource_counts" field in the mutation.
func (m *ConfigSnapshotMutation) ResourceCounts() (r map[string]int, exists bool) {
	v := m.resource_counts
	if v == nil {
		return
	}
	return *v, true
}

// OldResourceCounts returns the old "resource_counts" field's value of the ConfigSnapshot entity.
// If the ConfigSnapshot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConfigSnapshotMutation) OldResourceCounts(ctx context.Context) (v map[string]int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResourceCounts is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResourceCounts requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResourceCounts: %w", err)
	}
	return oldValue.ResourceCounts, nil
}

// ClearResourceCounts clears the value of the "resource_counts" field.
func (m *ConfigSnapshotMutation) ClearResourceCounts() {
	m.resource_counts = nil
	m.clearedFields[configsnapshot.FieldResourceCounts] = struct{}{}
}

// ResourceCountsCleared returns if the "resource_counts" field was cleared in this mutation.
func (m *ConfigSnapshotMutation) ResourceCountsCleared() bool {
	_, ok := m.clearedFields[configsnapshot.FieldResourceCounts]
	return ok
}

// ResetResourceCounts resets all changes to the "resource_counts" field.
func (m *ConfigSnapshotMutation) ResetResourceCounts() {
	m.resource_counts = nil
	delete(m.clearedFields, configsnapshot.FieldResourceCounts)
}

// SetRosVersion sets the "ros_version" field.
func (m *ConfigSnapshotMutation) SetRosVersion(s string) {
	m.ros_version = &s
}

// RosVersion returns the value of the "ros_version" field in the mutation.
func (m *ConfigSnapshotMutation) RosVersion() (r string, exists bool) {
	v := m.ros_version
	if v == nil {
		return
	}
	return *v, true
}

// OldRosVersion returns the old "ros_version" field's value of the ConfigSnapshot entity.
// If the ConfigSnapshot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConfigSnapshotMutation) OldRosVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRosVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRosVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRosVersion: %w", err)
	}
	return oldValue.RosVersion, nil
}

// ClearRosVersion clears the value of the "ros_version" field.
func (m *ConfigSnapshotMutation) ClearRosVersion() {
	m.ros_version = nil
	m.clearedFields[configsnapshot.FieldRosVersion] = struct{}{}
}

// RosVersionCleared returns if the "ros_version" field was cleared in this mutation.
func (m *ConfigSnapshotMutation) RosVersionCleared() bool {
	_, ok := m.clearedFields[configsnapshot.FieldRosVersion]
	return ok
}

// ResetRosVersion resets all changes to the "ros_version" field.
func (m *ConfigSnapshotMutation) ResetRosVersion() {
	m.ros_version = nil
	delete(m.clearedFields, configsnapshot.FieldRosVersion)
}

// SetRouterModel sets the "router_model" field.
func (m *ConfigSnapshotMutation) SetRouterModel(s string) {
	m.router_model = &s
}

// RouterModel returns the value of the "router_model" field in the mutation.
func (m *ConfigSnapshotMutation) RouterModel() (r string, exists bool) {
	v := m.router_model
	if v == nil {
		return
	}
	return *v, true
}

// OldRouterModel returns the old "router_model" field's value of the ConfigSnapshot entity.
// If the ConfigSnapshot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConfigSnapshotMutation) OldRouterModel(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRouterModel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRouterModel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRouterModel: %w", err)
	}
	return oldValue.RouterModel, nil
}

// ClearRouterModel clears the value of the "router_model" field.
func (m *ConfigSnapshotMutation) ClearRouterModel() {
	m.router_model = nil
	m.clearedFields[configsnapshot.FieldRouterModel] = struct{}{}
}

// RouterModelCleared returns if the "router_model" field was cleared in this mutation.
func (m *ConfigSnapshotMutation) RouterModelCleared() bool {
	_, ok := m.clearedFields[configsnapshot.FieldRouterModel]
	return ok
}

// ResetRouterModel resets all changes to the "router_model" field.
func (m *ConfigSnapshotMutation) ResetRouterModel() {
	m.router_model = nil
	delete(m.clearedFields, configsnapshot.FieldRouterModel)
}

// SetChecksum sets the "checksum" field.
func (m *ConfigSnapshotMutation) SetChecksum(s string) {
	m.checksum = &s
}

// Checksum returns the value of the "checksum" field in the mutation.
func (m *ConfigSnapshotMutation) Checksum() (r string, exists bool) {
	v := m.checksum
	if v == nil {
		return
	}
	return *v, true
}

// OldChecksum returns the old "checksum" field's value of the ConfigSnapshot entity.
// If the ConfigSnapshot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConfigSnapshotMutation) OldChecksum(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChecksum is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChecksum requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChecksum: %w", err)
	}
	return oldValue.Checksum, nil
}

// ClearChecksum clears the value of the "checksum" field.
func (m *ConfigSnapshotMutation) ClearChecksum() {
	m.checksum = nil
	m.clearedFields[configsnapshot.FieldChecksum] = struct{}{}
}

// ChecksumCleared returns if the "checksum" field was cleared in this mutation.
func (m *ConfigSnapshotMutation) ChecksumCleared() bool {
	_, ok := m.clearedFields[configsnapshot.FieldChecksum]
	return ok
}

// ResetChecksum resets all changes to the "checksum" field.
func (m *ConfigSnapshotMutation) ResetChecksum() {
	m.checksum = nil
	delete(m.clearedFields, configsnapshot.FieldChecksum)
}

// SetSizeBytes sets the "size_bytes" field.
func (m *ConfigSnapshotMutation) SetSizeBytes(i int64) {
	m.size_bytes = &i
	m.addsize_bytes = nil
}

// SizeBytes returns the value of the "size_bytes" field in the mutation.
func (m *ConfigSnapshotMutation) SizeBytes() (r int64, exists bool) {
	v := m.size_bytes
	if v == nil {
		return
	}
	return *v, true
}

// OldSizeBytes returns the old "size_bytes" field's value of the ConfigSnapshot entity.
// If the ConfigSnapshot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConfigSnapshotMutation) OldSizeBytes(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSizeBytes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSizeBytes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSizeBytes: %w", err)
	}
	return oldValue.SizeBytes, nil
}

// AddSizeBytes adds i to the "size_bytes" field.
func (m *ConfigSnapshotMutation) AddSizeBytes(i int64) {
	if m.addsize_bytes != nil {
		*m.addsize_bytes += i
	} else {
		m.addsize_bytes = &i
	}
}

// AddedSizeBytes returns the value that was added to the "size_bytes" field in this mutation.
func (m *ConfigSnapshotMutation) AddedSizeBytes() (r int64, exists bool) {
	v := m.addsize_bytes
	if v == nil {
		return
	}
	return *v, true
}

// ClearSizeBytes clears the value of the "size_bytes" field.
func (m *ConfigSnapshotMutation) ClearSizeBytes() {
	m.size_bytes = nil
	m.addsize_bytes = nil
	m.clearedFields[configsnapshot.FieldSizeBytes] = struct{}{}
}

// SizeBytesCleared returns if the "size_bytes" field was cleared in this mutation.
func (m *ConfigSnapshotMutation) SizeBytesCleared() bool {
	_, ok := m.clearedFields[configsnapshot.FieldSizeBytes]
	return ok
}

// ResetSizeBytes resets all changes to the "size_bytes" field.
func (m *ConfigSnapshotMutation) ResetSizeBytes() {
	m.size_bytes = nil
	m.addsize_bytes = nil
	delete(m.clearedFields, configsnapshot.FieldSizeBytes)
}

// SetTags sets the "tags" field.
func (m *ConfigSnapshotMutation) SetTags(s []string) {
	m.tags = &s
	m.appendtags = nil
}

// Tags returns the value of the "tags" field in the mutation.
func (m *ConfigSnapshotMutation) Tags() (r []string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the ConfigSnapshot entity.
// If the ConfigSnapshot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConfigSnapshotMutation) OldTags(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// AppendTags adds s to the "tags" field.
func (m *ConfigSnapshotMutation) AppendTags(s []string) {
	m.appendtags = append(m.appendtags, s...)
}

// AppendedTags returns the list of values that were appended to the "tags" field in this mutation.
func (m *ConfigSnapshotMutation) AppendedTags() ([]string, bool) {
	if len(m.appendtags) == 0 {
		return nil, false
	}
	return m.appendtags, true
}

// ClearTags clears the value of the "tags" field.
func (m *ConfigSnapshotMutation) ClearTags() {
	m.tags = nil
	m.appendtags = nil
	m.clearedFields[configsnapshot.FieldTags] = struct{}{}
}

// TagsCleared returns if the "tags" field was cleared in this mutation.
func (m *ConfigSnapshotMutation) TagsCleared() bool {
	_, ok := m.clearedFields[configsnapshot.FieldTags]
	return ok
}

// ResetTags resets all changes to the "tags" field.
func (m *ConfigSnapshotMutation) ResetTags() {
	m.tags = nil
	m.appendtags = nil
	delete(m.clearedFields, configsnapshot.FieldTags)
}

// SetPinned sets the "pinned" field.
func (m *ConfigSnapshotMutation) SetPinned(b bool) {
	m.pinned = &b
}

// Pinned returns the value of the "pinned" field in the mutation.
func (m *ConfigSnapshotMutation) Pinned() (r bool, exists bool) {
	v := m.pinned
	if v == nil {
		return
	}
	return *v, true
}

// OldPinned returns the old "pinned" field's value of the ConfigSnapshot entity.
// If the ConfigSnapshot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConfigSnapshotMutation) OldPinned(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPinned is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPinned requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPinned: %w", err)
	}
	return oldValue.Pinned, nil
}

// ResetPinned resets all changes to the "pinned" field.
func (m *ConfigSnapshotMutation) ResetPinned() {
	m.pinned = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *ConfigSnapshotMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *ConfigSnapshotMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the ConfigSnapshot entity.
// If the ConfigSnapshot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConfigSnapshotMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *ConfigSnapshotMutation) ResetCreatedBy() {
	m.created_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ConfigSnapshotMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ConfigSnapshotMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ConfigSnapshot entity.
// If the ConfigSnapshot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConfigSnapshotMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ConfigSnapshotMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetExpiresAt sets the "expires_at" field.
func (m *ConfigSnapshotMutation) SetExpiresAt(t time.Time) {
	m.expires_at = &t
}

// ExpiresAt returns the value of the "expires_at" field in the mutation.
func (m *ConfigSnapshotMutation) ExpiresAt() (r time.Time, exists bool) {
	v := m.expires_at
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiresAt returns the old "expires_at" field's value of the ConfigSnapshot entity.
// If the ConfigSnapshot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConfigSnapshotMutation) OldExpiresAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiresAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiresAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiresAt: %w", err)
	}
	return oldValue.ExpiresAt, nil
}

// ClearExpiresAt clears the value of the "expires_at" field.
func (m *ConfigSnapshotMutation) ClearExpiresAt() {
	m.expires_at = nil
	m.clearedFields[configsnapshot.FieldExpiresAt] = struct{}{}
}

// ExpiresAtCleared returns if the "expires_at" field was cleared in this mutation.
func (m *ConfigSnapshotMutation) ExpiresAtCleared() bool {
	_, ok := m.clearedFields[configsnapshot.FieldExpiresAt]
	return ok
}

// ResetExpiresAt resets all changes to the "expires_at" field.
func (m *ConfigSnapshotMutation) ResetExpiresAt() {
	m.expires_at = nil
	delete(m.clearedFields, configsnapshot.FieldExpiresAt)
}

// Where appends a list predicates to the ConfigSnapshotMutation builder.
func (m *ConfigSnapshotMutation) Where(ps ...predicate.ConfigSnapshot) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ConfigSnapshotMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ConfigSnapshotMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ConfigSnapshot, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ConfigSnapshotMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ConfigSnapshotMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ConfigSnapshot).
func (m *ConfigSnapshotMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ConfigSnapshotMutation) Fields() []string {
	fields := make([]string, 0, 14)
	if m.name != nil {
		fields = append(fields, configsnapshot.FieldName)
	}
	if m.description != nil {
		fields = append(fields, configsnapshot.FieldDescription)
	}
	if m.snapshot_type != nil {
		fields = append(fields, configsnapshot.FieldSnapshotType)
	}
	if m.configuration != nil {
		fields = append(fields, configsnapshot.FieldConfiguration)
	}
	if m.resource_counts != nil {
		fields = append(fields, configsnapshot.FieldResourceCounts)
	}
	if m.ros_version != nil {
		fields = append(fields, configsnapshot.FieldRosVersion)
	}
	if m.router_model != nil {
		fields = append(fields, configsnapshot.FieldRouterModel)
	}
	if m.checksum != nil {
		fields = append(fields, configsnapshot.FieldChecksum)
	}
	if m.size_bytes != nil {
		fields = append(fields, configsnapshot.FieldSizeBytes)
	}
	if m.tags != nil {
		fields = append(fields, configsnapshot.FieldTags)
	}
	if m.pinned != nil {
		fields = append(fields, configsnapshot.FieldPinned)
	}
	if m.created_by != nil {
		fields = append(fields, configsnapshot.FieldCreatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, configsnapshot.FieldCreatedAt)
	}
	if m.expires_at != nil {
		fields = append(fields, configsnapshot.FieldExpiresAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ConfigSnapshotMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case configsnapshot.FieldName:
		return m.Name()
	case configsnapshot.FieldDescription:
		return m.Description()
	case configsnapshot.FieldSnapshotType:
		return m.SnapshotType()
	case configsnapshot.FieldConfiguration:
		return m.Configuration()
	case configsnapshot.FieldResourceCounts:
		return m.ResourceCounts()
	case configsnapshot.FieldRosVersion:
		return m.RosVersion()
	case configsnapshot.FieldRouterModel:
		return m.RouterModel()
	case configsnapshot.FieldChecksum:
		return m.Checksum()
	case configsnapshot.FieldSizeBytes:
		return m.SizeBytes()
	case configsnapshot.FieldTags:
		return m.Tags()
	case configsnapshot.FieldPinned:
		return m.Pinned()
	case configsnapshot.FieldCreatedBy:
		return m.CreatedBy()
	case configsnapshot.FieldCreatedAt:
		return m.CreatedAt()
	case configsnapshot.FieldExpiresAt:
		return m.ExpiresAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ConfigSnapshotMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case configsnapshot.FieldName:
		return m.OldName(ctx)
	case configsnapshot.FieldDescription:
		return m.OldDescription(ctx)
	case configsnapshot.FieldSnapshotType:
		return m.OldSnapshotType(ctx)
	case configsnapshot.FieldConfiguration:
		return m.OldConfiguration(ctx)
	case configsnapshot.FieldResourceCounts:
		return m.OldResourceCounts(ctx)
	case configsnapshot.FieldRosVersion:
		return m.OldRosVersion(ctx)
	case configsnapshot.FieldRouterModel:
		return m.OldRouterModel(ctx)
	case configsnapshot.FieldChecksum:
		return m.OldChecksum(ctx)
	case configsnapshot.FieldSizeBytes:
		return m.OldSizeBytes(ctx)
	case configsnapshot.FieldTags:
		return m.OldTags(ctx)
	case configsnapshot.FieldPinned:
		return m.OldPinned(ctx)
	case configsnapshot.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case configsnapshot.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case configsnapshot.FieldExpiresAt:
		return m.OldExpiresAt(ctx)
	}
	return nil, fmt.Errorf("unknown ConfigSnapshot field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ConfigSnapshotMutation) SetField(name string, value ent.Value) error {
	switch name {
	case configsnapshot.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case configsnapshot.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case configsnapshot.FieldSnapshotType:
		v, ok := value.(configsnapshot.SnapshotType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSnapshotType(v)
		return nil
	case configsnapshot.FieldConfiguration:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConfiguration(v)
		return nil
	case configsnapshot.FieldResourceCounts:
		v, ok := value.(map[string]int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResourceCounts(v)
		return nil
	case configsnapshot.FieldRosVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRosVersion(v)
		return nil
	case configsnapshot.FieldRouterModel:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRouterModel(v)
		return nil
	case configsnapshot.FieldChecksum:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChecksum(v)
		return nil
	case configsnapshot.FieldSizeBytes:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSizeBytes(v)
		return nil
	case configsnapshot.FieldTags:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	case configsnapshot.FieldPinned:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPinned(v)
		return nil
	case configsnapshot.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case configsnapshot.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case configsnapshot.FieldExpiresAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiresAt(v)
		return nil
	}
	return fmt.Errorf("unknown ConfigSnapshot field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ConfigSnapshotMutation) AddedFields() []string {
	var fields []string
	if m.addsize_bytes != nil {
		fields = append(fields, configsnapshot.FieldSizeBytes)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ConfigSnapshotMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case configsnapshot.FieldSizeBytes:
		return m.AddedSizeBytes()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ConfigSnapshotMutation) AddField(name string, value ent.Value) error {
	switch name {
	case configsnapshot.FieldSizeBytes:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSizeBytes(v)
		return nil
	}
	return fmt.Errorf("unknown ConfigSnapshot numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ConfigSnapshotMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(configsnapshot.FieldDescription) {
		fields = append(fields, configsnapshot.FieldDescription)
	}
	if m.FieldCleared(configsnapshot.FieldResourceCounts) {
		fields = append(fields, configsnapshot.FieldResourceCounts)
	}
	if m.FieldCleared(configsnapshot.FieldRosVersion) {
		fields = append(fields, configsnapshot.FieldRosVersion)
	}
	if m.FieldCleared(configsnapshot.FieldRouterModel) {
		fields = append(fields, configsnapshot.FieldRouterModel)
	}
	if m.FieldCleared(configsnapshot.FieldChecksum) {
		fields = append(fields, configsnapshot.FieldChecksum)
	}
	if m.FieldCleared(configsnapshot.FieldSizeBytes) {
		fields = append(fields, configsnapshot.FieldSizeBytes)
	}
	if m.FieldCleared(configsnapshot.FieldTags) {
		fields = append(fields, configsnapshot.FieldTags)
	}
	if m.FieldCleared(configsnapshot.FieldExpiresAt) {
		fields = append(fields, configsnapshot.FieldExpiresAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ConfigSnapshotMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ConfigSnapshotMutation) ClearField(name string) error {
	switch name {
	case configsnapshot.FieldDescription:
		m.ClearDescription()
		return nil
	case configsnapshot.FieldResourceCounts:
		m.ClearResourceCounts()
		return nil
	case configsnapshot.FieldRosVersion:
		m.ClearRosVersion()
		return nil
	case configsnapshot.FieldRouterModel:
		m.ClearRouterModel()
		return nil
	case configsnapshot.FieldChecksum:
		m.ClearChecksum()
		return nil
	case configsnapshot.FieldSizeBytes:
		m.ClearSizeBytes()
		return nil
	case configsnapshot.FieldTags:
		m.ClearTags()
		return nil
	case configsnapshot.FieldExpiresAt:
		m.ClearExpiresAt()
		return nil
	}
	return fmt.Errorf("unknown ConfigSnapshot nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ConfigSnapshotMutation) ResetField(name string) error {
	switch name {
	case configsnapshot.FieldName:
		m.ResetName()
		return nil
	case configsnapshot.FieldDescription:
		m.ResetDescription()
		return nil
	case configsnapshot.FieldSnapshotType:
		m.ResetSnapshotType()
		return nil
	case configsnapshot.FieldConfiguration:
		m.ResetConfiguration()
		return nil
	case configsnapshot.FieldResourceCounts:
		m.ResetResourceCounts()
		return nil
	case configsnapshot.FieldRosVersion:
		m.ResetRosVersion()
		return nil
	case configsnapshot.FieldRouterModel:
		m.ResetRouterModel()
		return nil
	case configsnapshot.FieldChecksum:
		m.ResetChecksum()
		return nil
	case configsnapshot.FieldSizeBytes:
		m.ResetSizeBytes()
		return nil
	case configsnapshot.FieldTags:
		m.ResetTags()
		return nil
	case configsnapshot.FieldPinned:
		m.ResetPinned()
		return nil
	case configsnapshot.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case configsnapshot.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case configsnapshot.FieldExpiresAt:
		m.ResetExpiresAt()
		return nil
	}
	return fmt.Errorf("unknown ConfigSnapshot field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ConfigSnapshotMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ConfigSnapshotMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ConfigSnapshotMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ConfigSnapshotMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ConfigSnapshotMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ConfigSnapshotMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ConfigSnapshotMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown ConfigSnapshot unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ConfigSnapshotMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown ConfigSnapshot edge %s", name)
}

// DeviceRoutingMutation represents an operation that mutates the DeviceRouting nodes in the graph.
type DeviceRoutingMutation struct {
	config
	op                                Op
	typ                               string
	id                                *string
	device_id                         *string
	mac_address                       *string
	device_ip                         *string
	device_name                       *string
	routing_mark                      *string
	routing_mode                      *devicerouting.RoutingMode
	mangle_rule_id                    *string
	active                            *bool
	kill_switch_enabled               *bool
	kill_switch_mode                  *devicerouting.KillSwitchMode
	kill_switch_rule_id               *string
	kill_switch_active                *bool
	kill_switch_activated_at          *time.Time
	kill_switch_fallback_interface_id *string
	created_at                        *time.Time
	updated_at                        *time.Time
	clearedFields                     map[string]struct{}
	router                            *string
	clearedrouter                     bool
	instance                          *string
	clearedinstance                   bool
	virtual_interface                 *string
	clearedvirtual_interface          bool
	schedules                         map[string]struct{}
	removedschedules                  map[string]struct{}
	clearedschedules                  bool
	done                              bool
	oldValue                          func(context.Context) (*DeviceRouting, error)
	predicates                        []predicate.DeviceRouting
}

var _ ent.Mutation = (*DeviceRoutingMutation)(nil)

// deviceroutingOption allows management of the mutation configuration using functional options.
type deviceroutingOption func(*DeviceRoutingMutation)

// newDeviceRoutingMutation creates new mutation for the DeviceRouting entity.
func newDeviceRoutingMutation(c config, op Op, opts ...deviceroutingOption) *DeviceRoutingMutation {
	m := &DeviceRoutingMutation{
		config:        c,
		op:            op,
		typ:           TypeDeviceRouting,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDeviceRoutingID sets the ID field of the mutation.
func withDeviceRoutingID(id string) deviceroutingOption {
	return func(m *DeviceRoutingMutation) {
		var (
			err   error
			once  sync.Once
			value *DeviceRouting
		)
		m.oldValue = func(ctx context.Context) (*DeviceRouting, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().DeviceRouting.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDeviceRouting sets the old DeviceRouting of the mutation.
func withDeviceRouting(node *DeviceRouting) deviceroutingOption {
	return func(m *DeviceRoutingMutation) {
		m.oldValue = func(context.Context) (*DeviceRouting, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DeviceRoutingMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DeviceRoutingMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of DeviceRouting entities.
func (m *DeviceRoutingMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DeviceRoutingMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DeviceRoutingMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().DeviceRouting.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetRouterID sets the "router_id" field.
func (m *DeviceRoutingMutation) SetRouterID(s string) {
	m.router = &s
}

// RouterID returns the value of the "router_id" field in the mutation.
func (m *DeviceRoutingMutation) RouterID() (r string, exists bool) {
	v := m.router
	if v == nil {
		return
	}
	return *v, true
}

// OldRouterID returns the old "router_id" field's value of the DeviceRouting entity.
// If the DeviceRouting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceRoutingMutation) OldRouterID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRouterID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRouterID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRouterID: %w", err)
	}
	return oldValue.RouterID, nil
}

// ResetRouterID resets all changes to the "router_id" field.
func (m *DeviceRoutingMutation) ResetRouterID() {
	m.router = nil
}

// SetDeviceID sets the "device_id" field.
func (m *DeviceRoutingMutation) SetDeviceID(s string) {
	m.device_id = &s
}

// DeviceID returns the value of the "device_id" field in the mutation.
func (m *DeviceRoutingMutation) DeviceID() (r string, exists bool) {
	v := m.device_id
	if v == nil {
		return
	}
	return *v, true
}

// OldDeviceID returns the old "device_id" field's value of the DeviceRouting entity.
// If the DeviceRouting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceRoutingMutation) OldDeviceID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeviceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeviceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeviceID: %w", err)
	}
	return oldValue.DeviceID, nil
}

// ResetDeviceID resets all changes to the "device_id" field.
func (m *DeviceRoutingMutation) ResetDeviceID() {
	m.device_id = nil
}

// SetMACAddress sets the "mac_address" field.
func (m *DeviceRoutingMutation) SetMACAddress(s string) {
	m.mac_address = &s
}

// MACAddress returns the value of the "mac_address" field in the mutation.
func (m *DeviceRoutingMutation) MACAddress() (r string, exists bool) {
	v := m.mac_address
	if v == nil {
		return
	}
	return *v, true
}

// OldMACAddress returns the old "mac_address" field's value of the DeviceRouting entity.
// If the DeviceRouting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceRoutingMutation) OldMACAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMACAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMACAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMACAddress: %w", err)
	}
	return oldValue.MACAddress, nil
}

// ResetMACAddress resets all changes to the "mac_address" field.
func (m *DeviceRoutingMutation) ResetMACAddress() {
	m.mac_address = nil
}

// SetDeviceIP sets the "device_ip" field.
func (m *DeviceRoutingMutation) SetDeviceIP(s string) {
	m.device_ip = &s
}

// DeviceIP returns the value of the "device_ip" field in the mutation.
func (m *DeviceRoutingMutation) DeviceIP() (r string, exists bool) {
	v := m.device_ip
	if v == nil {
		return
	}
	return *v, true
}

// OldDeviceIP returns the old "device_ip" field's value of the DeviceRouting entity.
// If the DeviceRouting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceRoutingMutation) OldDeviceIP(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeviceIP is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeviceIP requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeviceIP: %w", err)
	}
	return oldValue.DeviceIP, nil
}

// ClearDeviceIP clears the value of the "device_ip" field.
func (m *DeviceRoutingMutation) ClearDeviceIP() {
	m.device_ip = nil
	m.clearedFields[devicerouting.FieldDeviceIP] = struct{}{}
}

// DeviceIPCleared returns if the "device_ip" field was cleared in this mutation.
func (m *DeviceRoutingMutation) DeviceIPCleared() bool {
	_, ok := m.clearedFields[devicerouting.FieldDeviceIP]
	return ok
}

// ResetDeviceIP resets all changes to the "device_ip" field.
func (m *DeviceRoutingMutation) ResetDeviceIP() {
	m.device_ip = nil
	delete(m.clearedFields, devicerouting.FieldDeviceIP)
}

// SetDeviceName sets the "device_name" field.
func (m *DeviceRoutingMutation) SetDeviceName(s string) {
	m.device_name = &s
}

// DeviceName returns the value of the "device_name" field in the mutation.
func (m *DeviceRoutingMutation) DeviceName() (r string, exists bool) {
	v := m.device_name
	if v == nil {
		return
	}
	return *v, true
}

// OldDeviceName returns the old "device_name" field's value of the DeviceRouting entity.
// If the DeviceRouting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceRoutingMutation) OldDeviceName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeviceName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeviceName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeviceName: %w", err)
	}
	return oldValue.DeviceName, nil
}

// ClearDeviceName clears the value of the "device_name" field.
func (m *DeviceRoutingMutation) ClearDeviceName() {
	m.device_name = nil
	m.clearedFields[devicerouting.FieldDeviceName] = struct{}{}
}

// DeviceNameCleared returns if the "device_name" field was cleared in this mutation.
func (m *DeviceRoutingMutation) DeviceNameCleared() bool {
	_, ok := m.clearedFields[devicerouting.FieldDeviceName]
	return ok
}

// ResetDeviceName resets all changes to the "device_name" field.
func (m *DeviceRoutingMutation) ResetDeviceName() {
	m.device_name = nil
	delete(m.clearedFields, devicerouting.FieldDeviceName)
}

// SetInstanceID sets the "instance_id" field.
func (m *DeviceRoutingMutation) SetInstanceID(s string) {
	m.instance = &s
}

// InstanceID returns the value of the "instance_id" field in the mutation.
func (m *DeviceRoutingMutation) InstanceID() (r string, exists bool) {
	v := m.instance
	if v == nil {
		return
	}
	return *v, true
}

// OldInstanceID returns the old "instance_id" field's value of the DeviceRouting entity.
// If the DeviceRouting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceRoutingMutation) OldInstanceID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInstanceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInstanceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInstanceID: %w", err)
	}
	return oldValue.InstanceID, nil
}

// ResetInstanceID resets all changes to the "instance_id" field.
func (m *DeviceRoutingMutation) ResetInstanceID() {
	m.instance = nil
}

// SetInterfaceID sets the "interface_id" field.
func (m *DeviceRoutingMutation) SetInterfaceID(s string) {
	m.virtual_interface = &s
}

// InterfaceID returns the value of the "interface_id" field in the mutation.
func (m *DeviceRoutingMutation) InterfaceID() (r string, exists bool) {
	v := m.virtual_interface
	if v == nil {
		return
	}
	return *v, true
}

// OldInterfaceID returns the old "interface_id" field's value of the DeviceRouting entity.
// If the DeviceRouting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceRoutingMutation) OldInterfaceID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInterfaceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInterfaceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInterfaceID: %w", err)
	}
	return oldValue.InterfaceID, nil
}

// ResetInterfaceID resets all changes to the "interface_id" field.
func (m *DeviceRoutingMutation) ResetInterfaceID() {
	m.virtual_interface = nil
}

// SetRoutingMark sets the "routing_mark" field.
func (m *DeviceRoutingMutation) SetRoutingMark(s string) {
	m.routing_mark = &s
}

// RoutingMark returns the value of the "routing_mark" field in the mutation.
func (m *DeviceRoutingMutation) RoutingMark() (r string, exists bool) {
	v := m.routing_mark
	if v == nil {
		return
	}
	return *v, true
}

// OldRoutingMark returns the old "routing_mark" field's value of the DeviceRouting entity.
// If the DeviceRouting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceRoutingMutation) OldRoutingMark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRoutingMark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRoutingMark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRoutingMark: %w", err)
	}
	return oldValue.RoutingMark, nil
}

// ResetRoutingMark resets all changes to the "routing_mark" field.
func (m *DeviceRoutingMutation) ResetRoutingMark() {
	m.routing_mark = nil
}

// SetRoutingMode sets the "routing_mode" field.
func (m *DeviceRoutingMutation) SetRoutingMode(dm devicerouting.RoutingMode) {
	m.routing_mode = &dm
}

// RoutingMode returns the value of the "routing_mode" field in the mutation.
func (m *DeviceRoutingMutation) RoutingMode() (r devicerouting.RoutingMode, exists bool) {
	v := m.routing_mode
	if v == nil {
		return
	}
	return *v, true
}

// OldRoutingMode returns the old "routing_mode" field's value of the DeviceRouting entity.
// If the DeviceRouting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceRoutingMutation) OldRoutingMode(ctx context.Context) (v devicerouting.RoutingMode, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRoutingMode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRoutingMode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRoutingMode: %w", err)
	}
	return oldValue.RoutingMode, nil
}

// ResetRoutingMode resets all changes to the "routing_mode" field.
func (m *DeviceRoutingMutation) ResetRoutingMode() {
	m.routing_mode = nil
}

// SetMangleRuleID sets the "mangle_rule_id" field.
func (m *DeviceRoutingMutation) SetMangleRuleID(s string) {
	m.mangle_rule_id = &s
}

// MangleRuleID returns the value of the "mangle_rule_id" field in the mutation.
func (m *DeviceRoutingMutation) MangleRuleID() (r string, exists bool) {
	v := m.mangle_rule_id
	if v == nil {
		return
	}
	return *v, true
}

// OldMangleRuleID returns the old "mangle_rule_id" field's value of the DeviceRouting entity.
// If the DeviceRouting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceRoutingMutation) OldMangleRuleID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMangleRuleID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMangleRuleID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMangleRuleID: %w", err)
	}
	return oldValue.MangleRuleID, nil
}

// ResetMangleRuleID resets all changes to the "mangle_rule_id" field.
func (m *DeviceRoutingMutation) ResetMangleRuleID() {
	m.mangle_rule_id = nil
}

// SetActive sets the "active" field.
func (m *DeviceRoutingMutation) SetActive(b bool) {
	m.active = &b
}

// Active returns the value of the "active" field in the mutation.
func (m *DeviceRoutingMutation) Active() (r bool, exists bool) {
	v := m.active
	if v == nil {
		return
	}
	return *v, true
}

// OldActive returns the old "active" field's value of the DeviceRouting entity.
// If the DeviceRouting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceRoutingMutation) OldActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActive: %w", err)
	}
	return oldValue.Active, nil
}

// ResetActive resets all changes to the "active" field.
func (m *DeviceRoutingMutation) ResetActive() {
	m.active = nil
}

// SetKillSwitchEnabled sets the "kill_switch_enabled" field.
func (m *DeviceRoutingMutation) SetKillSwitchEnabled(b bool) {
	m.kill_switch_enabled = &b
}

// KillSwitchEnabled returns the value of the "kill_switch_enabled" field in the mutation.
func (m *DeviceRoutingMutation) KillSwitchEnabled() (r bool, exists bool) {
	v := m.kill_switch_enabled
	if v == nil {
		return
	}
	return *v, true
}

// OldKillSwitchEnabled returns the old "kill_switch_enabled" field's value of the DeviceRouting entity.
// If the DeviceRouting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceRoutingMutation) OldKillSwitchEnabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKillSwitchEnabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKillSwitchEnabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKillSwitchEnabled: %w", err)
	}
	return oldValue.KillSwitchEnabled, nil
}

// ResetKillSwitchEnabled resets all changes to the "kill_switch_enabled" field.
func (m *DeviceRoutingMutation) ResetKillSwitchEnabled() {
	m.kill_switch_enabled = nil
}

// SetKillSwitchMode sets the "kill_switch_mode" field.
func (m *DeviceRoutingMutation) SetKillSwitchMode(dsm devicerouting.KillSwitchMode) {
	m.kill_switch_mode = &dsm
}

// KillSwitchMode returns the value of the "kill_switch_mode" field in the mutation.
func (m *DeviceRoutingMutation) KillSwitchMode() (r devicerouting.KillSwitchMode, exists bool) {
	v := m.kill_switch_mode
	if v == nil {
		return
	}
	return *v, true
}

// OldKillSwitchMode returns the old "kill_switch_mode" field's value of the DeviceRouting entity.
// If the DeviceRouting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceRoutingMutation) OldKillSwitchMode(ctx context.Context) (v devicerouting.KillSwitchMode, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKillSwitchMode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKillSwitchMode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKillSwitchMode: %w", err)
	}
	return oldValue.KillSwitchMode, nil
}

// ClearKillSwitchMode clears the value of the "kill_switch_mode" field.
func (m *DeviceRoutingMutation) ClearKillSwitchMode() {
	m.kill_switch_mode = nil
	m.clearedFields[devicerouting.FieldKillSwitchMode] = struct{}{}
}

// KillSwitchModeCleared returns if the "kill_switch_mode" field was cleared in this mutation.
func (m *DeviceRoutingMutation) KillSwitchModeCleared() bool {
	_, ok := m.clearedFields[devicerouting.FieldKillSwitchMode]
	return ok
}

// ResetKillSwitchMode resets all changes to the "kill_switch_mode" field.
func (m *DeviceRoutingMutation) ResetKillSwitchMode() {
	m.kill_switch_mode = nil
	delete(m.clearedFields, devicerouting.FieldKillSwitchMode)
}

// SetKillSwitchRuleID sets the "kill_switch_rule_id" field.
func (m *DeviceRoutingMutation) SetKillSwitchRuleID(s string) {
	m.kill_switch_rule_id = &s
}

// KillSwitchRuleID returns the value of the "kill_switch_rule_id" field in the mutation.
func (m *DeviceRoutingMutation) KillSwitchRuleID() (r string, exists bool) {
	v := m.kill_switch_rule_id
	if v == nil {
		return
	}
	return *v, true
}

// OldKillSwitchRuleID returns the old "kill_switch_rule_id" field's value of the DeviceRouting entity.
// If the DeviceRouting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceRoutingMutation) OldKillSwitchRuleID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKillSwitchRuleID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKillSwitchRuleID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKillSwitchRuleID: %w", err)
	}
	return oldValue.KillSwitchRuleID, nil
}

// ClearKillSwitchRuleID clears the value of the "kill_switch_rule_id" field.
func (m *DeviceRoutingMutation) ClearKillSwitchRuleID() {
	m.kill_switch_rule_id = nil
	m.clearedFields[devicerouting.FieldKillSwitchRuleID] = struct{}{}
}

// KillSwitchRuleIDCleared returns if the "kill_switch_rule_id" field was cleared in this mutation.
func (m *DeviceRoutingMutation) KillSwitchRuleIDCleared() bool {
	_, ok := m.clearedFields[devicerouting.FieldKillSwitchRuleID]
	return ok
}

// ResetKillSwitchRuleID resets all changes to the "kill_switch_rule_id" field.
func (m *DeviceRoutingMutation) ResetKillSwitchRuleID() {
	m.kill_switch_rule_id = nil
	delete(m.clearedFields, devicerouting.FieldKillSwitchRuleID)
}

// SetKillSwitchActive sets the "kill_switch_active" field.
func (m *DeviceRoutingMutation) SetKillSwitchActive(b bool) {
	m.kill_switch_active = &b
}

// KillSwitchActive returns the value of the "kill_switch_active" field in the mutation.
func (m *DeviceRoutingMutation) KillSwitchActive() (r bool, exists bool) {
	v := m.kill_switch_active
	if v == nil {
		return
	}
	return *v, true
}

// OldKillSwitchActive returns the old "kill_switch_active" field's value of the DeviceRouting entity.
// If the DeviceRouting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceRoutingMutation) OldKillSwitchActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKillSwitchActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKillSwitchActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKillSwitchActive: %w", err)
	}
	return oldValue.KillSwitchActive, nil
}

// ResetKillSwitchActive resets all changes to the "kill_switch_active" field.
func (m *DeviceRoutingMutation) ResetKillSwitchActive() {
	m.kill_switch_active = nil
}

// SetKillSwitchActivatedAt sets the "kill_switch_activated_at" field.
func (m *DeviceRoutingMutation) SetKillSwitchActivatedAt(t time.Time) {
	m.kill_switch_activated_at = &t
}

// KillSwitchActivatedAt returns the value of the "kill_switch_activated_at" field in the mutation.
func (m *DeviceRoutingMutation) KillSwitchActivatedAt() (r time.Time, exists bool) {
	v := m.kill_switch_activated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldKillSwitchActivatedAt returns the old "kill_switch_activated_at" field's value of the DeviceRouting entity.
// If the DeviceRouting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceRoutingMutation) OldKillSwitchActivatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKillSwitchActivatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKillSwitchActivatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKillSwitchActivatedAt: %w", err)
	}
	return oldValue.KillSwitchActivatedAt, nil
}

// ClearKillSwitchActivatedAt clears the value of the "kill_switch_activated_at" field.
func (m *DeviceRoutingMutation) ClearKillSwitchActivatedAt() {
	m.kill_switch_activated_at = nil
	m.clearedFields[devicerouting.FieldKillSwitchActivatedAt] = struct{}{}
}

// KillSwitchActivatedAtCleared returns if the "kill_switch_activated_at" field was cleared in this mutation.
func (m *DeviceRoutingMutation) KillSwitchActivatedAtCleared() bool {
	_, ok := m.clearedFields[devicerouting.FieldKillSwitchActivatedAt]
	return ok
}

// ResetKillSwitchActivatedAt resets all changes to the "kill_switch_activated_at" field.
func (m *DeviceRoutingMutation) ResetKillSwitchActivatedAt() {
	m.kill_switch_activated_at = nil
	delete(m.clearedFields, devicerouting.FieldKillSwitchActivatedAt)
}

// SetKillSwitchFallbackInterfaceID sets the "kill_switch_fallback_interface_id" field.
func (m *DeviceRoutingMutation) SetKillSwitchFallbackInterfaceID(s string) {
	m.kill_switch_fallback_interface_id = &s
}

// KillSwitchFallbackInterfaceID returns the value of the "kill_switch_fallback_interface_id" field in the mutation.
func (m *DeviceRoutingMutation) KillSwitchFallbackInterfaceID() (r string, exists bool) {
	v := m.kill_switch_fallback_interface_id
	if v == nil {
		return
	}
	return *v, true
}

// OldKillSwitchFallbackInterfaceID returns the old "kill_switch_fallback_interface_id" field's value of the DeviceRouting entity.
// If the DeviceRouting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceRoutingMutation) OldKillSwitchFallbackInterfaceID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKillSwitchFallbackInterfaceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKillSwitchFallbackInterfaceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKillSwitchFallbackInterfaceID: %w", err)
	}
	return oldValue.KillSwitchFallbackInterfaceID, nil
}

// ClearKillSwitchFallbackInterfaceID clears the value of the "kill_switch_fallback_interface_id" field.
func (m *DeviceRoutingMutation) ClearKillSwitchFallbackInterfaceID() {
	m.kill_switch_fallback_interface_id = nil
	m.clearedFields[devicerouting.FieldKillSwitchFallbackInterfaceID] = struct{}{}
}

// KillSwitchFallbackInterfaceIDCleared returns if the "kill_switch_fallback_interface_id" field was cleared in this mutation.
func (m *DeviceRoutingMutation) KillSwitchFallbackInterfaceIDCleared() bool {
	_, ok := m.clearedFields[devicerouting.FieldKillSwitchFallbackInterfaceID]
	return ok
}

// ResetKillSwitchFallbackInterfaceID resets all changes to the "kill_switch_fallback_interface_id" field.
func (m *DeviceRoutingMutation) ResetKillSwitchFallbackInterfaceID() {
	m.kill_switch_fallback_interface_id = nil
	delete(m.clearedFields, devicerouting.FieldKillSwitchFallbackInterfaceID)
}

// SetCreatedAt sets the "created_at" field.
func (m *DeviceRoutingMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *DeviceRoutingMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the DeviceRouting entity.
// If the DeviceRouting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceRoutingMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *DeviceRoutingMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *DeviceRoutingMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *DeviceRoutingMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the DeviceRouting entity.
// If the DeviceRouting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceRoutingMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *DeviceRoutingMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearRouter clears the "router" edge to the Router entity.
func (m *DeviceRoutingMutation) ClearRouter() {
	m.clearedrouter = true
	m.clearedFields[devicerouting.FieldRouterID] = struct{}{}
}

// RouterCleared reports if the "router" edge to the Router entity was cleared.
func (m *DeviceRoutingMutation) RouterCleared() bool {
	return m.clearedrouter
}

// RouterIDs returns the "router" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RouterID instead. It exists only for internal usage by the builders.
func (m *DeviceRoutingMutation) RouterIDs() (ids []string) {
	if id := m.router; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRouter resets all changes to the "router" edge.
func (m *DeviceRoutingMutation) ResetRouter() {
	m.router = nil
	m.clearedrouter = false
}

// ClearInstance clears the "instance" edge to the ServiceInstance entity.
func (m *DeviceRoutingMutation) ClearInstance() {
	m.clearedinstance = true
	m.clearedFields[devicerouting.FieldInstanceID] = struct{}{}
}

// InstanceCleared reports if the "instance" edge to the ServiceInstance entity was cleared.
func (m *DeviceRoutingMutation) InstanceCleared() bool {
	return m.clearedinstance
}

// InstanceIDs returns the "instance" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// InstanceID instead. It exists only for internal usage by the builders.
func (m *DeviceRoutingMutation) InstanceIDs() (ids []string) {
	if id := m.instance; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetInstance resets all changes to the "instance" edge.
func (m *DeviceRoutingMutation) ResetInstance() {
	m.instance = nil
	m.clearedinstance = false
}

// SetVirtualInterfaceID sets the "virtual_interface" edge to the VirtualInterface entity by id.
func (m *DeviceRoutingMutation) SetVirtualInterfaceID(id string) {
	m.virtual_interface = &id
}

// ClearVirtualInterface clears the "virtual_interface" edge to the VirtualInterface entity.
func (m *DeviceRoutingMutation) ClearVirtualInterface() {
	m.clearedvirtual_interface = true
	m.clearedFields[devicerouting.FieldInterfaceID] = struct{}{}
}

// VirtualInterfaceCleared reports if the "virtual_interface" edge to the VirtualInterface entity was cleared.
func (m *DeviceRoutingMutation) VirtualInterfaceCleared() bool {
	return m.clearedvirtual_interface
}

// VirtualInterfaceID returns the "virtual_interface" edge ID in the mutation.
func (m *DeviceRoutingMutation) VirtualInterfaceID() (id string, exists bool) {
	if m.virtual_interface != nil {
		return *m.virtual_interface, true
	}
	return
}

// VirtualInterfaceIDs returns the "virtual_interface" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// VirtualInterfaceID instead. It exists only for internal usage by the builders.
func (m *DeviceRoutingMutation) VirtualInterfaceIDs() (ids []string) {
	if id := m.virtual_interface; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetVirtualInterface resets all changes to the "virtual_interface" edge.
func (m *DeviceRoutingMutation) ResetVirtualInterface() {
	m.virtual_interface = nil
	m.clearedvirtual_interface = false
}

// AddScheduleIDs adds the "schedules" edge to the RoutingSchedule entity by ids.
func (m *DeviceRoutingMutation) AddScheduleIDs(ids ...string) {
	if m.schedules == nil {
		m.schedules = make(map[string]struct{})
	}
	for i := range ids {
		m.schedules[ids[i]] = struct{}{}
	}
}

// ClearSchedules clears the "schedules" edge to the RoutingSchedule entity.
func (m *DeviceRoutingMutation) ClearSchedules() {
	m.clearedschedules = true
}

// SchedulesCleared reports if the "schedules" edge to the RoutingSchedule entity was cleared.
func (m *DeviceRoutingMutation) SchedulesCleared() bool {
	return m.clearedschedules
}

// RemoveScheduleIDs removes the "schedules" edge to the RoutingSchedule entity by IDs.
func (m *DeviceRoutingMutation) RemoveScheduleIDs(ids ...string) {
	if m.removedschedules == nil {
		m.removedschedules = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.schedules, ids[i])
		m.removedschedules[ids[i]] = struct{}{}
	}
}

// RemovedSchedules returns the removed IDs of the "schedules" edge to the RoutingSchedule entity.
func (m *DeviceRoutingMutation) RemovedSchedulesIDs() (ids []string) {
	for id := range m.removedschedules {
		ids = append(ids, id)
	}
	return
}

// SchedulesIDs returns the "schedules" edge IDs in the mutation.
func (m *DeviceRoutingMutation) SchedulesIDs() (ids []string) {
	for id := range m.schedules {
		ids = append(ids, id)
	}
	return
}

// ResetSchedules resets all changes to the "schedules" edge.
func (m *DeviceRoutingMutation) ResetSchedules() {
	m.schedules = nil
	m.clearedschedules = false
	m.removedschedules = nil
}

// Where appends a list predicates to the DeviceRoutingMutation builder.
func (m *DeviceRoutingMutation) Where(ps ...predicate.DeviceRouting) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DeviceRoutingMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DeviceRoutingMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.DeviceRouting, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DeviceRoutingMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DeviceRoutingMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (DeviceRouting).
func (m *DeviceRoutingMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DeviceRoutingMutation) Fields() []string {
	fields := make([]string, 0, 19)
	if m.router != nil {
		fields = append(fields, devicerouting.FieldRouterID)
	}
	if m.device_id != nil {
		fields = append(fields, devicerouting.FieldDeviceID)
	}
	if m.mac_address != nil {
		fields = append(fields, devicerouting.FieldMACAddress)
	}
	if m.device_ip != nil {
		fields = append(fields, devicerouting.FieldDeviceIP)
	}
	if m.device_name != nil {
		fields = append(fields, devicerouting.FieldDeviceName)
	}
	if m.instance != nil {
		fields = append(fields, devicerouting.FieldInstanceID)
	}
	if m.virtual_interface != nil {
		fields = append(fields, devicerouting.FieldInterfaceID)
	}
	if m.routing_mark != nil {
		fields = append(fields, devicerouting.FieldRoutingMark)
	}
	if m.routing_mode != nil {
		fields = append(fields, devicerouting.FieldRoutingMode)
	}
	if m.mangle_rule_id != nil {
		fields = append(fields, devicerouting.FieldMangleRuleID)
	}
	if m.active != nil {
		fields = append(fields, devicerouting.FieldActive)
	}
	if m.kill_switch_enabled != nil {
		fields = append(fields, devicerouting.FieldKillSwitchEnabled)
	}
	if m.kill_switch_mode != nil {
		fields = append(fields, devicerouting.FieldKillSwitchMode)
	}
	if m.kill_switch_rule_id != nil {
		fields = append(fields, devicerouting.FieldKillSwitchRuleID)
	}
	if m.kill_switch_active != nil {
		fields = append(fields, devicerouting.FieldKillSwitchActive)
	}
	if m.kill_switch_activated_at != nil {
		fields = append(fields, devicerouting.FieldKillSwitchActivatedAt)
	}
	if m.kill_switch_fallback_interface_id != nil {
		fields = append(fields, devicerouting.FieldKillSwitchFallbackInterfaceID)
	}
	if m.created_at != nil {
		fields = append(fields, devicerouting.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, devicerouting.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DeviceRoutingMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case devicerouting.FieldRouterID:
		return m.RouterID()
	case devicerouting.FieldDeviceID:
		return m.DeviceID()
	case devicerouting.FieldMACAddress:
		return m.MACAddress()
	case devicerouting.FieldDeviceIP:
		return m.DeviceIP()
	case devicerouting.FieldDeviceName:
		return m.DeviceName()
	case devicerouting.FieldInstanceID:
		return m.InstanceID()
	case devicerouting.FieldInterfaceID:
		return m.InterfaceID()
	case devicerouting.FieldRoutingMark:
		return m.RoutingMark()
	case devicerouting.FieldRoutingMode:
		return m.RoutingMode()
	case devicerouting.FieldMangleRuleID:
		return m.MangleRuleID()
	case devicerouting.FieldActive:
		return m.Active()
	case devicerouting.FieldKillSwitchEnabled:
		return m.KillSwitchEnabled()
	case devicerouting.FieldKillSwitchMode:
		return m.KillSwitchMode()
	case devicerouting.FieldKillSwitchRuleID:
		return m.KillSwitchRuleID()
	case devicerouting.FieldKillSwitchActive:
		return m.KillSwitchActive()
	case devicerouting.FieldKillSwitchActivatedAt:
		return m.KillSwitchActivatedAt()
	case devicerouting.FieldKillSwitchFallbackInterfaceID:
		return m.KillSwitchFallbackInterfaceID()
	case devicerouting.FieldCreatedAt:
		return m.CreatedAt()
	case devicerouting.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DeviceRoutingMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case devicerouting.FieldRouterID:
		return m.OldRouterID(ctx)
	case devicerouting.FieldDeviceID:
		return m.OldDeviceID(ctx)
	case devicerouting.FieldMACAddress:
		return m.OldMACAddress(ctx)
	case devicerouting.FieldDeviceIP:
		return m.OldDeviceIP(ctx)
	case devicerouting.FieldDeviceName:
		return m.OldDeviceName(ctx)
	case devicerouting.FieldInstanceID:
		return m.OldInstanceID(ctx)
	case devicerouting.FieldInterfaceID:
		return m.OldInterfaceID(ctx)
	case devicerouting.FieldRoutingMark:
		return m.OldRoutingMark(ctx)
	case devicerouting.FieldRoutingMode:
		return m.OldRoutingMode(ctx)
	case devicerouting.FieldMangleRuleID:
		return m.OldMangleRuleID(ctx)
	case devicerouting.FieldActive:
		return m.OldActive(ctx)
	case devicerouting.FieldKillSwitchEnabled:
		return m.OldKillSwitchEnabled(ctx)
	case devicerouting.FieldKillSwitchMode:
		return m.OldKillSwitchMode(ctx)
	case devicerouting.FieldKillSwitchRuleID:
		return m.OldKillSwitchRuleID(ctx)
	case devicerouting.FieldKillSwitchActive:
		return m.OldKillSwitchActive(ctx)
	case devicerouting.FieldKillSwitchActivatedAt:
		return m.OldKillSwitchActivatedAt(ctx)
	case devicerouting.FieldKillSwitchFallbackInterfaceID:
		return m.OldKillSwitchFallbackInterfaceID(ctx)
	case devicerouting.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case devicerouting.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown DeviceRouting field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DeviceRoutingMutation) SetField(name string, value ent.Value) error {
	switch name {
	case devicerouting.FieldRouterID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRouterID(v)
		return nil
	case devicerouting.FieldDeviceID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeviceID(v)
		return nil
	case devicerouting.FieldMACAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMACAddress(v)
		return nil
	case devicerouting.FieldDeviceIP:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeviceIP(v)
		return nil
	case devicerouting.FieldDeviceName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeviceName(v)
		return nil
	case devicerouting.FieldInstanceID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInstanceID(v)
		return nil
	case devicerouting.FieldInterfaceID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInterfaceID(v)
		return nil
	case devicerouting.FieldRoutingMark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRoutingMark(v)
		return nil
	case devicerouting.FieldRoutingMode:
		v, ok := value.(devicerouting.RoutingMode)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRoutingMode(v)
		return nil
	case devicerouting.FieldMangleRuleID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMangleRuleID(v)
		return nil
	case devicerouting.FieldActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActive(v)
		return nil
	case devicerouting.FieldKillSwitchEnabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKillSwitchEnabled(v)
		return nil
	case devicerouting.FieldKillSwitchMode:
		v, ok := value.(devicerouting.KillSwitchMode)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKillSwitchMode(v)
		return nil
	case devicerouting.FieldKillSwitchRuleID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKillSwitchRuleID(v)
		return nil
	case devicerouting.FieldKillSwitchActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKillSwitchActive(v)
		return nil
	case devicerouting.FieldKillSwitchActivatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKillSwitchActivatedAt(v)
		return nil
	case devicerouting.FieldKillSwitchFallbackInterfaceID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKillSwitchFallbackInterfaceID(v)
		return nil
	case devicerouting.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case devicerouting.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown DeviceRouting field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DeviceRoutingMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DeviceRoutingMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DeviceRoutingMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown DeviceRouting numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DeviceRoutingMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(devicerouting.FieldDeviceIP) {
		fields = append(fields, devicerouting.FieldDeviceIP)
	}
	if m.FieldCleared(devicerouting.FieldDeviceName) {
		fields = append(fields, devicerouting.FieldDeviceName)
	}
	if m.FieldCleared(devicerouting.FieldKillSwitchMode) {
		fields = append(fields, devicerouting.FieldKillSwitchMode)
	}
	if m.FieldCleared(devicerouting.FieldKillSwitchRuleID) {
		fields = append(fields, devicerouting.FieldKillSwitchRuleID)
	}
	if m.FieldCleared(devicerouting.FieldKillSwitchActivatedAt) {
		fields = append(fields, devicerouting.FieldKillSwitchActivatedAt)
	}
	if m.FieldCleared(devicerouting.FieldKillSwitchFallbackInterfaceID) {
		fields = append(fields, devicerouting.FieldKillSwitchFallbackInterfaceID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DeviceRoutingMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DeviceRoutingMutation) ClearField(name string) error {
	switch name {
	case devicerouting.FieldDeviceIP:
		m.ClearDeviceIP()
		return nil
	case devicerouting.FieldDeviceName:
		m.ClearDeviceName()
		return nil
	case devicerouting.FieldKillSwitchMode:
		m.ClearKillSwitchMode()
		return nil
	case devicerouting.FieldKillSwitchRuleID:
		m.ClearKillSwitchRuleID()
		return nil
	case devicerouting.FieldKillSwitchActivatedAt:
		m.ClearKillSwitchActivatedAt()
		return nil
	case devicerouting.FieldKillSwitchFallbackInterfaceID:
		m.ClearKillSwitchFallbackInterfaceID()
		return nil
	}
	return fmt.Errorf("unknown DeviceRouting nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DeviceRoutingMutation) ResetField(name string) error {
	switch name {
	case devicerouting.FieldRouterID:
		m.ResetRouterID()
		return nil
	case devicerouting.FieldDeviceID:
		m.ResetDeviceID()
		return nil
	case devicerouting.FieldMACAddress:
		m.ResetMACAddress()
		return nil
	case devicerouting.FieldDeviceIP:
		m.ResetDeviceIP()
		return nil
	case devicerouting.FieldDeviceName:
		m.ResetDeviceName()
		return nil
	case devicerouting.FieldInstanceID:
		m.ResetInstanceID()
		return nil
	case devicerouting.FieldInterfaceID:
		m.ResetInterfaceID()
		return nil
	case devicerouting.FieldRoutingMark:
		m.ResetRoutingMark()
		return nil
	case devicerouting.FieldRoutingMode:
		m.ResetRoutingMode()
		return nil
	case devicerouting.FieldMangleRuleID:
		m.ResetMangleRuleID()
		return nil
	case devicerouting.FieldActive:
		m.ResetActive()
		return nil
	case devicerouting.FieldKillSwitchEnabled:
		m.ResetKillSwitchEnabled()
		return nil
	case devicerouting.FieldKillSwitchMode:
		m.ResetKillSwitchMode()
		return nil
	case devicerouting.FieldKillSwitchRuleID:
		m.ResetKillSwitchRuleID()
		return nil
	case devicerouting.FieldKillSwitchActive:
		m.ResetKillSwitchActive()
		return nil
	case devicerouting.FieldKillSwitchActivatedAt:
		m.ResetKillSwitchActivatedAt()
		return nil
	case devicerouting.FieldKillSwitchFallbackInterfaceID:
		m.ResetKillSwitchFallbackInterfaceID()
		return nil
	case devicerouting.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case devicerouting.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown DeviceRouting field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DeviceRoutingMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.router != nil {
		edges = append(edges, devicerouting.EdgeRouter)
	}
	if m.instance != nil {
		edges = append(edges, devicerouting.EdgeInstance)
	}
	if m.virtual_interface != nil {
		edges = append(edges, devicerouting.EdgeVirtualInterface)
	}
	if m.schedules != nil {
		edges = append(edges, devicerouting.EdgeSchedules)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DeviceRoutingMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case devicerouting.EdgeRouter:
		if id := m.router; id != nil {
			return []ent.Value{*id}
		}
	case devicerouting.EdgeInstance:
		if id := m.instance; id != nil {
			return []ent.Value{*id}
		}
	case devicerouting.EdgeVirtualInterface:
		if id := m.virtual_interface; id != nil {
			return []ent.Value{*id}
		}
	case devicerouting.EdgeSchedules:
		ids := make([]ent.Value, 0, len(m.schedules))
		for id := range m.schedules {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DeviceRoutingMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedschedules != nil {
		edges = append(edges, devicerouting.EdgeSchedules)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DeviceRoutingMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case devicerouting.EdgeSchedules:
		ids := make([]ent.Value, 0, len(m.removedschedules))
		for id := range m.removedschedules {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DeviceRoutingMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedrouter {
		edges = append(edges, devicerouting.EdgeRouter)
	}
	if m.clearedinstance {
		edges = append(edges, devicerouting.EdgeInstance)
	}
	if m.clearedvirtual_interface {
		edges = append(edges, devicerouting.EdgeVirtualInterface)
	}
	if m.clearedschedules {
		edges = append(edges, devicerouting.EdgeSchedules)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DeviceRoutingMutation) EdgeCleared(name string) bool {
	switch name {
	case devicerouting.EdgeRouter:
		return m.clearedrouter
	case devicerouting.EdgeInstance:
		return m.clearedinstance
	case devicerouting.EdgeVirtualInterface:
		return m.clearedvirtual_interface
	case devicerouting.EdgeSchedules:
		return m.clearedschedules
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DeviceRoutingMutation) ClearEdge(name string) error {
	switch name {
	case devicerouting.EdgeRouter:
		m.ClearRouter()
		return nil
	case devicerouting.EdgeInstance:
		m.ClearInstance()
		return nil
	case devicerouting.EdgeVirtualInterface:
		m.ClearVirtualInterface()
		return nil
	}
	return fmt.Errorf("unknown DeviceRouting unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DeviceRoutingMutation) ResetEdge(name string) error {
	switch name {
	case devicerouting.EdgeRouter:
		m.ResetRouter()
		return nil
	case devicerouting.EdgeInstance:
		m.ResetInstance()
		return nil
	case devicerouting.EdgeVirtualInterface:
		m.ResetVirtualInterface()
		return nil
	case devicerouting.EdgeSchedules:
		m.ResetSchedules()
		return nil
	}
	return fmt.Errorf("unknown DeviceRouting edge %s", name)
}

// DiagnosticResultMutation represents an operation that mutates the DiagnosticResult nodes in the graph.
type DiagnosticResultMutation struct {
	config
	op                      Op
	typ                     string
	id                      *string
	test_name               *string
	status                  *diagnosticresult.Status
	message                 *string
	details                 *string
	duration_ms             *int64
	addduration_ms          *int64
	run_group_id            *string
	metadata                *map[string]string
	error_message           *string
	created_at              *time.Time
	clearedFields           map[string]struct{}
	service_instance        *string
	clearedservice_instance bool
	done                    bool
	oldValue                func(context.Context) (*DiagnosticResult, error)
	predicates              []predicate.DiagnosticResult
}

var _ ent.Mutation = (*DiagnosticResultMutation)(nil)

// diagnosticresultOption allows management of the mutation configuration using functional options.
type diagnosticresultOption func(*DiagnosticResultMutation)

// newDiagnosticResultMutation creates new mutation for the DiagnosticResult entity.
func newDiagnosticResultMutation(c config, op Op, opts ...diagnosticresultOption) *DiagnosticResultMutation {
	m := &DiagnosticResultMutation{
		config:        c,
		op:            op,
		typ:           TypeDiagnosticResult,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDiagnosticResultID sets the ID field of the mutation.
func withDiagnosticResultID(id string) diagnosticresultOption {
	return func(m *DiagnosticResultMutation) {
		var (
			err   error
			once  sync.Once
			value *DiagnosticResult
		)
		m.oldValue = func(ctx context.Context) (*DiagnosticResult, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().DiagnosticResult.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDiagnosticResult sets the old DiagnosticResult of the mutation.
func withDiagnosticResult(node *DiagnosticResult) diagnosticresultOption {
	return func(m *DiagnosticResultMutation) {
		m.oldValue = func(context.Context) (*DiagnosticResult, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DiagnosticResultMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DiagnosticResultMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of DiagnosticResult entities.
func (m *DiagnosticResultMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DiagnosticResultMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DiagnosticResultMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().DiagnosticResult.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetInstanceID sets the "instance_id" field.
func (m *DiagnosticResultMutation) SetInstanceID(s string) {
	m.service_instance = &s
}

// InstanceID returns the value of the "instance_id" field in the mutation.
func (m *DiagnosticResultMutation) InstanceID() (r string, exists bool) {
	v := m.service_instance
	if v == nil {
		return
	}
	return *v, true
}

// OldInstanceID returns the old "instance_id" field's value of the DiagnosticResult entity.
// If the DiagnosticResult object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DiagnosticResultMutation) OldInstanceID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInstanceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInstanceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInstanceID: %w", err)
	}
	return oldValue.InstanceID, nil
}

// ResetInstanceID resets all changes to the "instance_id" field.
func (m *DiagnosticResultMutation) ResetInstanceID() {
	m.service_instance = nil
}

// SetTestName sets the "test_name" field.
func (m *DiagnosticResultMutation) SetTestName(s string) {
	m.test_name = &s
}

// TestName returns the value of the "test_name" field in the mutation.
func (m *DiagnosticResultMutation) TestName() (r string, exists bool) {
	v := m.test_name
	if v == nil {
		return
	}
	return *v, true
}

// OldTestName returns the old "test_name" field's value of the DiagnosticResult entity.
// If the DiagnosticResult object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DiagnosticResultMutation) OldTestName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTestName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTestName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTestName: %w", err)
	}
	return oldValue.TestName, nil
}

// ResetTestName resets all changes to the "test_name" field.
func (m *DiagnosticResultMutation) ResetTestName() {
	m.test_name = nil
}

// SetStatus sets the "status" field.
func (m *DiagnosticResultMutation) SetStatus(d diagnosticresult.Status) {
	m.status = &d
}

// Status returns the value of the "status" field in the mutation.
func (m *DiagnosticResultMutation) Status() (r diagnosticresult.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the DiagnosticResult entity.
// If the DiagnosticResult object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DiagnosticResultMutation) OldStatus(ctx context.Context) (v diagnosticresult.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *DiagnosticResultMutation) ResetStatus() {
	m.status = nil
}

// SetMessage sets the "message" field.
func (m *DiagnosticResultMutation) SetMessage(s string) {
	m.message = &s
}

// Message returns the value of the "message" field in the mutation.
func (m *DiagnosticResultMutation) Message() (r string, exists bool) {
	v := m.message
	if v == nil {
		return
	}
	return *v, true
}

// OldMessage returns the old "message" field's value of the DiagnosticResult entity.
// If the DiagnosticResult object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DiagnosticResultMutation) OldMessage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMessage: %w", err)
	}
	return oldValue.Message, nil
}

// ResetMessage resets all changes to the "message" field.
func (m *DiagnosticResultMutation) ResetMessage() {
	m.message = nil
}

// SetDetails sets the "details" field.
func (m *DiagnosticResultMutation) SetDetails(s string) {
	m.details = &s
}

// Details returns the value of the "details" field in the mutation.
func (m *DiagnosticResultMutation) Details() (r string, exists bool) {
	v := m.details
	if v == nil {
		return
	}
	return *v, true
}

// OldDetails returns the old "details" field's value of the DiagnosticResult entity.
// If the DiagnosticResult object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DiagnosticResultMutation) OldDetails(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDetails is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDetails requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDetails: %w", err)
	}
	return oldValue.Details, nil
}

// ClearDetails clears the value of the "details" field.
func (m *DiagnosticResultMutation) ClearDetails() {
	m.details = nil
	m.clearedFields[diagnosticresult.FieldDetails] = struct{}{}
}

// DetailsCleared returns if the "details" field was cleared in this mutation.
func (m *DiagnosticResultMutation) DetailsCleared() bool {
	_, ok := m.clearedFields[diagnosticresult.FieldDetails]
	return ok
}

// ResetDetails resets all changes to the "details" field.
func (m *DiagnosticResultMutation) ResetDetails() {
	m.details = nil
	delete(m.clearedFields, diagnosticresult.FieldDetails)
}

// SetDurationMs sets the "duration_ms" field.
func (m *DiagnosticResultMutation) SetDurationMs(i int64) {
	m.duration_ms = &i
	m.addduration_ms = nil
}

// DurationMs returns the value of the "duration_ms" field in the mutation.
func (m *DiagnosticResultMutation) DurationMs() (r int64, exists bool) {
	v := m.duration_ms
	if v == nil {
		return
	}
	return *v, true
}

// OldDurationMs returns the old "duration_ms" field's value of the DiagnosticResult entity.
// If the DiagnosticResult object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DiagnosticResultMutation) OldDurationMs(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDurationMs is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDurationMs requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDurationMs: %w", err)
	}
	return oldValue.DurationMs, nil
}

// AddDurationMs adds i to the "duration_ms" field.
func (m *DiagnosticResultMutation) AddDurationMs(i int64) {
	if m.addduration_ms != nil {
		*m.addduration_ms += i
	} else {
		m.addduration_ms = &i
	}
}

// AddedDurationMs returns the value that was added to the "duration_ms" field in this mutation.
func (m *DiagnosticResultMutation) AddedDurationMs() (r int64, exists bool) {
	v := m.addduration_ms
	if v == nil {
		return
	}
	return *v, true
}

// ResetDurationMs resets all changes to the "duration_ms" field.
func (m *DiagnosticResultMutation) ResetDurationMs() {
	m.duration_ms = nil
	m.addduration_ms = nil
}

// SetRunGroupID sets the "run_group_id" field.
func (m *DiagnosticResultMutation) SetRunGroupID(s string) {
	m.run_group_id = &s
}

// RunGroupID returns the value of the "run_group_id" field in the mutation.
func (m *DiagnosticResultMutation) RunGroupID() (r string, exists bool) {
	v := m.run_group_id
	if v == nil {
		return
	}
	return *v, true
}

// OldRunGroupID returns the old "run_group_id" field's value of the DiagnosticResult entity.
// If the DiagnosticResult object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DiagnosticResultMutation) OldRunGroupID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRunGroupID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRunGroupID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRunGroupID: %w", err)
	}
	return oldValue.RunGroupID, nil
}

// ClearRunGroupID clears the value of the "run_group_id" field.
func (m *DiagnosticResultMutation) ClearRunGroupID() {
	m.run_group_id = nil
	m.clearedFields[diagnosticresult.FieldRunGroupID] = struct{}{}
}

// RunGroupIDCleared returns if the "run_group_id" field was cleared in this mutation.
func (m *DiagnosticResultMutation) RunGroupIDCleared() bool {
	_, ok := m.clearedFields[diagnosticresult.FieldRunGroupID]
	return ok
}

// ResetRunGroupID resets all changes to the "run_group_id" field.
func (m *DiagnosticResultMutation) ResetRunGroupID() {
	m.run_group_id = nil
	delete(m.clearedFields, diagnosticresult.FieldRunGroupID)
}

// SetMetadata sets the "metadata" field.
func (m *DiagnosticResultMutation) SetMetadata(value map[string]string) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *DiagnosticResultMutation) Metadata() (r map[string]string, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the DiagnosticResult entity.
// If the DiagnosticResult object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DiagnosticResultMutation) OldMetadata(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *DiagnosticResultMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[diagnosticresult.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *DiagnosticResultMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[diagnosticresult.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *DiagnosticResultMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, diagnosticresult.FieldMetadata)
}

// SetErrorMessage sets the "error_message" field.
func (m *DiagnosticResultMutation) SetErrorMessage(s string) {
	m.error_message = &s
}

// ErrorMessage returns the value of the "error_message" field in the mutation.
func (m *DiagnosticResultMutation) ErrorMessage() (r string, exists bool) {
	v := m.error_message
	if v == nil {
		return
	}
	return *v, true
}

// OldErrorMessage returns the old "error_message" field's value of the DiagnosticResult entity.
// If the DiagnosticResult object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DiagnosticResultMutation) OldErrorMessage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldErrorMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldErrorMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldErrorMessage: %w", err)
	}
	return oldValue.ErrorMessage, nil
}

// ClearErrorMessage clears the value of the "error_message" field.
func (m *DiagnosticResultMutation) ClearErrorMessage() {
	m.error_message = nil
	m.clearedFields[diagnosticresult.FieldErrorMessage] = struct{}{}
}

// ErrorMessageCleared returns if the "error_message" field was cleared in this mutation.
func (m *DiagnosticResultMutation) ErrorMessageCleared() bool {
	_, ok := m.clearedFields[diagnosticresult.FieldErrorMessage]
	return ok
}

// ResetErrorMessage resets all changes to the "error_message" field.
func (m *DiagnosticResultMutation) ResetErrorMessage() {
	m.error_message = nil
	delete(m.clearedFields, diagnosticresult.FieldErrorMessage)
}

// SetCreatedAt sets the "created_at" field.
func (m *DiagnosticResultMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *DiagnosticResultMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the DiagnosticResult entity.
// If the DiagnosticResult object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DiagnosticResultMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *DiagnosticResultMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetServiceInstanceID sets the "service_instance" edge to the ServiceInstance entity by id.
func (m *DiagnosticResultMutation) SetServiceInstanceID(id string) {
	m.service_instance = &id
}

// ClearServiceInstance clears the "service_instance" edge to the ServiceInstance entity.
func (m *DiagnosticResultMutation) ClearServiceInstance() {
	m.clearedservice_instance = true
	m.clearedFields[diagnosticresult.FieldInstanceID] = struct{}{}
}

// ServiceInstanceCleared reports if the "service_instance" edge to the ServiceInstance entity was cleared.
func (m *DiagnosticResultMutation) ServiceInstanceCleared() bool {
	return m.clearedservice_instance
}

// ServiceInstanceID returns the "service_instance" edge ID in the mutation.
func (m *DiagnosticResultMutation) ServiceInstanceID() (id string, exists bool) {
	if m.service_instance != nil {
		return *m.service_instance, true
	}
	return
}

// ServiceInstanceIDs returns the "service_instance" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ServiceInstanceID instead. It exists only for internal usage by the builders.
func (m *DiagnosticResultMutation) ServiceInstanceIDs() (ids []string) {
	if id := m.service_instance; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetServiceInstance resets all changes to the "service_instance" edge.
func (m *DiagnosticResultMutation) ResetServiceInstance() {
	m.service_instance = nil
	m.clearedservice_instance = false
}

// Where appends a list predicates to the DiagnosticResultMutation builder.
func (m *DiagnosticResultMutation) Where(ps ...predicate.DiagnosticResult) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DiagnosticResultMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DiagnosticResultMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.DiagnosticResult, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DiagnosticResultMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DiagnosticResultMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (DiagnosticResult).
func (m *DiagnosticResultMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DiagnosticResultMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.service_instance != nil {
		fields = append(fields, diagnosticresult.FieldInstanceID)
	}
	if m.test_name != nil {
		fields = append(fields, diagnosticresult.FieldTestName)
	}
	if m.status != nil {
		fields = append(fields, diagnosticresult.FieldStatus)
	}
	if m.message != nil {
		fields = append(fields, diagnosticresult.FieldMessage)
	}
	if m.details != nil {
		fields = append(fields, diagnosticresult.FieldDetails)
	}
	if m.duration_ms != nil {
		fields = append(fields, diagnosticresult.FieldDurationMs)
	}
	if m.run_group_id != nil {
		fields = append(fields, diagnosticresult.FieldRunGroupID)
	}
	if m.metadata != nil {
		fields = append(fields, diagnosticresult.FieldMetadata)
	}
	if m.error_message != nil {
		fields = append(fields, diagnosticresult.FieldErrorMessage)
	}
	if m.created_at != nil {
		fields = append(fields, diagnosticresult.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DiagnosticResultMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case diagnosticresult.FieldInstanceID:
		return m.InstanceID()
	case diagnosticresult.FieldTestName:
		return m.TestName()
	case diagnosticresult.FieldStatus:
		return m.Status()
	case diagnosticresult.FieldMessage:
		return m.Message()
	case diagnosticresult.FieldDetails:
		return m.Details()
	case diagnosticresult.FieldDurationMs:
		return m.DurationMs()
	case diagnosticresult.FieldRunGroupID:
		return m.RunGroupID()
	case diagnosticresult.FieldMetadata:
		return m.Metadata()
	case diagnosticresult.FieldErrorMessage:
		return m.ErrorMessage()
	case diagnosticresult.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DiagnosticResultMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case diagnosticresult.FieldInstanceID:
		return m.OldInstanceID(ctx)
	case diagnosticresult.FieldTestName:
		return m.OldTestName(ctx)
	case diagnosticresult.FieldStatus:
		return m.OldStatus(ctx)
	case diagnosticresult.FieldMessage:
		return m.OldMessage(ctx)
	case diagnosticresult.FieldDetails:
		return m.OldDetails(ctx)
	case diagnosticresult.FieldDurationMs:
		return m.OldDurationMs(ctx)
	case diagnosticresult.FieldRunGroupID:
		return m.OldRunGroupID(ctx)
	case diagnosticresult.FieldMetadata:
		return m.OldMetadata(ctx)
	case diagnosticresult.FieldErrorMessage:
		return m.OldErrorMessage(ctx)
	case diagnosticresult.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown DiagnosticResult field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DiagnosticResultMutation) SetField(name string, value ent.Value) error {
	switch name {
	case diagnosticresult.FieldInstanceID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInstanceID(v)
		return nil
	case diagnosticresult.FieldTestName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTestName(v)
		return nil
	case diagnosticresult.FieldStatus:
		v, ok := value.(diagnosticresult.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case diagnosticresult.FieldMessage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMessage(v)
		return nil
	case diagnosticresult.FieldDetails:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDetails(v)
		return nil
	case diagnosticresult.FieldDurationMs:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDurationMs(v)
		return nil
	case diagnosticresult.FieldRunGroupID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRunGroupID(v)
		return nil
	case diagnosticresult.FieldMetadata:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	case diagnosticresult.FieldErrorMessage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetErrorMessage(v)
		return nil
	case diagnosticresult.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown DiagnosticResult field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DiagnosticResultMutation) AddedFields() []string {
	var fields []string
	if m.addduration_ms != nil {
		fields = append(fields, diagnosticresult.FieldDurationMs)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DiagnosticResultMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case diagnosticresult.FieldDurationMs:
		return m.AddedDurationMs()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DiagnosticResultMutation) AddField(name string, value ent.Value) error {
	switch name {
	case diagnosticresult.FieldDurationMs:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDurationMs(v)
		return nil
	}
	return fmt.Errorf("unknown DiagnosticResult numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DiagnosticResultMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(diagnosticresult.FieldDetails) {
		fields = append(fields, diagnosticresult.FieldDetails)
	}
	if m.FieldCleared(diagnosticresult.FieldRunGroupID) {
		fields = append(fields, diagnosticresult.FieldRunGroupID)
	}
	if m.FieldCleared(diagnosticresult.FieldMetadata) {
		fields = append(fields, diagnosticresult.FieldMetadata)
	}
	if m.FieldCleared(diagnosticresult.FieldErrorMessage) {
		fields = append(fields, diagnosticresult.FieldErrorMessage)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DiagnosticResultMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DiagnosticResultMutation) ClearField(name string) error {
	switch name {
	case diagnosticresult.FieldDetails:
		m.ClearDetails()
		return nil
	case diagnosticresult.FieldRunGroupID:
		m.ClearRunGroupID()
		return nil
	case diagnosticresult.FieldMetadata:
		m.ClearMetadata()
		return nil
	case diagnosticresult.FieldErrorMessage:
		m.ClearErrorMessage()
		return nil
	}
	return fmt.Errorf("unknown DiagnosticResult nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DiagnosticResultMutation) ResetField(name string) error {
	switch name {
	case diagnosticresult.FieldInstanceID:
		m.ResetInstanceID()
		return nil
	case diagnosticresult.FieldTestName:
		m.ResetTestName()
		return nil
	case diagnosticresult.FieldStatus:
		m.ResetStatus()
		return nil
	case diagnosticresult.FieldMessage:
		m.ResetMessage()
		return nil
	case diagnosticresult.FieldDetails:
		m.ResetDetails()
		return nil
	case diagnosticresult.FieldDurationMs:
		m.ResetDurationMs()
		return nil
	case diagnosticresult.FieldRunGroupID:
		m.ResetRunGroupID()
		return nil
	case diagnosticresult.FieldMetadata:
		m.ResetMetadata()
		return nil
	case diagnosticresult.FieldErrorMessage:
		m.ResetErrorMessage()
		return nil
	case diagnosticresult.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown DiagnosticResult field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DiagnosticResultMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.service_instance != nil {
		edges = append(edges, diagnosticresult.EdgeServiceInstance)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DiagnosticResultMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case diagnosticresult.EdgeServiceInstance:
		if id := m.service_instance; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DiagnosticResultMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DiagnosticResultMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DiagnosticResultMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedservice_instance {
		edges = append(edges, diagnosticresult.EdgeServiceInstance)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DiagnosticResultMutation) EdgeCleared(name string) bool {
	switch name {
	case diagnosticresult.EdgeServiceInstance:
		return m.clearedservice_instance
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DiagnosticResultMutation) ClearEdge(name string) error {
	switch name {
	case diagnosticresult.EdgeServiceInstance:
		m.ClearServiceInstance()
		return nil
	}
	return fmt.Errorf("unknown DiagnosticResult unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DiagnosticResultMutation) ResetEdge(name string) error {
	switch name {
	case diagnosticresult.EdgeServiceInstance:
		m.ResetServiceInstance()
		return nil
	}
	return fmt.Errorf("unknown DiagnosticResult edge %s", name)
}

// GlobalSettingsMutation represents an operation that mutates the GlobalSettings nodes in the graph.
type GlobalSettingsMutation struct {
	config
	op               Op
	typ              string
	id               *string
	namespace        *string
	key              *string
	value            *map[string]interface{}
	value_type       *globalsettings.ValueType
	description      *string
	editable         *bool
	requires_restart *bool
	sensitive        *bool
	created_at       *time.Time
	updated_at       *time.Time
	clearedFields    map[string]struct{}
	done             bool
	oldValue         func(context.Context) (*GlobalSettings, error)
	predicates       []predicate.GlobalSettings
}

var _ ent.Mutation = (*GlobalSettingsMutation)(nil)

// globalsettingsOption allows management of the mutation configuration using functional options.
type globalsettingsOption func(*GlobalSettingsMutation)

// newGlobalSettingsMutation creates new mutation for the GlobalSettings entity.
func newGlobalSettingsMutation(c config, op Op, opts ...globalsettingsOption) *GlobalSettingsMutation {
	m := &GlobalSettingsMutation{
		config:        c,
		op:            op,
		typ:           TypeGlobalSettings,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withGlobalSettingsID sets the ID field of the mutation.
func withGlobalSettingsID(id string) globalsettingsOption {
	return func(m *GlobalSettingsMutation) {
		var (
			err   error
			once  sync.Once
			value *GlobalSettings
		)
		m.oldValue = func(ctx context.Context) (*GlobalSettings, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().GlobalSettings.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withGlobalSettings sets the old GlobalSettings of the mutation.
func withGlobalSettings(node *GlobalSettings) globalsettingsOption {
	return func(m *GlobalSettingsMutation) {
		m.oldValue = func(context.Context) (*GlobalSettings, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m GlobalSettingsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m GlobalSettingsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of GlobalSettings entities.
func (m *GlobalSettingsMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *GlobalSettingsMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *GlobalSettingsMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().GlobalSettings.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetNamespace sets the "namespace" field.
func (m *GlobalSettingsMutation) SetNamespace(s string) {
	m.namespace = &s
}

// Namespace returns the value of the "namespace" field in the mutation.
func (m *GlobalSettingsMutation) Namespace() (r string, exists bool) {
	v := m.namespace
	if v == nil {
		return
	}
	return *v, true
}

// OldNamespace returns the old "namespace" field's value of the GlobalSettings entity.
// If the GlobalSettings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GlobalSettingsMutation) OldNamespace(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNamespace is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNamespace requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNamespace: %w", err)
	}
	return oldValue.Namespace, nil
}

// ResetNamespace resets all changes to the "namespace" field.
func (m *GlobalSettingsMutation) ResetNamespace() {
	m.namespace = nil
}

// SetKey sets the "key" field.
func (m *GlobalSettingsMutation) SetKey(s string) {
	m.key = &s
}

// Key returns the value of the "key" field in the mutation.
func (m *GlobalSettingsMutation) Key() (r string, exists bool) {
	v := m.key
	if v == nil {
		return
	}
	return *v, true
}

// OldKey returns the old "key" field's value of the GlobalSettings entity.
// If the GlobalSettings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GlobalSettingsMutation) OldKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKey: %w", err)
	}
	return oldValue.Key, nil
}

// ResetKey resets all changes to the "key" field.
func (m *GlobalSettingsMutation) ResetKey() {
	m.key = nil
}

// SetValue sets the "value" field.
func (m *GlobalSettingsMutation) SetValue(value map[string]interface{}) {
	m.value = &value
}

// Value returns the value of the "value" field in the mutation.
func (m *GlobalSettingsMutation) Value() (r map[string]interface{}, exists bool) {
	v := m.value
	if v == nil {
		return
	}
	return *v, true
}

// OldValue returns the old "value" field's value of the GlobalSettings entity.
// If the GlobalSettings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GlobalSettingsMutation) OldValue(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValue: %w", err)
	}
	return oldValue.Value, nil
}

// ResetValue resets all changes to the "value" field.
func (m *GlobalSettingsMutation) ResetValue() {
	m.value = nil
}

// SetValueType sets the "value_type" field.
func (m *GlobalSettingsMutation) SetValueType(gt globalsettings.ValueType) {
	m.value_type = &gt
}

// ValueType returns the value of the "value_type" field in the mutation.
func (m *GlobalSettingsMutation) ValueType() (r globalsettings.ValueType, exists bool) {
	v := m.value_type
	if v == nil {
		return
	}
	return *v, true
}

// OldValueType returns the old "value_type" field's value of the GlobalSettings entity.
// If the GlobalSettings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GlobalSettingsMutation) OldValueType(ctx context.Context) (v globalsettings.ValueType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValueType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValueType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValueType: %w", err)
	}
	return oldValue.ValueType, nil
}

// ResetValueType resets all changes to the "value_type" field.
func (m *GlobalSettingsMutation) ResetValueType() {
	m.value_type = nil
}

// SetDescription sets the "description" field.
func (m *GlobalSettingsMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *GlobalSettingsMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the GlobalSettings entity.
// If the GlobalSettings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GlobalSettingsMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *GlobalSettingsMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[globalsettings.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *GlobalSettingsMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[globalsettings.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *GlobalSettingsMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, globalsettings.FieldDescription)
}

// SetEditable sets the "editable" field.
func (m *GlobalSettingsMutation) SetEditable(b bool) {
	m.editable = &b
}

// Editable returns the value of the "editable" field in the mutation.
func (m *GlobalSettingsMutation) Editable() (r bool, exists bool) {
	v := m.editable
	if v == nil {
		return
	}
	return *v, true
}

// OldEditable returns the old "editable" field's value of the GlobalSettings entity.
// If the GlobalSettings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GlobalSettingsMutation) OldEditable(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEditable is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEditable requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEditable: %w", err)
	}
	return oldValue.Editable, nil
}

// ResetEditable resets all changes to the "editable" field.
func (m *GlobalSettingsMutation) ResetEditable() {
	m.editable = nil
}

// SetRequiresRestart sets the "requires_restart" field.
func (m *GlobalSettingsMutation) SetRequiresRestart(b bool) {
	m.requires_restart = &b
}

// RequiresRestart returns the value of the "requires_restart" field in the mutation.
func (m *GlobalSettingsMutation) RequiresRestart() (r bool, exists bool) {
	v := m.requires_restart
	if v == nil {
		return
	}
	return *v, true
}

// OldRequiresRestart returns the old "requires_restart" field's value of the GlobalSettings entity.
// If the GlobalSettings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GlobalSettingsMutation) OldRequiresRestart(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRequiresRestart is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRequiresRestart requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRequiresRestart: %w", err)
	}
	return oldValue.RequiresRestart, nil
}

// ResetRequiresRestart resets all changes to the "requires_restart" field.
func (m *GlobalSettingsMutation) ResetRequiresRestart() {
	m.requires_restart = nil
}

// SetSensitive sets the "sensitive" field.
func (m *GlobalSettingsMutation) SetSensitive(b bool) {
	m.sensitive = &b
}

// Sensitive returns the value of the "sensitive" field in the mutation.
func (m *GlobalSettingsMutation) Sensitive() (r bool, exists bool) {
	v := m.sensitive
	if v == nil {
		return
	}
	return *v, true
}

// OldSensitive returns the old "sensitive" field's value of the GlobalSettings entity.
// If the GlobalSettings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GlobalSettingsMutation) OldSensitive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSensitive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSensitive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSensitive: %w", err)
	}
	return oldValue.Sensitive, nil
}

// ResetSensitive resets all changes to the "sensitive" field.
func (m *GlobalSettingsMutation) ResetSensitive() {
	m.sensitive = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *GlobalSettingsMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *GlobalSettingsMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the GlobalSettings entity.
// If the GlobalSettings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GlobalSettingsMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *GlobalSettingsMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *GlobalSettingsMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *GlobalSettingsMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the GlobalSettings entity.
// If the GlobalSettings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GlobalSettingsMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *GlobalSettingsMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// Where appends a list predicates to the GlobalSettingsMutation builder.
func (m *GlobalSettingsMutation) Where(ps ...predicate.GlobalSettings) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the GlobalSettingsMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *GlobalSettingsMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.GlobalSettings, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *GlobalSettingsMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *GlobalSettingsMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (GlobalSettings).
func (m *GlobalSettingsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *GlobalSettingsMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.namespace != nil {
		fields = append(fields, globalsettings.FieldNamespace)
	}
	if m.key != nil {
		fields = append(fields, globalsettings.FieldKey)
	}
	if m.value != nil {
		fields = append(fields, globalsettings.FieldValue)
	}
	if m.value_type != nil {
		fields = append(fields, globalsettings.FieldValueType)
	}
	if m.description != nil {
		fields = append(fields, globalsettings.FieldDescription)
	}
	if m.editable != nil {
		fields = append(fields, globalsettings.FieldEditable)
	}
	if m.requires_restart != nil {
		fields = append(fields, globalsettings.FieldRequiresRestart)
	}
	if m.sensitive != nil {
		fields = append(fields, globalsettings.FieldSensitive)
	}
	if m.created_at != nil {
		fields = append(fields, globalsettings.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, globalsettings.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *GlobalSettingsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case globalsettings.FieldNamespace:
		return m.Namespace()
	case globalsettings.FieldKey:
		return m.Key()
	case globalsettings.FieldValue:
		return m.Value()
	case globalsettings.FieldValueType:
		return m.ValueType()
	case globalsettings.FieldDescription:
		return m.Description()
	case globalsettings.FieldEditable:
		return m.Editable()
	case globalsettings.FieldRequiresRestart:
		return m.RequiresRestart()
	case globalsettings.FieldSensitive:
		return m.Sensitive()
	case globalsettings.FieldCreatedAt:
		return m.CreatedAt()
	case globalsettings.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *GlobalSettingsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case globalsettings.FieldNamespace:
		return m.OldNamespace(ctx)
	case globalsettings.FieldKey:
		return m.OldKey(ctx)
	case globalsettings.FieldValue:
		return m.OldValue(ctx)
	case globalsettings.FieldValueType:
		return m.OldValueType(ctx)
	case globalsettings.FieldDescription:
		return m.OldDescription(ctx)
	case globalsettings.FieldEditable:
		return m.OldEditable(ctx)
	case globalsettings.FieldRequiresRestart:
		return m.OldRequiresRestart(ctx)
	case globalsettings.FieldSensitive:
		return m.OldSensitive(ctx)
	case globalsettings.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case globalsettings.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown GlobalSettings field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GlobalSettingsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case globalsettings.FieldNamespace:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNamespace(v)
		return nil
	case globalsettings.FieldKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKey(v)
		return nil
	case globalsettings.FieldValue:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValue(v)
		return nil
	case globalsettings.FieldValueType:
		v, ok := value.(globalsettings.ValueType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValueType(v)
		return nil
	case globalsettings.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case globalsettings.FieldEditable:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEditable(v)
		return nil
	case globalsettings.FieldRequiresRestart:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRequiresRestart(v)
		return nil
	case globalsettings.FieldSensitive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSensitive(v)
		return nil
	case globalsettings.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case globalsettings.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown GlobalSettings field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *GlobalSettingsMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *GlobalSettingsMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GlobalSettingsMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown GlobalSettings numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *GlobalSettingsMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(globalsettings.FieldDescription) {
		fields = append(fields, globalsettings.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *GlobalSettingsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *GlobalSettingsMutation) ClearField(name string) error {
	switch name {
	case globalsettings.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown GlobalSettings nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *GlobalSettingsMutation) ResetField(name string) error {
	switch name {
	case globalsettings.FieldNamespace:
		m.ResetNamespace()
		return nil
	case globalsettings.FieldKey:
		m.ResetKey()
		return nil
	case globalsettings.FieldValue:
		m.ResetValue()
		return nil
	case globalsettings.FieldValueType:
		m.ResetValueType()
		return nil
	case globalsettings.FieldDescription:
		m.ResetDescription()
		return nil
	case globalsettings.FieldEditable:
		m.ResetEditable()
		return nil
	case globalsettings.FieldRequiresRestart:
		m.ResetRequiresRestart()
		return nil
	case globalsettings.FieldSensitive:
		m.ResetSensitive()
		return nil
	case globalsettings.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case globalsettings.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown GlobalSettings field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *GlobalSettingsMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *GlobalSettingsMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *GlobalSettingsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *GlobalSettingsMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *GlobalSettingsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *GlobalSettingsMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *GlobalSettingsMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown GlobalSettings unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *GlobalSettingsMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown GlobalSettings edge %s", name)
}

// NotificationChannelConfigMutation represents an operation that mutates the NotificationChannelConfig nodes in the graph.
type NotificationChannelConfigMutation struct {
	config
	op                Op
	typ               string
	id                *string
	create_time       *time.Time
	update_time       *time.Time
	channel_type      *notificationchannelconfig.ChannelType
	name              *string
	description       *string
	enabled           *bool
	is_default        *bool
	config_encrypted  *[]byte
	encryption_key_id *string
	created_by        *string
	updated_by        *string
	deleted_at        *time.Time
	clearedFields     map[string]struct{}
	done              bool
	oldValue          func(context.Context) (*NotificationChannelConfig, error)
	predicates        []predicate.NotificationChannelConfig
}

var _ ent.Mutation = (*NotificationChannelConfigMutation)(nil)

// notificationchannelconfigOption allows management of the mutation configuration using functional options.
type notificationchannelconfigOption func(*NotificationChannelConfigMutation)

// newNotificationChannelConfigMutation creates new mutation for the NotificationChannelConfig entity.
func newNotificationChannelConfigMutation(c config, op Op, opts ...notificationchannelconfigOption) *NotificationChannelConfigMutation {
	m := &NotificationChannelConfigMutation{
		config:        c,
		op:            op,
		typ:           TypeNotificationChannelConfig,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withNotificationChannelConfigID sets the ID field of the mutation.
func withNotificationChannelConfigID(id string) notificationchannelconfigOption {
	return func(m *NotificationChannelConfigMutation) {
		var (
			err   error
			once  sync.Once
			value *NotificationChannelConfig
		)
		m.oldValue = func(ctx context.Context) (*NotificationChannelConfig, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().NotificationChannelConfig.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withNotificationChannelConfig sets the old NotificationChannelConfig of the mutation.
func withNotificationChannelConfig(node *NotificationChannelConfig) notificationchannelconfigOption {
	return func(m *NotificationChannelConfigMutation) {
		m.oldValue = func(context.Context) (*NotificationChannelConfig, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m NotificationChannelConfigMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m NotificationChannelConfigMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of NotificationChannelConfig entities.
func (m *NotificationChannelConfigMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *NotificationChannelConfigMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *NotificationChannelConfigMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().NotificationChannelConfig.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *NotificationChannelConfigMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *NotificationChannelConfigMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the NotificationChannelConfig entity.
// If the NotificationChannelConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationChannelConfigMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *NotificationChannelConfigMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *NotificationChannelConfigMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *NotificationChannelConfigMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the NotificationChannelConfig entity.
// If the NotificationChannelConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationChannelConfigMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *NotificationChannelConfigMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetChannelType sets the "channel_type" field.
func (m *NotificationChannelConfigMutation) SetChannelType(nt notificationchannelconfig.ChannelType) {
	m.channel_type = &nt
}

// ChannelType returns the value of the "channel_type" field in the mutation.
func (m *NotificationChannelConfigMutation) ChannelType() (r notificationchannelconfig.ChannelType, exists bool) {
	v := m.channel_type
	if v == nil {
		return
	}
	return *v, true
}

// OldChannelType returns the old "channel_type" field's value of the NotificationChannelConfig entity.
// If the NotificationChannelConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationChannelConfigMutation) OldChannelType(ctx context.Context) (v notificationchannelconfig.ChannelType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChannelType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChannelType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChannelType: %w", err)
	}
	return oldValue.ChannelType, nil
}

// ResetChannelType resets all changes to the "channel_type" field.
func (m *NotificationChannelConfigMutation) ResetChannelType() {
	m.channel_type = nil
}

// SetName sets the "name" field.
func (m *NotificationChannelConfigMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *NotificationChannelConfigMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the NotificationChannelConfig entity.
// If the NotificationChannelConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationChannelConfigMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *NotificationChannelConfigMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *NotificationChannelConfigMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *NotificationChannelConfigMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the NotificationChannelConfig entity.
// If the NotificationChannelConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationChannelConfigMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *NotificationChannelConfigMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[notificationchannelconfig.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *NotificationChannelConfigMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[notificationchannelconfig.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *NotificationChannelConfigMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, notificationchannelconfig.FieldDescription)
}

// SetEnabled sets the "enabled" field.
func (m *NotificationChannelConfigMutation) SetEnabled(b bool) {
	m.enabled = &b
}

// Enabled returns the value of the "enabled" field in the mutation.
func (m *NotificationChannelConfigMutation) Enabled() (r bool, exists bool) {
	v := m.enabled
	if v == nil {
		return
	}
	return *v, true
}

// OldEnabled returns the old "enabled" field's value of the NotificationChannelConfig entity.
// If the NotificationChannelConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationChannelConfigMutation) OldEnabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnabled: %w", err)
	}
	return oldValue.Enabled, nil
}

// ResetEnabled resets all changes to the "enabled" field.
func (m *NotificationChannelConfigMutation) ResetEnabled() {
	m.enabled = nil
}

// SetIsDefault sets the "is_default" field.
func (m *NotificationChannelConfigMutation) SetIsDefault(b bool) {
	m.is_default = &b
}

// IsDefault returns the value of the "is_default" field in the mutation.
func (m *NotificationChannelConfigMutation) IsDefault() (r bool, exists bool) {
	v := m.is_default
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDefault returns the old "is_default" field's value of the NotificationChannelConfig entity.
// If the NotificationChannelConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationChannelConfigMutation) OldIsDefault(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsDefault is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsDefault requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDefault: %w", err)
	}
	return oldValue.IsDefault, nil
}

// ResetIsDefault resets all changes to the "is_default" field.
func (m *NotificationChannelConfigMutation) ResetIsDefault() {
	m.is_default = nil
}

// SetConfigEncrypted sets the "config_encrypted" field.
func (m *NotificationChannelConfigMutation) SetConfigEncrypted(b []byte) {
	m.config_encrypted = &b
}

// ConfigEncrypted returns the value of the "config_encrypted" field in the mutation.
func (m *NotificationChannelConfigMutation) ConfigEncrypted() (r []byte, exists bool) {
	v := m.config_encrypted
	if v == nil {
		return
	}
	return *v, true
}

// OldConfigEncrypted returns the old "config_encrypted" field's value of the NotificationChannelConfig entity.
// If the NotificationChannelConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationChannelConfigMutation) OldConfigEncrypted(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConfigEncrypted is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConfigEncrypted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConfigEncrypted: %w", err)
	}
	return oldValue.ConfigEncrypted, nil
}

// ResetConfigEncrypted resets all changes to the "config_encrypted" field.
func (m *NotificationChannelConfigMutation) ResetConfigEncrypted() {
	m.config_encrypted = nil
}

// SetEncryptionKeyID sets the "encryption_key_id" field.
func (m *NotificationChannelConfigMutation) SetEncryptionKeyID(s string) {
	m.encryption_key_id = &s
}

// EncryptionKeyID returns the value of the "encryption_key_id" field in the mutation.
func (m *NotificationChannelConfigMutation) EncryptionKeyID() (r string, exists bool) {
	v := m.encryption_key_id
	if v == nil {
		return
	}
	return *v, true
}

// OldEncryptionKeyID returns the old "encryption_key_id" field's value of the NotificationChannelConfig entity.
// If the NotificationChannelConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationChannelConfigMutation) OldEncryptionKeyID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEncryptionKeyID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEncryptionKeyID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEncryptionKeyID: %w", err)
	}
	return oldValue.EncryptionKeyID, nil
}

// ResetEncryptionKeyID resets all changes to the "encryption_key_id" field.
func (m *NotificationChannelConfigMutation) ResetEncryptionKeyID() {
	m.encryption_key_id = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *NotificationChannelConfigMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *NotificationChannelConfigMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the NotificationChannelConfig entity.
// If the NotificationChannelConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationChannelConfigMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *NotificationChannelConfigMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[notificationchannelconfig.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *NotificationChannelConfigMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[notificationchannelconfig.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *NotificationChannelConfigMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, notificationchannelconfig.FieldCreatedBy)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *NotificationChannelConfigMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *NotificationChannelConfigMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the NotificationChannelConfig entity.
// If the NotificationChannelConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationChannelConfigMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *NotificationChannelConfigMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[notificationchannelconfig.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *NotificationChannelConfigMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[notificationchannelconfig.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *NotificationChannelConfigMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, notificationchannelconfig.FieldUpdatedBy)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *NotificationChannelConfigMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *NotificationChannelConfigMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the NotificationChannelConfig entity.
// If the NotificationChannelConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationChannelConfigMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *NotificationChannelConfigMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[notificationchannelconfig.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *NotificationChannelConfigMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[notificationchannelconfig.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *NotificationChannelConfigMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, notificationchannelconfig.FieldDeletedAt)
}

// Where appends a list predicates to the NotificationChannelConfigMutation builder.
func (m *NotificationChannelConfigMutation) Where(ps ...predicate.NotificationChannelConfig) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the NotificationChannelConfigMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *NotificationChannelConfigMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.NotificationChannelConfig, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *NotificationChannelConfigMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *NotificationChannelConfigMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (NotificationChannelConfig).
func (m *NotificationChannelConfigMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *NotificationChannelConfigMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.create_time != nil {
		fields = append(fields, notificationchannelconfig.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, notificationchannelconfig.FieldUpdateTime)
	}
	if m.channel_type != nil {
		fields = append(fields, notificationchannelconfig.FieldChannelType)
	}
	if m.name != nil {
		fields = append(fields, notificationchannelconfig.FieldName)
	}
	if m.description != nil {
		fields = append(fields, notificationchannelconfig.FieldDescription)
	}
	if m.enabled != nil {
		fields = append(fields, notificationchannelconfig.FieldEnabled)
	}
	if m.is_default != nil {
		fields = append(fields, notificationchannelconfig.FieldIsDefault)
	}
	if m.config_encrypted != nil {
		fields = append(fields, notificationchannelconfig.FieldConfigEncrypted)
	}
	if m.encryption_key_id != nil {
		fields = append(fields, notificationchannelconfig.FieldEncryptionKeyID)
	}
	if m.created_by != nil {
		fields = append(fields, notificationchannelconfig.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, notificationchannelconfig.FieldUpdatedBy)
	}
	if m.deleted_at != nil {
		fields = append(fields, notificationchannelconfig.FieldDeletedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *NotificationChannelConfigMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case notificationchannelconfig.FieldCreateTime:
		return m.CreateTime()
	case notificationchannelconfig.FieldUpdateTime:
		return m.UpdateTime()
	case notificationchannelconfig.FieldChannelType:
		return m.ChannelType()
	case notificationchannelconfig.FieldName:
		return m.Name()
	case notificationchannelconfig.FieldDescription:
		return m.Description()
	case notificationchannelconfig.FieldEnabled:
		return m.Enabled()
	case notificationchannelconfig.FieldIsDefault:
		return m.IsDefault()
	case notificationchannelconfig.FieldConfigEncrypted:
		return m.ConfigEncrypted()
	case notificationchannelconfig.FieldEncryptionKeyID:
		return m.EncryptionKeyID()
	case notificationchannelconfig.FieldCreatedBy:
		return m.CreatedBy()
	case notificationchannelconfig.FieldUpdatedBy:
		return m.UpdatedBy()
	case notificationchannelconfig.FieldDeletedAt:
		return m.DeletedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *NotificationChannelConfigMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case notificationchannelconfig.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case notificationchannelconfig.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case notificationchannelconfig.FieldChannelType:
		return m.OldChannelType(ctx)
	case notificationchannelconfig.FieldName:
		return m.OldName(ctx)
	case notificationchannelconfig.FieldDescription:
		return m.OldDescription(ctx)
	case notificationchannelconfig.FieldEnabled:
		return m.OldEnabled(ctx)
	case notificationchannelconfig.FieldIsDefault:
		return m.OldIsDefault(ctx)
	case notificationchannelconfig.FieldConfigEncrypted:
		return m.OldConfigEncrypted(ctx)
	case notificationchannelconfig.FieldEncryptionKeyID:
		return m.OldEncryptionKeyID(ctx)
	case notificationchannelconfig.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case notificationchannelconfig.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case notificationchannelconfig.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	}
	return nil, fmt.Errorf("unknown NotificationChannelConfig field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NotificationChannelConfigMutation) SetField(name string, value ent.Value) error {
	switch name {
	case notificationchannelconfig.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case notificationchannelconfig.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case notificationchannelconfig.FieldChannelType:
		v, ok := value.(notificationchannelconfig.ChannelType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChannelType(v)
		return nil
	case notificationchannelconfig.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case notificationchannelconfig.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case notificationchannelconfig.FieldEnabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnabled(v)
		return nil
	case notificationchannelconfig.FieldIsDefault:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDefault(v)
		return nil
	case notificationchannelconfig.FieldConfigEncrypted:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConfigEncrypted(v)
		return nil
	case notificationchannelconfig.FieldEncryptionKeyID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEncryptionKeyID(v)
		return nil
	case notificationchannelconfig.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case notificationchannelconfig.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case notificationchannelconfig.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown NotificationChannelConfig field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *NotificationChannelConfigMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *NotificationChannelConfigMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NotificationChannelConfigMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown NotificationChannelConfig numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *NotificationChannelConfigMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(notificationchannelconfig.FieldDescription) {
		fields = append(fields, notificationchannelconfig.FieldDescription)
	}
	if m.FieldCleared(notificationchannelconfig.FieldCreatedBy) {
		fields = append(fields, notificationchannelconfig.FieldCreatedBy)
	}
	if m.FieldCleared(notificationchannelconfig.FieldUpdatedBy) {
		fields = append(fields, notificationchannelconfig.FieldUpdatedBy)
	}
	if m.FieldCleared(notificationchannelconfig.FieldDeletedAt) {
		fields = append(fields, notificationchannelconfig.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *NotificationChannelConfigMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *NotificationChannelConfigMutation) ClearField(name string) error {
	switch name {
	case notificationchannelconfig.FieldDescription:
		m.ClearDescription()
		return nil
	case notificationchannelconfig.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case notificationchannelconfig.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case notificationchannelconfig.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown NotificationChannelConfig nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *NotificationChannelConfigMutation) ResetField(name string) error {
	switch name {
	case notificationchannelconfig.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case notificationchannelconfig.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case notificationchannelconfig.FieldChannelType:
		m.ResetChannelType()
		return nil
	case notificationchannelconfig.FieldName:
		m.ResetName()
		return nil
	case notificationchannelconfig.FieldDescription:
		m.ResetDescription()
		return nil
	case notificationchannelconfig.FieldEnabled:
		m.ResetEnabled()
		return nil
	case notificationchannelconfig.FieldIsDefault:
		m.ResetIsDefault()
		return nil
	case notificationchannelconfig.FieldConfigEncrypted:
		m.ResetConfigEncrypted()
		return nil
	case notificationchannelconfig.FieldEncryptionKeyID:
		m.ResetEncryptionKeyID()
		return nil
	case notificationchannelconfig.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case notificationchannelconfig.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case notificationchannelconfig.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown NotificationChannelConfig field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *NotificationChannelConfigMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *NotificationChannelConfigMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *NotificationChannelConfigMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *NotificationChannelConfigMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *NotificationChannelConfigMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *NotificationChannelConfigMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *NotificationChannelConfigMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown NotificationChannelConfig unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *NotificationChannelConfigMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown NotificationChannelConfig edge %s", name)
}

// NotificationLogMutation represents an operation that mutates the NotificationLog nodes in the graph.
type NotificationLogMutation struct {
	config
	op                Op
	typ               string
	id                *string
	channel           *notificationlog.Channel
	status            *notificationlog.Status
	attempt_number    *int
	addattempt_number *int
	response_code     *int
	addresponse_code  *int
	response_body     *string
	error_message     *string
	request_metadata  *map[string]interface{}
	created_at        *time.Time
	completed_at      *time.Time
	clearedFields     map[string]struct{}
	alert             *string
	clearedalert      bool
	webhook           *string
	clearedwebhook    bool
	done              bool
	oldValue          func(context.Context) (*NotificationLog, error)
	predicates        []predicate.NotificationLog
}

var _ ent.Mutation = (*NotificationLogMutation)(nil)

// notificationlogOption allows management of the mutation configuration using functional options.
type notificationlogOption func(*NotificationLogMutation)

// newNotificationLogMutation creates new mutation for the NotificationLog entity.
func newNotificationLogMutation(c config, op Op, opts ...notificationlogOption) *NotificationLogMutation {
	m := &NotificationLogMutation{
		config:        c,
		op:            op,
		typ:           TypeNotificationLog,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withNotificationLogID sets the ID field of the mutation.
func withNotificationLogID(id string) notificationlogOption {
	return func(m *NotificationLogMutation) {
		var (
			err   error
			once  sync.Once
			value *NotificationLog
		)
		m.oldValue = func(ctx context.Context) (*NotificationLog, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().NotificationLog.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withNotificationLog sets the old NotificationLog of the mutation.
func withNotificationLog(node *NotificationLog) notificationlogOption {
	return func(m *NotificationLogMutation) {
		m.oldValue = func(context.Context) (*NotificationLog, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m NotificationLogMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m NotificationLogMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of NotificationLog entities.
func (m *NotificationLogMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *NotificationLogMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *NotificationLogMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().NotificationLog.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetChannel sets the "channel" field.
func (m *NotificationLogMutation) SetChannel(n notificationlog.Channel) {
	m.channel = &n
}

// Channel returns the value of the "channel" field in the mutation.
func (m *NotificationLogMutation) Channel() (r notificationlog.Channel, exists bool) {
	v := m.channel
	if v == nil {
		return
	}
	return *v, true
}

// OldChannel returns the old "channel" field's value of the NotificationLog entity.
// If the NotificationLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationLogMutation) OldChannel(ctx context.Context) (v notificationlog.Channel, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChannel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChannel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChannel: %w", err)
	}
	return oldValue.Channel, nil
}

// ResetChannel resets all changes to the "channel" field.
func (m *NotificationLogMutation) ResetChannel() {
	m.channel = nil
}

// SetAlertID sets the "alert_id" field.
func (m *NotificationLogMutation) SetAlertID(s string) {
	m.alert = &s
}

// AlertID returns the value of the "alert_id" field in the mutation.
func (m *NotificationLogMutation) AlertID() (r string, exists bool) {
	v := m.alert
	if v == nil {
		return
	}
	return *v, true
}

// OldAlertID returns the old "alert_id" field's value of the NotificationLog entity.
// If the NotificationLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationLogMutation) OldAlertID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAlertID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAlertID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAlertID: %w", err)
	}
	return oldValue.AlertID, nil
}

// ResetAlertID resets all changes to the "alert_id" field.
func (m *NotificationLogMutation) ResetAlertID() {
	m.alert = nil
}

// SetWebhookID sets the "webhook_id" field.
func (m *NotificationLogMutation) SetWebhookID(s string) {
	m.webhook = &s
}

// WebhookID returns the value of the "webhook_id" field in the mutation.
func (m *NotificationLogMutation) WebhookID() (r string, exists bool) {
	v := m.webhook
	if v == nil {
		return
	}
	return *v, true
}

// OldWebhookID returns the old "webhook_id" field's value of the NotificationLog entity.
// If the NotificationLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationLogMutation) OldWebhookID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWebhookID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWebhookID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWebhookID: %w", err)
	}
	return oldValue.WebhookID, nil
}

// ClearWebhookID clears the value of the "webhook_id" field.
func (m *NotificationLogMutation) ClearWebhookID() {
	m.webhook = nil
	m.clearedFields[notificationlog.FieldWebhookID] = struct{}{}
}

// WebhookIDCleared returns if the "webhook_id" field was cleared in this mutation.
func (m *NotificationLogMutation) WebhookIDCleared() bool {
	_, ok := m.clearedFields[notificationlog.FieldWebhookID]
	return ok
}

// ResetWebhookID resets all changes to the "webhook_id" field.
func (m *NotificationLogMutation) ResetWebhookID() {
	m.webhook = nil
	delete(m.clearedFields, notificationlog.FieldWebhookID)
}

// SetStatus sets the "status" field.
func (m *NotificationLogMutation) SetStatus(n notificationlog.Status) {
	m.status = &n
}

// Status returns the value of the "status" field in the mutation.
func (m *NotificationLogMutation) Status() (r notificationlog.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the NotificationLog entity.
// If the NotificationLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationLogMutation) OldStatus(ctx context.Context) (v notificationlog.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *NotificationLogMutation) ResetStatus() {
	m.status = nil
}

// SetAttemptNumber sets the "attempt_number" field.
func (m *NotificationLogMutation) SetAttemptNumber(i int) {
	m.attempt_number = &i
	m.addattempt_number = nil
}

// AttemptNumber returns the value of the "attempt_number" field in the mutation.
func (m *NotificationLogMutation) AttemptNumber() (r int, exists bool) {
	v := m.attempt_number
	if v == nil {
		return
	}
	return *v, true
}

// OldAttemptNumber returns the old "attempt_number" field's value of the NotificationLog entity.
// If the NotificationLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationLogMutation) OldAttemptNumber(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAttemptNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAttemptNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAttemptNumber: %w", err)
	}
	return oldValue.AttemptNumber, nil
}

// AddAttemptNumber adds i to the "attempt_number" field.
func (m *NotificationLogMutation) AddAttemptNumber(i int) {
	if m.addattempt_number != nil {
		*m.addattempt_number += i
	} else {
		m.addattempt_number = &i
	}
}

// AddedAttemptNumber returns the value that was added to the "attempt_number" field in this mutation.
func (m *NotificationLogMutation) AddedAttemptNumber() (r int, exists bool) {
	v := m.addattempt_number
	if v == nil {
		return
	}
	return *v, true
}

// ResetAttemptNumber resets all changes to the "attempt_number" field.
func (m *NotificationLogMutation) ResetAttemptNumber() {
	m.attempt_number = nil
	m.addattempt_number = nil
}

// SetResponseCode sets the "response_code" field.
func (m *NotificationLogMutation) SetResponseCode(i int) {
	m.response_code = &i
	m.addresponse_code = nil
}

// ResponseCode returns the value of the "response_code" field in the mutation.
func (m *NotificationLogMutation) ResponseCode() (r int, exists bool) {
	v := m.response_code
	if v == nil {
		return
	}
	return *v, true
}

// OldResponseCode returns the old "response_code" field's value of the NotificationLog entity.
// If the NotificationLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationLogMutation) OldResponseCode(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResponseCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResponseCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResponseCode: %w", err)
	}
	return oldValue.ResponseCode, nil
}

// AddResponseCode adds i to the "response_code" field.
func (m *NotificationLogMutation) AddResponseCode(i int) {
	if m.addresponse_code != nil {
		*m.addresponse_code += i
	} else {
		m.addresponse_code = &i
	}
}

// AddedResponseCode returns the value that was added to the "response_code" field in this mutation.
func (m *NotificationLogMutation) AddedResponseCode() (r int, exists bool) {
	v := m.addresponse_code
	if v == nil {
		return
	}
	return *v, true
}

// ClearResponseCode clears the value of the "response_code" field.
func (m *NotificationLogMutation) ClearResponseCode() {
	m.response_code = nil
	m.addresponse_code = nil
	m.clearedFields[notificationlog.FieldResponseCode] = struct{}{}
}

// ResponseCodeCleared returns if the "response_code" field was cleared in this mutation.
func (m *NotificationLogMutation) ResponseCodeCleared() bool {
	_, ok := m.clearedFields[notificationlog.FieldResponseCode]
	return ok
}

// ResetResponseCode resets all changes to the "response_code" field.
func (m *NotificationLogMutation) ResetResponseCode() {
	m.response_code = nil
	m.addresponse_code = nil
	delete(m.clearedFields, notificationlog.FieldResponseCode)
}

// SetResponseBody sets the "response_body" field.
func (m *NotificationLogMutation) SetResponseBody(s string) {
	m.response_body = &s
}

// ResponseBody returns the value of the "response_body" field in the mutation.
func (m *NotificationLogMutation) ResponseBody() (r string, exists bool) {
	v := m.response_body
	if v == nil {
		return
	}
	return *v, true
}

// OldResponseBody returns the old "response_body" field's value of the NotificationLog entity.
// If the NotificationLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationLogMutation) OldResponseBody(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResponseBody is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResponseBody requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResponseBody: %w", err)
	}
	return oldValue.ResponseBody, nil
}

// ClearResponseBody clears the value of the "response_body" field.
func (m *NotificationLogMutation) ClearResponseBody() {
	m.response_body = nil
	m.clearedFields[notificationlog.FieldResponseBody] = struct{}{}
}

// ResponseBodyCleared returns if the "response_body" field was cleared in this mutation.
func (m *NotificationLogMutation) ResponseBodyCleared() bool {
	_, ok := m.clearedFields[notificationlog.FieldResponseBody]
	return ok
}

// ResetResponseBody resets all changes to the "response_body" field.
func (m *NotificationLogMutation) ResetResponseBody() {
	m.response_body = nil
	delete(m.clearedFields, notificationlog.FieldResponseBody)
}

// SetErrorMessage sets the "error_message" field.
func (m *NotificationLogMutation) SetErrorMessage(s string) {
	m.error_message = &s
}

// ErrorMessage returns the value of the "error_message" field in the mutation.
func (m *NotificationLogMutation) ErrorMessage() (r string, exists bool) {
	v := m.error_message
	if v == nil {
		return
	}
	return *v, true
}

// OldErrorMessage returns the old "error_message" field's value of the NotificationLog entity.
// If the NotificationLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationLogMutation) OldErrorMessage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldErrorMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldErrorMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldErrorMessage: %w", err)
	}
	return oldValue.ErrorMessage, nil
}

// ClearErrorMessage clears the value of the "error_message" field.
func (m *NotificationLogMutation) ClearErrorMessage() {
	m.error_message = nil
	m.clearedFields[notificationlog.FieldErrorMessage] = struct{}{}
}

// ErrorMessageCleared returns if the "error_message" field was cleared in this mutation.
func (m *NotificationLogMutation) ErrorMessageCleared() bool {
	_, ok := m.clearedFields[notificationlog.FieldErrorMessage]
	return ok
}

// ResetErrorMessage resets all changes to the "error_message" field.
func (m *NotificationLogMutation) ResetErrorMessage() {
	m.error_message = nil
	delete(m.clearedFields, notificationlog.FieldErrorMessage)
}

// SetRequestMetadata sets the "request_metadata" field.
func (m *NotificationLogMutation) SetRequestMetadata(value map[string]interface{}) {
	m.request_metadata = &value
}

// RequestMetadata returns the value of the "request_metadata" field in the mutation.
func (m *NotificationLogMutation) RequestMetadata() (r map[string]interface{}, exists bool) {
	v := m.request_metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldRequestMetadata returns the old "request_metadata" field's value of the NotificationLog entity.
// If the NotificationLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationLogMutation) OldRequestMetadata(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRequestMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRequestMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRequestMetadata: %w", err)
	}
	return oldValue.RequestMetadata, nil
}

// ClearRequestMetadata clears the value of the "request_metadata" field.
func (m *NotificationLogMutation) ClearRequestMetadata() {
	m.request_metadata = nil
	m.clearedFields[notificationlog.FieldRequestMetadata] = struct{}{}
}

// RequestMetadataCleared returns if the "request_metadata" field was cleared in this mutation.
func (m *NotificationLogMutation) RequestMetadataCleared() bool {
	_, ok := m.clearedFields[notificationlog.FieldRequestMetadata]
	return ok
}

// ResetRequestMetadata resets all changes to the "request_metadata" field.
func (m *NotificationLogMutation) ResetRequestMetadata() {
	m.request_metadata = nil
	delete(m.clearedFields, notificationlog.FieldRequestMetadata)
}

// SetCreatedAt sets the "created_at" field.
func (m *NotificationLogMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *NotificationLogMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the NotificationLog entity.
// If the NotificationLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationLogMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *NotificationLogMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetCompletedAt sets the "completed_at" field.
func (m *NotificationLogMutation) SetCompletedAt(t time.Time) {
	m.completed_at = &t
}

// CompletedAt returns the value of the "completed_at" field in the mutation.
func (m *NotificationLogMutation) CompletedAt() (r time.Time, exists bool) {
	v := m.completed_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCompletedAt returns the old "completed_at" field's value of the NotificationLog entity.
// If the NotificationLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationLogMutation) OldCompletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompletedAt: %w", err)
	}
	return oldValue.CompletedAt, nil
}

// ClearCompletedAt clears the value of the "completed_at" field.
func (m *NotificationLogMutation) ClearCompletedAt() {
	m.completed_at = nil
	m.clearedFields[notificationlog.FieldCompletedAt] = struct{}{}
}

// CompletedAtCleared returns if the "completed_at" field was cleared in this mutation.
func (m *NotificationLogMutation) CompletedAtCleared() bool {
	_, ok := m.clearedFields[notificationlog.FieldCompletedAt]
	return ok
}

// ResetCompletedAt resets all changes to the "completed_at" field.
func (m *NotificationLogMutation) ResetCompletedAt() {
	m.completed_at = nil
	delete(m.clearedFields, notificationlog.FieldCompletedAt)
}

// ClearAlert clears the "alert" edge to the Alert entity.
func (m *NotificationLogMutation) ClearAlert() {
	m.clearedalert = true
	m.clearedFields[notificationlog.FieldAlertID] = struct{}{}
}

// AlertCleared reports if the "alert" edge to the Alert entity was cleared.
func (m *NotificationLogMutation) AlertCleared() bool {
	return m.clearedalert
}

// AlertIDs returns the "alert" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AlertID instead. It exists only for internal usage by the builders.
func (m *NotificationLogMutation) AlertIDs() (ids []string) {
	if id := m.alert; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAlert resets all changes to the "alert" edge.
func (m *NotificationLogMutation) ResetAlert() {
	m.alert = nil
	m.clearedalert = false
}

// ClearWebhook clears the "webhook" edge to the Webhook entity.
func (m *NotificationLogMutation) ClearWebhook() {
	m.clearedwebhook = true
	m.clearedFields[notificationlog.FieldWebhookID] = struct{}{}
}

// WebhookCleared reports if the "webhook" edge to the Webhook entity was cleared.
func (m *NotificationLogMutation) WebhookCleared() bool {
	return m.WebhookIDCleared() || m.clearedwebhook
}

// WebhookIDs returns the "webhook" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// WebhookID instead. It exists only for internal usage by the builders.
func (m *NotificationLogMutation) WebhookIDs() (ids []string) {
	if id := m.webhook; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetWebhook resets all changes to the "webhook" edge.
func (m *NotificationLogMutation) ResetWebhook() {
	m.webhook = nil
	m.clearedwebhook = false
}

// Where appends a list predicates to the NotificationLogMutation builder.
func (m *NotificationLogMutation) Where(ps ...predicate.NotificationLog) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the NotificationLogMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *NotificationLogMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.NotificationLog, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *NotificationLogMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *NotificationLogMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (NotificationLog).
func (m *NotificationLogMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *NotificationLogMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.channel != nil {
		fields = append(fields, notificationlog.FieldChannel)
	}
	if m.alert != nil {
		fields = append(fields, notificationlog.FieldAlertID)
	}
	if m.webhook != nil {
		fields = append(fields, notificationlog.FieldWebhookID)
	}
	if m.status != nil {
		fields = append(fields, notificationlog.FieldStatus)
	}
	if m.attempt_number != nil {
		fields = append(fields, notificationlog.FieldAttemptNumber)
	}
	if m.response_code != nil {
		fields = append(fields, notificationlog.FieldResponseCode)
	}
	if m.response_body != nil {
		fields = append(fields, notificationlog.FieldResponseBody)
	}
	if m.error_message != nil {
		fields = append(fields, notificationlog.FieldErrorMessage)
	}
	if m.request_metadata != nil {
		fields = append(fields, notificationlog.FieldRequestMetadata)
	}
	if m.created_at != nil {
		fields = append(fields, notificationlog.FieldCreatedAt)
	}
	if m.completed_at != nil {
		fields = append(fields, notificationlog.FieldCompletedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *NotificationLogMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case notificationlog.FieldChannel:
		return m.Channel()
	case notificationlog.FieldAlertID:
		return m.AlertID()
	case notificationlog.FieldWebhookID:
		return m.WebhookID()
	case notificationlog.FieldStatus:
		return m.Status()
	case notificationlog.FieldAttemptNumber:
		return m.AttemptNumber()
	case notificationlog.FieldResponseCode:
		return m.ResponseCode()
	case notificationlog.FieldResponseBody:
		return m.ResponseBody()
	case notificationlog.FieldErrorMessage:
		return m.ErrorMessage()
	case notificationlog.FieldRequestMetadata:
		return m.RequestMetadata()
	case notificationlog.FieldCreatedAt:
		return m.CreatedAt()
	case notificationlog.FieldCompletedAt:
		return m.CompletedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *NotificationLogMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case notificationlog.FieldChannel:
		return m.OldChannel(ctx)
	case notificationlog.FieldAlertID:
		return m.OldAlertID(ctx)
	case notificationlog.FieldWebhookID:
		return m.OldWebhookID(ctx)
	case notificationlog.FieldStatus:
		return m.OldStatus(ctx)
	case notificationlog.FieldAttemptNumber:
		return m.OldAttemptNumber(ctx)
	case notificationlog.FieldResponseCode:
		return m.OldResponseCode(ctx)
	case notificationlog.FieldResponseBody:
		return m.OldResponseBody(ctx)
	case notificationlog.FieldErrorMessage:
		return m.OldErrorMessage(ctx)
	case notificationlog.FieldRequestMetadata:
		return m.OldRequestMetadata(ctx)
	case notificationlog.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case notificationlog.FieldCompletedAt:
		return m.OldCompletedAt(ctx)
	}
	return nil, fmt.Errorf("unknown NotificationLog field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NotificationLogMutation) SetField(name string, value ent.Value) error {
	switch name {
	case notificationlog.FieldChannel:
		v, ok := value.(notificationlog.Channel)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChannel(v)
		return nil
	case notificationlog.FieldAlertID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAlertID(v)
		return nil
	case notificationlog.FieldWebhookID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWebhookID(v)
		return nil
	case notificationlog.FieldStatus:
		v, ok := value.(notificationlog.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case notificationlog.FieldAttemptNumber:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAttemptNumber(v)
		return nil
	case notificationlog.FieldResponseCode:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResponseCode(v)
		return nil
	case notificationlog.FieldResponseBody:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResponseBody(v)
		return nil
	case notificationlog.FieldErrorMessage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetErrorMessage(v)
		return nil
	case notificationlog.FieldRequestMetadata:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRequestMetadata(v)
		return nil
	case notificationlog.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case notificationlog.FieldCompletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown NotificationLog field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *NotificationLogMutation) AddedFields() []string {
	var fields []string
	if m.addattempt_number != nil {
		fields = append(fields, notificationlog.FieldAttemptNumber)
	}
	if m.addresponse_code != nil {
		fields = append(fields, notificationlog.FieldResponseCode)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *NotificationLogMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case notificationlog.FieldAttemptNumber:
		return m.AddedAttemptNumber()
	case notificationlog.FieldResponseCode:
		return m.AddedResponseCode()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NotificationLogMutation) AddField(name string, value ent.Value) error {
	switch name {
	case notificationlog.FieldAttemptNumber:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAttemptNumber(v)
		return nil
	case notificationlog.FieldResponseCode:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddResponseCode(v)
		return nil
	}
	return fmt.Errorf("unknown NotificationLog numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *NotificationLogMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(notificationlog.FieldWebhookID) {
		fields = append(fields, notificationlog.FieldWebhookID)
	}
	if m.FieldCleared(notificationlog.FieldResponseCode) {
		fields = append(fields, notificationlog.FieldResponseCode)
	}
	if m.FieldCleared(notificationlog.FieldResponseBody) {
		fields = append(fields, notificationlog.FieldResponseBody)
	}
	if m.FieldCleared(notificationlog.FieldErrorMessage) {
		fields = append(fields, notificationlog.FieldErrorMessage)
	}
	if m.FieldCleared(notificationlog.FieldRequestMetadata) {
		fields = append(fields, notificationlog.FieldRequestMetadata)
	}
	if m.FieldCleared(notificationlog.FieldCompletedAt) {
		fields = append(fields, notificationlog.FieldCompletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *NotificationLogMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *NotificationLogMutation) ClearField(name string) error {
	switch name {
	case notificationlog.FieldWebhookID:
		m.ClearWebhookID()
		return nil
	case notificationlog.FieldResponseCode:
		m.ClearResponseCode()
		return nil
	case notificationlog.FieldResponseBody:
		m.ClearResponseBody()
		return nil
	case notificationlog.FieldErrorMessage:
		m.ClearErrorMessage()
		return nil
	case notificationlog.FieldRequestMetadata:
		m.ClearRequestMetadata()
		return nil
	case notificationlog.FieldCompletedAt:
		m.ClearCompletedAt()
		return nil
	}
	return fmt.Errorf("unknown NotificationLog nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *NotificationLogMutation) ResetField(name string) error {
	switch name {
	case notificationlog.FieldChannel:
		m.ResetChannel()
		return nil
	case notificationlog.FieldAlertID:
		m.ResetAlertID()
		return nil
	case notificationlog.FieldWebhookID:
		m.ResetWebhookID()
		return nil
	case notificationlog.FieldStatus:
		m.ResetStatus()
		return nil
	case notificationlog.FieldAttemptNumber:
		m.ResetAttemptNumber()
		return nil
	case notificationlog.FieldResponseCode:
		m.ResetResponseCode()
		return nil
	case notificationlog.FieldResponseBody:
		m.ResetResponseBody()
		return nil
	case notificationlog.FieldErrorMessage:
		m.ResetErrorMessage()
		return nil
	case notificationlog.FieldRequestMetadata:
		m.ResetRequestMetadata()
		return nil
	case notificationlog.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case notificationlog.FieldCompletedAt:
		m.ResetCompletedAt()
		return nil
	}
	return fmt.Errorf("unknown NotificationLog field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *NotificationLogMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.alert != nil {
		edges = append(edges, notificationlog.EdgeAlert)
	}
	if m.webhook != nil {
		edges = append(edges, notificationlog.EdgeWebhook)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *NotificationLogMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case notificationlog.EdgeAlert:
		if id := m.alert; id != nil {
			return []ent.Value{*id}
		}
	case notificationlog.EdgeWebhook:
		if id := m.webhook; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *NotificationLogMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *NotificationLogMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *NotificationLogMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedalert {
		edges = append(edges, notificationlog.EdgeAlert)
	}
	if m.clearedwebhook {
		edges = append(edges, notificationlog.EdgeWebhook)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *NotificationLogMutation) EdgeCleared(name string) bool {
	switch name {
	case notificationlog.EdgeAlert:
		return m.clearedalert
	case notificationlog.EdgeWebhook:
		return m.clearedwebhook
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *NotificationLogMutation) ClearEdge(name string) error {
	switch name {
	case notificationlog.EdgeAlert:
		m.ClearAlert()
		return nil
	case notificationlog.EdgeWebhook:
		m.ClearWebhook()
		return nil
	}
	return fmt.Errorf("unknown NotificationLog unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *NotificationLogMutation) ResetEdge(name string) error {
	switch name {
	case notificationlog.EdgeAlert:
		m.ResetAlert()
		return nil
	case notificationlog.EdgeWebhook:
		m.ResetWebhook()
		return nil
	}
	return fmt.Errorf("unknown NotificationLog edge %s", name)
}

// NotificationSettingsMutation represents an operation that mutates the NotificationSettings nodes in the graph.
type NotificationSettingsMutation struct {
	config
	op                    Op
	typ                   string
	id                    *string
	channel               *notificationsettings.Channel
	credentials_encrypted *[]byte
	nonce                 *[]byte
	enabled               *bool
	test_status           *notificationsettings.TestStatus
	test_message          *string
	tested_at             *time.Time
	created_at            *time.Time
	updated_at            *time.Time
	clearedFields         map[string]struct{}
	done                  bool
	oldValue              func(context.Context) (*NotificationSettings, error)
	predicates            []predicate.NotificationSettings
}

var _ ent.Mutation = (*NotificationSettingsMutation)(nil)

// notificationsettingsOption allows management of the mutation configuration using functional options.
type notificationsettingsOption func(*NotificationSettingsMutation)

// newNotificationSettingsMutation creates new mutation for the NotificationSettings entity.
func newNotificationSettingsMutation(c config, op Op, opts ...notificationsettingsOption) *NotificationSettingsMutation {
	m := &NotificationSettingsMutation{
		config:        c,
		op:            op,
		typ:           TypeNotificationSettings,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withNotificationSettingsID sets the ID field of the mutation.
func withNotificationSettingsID(id string) notificationsettingsOption {
	return func(m *NotificationSettingsMutation) {
		var (
			err   error
			once  sync.Once
			value *NotificationSettings
		)
		m.oldValue = func(ctx context.Context) (*NotificationSettings, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().NotificationSettings.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withNotificationSettings sets the old NotificationSettings of the mutation.
func withNotificationSettings(node *NotificationSettings) notificationsettingsOption {
	return func(m *NotificationSettingsMutation) {
		m.oldValue = func(context.Context) (*NotificationSettings, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m NotificationSettingsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m NotificationSettingsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of NotificationSettings entities.
func (m *NotificationSettingsMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *NotificationSettingsMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *NotificationSettingsMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().NotificationSettings.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetChannel sets the "channel" field.
func (m *NotificationSettingsMutation) SetChannel(n notificationsettings.Channel) {
	m.channel = &n
}

// Channel returns the value of the "channel" field in the mutation.
func (m *NotificationSettingsMutation) Channel() (r notificationsettings.Channel, exists bool) {
	v := m.channel
	if v == nil {
		return
	}
	return *v, true
}

// OldChannel returns the old "channel" field's value of the NotificationSettings entity.
// If the NotificationSettings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationSettingsMutation) OldChannel(ctx context.Context) (v notificationsettings.Channel, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChannel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChannel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChannel: %w", err)
	}
	return oldValue.Channel, nil
}

// ResetChannel resets all changes to the "channel" field.
func (m *NotificationSettingsMutation) ResetChannel() {
	m.channel = nil
}

// SetCredentialsEncrypted sets the "credentials_encrypted" field.
func (m *NotificationSettingsMutation) SetCredentialsEncrypted(b []byte) {
	m.credentials_encrypted = &b
}

// CredentialsEncrypted returns the value of the "credentials_encrypted" field in the mutation.
func (m *NotificationSettingsMutation) CredentialsEncrypted() (r []byte, exists bool) {
	v := m.credentials_encrypted
	if v == nil {
		return
	}
	return *v, true
}

// OldCredentialsEncrypted returns the old "credentials_encrypted" field's value of the NotificationSettings entity.
// If the NotificationSettings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationSettingsMutation) OldCredentialsEncrypted(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCredentialsEncrypted is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCredentialsEncrypted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCredentialsEncrypted: %w", err)
	}
	return oldValue.CredentialsEncrypted, nil
}

// ResetCredentialsEncrypted resets all changes to the "credentials_encrypted" field.
func (m *NotificationSettingsMutation) ResetCredentialsEncrypted() {
	m.credentials_encrypted = nil
}

// SetNonce sets the "nonce" field.
func (m *NotificationSettingsMutation) SetNonce(b []byte) {
	m.nonce = &b
}

// Nonce returns the value of the "nonce" field in the mutation.
func (m *NotificationSettingsMutation) Nonce() (r []byte, exists bool) {
	v := m.nonce
	if v == nil {
		return
	}
	return *v, true
}

// OldNonce returns the old "nonce" field's value of the NotificationSettings entity.
// If the NotificationSettings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationSettingsMutation) OldNonce(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNonce is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNonce requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNonce: %w", err)
	}
	return oldValue.Nonce, nil
}

// ResetNonce resets all changes to the "nonce" field.
func (m *NotificationSettingsMutation) ResetNonce() {
	m.nonce = nil
}

// SetEnabled sets the "enabled" field.
func (m *NotificationSettingsMutation) SetEnabled(b bool) {
	m.enabled = &b
}

// Enabled returns the value of the "enabled" field in the mutation.
func (m *NotificationSettingsMutation) Enabled() (r bool, exists bool) {
	v := m.enabled
	if v == nil {
		return
	}
	return *v, true
}

// OldEnabled returns the old "enabled" field's value of the NotificationSettings entity.
// If the NotificationSettings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationSettingsMutation) OldEnabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnabled: %w", err)
	}
	return oldValue.Enabled, nil
}

// ResetEnabled resets all changes to the "enabled" field.
func (m *NotificationSettingsMutation) ResetEnabled() {
	m.enabled = nil
}

// SetTestStatus sets the "test_status" field.
func (m *NotificationSettingsMutation) SetTestStatus(ns notificationsettings.TestStatus) {
	m.test_status = &ns
}

// TestStatus returns the value of the "test_status" field in the mutation.
func (m *NotificationSettingsMutation) TestStatus() (r notificationsettings.TestStatus, exists bool) {
	v := m.test_status
	if v == nil {
		return
	}
	return *v, true
}

// OldTestStatus returns the old "test_status" field's value of the NotificationSettings entity.
// If the NotificationSettings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationSettingsMutation) OldTestStatus(ctx context.Context) (v notificationsettings.TestStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTestStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTestStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTestStatus: %w", err)
	}
	return oldValue.TestStatus, nil
}

// ResetTestStatus resets all changes to the "test_status" field.
func (m *NotificationSettingsMutation) ResetTestStatus() {
	m.test_status = nil
}

// SetTestMessage sets the "test_message" field.
func (m *NotificationSettingsMutation) SetTestMessage(s string) {
	m.test_message = &s
}

// TestMessage returns the value of the "test_message" field in the mutation.
func (m *NotificationSettingsMutation) TestMessage() (r string, exists bool) {
	v := m.test_message
	if v == nil {
		return
	}
	return *v, true
}

// OldTestMessage returns the old "test_message" field's value of the NotificationSettings entity.
// If the NotificationSettings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationSettingsMutation) OldTestMessage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTestMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTestMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTestMessage: %w", err)
	}
	return oldValue.TestMessage, nil
}

// ClearTestMessage clears the value of the "test_message" field.
func (m *NotificationSettingsMutation) ClearTestMessage() {
	m.test_message = nil
	m.clearedFields[notificationsettings.FieldTestMessage] = struct{}{}
}

// TestMessageCleared returns if the "test_message" field was cleared in this mutation.
func (m *NotificationSettingsMutation) TestMessageCleared() bool {
	_, ok := m.clearedFields[notificationsettings.FieldTestMessage]
	return ok
}

// ResetTestMessage resets all changes to the "test_message" field.
func (m *NotificationSettingsMutation) ResetTestMessage() {
	m.test_message = nil
	delete(m.clearedFields, notificationsettings.FieldTestMessage)
}

// SetTestedAt sets the "tested_at" field.
func (m *NotificationSettingsMutation) SetTestedAt(t time.Time) {
	m.tested_at = &t
}

// TestedAt returns the value of the "tested_at" field in the mutation.
func (m *NotificationSettingsMutation) TestedAt() (r time.Time, exists bool) {
	v := m.tested_at
	if v == nil {
		return
	}
	return *v, true
}

// OldTestedAt returns the old "tested_at" field's value of the NotificationSettings entity.
// If the NotificationSettings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationSettingsMutation) OldTestedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTestedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTestedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTestedAt: %w", err)
	}
	return oldValue.TestedAt, nil
}

// ClearTestedAt clears the value of the "tested_at" field.
func (m *NotificationSettingsMutation) ClearTestedAt() {
	m.tested_at = nil
	m.clearedFields[notificationsettings.FieldTestedAt] = struct{}{}
}

// TestedAtCleared returns if the "tested_at" field was cleared in this mutation.
func (m *NotificationSettingsMutation) TestedAtCleared() bool {
	_, ok := m.clearedFields[notificationsettings.FieldTestedAt]
	return ok
}

// ResetTestedAt resets all changes to the "tested_at" field.
func (m *NotificationSettingsMutation) ResetTestedAt() {
	m.tested_at = nil
	delete(m.clearedFields, notificationsettings.FieldTestedAt)
}

// SetCreatedAt sets the "created_at" field.
func (m *NotificationSettingsMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *NotificationSettingsMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the NotificationSettings entity.
// If the NotificationSettings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationSettingsMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *NotificationSettingsMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *NotificationSettingsMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *NotificationSettingsMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the NotificationSettings entity.
// If the NotificationSettings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationSettingsMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *NotificationSettingsMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// Where appends a list predicates to the NotificationSettingsMutation builder.
func (m *NotificationSettingsMutation) Where(ps ...predicate.NotificationSettings) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the NotificationSettingsMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *NotificationSettingsMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.NotificationSettings, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *NotificationSettingsMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *NotificationSettingsMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (NotificationSettings).
func (m *NotificationSettingsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *NotificationSettingsMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.channel != nil {
		fields = append(fields, notificationsettings.FieldChannel)
	}
	if m.credentials_encrypted != nil {
		fields = append(fields, notificationsettings.FieldCredentialsEncrypted)
	}
	if m.nonce != nil {
		fields = append(fields, notificationsettings.FieldNonce)
	}
	if m.enabled != nil {
		fields = append(fields, notificationsettings.FieldEnabled)
	}
	if m.test_status != nil {
		fields = append(fields, notificationsettings.FieldTestStatus)
	}
	if m.test_message != nil {
		fields = append(fields, notificationsettings.FieldTestMessage)
	}
	if m.tested_at != nil {
		fields = append(fields, notificationsettings.FieldTestedAt)
	}
	if m.created_at != nil {
		fields = append(fields, notificationsettings.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, notificationsettings.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *NotificationSettingsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case notificationsettings.FieldChannel:
		return m.Channel()
	case notificationsettings.FieldCredentialsEncrypted:
		return m.CredentialsEncrypted()
	case notificationsettings.FieldNonce:
		return m.Nonce()
	case notificationsettings.FieldEnabled:
		return m.Enabled()
	case notificationsettings.FieldTestStatus:
		return m.TestStatus()
	case notificationsettings.FieldTestMessage:
		return m.TestMessage()
	case notificationsettings.FieldTestedAt:
		return m.TestedAt()
	case notificationsettings.FieldCreatedAt:
		return m.CreatedAt()
	case notificationsettings.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *NotificationSettingsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case notificationsettings.FieldChannel:
		return m.OldChannel(ctx)
	case notificationsettings.FieldCredentialsEncrypted:
		return m.OldCredentialsEncrypted(ctx)
	case notificationsettings.FieldNonce:
		return m.OldNonce(ctx)
	case notificationsettings.FieldEnabled:
		return m.OldEnabled(ctx)
	case notificationsettings.FieldTestStatus:
		return m.OldTestStatus(ctx)
	case notificationsettings.FieldTestMessage:
		return m.OldTestMessage(ctx)
	case notificationsettings.FieldTestedAt:
		return m.OldTestedAt(ctx)
	case notificationsettings.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case notificationsettings.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown NotificationSettings field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NotificationSettingsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case notificationsettings.FieldChannel:
		v, ok := value.(notificationsettings.Channel)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChannel(v)
		return nil
	case notificationsettings.FieldCredentialsEncrypted:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCredentialsEncrypted(v)
		return nil
	case notificationsettings.FieldNonce:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNonce(v)
		return nil
	case notificationsettings.FieldEnabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnabled(v)
		return nil
	case notificationsettings.FieldTestStatus:
		v, ok := value.(notificationsettings.TestStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTestStatus(v)
		return nil
	case notificationsettings.FieldTestMessage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTestMessage(v)
		return nil
	case notificationsettings.FieldTestedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTestedAt(v)
		return nil
	case notificationsettings.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case notificationsettings.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown NotificationSettings field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *NotificationSettingsMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *NotificationSettingsMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NotificationSettingsMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown NotificationSettings numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *NotificationSettingsMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(notificationsettings.FieldTestMessage) {
		fields = append(fields, notificationsettings.FieldTestMessage)
	}
	if m.FieldCleared(notificationsettings.FieldTestedAt) {
		fields = append(fields, notificationsettings.FieldTestedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *NotificationSettingsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *NotificationSettingsMutation) ClearField(name string) error {
	switch name {
	case notificationsettings.FieldTestMessage:
		m.ClearTestMessage()
		return nil
	case notificationsettings.FieldTestedAt:
		m.ClearTestedAt()
		return nil
	}
	return fmt.Errorf("unknown NotificationSettings nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *NotificationSettingsMutation) ResetField(name string) error {
	switch name {
	case notificationsettings.FieldChannel:
		m.ResetChannel()
		return nil
	case notificationsettings.FieldCredentialsEncrypted:
		m.ResetCredentialsEncrypted()
		return nil
	case notificationsettings.FieldNonce:
		m.ResetNonce()
		return nil
	case notificationsettings.FieldEnabled:
		m.ResetEnabled()
		return nil
	case notificationsettings.FieldTestStatus:
		m.ResetTestStatus()
		return nil
	case notificationsettings.FieldTestMessage:
		m.ResetTestMessage()
		return nil
	case notificationsettings.FieldTestedAt:
		m.ResetTestedAt()
		return nil
	case notificationsettings.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case notificationsettings.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown NotificationSettings field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *NotificationSettingsMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *NotificationSettingsMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *NotificationSettingsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *NotificationSettingsMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *NotificationSettingsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *NotificationSettingsMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *NotificationSettingsMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown NotificationSettings unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *NotificationSettingsMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown NotificationSettings edge %s", name)
}

// PortAllocationMutation represents an operation that mutates the PortAllocation nodes in the graph.
type PortAllocationMutation struct {
	config
	op                      Op
	typ                     string
	id                      *string
	port                    *int
	addport                 *int
	protocol                *portallocation.Protocol
	service_type            *string
	notes                   *string
	allocated_at            *time.Time
	clearedFields           map[string]struct{}
	router                  *string
	clearedrouter           bool
	service_instance        *string
	clearedservice_instance bool
	done                    bool
	oldValue                func(context.Context) (*PortAllocation, error)
	predicates              []predicate.PortAllocation
}

var _ ent.Mutation = (*PortAllocationMutation)(nil)

// portallocationOption allows management of the mutation configuration using functional options.
type portallocationOption func(*PortAllocationMutation)

// newPortAllocationMutation creates new mutation for the PortAllocation entity.
func newPortAllocationMutation(c config, op Op, opts ...portallocationOption) *PortAllocationMutation {
	m := &PortAllocationMutation{
		config:        c,
		op:            op,
		typ:           TypePortAllocation,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPortAllocationID sets the ID field of the mutation.
func withPortAllocationID(id string) portallocationOption {
	return func(m *PortAllocationMutation) {
		var (
			err   error
			once  sync.Once
			value *PortAllocation
		)
		m.oldValue = func(ctx context.Context) (*PortAllocation, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PortAllocation.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPortAllocation sets the old PortAllocation of the mutation.
func withPortAllocation(node *PortAllocation) portallocationOption {
	return func(m *PortAllocationMutation) {
		m.oldValue = func(context.Context) (*PortAllocation, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PortAllocationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PortAllocationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of PortAllocation entities.
func (m *PortAllocationMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PortAllocationMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PortAllocationMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PortAllocation.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetRouterID sets the "router_id" field.
func (m *PortAllocationMutation) SetRouterID(s string) {
	m.router = &s
}

// RouterID returns the value of the "router_id" field in the mutation.
func (m *PortAllocationMutation) RouterID() (r string, exists bool) {
	v := m.router
	if v == nil {
		return
	}
	return *v, true
}

// OldRouterID returns the old "router_id" field's value of the PortAllocation entity.
// If the PortAllocation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PortAllocationMutation) OldRouterID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRouterID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRouterID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRouterID: %w", err)
	}
	return oldValue.RouterID, nil
}

// ResetRouterID resets all changes to the "router_id" field.
func (m *PortAllocationMutation) ResetRouterID() {
	m.router = nil
}

// SetPort sets the "port" field.
func (m *PortAllocationMutation) SetPort(i int) {
	m.port = &i
	m.addport = nil
}

// Port returns the value of the "port" field in the mutation.
func (m *PortAllocationMutation) Port() (r int, exists bool) {
	v := m.port
	if v == nil {
		return
	}
	return *v, true
}

// OldPort returns the old "port" field's value of the PortAllocation entity.
// If the PortAllocation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PortAllocationMutation) OldPort(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPort is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPort requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPort: %w", err)
	}
	return oldValue.Port, nil
}

// AddPort adds i to the "port" field.
func (m *PortAllocationMutation) AddPort(i int) {
	if m.addport != nil {
		*m.addport += i
	} else {
		m.addport = &i
	}
}

// AddedPort returns the value that was added to the "port" field in this mutation.
func (m *PortAllocationMutation) AddedPort() (r int, exists bool) {
	v := m.addport
	if v == nil {
		return
	}
	return *v, true
}

// ResetPort resets all changes to the "port" field.
func (m *PortAllocationMutation) ResetPort() {
	m.port = nil
	m.addport = nil
}

// SetProtocol sets the "protocol" field.
func (m *PortAllocationMutation) SetProtocol(po portallocation.Protocol) {
	m.protocol = &po
}

// Protocol returns the value of the "protocol" field in the mutation.
func (m *PortAllocationMutation) Protocol() (r portallocation.Protocol, exists bool) {
	v := m.protocol
	if v == nil {
		return
	}
	return *v, true
}

// OldProtocol returns the old "protocol" field's value of the PortAllocation entity.
// If the PortAllocation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PortAllocationMutation) OldProtocol(ctx context.Context) (v portallocation.Protocol, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProtocol is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProtocol requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProtocol: %w", err)
	}
	return oldValue.Protocol, nil
}

// ResetProtocol resets all changes to the "protocol" field.
func (m *PortAllocationMutation) ResetProtocol() {
	m.protocol = nil
}

// SetInstanceID sets the "instance_id" field.
func (m *PortAllocationMutation) SetInstanceID(s string) {
	m.service_instance = &s
}

// InstanceID returns the value of the "instance_id" field in the mutation.
func (m *PortAllocationMutation) InstanceID() (r string, exists bool) {
	v := m.service_instance
	if v == nil {
		return
	}
	return *v, true
}

// OldInstanceID returns the old "instance_id" field's value of the PortAllocation entity.
// If the PortAllocation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PortAllocationMutation) OldInstanceID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInstanceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInstanceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInstanceID: %w", err)
	}
	return oldValue.InstanceID, nil
}

// ResetInstanceID resets all changes to the "instance_id" field.
func (m *PortAllocationMutation) ResetInstanceID() {
	m.service_instance = nil
}

// SetServiceType sets the "service_type" field.
func (m *PortAllocationMutation) SetServiceType(s string) {
	m.service_type = &s
}

// ServiceType returns the value of the "service_type" field in the mutation.
func (m *PortAllocationMutation) ServiceType() (r string, exists bool) {
	v := m.service_type
	if v == nil {
		return
	}
	return *v, true
}

// OldServiceType returns the old "service_type" field's value of the PortAllocation entity.
// If the PortAllocation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PortAllocationMutation) OldServiceType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldServiceType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldServiceType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldServiceType: %w", err)
	}
	return oldValue.ServiceType, nil
}

// ResetServiceType resets all changes to the "service_type" field.
func (m *PortAllocationMutation) ResetServiceType() {
	m.service_type = nil
}

// SetNotes sets the "notes" field.
func (m *PortAllocationMutation) SetNotes(s string) {
	m.notes = &s
}

// Notes returns the value of the "notes" field in the mutation.
func (m *PortAllocationMutation) Notes() (r string, exists bool) {
	v := m.notes
	if v == nil {
		return
	}
	return *v, true
}

// OldNotes returns the old "notes" field's value of the PortAllocation entity.
// If the PortAllocation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PortAllocationMutation) OldNotes(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNotes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNotes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNotes: %w", err)
	}
	return oldValue.Notes, nil
}

// ClearNotes clears the value of the "notes" field.
func (m *PortAllocationMutation) ClearNotes() {
	m.notes = nil
	m.clearedFields[portallocation.FieldNotes] = struct{}{}
}

// NotesCleared returns if the "notes" field was cleared in this mutation.
func (m *PortAllocationMutation) NotesCleared() bool {
	_, ok := m.clearedFields[portallocation.FieldNotes]
	return ok
}

// ResetNotes resets all changes to the "notes" field.
func (m *PortAllocationMutation) ResetNotes() {
	m.notes = nil
	delete(m.clearedFields, portallocation.FieldNotes)
}

// SetAllocatedAt sets the "allocated_at" field.
func (m *PortAllocationMutation) SetAllocatedAt(t time.Time) {
	m.allocated_at = &t
}

// AllocatedAt returns the value of the "allocated_at" field in the mutation.
func (m *PortAllocationMutation) AllocatedAt() (r time.Time, exists bool) {
	v := m.allocated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldAllocatedAt returns the old "allocated_at" field's value of the PortAllocation entity.
// If the PortAllocation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PortAllocationMutation) OldAllocatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAllocatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAllocatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAllocatedAt: %w", err)
	}
	return oldValue.AllocatedAt, nil
}

// ResetAllocatedAt resets all changes to the "allocated_at" field.
func (m *PortAllocationMutation) ResetAllocatedAt() {
	m.allocated_at = nil
}

// ClearRouter clears the "router" edge to the Router entity.
func (m *PortAllocationMutation) ClearRouter() {
	m.clearedrouter = true
	m.clearedFields[portallocation.FieldRouterID] = struct{}{}
}

// RouterCleared reports if the "router" edge to the Router entity was cleared.
func (m *PortAllocationMutation) RouterCleared() bool {
	return m.clearedrouter
}

// RouterIDs returns the "router" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RouterID instead. It exists only for internal usage by the builders.
func (m *PortAllocationMutation) RouterIDs() (ids []string) {
	if id := m.router; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRouter resets all changes to the "router" edge.
func (m *PortAllocationMutation) ResetRouter() {
	m.router = nil
	m.clearedrouter = false
}

// SetServiceInstanceID sets the "service_instance" edge to the ServiceInstance entity by id.
func (m *PortAllocationMutation) SetServiceInstanceID(id string) {
	m.service_instance = &id
}

// ClearServiceInstance clears the "service_instance" edge to the ServiceInstance entity.
func (m *PortAllocationMutation) ClearServiceInstance() {
	m.clearedservice_instance = true
	m.clearedFields[portallocation.FieldInstanceID] = struct{}{}
}

// ServiceInstanceCleared reports if the "service_instance" edge to the ServiceInstance entity was cleared.
func (m *PortAllocationMutation) ServiceInstanceCleared() bool {
	return m.clearedservice_instance
}

// ServiceInstanceID returns the "service_instance" edge ID in the mutation.
func (m *PortAllocationMutation) ServiceInstanceID() (id string, exists bool) {
	if m.service_instance != nil {
		return *m.service_instance, true
	}
	return
}

// ServiceInstanceIDs returns the "service_instance" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ServiceInstanceID instead. It exists only for internal usage by the builders.
func (m *PortAllocationMutation) ServiceInstanceIDs() (ids []string) {
	if id := m.service_instance; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetServiceInstance resets all changes to the "service_instance" edge.
func (m *PortAllocationMutation) ResetServiceInstance() {
	m.service_instance = nil
	m.clearedservice_instance = false
}

// Where appends a list predicates to the PortAllocationMutation builder.
func (m *PortAllocationMutation) Where(ps ...predicate.PortAllocation) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PortAllocationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PortAllocationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PortAllocation, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PortAllocationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PortAllocationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PortAllocation).
func (m *PortAllocationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PortAllocationMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.router != nil {
		fields = append(fields, portallocation.FieldRouterID)
	}
	if m.port != nil {
		fields = append(fields, portallocation.FieldPort)
	}
	if m.protocol != nil {
		fields = append(fields, portallocation.FieldProtocol)
	}
	if m.service_instance != nil {
		fields = append(fields, portallocation.FieldInstanceID)
	}
	if m.service_type != nil {
		fields = append(fields, portallocation.FieldServiceType)
	}
	if m.notes != nil {
		fields = append(fields, portallocation.FieldNotes)
	}
	if m.allocated_at != nil {
		fields = append(fields, portallocation.FieldAllocatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PortAllocationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case portallocation.FieldRouterID:
		return m.RouterID()
	case portallocation.FieldPort:
		return m.Port()
	case portallocation.FieldProtocol:
		return m.Protocol()
	case portallocation.FieldInstanceID:
		return m.InstanceID()
	case portallocation.FieldServiceType:
		return m.ServiceType()
	case portallocation.FieldNotes:
		return m.Notes()
	case portallocation.FieldAllocatedAt:
		return m.AllocatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PortAllocationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case portallocation.FieldRouterID:
		return m.OldRouterID(ctx)
	case portallocation.FieldPort:
		return m.OldPort(ctx)
	case portallocation.FieldProtocol:
		return m.OldProtocol(ctx)
	case portallocation.FieldInstanceID:
		return m.OldInstanceID(ctx)
	case portallocation.FieldServiceType:
		return m.OldServiceType(ctx)
	case portallocation.FieldNotes:
		return m.OldNotes(ctx)
	case portallocation.FieldAllocatedAt:
		return m.OldAllocatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown PortAllocation field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PortAllocationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case portallocation.FieldRouterID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRouterID(v)
		return nil
	case portallocation.FieldPort:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPort(v)
		return nil
	case portallocation.FieldProtocol:
		v, ok := value.(portallocation.Protocol)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProtocol(v)
		return nil
	case portallocation.FieldInstanceID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInstanceID(v)
		return nil
	case portallocation.FieldServiceType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetServiceType(v)
		return nil
	case portallocation.FieldNotes:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNotes(v)
		return nil
	case portallocation.FieldAllocatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAllocatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown PortAllocation field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PortAllocationMutation) AddedFields() []string {
	var fields []string
	if m.addport != nil {
		fields = append(fields, portallocation.FieldPort)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PortAllocationMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case portallocation.FieldPort:
		return m.AddedPort()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PortAllocationMutation) AddField(name string, value ent.Value) error {
	switch name {
	case portallocation.FieldPort:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPort(v)
		return nil
	}
	return fmt.Errorf("unknown PortAllocation numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PortAllocationMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(portallocation.FieldNotes) {
		fields = append(fields, portallocation.FieldNotes)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PortAllocationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PortAllocationMutation) ClearField(name string) error {
	switch name {
	case portallocation.FieldNotes:
		m.ClearNotes()
		return nil
	}
	return fmt.Errorf("unknown PortAllocation nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PortAllocationMutation) ResetField(name string) error {
	switch name {
	case portallocation.FieldRouterID:
		m.ResetRouterID()
		return nil
	case portallocation.FieldPort:
		m.ResetPort()
		return nil
	case portallocation.FieldProtocol:
		m.ResetProtocol()
		return nil
	case portallocation.FieldInstanceID:
		m.ResetInstanceID()
		return nil
	case portallocation.FieldServiceType:
		m.ResetServiceType()
		return nil
	case portallocation.FieldNotes:
		m.ResetNotes()
		return nil
	case portallocation.FieldAllocatedAt:
		m.ResetAllocatedAt()
		return nil
	}
	return fmt.Errorf("unknown PortAllocation field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PortAllocationMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.router != nil {
		edges = append(edges, portallocation.EdgeRouter)
	}
	if m.service_instance != nil {
		edges = append(edges, portallocation.EdgeServiceInstance)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PortAllocationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case portallocation.EdgeRouter:
		if id := m.router; id != nil {
			return []ent.Value{*id}
		}
	case portallocation.EdgeServiceInstance:
		if id := m.service_instance; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PortAllocationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PortAllocationMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PortAllocationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedrouter {
		edges = append(edges, portallocation.EdgeRouter)
	}
	if m.clearedservice_instance {
		edges = append(edges, portallocation.EdgeServiceInstance)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PortAllocationMutation) EdgeCleared(name string) bool {
	switch name {
	case portallocation.EdgeRouter:
		return m.clearedrouter
	case portallocation.EdgeServiceInstance:
		return m.clearedservice_instance
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PortAllocationMutation) ClearEdge(name string) error {
	switch name {
	case portallocation.EdgeRouter:
		m.ClearRouter()
		return nil
	case portallocation.EdgeServiceInstance:
		m.ClearServiceInstance()
		return nil
	}
	return fmt.Errorf("unknown PortAllocation unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PortAllocationMutation) ResetEdge(name string) error {
	switch name {
	case portallocation.EdgeRouter:
		m.ResetRouter()
		return nil
	case portallocation.EdgeServiceInstance:
		m.ResetServiceInstance()
		return nil
	}
	return fmt.Errorf("unknown PortAllocation edge %s", name)
}

// PortKnockSequenceMutation represents an operation that mutates the PortKnockSequence nodes in the graph.
type PortKnockSequenceMutation struct {
	config
	op                       Op
	typ                      string
	id                       *string
	name                     *string
	knock_ports              *[]map[string]interface{}
	appendknock_ports        []map[string]interface{}
	protected_port           *int
	addprotected_port        *int
	protected_protocol       *portknocksequence.ProtectedProtocol
	access_timeout           *string
	knock_timeout            *string
	enabled                  *bool
	generated_rule_ids       *[]string
	appendgenerated_rule_ids []string
	recent_access_count      *int
	addrecent_access_count   *int
	last_accessed_at         *time.Time
	created_at               *time.Time
	updated_at               *time.Time
	clearedFields            map[string]struct{}
	router                   *string
	clearedrouter            bool
	done                     bool
	oldValue                 func(context.Context) (*PortKnockSequence, error)
	predicates               []predicate.PortKnockSequence
}

var _ ent.Mutation = (*PortKnockSequenceMutation)(nil)

// portknocksequenceOption allows management of the mutation configuration using functional options.
type portknocksequenceOption func(*PortKnockSequenceMutation)

// newPortKnockSequenceMutation creates new mutation for the PortKnockSequence entity.
func newPortKnockSequenceMutation(c config, op Op, opts ...portknocksequenceOption) *PortKnockSequenceMutation {
	m := &PortKnockSequenceMutation{
		config:        c,
		op:            op,
		typ:           TypePortKnockSequence,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPortKnockSequenceID sets the ID field of the mutation.
func withPortKnockSequenceID(id string) portknocksequenceOption {
	return func(m *PortKnockSequenceMutation) {
		var (
			err   error
			once  sync.Once
			value *PortKnockSequence
		)
		m.oldValue = func(ctx context.Context) (*PortKnockSequence, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PortKnockSequence.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPortKnockSequence sets the old PortKnockSequence of the mutation.
func withPortKnockSequence(node *PortKnockSequence) portknocksequenceOption {
	return func(m *PortKnockSequenceMutation) {
		m.oldValue = func(context.Context) (*PortKnockSequence, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PortKnockSequenceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PortKnockSequenceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of PortKnockSequence entities.
func (m *PortKnockSequenceMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PortKnockSequenceMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PortKnockSequenceMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PortKnockSequence.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *PortKnockSequenceMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *PortKnockSequenceMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the PortKnockSequence entity.
// If the PortKnockSequence object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PortKnockSequenceMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *PortKnockSequenceMutation) ResetName() {
	m.name = nil
}

// SetKnockPorts sets the "knock_ports" field.
func (m *PortKnockSequenceMutation) SetKnockPorts(value []map[string]interface{}) {
	m.knock_ports = &value
	m.appendknock_ports = nil
}

// KnockPorts returns the value of the "knock_ports" field in the mutation.
func (m *PortKnockSequenceMutation) KnockPorts() (r []map[string]interface{}, exists bool) {
	v := m.knock_ports
	if v == nil {
		return
	}
	return *v, true
}

// OldKnockPorts returns the old "knock_ports" field's value of the PortKnockSequence entity.
// If the PortKnockSequence object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PortKnockSequenceMutation) OldKnockPorts(ctx context.Context) (v []map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKnockPorts is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKnockPorts requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKnockPorts: %w", err)
	}
	return oldValue.KnockPorts, nil
}

// AppendKnockPorts adds value to the "knock_ports" field.
func (m *PortKnockSequenceMutation) AppendKnockPorts(value []map[string]interface{}) {
	m.appendknock_ports = append(m.appendknock_ports, value...)
}

// AppendedKnockPorts returns the list of values that were appended to the "knock_ports" field in this mutation.
func (m *PortKnockSequenceMutation) AppendedKnockPorts() ([]map[string]interface{}, bool) {
	if len(m.appendknock_ports) == 0 {
		return nil, false
	}
	return m.appendknock_ports, true
}

// ResetKnockPorts resets all changes to the "knock_ports" field.
func (m *PortKnockSequenceMutation) ResetKnockPorts() {
	m.knock_ports = nil
	m.appendknock_ports = nil
}

// SetProtectedPort sets the "protected_port" field.
func (m *PortKnockSequenceMutation) SetProtectedPort(i int) {
	m.protected_port = &i
	m.addprotected_port = nil
}

// ProtectedPort returns the value of the "protected_port" field in the mutation.
func (m *PortKnockSequenceMutation) ProtectedPort() (r int, exists bool) {
	v := m.protected_port
	if v == nil {
		return
	}
	return *v, true
}

// OldProtectedPort returns the old "protected_port" field's value of the PortKnockSequence entity.
// If the PortKnockSequence object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PortKnockSequenceMutation) OldProtectedPort(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProtectedPort is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProtectedPort requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProtectedPort: %w", err)
	}
	return oldValue.ProtectedPort, nil
}

// AddProtectedPort adds i to the "protected_port" field.
func (m *PortKnockSequenceMutation) AddProtectedPort(i int) {
	if m.addprotected_port != nil {
		*m.addprotected_port += i
	} else {
		m.addprotected_port = &i
	}
}

// AddedProtectedPort returns the value that was added to the "protected_port" field in this mutation.
func (m *PortKnockSequenceMutation) AddedProtectedPort() (r int, exists bool) {
	v := m.addprotected_port
	if v == nil {
		return
	}
	return *v, true
}

// ResetProtectedPort resets all changes to the "protected_port" field.
func (m *PortKnockSequenceMutation) ResetProtectedPort() {
	m.protected_port = nil
	m.addprotected_port = nil
}

// SetProtectedProtocol sets the "protected_protocol" field.
func (m *PortKnockSequenceMutation) SetProtectedProtocol(pp portknocksequence.ProtectedProtocol) {
	m.protected_protocol = &pp
}

// ProtectedProtocol returns the value of the "protected_protocol" field in the mutation.
func (m *PortKnockSequenceMutation) ProtectedProtocol() (r portknocksequence.ProtectedProtocol, exists bool) {
	v := m.protected_protocol
	if v == nil {
		return
	}
	return *v, true
}

// OldProtectedProtocol returns the old "protected_protocol" field's value of the PortKnockSequence entity.
// If the PortKnockSequence object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PortKnockSequenceMutation) OldProtectedProtocol(ctx context.Context) (v portknocksequence.ProtectedProtocol, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProtectedProtocol is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProtectedProtocol requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProtectedProtocol: %w", err)
	}
	return oldValue.ProtectedProtocol, nil
}

// ResetProtectedProtocol resets all changes to the "protected_protocol" field.
func (m *PortKnockSequenceMutation) ResetProtectedProtocol() {
	m.protected_protocol = nil
}

// SetAccessTimeout sets the "access_timeout" field.
func (m *PortKnockSequenceMutation) SetAccessTimeout(s string) {
	m.access_timeout = &s
}

// AccessTimeout returns the value of the "access_timeout" field in the mutation.
func (m *PortKnockSequenceMutation) AccessTimeout() (r string, exists bool) {
	v := m.access_timeout
	if v == nil {
		return
	}
	return *v, true
}

// OldAccessTimeout returns the old "access_timeout" field's value of the PortKnockSequence entity.
// If the PortKnockSequence object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PortKnockSequenceMutation) OldAccessTimeout(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccessTimeout is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccessTimeout requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccessTimeout: %w", err)
	}
	return oldValue.AccessTimeout, nil
}

// ResetAccessTimeout resets all changes to the "access_timeout" field.
func (m *PortKnockSequenceMutation) ResetAccessTimeout() {
	m.access_timeout = nil
}

// SetKnockTimeout sets the "knock_timeout" field.
func (m *PortKnockSequenceMutation) SetKnockTimeout(s string) {
	m.knock_timeout = &s
}

// KnockTimeout returns the value of the "knock_timeout" field in the mutation.
func (m *PortKnockSequenceMutation) KnockTimeout() (r string, exists bool) {
	v := m.knock_timeout
	if v == nil {
		return
	}
	return *v, true
}

// OldKnockTimeout returns the old "knock_timeout" field's value of the PortKnockSequence entity.
// If the PortKnockSequence object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PortKnockSequenceMutation) OldKnockTimeout(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKnockTimeout is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKnockTimeout requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKnockTimeout: %w", err)
	}
	return oldValue.KnockTimeout, nil
}

// ResetKnockTimeout resets all changes to the "knock_timeout" field.
func (m *PortKnockSequenceMutation) ResetKnockTimeout() {
	m.knock_timeout = nil
}

// SetEnabled sets the "enabled" field.
func (m *PortKnockSequenceMutation) SetEnabled(b bool) {
	m.enabled = &b
}

// Enabled returns the value of the "enabled" field in the mutation.
func (m *PortKnockSequenceMutation) Enabled() (r bool, exists bool) {
	v := m.enabled
	if v == nil {
		return
	}
	return *v, true
}

// OldEnabled returns the old "enabled" field's value of the PortKnockSequence entity.
// If the PortKnockSequence object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PortKnockSequenceMutation) OldEnabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnabled: %w", err)
	}
	return oldValue.Enabled, nil
}

// ResetEnabled resets all changes to the "enabled" field.
func (m *PortKnockSequenceMutation) ResetEnabled() {
	m.enabled = nil
}

// SetRouterID sets the "router_id" field.
func (m *PortKnockSequenceMutation) SetRouterID(s string) {
	m.router = &s
}

// RouterID returns the value of the "router_id" field in the mutation.
func (m *PortKnockSequenceMutation) RouterID() (r string, exists bool) {
	v := m.router
	if v == nil {
		return
	}
	return *v, true
}

// OldRouterID returns the old "router_id" field's value of the PortKnockSequence entity.
// If the PortKnockSequence object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PortKnockSequenceMutation) OldRouterID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRouterID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRouterID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRouterID: %w", err)
	}
	return oldValue.RouterID, nil
}

// ResetRouterID resets all changes to the "router_id" field.
func (m *PortKnockSequenceMutation) ResetRouterID() {
	m.router = nil
}

// SetGeneratedRuleIds sets the "generated_rule_ids" field.
func (m *PortKnockSequenceMutation) SetGeneratedRuleIds(s []string) {
	m.generated_rule_ids = &s
	m.appendgenerated_rule_ids = nil
}

// GeneratedRuleIds returns the value of the "generated_rule_ids" field in the mutation.
func (m *PortKnockSequenceMutation) GeneratedRuleIds() (r []string, exists bool) {
	v := m.generated_rule_ids
	if v == nil {
		return
	}
	return *v, true
}

// OldGeneratedRuleIds returns the old "generated_rule_ids" field's value of the PortKnockSequence entity.
// If the PortKnockSequence object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PortKnockSequenceMutation) OldGeneratedRuleIds(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGeneratedRuleIds is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGeneratedRuleIds requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGeneratedRuleIds: %w", err)
	}
	return oldValue.GeneratedRuleIds, nil
}

// AppendGeneratedRuleIds adds s to the "generated_rule_ids" field.
func (m *PortKnockSequenceMutation) AppendGeneratedRuleIds(s []string) {
	m.appendgenerated_rule_ids = append(m.appendgenerated_rule_ids, s...)
}

// AppendedGeneratedRuleIds returns the list of values that were appended to the "generated_rule_ids" field in this mutation.
func (m *PortKnockSequenceMutation) AppendedGeneratedRuleIds() ([]string, bool) {
	if len(m.appendgenerated_rule_ids) == 0 {
		return nil, false
	}
	return m.appendgenerated_rule_ids, true
}

// ClearGeneratedRuleIds clears the value of the "generated_rule_ids" field.
func (m *PortKnockSequenceMutation) ClearGeneratedRuleIds() {
	m.generated_rule_ids = nil
	m.appendgenerated_rule_ids = nil
	m.clearedFields[portknocksequence.FieldGeneratedRuleIds] = struct{}{}
}

// GeneratedRuleIdsCleared returns if the "generated_rule_ids" field was cleared in this mutation.
func (m *PortKnockSequenceMutation) GeneratedRuleIdsCleared() bool {
	_, ok := m.clearedFields[portknocksequence.FieldGeneratedRuleIds]
	return ok
}

// ResetGeneratedRuleIds resets all changes to the "generated_rule_ids" field.
func (m *PortKnockSequenceMutation) ResetGeneratedRuleIds() {
	m.generated_rule_ids = nil
	m.appendgenerated_rule_ids = nil
	delete(m.clearedFields, portknocksequence.FieldGeneratedRuleIds)
}

// SetRecentAccessCount sets the "recent_access_count" field.
func (m *PortKnockSequenceMutation) SetRecentAccessCount(i int) {
	m.recent_access_count = &i
	m.addrecent_access_count = nil
}

// RecentAccessCount returns the value of the "recent_access_count" field in the mutation.
func (m *PortKnockSequenceMutation) RecentAccessCount() (r int, exists bool) {
	v := m.recent_access_count
	if v == nil {
		return
	}
	return *v, true
}

// OldRecentAccessCount returns the old "recent_access_count" field's value of the PortKnockSequence entity.
// If the PortKnockSequence object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PortKnockSequenceMutation) OldRecentAccessCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRecentAccessCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRecentAccessCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRecentAccessCount: %w", err)
	}
	return oldValue.RecentAccessCount, nil
}

// AddRecentAccessCount adds i to the "recent_access_count" field.
func (m *PortKnockSequenceMutation) AddRecentAccessCount(i int) {
	if m.addrecent_access_count != nil {
		*m.addrecent_access_count += i
	} else {
		m.addrecent_access_count = &i
	}
}

// AddedRecentAccessCount returns the value that was added to the "recent_access_count" field in this mutation.
func (m *PortKnockSequenceMutation) AddedRecentAccessCount() (r int, exists bool) {
	v := m.addrecent_access_count
	if v == nil {
		return
	}
	return *v, true
}

// ClearRecentAccessCount clears the value of the "recent_access_count" field.
func (m *PortKnockSequenceMutation) ClearRecentAccessCount() {
	m.recent_access_count = nil
	m.addrecent_access_count = nil
	m.clearedFields[portknocksequence.FieldRecentAccessCount] = struct{}{}
}

// RecentAccessCountCleared returns if the "recent_access_count" field was cleared in this mutation.
func (m *PortKnockSequenceMutation) RecentAccessCountCleared() bool {
	_, ok := m.clearedFields[portknocksequence.FieldRecentAccessCount]
	return ok
}

// ResetRecentAccessCount resets all changes to the "recent_access_count" field.
func (m *PortKnockSequenceMutation) ResetRecentAccessCount() {
	m.recent_access_count = nil
	m.addrecent_access_count = nil
	delete(m.clearedFields, portknocksequence.FieldRecentAccessCount)
}

// SetLastAccessedAt sets the "last_accessed_at" field.
func (m *PortKnockSequenceMutation) SetLastAccessedAt(t time.Time) {
	m.last_accessed_at = &t
}

// LastAccessedAt returns the value of the "last_accessed_at" field in the mutation.
func (m *PortKnockSequenceMutation) LastAccessedAt() (r time.Time, exists bool) {
	v := m.last_accessed_at
	if v == nil {
		return
	}
	return *v, true
}

// OldLastAccessedAt returns the old "last_accessed_at" field's value of the PortKnockSequence entity.
// If the PortKnockSequence object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PortKnockSequenceMutation) OldLastAccessedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastAccessedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastAccessedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastAccessedAt: %w", err)
	}
	return oldValue.LastAccessedAt, nil
}

// ClearLastAccessedAt clears the value of the "last_accessed_at" field.
func (m *PortKnockSequenceMutation) ClearLastAccessedAt() {
	m.last_accessed_at = nil
	m.clearedFields[portknocksequence.FieldLastAccessedAt] = struct{}{}
}

// LastAccessedAtCleared returns if the "last_accessed_at" field was cleared in this mutation.
func (m *PortKnockSequenceMutation) LastAccessedAtCleared() bool {
	_, ok := m.clearedFields[portknocksequence.FieldLastAccessedAt]
	return ok
}

// ResetLastAccessedAt resets all changes to the "last_accessed_at" field.
func (m *PortKnockSequenceMutation) ResetLastAccessedAt() {
	m.last_accessed_at = nil
	delete(m.clearedFields, portknocksequence.FieldLastAccessedAt)
}

// SetCreatedAt sets the "created_at" field.
func (m *PortKnockSequenceMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PortKnockSequenceMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the PortKnockSequence entity.
// If the PortKnockSequence object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PortKnockSequenceMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PortKnockSequenceMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PortKnockSequenceMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PortKnockSequenceMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the PortKnockSequence entity.
// If the PortKnockSequence object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PortKnockSequenceMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PortKnockSequenceMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearRouter clears the "router" edge to the Router entity.
func (m *PortKnockSequenceMutation) ClearRouter() {
	m.clearedrouter = true
	m.clearedFields[portknocksequence.FieldRouterID] = struct{}{}
}

// RouterCleared reports if the "router" edge to the Router entity was cleared.
func (m *PortKnockSequenceMutation) RouterCleared() bool {
	return m.clearedrouter
}

// RouterIDs returns the "router" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RouterID instead. It exists only for internal usage by the builders.
func (m *PortKnockSequenceMutation) RouterIDs() (ids []string) {
	if id := m.router; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRouter resets all changes to the "router" edge.
func (m *PortKnockSequenceMutation) ResetRouter() {
	m.router = nil
	m.clearedrouter = false
}

// Where appends a list predicates to the PortKnockSequenceMutation builder.
func (m *PortKnockSequenceMutation) Where(ps ...predicate.PortKnockSequence) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PortKnockSequenceMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PortKnockSequenceMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PortKnockSequence, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PortKnockSequenceMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PortKnockSequenceMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PortKnockSequence).
func (m *PortKnockSequenceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PortKnockSequenceMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.name != nil {
		fields = append(fields, portknocksequence.FieldName)
	}
	if m.knock_ports != nil {
		fields = append(fields, portknocksequence.FieldKnockPorts)
	}
	if m.protected_port != nil {
		fields = append(fields, portknocksequence.FieldProtectedPort)
	}
	if m.protected_protocol != nil {
		fields = append(fields, portknocksequence.FieldProtectedProtocol)
	}
	if m.access_timeout != nil {
		fields = append(fields, portknocksequence.FieldAccessTimeout)
	}
	if m.knock_timeout != nil {
		fields = append(fields, portknocksequence.FieldKnockTimeout)
	}
	if m.enabled != nil {
		fields = append(fields, portknocksequence.FieldEnabled)
	}
	if m.router != nil {
		fields = append(fields, portknocksequence.FieldRouterID)
	}
	if m.generated_rule_ids != nil {
		fields = append(fields, portknocksequence.FieldGeneratedRuleIds)
	}
	if m.recent_access_count != nil {
		fields = append(fields, portknocksequence.FieldRecentAccessCount)
	}
	if m.last_accessed_at != nil {
		fields = append(fields, portknocksequence.FieldLastAccessedAt)
	}
	if m.created_at != nil {
		fields = append(fields, portknocksequence.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, portknocksequence.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PortKnockSequenceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case portknocksequence.FieldName:
		return m.Name()
	case portknocksequence.FieldKnockPorts:
		return m.KnockPorts()
	case portknocksequence.FieldProtectedPort:
		return m.ProtectedPort()
	case portknocksequence.FieldProtectedProtocol:
		return m.ProtectedProtocol()
	case portknocksequence.FieldAccessTimeout:
		return m.AccessTimeout()
	case portknocksequence.FieldKnockTimeout:
		return m.KnockTimeout()
	case portknocksequence.FieldEnabled:
		return m.Enabled()
	case portknocksequence.FieldRouterID:
		return m.RouterID()
	case portknocksequence.FieldGeneratedRuleIds:
		return m.GeneratedRuleIds()
	case portknocksequence.FieldRecentAccessCount:
		return m.RecentAccessCount()
	case portknocksequence.FieldLastAccessedAt:
		return m.LastAccessedAt()
	case portknocksequence.FieldCreatedAt:
		return m.CreatedAt()
	case portknocksequence.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PortKnockSequenceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case portknocksequence.FieldName:
		return m.OldName(ctx)
	case portknocksequence.FieldKnockPorts:
		return m.OldKnockPorts(ctx)
	case portknocksequence.FieldProtectedPort:
		return m.OldProtectedPort(ctx)
	case portknocksequence.FieldProtectedProtocol:
		return m.OldProtectedProtocol(ctx)
	case portknocksequence.FieldAccessTimeout:
		return m.OldAccessTimeout(ctx)
	case portknocksequence.FieldKnockTimeout:
		return m.OldKnockTimeout(ctx)
	case portknocksequence.FieldEnabled:
		return m.OldEnabled(ctx)
	case portknocksequence.FieldRouterID:
		return m.OldRouterID(ctx)
	case portknocksequence.FieldGeneratedRuleIds:
		return m.OldGeneratedRuleIds(ctx)
	case portknocksequence.FieldRecentAccessCount:
		return m.OldRecentAccessCount(ctx)
	case portknocksequence.FieldLastAccessedAt:
		return m.OldLastAccessedAt(ctx)
	case portknocksequence.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case portknocksequence.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown PortKnockSequence field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PortKnockSequenceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case portknocksequence.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case portknocksequence.FieldKnockPorts:
		v, ok := value.([]map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKnockPorts(v)
		return nil
	case portknocksequence.FieldProtectedPort:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProtectedPort(v)
		return nil
	case portknocksequence.FieldProtectedProtocol:
		v, ok := value.(portknocksequence.ProtectedProtocol)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProtectedProtocol(v)
		return nil
	case portknocksequence.FieldAccessTimeout:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccessTimeout(v)
		return nil
	case portknocksequence.FieldKnockTimeout:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKnockTimeout(v)
		return nil
	case portknocksequence.FieldEnabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnabled(v)
		return nil
	case portknocksequence.FieldRouterID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRouterID(v)
		return nil
	case portknocksequence.FieldGeneratedRuleIds:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGeneratedRuleIds(v)
		return nil
	case portknocksequence.FieldRecentAccessCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRecentAccessCount(v)
		return nil
	case portknocksequence.FieldLastAccessedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastAccessedAt(v)
		return nil
	case portknocksequence.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case portknocksequence.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown PortKnockSequence field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PortKnockSequenceMutation) AddedFields() []string {
	var fields []string
	if m.addprotected_port != nil {
		fields = append(fields, portknocksequence.FieldProtectedPort)
	}
	if m.addrecent_access_count != nil {
		fields = append(fields, portknocksequence.FieldRecentAccessCount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PortKnockSequenceMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case portknocksequence.FieldProtectedPort:
		return m.AddedProtectedPort()
	case portknocksequence.FieldRecentAccessCount:
		return m.AddedRecentAccessCount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PortKnockSequenceMutation) AddField(name string, value ent.Value) error {
	switch name {
	case portknocksequence.FieldProtectedPort:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddProtectedPort(v)
		return nil
	case portknocksequence.FieldRecentAccessCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRecentAccessCount(v)
		return nil
	}
	return fmt.Errorf("unknown PortKnockSequence numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PortKnockSequenceMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(portknocksequence.FieldGeneratedRuleIds) {
		fields = append(fields, portknocksequence.FieldGeneratedRuleIds)
	}
	if m.FieldCleared(portknocksequence.FieldRecentAccessCount) {
		fields = append(fields, portknocksequence.FieldRecentAccessCount)
	}
	if m.FieldCleared(portknocksequence.FieldLastAccessedAt) {
		fields = append(fields, portknocksequence.FieldLastAccessedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PortKnockSequenceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PortKnockSequenceMutation) ClearField(name string) error {
	switch name {
	case portknocksequence.FieldGeneratedRuleIds:
		m.ClearGeneratedRuleIds()
		return nil
	case portknocksequence.FieldRecentAccessCount:
		m.ClearRecentAccessCount()
		return nil
	case portknocksequence.FieldLastAccessedAt:
		m.ClearLastAccessedAt()
		return nil
	}
	return fmt.Errorf("unknown PortKnockSequence nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PortKnockSequenceMutation) ResetField(name string) error {
	switch name {
	case portknocksequence.FieldName:
		m.ResetName()
		return nil
	case portknocksequence.FieldKnockPorts:
		m.ResetKnockPorts()
		return nil
	case portknocksequence.FieldProtectedPort:
		m.ResetProtectedPort()
		return nil
	case portknocksequence.FieldProtectedProtocol:
		m.ResetProtectedProtocol()
		return nil
	case portknocksequence.FieldAccessTimeout:
		m.ResetAccessTimeout()
		return nil
	case portknocksequence.FieldKnockTimeout:
		m.ResetKnockTimeout()
		return nil
	case portknocksequence.FieldEnabled:
		m.ResetEnabled()
		return nil
	case portknocksequence.FieldRouterID:
		m.ResetRouterID()
		return nil
	case portknocksequence.FieldGeneratedRuleIds:
		m.ResetGeneratedRuleIds()
		return nil
	case portknocksequence.FieldRecentAccessCount:
		m.ResetRecentAccessCount()
		return nil
	case portknocksequence.FieldLastAccessedAt:
		m.ResetLastAccessedAt()
		return nil
	case portknocksequence.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case portknocksequence.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown PortKnockSequence field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PortKnockSequenceMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.router != nil {
		edges = append(edges, portknocksequence.EdgeRouter)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PortKnockSequenceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case portknocksequence.EdgeRouter:
		if id := m.router; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PortKnockSequenceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PortKnockSequenceMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PortKnockSequenceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedrouter {
		edges = append(edges, portknocksequence.EdgeRouter)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PortKnockSequenceMutation) EdgeCleared(name string) bool {
	switch name {
	case portknocksequence.EdgeRouter:
		return m.clearedrouter
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PortKnockSequenceMutation) ClearEdge(name string) error {
	switch name {
	case portknocksequence.EdgeRouter:
		m.ClearRouter()
		return nil
	}
	return fmt.Errorf("unknown PortKnockSequence unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PortKnockSequenceMutation) ResetEdge(name string) error {
	switch name {
	case portknocksequence.EdgeRouter:
		m.ResetRouter()
		return nil
	}
	return fmt.Errorf("unknown PortKnockSequence edge %s", name)
}

// ResourceMutation represents an operation that mutates the Resource nodes in the graph.
type ResourceMutation struct {
	config
	op                 Op
	typ                string
	id                 *string
	_type              *string
	category           *string
	ros_id             *string
	configuration      *map[string]interface{}
	validation         *map[string]interface{}
	deployment         *map[string]interface{}
	runtime            *map[string]interface{}
	telemetry          *map[string]interface{}
	metadata           *map[string]interface{}
	relationships      *map[string]interface{}
	platform           *map[string]interface{}
	sync_status        *resource.SyncStatus
	enabled            *bool
	managed            *bool
	version            *int64
	addversion         *int64
	created_at         *time.Time
	updated_at         *time.Time
	synced_at          *time.Time
	router_modified_at *time.Time
	clearedFields      map[string]struct{}
	events             map[string]struct{}
	removedevents      map[string]struct{}
	clearedevents      bool
	done               bool
	oldValue           func(context.Context) (*Resource, error)
	predicates         []predicate.Resource
}

var _ ent.Mutation = (*ResourceMutation)(nil)

// resourceOption allows management of the mutation configuration using functional options.
type resourceOption func(*ResourceMutation)

// newResourceMutation creates new mutation for the Resource entity.
func newResourceMutation(c config, op Op, opts ...resourceOption) *ResourceMutation {
	m := &ResourceMutation{
		config:        c,
		op:            op,
		typ:           TypeResource,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withResourceID sets the ID field of the mutation.
func withResourceID(id string) resourceOption {
	return func(m *ResourceMutation) {
		var (
			err   error
			once  sync.Once
			value *Resource
		)
		m.oldValue = func(ctx context.Context) (*Resource, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Resource.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withResource sets the old Resource of the mutation.
func withResource(node *Resource) resourceOption {
	return func(m *ResourceMutation) {
		m.oldValue = func(context.Context) (*Resource, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ResourceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ResourceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Resource entities.
func (m *ResourceMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ResourceMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ResourceMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Resource.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetType sets the "type" field.
func (m *ResourceMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *ResourceMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Resource entity.
// If the Resource object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *ResourceMutation) ResetType() {
	m._type = nil
}

// SetCategory sets the "category" field.
func (m *ResourceMutation) SetCategory(s string) {
	m.category = &s
}

// Category returns the value of the "category" field in the mutation.
func (m *ResourceMutation) Category() (r string, exists bool) {
	v := m.category
	if v == nil {
		return
	}
	return *v, true
}

// OldCategory returns the old "category" field's value of the Resource entity.
// If the Resource object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceMutation) OldCategory(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategory: %w", err)
	}
	return oldValue.Category, nil
}

// ResetCategory resets all changes to the "category" field.
func (m *ResourceMutation) ResetCategory() {
	m.category = nil
}

// SetRosID sets the "ros_id" field.
func (m *ResourceMutation) SetRosID(s string) {
	m.ros_id = &s
}

// RosID returns the value of the "ros_id" field in the mutation.
func (m *ResourceMutation) RosID() (r string, exists bool) {
	v := m.ros_id
	if v == nil {
		return
	}
	return *v, true
}

// OldRosID returns the old "ros_id" field's value of the Resource entity.
// If the Resource object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceMutation) OldRosID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRosID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRosID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRosID: %w", err)
	}
	return oldValue.RosID, nil
}

// ClearRosID clears the value of the "ros_id" field.
func (m *ResourceMutation) ClearRosID() {
	m.ros_id = nil
	m.clearedFields[resource.FieldRosID] = struct{}{}
}

// RosIDCleared returns if the "ros_id" field was cleared in this mutation.
func (m *ResourceMutation) RosIDCleared() bool {
	_, ok := m.clearedFields[resource.FieldRosID]
	return ok
}

// ResetRosID resets all changes to the "ros_id" field.
func (m *ResourceMutation) ResetRosID() {
	m.ros_id = nil
	delete(m.clearedFields, resource.FieldRosID)
}

// SetConfiguration sets the "configuration" field.
func (m *ResourceMutation) SetConfiguration(value map[string]interface{}) {
	m.configuration = &value
}

// Configuration returns the value of the "configuration" field in the mutation.
func (m *ResourceMutation) Configuration() (r map[string]interface{}, exists bool) {
	v := m.configuration
	if v == nil {
		return
	}
	return *v, true
}

// OldConfiguration returns the old "configuration" field's value of the Resource entity.
// If the Resource object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceMutation) OldConfiguration(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConfiguration is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConfiguration requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConfiguration: %w", err)
	}
	return oldValue.Configuration, nil
}

// ResetConfiguration resets all changes to the "configuration" field.
func (m *ResourceMutation) ResetConfiguration() {
	m.configuration = nil
}

// SetValidation sets the "validation" field.
func (m *ResourceMutation) SetValidation(value map[string]interface{}) {
	m.validation = &value
}

// Validation returns the value of the "validation" field in the mutation.
func (m *ResourceMutation) Validation() (r map[string]interface{}, exists bool) {
	v := m.validation
	if v == nil {
		return
	}
	return *v, true
}

// OldValidation returns the old "validation" field's value of the Resource entity.
// If the Resource object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceMutation) OldValidation(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValidation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValidation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValidation: %w", err)
	}
	return oldValue.Validation, nil
}

// ClearValidation clears the value of the "validation" field.
func (m *ResourceMutation) ClearValidation() {
	m.validation = nil
	m.clearedFields[resource.FieldValidation] = struct{}{}
}

// ValidationCleared returns if the "validation" field was cleared in this mutation.
func (m *ResourceMutation) ValidationCleared() bool {
	_, ok := m.clearedFields[resource.FieldValidation]
	return ok
}

// ResetValidation resets all changes to the "validation" field.
func (m *ResourceMutation) ResetValidation() {
	m.validation = nil
	delete(m.clearedFields, resource.FieldValidation)
}

// SetDeployment sets the "deployment" field.
func (m *ResourceMutation) SetDeployment(value map[string]interface{}) {
	m.deployment = &value
}

// Deployment returns the value of the "deployment" field in the mutation.
func (m *ResourceMutation) Deployment() (r map[string]interface{}, exists bool) {
	v := m.deployment
	if v == nil {
		return
	}
	return *v, true
}

// OldDeployment returns the old "deployment" field's value of the Resource entity.
// If the Resource object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceMutation) OldDeployment(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeployment is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeployment requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeployment: %w", err)
	}
	return oldValue.Deployment, nil
}

// ClearDeployment clears the value of the "deployment" field.
func (m *ResourceMutation) ClearDeployment() {
	m.deployment = nil
	m.clearedFields[resource.FieldDeployment] = struct{}{}
}

// DeploymentCleared returns if the "deployment" field was cleared in this mutation.
func (m *ResourceMutation) DeploymentCleared() bool {
	_, ok := m.clearedFields[resource.FieldDeployment]
	return ok
}

// ResetDeployment resets all changes to the "deployment" field.
func (m *ResourceMutation) ResetDeployment() {
	m.deployment = nil
	delete(m.clearedFields, resource.FieldDeployment)
}

// SetRuntime sets the "runtime" field.
func (m *ResourceMutation) SetRuntime(value map[string]interface{}) {
	m.runtime = &value
}

// Runtime returns the value of the "runtime" field in the mutation.
func (m *ResourceMutation) Runtime() (r map[string]interface{}, exists bool) {
	v := m.runtime
	if v == nil {
		return
	}
	return *v, true
}

// OldRuntime returns the old "runtime" field's value of the Resource entity.
// If the Resource object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceMutation) OldRuntime(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRuntime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRuntime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRuntime: %w", err)
	}
	return oldValue.Runtime, nil
}

// ClearRuntime clears the value of the "runtime" field.
func (m *ResourceMutation) ClearRuntime() {
	m.runtime = nil
	m.clearedFields[resource.FieldRuntime] = struct{}{}
}

// RuntimeCleared returns if the "runtime" field was cleared in this mutation.
func (m *ResourceMutation) RuntimeCleared() bool {
	_, ok := m.clearedFields[resource.FieldRuntime]
	return ok
}

// ResetRuntime resets all changes to the "runtime" field.
func (m *ResourceMutation) ResetRuntime() {
	m.runtime = nil
	delete(m.clearedFields, resource.FieldRuntime)
}

// SetTelemetry sets the "telemetry" field.
func (m *ResourceMutation) SetTelemetry(value map[string]interface{}) {
	m.telemetry = &value
}

// Telemetry returns the value of the "telemetry" field in the mutation.
func (m *ResourceMutation) Telemetry() (r map[string]interface{}, exists bool) {
	v := m.telemetry
	if v == nil {
		return
	}
	return *v, true
}

// OldTelemetry returns the old "telemetry" field's value of the Resource entity.
// If the Resource object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceMutation) OldTelemetry(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTelemetry is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTelemetry requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTelemetry: %w", err)
	}
	return oldValue.Telemetry, nil
}

// ClearTelemetry clears the value of the "telemetry" field.
func (m *ResourceMutation) ClearTelemetry() {
	m.telemetry = nil
	m.clearedFields[resource.FieldTelemetry] = struct{}{}
}

// TelemetryCleared returns if the "telemetry" field was cleared in this mutation.
func (m *ResourceMutation) TelemetryCleared() bool {
	_, ok := m.clearedFields[resource.FieldTelemetry]
	return ok
}

// ResetTelemetry resets all changes to the "telemetry" field.
func (m *ResourceMutation) ResetTelemetry() {
	m.telemetry = nil
	delete(m.clearedFields, resource.FieldTelemetry)
}

// SetMetadata sets the "metadata" field.
func (m *ResourceMutation) SetMetadata(value map[string]interface{}) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *ResourceMutation) Metadata() (r map[string]interface{}, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the Resource entity.
// If the Resource object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceMutation) OldMetadata(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *ResourceMutation) ResetMetadata() {
	m.metadata = nil
}

// SetRelationships sets the "relationships" field.
func (m *ResourceMutation) SetRelationships(value map[string]interface{}) {
	m.relationships = &value
}

// Relationships returns the value of the "relationships" field in the mutation.
func (m *ResourceMutation) Relationships() (r map[string]interface{}, exists bool) {
	v := m.relationships
	if v == nil {
		return
	}
	return *v, true
}

// OldRelationships returns the old "relationships" field's value of the Resource entity.
// If the Resource object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceMutation) OldRelationships(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRelationships is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRelationships requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRelationships: %w", err)
	}
	return oldValue.Relationships, nil
}

// ClearRelationships clears the value of the "relationships" field.
func (m *ResourceMutation) ClearRelationships() {
	m.relationships = nil
	m.clearedFields[resource.FieldRelationships] = struct{}{}
}

// RelationshipsCleared returns if the "relationships" field was cleared in this mutation.
func (m *ResourceMutation) RelationshipsCleared() bool {
	_, ok := m.clearedFields[resource.FieldRelationships]
	return ok
}

// ResetRelationships resets all changes to the "relationships" field.
func (m *ResourceMutation) ResetRelationships() {
	m.relationships = nil
	delete(m.clearedFields, resource.FieldRelationships)
}

// SetPlatform sets the "platform" field.
func (m *ResourceMutation) SetPlatform(value map[string]interface{}) {
	m.platform = &value
}

// Platform returns the value of the "platform" field in the mutation.
func (m *ResourceMutation) Platform() (r map[string]interface{}, exists bool) {
	v := m.platform
	if v == nil {
		return
	}
	return *v, true
}

// OldPlatform returns the old "platform" field's value of the Resource entity.
// If the Resource object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceMutation) OldPlatform(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPlatform is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPlatform requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPlatform: %w", err)
	}
	return oldValue.Platform, nil
}

// ClearPlatform clears the value of the "platform" field.
func (m *ResourceMutation) ClearPlatform() {
	m.platform = nil
	m.clearedFields[resource.FieldPlatform] = struct{}{}
}

// PlatformCleared returns if the "platform" field was cleared in this mutation.
func (m *ResourceMutation) PlatformCleared() bool {
	_, ok := m.clearedFields[resource.FieldPlatform]
	return ok
}

// ResetPlatform resets all changes to the "platform" field.
func (m *ResourceMutation) ResetPlatform() {
	m.platform = nil
	delete(m.clearedFields, resource.FieldPlatform)
}

// SetSyncStatus sets the "sync_status" field.
func (m *ResourceMutation) SetSyncStatus(rs resource.SyncStatus) {
	m.sync_status = &rs
}

// SyncStatus returns the value of the "sync_status" field in the mutation.
func (m *ResourceMutation) SyncStatus() (r resource.SyncStatus, exists bool) {
	v := m.sync_status
	if v == nil {
		return
	}
	return *v, true
}

// OldSyncStatus returns the old "sync_status" field's value of the Resource entity.
// If the Resource object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceMutation) OldSyncStatus(ctx context.Context) (v resource.SyncStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSyncStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSyncStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSyncStatus: %w", err)
	}
	return oldValue.SyncStatus, nil
}

// ResetSyncStatus resets all changes to the "sync_status" field.
func (m *ResourceMutation) ResetSyncStatus() {
	m.sync_status = nil
}

// SetEnabled sets the "enabled" field.
func (m *ResourceMutation) SetEnabled(b bool) {
	m.enabled = &b
}

// Enabled returns the value of the "enabled" field in the mutation.
func (m *ResourceMutation) Enabled() (r bool, exists bool) {
	v := m.enabled
	if v == nil {
		return
	}
	return *v, true
}

// OldEnabled returns the old "enabled" field's value of the Resource entity.
// If the Resource object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceMutation) OldEnabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnabled: %w", err)
	}
	return oldValue.Enabled, nil
}

// ResetEnabled resets all changes to the "enabled" field.
func (m *ResourceMutation) ResetEnabled() {
	m.enabled = nil
}

// SetManaged sets the "managed" field.
func (m *ResourceMutation) SetManaged(b bool) {
	m.managed = &b
}

// Managed returns the value of the "managed" field in the mutation.
func (m *ResourceMutation) Managed() (r bool, exists bool) {
	v := m.managed
	if v == nil {
		return
	}
	return *v, true
}

// OldManaged returns the old "managed" field's value of the Resource entity.
// If the Resource object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceMutation) OldManaged(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldManaged is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldManaged requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldManaged: %w", err)
	}
	return oldValue.Managed, nil
}

// ResetManaged resets all changes to the "managed" field.
func (m *ResourceMutation) ResetManaged() {
	m.managed = nil
}

// SetVersion sets the "version" field.
func (m *ResourceMutation) SetVersion(i int64) {
	m.version = &i
	m.addversion = nil
}

// Version returns the value of the "version" field in the mutation.
func (m *ResourceMutation) Version() (r int64, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the Resource entity.
// If the Resource object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceMutation) OldVersion(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// AddVersion adds i to the "version" field.
func (m *ResourceMutation) AddVersion(i int64) {
	if m.addversion != nil {
		*m.addversion += i
	} else {
		m.addversion = &i
	}
}

// AddedVersion returns the value that was added to the "version" field in this mutation.
func (m *ResourceMutation) AddedVersion() (r int64, exists bool) {
	v := m.addversion
	if v == nil {
		return
	}
	return *v, true
}

// ResetVersion resets all changes to the "version" field.
func (m *ResourceMutation) ResetVersion() {
	m.version = nil
	m.addversion = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ResourceMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ResourceMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Resource entity.
// If the Resource object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ResourceMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ResourceMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ResourceMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Resource entity.
// If the Resource object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ResourceMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetSyncedAt sets the "synced_at" field.
func (m *ResourceMutation) SetSyncedAt(t time.Time) {
	m.synced_at = &t
}

// SyncedAt returns the value of the "synced_at" field in the mutation.
func (m *ResourceMutation) SyncedAt() (r time.Time, exists bool) {
	v := m.synced_at
	if v == nil {
		return
	}
	return *v, true
}

// OldSyncedAt returns the old "synced_at" field's value of the Resource entity.
// If the Resource object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceMutation) OldSyncedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSyncedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSyncedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSyncedAt: %w", err)
	}
	return oldValue.SyncedAt, nil
}

// ClearSyncedAt clears the value of the "synced_at" field.
func (m *ResourceMutation) ClearSyncedAt() {
	m.synced_at = nil
	m.clearedFields[resource.FieldSyncedAt] = struct{}{}
}

// SyncedAtCleared returns if the "synced_at" field was cleared in this mutation.
func (m *ResourceMutation) SyncedAtCleared() bool {
	_, ok := m.clearedFields[resource.FieldSyncedAt]
	return ok
}

// ResetSyncedAt resets all changes to the "synced_at" field.
func (m *ResourceMutation) ResetSyncedAt() {
	m.synced_at = nil
	delete(m.clearedFields, resource.FieldSyncedAt)
}

// SetRouterModifiedAt sets the "router_modified_at" field.
func (m *ResourceMutation) SetRouterModifiedAt(t time.Time) {
	m.router_modified_at = &t
}

// RouterModifiedAt returns the value of the "router_modified_at" field in the mutation.
func (m *ResourceMutation) RouterModifiedAt() (r time.Time, exists bool) {
	v := m.router_modified_at
	if v == nil {
		return
	}
	return *v, true
}

// OldRouterModifiedAt returns the old "router_modified_at" field's value of the Resource entity.
// If the Resource object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceMutation) OldRouterModifiedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRouterModifiedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRouterModifiedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRouterModifiedAt: %w", err)
	}
	return oldValue.RouterModifiedAt, nil
}

// ClearRouterModifiedAt clears the value of the "router_modified_at" field.
func (m *ResourceMutation) ClearRouterModifiedAt() {
	m.router_modified_at = nil
	m.clearedFields[resource.FieldRouterModifiedAt] = struct{}{}
}

// RouterModifiedAtCleared returns if the "router_modified_at" field was cleared in this mutation.
func (m *ResourceMutation) RouterModifiedAtCleared() bool {
	_, ok := m.clearedFields[resource.FieldRouterModifiedAt]
	return ok
}

// ResetRouterModifiedAt resets all changes to the "router_modified_at" field.
func (m *ResourceMutation) ResetRouterModifiedAt() {
	m.router_modified_at = nil
	delete(m.clearedFields, resource.FieldRouterModifiedAt)
}

// AddEventIDs adds the "events" edge to the ResourceEvent entity by ids.
func (m *ResourceMutation) AddEventIDs(ids ...string) {
	if m.events == nil {
		m.events = make(map[string]struct{})
	}
	for i := range ids {
		m.events[ids[i]] = struct{}{}
	}
}

// ClearEvents clears the "events" edge to the ResourceEvent entity.
func (m *ResourceMutation) ClearEvents() {
	m.clearedevents = true
}

// EventsCleared reports if the "events" edge to the ResourceEvent entity was cleared.
func (m *ResourceMutation) EventsCleared() bool {
	return m.clearedevents
}

// RemoveEventIDs removes the "events" edge to the ResourceEvent entity by IDs.
func (m *ResourceMutation) RemoveEventIDs(ids ...string) {
	if m.removedevents == nil {
		m.removedevents = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.events, ids[i])
		m.removedevents[ids[i]] = struct{}{}
	}
}

// RemovedEvents returns the removed IDs of the "events" edge to the ResourceEvent entity.
func (m *ResourceMutation) RemovedEventsIDs() (ids []string) {
	for id := range m.removedevents {
		ids = append(ids, id)
	}
	return
}

// EventsIDs returns the "events" edge IDs in the mutation.
func (m *ResourceMutation) EventsIDs() (ids []string) {
	for id := range m.events {
		ids = append(ids, id)
	}
	return
}

// ResetEvents resets all changes to the "events" edge.
func (m *ResourceMutation) ResetEvents() {
	m.events = nil
	m.clearedevents = false
	m.removedevents = nil
}

// Where appends a list predicates to the ResourceMutation builder.
func (m *ResourceMutation) Where(ps ...predicate.Resource) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ResourceMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ResourceMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Resource, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ResourceMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ResourceMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Resource).
func (m *ResourceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ResourceMutation) Fields() []string {
	fields := make([]string, 0, 19)
	if m._type != nil {
		fields = append(fields, resource.FieldType)
	}
	if m.category != nil {
		fields = append(fields, resource.FieldCategory)
	}
	if m.ros_id != nil {
		fields = append(fields, resource.FieldRosID)
	}
	if m.configuration != nil {
		fields = append(fields, resource.FieldConfiguration)
	}
	if m.validation != nil {
		fields = append(fields, resource.FieldValidation)
	}
	if m.deployment != nil {
		fields = append(fields, resource.FieldDeployment)
	}
	if m.runtime != nil {
		fields = append(fields, resource.FieldRuntime)
	}
	if m.telemetry != nil {
		fields = append(fields, resource.FieldTelemetry)
	}
	if m.metadata != nil {
		fields = append(fields, resource.FieldMetadata)
	}
	if m.relationships != nil {
		fields = append(fields, resource.FieldRelationships)
	}
	if m.platform != nil {
		fields = append(fields, resource.FieldPlatform)
	}
	if m.sync_status != nil {
		fields = append(fields, resource.FieldSyncStatus)
	}
	if m.enabled != nil {
		fields = append(fields, resource.FieldEnabled)
	}
	if m.managed != nil {
		fields = append(fields, resource.FieldManaged)
	}
	if m.version != nil {
		fields = append(fields, resource.FieldVersion)
	}
	if m.created_at != nil {
		fields = append(fields, resource.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, resource.FieldUpdatedAt)
	}
	if m.synced_at != nil {
		fields = append(fields, resource.FieldSyncedAt)
	}
	if m.router_modified_at != nil {
		fields = append(fields, resource.FieldRouterModifiedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ResourceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case resource.FieldType:
		return m.GetType()
	case resource.FieldCategory:
		return m.Category()
	case resource.FieldRosID:
		return m.RosID()
	case resource.FieldConfiguration:
		return m.Configuration()
	case resource.FieldValidation:
		return m.Validation()
	case resource.FieldDeployment:
		return m.Deployment()
	case resource.FieldRuntime:
		return m.Runtime()
	case resource.FieldTelemetry:
		return m.Telemetry()
	case resource.FieldMetadata:
		return m.Metadata()
	case resource.FieldRelationships:
		return m.Relationships()
	case resource.FieldPlatform:
		return m.Platform()
	case resource.FieldSyncStatus:
		return m.SyncStatus()
	case resource.FieldEnabled:
		return m.Enabled()
	case resource.FieldManaged:
		return m.Managed()
	case resource.FieldVersion:
		return m.Version()
	case resource.FieldCreatedAt:
		return m.CreatedAt()
	case resource.FieldUpdatedAt:
		return m.UpdatedAt()
	case resource.FieldSyncedAt:
		return m.SyncedAt()
	case resource.FieldRouterModifiedAt:
		return m.RouterModifiedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ResourceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case resource.FieldType:
		return m.OldType(ctx)
	case resource.FieldCategory:
		return m.OldCategory(ctx)
	case resource.FieldRosID:
		return m.OldRosID(ctx)
	case resource.FieldConfiguration:
		return m.OldConfiguration(ctx)
	case resource.FieldValidation:
		return m.OldValidation(ctx)
	case resource.FieldDeployment:
		return m.OldDeployment(ctx)
	case resource.FieldRuntime:
		return m.OldRuntime(ctx)
	case resource.FieldTelemetry:
		return m.OldTelemetry(ctx)
	case resource.FieldMetadata:
		return m.OldMetadata(ctx)
	case resource.FieldRelationships:
		return m.OldRelationships(ctx)
	case resource.FieldPlatform:
		return m.OldPlatform(ctx)
	case resource.FieldSyncStatus:
		return m.OldSyncStatus(ctx)
	case resource.FieldEnabled:
		return m.OldEnabled(ctx)
	case resource.FieldManaged:
		return m.OldManaged(ctx)
	case resource.FieldVersion:
		return m.OldVersion(ctx)
	case resource.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case resource.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case resource.FieldSyncedAt:
		return m.OldSyncedAt(ctx)
	case resource.FieldRouterModifiedAt:
		return m.OldRouterModifiedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Resource field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ResourceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case resource.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case resource.FieldCategory:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategory(v)
		return nil
	case resource.FieldRosID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRosID(v)
		return nil
	case resource.FieldConfiguration:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConfiguration(v)
		return nil
	case resource.FieldValidation:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValidation(v)
		return nil
	case resource.FieldDeployment:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeployment(v)
		return nil
	case resource.FieldRuntime:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRuntime(v)
		return nil
	case resource.FieldTelemetry:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTelemetry(v)
		return nil
	case resource.FieldMetadata:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	case resource.FieldRelationships:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRelationships(v)
		return nil
	case resource.FieldPlatform:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPlatform(v)
		return nil
	case resource.FieldSyncStatus:
		v, ok := value.(resource.SyncStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSyncStatus(v)
		return nil
	case resource.FieldEnabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnabled(v)
		return nil
	case resource.FieldManaged:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetManaged(v)
		return nil
	case resource.FieldVersion:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case resource.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case resource.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case resource.FieldSyncedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSyncedAt(v)
		return nil
	case resource.FieldRouterModifiedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRouterModifiedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Resource field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ResourceMutation) AddedFields() []string {
	var fields []string
	if m.addversion != nil {
		fields = append(fields, resource.FieldVersion)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ResourceMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case resource.FieldVersion:
		return m.AddedVersion()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ResourceMutation) AddField(name string, value ent.Value) error {
	switch name {
	case resource.FieldVersion:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVersion(v)
		return nil
	}
	return fmt.Errorf("unknown Resource numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ResourceMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(resource.FieldRosID) {
		fields = append(fields, resource.FieldRosID)
	}
	if m.FieldCleared(resource.FieldValidation) {
		fields = append(fields, resource.FieldValidation)
	}
	if m.FieldCleared(resource.FieldDeployment) {
		fields = append(fields, resource.FieldDeployment)
	}
	if m.FieldCleared(resource.FieldRuntime) {
		fields = append(fields, resource.FieldRuntime)
	}
	if m.FieldCleared(resource.FieldTelemetry) {
		fields = append(fields, resource.FieldTelemetry)
	}
	if m.FieldCleared(resource.FieldRelationships) {
		fields = append(fields, resource.FieldRelationships)
	}
	if m.FieldCleared(resource.FieldPlatform) {
		fields = append(fields, resource.FieldPlatform)
	}
	if m.FieldCleared(resource.FieldSyncedAt) {
		fields = append(fields, resource.FieldSyncedAt)
	}
	if m.FieldCleared(resource.FieldRouterModifiedAt) {
		fields = append(fields, resource.FieldRouterModifiedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ResourceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ResourceMutation) ClearField(name string) error {
	switch name {
	case resource.FieldRosID:
		m.ClearRosID()
		return nil
	case resource.FieldValidation:
		m.ClearValidation()
		return nil
	case resource.FieldDeployment:
		m.ClearDeployment()
		return nil
	case resource.FieldRuntime:
		m.ClearRuntime()
		return nil
	case resource.FieldTelemetry:
		m.ClearTelemetry()
		return nil
	case resource.FieldRelationships:
		m.ClearRelationships()
		return nil
	case resource.FieldPlatform:
		m.ClearPlatform()
		return nil
	case resource.FieldSyncedAt:
		m.ClearSyncedAt()
		return nil
	case resource.FieldRouterModifiedAt:
		m.ClearRouterModifiedAt()
		return nil
	}
	return fmt.Errorf("unknown Resource nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ResourceMutation) ResetField(name string) error {
	switch name {
	case resource.FieldType:
		m.ResetType()
		return nil
	case resource.FieldCategory:
		m.ResetCategory()
		return nil
	case resource.FieldRosID:
		m.ResetRosID()
		return nil
	case resource.FieldConfiguration:
		m.ResetConfiguration()
		return nil
	case resource.FieldValidation:
		m.ResetValidation()
		return nil
	case resource.FieldDeployment:
		m.ResetDeployment()
		return nil
	case resource.FieldRuntime:
		m.ResetRuntime()
		return nil
	case resource.FieldTelemetry:
		m.ResetTelemetry()
		return nil
	case resource.FieldMetadata:
		m.ResetMetadata()
		return nil
	case resource.FieldRelationships:
		m.ResetRelationships()
		return nil
	case resource.FieldPlatform:
		m.ResetPlatform()
		return nil
	case resource.FieldSyncStatus:
		m.ResetSyncStatus()
		return nil
	case resource.FieldEnabled:
		m.ResetEnabled()
		return nil
	case resource.FieldManaged:
		m.ResetManaged()
		return nil
	case resource.FieldVersion:
		m.ResetVersion()
		return nil
	case resource.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case resource.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case resource.FieldSyncedAt:
		m.ResetSyncedAt()
		return nil
	case resource.FieldRouterModifiedAt:
		m.ResetRouterModifiedAt()
		return nil
	}
	return fmt.Errorf("unknown Resource field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ResourceMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.events != nil {
		edges = append(edges, resource.EdgeEvents)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ResourceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case resource.EdgeEvents:
		ids := make([]ent.Value, 0, len(m.events))
		for id := range m.events {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ResourceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedevents != nil {
		edges = append(edges, resource.EdgeEvents)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ResourceMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case resource.EdgeEvents:
		ids := make([]ent.Value, 0, len(m.removedevents))
		for id := range m.removedevents {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ResourceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedevents {
		edges = append(edges, resource.EdgeEvents)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ResourceMutation) EdgeCleared(name string) bool {
	switch name {
	case resource.EdgeEvents:
		return m.clearedevents
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ResourceMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Resource unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ResourceMutation) ResetEdge(name string) error {
	switch name {
	case resource.EdgeEvents:
		m.ResetEvents()
		return nil
	}
	return fmt.Errorf("unknown Resource edge %s", name)
}

// ResourceEventMutation represents an operation that mutates the ResourceEvent nodes in the graph.
type ResourceEventMutation struct {
	config
	op              Op
	typ             string
	id              *string
	event_type      *resourceevent.EventType
	actor           *string
	previous_state  *map[string]interface{}
	new_state       *map[string]interface{}
	diff            *map[string]interface{}
	metadata        *map[string]interface{}
	error_message   *string
	source          *resourceevent.Source
	reversible      *bool
	created_at      *time.Time
	clearedFields   map[string]struct{}
	resource        *string
	clearedresource bool
	done            bool
	oldValue        func(context.Context) (*ResourceEvent, error)
	predicates      []predicate.ResourceEvent
}

var _ ent.Mutation = (*ResourceEventMutation)(nil)

// resourceeventOption allows management of the mutation configuration using functional options.
type resourceeventOption func(*ResourceEventMutation)

// newResourceEventMutation creates new mutation for the ResourceEvent entity.
func newResourceEventMutation(c config, op Op, opts ...resourceeventOption) *ResourceEventMutation {
	m := &ResourceEventMutation{
		config:        c,
		op:            op,
		typ:           TypeResourceEvent,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withResourceEventID sets the ID field of the mutation.
func withResourceEventID(id string) resourceeventOption {
	return func(m *ResourceEventMutation) {
		var (
			err   error
			once  sync.Once
			value *ResourceEvent
		)
		m.oldValue = func(ctx context.Context) (*ResourceEvent, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ResourceEvent.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withResourceEvent sets the old ResourceEvent of the mutation.
func withResourceEvent(node *ResourceEvent) resourceeventOption {
	return func(m *ResourceEventMutation) {
		m.oldValue = func(context.Context) (*ResourceEvent, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ResourceEventMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ResourceEventMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ResourceEvent entities.
func (m *ResourceEventMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ResourceEventMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ResourceEventMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ResourceEvent.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetResourceID sets the "resource_id" field.
func (m *ResourceEventMutation) SetResourceID(s string) {
	m.resource = &s
}

// ResourceID returns the value of the "resource_id" field in the mutation.
func (m *ResourceEventMutation) ResourceID() (r string, exists bool) {
	v := m.resource
	if v == nil {
		return
	}
	return *v, true
}

// OldResourceID returns the old "resource_id" field's value of the ResourceEvent entity.
// If the ResourceEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceEventMutation) OldResourceID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResourceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResourceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResourceID: %w", err)
	}
	return oldValue.ResourceID, nil
}

// ResetResourceID resets all changes to the "resource_id" field.
func (m *ResourceEventMutation) ResetResourceID() {
	m.resource = nil
}

// SetEventType sets the "event_type" field.
func (m *ResourceEventMutation) SetEventType(rt resourceevent.EventType) {
	m.event_type = &rt
}

// EventType returns the value of the "event_type" field in the mutation.
func (m *ResourceEventMutation) EventType() (r resourceevent.EventType, exists bool) {
	v := m.event_type
	if v == nil {
		return
	}
	return *v, true
}

// OldEventType returns the old "event_type" field's value of the ResourceEvent entity.
// If the ResourceEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceEventMutation) OldEventType(ctx context.Context) (v resourceevent.EventType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEventType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEventType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEventType: %w", err)
	}
	return oldValue.EventType, nil
}

// ResetEventType resets all changes to the "event_type" field.
func (m *ResourceEventMutation) ResetEventType() {
	m.event_type = nil
}

// SetActor sets the "actor" field.
func (m *ResourceEventMutation) SetActor(s string) {
	m.actor = &s
}

// Actor returns the value of the "actor" field in the mutation.
func (m *ResourceEventMutation) Actor() (r string, exists bool) {
	v := m.actor
	if v == nil {
		return
	}
	return *v, true
}

// OldActor returns the old "actor" field's value of the ResourceEvent entity.
// If the ResourceEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceEventMutation) OldActor(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActor: %w", err)
	}
	return oldValue.Actor, nil
}

// ResetActor resets all changes to the "actor" field.
func (m *ResourceEventMutation) ResetActor() {
	m.actor = nil
}

// SetPreviousState sets the "previous_state" field.
func (m *ResourceEventMutation) SetPreviousState(value map[string]interface{}) {
	m.previous_state = &value
}

// PreviousState returns the value of the "previous_state" field in the mutation.
func (m *ResourceEventMutation) PreviousState() (r map[string]interface{}, exists bool) {
	v := m.previous_state
	if v == nil {
		return
	}
	return *v, true
}

// OldPreviousState returns the old "previous_state" field's value of the ResourceEvent entity.
// If the ResourceEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceEventMutation) OldPreviousState(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPreviousState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPreviousState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPreviousState: %w", err)
	}
	return oldValue.PreviousState, nil
}

// ClearPreviousState clears the value of the "previous_state" field.
func (m *ResourceEventMutation) ClearPreviousState() {
	m.previous_state = nil
	m.clearedFields[resourceevent.FieldPreviousState] = struct{}{}
}

// PreviousStateCleared returns if the "previous_state" field was cleared in this mutation.
func (m *ResourceEventMutation) PreviousStateCleared() bool {
	_, ok := m.clearedFields[resourceevent.FieldPreviousState]
	return ok
}

// ResetPreviousState resets all changes to the "previous_state" field.
func (m *ResourceEventMutation) ResetPreviousState() {
	m.previous_state = nil
	delete(m.clearedFields, resourceevent.FieldPreviousState)
}

// SetNewState sets the "new_state" field.
func (m *ResourceEventMutation) SetNewState(value map[string]interface{}) {
	m.new_state = &value
}

// NewState returns the value of the "new_state" field in the mutation.
func (m *ResourceEventMutation) NewState() (r map[string]interface{}, exists bool) {
	v := m.new_state
	if v == nil {
		return
	}
	return *v, true
}

// OldNewState returns the old "new_state" field's value of the ResourceEvent entity.
// If the ResourceEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceEventMutation) OldNewState(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNewState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNewState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNewState: %w", err)
	}
	return oldValue.NewState, nil
}

// ClearNewState clears the value of the "new_state" field.
func (m *ResourceEventMutation) ClearNewState() {
	m.new_state = nil
	m.clearedFields[resourceevent.FieldNewState] = struct{}{}
}

// NewStateCleared returns if the "new_state" field was cleared in this mutation.
func (m *ResourceEventMutation) NewStateCleared() bool {
	_, ok := m.clearedFields[resourceevent.FieldNewState]
	return ok
}

// ResetNewState resets all changes to the "new_state" field.
func (m *ResourceEventMutation) ResetNewState() {
	m.new_state = nil
	delete(m.clearedFields, resourceevent.FieldNewState)
}

// SetDiff sets the "diff" field.
func (m *ResourceEventMutation) SetDiff(value map[string]interface{}) {
	m.diff = &value
}

// Diff returns the value of the "diff" field in the mutation.
func (m *ResourceEventMutation) Diff() (r map[string]interface{}, exists bool) {
	v := m.diff
	if v == nil {
		return
	}
	return *v, true
}

// OldDiff returns the old "diff" field's value of the ResourceEvent entity.
// If the ResourceEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceEventMutation) OldDiff(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDiff is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDiff requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDiff: %w", err)
	}
	return oldValue.Diff, nil
}

// ClearDiff clears the value of the "diff" field.
func (m *ResourceEventMutation) ClearDiff() {
	m.diff = nil
	m.clearedFields[resourceevent.FieldDiff] = struct{}{}
}

// DiffCleared returns if the "diff" field was cleared in this mutation.
func (m *ResourceEventMutation) DiffCleared() bool {
	_, ok := m.clearedFields[resourceevent.FieldDiff]
	return ok
}

// ResetDiff resets all changes to the "diff" field.
func (m *ResourceEventMutation) ResetDiff() {
	m.diff = nil
	delete(m.clearedFields, resourceevent.FieldDiff)
}

// SetMetadata sets the "metadata" field.
func (m *ResourceEventMutation) SetMetadata(value map[string]interface{}) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *ResourceEventMutation) Metadata() (r map[string]interface{}, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the ResourceEvent entity.
// If the ResourceEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceEventMutation) OldMetadata(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *ResourceEventMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[resourceevent.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *ResourceEventMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[resourceevent.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *ResourceEventMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, resourceevent.FieldMetadata)
}

// SetErrorMessage sets the "error_message" field.
func (m *ResourceEventMutation) SetErrorMessage(s string) {
	m.error_message = &s
}

// ErrorMessage returns the value of the "error_message" field in the mutation.
func (m *ResourceEventMutation) ErrorMessage() (r string, exists bool) {
	v := m.error_message
	if v == nil {
		return
	}
	return *v, true
}

// OldErrorMessage returns the old "error_message" field's value of the ResourceEvent entity.
// If the ResourceEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceEventMutation) OldErrorMessage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldErrorMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldErrorMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldErrorMessage: %w", err)
	}
	return oldValue.ErrorMessage, nil
}

// ClearErrorMessage clears the value of the "error_message" field.
func (m *ResourceEventMutation) ClearErrorMessage() {
	m.error_message = nil
	m.clearedFields[resourceevent.FieldErrorMessage] = struct{}{}
}

// ErrorMessageCleared returns if the "error_message" field was cleared in this mutation.
func (m *ResourceEventMutation) ErrorMessageCleared() bool {
	_, ok := m.clearedFields[resourceevent.FieldErrorMessage]
	return ok
}

// ResetErrorMessage resets all changes to the "error_message" field.
func (m *ResourceEventMutation) ResetErrorMessage() {
	m.error_message = nil
	delete(m.clearedFields, resourceevent.FieldErrorMessage)
}

// SetSource sets the "source" field.
func (m *ResourceEventMutation) SetSource(r resourceevent.Source) {
	m.source = &r
}

// Source returns the value of the "source" field in the mutation.
func (m *ResourceEventMutation) Source() (r resourceevent.Source, exists bool) {
	v := m.source
	if v == nil {
		return
	}
	return *v, true
}

// OldSource returns the old "source" field's value of the ResourceEvent entity.
// If the ResourceEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceEventMutation) OldSource(ctx context.Context) (v resourceevent.Source, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSource is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSource requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSource: %w", err)
	}
	return oldValue.Source, nil
}

// ResetSource resets all changes to the "source" field.
func (m *ResourceEventMutation) ResetSource() {
	m.source = nil
}

// SetReversible sets the "reversible" field.
func (m *ResourceEventMutation) SetReversible(b bool) {
	m.reversible = &b
}

// Reversible returns the value of the "reversible" field in the mutation.
func (m *ResourceEventMutation) Reversible() (r bool, exists bool) {
	v := m.reversible
	if v == nil {
		return
	}
	return *v, true
}

// OldReversible returns the old "reversible" field's value of the ResourceEvent entity.
// If the ResourceEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceEventMutation) OldReversible(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReversible is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReversible requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReversible: %w", err)
	}
	return oldValue.Reversible, nil
}

// ResetReversible resets all changes to the "reversible" field.
func (m *ResourceEventMutation) ResetReversible() {
	m.reversible = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ResourceEventMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ResourceEventMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ResourceEvent entity.
// If the ResourceEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceEventMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ResourceEventMutation) ResetCreatedAt() {
	m.created_at = nil
}

// ClearResource clears the "resource" edge to the Resource entity.
func (m *ResourceEventMutation) ClearResource() {
	m.clearedresource = true
	m.clearedFields[resourceevent.FieldResourceID] = struct{}{}
}

// ResourceCleared reports if the "resource" edge to the Resource entity was cleared.
func (m *ResourceEventMutation) ResourceCleared() bool {
	return m.clearedresource
}

// ResourceIDs returns the "resource" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ResourceID instead. It exists only for internal usage by the builders.
func (m *ResourceEventMutation) ResourceIDs() (ids []string) {
	if id := m.resource; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetResource resets all changes to the "resource" edge.
func (m *ResourceEventMutation) ResetResource() {
	m.resource = nil
	m.clearedresource = false
}

// Where appends a list predicates to the ResourceEventMutation builder.
func (m *ResourceEventMutation) Where(ps ...predicate.ResourceEvent) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ResourceEventMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ResourceEventMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ResourceEvent, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ResourceEventMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ResourceEventMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ResourceEvent).
func (m *ResourceEventMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ResourceEventMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.resource != nil {
		fields = append(fields, resourceevent.FieldResourceID)
	}
	if m.event_type != nil {
		fields = append(fields, resourceevent.FieldEventType)
	}
	if m.actor != nil {
		fields = append(fields, resourceevent.FieldActor)
	}
	if m.previous_state != nil {
		fields = append(fields, resourceevent.FieldPreviousState)
	}
	if m.new_state != nil {
		fields = append(fields, resourceevent.FieldNewState)
	}
	if m.diff != nil {
		fields = append(fields, resourceevent.FieldDiff)
	}
	if m.metadata != nil {
		fields = append(fields, resourceevent.FieldMetadata)
	}
	if m.error_message != nil {
		fields = append(fields, resourceevent.FieldErrorMessage)
	}
	if m.source != nil {
		fields = append(fields, resourceevent.FieldSource)
	}
	if m.reversible != nil {
		fields = append(fields, resourceevent.FieldReversible)
	}
	if m.created_at != nil {
		fields = append(fields, resourceevent.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ResourceEventMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case resourceevent.FieldResourceID:
		return m.ResourceID()
	case resourceevent.FieldEventType:
		return m.EventType()
	case resourceevent.FieldActor:
		return m.Actor()
	case resourceevent.FieldPreviousState:
		return m.PreviousState()
	case resourceevent.FieldNewState:
		return m.NewState()
	case resourceevent.FieldDiff:
		return m.Diff()
	case resourceevent.FieldMetadata:
		return m.Metadata()
	case resourceevent.FieldErrorMessage:
		return m.ErrorMessage()
	case resourceevent.FieldSource:
		return m.Source()
	case resourceevent.FieldReversible:
		return m.Reversible()
	case resourceevent.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ResourceEventMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case resourceevent.FieldResourceID:
		return m.OldResourceID(ctx)
	case resourceevent.FieldEventType:
		return m.OldEventType(ctx)
	case resourceevent.FieldActor:
		return m.OldActor(ctx)
	case resourceevent.FieldPreviousState:
		return m.OldPreviousState(ctx)
	case resourceevent.FieldNewState:
		return m.OldNewState(ctx)
	case resourceevent.FieldDiff:
		return m.OldDiff(ctx)
	case resourceevent.FieldMetadata:
		return m.OldMetadata(ctx)
	case resourceevent.FieldErrorMessage:
		return m.OldErrorMessage(ctx)
	case resourceevent.FieldSource:
		return m.OldSource(ctx)
	case resourceevent.FieldReversible:
		return m.OldReversible(ctx)
	case resourceevent.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown ResourceEvent field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ResourceEventMutation) SetField(name string, value ent.Value) error {
	switch name {
	case resourceevent.FieldResourceID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResourceID(v)
		return nil
	case resourceevent.FieldEventType:
		v, ok := value.(resourceevent.EventType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEventType(v)
		return nil
	case resourceevent.FieldActor:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActor(v)
		return nil
	case resourceevent.FieldPreviousState:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPreviousState(v)
		return nil
	case resourceevent.FieldNewState:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNewState(v)
		return nil
	case resourceevent.FieldDiff:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDiff(v)
		return nil
	case resourceevent.FieldMetadata:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	case resourceevent.FieldErrorMessage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetErrorMessage(v)
		return nil
	case resourceevent.FieldSource:
		v, ok := value.(resourceevent.Source)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSource(v)
		return nil
	case resourceevent.FieldReversible:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReversible(v)
		return nil
	case resourceevent.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown ResourceEvent field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ResourceEventMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ResourceEventMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ResourceEventMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ResourceEvent numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ResourceEventMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(resourceevent.FieldPreviousState) {
		fields = append(fields, resourceevent.FieldPreviousState)
	}
	if m.FieldCleared(resourceevent.FieldNewState) {
		fields = append(fields, resourceevent.FieldNewState)
	}
	if m.FieldCleared(resourceevent.FieldDiff) {
		fields = append(fields, resourceevent.FieldDiff)
	}
	if m.FieldCleared(resourceevent.FieldMetadata) {
		fields = append(fields, resourceevent.FieldMetadata)
	}
	if m.FieldCleared(resourceevent.FieldErrorMessage) {
		fields = append(fields, resourceevent.FieldErrorMessage)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ResourceEventMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ResourceEventMutation) ClearField(name string) error {
	switch name {
	case resourceevent.FieldPreviousState:
		m.ClearPreviousState()
		return nil
	case resourceevent.FieldNewState:
		m.ClearNewState()
		return nil
	case resourceevent.FieldDiff:
		m.ClearDiff()
		return nil
	case resourceevent.FieldMetadata:
		m.ClearMetadata()
		return nil
	case resourceevent.FieldErrorMessage:
		m.ClearErrorMessage()
		return nil
	}
	return fmt.Errorf("unknown ResourceEvent nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ResourceEventMutation) ResetField(name string) error {
	switch name {
	case resourceevent.FieldResourceID:
		m.ResetResourceID()
		return nil
	case resourceevent.FieldEventType:
		m.ResetEventType()
		return nil
	case resourceevent.FieldActor:
		m.ResetActor()
		return nil
	case resourceevent.FieldPreviousState:
		m.ResetPreviousState()
		return nil
	case resourceevent.FieldNewState:
		m.ResetNewState()
		return nil
	case resourceevent.FieldDiff:
		m.ResetDiff()
		return nil
	case resourceevent.FieldMetadata:
		m.ResetMetadata()
		return nil
	case resourceevent.FieldErrorMessage:
		m.ResetErrorMessage()
		return nil
	case resourceevent.FieldSource:
		m.ResetSource()
		return nil
	case resourceevent.FieldReversible:
		m.ResetReversible()
		return nil
	case resourceevent.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown ResourceEvent field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ResourceEventMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.resource != nil {
		edges = append(edges, resourceevent.EdgeResource)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ResourceEventMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case resourceevent.EdgeResource:
		if id := m.resource; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ResourceEventMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ResourceEventMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ResourceEventMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedresource {
		edges = append(edges, resourceevent.EdgeResource)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ResourceEventMutation) EdgeCleared(name string) bool {
	switch name {
	case resourceevent.EdgeResource:
		return m.clearedresource
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ResourceEventMutation) ClearEdge(name string) error {
	switch name {
	case resourceevent.EdgeResource:
		m.ClearResource()
		return nil
	}
	return fmt.Errorf("unknown ResourceEvent unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ResourceEventMutation) ResetEdge(name string) error {
	switch name {
	case resourceevent.EdgeResource:
		m.ResetResource()
		return nil
	}
	return fmt.Errorf("unknown ResourceEvent edge %s", name)
}

// RouterMutation represents an operation that mutates the Router nodes in the graph.
type RouterMutation struct {
	config
	op                          Op
	typ                         string
	id                          *string
	name                        *string
	host                        *string
	port                        *int
	addport                     *int
	platform                    *router.Platform
	model                       *string
	version                     *string
	status                      *router.Status
	last_seen                   *time.Time
	created_at                  *time.Time
	updated_at                  *time.Time
	clearedFields               map[string]struct{}
	secrets                     *string
	clearedsecrets              bool
	port_knock_sequences        map[string]struct{}
	removedport_knock_sequences map[string]struct{}
	clearedport_knock_sequences bool
	service_instances           map[string]struct{}
	removedservice_instances    map[string]struct{}
	clearedservice_instances    bool
	port_allocations            map[string]struct{}
	removedport_allocations     map[string]struct{}
	clearedport_allocations     bool
	vlan_allocations            map[string]struct{}
	removedvlan_allocations     map[string]struct{}
	clearedvlan_allocations     bool
	device_routings             map[string]struct{}
	removeddevice_routings      map[string]struct{}
	cleareddevice_routings      bool
	routing_chains              map[string]struct{}
	removedrouting_chains       map[string]struct{}
	clearedrouting_chains       bool
	service_templates           map[string]struct{}
	removedservice_templates    map[string]struct{}
	clearedservice_templates    bool
	done                        bool
	oldValue                    func(context.Context) (*Router, error)
	predicates                  []predicate.Router
}

var _ ent.Mutation = (*RouterMutation)(nil)

// routerOption allows management of the mutation configuration using functional options.
type routerOption func(*RouterMutation)

// newRouterMutation creates new mutation for the Router entity.
func newRouterMutation(c config, op Op, opts ...routerOption) *RouterMutation {
	m := &RouterMutation{
		config:        c,
		op:            op,
		typ:           TypeRouter,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRouterID sets the ID field of the mutation.
func withRouterID(id string) routerOption {
	return func(m *RouterMutation) {
		var (
			err   error
			once  sync.Once
			value *Router
		)
		m.oldValue = func(ctx context.Context) (*Router, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Router.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRouter sets the old Router of the mutation.
func withRouter(node *Router) routerOption {
	return func(m *RouterMutation) {
		m.oldValue = func(context.Context) (*Router, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RouterMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RouterMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Router entities.
func (m *RouterMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RouterMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RouterMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Router.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *RouterMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *RouterMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Router entity.
// If the Router object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RouterMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *RouterMutation) ResetName() {
	m.name = nil
}

// SetHost sets the "host" field.
func (m *RouterMutation) SetHost(s string) {
	m.host = &s
}

// Host returns the value of the "host" field in the mutation.
func (m *RouterMutation) Host() (r string, exists bool) {
	v := m.host
	if v == nil {
		return
	}
	return *v, true
}

// OldHost returns the old "host" field's value of the Router entity.
// If the Router object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RouterMutation) OldHost(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHost is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHost requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHost: %w", err)
	}
	return oldValue.Host, nil
}

// ResetHost resets all changes to the "host" field.
func (m *RouterMutation) ResetHost() {
	m.host = nil
}

// SetPort sets the "port" field.
func (m *RouterMutation) SetPort(i int) {
	m.port = &i
	m.addport = nil
}

// Port returns the value of the "port" field in the mutation.
func (m *RouterMutation) Port() (r int, exists bool) {
	v := m.port
	if v == nil {
		return
	}
	return *v, true
}

// OldPort returns the old "port" field's value of the Router entity.
// If the Router object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RouterMutation) OldPort(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPort is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPort requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPort: %w", err)
	}
	return oldValue.Port, nil
}

// AddPort adds i to the "port" field.
func (m *RouterMutation) AddPort(i int) {
	if m.addport != nil {
		*m.addport += i
	} else {
		m.addport = &i
	}
}

// AddedPort returns the value that was added to the "port" field in this mutation.
func (m *RouterMutation) AddedPort() (r int, exists bool) {
	v := m.addport
	if v == nil {
		return
	}
	return *v, true
}

// ResetPort resets all changes to the "port" field.
func (m *RouterMutation) ResetPort() {
	m.port = nil
	m.addport = nil
}

// SetPlatform sets the "platform" field.
func (m *RouterMutation) SetPlatform(r router.Platform) {
	m.platform = &r
}

// Platform returns the value of the "platform" field in the mutation.
func (m *RouterMutation) Platform() (r router.Platform, exists bool) {
	v := m.platform
	if v == nil {
		return
	}
	return *v, true
}

// OldPlatform returns the old "platform" field's value of the Router entity.
// If the Router object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RouterMutation) OldPlatform(ctx context.Context) (v router.Platform, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPlatform is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPlatform requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPlatform: %w", err)
	}
	return oldValue.Platform, nil
}

// ResetPlatform resets all changes to the "platform" field.
func (m *RouterMutation) ResetPlatform() {
	m.platform = nil
}

// SetModel sets the "model" field.
func (m *RouterMutation) SetModel(s string) {
	m.model = &s
}

// Model returns the value of the "model" field in the mutation.
func (m *RouterMutation) Model() (r string, exists bool) {
	v := m.model
	if v == nil {
		return
	}
	return *v, true
}

// OldModel returns the old "model" field's value of the Router entity.
// If the Router object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RouterMutation) OldModel(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldModel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldModel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModel: %w", err)
	}
	return oldValue.Model, nil
}

// ClearModel clears the value of the "model" field.
func (m *RouterMutation) ClearModel() {
	m.model = nil
	m.clearedFields[router.FieldModel] = struct{}{}
}

// ModelCleared returns if the "model" field was cleared in this mutation.
func (m *RouterMutation) ModelCleared() bool {
	_, ok := m.clearedFields[router.FieldModel]
	return ok
}

// ResetModel resets all changes to the "model" field.
func (m *RouterMutation) ResetModel() {
	m.model = nil
	delete(m.clearedFields, router.FieldModel)
}

// SetVersion sets the "version" field.
func (m *RouterMutation) SetVersion(s string) {
	m.version = &s
}

// Version returns the value of the "version" field in the mutation.
func (m *RouterMutation) Version() (r string, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the Router entity.
// If the Router object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RouterMutation) OldVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// ClearVersion clears the value of the "version" field.
func (m *RouterMutation) ClearVersion() {
	m.version = nil
	m.clearedFields[router.FieldVersion] = struct{}{}
}

// VersionCleared returns if the "version" field was cleared in this mutation.
func (m *RouterMutation) VersionCleared() bool {
	_, ok := m.clearedFields[router.FieldVersion]
	return ok
}

// ResetVersion resets all changes to the "version" field.
func (m *RouterMutation) ResetVersion() {
	m.version = nil
	delete(m.clearedFields, router.FieldVersion)
}

// SetStatus sets the "status" field.
func (m *RouterMutation) SetStatus(r router.Status) {
	m.status = &r
}

// Status returns the value of the "status" field in the mutation.
func (m *RouterMutation) Status() (r router.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Router entity.
// If the Router object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RouterMutation) OldStatus(ctx context.Context) (v router.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *RouterMutation) ResetStatus() {
	m.status = nil
}

// SetLastSeen sets the "last_seen" field.
func (m *RouterMutation) SetLastSeen(t time.Time) {
	m.last_seen = &t
}

// LastSeen returns the value of the "last_seen" field in the mutation.
func (m *RouterMutation) LastSeen() (r time.Time, exists bool) {
	v := m.last_seen
	if v == nil {
		return
	}
	return *v, true
}

// OldLastSeen returns the old "last_seen" field's value of the Router entity.
// If the Router object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RouterMutation) OldLastSeen(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastSeen is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastSeen requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastSeen: %w", err)
	}
	return oldValue.LastSeen, nil
}

// ClearLastSeen clears the value of the "last_seen" field.
func (m *RouterMutation) ClearLastSeen() {
	m.last_seen = nil
	m.clearedFields[router.FieldLastSeen] = struct{}{}
}

// LastSeenCleared returns if the "last_seen" field was cleared in this mutation.
func (m *RouterMutation) LastSeenCleared() bool {
	_, ok := m.clearedFields[router.FieldLastSeen]
	return ok
}

// ResetLastSeen resets all changes to the "last_seen" field.
func (m *RouterMutation) ResetLastSeen() {
	m.last_seen = nil
	delete(m.clearedFields, router.FieldLastSeen)
}

// SetCreatedAt sets the "created_at" field.
func (m *RouterMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *RouterMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Router entity.
// If the Router object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RouterMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *RouterMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *RouterMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *RouterMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Router entity.
// If the Router object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RouterMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *RouterMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetSecretsID sets the "secrets" edge to the RouterSecret entity by id.
func (m *RouterMutation) SetSecretsID(id string) {
	m.secrets = &id
}

// ClearSecrets clears the "secrets" edge to the RouterSecret entity.
func (m *RouterMutation) ClearSecrets() {
	m.clearedsecrets = true
}

// SecretsCleared reports if the "secrets" edge to the RouterSecret entity was cleared.
func (m *RouterMutation) SecretsCleared() bool {
	return m.clearedsecrets
}

// SecretsID returns the "secrets" edge ID in the mutation.
func (m *RouterMutation) SecretsID() (id string, exists bool) {
	if m.secrets != nil {
		return *m.secrets, true
	}
	return
}

// SecretsIDs returns the "secrets" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SecretsID instead. It exists only for internal usage by the builders.
func (m *RouterMutation) SecretsIDs() (ids []string) {
	if id := m.secrets; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSecrets resets all changes to the "secrets" edge.
func (m *RouterMutation) ResetSecrets() {
	m.secrets = nil
	m.clearedsecrets = false
}

// AddPortKnockSequenceIDs adds the "port_knock_sequences" edge to the PortKnockSequence entity by ids.
func (m *RouterMutation) AddPortKnockSequenceIDs(ids ...string) {
	if m.port_knock_sequences == nil {
		m.port_knock_sequences = make(map[string]struct{})
	}
	for i := range ids {
		m.port_knock_sequences[ids[i]] = struct{}{}
	}
}

// ClearPortKnockSequences clears the "port_knock_sequences" edge to the PortKnockSequence entity.
func (m *RouterMutation) ClearPortKnockSequences() {
	m.clearedport_knock_sequences = true
}

// PortKnockSequencesCleared reports if the "port_knock_sequences" edge to the PortKnockSequence entity was cleared.
func (m *RouterMutation) PortKnockSequencesCleared() bool {
	return m.clearedport_knock_sequences
}

// RemovePortKnockSequenceIDs removes the "port_knock_sequences" edge to the PortKnockSequence entity by IDs.
func (m *RouterMutation) RemovePortKnockSequenceIDs(ids ...string) {
	if m.removedport_knock_sequences == nil {
		m.removedport_knock_sequences = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.port_knock_sequences, ids[i])
		m.removedport_knock_sequences[ids[i]] = struct{}{}
	}
}

// RemovedPortKnockSequences returns the removed IDs of the "port_knock_sequences" edge to the PortKnockSequence entity.
func (m *RouterMutation) RemovedPortKnockSequencesIDs() (ids []string) {
	for id := range m.removedport_knock_sequences {
		ids = append(ids, id)
	}
	return
}

// PortKnockSequencesIDs returns the "port_knock_sequences" edge IDs in the mutation.
func (m *RouterMutation) PortKnockSequencesIDs() (ids []string) {
	for id := range m.port_knock_sequences {
		ids = append(ids, id)
	}
	return
}

// ResetPortKnockSequences resets all changes to the "port_knock_sequences" edge.
func (m *RouterMutation) ResetPortKnockSequences() {
	m.port_knock_sequences = nil
	m.clearedport_knock_sequences = false
	m.removedport_knock_sequences = nil
}

// AddServiceInstanceIDs adds the "service_instances" edge to the ServiceInstance entity by ids.
func (m *RouterMutation) AddServiceInstanceIDs(ids ...string) {
	if m.service_instances == nil {
		m.service_instances = make(map[string]struct{})
	}
	for i := range ids {
		m.service_instances[ids[i]] = struct{}{}
	}
}

// ClearServiceInstances clears the "service_instances" edge to the ServiceInstance entity.
func (m *RouterMutation) ClearServiceInstances() {
	m.clearedservice_instances = true
}

// ServiceInstancesCleared reports if the "service_instances" edge to the ServiceInstance entity was cleared.
func (m *RouterMutation) ServiceInstancesCleared() bool {
	return m.clearedservice_instances
}

// RemoveServiceInstanceIDs removes the "service_instances" edge to the ServiceInstance entity by IDs.
func (m *RouterMutation) RemoveServiceInstanceIDs(ids ...string) {
	if m.removedservice_instances == nil {
		m.removedservice_instances = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.service_instances, ids[i])
		m.removedservice_instances[ids[i]] = struct{}{}
	}
}

// RemovedServiceInstances returns the removed IDs of the "service_instances" edge to the ServiceInstance entity.
func (m *RouterMutation) RemovedServiceInstancesIDs() (ids []string) {
	for id := range m.removedservice_instances {
		ids = append(ids, id)
	}
	return
}

// ServiceInstancesIDs returns the "service_instances" edge IDs in the mutation.
func (m *RouterMutation) ServiceInstancesIDs() (ids []string) {
	for id := range m.service_instances {
		ids = append(ids, id)
	}
	return
}

// ResetServiceInstances resets all changes to the "service_instances" edge.
func (m *RouterMutation) ResetServiceInstances() {
	m.service_instances = nil
	m.clearedservice_instances = false
	m.removedservice_instances = nil
}

// AddPortAllocationIDs adds the "port_allocations" edge to the PortAllocation entity by ids.
func (m *RouterMutation) AddPortAllocationIDs(ids ...string) {
	if m.port_allocations == nil {
		m.port_allocations = make(map[string]struct{})
	}
	for i := range ids {
		m.port_allocations[ids[i]] = struct{}{}
	}
}

// ClearPortAllocations clears the "port_allocations" edge to the PortAllocation entity.
func (m *RouterMutation) ClearPortAllocations() {
	m.clearedport_allocations = true
}

// PortAllocationsCleared reports if the "port_allocations" edge to the PortAllocation entity was cleared.
func (m *RouterMutation) PortAllocationsCleared() bool {
	return m.clearedport_allocations
}

// RemovePortAllocationIDs removes the "port_allocations" edge to the PortAllocation entity by IDs.
func (m *RouterMutation) RemovePortAllocationIDs(ids ...string) {
	if m.removedport_allocations == nil {
		m.removedport_allocations = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.port_allocations, ids[i])
		m.removedport_allocations[ids[i]] = struct{}{}
	}
}

// RemovedPortAllocations returns the removed IDs of the "port_allocations" edge to the PortAllocation entity.
func (m *RouterMutation) RemovedPortAllocationsIDs() (ids []string) {
	for id := range m.removedport_allocations {
		ids = append(ids, id)
	}
	return
}

// PortAllocationsIDs returns the "port_allocations" edge IDs in the mutation.
func (m *RouterMutation) PortAllocationsIDs() (ids []string) {
	for id := range m.port_allocations {
		ids = append(ids, id)
	}
	return
}

// ResetPortAllocations resets all changes to the "port_allocations" edge.
func (m *RouterMutation) ResetPortAllocations() {
	m.port_allocations = nil
	m.clearedport_allocations = false
	m.removedport_allocations = nil
}

// AddVlanAllocationIDs adds the "vlan_allocations" edge to the VLANAllocation entity by ids.
func (m *RouterMutation) AddVlanAllocationIDs(ids ...string) {
	if m.vlan_allocations == nil {
		m.vlan_allocations = make(map[string]struct{})
	}
	for i := range ids {
		m.vlan_allocations[ids[i]] = struct{}{}
	}
}

// ClearVlanAllocations clears the "vlan_allocations" edge to the VLANAllocation entity.
func (m *RouterMutation) ClearVlanAllocations() {
	m.clearedvlan_allocations = true
}

// VlanAllocationsCleared reports if the "vlan_allocations" edge to the VLANAllocation entity was cleared.
func (m *RouterMutation) VlanAllocationsCleared() bool {
	return m.clearedvlan_allocations
}

// RemoveVlanAllocationIDs removes the "vlan_allocations" edge to the VLANAllocation entity by IDs.
func (m *RouterMutation) RemoveVlanAllocationIDs(ids ...string) {
	if m.removedvlan_allocations == nil {
		m.removedvlan_allocations = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.vlan_allocations, ids[i])
		m.removedvlan_allocations[ids[i]] = struct{}{}
	}
}

// RemovedVlanAllocations returns the removed IDs of the "vlan_allocations" edge to the VLANAllocation entity.
func (m *RouterMutation) RemovedVlanAllocationsIDs() (ids []string) {
	for id := range m.removedvlan_allocations {
		ids = append(ids, id)
	}
	return
}

// VlanAllocationsIDs returns the "vlan_allocations" edge IDs in the mutation.
func (m *RouterMutation) VlanAllocationsIDs() (ids []string) {
	for id := range m.vlan_allocations {
		ids = append(ids, id)
	}
	return
}

// ResetVlanAllocations resets all changes to the "vlan_allocations" edge.
func (m *RouterMutation) ResetVlanAllocations() {
	m.vlan_allocations = nil
	m.clearedvlan_allocations = false
	m.removedvlan_allocations = nil
}

// AddDeviceRoutingIDs adds the "device_routings" edge to the DeviceRouting entity by ids.
func (m *RouterMutation) AddDeviceRoutingIDs(ids ...string) {
	if m.device_routings == nil {
		m.device_routings = make(map[string]struct{})
	}
	for i := range ids {
		m.device_routings[ids[i]] = struct{}{}
	}
}

// ClearDeviceRoutings clears the "device_routings" edge to the DeviceRouting entity.
func (m *RouterMutation) ClearDeviceRoutings() {
	m.cleareddevice_routings = true
}

// DeviceRoutingsCleared reports if the "device_routings" edge to the DeviceRouting entity was cleared.
func (m *RouterMutation) DeviceRoutingsCleared() bool {
	return m.cleareddevice_routings
}

// RemoveDeviceRoutingIDs removes the "device_routings" edge to the DeviceRouting entity by IDs.
func (m *RouterMutation) RemoveDeviceRoutingIDs(ids ...string) {
	if m.removeddevice_routings == nil {
		m.removeddevice_routings = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.device_routings, ids[i])
		m.removeddevice_routings[ids[i]] = struct{}{}
	}
}

// RemovedDeviceRoutings returns the removed IDs of the "device_routings" edge to the DeviceRouting entity.
func (m *RouterMutation) RemovedDeviceRoutingsIDs() (ids []string) {
	for id := range m.removeddevice_routings {
		ids = append(ids, id)
	}
	return
}

// DeviceRoutingsIDs returns the "device_routings" edge IDs in the mutation.
func (m *RouterMutation) DeviceRoutingsIDs() (ids []string) {
	for id := range m.device_routings {
		ids = append(ids, id)
	}
	return
}

// ResetDeviceRoutings resets all changes to the "device_routings" edge.
func (m *RouterMutation) ResetDeviceRoutings() {
	m.device_routings = nil
	m.cleareddevice_routings = false
	m.removeddevice_routings = nil
}

// AddRoutingChainIDs adds the "routing_chains" edge to the RoutingChain entity by ids.
func (m *RouterMutation) AddRoutingChainIDs(ids ...string) {
	if m.routing_chains == nil {
		m.routing_chains = make(map[string]struct{})
	}
	for i := range ids {
		m.routing_chains[ids[i]] = struct{}{}
	}
}

// ClearRoutingChains clears the "routing_chains" edge to the RoutingChain entity.
func (m *RouterMutation) ClearRoutingChains() {
	m.clearedrouting_chains = true
}

// RoutingChainsCleared reports if the "routing_chains" edge to the RoutingChain entity was cleared.
func (m *RouterMutation) RoutingChainsCleared() bool {
	return m.clearedrouting_chains
}

// RemoveRoutingChainIDs removes the "routing_chains" edge to the RoutingChain entity by IDs.
func (m *RouterMutation) RemoveRoutingChainIDs(ids ...string) {
	if m.removedrouting_chains == nil {
		m.removedrouting_chains = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.routing_chains, ids[i])
		m.removedrouting_chains[ids[i]] = struct{}{}
	}
}

// RemovedRoutingChains returns the removed IDs of the "routing_chains" edge to the RoutingChain entity.
func (m *RouterMutation) RemovedRoutingChainsIDs() (ids []string) {
	for id := range m.removedrouting_chains {
		ids = append(ids, id)
	}
	return
}

// RoutingChainsIDs returns the "routing_chains" edge IDs in the mutation.
func (m *RouterMutation) RoutingChainsIDs() (ids []string) {
	for id := range m.routing_chains {
		ids = append(ids, id)
	}
	return
}

// ResetRoutingChains resets all changes to the "routing_chains" edge.
func (m *RouterMutation) ResetRoutingChains() {
	m.routing_chains = nil
	m.clearedrouting_chains = false
	m.removedrouting_chains = nil
}

// AddServiceTemplateIDs adds the "service_templates" edge to the ServiceTemplate entity by ids.
func (m *RouterMutation) AddServiceTemplateIDs(ids ...string) {
	if m.service_templates == nil {
		m.service_templates = make(map[string]struct{})
	}
	for i := range ids {
		m.service_templates[ids[i]] = struct{}{}
	}
}

// ClearServiceTemplates clears the "service_templates" edge to the ServiceTemplate entity.
func (m *RouterMutation) ClearServiceTemplates() {
	m.clearedservice_templates = true
}

// ServiceTemplatesCleared reports if the "service_templates" edge to the ServiceTemplate entity was cleared.
func (m *RouterMutation) ServiceTemplatesCleared() bool {
	return m.clearedservice_templates
}

// RemoveServiceTemplateIDs removes the "service_templates" edge to the ServiceTemplate entity by IDs.
func (m *RouterMutation) RemoveServiceTemplateIDs(ids ...string) {
	if m.removedservice_templates == nil {
		m.removedservice_templates = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.service_templates, ids[i])
		m.removedservice_templates[ids[i]] = struct{}{}
	}
}

// RemovedServiceTemplates returns the removed IDs of the "service_templates" edge to the ServiceTemplate entity.
func (m *RouterMutation) RemovedServiceTemplatesIDs() (ids []string) {
	for id := range m.removedservice_templates {
		ids = append(ids, id)
	}
	return
}

// ServiceTemplatesIDs returns the "service_templates" edge IDs in the mutation.
func (m *RouterMutation) ServiceTemplatesIDs() (ids []string) {
	for id := range m.service_templates {
		ids = append(ids, id)
	}
	return
}

// ResetServiceTemplates resets all changes to the "service_templates" edge.
func (m *RouterMutation) ResetServiceTemplates() {
	m.service_templates = nil
	m.clearedservice_templates = false
	m.removedservice_templates = nil
}

// Where appends a list predicates to the RouterMutation builder.
func (m *RouterMutation) Where(ps ...predicate.Router) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RouterMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RouterMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Router, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RouterMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RouterMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Router).
func (m *RouterMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RouterMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.name != nil {
		fields = append(fields, router.FieldName)
	}
	if m.host != nil {
		fields = append(fields, router.FieldHost)
	}
	if m.port != nil {
		fields = append(fields, router.FieldPort)
	}
	if m.platform != nil {
		fields = append(fields, router.FieldPlatform)
	}
	if m.model != nil {
		fields = append(fields, router.FieldModel)
	}
	if m.version != nil {
		fields = append(fields, router.FieldVersion)
	}
	if m.status != nil {
		fields = append(fields, router.FieldStatus)
	}
	if m.last_seen != nil {
		fields = append(fields, router.FieldLastSeen)
	}
	if m.created_at != nil {
		fields = append(fields, router.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, router.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RouterMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case router.FieldName:
		return m.Name()
	case router.FieldHost:
		return m.Host()
	case router.FieldPort:
		return m.Port()
	case router.FieldPlatform:
		return m.Platform()
	case router.FieldModel:
		return m.Model()
	case router.FieldVersion:
		return m.Version()
	case router.FieldStatus:
		return m.Status()
	case router.FieldLastSeen:
		return m.LastSeen()
	case router.FieldCreatedAt:
		return m.CreatedAt()
	case router.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RouterMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case router.FieldName:
		return m.OldName(ctx)
	case router.FieldHost:
		return m.OldHost(ctx)
	case router.FieldPort:
		return m.OldPort(ctx)
	case router.FieldPlatform:
		return m.OldPlatform(ctx)
	case router.FieldModel:
		return m.OldModel(ctx)
	case router.FieldVersion:
		return m.OldVersion(ctx)
	case router.FieldStatus:
		return m.OldStatus(ctx)
	case router.FieldLastSeen:
		return m.OldLastSeen(ctx)
	case router.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case router.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Router field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RouterMutation) SetField(name string, value ent.Value) error {
	switch name {
	case router.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case router.FieldHost:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHost(v)
		return nil
	case router.FieldPort:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPort(v)
		return nil
	case router.FieldPlatform:
		v, ok := value.(router.Platform)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPlatform(v)
		return nil
	case router.FieldModel:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModel(v)
		return nil
	case router.FieldVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case router.FieldStatus:
		v, ok := value.(router.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case router.FieldLastSeen:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastSeen(v)
		return nil
	case router.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case router.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Router field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RouterMutation) AddedFields() []string {
	var fields []string
	if m.addport != nil {
		fields = append(fields, router.FieldPort)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RouterMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case router.FieldPort:
		return m.AddedPort()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RouterMutation) AddField(name string, value ent.Value) error {
	switch name {
	case router.FieldPort:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPort(v)
		return nil
	}
	return fmt.Errorf("unknown Router numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RouterMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(router.FieldModel) {
		fields = append(fields, router.FieldModel)
	}
	if m.FieldCleared(router.FieldVersion) {
		fields = append(fields, router.FieldVersion)
	}
	if m.FieldCleared(router.FieldLastSeen) {
		fields = append(fields, router.FieldLastSeen)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RouterMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RouterMutation) ClearField(name string) error {
	switch name {
	case router.FieldModel:
		m.ClearModel()
		return nil
	case router.FieldVersion:
		m.ClearVersion()
		return nil
	case router.FieldLastSeen:
		m.ClearLastSeen()
		return nil
	}
	return fmt.Errorf("unknown Router nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RouterMutation) ResetField(name string) error {
	switch name {
	case router.FieldName:
		m.ResetName()
		return nil
	case router.FieldHost:
		m.ResetHost()
		return nil
	case router.FieldPort:
		m.ResetPort()
		return nil
	case router.FieldPlatform:
		m.ResetPlatform()
		return nil
	case router.FieldModel:
		m.ResetModel()
		return nil
	case router.FieldVersion:
		m.ResetVersion()
		return nil
	case router.FieldStatus:
		m.ResetStatus()
		return nil
	case router.FieldLastSeen:
		m.ResetLastSeen()
		return nil
	case router.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case router.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Router field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RouterMutation) AddedEdges() []string {
	edges := make([]string, 0, 8)
	if m.secrets != nil {
		edges = append(edges, router.EdgeSecrets)
	}
	if m.port_knock_sequences != nil {
		edges = append(edges, router.EdgePortKnockSequences)
	}
	if m.service_instances != nil {
		edges = append(edges, router.EdgeServiceInstances)
	}
	if m.port_allocations != nil {
		edges = append(edges, router.EdgePortAllocations)
	}
	if m.vlan_allocations != nil {
		edges = append(edges, router.EdgeVlanAllocations)
	}
	if m.device_routings != nil {
		edges = append(edges, router.EdgeDeviceRoutings)
	}
	if m.routing_chains != nil {
		edges = append(edges, router.EdgeRoutingChains)
	}
	if m.service_templates != nil {
		edges = append(edges, router.EdgeServiceTemplates)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RouterMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case router.EdgeSecrets:
		if id := m.secrets; id != nil {
			return []ent.Value{*id}
		}
	case router.EdgePortKnockSequences:
		ids := make([]ent.Value, 0, len(m.port_knock_sequences))
		for id := range m.port_knock_sequences {
			ids = append(ids, id)
		}
		return ids
	case router.EdgeServiceInstances:
		ids := make([]ent.Value, 0, len(m.service_instances))
		for id := range m.service_instances {
			ids = append(ids, id)
		}
		return ids
	case router.EdgePortAllocations:
		ids := make([]ent.Value, 0, len(m.port_allocations))
		for id := range m.port_allocations {
			ids = append(ids, id)
		}
		return ids
	case router.EdgeVlanAllocations:
		ids := make([]ent.Value, 0, len(m.vlan_allocations))
		for id := range m.vlan_allocations {
			ids = append(ids, id)
		}
		return ids
	case router.EdgeDeviceRoutings:
		ids := make([]ent.Value, 0, len(m.device_routings))
		for id := range m.device_routings {
			ids = append(ids, id)
		}
		return ids
	case router.EdgeRoutingChains:
		ids := make([]ent.Value, 0, len(m.routing_chains))
		for id := range m.routing_chains {
			ids = append(ids, id)
		}
		return ids
	case router.EdgeServiceTemplates:
		ids := make([]ent.Value, 0, len(m.service_templates))
		for id := range m.service_templates {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RouterMutation) RemovedEdges() []string {
	edges := make([]string, 0, 8)
	if m.removedport_knock_sequences != nil {
		edges = append(edges, router.EdgePortKnockSequences)
	}
	if m.removedservice_instances != nil {
		edges = append(edges, router.EdgeServiceInstances)
	}
	if m.removedport_allocations != nil {
		edges = append(edges, router.EdgePortAllocations)
	}
	if m.removedvlan_allocations != nil {
		edges = append(edges, router.EdgeVlanAllocations)
	}
	if m.removeddevice_routings != nil {
		edges = append(edges, router.EdgeDeviceRoutings)
	}
	if m.removedrouting_chains != nil {
		edges = append(edges, router.EdgeRoutingChains)
	}
	if m.removedservice_templates != nil {
		edges = append(edges, router.EdgeServiceTemplates)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RouterMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case router.EdgePortKnockSequences:
		ids := make([]ent.Value, 0, len(m.removedport_knock_sequences))
		for id := range m.removedport_knock_sequences {
			ids = append(ids, id)
		}
		return ids
	case router.EdgeServiceInstances:
		ids := make([]ent.Value, 0, len(m.removedservice_instances))
		for id := range m.removedservice_instances {
			ids = append(ids, id)
		}
		return ids
	case router.EdgePortAllocations:
		ids := make([]ent.Value, 0, len(m.removedport_allocations))
		for id := range m.removedport_allocations {
			ids = append(ids, id)
		}
		return ids
	case router.EdgeVlanAllocations:
		ids := make([]ent.Value, 0, len(m.removedvlan_allocations))
		for id := range m.removedvlan_allocations {
			ids = append(ids, id)
		}
		return ids
	case router.EdgeDeviceRoutings:
		ids := make([]ent.Value, 0, len(m.removeddevice_routings))
		for id := range m.removeddevice_routings {
			ids = append(ids, id)
		}
		return ids
	case router.EdgeRoutingChains:
		ids := make([]ent.Value, 0, len(m.removedrouting_chains))
		for id := range m.removedrouting_chains {
			ids = append(ids, id)
		}
		return ids
	case router.EdgeServiceTemplates:
		ids := make([]ent.Value, 0, len(m.removedservice_templates))
		for id := range m.removedservice_templates {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RouterMutation) ClearedEdges() []string {
	edges := make([]string, 0, 8)
	if m.clearedsecrets {
		edges = append(edges, router.EdgeSecrets)
	}
	if m.clearedport_knock_sequences {
		edges = append(edges, router.EdgePortKnockSequences)
	}
	if m.clearedservice_instances {
		edges = append(edges, router.EdgeServiceInstances)
	}
	if m.clearedport_allocations {
		edges = append(edges, router.EdgePortAllocations)
	}
	if m.clearedvlan_allocations {
		edges = append(edges, router.EdgeVlanAllocations)
	}
	if m.cleareddevice_routings {
		edges = append(edges, router.EdgeDeviceRoutings)
	}
	if m.clearedrouting_chains {
		edges = append(edges, router.EdgeRoutingChains)
	}
	if m.clearedservice_templates {
		edges = append(edges, router.EdgeServiceTemplates)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RouterMutation) EdgeCleared(name string) bool {
	switch name {
	case router.EdgeSecrets:
		return m.clearedsecrets
	case router.EdgePortKnockSequences:
		return m.clearedport_knock_sequences
	case router.EdgeServiceInstances:
		return m.clearedservice_instances
	case router.EdgePortAllocations:
		return m.clearedport_allocations
	case router.EdgeVlanAllocations:
		return m.clearedvlan_allocations
	case router.EdgeDeviceRoutings:
		return m.cleareddevice_routings
	case router.EdgeRoutingChains:
		return m.clearedrouting_chains
	case router.EdgeServiceTemplates:
		return m.clearedservice_templates
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RouterMutation) ClearEdge(name string) error {
	switch name {
	case router.EdgeSecrets:
		m.ClearSecrets()
		return nil
	}
	return fmt.Errorf("unknown Router unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RouterMutation) ResetEdge(name string) error {
	switch name {
	case router.EdgeSecrets:
		m.ResetSecrets()
		return nil
	case router.EdgePortKnockSequences:
		m.ResetPortKnockSequences()
		return nil
	case router.EdgeServiceInstances:
		m.ResetServiceInstances()
		return nil
	case router.EdgePortAllocations:
		m.ResetPortAllocations()
		return nil
	case router.EdgeVlanAllocations:
		m.ResetVlanAllocations()
		return nil
	case router.EdgeDeviceRoutings:
		m.ResetDeviceRoutings()
		return nil
	case router.EdgeRoutingChains:
		m.ResetRoutingChains()
		return nil
	case router.EdgeServiceTemplates:
		m.ResetServiceTemplates()
		return nil
	}
	return fmt.Errorf("unknown Router edge %s", name)
}

// RouterCapabilityMutation represents an operation that mutates the RouterCapability nodes in the graph.
type RouterCapabilityMutation struct {
	config
	op                             Op
	typ                            string
	id                             *string
	architecture                   *string
	model                          *string
	board_name                     *string
	total_memory                   *int64
	addtotal_memory                *int64
	available_storage              *int64
	addavailable_storage           *int64
	cpu_count                      *int
	addcpu_count                   *int
	has_wireless_chip              *bool
	has_lte_module                 *bool
	version_raw                    *string
	version_major                  *int
	addversion_major               *int
	version_minor                  *int
	addversion_minor               *int
	version_patch                  *int
	addversion_patch               *int
	installed_packages             *[]string
	appendinstalled_packages       []string
	license_level                  *int
	addlicense_level               *int
	update_channel                 *string
	container_package_installed    *bool
	container_enabled              *bool
	container_registry_configured  *bool
	container_storage_available    *int64
	addcontainer_storage_available *int64
	supports_network_namespace     *bool
	max_containers                 *int
	addmax_containers              *int
	capability_entries             *map[string]interface{}
	detected_at                    *time.Time
	expires_at                     *time.Time
	is_refreshing                  *bool
	created_at                     *time.Time
	updated_at                     *time.Time
	clearedFields                  map[string]struct{}
	done                           bool
	oldValue                       func(context.Context) (*RouterCapability, error)
	predicates                     []predicate.RouterCapability
}

var _ ent.Mutation = (*RouterCapabilityMutation)(nil)

// routercapabilityOption allows management of the mutation configuration using functional options.
type routercapabilityOption func(*RouterCapabilityMutation)

// newRouterCapabilityMutation creates new mutation for the RouterCapability entity.
func newRouterCapabilityMutation(c config, op Op, opts ...routercapabilityOption) *RouterCapabilityMutation {
	m := &RouterCapabilityMutation{
		config:        c,
		op:            op,
		typ:           TypeRouterCapability,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRouterCapabilityID sets the ID field of the mutation.
func withRouterCapabilityID(id string) routercapabilityOption {
	return func(m *RouterCapabilityMutation) {
		var (
			err   error
			once  sync.Once
			value *RouterCapability
		)
		m.oldValue = func(ctx context.Context) (*RouterCapability, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().RouterCapability.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRouterCapability sets the old RouterCapability of the mutation.
func withRouterCapability(node *RouterCapability) routercapabilityOption {
	return func(m *RouterCapabilityMutation) {
		m.oldValue = func(context.Context) (*RouterCapability, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RouterCapabilityMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RouterCapabilityMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of RouterCapability entities.
func (m *RouterCapabilityMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RouterCapabilityMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RouterCapabilityMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().RouterCapability.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetArchitecture sets the "architecture" field.
func (m *RouterCapabilityMutation) SetArchitecture(s string) {
	m.architecture = &s
}

// Architecture returns the value of the "architecture" field in the mutation.
func (m *RouterCapabilityMutation) Architecture() (r string, exists bool) {
	v := m.architecture
	if v == nil {
		return
	}
	return *v, true
}

// OldArchitecture returns the old "architecture" field's value of the RouterCapability entity.
// If the RouterCapability object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RouterCapabilityMutation) OldArchitecture(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldArchitecture is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldArchitecture requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldArchitecture: %w", err)
	}
	return oldValue.Architecture, nil
}

// ResetArchitecture resets all changes to the "architecture" field.
func (m *RouterCapabilityMutation) ResetArchitecture() {
	m.architecture = nil
}

// SetModel sets the "model" field.
func (m *RouterCapabilityMutation) SetModel(s string) {
	m.model = &s
}

// Model returns the value of the "model" field in the mutation.
func (m *RouterCapabilityMutation) Model() (r string, exists bool) {
	v := m.model
	if v == nil {
		return
	}
	return *v, true
}

// OldModel returns the old "model" field's value of the RouterCapability entity.
// If the RouterCapability object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RouterCapabilityMutation) OldModel(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldModel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldModel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModel: %w", err)
	}
	return oldValue.Model, nil
}

// ClearModel clears the value of the "model" field.
func (m *RouterCapabilityMutation) ClearModel() {
	m.model = nil
	m.clearedFields[routercapability.FieldModel] = struct{}{}
}

// ModelCleared returns if the "model" field was cleared in this mutation.
func (m *RouterCapabilityMutation) ModelCleared() bool {
	_, ok := m.clearedFields[routercapability.FieldModel]
	return ok
}

// ResetModel resets all changes to the "model" field.
func (m *RouterCapabilityMutation) ResetModel() {
	m.model = nil
	delete(m.clearedFields, routercapability.FieldModel)
}

// SetBoardName sets the "board_name" field.
func (m *RouterCapabilityMutation) SetBoardName(s string) {
	m.board_name = &s
}

// BoardName returns the value of the "board_name" field in the mutation.
func (m *RouterCapabilityMutation) BoardName() (r string, exists bool) {
	v := m.board_name
	if v == nil {
		return
	}
	return *v, true
}

// OldBoardName returns the old "board_name" field's value of the RouterCapability entity.
// If the RouterCapability object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RouterCapabilityMutation) OldBoardName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBoardName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBoardName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBoardName: %w", err)
	}
	return oldValue.BoardName, nil
}

// ClearBoardName clears the value of the "board_name" field.
func (m *RouterCapabilityMutation) ClearBoardName() {
	m.board_name = nil
	m.clearedFields[routercapability.FieldBoardName] = struct{}{}
}

// BoardNameCleared returns if the "board_name" field was cleared in this mutation.
func (m *RouterCapabilityMutation) BoardNameCleared() bool {
	_, ok := m.clearedFields[routercapability.FieldBoardName]
	return ok
}

// ResetBoardName resets all changes to the "board_name" field.
func (m *RouterCapabilityMutation) ResetBoardName() {
	m.board_name = nil
	delete(m.clearedFields, routercapability.FieldBoardName)
}

// SetTotalMemory sets the "total_memory" field.
func (m *RouterCapabilityMutation) SetTotalMemory(i int64) {
	m.total_memory = &i
	m.addtotal_memory = nil
}

// TotalMemory returns the value of the "total_memory" field in the mutation.
func (m *RouterCapabilityMutation) TotalMemory() (r int64, exists bool) {
	v := m.total_memory
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalMemory returns the old "total_memory" field's value of the RouterCapability entity.
// If the RouterCapability object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RouterCapabilityMutation) OldTotalMemory(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalMemory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalMemory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalMemory: %w", err)
	}
	return oldValue.TotalMemory, nil
}

// AddTotalMemory adds i to the "total_memory" field.
func (m *RouterCapabilityMutation) AddTotalMemory(i int64) {
	if m.addtotal_memory != nil {
		*m.addtotal_memory += i
	} else {
		m.addtotal_memory = &i
	}
}

// AddedTotalMemory returns the value that was added to the "total_memory" field in this mutation.
func (m *RouterCapabilityMutation) AddedTotalMemory() (r int64, exists bool) {
	v := m.addtotal_memory
	if v == nil {
		return
	}
	return *v, true
}

// ResetTotalMemory resets all changes to the "total_memory" field.
func (m *RouterCapabilityMutation) ResetTotalMemory() {
	m.total_memory = nil
	m.addtotal_memory = nil
}

// SetAvailableStorage sets the "available_storage" field.
func (m *RouterCapabilityMutation) SetAvailableStorage(i int64) {
	m.available_storage = &i
	m.addavailable_storage = nil
}

// AvailableStorage returns the value of the "available_storage" field in the mutation.
func (m *RouterCapabilityMutation) AvailableStorage() (r int64, exists bool) {
	v := m.available_storage
	if v == nil {
		return
	}
	return *v, true
}

// OldAvailableStorage returns the old "available_storage" field's value of the RouterCapability entity.
// If the RouterCapability object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RouterCapabilityMutation) OldAvailableStorage(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAvailableStorage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAvailableStorage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAvailableStorage: %w", err)
	}
	return oldValue.AvailableStorage, nil
}

// AddAvailableStorage adds i to the "available_storage" field.
func (m *RouterCapabilityMutation) AddAvailableStorage(i int64) {
	if m.addavailable_storage != nil {
		*m.addavailable_storage += i
	} else {
		m.addavailable_storage = &i
	}
}

// AddedAvailableStorage returns the value that was added to the "available_storage" field in this mutation.
func (m *RouterCapabilityMutation) AddedAvailableStorage() (r int64, exists bool) {
	v := m.addavailable_storage
	if v == nil {
		return
	}
	return *v, true
}

// ResetAvailableStorage resets all changes to the "available_storage" field.
func (m *RouterCapabilityMutation) ResetAvailableStorage() {
	m.available_storage = nil
	m.addavailable_storage = nil
}

// SetCPUCount sets the "cpu_count" field.
func (m *RouterCapabilityMutation) SetCPUCount(i int) {
	m.cpu_count = &i
	m.addcpu_count = nil
}

// CPUCount returns the value of the "cpu_count" field in the mutation.
func (m *RouterCapabilityMutation) CPUCount() (r int, exists bool) {
	v := m.cpu_count
	if v == nil {
		return
	}
	return *v, true
}

// OldCPUCount returns the old "cpu_count" field's value of the RouterCapability entity.
// If the RouterCapability object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RouterCapabilityMutation) OldCPUCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCPUCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCPUCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCPUCount: %w", err)
	}
	return oldValue.CPUCount, nil
}

// AddCPUCount adds i to the "cpu_count" field.
func (m *RouterCapabilityMutation) AddCPUCount(i int) {
	if m.addcpu_count != nil {
		*m.addcpu_count += i
	} else {
		m.addcpu_count = &i
	}
}

// AddedCPUCount returns the value that was added to the "cpu_count" field in this mutation.
func (m *RouterCapabilityMutation) AddedCPUCount() (r int, exists bool) {
	v := m.addcpu_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetCPUCount resets all changes to the "cpu_count" field.
func (m *RouterCapabilityMutation) ResetCPUCount() {
	m.cpu_count = nil
	m.addcpu_count = nil
}

// SetHasWirelessChip sets the "has_wireless_chip" field.
func (m *RouterCapabilityMutation) SetHasWirelessChip(b bool) {
	m.has_wireless_chip = &b
}

// HasWirelessChip returns the value of the "has_wireless_chip" field in the mutation.
func (m *RouterCapabilityMutation) HasWirelessChip() (r bool, exists bool) {
	v := m.has_wireless_chip
	if v == nil {
		return
	}
	return *v, true
}

// OldHasWirelessChip returns the old "has_wireless_chip" field's value of the RouterCapability entity.
// If the RouterCapability object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RouterCapabilityMutation) OldHasWirelessChip(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHasWirelessChip is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHasWirelessChip requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHasWirelessChip: %w", err)
	}
	return oldValue.HasWirelessChip, nil
}

// ResetHasWirelessChip resets all changes to the "has_wireless_chip" field.
func (m *RouterCapabilityMutation) ResetHasWirelessChip() {
	m.has_wireless_chip = nil
}

// SetHasLteModule sets the "has_lte_module" field.
func (m *RouterCapabilityMutation) SetHasLteModule(b bool) {
	m.has_lte_module = &b
}

// HasLteModule returns the value of the "has_lte_module" field in the mutation.
func (m *RouterCapabilityMutation) HasLteModule() (r bool, exists bool) {
	v := m.has_lte_module
	if v == nil {
		return
	}
	return *v, true
}

// OldHasLteModule returns the old "has_lte_module" field's value of the RouterCapability entity.
// If the RouterCapability object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RouterCapabilityMutation) OldHasLteModule(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHasLteModule is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHasLteModule requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHasLteModule: %w", err)
	}
	return oldValue.HasLteModule, nil
}

// ResetHasLteModule resets all changes to the "has_lte_module" field.
func (m *RouterCapabilityMutation) ResetHasLteModule() {
	m.has_lte_module = nil
}

// SetVersionRaw sets the "version_raw" field.
func (m *RouterCapabilityMutation) SetVersionRaw(s string) {
	m.version_raw = &s
}

// VersionRaw returns the value of the "version_raw" field in the mutation.
func (m *RouterCapabilityMutation) VersionRaw() (r string, exists bool) {
	v := m.version_raw
	if v == nil {
		return
	}
	return *v, true
}

// OldVersionRaw returns the old "version_raw" field's value of the RouterCapability entity.
// If the RouterCapability object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RouterCapabilityMutation) OldVersionRaw(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersionRaw is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersionRaw requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersionRaw: %w", err)
	}
	return oldValue.VersionRaw, nil
}

// ResetVersionRaw resets all changes to the "version_raw" field.
func (m *RouterCapabilityMutation) ResetVersionRaw() {
	m.version_raw = nil
}

// SetVersionMajor sets the "version_major" field.
func (m *RouterCapabilityMutation) SetVersionMajor(i int) {
	m.version_major = &i
	m.addversion_major = nil
}

// VersionMajor returns the value of the "version_major" field in the mutation.
func (m *RouterCapabilityMutation) VersionMajor() (r int, exists bool) {
	v := m.version_major
	if v == nil {
		return
	}
	return *v, true
}

// OldVersionMajor returns the old "version_major" field's value of the RouterCapability entity.
// If the RouterCapability object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RouterCapabilityMutation) OldVersionMajor(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersionMajor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersionMajor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersionMajor: %w", err)
	}
	return oldValue.VersionMajor, nil
}

// AddVersionMajor adds i to the "version_major" field.
func (m *RouterCapabilityMutation) AddVersionMajor(i int) {
	if m.addversion_major != nil {
		*m.addversion_major += i
	} else {
		m.addversion_major = &i
	}
}

// AddedVersionMajor returns the value that was added to the "version_major" field in this mutation.
func (m *RouterCapabilityMutation) AddedVersionMajor() (r int, exists bool) {
	v := m.addversion_major
	if v == nil {
		return
	}
	return *v, true
}

// ResetVersionMajor resets all changes to the "version_major" field.
func (m *RouterCapabilityMutation) ResetVersionMajor() {
	m.version_major = nil
	m.addversion_major = nil
}

// SetVersionMinor sets the "version_minor" field.
func (m *RouterCapabilityMutation) SetVersionMinor(i int) {
	m.version_minor = &i
	m.addversion_minor = nil
}

// VersionMinor returns the value of the "version_minor" field in the mutation.
func (m *RouterCapabilityMutation) VersionMinor() (r int, exists bool) {
	v := m.version_minor
	if v == nil {
		return
	}
	return *v, true
}

// OldVersionMinor returns the old "version_minor" field's value of the RouterCapability entity.
// If the RouterCapability object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RouterCapabilityMutation) OldVersionMinor(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersionMinor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersionMinor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersionMinor: %w", err)
	}
	return oldValue.VersionMinor, nil
}

// AddVersionMinor adds i to the "version_minor" field.
func (m *RouterCapabilityMutation) AddVersionMinor(i int) {
	if m.addversion_minor != nil {
		*m.addversion_minor += i
	} else {
		m.addversion_minor = &i
	}
}

// AddedVersionMinor returns the value that was added to the "version_minor" field in this mutation.
func (m *RouterCapabilityMutation) AddedVersionMinor() (r int, exists bool) {
	v := m.addversion_minor
	if v == nil {
		return
	}
	return *v, true
}

// ResetVersionMinor resets all changes to the "version_minor" field.
func (m *RouterCapabilityMutation) ResetVersionMinor() {
	m.version_minor = nil
	m.addversion_minor = nil
}

// SetVersionPatch sets the "version_patch" field.
func (m *RouterCapabilityMutation) SetVersionPatch(i int) {
	m.version_patch = &i
	m.addversion_patch = nil
}

// VersionPatch returns the value of the "version_patch" field in the mutation.
func (m *RouterCapabilityMutation) VersionPatch() (r int, exists bool) {
	v := m.version_patch
	if v == nil {
		return
	}
	return *v, true
}

// OldVersionPatch returns the old "version_patch" field's value of the RouterCapability entity.
// If the RouterCapability object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RouterCapabilityMutation) OldVersionPatch(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersionPatch is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersionPatch requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersionPatch: %w", err)
	}
	return oldValue.VersionPatch, nil
}

// AddVersionPatch adds i to the "version_patch" field.
func (m *RouterCapabilityMutation) AddVersionPatch(i int) {
	if m.addversion_patch != nil {
		*m.addversion_patch += i
	} else {
		m.addversion_patch = &i
	}
}

// AddedVersionPatch returns the value that was added to the "version_patch" field in this mutation.
func (m *RouterCapabilityMutation) AddedVersionPatch() (r int, exists bool) {
	v := m.addversion_patch
	if v == nil {
		return
	}
	return *v, true
}

// ResetVersionPatch resets all changes to the "version_patch" field.
func (m *RouterCapabilityMutation) ResetVersionPatch() {
	m.version_patch = nil
	m.addversion_patch = nil
}

// SetInstalledPackages sets the "installed_packages" field.
func (m *RouterCapabilityMutation) SetInstalledPackages(s []string) {
	m.installed_packages = &s
	m.appendinstalled_packages = nil
}

// InstalledPackages returns the value of the "installed_packages" field in the mutation.
func (m *RouterCapabilityMutation) InstalledPackages() (r []string, exists bool) {
	v := m.installed_packages
	if v == nil {
		return
	}
	return *v, true
}

// OldInstalledPackages returns the old "installed_packages" field's value of the RouterCapability entity.
// If the RouterCapability object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RouterCapabilityMutation) OldInstalledPackages(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInstalledPackages is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInstalledPackages requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInstalledPackages: %w", err)
	}
	return oldValue.InstalledPackages, nil
}

// AppendInstalledPackages adds s to the "installed_packages" field.
func (m *RouterCapabilityMutation) AppendInstalledPackages(s []string) {
	m.appendinstalled_packages = append(m.appendinstalled_packages, s...)
}

// AppendedInstalledPackages returns the list of values that were appended to the "installed_packages" field in this mutation.
func (m *RouterCapabilityMutation) AppendedInstalledPackages() ([]string, bool) {
	if len(m.appendinstalled_packages) == 0 {
		return nil, false
	}
	return m.appendinstalled_packages, true
}

// ResetInstalledPackages resets all changes to the "installed_packages" field.
func (m *RouterCapabilityMutation) ResetInstalledPackages() {
	m.installed_packages = nil
	m.appendinstalled_packages = nil
}

// SetLicenseLevel sets the "license_level" field.
func (m *RouterCapabilityMutation) SetLicenseLevel(i int) {
	m.license_level = &i
	m.addlicense_level = nil
}

// LicenseLevel returns the value of the "license_level" field in the mutation.
func (m *RouterCapabilityMutation) LicenseLevel() (r int, exists bool) {
	v := m.license_level
	if v == nil {
		return
	}
	return *v, true
}

// OldLicenseLevel returns the old "license_level" field's value of the RouterCapability entity.
// If the RouterCapability object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RouterCapabilityMutation) OldLicenseLevel(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLicenseLevel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLicenseLevel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLicenseLevel: %w", err)
	}
	return oldValue.LicenseLevel, nil
}

// AddLicenseLevel adds i to the "license_level" field.
func (m *RouterCapabilityMutation) AddLicenseLevel(i int) {
	if m.addlicense_level != nil {
		*m.addlicense_level += i
	} else {
		m.addlicense_level = &i
	}
}

// AddedLicenseLevel returns the value that was added to the "license_level" field in this mutation.
func (m *RouterCapabilityMutation) AddedLicenseLevel() (r int, exists bool) {
	v := m.addlicense_level
	if v == nil {
		return
	}
	return *v, true
}

// ResetLicenseLevel resets all changes to the "license_level" field.
func (m *RouterCapabilityMutation) ResetLicenseLevel() {
	m.license_level = nil
	m.addlicense_level = nil
}

// SetUpdateChannel sets the "update_channel" field.
func (m *RouterCapabilityMutation) SetUpdateChannel(s string) {
	m.update_channel = &s
}

// UpdateChannel returns the value of the "update_channel" field in the mutation.
func (m *RouterCapabilityMutation) UpdateChannel() (r string, exists bool) {
	v := m.update_channel
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateChannel returns the old "update_channel" field's value of the RouterCapability entity.
// If the RouterCapability object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RouterCapabilityMutation) OldUpdateChannel(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateChannel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateChannel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateChannel: %w", err)
	}
	return oldValue.UpdateChannel, nil
}

// ClearUpdateChannel clears the value of the "update_channel" field.
func (m *RouterCapabilityMutation) ClearUpdateChannel() {
	m.update_channel = nil
	m.clearedFields[routercapability.FieldUpdateChannel] = struct{}{}
}

// UpdateChannelCleared returns if the "update_channel" field was cleared in this mutation.
func (m *RouterCapabilityMutation) UpdateChannelCleared() bool {
	_, ok := m.clearedFields[routercapability.FieldUpdateChannel]
	return ok
}

// ResetUpdateChannel resets all changes to the "update_channel" field.
func (m *RouterCapabilityMutation) ResetUpdateChannel() {
	m.update_channel = nil
	delete(m.clearedFields, routercapability.FieldUpdateChannel)
}

// SetContainerPackageInstalled sets the "container_package_installed" field.
func (m *RouterCapabilityMutation) SetContainerPackageInstalled(b bool) {
	m.container_package_installed = &b
}

// ContainerPackageInstalled returns the value of the "container_package_installed" field in the mutation.
func (m *RouterCapabilityMutation) ContainerPackageInstalled() (r bool, exists bool) {
	v := m.container_package_installed
	if v == nil {
		return
	}
	return *v, true
}

// OldContainerPackageInstalled returns the old "container_package_installed" field's value of the RouterCapability entity.
// If the RouterCapability object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RouterCapabilityMutation) OldContainerPackageInstalled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContainerPackageInstalled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContainerPackageInstalled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContainerPackageInstalled: %w", err)
	}
	return oldValue.ContainerPackageInstalled, nil
}

// ResetContainerPackageInstalled resets all changes to the "container_package_installed" field.
func (m *RouterCapabilityMutation) ResetContainerPackageInstalled() {
	m.container_package_installed = nil
}

// SetContainerEnabled sets the "container_enabled" field.
func (m *RouterCapabilityMutation) SetContainerEnabled(b bool) {
	m.container_enabled = &b
}

// ContainerEnabled returns the value of the "container_enabled" field in the mutation.
func (m *RouterCapabilityMutation) ContainerEnabled() (r bool, exists bool) {
	v := m.container_enabled
	if v == nil {
		return
	}
	return *v, true
}

// OldContainerEnabled returns the old "container_enabled" field's value of the RouterCapability entity.
// If the RouterCapability object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RouterCapabilityMutation) OldContainerEnabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContainerEnabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContainerEnabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContainerEnabled: %w", err)
	}
	return oldValue.ContainerEnabled, nil
}

// ResetContainerEnabled resets all changes to the "container_enabled" field.
func (m *RouterCapabilityMutation) ResetContainerEnabled() {
	m.container_enabled = nil
}

// SetContainerRegistryConfigured sets the "container_registry_configured" field.
func (m *RouterCapabilityMutation) SetContainerRegistryConfigured(b bool) {
	m.container_registry_configured = &b
}

// ContainerRegistryConfigured returns the value of the "container_registry_configured" field in the mutation.
func (m *RouterCapabilityMutation) ContainerRegistryConfigured() (r bool, exists bool) {
	v := m.container_registry_configured
	if v == nil {
		return
	}
	return *v, true
}

// OldContainerRegistryConfigured returns the old "container_registry_configured" field's value of the RouterCapability entity.
// If the RouterCapability object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RouterCapabilityMutation) OldContainerRegistryConfigured(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContainerRegistryConfigured is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContainerRegistryConfigured requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContainerRegistryConfigured: %w", err)
	}
	return oldValue.ContainerRegistryConfigured, nil
}

// ResetContainerRegistryConfigured resets all changes to the "container_registry_configured" field.
func (m *RouterCapabilityMutation) ResetContainerRegistryConfigured() {
	m.container_registry_configured = nil
}

// SetContainerStorageAvailable sets the "container_storage_available" field.
func (m *RouterCapabilityMutation) SetContainerStorageAvailable(i int64) {
	m.container_storage_available = &i
	m.addcontainer_storage_available = nil
}

// ContainerStorageAvailable returns the value of the "container_storage_available" field in the mutation.
func (m *RouterCapabilityMutation) ContainerStorageAvailable() (r int64, exists bool) {
	v := m.container_storage_available
	if v == nil {
		return
	}
	return *v, true
}

// OldContainerStorageAvailable returns the old "container_storage_available" field's value of the RouterCapability entity.
// If the RouterCapability object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RouterCapabilityMutation) OldContainerStorageAvailable(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContainerStorageAvailable is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContainerStorageAvailable requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContainerStorageAvailable: %w", err)
	}
	return oldValue.ContainerStorageAvailable, nil
}

// AddContainerStorageAvailable adds i to the "container_storage_available" field.
func (m *RouterCapabilityMutation) AddContainerStorageAvailable(i int64) {
	if m.addcontainer_storage_available != nil {
		*m.addcontainer_storage_available += i
	} else {
		m.addcontainer_storage_available = &i
	}
}

// AddedContainerStorageAvailable returns the value that was added to the "container_storage_available" field in this mutation.
func (m *RouterCapabilityMutation) AddedContainerStorageAvailable() (r int64, exists bool) {
	v := m.addcontainer_storage_available
	if v == nil {
		return
	}
	return *v, true
}

// ResetContainerStorageAvailable resets all changes to the "container_storage_available" field.
func (m *RouterCapabilityMutation) ResetContainerStorageAvailable() {
	m.container_storage_available = nil
	m.addcontainer_storage_available = nil
}

// SetSupportsNetworkNamespace sets the "supports_network_namespace" field.
func (m *RouterCapabilityMutation) SetSupportsNetworkNamespace(b bool) {
	m.supports_network_namespace = &b
}

// SupportsNetworkNamespace returns the value of the "supports_network_namespace" field in the mutation.
func (m *RouterCapabilityMutation) SupportsNetworkNamespace() (r bool, exists bool) {
	v := m.supports_network_namespace
	if v == nil {
		return
	}
	return *v, true
}

// OldSupportsNetworkNamespace returns the old "supports_network_namespace" field's value of the RouterCapability entity.
// If the RouterCapability object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RouterCapabilityMutation) OldSupportsNetworkNamespace(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSupportsNetworkNamespace is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSupportsNetworkNamespace requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSupportsNetworkNamespace: %w", err)
	}
	return oldValue.SupportsNetworkNamespace, nil
}

// ResetSupportsNetworkNamespace resets all changes to the "supports_network_namespace" field.
func (m *RouterCapabilityMutation) ResetSupportsNetworkNamespace() {
	m.supports_network_namespace = nil
}

// SetMaxContainers sets the "max_containers" field.
func (m *RouterCapabilityMutation) SetMaxContainers(i int) {
	m.max_containers = &i
	m.addmax_containers = nil
}

// MaxContainers returns the value of the "max_containers" field in the mutation.
func (m *RouterCapabilityMutation) MaxContainers() (r int, exists bool) {
	v := m.max_containers
	if v == nil {
		return
	}
	return *v, true
}

// OldMaxContainers returns the old "max_containers" field's value of the RouterCapability entity.
// If the RouterCapability object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RouterCapabilityMutation) OldMaxContainers(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMaxContainers is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMaxContainers requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaxContainers: %w", err)
	}
	return oldValue.MaxContainers, nil
}

// AddMaxContainers adds i to the "max_containers" field.
func (m *RouterCapabilityMutation) AddMaxContainers(i int) {
	if m.addmax_containers != nil {
		*m.addmax_containers += i
	} else {
		m.addmax_containers = &i
	}
}

// AddedMaxContainers returns the value that was added to the "max_containers" field in this mutation.
func (m *RouterCapabilityMutation) AddedMaxContainers() (r int, exists bool) {
	v := m.addmax_containers
	if v == nil {
		return
	}
	return *v, true
}

// ResetMaxContainers resets all changes to the "max_containers" field.
func (m *RouterCapabilityMutation) ResetMaxContainers() {
	m.max_containers = nil
	m.addmax_containers = nil
}

// SetCapabilityEntries sets the "capability_entries" field.
func (m *RouterCapabilityMutation) SetCapabilityEntries(value map[string]interface{}) {
	m.capability_entries = &value
}

// CapabilityEntries returns the value of the "capability_entries" field in the mutation.
func (m *RouterCapabilityMutation) CapabilityEntries() (r map[string]interface{}, exists bool) {
	v := m.capability_entries
	if v == nil {
		return
	}
	return *v, true
}

// OldCapabilityEntries returns the old "capability_entries" field's value of the RouterCapability entity.
// If the RouterCapability object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RouterCapabilityMutation) OldCapabilityEntries(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCapabilityEntries is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCapabilityEntries requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCapabilityEntries: %w", err)
	}
	return oldValue.CapabilityEntries, nil
}

// ResetCapabilityEntries resets all changes to the "capability_entries" field.
func (m *RouterCapabilityMutation) ResetCapabilityEntries() {
	m.capability_entries = nil
}

// SetDetectedAt sets the "detected_at" field.
func (m *RouterCapabilityMutation) SetDetectedAt(t time.Time) {
	m.detected_at = &t
}

// DetectedAt returns the value of the "detected_at" field in the mutation.
func (m *RouterCapabilityMutation) DetectedAt() (r time.Time, exists bool) {
	v := m.detected_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDetectedAt returns the old "detected_at" field's value of the RouterCapability entity.
// If the RouterCapability object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RouterCapabilityMutation) OldDetectedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDetectedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDetectedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDetectedAt: %w", err)
	}
	return oldValue.DetectedAt, nil
}

// ResetDetectedAt resets all changes to the "detected_at" field.
func (m *RouterCapabilityMutation) ResetDetectedAt() {
	m.detected_at = nil
}

// SetExpiresAt sets the "expires_at" field.
func (m *RouterCapabilityMutation) SetExpiresAt(t time.Time) {
	m.expires_at = &t
}

// ExpiresAt returns the value of the "expires_at" field in the mutation.
func (m *RouterCapabilityMutation) ExpiresAt() (r time.Time, exists bool) {
	v := m.expires_at
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiresAt returns the old "expires_at" field's value of the RouterCapability entity.
// If the RouterCapability object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RouterCapabilityMutation) OldExpiresAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiresAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiresAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiresAt: %w", err)
	}
	return oldValue.ExpiresAt, nil
}

// ResetExpiresAt resets all changes to the "expires_at" field.
func (m *RouterCapabilityMutation) ResetExpiresAt() {
	m.expires_at = nil
}

// SetIsRefreshing sets the "is_refreshing" field.
func (m *RouterCapabilityMutation) SetIsRefreshing(b bool) {
	m.is_refreshing = &b
}

// IsRefreshing returns the value of the "is_refreshing" field in the mutation.
func (m *RouterCapabilityMutation) IsRefreshing() (r bool, exists bool) {
	v := m.is_refreshing
	if v == nil {
		return
	}
	return *v, true
}

// OldIsRefreshing returns the old "is_refreshing" field's value of the RouterCapability entity.
// If the RouterCapability object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RouterCapabilityMutation) OldIsRefreshing(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsRefreshing is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsRefreshing requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsRefreshing: %w", err)
	}
	return oldValue.IsRefreshing, nil
}

// ResetIsRefreshing resets all changes to the "is_refreshing" field.
func (m *RouterCapabilityMutation) ResetIsRefreshing() {
	m.is_refreshing = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *RouterCapabilityMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *RouterCapabilityMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the RouterCapability entity.
// If the RouterCapability object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RouterCapabilityMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *RouterCapabilityMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *RouterCapabilityMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *RouterCapabilityMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the RouterCapability entity.
// If the RouterCapability object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RouterCapabilityMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *RouterCapabilityMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// Where appends a list predicates to the RouterCapabilityMutation builder.
func (m *RouterCapabilityMutation) Where(ps ...predicate.RouterCapability) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RouterCapabilityMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RouterCapabilityMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.RouterCapability, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RouterCapabilityMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RouterCapabilityMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (RouterCapability).
func (m *RouterCapabilityMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RouterCapabilityMutation) Fields() []string {
	fields := make([]string, 0, 27)
	if m.architecture != nil {
		fields = append(fields, routercapability.FieldArchitecture)
	}
	if m.model != nil {
		fields = append(fields, routercapability.FieldModel)
	}
	if m.board_name != nil {
		fields = append(fields, routercapability.FieldBoardName)
	}
	if m.total_memory != nil {
		fields = append(fields, routercapability.FieldTotalMemory)
	}
	if m.available_storage != nil {
		fields = append(fields, routercapability.FieldAvailableStorage)
	}
	if m.cpu_count != nil {
		fields = append(fields, routercapability.FieldCPUCount)
	}
	if m.has_wireless_chip != nil {
		fields = append(fields, routercapability.FieldHasWirelessChip)
	}
	if m.has_lte_module != nil {
		fields = append(fields, routercapability.FieldHasLteModule)
	}
	if m.version_raw != nil {
		fields = append(fields, routercapability.FieldVersionRaw)
	}
	if m.version_major != nil {
		fields = append(fields, routercapability.FieldVersionMajor)
	}
	if m.version_minor != nil {
		fields = append(fields, routercapability.FieldVersionMinor)
	}
	if m.version_patch != nil {
		fields = append(fields, routercapability.FieldVersionPatch)
	}
	if m.installed_packages != nil {
		fields = append(fields, routercapability.FieldInstalledPackages)
	}
	if m.license_level != nil {
		fields = append(fields, routercapability.FieldLicenseLevel)
	}
	if m.update_channel != nil {
		fields = append(fields, routercapability.FieldUpdateChannel)
	}
	if m.container_package_installed != nil {
		fields = append(fields, routercapability.FieldContainerPackageInstalled)
	}
	if m.container_enabled != nil {
		fields = append(fields, routercapability.FieldContainerEnabled)
	}
	if m.container_registry_configured != nil {
		fields = append(fields, routercapability.FieldContainerRegistryConfigured)
	}
	if m.container_storage_available != nil {
		fields = append(fields, routercapability.FieldContainerStorageAvailable)
	}
	if m.supports_network_namespace != nil {
		fields = append(fields, routercapability.FieldSupportsNetworkNamespace)
	}
	if m.max_containers != nil {
		fields = append(fields, routercapability.FieldMaxContainers)
	}
	if m.capability_entries != nil {
		fields = append(fields, routercapability.FieldCapabilityEntries)
	}
	if m.detected_at != nil {
		fields = append(fields, routercapability.FieldDetectedAt)
	}
	if m.expires_at != nil {
		fields = append(fields, routercapability.FieldExpiresAt)
	}
	if m.is_refreshing != nil {
		fields = append(fields, routercapability.FieldIsRefreshing)
	}
	if m.created_at != nil {
		fields = append(fields, routercapability.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, routercapability.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RouterCapabilityMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case routercapability.FieldArchitecture:
		return m.Architecture()
	case routercapability.FieldModel:
		return m.Model()
	case routercapability.FieldBoardName:
		return m.BoardName()
	case routercapability.FieldTotalMemory:
		return m.TotalMemory()
	case routercapability.FieldAvailableStorage:
		return m.AvailableStorage()
	case routercapability.FieldCPUCount:
		return m.CPUCount()
	case routercapability.FieldHasWirelessChip:
		return m.HasWirelessChip()
	case routercapability.FieldHasLteModule:
		return m.HasLteModule()
	case routercapability.FieldVersionRaw:
		return m.VersionRaw()
	case routercapability.FieldVersionMajor:
		return m.VersionMajor()
	case routercapability.FieldVersionMinor:
		return m.VersionMinor()
	case routercapability.FieldVersionPatch:
		return m.VersionPatch()
	case routercapability.FieldInstalledPackages:
		return m.InstalledPackages()
	case routercapability.FieldLicenseLevel:
		return m.LicenseLevel()
	case routercapability.FieldUpdateChannel:
		return m.UpdateChannel()
	case routercapability.FieldContainerPackageInstalled:
		return m.ContainerPackageInstalled()
	case routercapability.FieldContainerEnabled:
		return m.ContainerEnabled()
	case routercapability.FieldContainerRegistryConfigured:
		return m.ContainerRegistryConfigured()
	case routercapability.FieldContainerStorageAvailable:
		return m.ContainerStorageAvailable()
	case routercapability.FieldSupportsNetworkNamespace:
		return m.SupportsNetworkNamespace()
	case routercapability.FieldMaxContainers:
		return m.MaxContainers()
	case routercapability.FieldCapabilityEntries:
		return m.CapabilityEntries()
	case routercapability.FieldDetectedAt:
		return m.DetectedAt()
	case routercapability.FieldExpiresAt:
		return m.ExpiresAt()
	case routercapability.FieldIsRefreshing:
		return m.IsRefreshing()
	case routercapability.FieldCreatedAt:
		return m.CreatedAt()
	case routercapability.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RouterCapabilityMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case routercapability.FieldArchitecture:
		return m.OldArchitecture(ctx)
	case routercapability.FieldModel:
		return m.OldModel(ctx)
	case routercapability.FieldBoardName:
		return m.OldBoardName(ctx)
	case routercapability.FieldTotalMemory:
		return m.OldTotalMemory(ctx)
	case routercapability.FieldAvailableStorage:
		return m.OldAvailableStorage(ctx)
	case routercapability.FieldCPUCount:
		return m.OldCPUCount(ctx)
	case routercapability.FieldHasWirelessChip:
		return m.OldHasWirelessChip(ctx)
	case routercapability.FieldHasLteModule:
		return m.OldHasLteModule(ctx)
	case routercapability.FieldVersionRaw:
		return m.OldVersionRaw(ctx)
	case routercapability.FieldVersionMajor:
		return m.OldVersionMajor(ctx)
	case routercapability.FieldVersionMinor:
		return m.OldVersionMinor(ctx)
	case routercapability.FieldVersionPatch:
		return m.OldVersionPatch(ctx)
	case routercapability.FieldInstalledPackages:
		return m.OldInstalledPackages(ctx)
	case routercapability.FieldLicenseLevel:
		return m.OldLicenseLevel(ctx)
	case routercapability.FieldUpdateChannel:
		return m.OldUpdateChannel(ctx)
	case routercapability.FieldContainerPackageInstalled:
		return m.OldContainerPackageInstalled(ctx)
	case routercapability.FieldContainerEnabled:
		return m.OldContainerEnabled(ctx)
	case routercapability.FieldContainerRegistryConfigured:
		return m.OldContainerRegistryConfigured(ctx)
	case routercapability.FieldContainerStorageAvailable:
		return m.OldContainerStorageAvailable(ctx)
	case routercapability.FieldSupportsNetworkNamespace:
		return m.OldSupportsNetworkNamespace(ctx)
	case routercapability.FieldMaxContainers:
		return m.OldMaxContainers(ctx)
	case routercapability.FieldCapabilityEntries:
		return m.OldCapabilityEntries(ctx)
	case routercapability.FieldDetectedAt:
		return m.OldDetectedAt(ctx)
	case routercapability.FieldExpiresAt:
		return m.OldExpiresAt(ctx)
	case routercapability.FieldIsRefreshing:
		return m.OldIsRefreshing(ctx)
	case routercapability.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case routercapability.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown RouterCapability field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RouterCapabilityMutation) SetField(name string, value ent.Value) error {
	switch name {
	case routercapability.FieldArchitecture:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetArchitecture(v)
		return nil
	case routercapability.FieldModel:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModel(v)
		return nil
	case routercapability.FieldBoardName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBoardName(v)
		return nil
	case routercapability.FieldTotalMemory:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalMemory(v)
		return nil
	case routercapability.FieldAvailableStorage:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAvailableStorage(v)
		return nil
	case routercapability.FieldCPUCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCPUCount(v)
		return nil
	case routercapability.FieldHasWirelessChip:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHasWirelessChip(v)
		return nil
	case routercapability.FieldHasLteModule:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHasLteModule(v)
		return nil
	case routercapability.FieldVersionRaw:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersionRaw(v)
		return nil
	case routercapability.FieldVersionMajor:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersionMajor(v)
		return nil
	case routercapability.FieldVersionMinor:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersionMinor(v)
		return nil
	case routercapability.FieldVersionPatch:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersionPatch(v)
		return nil
	case routercapability.FieldInstalledPackages:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInstalledPackages(v)
		return nil
	case routercapability.FieldLicenseLevel:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLicenseLevel(v)
		return nil
	case routercapability.FieldUpdateChannel:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateChannel(v)
		return nil
	case routercapability.FieldContainerPackageInstalled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContainerPackageInstalled(v)
		return nil
	case routercapability.FieldContainerEnabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContainerEnabled(v)
		return nil
	case routercapability.FieldContainerRegistryConfigured:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContainerRegistryConfigured(v)
		return nil
	case routercapability.FieldContainerStorageAvailable:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContainerStorageAvailable(v)
		return nil
	case routercapability.FieldSupportsNetworkNamespace:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSupportsNetworkNamespace(v)
		return nil
	case routercapability.FieldMaxContainers:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaxContainers(v)
		return nil
	case routercapability.FieldCapabilityEntries:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCapabilityEntries(v)
		return nil
	case routercapability.FieldDetectedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDetectedAt(v)
		return nil
	case routercapability.FieldExpiresAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiresAt(v)
		return nil
	case routercapability.FieldIsRefreshing:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsRefreshing(v)
		return nil
	case routercapability.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case routercapability.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown RouterCapability field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RouterCapabilityMutation) AddedFields() []string {
	var fields []string
	if m.addtotal_memory != nil {
		fields = append(fields, routercapability.FieldTotalMemory)
	}
	if m.addavailable_storage != nil {
		fields = append(fields, routercapability.FieldAvailableStorage)
	}
	if m.addcpu_count != nil {
		fields = append(fields, routercapability.FieldCPUCount)
	}
	if m.addversion_major != nil {
		fields = append(fields, routercapability.FieldVersionMajor)
	}
	if m.addversion_minor != nil {
		fields = append(fields, routercapability.FieldVersionMinor)
	}
	if m.addversion_patch != nil {
		fields = append(fields, routercapability.FieldVersionPatch)
	}
	if m.addlicense_level != nil {
		fields = append(fields, routercapability.FieldLicenseLevel)
	}
	if m.addcontainer_storage_available != nil {
		fields = append(fields, routercapability.FieldContainerStorageAvailable)
	}
	if m.addmax_containers != nil {
		fields = append(fields, routercapability.FieldMaxContainers)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RouterCapabilityMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case routercapability.FieldTotalMemory:
		return m.AddedTotalMemory()
	case routercapability.FieldAvailableStorage:
		return m.AddedAvailableStorage()
	case routercapability.FieldCPUCount:
		return m.AddedCPUCount()
	case routercapability.FieldVersionMajor:
		return m.AddedVersionMajor()
	case routercapability.FieldVersionMinor:
		return m.AddedVersionMinor()
	case routercapability.FieldVersionPatch:
		return m.AddedVersionPatch()
	case routercapability.FieldLicenseLevel:
		return m.AddedLicenseLevel()
	case routercapability.FieldContainerStorageAvailable:
		return m.AddedContainerStorageAvailable()
	case routercapability.FieldMaxContainers:
		return m.AddedMaxContainers()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RouterCapabilityMutation) AddField(name string, value ent.Value) error {
	switch name {
	case routercapability.FieldTotalMemory:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotalMemory(v)
		return nil
	case routercapability.FieldAvailableStorage:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAvailableStorage(v)
		return nil
	case routercapability.FieldCPUCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCPUCount(v)
		return nil
	case routercapability.FieldVersionMajor:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVersionMajor(v)
		return nil
	case routercapability.FieldVersionMinor:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVersionMinor(v)
		return nil
	case routercapability.FieldVersionPatch:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVersionPatch(v)
		return nil
	case routercapability.FieldLicenseLevel:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLicenseLevel(v)
		return nil
	case routercapability.FieldContainerStorageAvailable:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddContainerStorageAvailable(v)
		return nil
	case routercapability.FieldMaxContainers:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMaxContainers(v)
		return nil
	}
	return fmt.Errorf("unknown RouterCapability numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RouterCapabilityMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(routercapability.FieldModel) {
		fields = append(fields, routercapability.FieldModel)
	}
	if m.FieldCleared(routercapability.FieldBoardName) {
		fields = append(fields, routercapability.FieldBoardName)
	}
	if m.FieldCleared(routercapability.FieldUpdateChannel) {
		fields = append(fields, routercapability.FieldUpdateChannel)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RouterCapabilityMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RouterCapabilityMutation) ClearField(name string) error {
	switch name {
	case routercapability.FieldModel:
		m.ClearModel()
		return nil
	case routercapability.FieldBoardName:
		m.ClearBoardName()
		return nil
	case routercapability.FieldUpdateChannel:
		m.ClearUpdateChannel()
		return nil
	}
	return fmt.Errorf("unknown RouterCapability nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RouterCapabilityMutation) ResetField(name string) error {
	switch name {
	case routercapability.FieldArchitecture:
		m.ResetArchitecture()
		return nil
	case routercapability.FieldModel:
		m.ResetModel()
		return nil
	case routercapability.FieldBoardName:
		m.ResetBoardName()
		return nil
	case routercapability.FieldTotalMemory:
		m.ResetTotalMemory()
		return nil
	case routercapability.FieldAvailableStorage:
		m.ResetAvailableStorage()
		return nil
	case routercapability.FieldCPUCount:
		m.ResetCPUCount()
		return nil
	case routercapability.FieldHasWirelessChip:
		m.ResetHasWirelessChip()
		return nil
	case routercapability.FieldHasLteModule:
		m.ResetHasLteModule()
		return nil
	case routercapability.FieldVersionRaw:
		m.ResetVersionRaw()
		return nil
	case routercapability.FieldVersionMajor:
		m.ResetVersionMajor()
		return nil
	case routercapability.FieldVersionMinor:
		m.ResetVersionMinor()
		return nil
	case routercapability.FieldVersionPatch:
		m.ResetVersionPatch()
		return nil
	case routercapability.FieldInstalledPackages:
		m.ResetInstalledPackages()
		return nil
	case routercapability.FieldLicenseLevel:
		m.ResetLicenseLevel()
		return nil
	case routercapability.FieldUpdateChannel:
		m.ResetUpdateChannel()
		return nil
	case routercapability.FieldContainerPackageInstalled:
		m.ResetContainerPackageInstalled()
		return nil
	case routercapability.FieldContainerEnabled:
		m.ResetContainerEnabled()
		return nil
	case routercapability.FieldContainerRegistryConfigured:
		m.ResetContainerRegistryConfigured()
		return nil
	case routercapability.FieldContainerStorageAvailable:
		m.ResetContainerStorageAvailable()
		return nil
	case routercapability.FieldSupportsNetworkNamespace:
		m.ResetSupportsNetworkNamespace()
		return nil
	case routercapability.FieldMaxContainers:
		m.ResetMaxContainers()
		return nil
	case routercapability.FieldCapabilityEntries:
		m.ResetCapabilityEntries()
		return nil
	case routercapability.FieldDetectedAt:
		m.ResetDetectedAt()
		return nil
	case routercapability.FieldExpiresAt:
		m.ResetExpiresAt()
		return nil
	case routercapability.FieldIsRefreshing:
		m.ResetIsRefreshing()
		return nil
	case routercapability.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case routercapability.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown RouterCapability field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RouterCapabilityMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RouterCapabilityMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RouterCapabilityMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RouterCapabilityMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RouterCapabilityMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RouterCapabilityMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RouterCapabilityMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown RouterCapability unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RouterCapabilityMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown RouterCapability edge %s", name)
}

// RouterSecretMutation represents an operation that mutates the RouterSecret nodes in the graph.
type RouterSecretMutation struct {
	config
	op                 Op
	typ                string
	id                 *string
	encrypted_username *[]byte
	encrypted_password *[]byte
	encryption_nonce   *[]byte
	key_version        *int
	addkey_version     *int
	created_at         *time.Time
	updated_at         *time.Time
	clearedFields      map[string]struct{}
	router             *string
	clearedrouter      bool
	done               bool
	oldValue           func(context.Context) (*RouterSecret, error)
	predicates         []predicate.RouterSecret
}

var _ ent.Mutation = (*RouterSecretMutation)(nil)

// routersecretOption allows management of the mutation configuration using functional options.
type routersecretOption func(*RouterSecretMutation)

// newRouterSecretMutation creates new mutation for the RouterSecret entity.
func newRouterSecretMutation(c config, op Op, opts ...routersecretOption) *RouterSecretMutation {
	m := &RouterSecretMutation{
		config:        c,
		op:            op,
		typ:           TypeRouterSecret,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRouterSecretID sets the ID field of the mutation.
func withRouterSecretID(id string) routersecretOption {
	return func(m *RouterSecretMutation) {
		var (
			err   error
			once  sync.Once
			value *RouterSecret
		)
		m.oldValue = func(ctx context.Context) (*RouterSecret, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().RouterSecret.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRouterSecret sets the old RouterSecret of the mutation.
func withRouterSecret(node *RouterSecret) routersecretOption {
	return func(m *RouterSecretMutation) {
		m.oldValue = func(context.Context) (*RouterSecret, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RouterSecretMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RouterSecretMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of RouterSecret entities.
func (m *RouterSecretMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RouterSecretMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RouterSecretMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().RouterSecret.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetRouterID sets the "router_id" field.
func (m *RouterSecretMutation) SetRouterID(s string) {
	m.router = &s
}

// RouterID returns the value of the "router_id" field in the mutation.
func (m *RouterSecretMutation) RouterID() (r string, exists bool) {
	v := m.router
	if v == nil {
		return
	}
	return *v, true
}

// OldRouterID returns the old "router_id" field's value of the RouterSecret entity.
// If the RouterSecret object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RouterSecretMutation) OldRouterID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRouterID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRouterID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRouterID: %w", err)
	}
	return oldValue.RouterID, nil
}

// ResetRouterID resets all changes to the "router_id" field.
func (m *RouterSecretMutation) ResetRouterID() {
	m.router = nil
}

// SetEncryptedUsername sets the "encrypted_username" field.
func (m *RouterSecretMutation) SetEncryptedUsername(b []byte) {
	m.encrypted_username = &b
}

// EncryptedUsername returns the value of the "encrypted_username" field in the mutation.
func (m *RouterSecretMutation) EncryptedUsername() (r []byte, exists bool) {
	v := m.encrypted_username
	if v == nil {
		return
	}
	return *v, true
}

// OldEncryptedUsername returns the old "encrypted_username" field's value of the RouterSecret entity.
// If the RouterSecret object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RouterSecretMutation) OldEncryptedUsername(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEncryptedUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEncryptedUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEncryptedUsername: %w", err)
	}
	return oldValue.EncryptedUsername, nil
}

// ResetEncryptedUsername resets all changes to the "encrypted_username" field.
func (m *RouterSecretMutation) ResetEncryptedUsername() {
	m.encrypted_username = nil
}

// SetEncryptedPassword sets the "encrypted_password" field.
func (m *RouterSecretMutation) SetEncryptedPassword(b []byte) {
	m.encrypted_password = &b
}

// EncryptedPassword returns the value of the "encrypted_password" field in the mutation.
func (m *RouterSecretMutation) EncryptedPassword() (r []byte, exists bool) {
	v := m.encrypted_password
	if v == nil {
		return
	}
	return *v, true
}

// OldEncryptedPassword returns the old "encrypted_password" field's value of the RouterSecret entity.
// If the RouterSecret object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RouterSecretMutation) OldEncryptedPassword(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEncryptedPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEncryptedPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEncryptedPassword: %w", err)
	}
	return oldValue.EncryptedPassword, nil
}

// ResetEncryptedPassword resets all changes to the "encrypted_password" field.
func (m *RouterSecretMutation) ResetEncryptedPassword() {
	m.encrypted_password = nil
}

// SetEncryptionNonce sets the "encryption_nonce" field.
func (m *RouterSecretMutation) SetEncryptionNonce(b []byte) {
	m.encryption_nonce = &b
}

// EncryptionNonce returns the value of the "encryption_nonce" field in the mutation.
func (m *RouterSecretMutation) EncryptionNonce() (r []byte, exists bool) {
	v := m.encryption_nonce
	if v == nil {
		return
	}
	return *v, true
}

// OldEncryptionNonce returns the old "encryption_nonce" field's value of the RouterSecret entity.
// If the RouterSecret object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RouterSecretMutation) OldEncryptionNonce(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEncryptionNonce is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEncryptionNonce requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEncryptionNonce: %w", err)
	}
	return oldValue.EncryptionNonce, nil
}

// ResetEncryptionNonce resets all changes to the "encryption_nonce" field.
func (m *RouterSecretMutation) ResetEncryptionNonce() {
	m.encryption_nonce = nil
}

// SetKeyVersion sets the "key_version" field.
func (m *RouterSecretMutation) SetKeyVersion(i int) {
	m.key_version = &i
	m.addkey_version = nil
}

// KeyVersion returns the value of the "key_version" field in the mutation.
func (m *RouterSecretMutation) KeyVersion() (r int, exists bool) {
	v := m.key_version
	if v == nil {
		return
	}
	return *v, true
}

// OldKeyVersion returns the old "key_version" field's value of the RouterSecret entity.
// If the RouterSecret object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RouterSecretMutation) OldKeyVersion(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKeyVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKeyVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKeyVersion: %w", err)
	}
	return oldValue.KeyVersion, nil
}

// AddKeyVersion adds i to the "key_version" field.
func (m *RouterSecretMutation) AddKeyVersion(i int) {
	if m.addkey_version != nil {
		*m.addkey_version += i
	} else {
		m.addkey_version = &i
	}
}

// AddedKeyVersion returns the value that was added to the "key_version" field in this mutation.
func (m *RouterSecretMutation) AddedKeyVersion() (r int, exists bool) {
	v := m.addkey_version
	if v == nil {
		return
	}
	return *v, true
}

// ResetKeyVersion resets all changes to the "key_version" field.
func (m *RouterSecretMutation) ResetKeyVersion() {
	m.key_version = nil
	m.addkey_version = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *RouterSecretMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *RouterSecretMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the RouterSecret entity.
// If the RouterSecret object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RouterSecretMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *RouterSecretMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *RouterSecretMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *RouterSecretMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the RouterSecret entity.
// If the RouterSecret object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RouterSecretMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *RouterSecretMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearRouter clears the "router" edge to the Router entity.
func (m *RouterSecretMutation) ClearRouter() {
	m.clearedrouter = true
	m.clearedFields[routersecret.FieldRouterID] = struct{}{}
}

// RouterCleared reports if the "router" edge to the Router entity was cleared.
func (m *RouterSecretMutation) RouterCleared() bool {
	return m.clearedrouter
}

// RouterIDs returns the "router" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RouterID instead. It exists only for internal usage by the builders.
func (m *RouterSecretMutation) RouterIDs() (ids []string) {
	if id := m.router; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRouter resets all changes to the "router" edge.
func (m *RouterSecretMutation) ResetRouter() {
	m.router = nil
	m.clearedrouter = false
}

// Where appends a list predicates to the RouterSecretMutation builder.
func (m *RouterSecretMutation) Where(ps ...predicate.RouterSecret) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RouterSecretMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RouterSecretMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.RouterSecret, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RouterSecretMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RouterSecretMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (RouterSecret).
func (m *RouterSecretMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RouterSecretMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.router != nil {
		fields = append(fields, routersecret.FieldRouterID)
	}
	if m.encrypted_username != nil {
		fields = append(fields, routersecret.FieldEncryptedUsername)
	}
	if m.encrypted_password != nil {
		fields = append(fields, routersecret.FieldEncryptedPassword)
	}
	if m.encryption_nonce != nil {
		fields = append(fields, routersecret.FieldEncryptionNonce)
	}
	if m.key_version != nil {
		fields = append(fields, routersecret.FieldKeyVersion)
	}
	if m.created_at != nil {
		fields = append(fields, routersecret.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, routersecret.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RouterSecretMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case routersecret.FieldRouterID:
		return m.RouterID()
	case routersecret.FieldEncryptedUsername:
		return m.EncryptedUsername()
	case routersecret.FieldEncryptedPassword:
		return m.EncryptedPassword()
	case routersecret.FieldEncryptionNonce:
		return m.EncryptionNonce()
	case routersecret.FieldKeyVersion:
		return m.KeyVersion()
	case routersecret.FieldCreatedAt:
		return m.CreatedAt()
	case routersecret.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RouterSecretMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case routersecret.FieldRouterID:
		return m.OldRouterID(ctx)
	case routersecret.FieldEncryptedUsername:
		return m.OldEncryptedUsername(ctx)
	case routersecret.FieldEncryptedPassword:
		return m.OldEncryptedPassword(ctx)
	case routersecret.FieldEncryptionNonce:
		return m.OldEncryptionNonce(ctx)
	case routersecret.FieldKeyVersion:
		return m.OldKeyVersion(ctx)
	case routersecret.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case routersecret.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown RouterSecret field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RouterSecretMutation) SetField(name string, value ent.Value) error {
	switch name {
	case routersecret.FieldRouterID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRouterID(v)
		return nil
	case routersecret.FieldEncryptedUsername:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEncryptedUsername(v)
		return nil
	case routersecret.FieldEncryptedPassword:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEncryptedPassword(v)
		return nil
	case routersecret.FieldEncryptionNonce:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEncryptionNonce(v)
		return nil
	case routersecret.FieldKeyVersion:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKeyVersion(v)
		return nil
	case routersecret.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case routersecret.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown RouterSecret field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RouterSecretMutation) AddedFields() []string {
	var fields []string
	if m.addkey_version != nil {
		fields = append(fields, routersecret.FieldKeyVersion)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RouterSecretMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case routersecret.FieldKeyVersion:
		return m.AddedKeyVersion()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RouterSecretMutation) AddField(name string, value ent.Value) error {
	switch name {
	case routersecret.FieldKeyVersion:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddKeyVersion(v)
		return nil
	}
	return fmt.Errorf("unknown RouterSecret numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RouterSecretMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RouterSecretMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RouterSecretMutation) ClearField(name string) error {
	return fmt.Errorf("unknown RouterSecret nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RouterSecretMutation) ResetField(name string) error {
	switch name {
	case routersecret.FieldRouterID:
		m.ResetRouterID()
		return nil
	case routersecret.FieldEncryptedUsername:
		m.ResetEncryptedUsername()
		return nil
	case routersecret.FieldEncryptedPassword:
		m.ResetEncryptedPassword()
		return nil
	case routersecret.FieldEncryptionNonce:
		m.ResetEncryptionNonce()
		return nil
	case routersecret.FieldKeyVersion:
		m.ResetKeyVersion()
		return nil
	case routersecret.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case routersecret.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown RouterSecret field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RouterSecretMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.router != nil {
		edges = append(edges, routersecret.EdgeRouter)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RouterSecretMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case routersecret.EdgeRouter:
		if id := m.router; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RouterSecretMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RouterSecretMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RouterSecretMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedrouter {
		edges = append(edges, routersecret.EdgeRouter)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RouterSecretMutation) EdgeCleared(name string) bool {
	switch name {
	case routersecret.EdgeRouter:
		return m.clearedrouter
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RouterSecretMutation) ClearEdge(name string) error {
	switch name {
	case routersecret.EdgeRouter:
		m.ClearRouter()
		return nil
	}
	return fmt.Errorf("unknown RouterSecret unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RouterSecretMutation) ResetEdge(name string) error {
	switch name {
	case routersecret.EdgeRouter:
		m.ResetRouter()
		return nil
	}
	return fmt.Errorf("unknown RouterSecret edge %s", name)
}

// RoutingChainMutation represents an operation that mutates the RoutingChain nodes in the graph.
type RoutingChainMutation struct {
	config
	op                       Op
	typ                      string
	id                       *string
	device_id                *string
	device_mac               *string
	device_ip                *string
	device_name              *string
	routing_mode             *routingchain.RoutingMode
	active                   *bool
	kill_switch_enabled      *bool
	kill_switch_mode         *routingchain.KillSwitchMode
	kill_switch_active       *bool
	kill_switch_activated_at *time.Time
	created_at               *time.Time
	updated_at               *time.Time
	clearedFields            map[string]struct{}
	router                   *string
	clearedrouter            bool
	hops                     map[string]struct{}
	removedhops              map[string]struct{}
	clearedhops              bool
	done                     bool
	oldValue                 func(context.Context) (*RoutingChain, error)
	predicates               []predicate.RoutingChain
}

var _ ent.Mutation = (*RoutingChainMutation)(nil)

// routingchainOption allows management of the mutation configuration using functional options.
type routingchainOption func(*RoutingChainMutation)

// newRoutingChainMutation creates new mutation for the RoutingChain entity.
func newRoutingChainMutation(c config, op Op, opts ...routingchainOption) *RoutingChainMutation {
	m := &RoutingChainMutation{
		config:        c,
		op:            op,
		typ:           TypeRoutingChain,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRoutingChainID sets the ID field of the mutation.
func withRoutingChainID(id string) routingchainOption {
	return func(m *RoutingChainMutation) {
		var (
			err   error
			once  sync.Once
			value *RoutingChain
		)
		m.oldValue = func(ctx context.Context) (*RoutingChain, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().RoutingChain.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRoutingChain sets the old RoutingChain of the mutation.
func withRoutingChain(node *RoutingChain) routingchainOption {
	return func(m *RoutingChainMutation) {
		m.oldValue = func(context.Context) (*RoutingChain, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RoutingChainMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RoutingChainMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of RoutingChain entities.
func (m *RoutingChainMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RoutingChainMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RoutingChainMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().RoutingChain.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetRouterID sets the "router_id" field.
func (m *RoutingChainMutation) SetRouterID(s string) {
	m.router = &s
}

// RouterID returns the value of the "router_id" field in the mutation.
func (m *RoutingChainMutation) RouterID() (r string, exists bool) {
	v := m.router
	if v == nil {
		return
	}
	return *v, true
}

// OldRouterID returns the old "router_id" field's value of the RoutingChain entity.
// If the RoutingChain object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoutingChainMutation) OldRouterID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRouterID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRouterID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRouterID: %w", err)
	}
	return oldValue.RouterID, nil
}

// ResetRouterID resets all changes to the "router_id" field.
func (m *RoutingChainMutation) ResetRouterID() {
	m.router = nil
}

// SetDeviceID sets the "device_id" field.
func (m *RoutingChainMutation) SetDeviceID(s string) {
	m.device_id = &s
}

// DeviceID returns the value of the "device_id" field in the mutation.
func (m *RoutingChainMutation) DeviceID() (r string, exists bool) {
	v := m.device_id
	if v == nil {
		return
	}
	return *v, true
}

// OldDeviceID returns the old "device_id" field's value of the RoutingChain entity.
// If the RoutingChain object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoutingChainMutation) OldDeviceID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeviceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeviceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeviceID: %w", err)
	}
	return oldValue.DeviceID, nil
}

// ResetDeviceID resets all changes to the "device_id" field.
func (m *RoutingChainMutation) ResetDeviceID() {
	m.device_id = nil
}

// SetDeviceMAC sets the "device_mac" field.
func (m *RoutingChainMutation) SetDeviceMAC(s string) {
	m.device_mac = &s
}

// DeviceMAC returns the value of the "device_mac" field in the mutation.
func (m *RoutingChainMutation) DeviceMAC() (r string, exists bool) {
	v := m.device_mac
	if v == nil {
		return
	}
	return *v, true
}

// OldDeviceMAC returns the old "device_mac" field's value of the RoutingChain entity.
// If the RoutingChain object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoutingChainMutation) OldDeviceMAC(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeviceMAC is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeviceMAC requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeviceMAC: %w", err)
	}
	return oldValue.DeviceMAC, nil
}

// ClearDeviceMAC clears the value of the "device_mac" field.
func (m *RoutingChainMutation) ClearDeviceMAC() {
	m.device_mac = nil
	m.clearedFields[routingchain.FieldDeviceMAC] = struct{}{}
}

// DeviceMACCleared returns if the "device_mac" field was cleared in this mutation.
func (m *RoutingChainMutation) DeviceMACCleared() bool {
	_, ok := m.clearedFields[routingchain.FieldDeviceMAC]
	return ok
}

// ResetDeviceMAC resets all changes to the "device_mac" field.
func (m *RoutingChainMutation) ResetDeviceMAC() {
	m.device_mac = nil
	delete(m.clearedFields, routingchain.FieldDeviceMAC)
}

// SetDeviceIP sets the "device_ip" field.
func (m *RoutingChainMutation) SetDeviceIP(s string) {
	m.device_ip = &s
}

// DeviceIP returns the value of the "device_ip" field in the mutation.
func (m *RoutingChainMutation) DeviceIP() (r string, exists bool) {
	v := m.device_ip
	if v == nil {
		return
	}
	return *v, true
}

// OldDeviceIP returns the old "device_ip" field's value of the RoutingChain entity.
// If the RoutingChain object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoutingChainMutation) OldDeviceIP(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeviceIP is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeviceIP requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeviceIP: %w", err)
	}
	return oldValue.DeviceIP, nil
}

// ClearDeviceIP clears the value of the "device_ip" field.
func (m *RoutingChainMutation) ClearDeviceIP() {
	m.device_ip = nil
	m.clearedFields[routingchain.FieldDeviceIP] = struct{}{}
}

// DeviceIPCleared returns if the "device_ip" field was cleared in this mutation.
func (m *RoutingChainMutation) DeviceIPCleared() bool {
	_, ok := m.clearedFields[routingchain.FieldDeviceIP]
	return ok
}

// ResetDeviceIP resets all changes to the "device_ip" field.
func (m *RoutingChainMutation) ResetDeviceIP() {
	m.device_ip = nil
	delete(m.clearedFields, routingchain.FieldDeviceIP)
}

// SetDeviceName sets the "device_name" field.
func (m *RoutingChainMutation) SetDeviceName(s string) {
	m.device_name = &s
}

// DeviceName returns the value of the "device_name" field in the mutation.
func (m *RoutingChainMutation) DeviceName() (r string, exists bool) {
	v := m.device_name
	if v == nil {
		return
	}
	return *v, true
}

// OldDeviceName returns the old "device_name" field's value of the RoutingChain entity.
// If the RoutingChain object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoutingChainMutation) OldDeviceName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeviceName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeviceName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeviceName: %w", err)
	}
	return oldValue.DeviceName, nil
}

// ClearDeviceName clears the value of the "device_name" field.
func (m *RoutingChainMutation) ClearDeviceName() {
	m.device_name = nil
	m.clearedFields[routingchain.FieldDeviceName] = struct{}{}
}

// DeviceNameCleared returns if the "device_name" field was cleared in this mutation.
func (m *RoutingChainMutation) DeviceNameCleared() bool {
	_, ok := m.clearedFields[routingchain.FieldDeviceName]
	return ok
}

// ResetDeviceName resets all changes to the "device_name" field.
func (m *RoutingChainMutation) ResetDeviceName() {
	m.device_name = nil
	delete(m.clearedFields, routingchain.FieldDeviceName)
}

// SetRoutingMode sets the "routing_mode" field.
func (m *RoutingChainMutation) SetRoutingMode(rm routingchain.RoutingMode) {
	m.routing_mode = &rm
}

// RoutingMode returns the value of the "routing_mode" field in the mutation.
func (m *RoutingChainMutation) RoutingMode() (r routingchain.RoutingMode, exists bool) {
	v := m.routing_mode
	if v == nil {
		return
	}
	return *v, true
}

// OldRoutingMode returns the old "routing_mode" field's value of the RoutingChain entity.
// If the RoutingChain object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoutingChainMutation) OldRoutingMode(ctx context.Context) (v routingchain.RoutingMode, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRoutingMode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRoutingMode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRoutingMode: %w", err)
	}
	return oldValue.RoutingMode, nil
}

// ResetRoutingMode resets all changes to the "routing_mode" field.
func (m *RoutingChainMutation) ResetRoutingMode() {
	m.routing_mode = nil
}

// SetActive sets the "active" field.
func (m *RoutingChainMutation) SetActive(b bool) {
	m.active = &b
}

// Active returns the value of the "active" field in the mutation.
func (m *RoutingChainMutation) Active() (r bool, exists bool) {
	v := m.active
	if v == nil {
		return
	}
	return *v, true
}

// OldActive returns the old "active" field's value of the RoutingChain entity.
// If the RoutingChain object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoutingChainMutation) OldActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActive: %w", err)
	}
	return oldValue.Active, nil
}

// ResetActive resets all changes to the "active" field.
func (m *RoutingChainMutation) ResetActive() {
	m.active = nil
}

// SetKillSwitchEnabled sets the "kill_switch_enabled" field.
func (m *RoutingChainMutation) SetKillSwitchEnabled(b bool) {
	m.kill_switch_enabled = &b
}

// KillSwitchEnabled returns the value of the "kill_switch_enabled" field in the mutation.
func (m *RoutingChainMutation) KillSwitchEnabled() (r bool, exists bool) {
	v := m.kill_switch_enabled
	if v == nil {
		return
	}
	return *v, true
}

// OldKillSwitchEnabled returns the old "kill_switch_enabled" field's value of the RoutingChain entity.
// If the RoutingChain object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoutingChainMutation) OldKillSwitchEnabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKillSwitchEnabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKillSwitchEnabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKillSwitchEnabled: %w", err)
	}
	return oldValue.KillSwitchEnabled, nil
}

// ResetKillSwitchEnabled resets all changes to the "kill_switch_enabled" field.
func (m *RoutingChainMutation) ResetKillSwitchEnabled() {
	m.kill_switch_enabled = nil
}

// SetKillSwitchMode sets the "kill_switch_mode" field.
func (m *RoutingChainMutation) SetKillSwitchMode(rsm routingchain.KillSwitchMode) {
	m.kill_switch_mode = &rsm
}

// KillSwitchMode returns the value of the "kill_switch_mode" field in the mutation.
func (m *RoutingChainMutation) KillSwitchMode() (r routingchain.KillSwitchMode, exists bool) {
	v := m.kill_switch_mode
	if v == nil {
		return
	}
	return *v, true
}

// OldKillSwitchMode returns the old "kill_switch_mode" field's value of the RoutingChain entity.
// If the RoutingChain object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoutingChainMutation) OldKillSwitchMode(ctx context.Context) (v routingchain.KillSwitchMode, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKillSwitchMode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKillSwitchMode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKillSwitchMode: %w", err)
	}
	return oldValue.KillSwitchMode, nil
}

// ResetKillSwitchMode resets all changes to the "kill_switch_mode" field.
func (m *RoutingChainMutation) ResetKillSwitchMode() {
	m.kill_switch_mode = nil
}

// SetKillSwitchActive sets the "kill_switch_active" field.
func (m *RoutingChainMutation) SetKillSwitchActive(b bool) {
	m.kill_switch_active = &b
}

// KillSwitchActive returns the value of the "kill_switch_active" field in the mutation.
func (m *RoutingChainMutation) KillSwitchActive() (r bool, exists bool) {
	v := m.kill_switch_active
	if v == nil {
		return
	}
	return *v, true
}

// OldKillSwitchActive returns the old "kill_switch_active" field's value of the RoutingChain entity.
// If the RoutingChain object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoutingChainMutation) OldKillSwitchActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKillSwitchActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKillSwitchActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKillSwitchActive: %w", err)
	}
	return oldValue.KillSwitchActive, nil
}

// ResetKillSwitchActive resets all changes to the "kill_switch_active" field.
func (m *RoutingChainMutation) ResetKillSwitchActive() {
	m.kill_switch_active = nil
}

// SetKillSwitchActivatedAt sets the "kill_switch_activated_at" field.
func (m *RoutingChainMutation) SetKillSwitchActivatedAt(t time.Time) {
	m.kill_switch_activated_at = &t
}

// KillSwitchActivatedAt returns the value of the "kill_switch_activated_at" field in the mutation.
func (m *RoutingChainMutation) KillSwitchActivatedAt() (r time.Time, exists bool) {
	v := m.kill_switch_activated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldKillSwitchActivatedAt returns the old "kill_switch_activated_at" field's value of the RoutingChain entity.
// If the RoutingChain object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoutingChainMutation) OldKillSwitchActivatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKillSwitchActivatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKillSwitchActivatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKillSwitchActivatedAt: %w", err)
	}
	return oldValue.KillSwitchActivatedAt, nil
}

// ClearKillSwitchActivatedAt clears the value of the "kill_switch_activated_at" field.
func (m *RoutingChainMutation) ClearKillSwitchActivatedAt() {
	m.kill_switch_activated_at = nil
	m.clearedFields[routingchain.FieldKillSwitchActivatedAt] = struct{}{}
}

// KillSwitchActivatedAtCleared returns if the "kill_switch_activated_at" field was cleared in this mutation.
func (m *RoutingChainMutation) KillSwitchActivatedAtCleared() bool {
	_, ok := m.clearedFields[routingchain.FieldKillSwitchActivatedAt]
	return ok
}

// ResetKillSwitchActivatedAt resets all changes to the "kill_switch_activated_at" field.
func (m *RoutingChainMutation) ResetKillSwitchActivatedAt() {
	m.kill_switch_activated_at = nil
	delete(m.clearedFields, routingchain.FieldKillSwitchActivatedAt)
}

// SetCreatedAt sets the "created_at" field.
func (m *RoutingChainMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *RoutingChainMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the RoutingChain entity.
// If the RoutingChain object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoutingChainMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *RoutingChainMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *RoutingChainMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *RoutingChainMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the RoutingChain entity.
// If the RoutingChain object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoutingChainMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *RoutingChainMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearRouter clears the "router" edge to the Router entity.
func (m *RoutingChainMutation) ClearRouter() {
	m.clearedrouter = true
	m.clearedFields[routingchain.FieldRouterID] = struct{}{}
}

// RouterCleared reports if the "router" edge to the Router entity was cleared.
func (m *RoutingChainMutation) RouterCleared() bool {
	return m.clearedrouter
}

// RouterIDs returns the "router" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RouterID instead. It exists only for internal usage by the builders.
func (m *RoutingChainMutation) RouterIDs() (ids []string) {
	if id := m.router; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRouter resets all changes to the "router" edge.
func (m *RoutingChainMutation) ResetRouter() {
	m.router = nil
	m.clearedrouter = false
}

// AddHopIDs adds the "hops" edge to the ChainHop entity by ids.
func (m *RoutingChainMutation) AddHopIDs(ids ...string) {
	if m.hops == nil {
		m.hops = make(map[string]struct{})
	}
	for i := range ids {
		m.hops[ids[i]] = struct{}{}
	}
}

// ClearHops clears the "hops" edge to the ChainHop entity.
func (m *RoutingChainMutation) ClearHops() {
	m.clearedhops = true
}

// HopsCleared reports if the "hops" edge to the ChainHop entity was cleared.
func (m *RoutingChainMutation) HopsCleared() bool {
	return m.clearedhops
}

// RemoveHopIDs removes the "hops" edge to the ChainHop entity by IDs.
func (m *RoutingChainMutation) RemoveHopIDs(ids ...string) {
	if m.removedhops == nil {
		m.removedhops = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.hops, ids[i])
		m.removedhops[ids[i]] = struct{}{}
	}
}

// RemovedHops returns the removed IDs of the "hops" edge to the ChainHop entity.
func (m *RoutingChainMutation) RemovedHopsIDs() (ids []string) {
	for id := range m.removedhops {
		ids = append(ids, id)
	}
	return
}

// HopsIDs returns the "hops" edge IDs in the mutation.
func (m *RoutingChainMutation) HopsIDs() (ids []string) {
	for id := range m.hops {
		ids = append(ids, id)
	}
	return
}

// ResetHops resets all changes to the "hops" edge.
func (m *RoutingChainMutation) ResetHops() {
	m.hops = nil
	m.clearedhops = false
	m.removedhops = nil
}

// Where appends a list predicates to the RoutingChainMutation builder.
func (m *RoutingChainMutation) Where(ps ...predicate.RoutingChain) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RoutingChainMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RoutingChainMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.RoutingChain, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RoutingChainMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RoutingChainMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (RoutingChain).
func (m *RoutingChainMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RoutingChainMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.router != nil {
		fields = append(fields, routingchain.FieldRouterID)
	}
	if m.device_id != nil {
		fields = append(fields, routingchain.FieldDeviceID)
	}
	if m.device_mac != nil {
		fields = append(fields, routingchain.FieldDeviceMAC)
	}
	if m.device_ip != nil {
		fields = append(fields, routingchain.FieldDeviceIP)
	}
	if m.device_name != nil {
		fields = append(fields, routingchain.FieldDeviceName)
	}
	if m.routing_mode != nil {
		fields = append(fields, routingchain.FieldRoutingMode)
	}
	if m.active != nil {
		fields = append(fields, routingchain.FieldActive)
	}
	if m.kill_switch_enabled != nil {
		fields = append(fields, routingchain.FieldKillSwitchEnabled)
	}
	if m.kill_switch_mode != nil {
		fields = append(fields, routingchain.FieldKillSwitchMode)
	}
	if m.kill_switch_active != nil {
		fields = append(fields, routingchain.FieldKillSwitchActive)
	}
	if m.kill_switch_activated_at != nil {
		fields = append(fields, routingchain.FieldKillSwitchActivatedAt)
	}
	if m.created_at != nil {
		fields = append(fields, routingchain.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, routingchain.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RoutingChainMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case routingchain.FieldRouterID:
		return m.RouterID()
	case routingchain.FieldDeviceID:
		return m.DeviceID()
	case routingchain.FieldDeviceMAC:
		return m.DeviceMAC()
	case routingchain.FieldDeviceIP:
		return m.DeviceIP()
	case routingchain.FieldDeviceName:
		return m.DeviceName()
	case routingchain.FieldRoutingMode:
		return m.RoutingMode()
	case routingchain.FieldActive:
		return m.Active()
	case routingchain.FieldKillSwitchEnabled:
		return m.KillSwitchEnabled()
	case routingchain.FieldKillSwitchMode:
		return m.KillSwitchMode()
	case routingchain.FieldKillSwitchActive:
		return m.KillSwitchActive()
	case routingchain.FieldKillSwitchActivatedAt:
		return m.KillSwitchActivatedAt()
	case routingchain.FieldCreatedAt:
		return m.CreatedAt()
	case routingchain.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RoutingChainMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case routingchain.FieldRouterID:
		return m.OldRouterID(ctx)
	case routingchain.FieldDeviceID:
		return m.OldDeviceID(ctx)
	case routingchain.FieldDeviceMAC:
		return m.OldDeviceMAC(ctx)
	case routingchain.FieldDeviceIP:
		return m.OldDeviceIP(ctx)
	case routingchain.FieldDeviceName:
		return m.OldDeviceName(ctx)
	case routingchain.FieldRoutingMode:
		return m.OldRoutingMode(ctx)
	case routingchain.FieldActive:
		return m.OldActive(ctx)
	case routingchain.FieldKillSwitchEnabled:
		return m.OldKillSwitchEnabled(ctx)
	case routingchain.FieldKillSwitchMode:
		return m.OldKillSwitchMode(ctx)
	case routingchain.FieldKillSwitchActive:
		return m.OldKillSwitchActive(ctx)
	case routingchain.FieldKillSwitchActivatedAt:
		return m.OldKillSwitchActivatedAt(ctx)
	case routingchain.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case routingchain.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown RoutingChain field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RoutingChainMutation) SetField(name string, value ent.Value) error {
	switch name {
	case routingchain.FieldRouterID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRouterID(v)
		return nil
	case routingchain.FieldDeviceID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeviceID(v)
		return nil
	case routingchain.FieldDeviceMAC:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeviceMAC(v)
		return nil
	case routingchain.FieldDeviceIP:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeviceIP(v)
		return nil
	case routingchain.FieldDeviceName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeviceName(v)
		return nil
	case routingchain.FieldRoutingMode:
		v, ok := value.(routingchain.RoutingMode)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRoutingMode(v)
		return nil
	case routingchain.FieldActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActive(v)
		return nil
	case routingchain.FieldKillSwitchEnabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKillSwitchEnabled(v)
		return nil
	case routingchain.FieldKillSwitchMode:
		v, ok := value.(routingchain.KillSwitchMode)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKillSwitchMode(v)
		return nil
	case routingchain.FieldKillSwitchActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKillSwitchActive(v)
		return nil
	case routingchain.FieldKillSwitchActivatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKillSwitchActivatedAt(v)
		return nil
	case routingchain.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case routingchain.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown RoutingChain field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RoutingChainMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RoutingChainMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RoutingChainMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown RoutingChain numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RoutingChainMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(routingchain.FieldDeviceMAC) {
		fields = append(fields, routingchain.FieldDeviceMAC)
	}
	if m.FieldCleared(routingchain.FieldDeviceIP) {
		fields = append(fields, routingchain.FieldDeviceIP)
	}
	if m.FieldCleared(routingchain.FieldDeviceName) {
		fields = append(fields, routingchain.FieldDeviceName)
	}
	if m.FieldCleared(routingchain.FieldKillSwitchActivatedAt) {
		fields = append(fields, routingchain.FieldKillSwitchActivatedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RoutingChainMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RoutingChainMutation) ClearField(name string) error {
	switch name {
	case routingchain.FieldDeviceMAC:
		m.ClearDeviceMAC()
		return nil
	case routingchain.FieldDeviceIP:
		m.ClearDeviceIP()
		return nil
	case routingchain.FieldDeviceName:
		m.ClearDeviceName()
		return nil
	case routingchain.FieldKillSwitchActivatedAt:
		m.ClearKillSwitchActivatedAt()
		return nil
	}
	return fmt.Errorf("unknown RoutingChain nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RoutingChainMutation) ResetField(name string) error {
	switch name {
	case routingchain.FieldRouterID:
		m.ResetRouterID()
		return nil
	case routingchain.FieldDeviceID:
		m.ResetDeviceID()
		return nil
	case routingchain.FieldDeviceMAC:
		m.ResetDeviceMAC()
		return nil
	case routingchain.FieldDeviceIP:
		m.ResetDeviceIP()
		return nil
	case routingchain.FieldDeviceName:
		m.ResetDeviceName()
		return nil
	case routingchain.FieldRoutingMode:
		m.ResetRoutingMode()
		return nil
	case routingchain.FieldActive:
		m.ResetActive()
		return nil
	case routingchain.FieldKillSwitchEnabled:
		m.ResetKillSwitchEnabled()
		return nil
	case routingchain.FieldKillSwitchMode:
		m.ResetKillSwitchMode()
		return nil
	case routingchain.FieldKillSwitchActive:
		m.ResetKillSwitchActive()
		return nil
	case routingchain.FieldKillSwitchActivatedAt:
		m.ResetKillSwitchActivatedAt()
		return nil
	case routingchain.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case routingchain.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown RoutingChain field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RoutingChainMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.router != nil {
		edges = append(edges, routingchain.EdgeRouter)
	}
	if m.hops != nil {
		edges = append(edges, routingchain.EdgeHops)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RoutingChainMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case routingchain.EdgeRouter:
		if id := m.router; id != nil {
			return []ent.Value{*id}
		}
	case routingchain.EdgeHops:
		ids := make([]ent.Value, 0, len(m.hops))
		for id := range m.hops {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RoutingChainMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedhops != nil {
		edges = append(edges, routingchain.EdgeHops)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RoutingChainMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case routingchain.EdgeHops:
		ids := make([]ent.Value, 0, len(m.removedhops))
		for id := range m.removedhops {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RoutingChainMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedrouter {
		edges = append(edges, routingchain.EdgeRouter)
	}
	if m.clearedhops {
		edges = append(edges, routingchain.EdgeHops)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RoutingChainMutation) EdgeCleared(name string) bool {
	switch name {
	case routingchain.EdgeRouter:
		return m.clearedrouter
	case routingchain.EdgeHops:
		return m.clearedhops
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RoutingChainMutation) ClearEdge(name string) error {
	switch name {
	case routingchain.EdgeRouter:
		m.ClearRouter()
		return nil
	}
	return fmt.Errorf("unknown RoutingChain unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RoutingChainMutation) ResetEdge(name string) error {
	switch name {
	case routingchain.EdgeRouter:
		m.ResetRouter()
		return nil
	case routingchain.EdgeHops:
		m.ResetHops()
		return nil
	}
	return fmt.Errorf("unknown RoutingChain edge %s", name)
}

// RoutingScheduleMutation represents an operation that mutates the RoutingSchedule nodes in the graph.
type RoutingScheduleMutation struct {
	config
	op                    Op
	typ                   string
	id                    *string
	days                  *[]int
	appenddays            []int
	start_time            *string
	end_time              *string
	timezone              *string
	enabled               *bool
	last_activated        *time.Time
	last_deactivated      *time.Time
	created_at            *time.Time
	updated_at            *time.Time
	clearedFields         map[string]struct{}
	device_routing        *string
	cleareddevice_routing bool
	done                  bool
	oldValue              func(context.Context) (*RoutingSchedule, error)
	predicates            []predicate.RoutingSchedule
}

var _ ent.Mutation = (*RoutingScheduleMutation)(nil)

// routingscheduleOption allows management of the mutation configuration using functional options.
type routingscheduleOption func(*RoutingScheduleMutation)

// newRoutingScheduleMutation creates new mutation for the RoutingSchedule entity.
func newRoutingScheduleMutation(c config, op Op, opts ...routingscheduleOption) *RoutingScheduleMutation {
	m := &RoutingScheduleMutation{
		config:        c,
		op:            op,
		typ:           TypeRoutingSchedule,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRoutingScheduleID sets the ID field of the mutation.
func withRoutingScheduleID(id string) routingscheduleOption {
	return func(m *RoutingScheduleMutation) {
		var (
			err   error
			once  sync.Once
			value *RoutingSchedule
		)
		m.oldValue = func(ctx context.Context) (*RoutingSchedule, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().RoutingSchedule.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRoutingSchedule sets the old RoutingSchedule of the mutation.
func withRoutingSchedule(node *RoutingSchedule) routingscheduleOption {
	return func(m *RoutingScheduleMutation) {
		m.oldValue = func(context.Context) (*RoutingSchedule, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RoutingScheduleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RoutingScheduleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of RoutingSchedule entities.
func (m *RoutingScheduleMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RoutingScheduleMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RoutingScheduleMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().RoutingSchedule.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetRoutingID sets the "routing_id" field.
func (m *RoutingScheduleMutation) SetRoutingID(s string) {
	m.device_routing = &s
}

// RoutingID returns the value of the "routing_id" field in the mutation.
func (m *RoutingScheduleMutation) RoutingID() (r string, exists bool) {
	v := m.device_routing
	if v == nil {
		return
	}
	return *v, true
}

// OldRoutingID returns the old "routing_id" field's value of the RoutingSchedule entity.
// If the RoutingSchedule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoutingScheduleMutation) OldRoutingID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRoutingID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRoutingID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRoutingID: %w", err)
	}
	return oldValue.RoutingID, nil
}

// ResetRoutingID resets all changes to the "routing_id" field.
func (m *RoutingScheduleMutation) ResetRoutingID() {
	m.device_routing = nil
}

// SetDays sets the "days" field.
func (m *RoutingScheduleMutation) SetDays(i []int) {
	m.days = &i
	m.appenddays = nil
}

// Days returns the value of the "days" field in the mutation.
func (m *RoutingScheduleMutation) Days() (r []int, exists bool) {
	v := m.days
	if v == nil {
		return
	}
	return *v, true
}

// OldDays returns the old "days" field's value of the RoutingSchedule entity.
// If the RoutingSchedule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoutingScheduleMutation) OldDays(ctx context.Context) (v []int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDays is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDays requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDays: %w", err)
	}
	return oldValue.Days, nil
}

// AppendDays adds i to the "days" field.
func (m *RoutingScheduleMutation) AppendDays(i []int) {
	m.appenddays = append(m.appenddays, i...)
}

// AppendedDays returns the list of values that were appended to the "days" field in this mutation.
func (m *RoutingScheduleMutation) AppendedDays() ([]int, bool) {
	if len(m.appenddays) == 0 {
		return nil, false
	}
	return m.appenddays, true
}

// ResetDays resets all changes to the "days" field.
func (m *RoutingScheduleMutation) ResetDays() {
	m.days = nil
	m.appenddays = nil
}

// SetStartTime sets the "start_time" field.
func (m *RoutingScheduleMutation) SetStartTime(s string) {
	m.start_time = &s
}

// StartTime returns the value of the "start_time" field in the mutation.
func (m *RoutingScheduleMutation) StartTime() (r string, exists bool) {
	v := m.start_time
	if v == nil {
		return
	}
	return *v, true
}

// OldStartTime returns the old "start_time" field's value of the RoutingSchedule entity.
// If the RoutingSchedule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoutingScheduleMutation) OldStartTime(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartTime: %w", err)
	}
	return oldValue.StartTime, nil
}

// ResetStartTime resets all changes to the "start_time" field.
func (m *RoutingScheduleMutation) ResetStartTime() {
	m.start_time = nil
}

// SetEndTime sets the "end_time" field.
func (m *RoutingScheduleMutation) SetEndTime(s string) {
	m.end_time = &s
}

// EndTime returns the value of the "end_time" field in the mutation.
func (m *RoutingScheduleMutation) EndTime() (r string, exists bool) {
	v := m.end_time
	if v == nil {
		return
	}
	return *v, true
}

// OldEndTime returns the old "end_time" field's value of the RoutingSchedule entity.
// If the RoutingSchedule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoutingScheduleMutation) OldEndTime(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndTime: %w", err)
	}
	return oldValue.EndTime, nil
}

// ResetEndTime resets all changes to the "end_time" field.
func (m *RoutingScheduleMutation) ResetEndTime() {
	m.end_time = nil
}

// SetTimezone sets the "timezone" field.
func (m *RoutingScheduleMutation) SetTimezone(s string) {
	m.timezone = &s
}

// Timezone returns the value of the "timezone" field in the mutation.
func (m *RoutingScheduleMutation) Timezone() (r string, exists bool) {
	v := m.timezone
	if v == nil {
		return
	}
	return *v, true
}

// OldTimezone returns the old "timezone" field's value of the RoutingSchedule entity.
// If the RoutingSchedule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoutingScheduleMutation) OldTimezone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTimezone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTimezone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimezone: %w", err)
	}
	return oldValue.Timezone, nil
}

// ResetTimezone resets all changes to the "timezone" field.
func (m *RoutingScheduleMutation) ResetTimezone() {
	m.timezone = nil
}

// SetEnabled sets the "enabled" field.
func (m *RoutingScheduleMutation) SetEnabled(b bool) {
	m.enabled = &b
}

// Enabled returns the value of the "enabled" field in the mutation.
func (m *RoutingScheduleMutation) Enabled() (r bool, exists bool) {
	v := m.enabled
	if v == nil {
		return
	}
	return *v, true
}

// OldEnabled returns the old "enabled" field's value of the RoutingSchedule entity.
// If the RoutingSchedule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoutingScheduleMutation) OldEnabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnabled: %w", err)
	}
	return oldValue.Enabled, nil
}

// ResetEnabled resets all changes to the "enabled" field.
func (m *RoutingScheduleMutation) ResetEnabled() {
	m.enabled = nil
}

// SetLastActivated sets the "last_activated" field.
func (m *RoutingScheduleMutation) SetLastActivated(t time.Time) {
	m.last_activated = &t
}

// LastActivated returns the value of the "last_activated" field in the mutation.
func (m *RoutingScheduleMutation) LastActivated() (r time.Time, exists bool) {
	v := m.last_activated
	if v == nil {
		return
	}
	return *v, true
}

// OldLastActivated returns the old "last_activated" field's value of the RoutingSchedule entity.
// If the RoutingSchedule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoutingScheduleMutation) OldLastActivated(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastActivated is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastActivated requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastActivated: %w", err)
	}
	return oldValue.LastActivated, nil
}

// ClearLastActivated clears the value of the "last_activated" field.
func (m *RoutingScheduleMutation) ClearLastActivated() {
	m.last_activated = nil
	m.clearedFields[routingschedule.FieldLastActivated] = struct{}{}
}

// LastActivatedCleared returns if the "last_activated" field was cleared in this mutation.
func (m *RoutingScheduleMutation) LastActivatedCleared() bool {
	_, ok := m.clearedFields[routingschedule.FieldLastActivated]
	return ok
}

// ResetLastActivated resets all changes to the "last_activated" field.
func (m *RoutingScheduleMutation) ResetLastActivated() {
	m.last_activated = nil
	delete(m.clearedFields, routingschedule.FieldLastActivated)
}

// SetLastDeactivated sets the "last_deactivated" field.
func (m *RoutingScheduleMutation) SetLastDeactivated(t time.Time) {
	m.last_deactivated = &t
}

// LastDeactivated returns the value of the "last_deactivated" field in the mutation.
func (m *RoutingScheduleMutation) LastDeactivated() (r time.Time, exists bool) {
	v := m.last_deactivated
	if v == nil {
		return
	}
	return *v, true
}

// OldLastDeactivated returns the old "last_deactivated" field's value of the RoutingSchedule entity.
// If the RoutingSchedule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoutingScheduleMutation) OldLastDeactivated(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastDeactivated is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastDeactivated requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastDeactivated: %w", err)
	}
	return oldValue.LastDeactivated, nil
}

// ClearLastDeactivated clears the value of the "last_deactivated" field.
func (m *RoutingScheduleMutation) ClearLastDeactivated() {
	m.last_deactivated = nil
	m.clearedFields[routingschedule.FieldLastDeactivated] = struct{}{}
}

// LastDeactivatedCleared returns if the "last_deactivated" field was cleared in this mutation.
func (m *RoutingScheduleMutation) LastDeactivatedCleared() bool {
	_, ok := m.clearedFields[routingschedule.FieldLastDeactivated]
	return ok
}

// ResetLastDeactivated resets all changes to the "last_deactivated" field.
func (m *RoutingScheduleMutation) ResetLastDeactivated() {
	m.last_deactivated = nil
	delete(m.clearedFields, routingschedule.FieldLastDeactivated)
}

// SetCreatedAt sets the "created_at" field.
func (m *RoutingScheduleMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *RoutingScheduleMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the RoutingSchedule entity.
// If the RoutingSchedule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoutingScheduleMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *RoutingScheduleMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *RoutingScheduleMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *RoutingScheduleMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the RoutingSchedule entity.
// If the RoutingSchedule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoutingScheduleMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *RoutingScheduleMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeviceRoutingID sets the "device_routing" edge to the DeviceRouting entity by id.
func (m *RoutingScheduleMutation) SetDeviceRoutingID(id string) {
	m.device_routing = &id
}

// ClearDeviceRouting clears the "device_routing" edge to the DeviceRouting entity.
func (m *RoutingScheduleMutation) ClearDeviceRouting() {
	m.cleareddevice_routing = true
	m.clearedFields[routingschedule.FieldRoutingID] = struct{}{}
}

// DeviceRoutingCleared reports if the "device_routing" edge to the DeviceRouting entity was cleared.
func (m *RoutingScheduleMutation) DeviceRoutingCleared() bool {
	return m.cleareddevice_routing
}

// DeviceRoutingID returns the "device_routing" edge ID in the mutation.
func (m *RoutingScheduleMutation) DeviceRoutingID() (id string, exists bool) {
	if m.device_routing != nil {
		return *m.device_routing, true
	}
	return
}

// DeviceRoutingIDs returns the "device_routing" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DeviceRoutingID instead. It exists only for internal usage by the builders.
func (m *RoutingScheduleMutation) DeviceRoutingIDs() (ids []string) {
	if id := m.device_routing; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDeviceRouting resets all changes to the "device_routing" edge.
func (m *RoutingScheduleMutation) ResetDeviceRouting() {
	m.device_routing = nil
	m.cleareddevice_routing = false
}

// Where appends a list predicates to the RoutingScheduleMutation builder.
func (m *RoutingScheduleMutation) Where(ps ...predicate.RoutingSchedule) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RoutingScheduleMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RoutingScheduleMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.RoutingSchedule, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RoutingScheduleMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RoutingScheduleMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (RoutingSchedule).
func (m *RoutingScheduleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RoutingScheduleMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.device_routing != nil {
		fields = append(fields, routingschedule.FieldRoutingID)
	}
	if m.days != nil {
		fields = append(fields, routingschedule.FieldDays)
	}
	if m.start_time != nil {
		fields = append(fields, routingschedule.FieldStartTime)
	}
	if m.end_time != nil {
		fields = append(fields, routingschedule.FieldEndTime)
	}
	if m.timezone != nil {
		fields = append(fields, routingschedule.FieldTimezone)
	}
	if m.enabled != nil {
		fields = append(fields, routingschedule.FieldEnabled)
	}
	if m.last_activated != nil {
		fields = append(fields, routingschedule.FieldLastActivated)
	}
	if m.last_deactivated != nil {
		fields = append(fields, routingschedule.FieldLastDeactivated)
	}
	if m.created_at != nil {
		fields = append(fields, routingschedule.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, routingschedule.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RoutingScheduleMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case routingschedule.FieldRoutingID:
		return m.RoutingID()
	case routingschedule.FieldDays:
		return m.Days()
	case routingschedule.FieldStartTime:
		return m.StartTime()
	case routingschedule.FieldEndTime:
		return m.EndTime()
	case routingschedule.FieldTimezone:
		return m.Timezone()
	case routingschedule.FieldEnabled:
		return m.Enabled()
	case routingschedule.FieldLastActivated:
		return m.LastActivated()
	case routingschedule.FieldLastDeactivated:
		return m.LastDeactivated()
	case routingschedule.FieldCreatedAt:
		return m.CreatedAt()
	case routingschedule.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RoutingScheduleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case routingschedule.FieldRoutingID:
		return m.OldRoutingID(ctx)
	case routingschedule.FieldDays:
		return m.OldDays(ctx)
	case routingschedule.FieldStartTime:
		return m.OldStartTime(ctx)
	case routingschedule.FieldEndTime:
		return m.OldEndTime(ctx)
	case routingschedule.FieldTimezone:
		return m.OldTimezone(ctx)
	case routingschedule.FieldEnabled:
		return m.OldEnabled(ctx)
	case routingschedule.FieldLastActivated:
		return m.OldLastActivated(ctx)
	case routingschedule.FieldLastDeactivated:
		return m.OldLastDeactivated(ctx)
	case routingschedule.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case routingschedule.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown RoutingSchedule field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RoutingScheduleMutation) SetField(name string, value ent.Value) error {
	switch name {
	case routingschedule.FieldRoutingID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRoutingID(v)
		return nil
	case routingschedule.FieldDays:
		v, ok := value.([]int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDays(v)
		return nil
	case routingschedule.FieldStartTime:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartTime(v)
		return nil
	case routingschedule.FieldEndTime:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndTime(v)
		return nil
	case routingschedule.FieldTimezone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimezone(v)
		return nil
	case routingschedule.FieldEnabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnabled(v)
		return nil
	case routingschedule.FieldLastActivated:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastActivated(v)
		return nil
	case routingschedule.FieldLastDeactivated:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastDeactivated(v)
		return nil
	case routingschedule.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case routingschedule.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown RoutingSchedule field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RoutingScheduleMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RoutingScheduleMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RoutingScheduleMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown RoutingSchedule numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RoutingScheduleMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(routingschedule.FieldLastActivated) {
		fields = append(fields, routingschedule.FieldLastActivated)
	}
	if m.FieldCleared(routingschedule.FieldLastDeactivated) {
		fields = append(fields, routingschedule.FieldLastDeactivated)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RoutingScheduleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RoutingScheduleMutation) ClearField(name string) error {
	switch name {
	case routingschedule.FieldLastActivated:
		m.ClearLastActivated()
		return nil
	case routingschedule.FieldLastDeactivated:
		m.ClearLastDeactivated()
		return nil
	}
	return fmt.Errorf("unknown RoutingSchedule nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RoutingScheduleMutation) ResetField(name string) error {
	switch name {
	case routingschedule.FieldRoutingID:
		m.ResetRoutingID()
		return nil
	case routingschedule.FieldDays:
		m.ResetDays()
		return nil
	case routingschedule.FieldStartTime:
		m.ResetStartTime()
		return nil
	case routingschedule.FieldEndTime:
		m.ResetEndTime()
		return nil
	case routingschedule.FieldTimezone:
		m.ResetTimezone()
		return nil
	case routingschedule.FieldEnabled:
		m.ResetEnabled()
		return nil
	case routingschedule.FieldLastActivated:
		m.ResetLastActivated()
		return nil
	case routingschedule.FieldLastDeactivated:
		m.ResetLastDeactivated()
		return nil
	case routingschedule.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case routingschedule.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown RoutingSchedule field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RoutingScheduleMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.device_routing != nil {
		edges = append(edges, routingschedule.EdgeDeviceRouting)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RoutingScheduleMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case routingschedule.EdgeDeviceRouting:
		if id := m.device_routing; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RoutingScheduleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RoutingScheduleMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RoutingScheduleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareddevice_routing {
		edges = append(edges, routingschedule.EdgeDeviceRouting)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RoutingScheduleMutation) EdgeCleared(name string) bool {
	switch name {
	case routingschedule.EdgeDeviceRouting:
		return m.cleareddevice_routing
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RoutingScheduleMutation) ClearEdge(name string) error {
	switch name {
	case routingschedule.EdgeDeviceRouting:
		m.ClearDeviceRouting()
		return nil
	}
	return fmt.Errorf("unknown RoutingSchedule unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RoutingScheduleMutation) ResetEdge(name string) error {
	switch name {
	case routingschedule.EdgeDeviceRouting:
		m.ResetDeviceRouting()
		return nil
	}
	return fmt.Errorf("unknown RoutingSchedule edge %s", name)
}

// SchemaVersionMutation represents an operation that mutates the SchemaVersion nodes in the graph.
type SchemaVersionMutation struct {
	config
	op                   Op
	typ                  string
	id                   *string
	version              *int64
	addversion           *int64
	name                 *string
	checksum             *string
	applied              *bool
	error_message        *string
	execution_time_ms    *int64
	addexecution_time_ms *int64
	applied_at           *time.Time
	clearedFields        map[string]struct{}
	done                 bool
	oldValue             func(context.Context) (*SchemaVersion, error)
	predicates           []predicate.SchemaVersion
}

var _ ent.Mutation = (*SchemaVersionMutation)(nil)

// schemaversionOption allows management of the mutation configuration using functional options.
type schemaversionOption func(*SchemaVersionMutation)

// newSchemaVersionMutation creates new mutation for the SchemaVersion entity.
func newSchemaVersionMutation(c config, op Op, opts ...schemaversionOption) *SchemaVersionMutation {
	m := &SchemaVersionMutation{
		config:        c,
		op:            op,
		typ:           TypeSchemaVersion,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSchemaVersionID sets the ID field of the mutation.
func withSchemaVersionID(id string) schemaversionOption {
	return func(m *SchemaVersionMutation) {
		var (
			err   error
			once  sync.Once
			value *SchemaVersion
		)
		m.oldValue = func(ctx context.Context) (*SchemaVersion, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SchemaVersion.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSchemaVersion sets the old SchemaVersion of the mutation.
func withSchemaVersion(node *SchemaVersion) schemaversionOption {
	return func(m *SchemaVersionMutation) {
		m.oldValue = func(context.Context) (*SchemaVersion, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SchemaVersionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SchemaVersionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of SchemaVersion entities.
func (m *SchemaVersionMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SchemaVersionMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SchemaVersionMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SchemaVersion.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetVersion sets the "version" field.
func (m *SchemaVersionMutation) SetVersion(i int64) {
	m.version = &i
	m.addversion = nil
}

// Version returns the value of the "version" field in the mutation.
func (m *SchemaVersionMutation) Version() (r int64, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the SchemaVersion entity.
// If the SchemaVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SchemaVersionMutation) OldVersion(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// AddVersion adds i to the "version" field.
func (m *SchemaVersionMutation) AddVersion(i int64) {
	if m.addversion != nil {
		*m.addversion += i
	} else {
		m.addversion = &i
	}
}

// AddedVersion returns the value that was added to the "version" field in this mutation.
func (m *SchemaVersionMutation) AddedVersion() (r int64, exists bool) {
	v := m.addversion
	if v == nil {
		return
	}
	return *v, true
}

// ResetVersion resets all changes to the "version" field.
func (m *SchemaVersionMutation) ResetVersion() {
	m.version = nil
	m.addversion = nil
}

// SetName sets the "name" field.
func (m *SchemaVersionMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *SchemaVersionMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the SchemaVersion entity.
// If the SchemaVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SchemaVersionMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *SchemaVersionMutation) ResetName() {
	m.name = nil
}

// SetChecksum sets the "checksum" field.
func (m *SchemaVersionMutation) SetChecksum(s string) {
	m.checksum = &s
}

// Checksum returns the value of the "checksum" field in the mutation.
func (m *SchemaVersionMutation) Checksum() (r string, exists bool) {
	v := m.checksum
	if v == nil {
		return
	}
	return *v, true
}

// OldChecksum returns the old "checksum" field's value of the SchemaVersion entity.
// If the SchemaVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SchemaVersionMutation) OldChecksum(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChecksum is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChecksum requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChecksum: %w", err)
	}
	return oldValue.Checksum, nil
}

// ResetChecksum resets all changes to the "checksum" field.
func (m *SchemaVersionMutation) ResetChecksum() {
	m.checksum = nil
}

// SetApplied sets the "applied" field.
func (m *SchemaVersionMutation) SetApplied(b bool) {
	m.applied = &b
}

// Applied returns the value of the "applied" field in the mutation.
func (m *SchemaVersionMutation) Applied() (r bool, exists bool) {
	v := m.applied
	if v == nil {
		return
	}
	return *v, true
}

// OldApplied returns the old "applied" field's value of the SchemaVersion entity.
// If the SchemaVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SchemaVersionMutation) OldApplied(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldApplied is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldApplied requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldApplied: %w", err)
	}
	return oldValue.Applied, nil
}

// ResetApplied resets all changes to the "applied" field.
func (m *SchemaVersionMutation) ResetApplied() {
	m.applied = nil
}

// SetErrorMessage sets the "error_message" field.
func (m *SchemaVersionMutation) SetErrorMessage(s string) {
	m.error_message = &s
}

// ErrorMessage returns the value of the "error_message" field in the mutation.
func (m *SchemaVersionMutation) ErrorMessage() (r string, exists bool) {
	v := m.error_message
	if v == nil {
		return
	}
	return *v, true
}

// OldErrorMessage returns the old "error_message" field's value of the SchemaVersion entity.
// If the SchemaVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SchemaVersionMutation) OldErrorMessage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldErrorMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldErrorMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldErrorMessage: %w", err)
	}
	return oldValue.ErrorMessage, nil
}

// ClearErrorMessage clears the value of the "error_message" field.
func (m *SchemaVersionMutation) ClearErrorMessage() {
	m.error_message = nil
	m.clearedFields[schemaversion.FieldErrorMessage] = struct{}{}
}

// ErrorMessageCleared returns if the "error_message" field was cleared in this mutation.
func (m *SchemaVersionMutation) ErrorMessageCleared() bool {
	_, ok := m.clearedFields[schemaversion.FieldErrorMessage]
	return ok
}

// ResetErrorMessage resets all changes to the "error_message" field.
func (m *SchemaVersionMutation) ResetErrorMessage() {
	m.error_message = nil
	delete(m.clearedFields, schemaversion.FieldErrorMessage)
}

// SetExecutionTimeMs sets the "execution_time_ms" field.
func (m *SchemaVersionMutation) SetExecutionTimeMs(i int64) {
	m.execution_time_ms = &i
	m.addexecution_time_ms = nil
}

// ExecutionTimeMs returns the value of the "execution_time_ms" field in the mutation.
func (m *SchemaVersionMutation) ExecutionTimeMs() (r int64, exists bool) {
	v := m.execution_time_ms
	if v == nil {
		return
	}
	return *v, true
}

// OldExecutionTimeMs returns the old "execution_time_ms" field's value of the SchemaVersion entity.
// If the SchemaVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SchemaVersionMutation) OldExecutionTimeMs(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExecutionTimeMs is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExecutionTimeMs requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExecutionTimeMs: %w", err)
	}
	return oldValue.ExecutionTimeMs, nil
}

// AddExecutionTimeMs adds i to the "execution_time_ms" field.
func (m *SchemaVersionMutation) AddExecutionTimeMs(i int64) {
	if m.addexecution_time_ms != nil {
		*m.addexecution_time_ms += i
	} else {
		m.addexecution_time_ms = &i
	}
}

// AddedExecutionTimeMs returns the value that was added to the "execution_time_ms" field in this mutation.
func (m *SchemaVersionMutation) AddedExecutionTimeMs() (r int64, exists bool) {
	v := m.addexecution_time_ms
	if v == nil {
		return
	}
	return *v, true
}

// ClearExecutionTimeMs clears the value of the "execution_time_ms" field.
func (m *SchemaVersionMutation) ClearExecutionTimeMs() {
	m.execution_time_ms = nil
	m.addexecution_time_ms = nil
	m.clearedFields[schemaversion.FieldExecutionTimeMs] = struct{}{}
}

// ExecutionTimeMsCleared returns if the "execution_time_ms" field was cleared in this mutation.
func (m *SchemaVersionMutation) ExecutionTimeMsCleared() bool {
	_, ok := m.clearedFields[schemaversion.FieldExecutionTimeMs]
	return ok
}

// ResetExecutionTimeMs resets all changes to the "execution_time_ms" field.
func (m *SchemaVersionMutation) ResetExecutionTimeMs() {
	m.execution_time_ms = nil
	m.addexecution_time_ms = nil
	delete(m.clearedFields, schemaversion.FieldExecutionTimeMs)
}

// SetAppliedAt sets the "applied_at" field.
func (m *SchemaVersionMutation) SetAppliedAt(t time.Time) {
	m.applied_at = &t
}

// AppliedAt returns the value of the "applied_at" field in the mutation.
func (m *SchemaVersionMutation) AppliedAt() (r time.Time, exists bool) {
	v := m.applied_at
	if v == nil {
		return
	}
	return *v, true
}

// OldAppliedAt returns the old "applied_at" field's value of the SchemaVersion entity.
// If the SchemaVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SchemaVersionMutation) OldAppliedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppliedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppliedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppliedAt: %w", err)
	}
	return oldValue.AppliedAt, nil
}

// ResetAppliedAt resets all changes to the "applied_at" field.
func (m *SchemaVersionMutation) ResetAppliedAt() {
	m.applied_at = nil
}

// Where appends a list predicates to the SchemaVersionMutation builder.
func (m *SchemaVersionMutation) Where(ps ...predicate.SchemaVersion) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SchemaVersionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SchemaVersionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.SchemaVersion, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SchemaVersionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SchemaVersionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (SchemaVersion).
func (m *SchemaVersionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SchemaVersionMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.version != nil {
		fields = append(fields, schemaversion.FieldVersion)
	}
	if m.name != nil {
		fields = append(fields, schemaversion.FieldName)
	}
	if m.checksum != nil {
		fields = append(fields, schemaversion.FieldChecksum)
	}
	if m.applied != nil {
		fields = append(fields, schemaversion.FieldApplied)
	}
	if m.error_message != nil {
		fields = append(fields, schemaversion.FieldErrorMessage)
	}
	if m.execution_time_ms != nil {
		fields = append(fields, schemaversion.FieldExecutionTimeMs)
	}
	if m.applied_at != nil {
		fields = append(fields, schemaversion.FieldAppliedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SchemaVersionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case schemaversion.FieldVersion:
		return m.Version()
	case schemaversion.FieldName:
		return m.Name()
	case schemaversion.FieldChecksum:
		return m.Checksum()
	case schemaversion.FieldApplied:
		return m.Applied()
	case schemaversion.FieldErrorMessage:
		return m.ErrorMessage()
	case schemaversion.FieldExecutionTimeMs:
		return m.ExecutionTimeMs()
	case schemaversion.FieldAppliedAt:
		return m.AppliedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SchemaVersionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case schemaversion.FieldVersion:
		return m.OldVersion(ctx)
	case schemaversion.FieldName:
		return m.OldName(ctx)
	case schemaversion.FieldChecksum:
		return m.OldChecksum(ctx)
	case schemaversion.FieldApplied:
		return m.OldApplied(ctx)
	case schemaversion.FieldErrorMessage:
		return m.OldErrorMessage(ctx)
	case schemaversion.FieldExecutionTimeMs:
		return m.OldExecutionTimeMs(ctx)
	case schemaversion.FieldAppliedAt:
		return m.OldAppliedAt(ctx)
	}
	return nil, fmt.Errorf("unknown SchemaVersion field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SchemaVersionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case schemaversion.FieldVersion:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case schemaversion.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case schemaversion.FieldChecksum:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChecksum(v)
		return nil
	case schemaversion.FieldApplied:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetApplied(v)
		return nil
	case schemaversion.FieldErrorMessage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetErrorMessage(v)
		return nil
	case schemaversion.FieldExecutionTimeMs:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExecutionTimeMs(v)
		return nil
	case schemaversion.FieldAppliedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppliedAt(v)
		return nil
	}
	return fmt.Errorf("unknown SchemaVersion field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SchemaVersionMutation) AddedFields() []string {
	var fields []string
	if m.addversion != nil {
		fields = append(fields, schemaversion.FieldVersion)
	}
	if m.addexecution_time_ms != nil {
		fields = append(fields, schemaversion.FieldExecutionTimeMs)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SchemaVersionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case schemaversion.FieldVersion:
		return m.AddedVersion()
	case schemaversion.FieldExecutionTimeMs:
		return m.AddedExecutionTimeMs()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SchemaVersionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case schemaversion.FieldVersion:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVersion(v)
		return nil
	case schemaversion.FieldExecutionTimeMs:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddExecutionTimeMs(v)
		return nil
	}
	return fmt.Errorf("unknown SchemaVersion numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SchemaVersionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(schemaversion.FieldErrorMessage) {
		fields = append(fields, schemaversion.FieldErrorMessage)
	}
	if m.FieldCleared(schemaversion.FieldExecutionTimeMs) {
		fields = append(fields, schemaversion.FieldExecutionTimeMs)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SchemaVersionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SchemaVersionMutation) ClearField(name string) error {
	switch name {
	case schemaversion.FieldErrorMessage:
		m.ClearErrorMessage()
		return nil
	case schemaversion.FieldExecutionTimeMs:
		m.ClearExecutionTimeMs()
		return nil
	}
	return fmt.Errorf("unknown SchemaVersion nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SchemaVersionMutation) ResetField(name string) error {
	switch name {
	case schemaversion.FieldVersion:
		m.ResetVersion()
		return nil
	case schemaversion.FieldName:
		m.ResetName()
		return nil
	case schemaversion.FieldChecksum:
		m.ResetChecksum()
		return nil
	case schemaversion.FieldApplied:
		m.ResetApplied()
		return nil
	case schemaversion.FieldErrorMessage:
		m.ResetErrorMessage()
		return nil
	case schemaversion.FieldExecutionTimeMs:
		m.ResetExecutionTimeMs()
		return nil
	case schemaversion.FieldAppliedAt:
		m.ResetAppliedAt()
		return nil
	}
	return fmt.Errorf("unknown SchemaVersion field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SchemaVersionMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SchemaVersionMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SchemaVersionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SchemaVersionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SchemaVersionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SchemaVersionMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SchemaVersionMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown SchemaVersion unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SchemaVersionMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown SchemaVersion edge %s", name)
}

// ServiceDependencyMutation represents an operation that mutates the ServiceDependency nodes in the graph.
type ServiceDependencyMutation struct {
	config
	op                        Op
	typ                       string
	id                        *string
	dependency_type           *servicedependency.DependencyType
	auto_start                *bool
	health_timeout_seconds    *int
	addhealth_timeout_seconds *int
	created_at                *time.Time
	updated_at                *time.Time
	clearedFields             map[string]struct{}
	from_instance             *string
	clearedfrom_instance      bool
	to_instance               *string
	clearedto_instance        bool
	done                      bool
	oldValue                  func(context.Context) (*ServiceDependency, error)
	predicates                []predicate.ServiceDependency
}

var _ ent.Mutation = (*ServiceDependencyMutation)(nil)

// servicedependencyOption allows management of the mutation configuration using functional options.
type servicedependencyOption func(*ServiceDependencyMutation)

// newServiceDependencyMutation creates new mutation for the ServiceDependency entity.
func newServiceDependencyMutation(c config, op Op, opts ...servicedependencyOption) *ServiceDependencyMutation {
	m := &ServiceDependencyMutation{
		config:        c,
		op:            op,
		typ:           TypeServiceDependency,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withServiceDependencyID sets the ID field of the mutation.
func withServiceDependencyID(id string) servicedependencyOption {
	return func(m *ServiceDependencyMutation) {
		var (
			err   error
			once  sync.Once
			value *ServiceDependency
		)
		m.oldValue = func(ctx context.Context) (*ServiceDependency, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ServiceDependency.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withServiceDependency sets the old ServiceDependency of the mutation.
func withServiceDependency(node *ServiceDependency) servicedependencyOption {
	return func(m *ServiceDependencyMutation) {
		m.oldValue = func(context.Context) (*ServiceDependency, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ServiceDependencyMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ServiceDependencyMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ServiceDependency entities.
func (m *ServiceDependencyMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ServiceDependencyMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ServiceDependencyMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ServiceDependency.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetFromInstanceID sets the "from_instance_id" field.
func (m *ServiceDependencyMutation) SetFromInstanceID(s string) {
	m.from_instance = &s
}

// FromInstanceID returns the value of the "from_instance_id" field in the mutation.
func (m *ServiceDependencyMutation) FromInstanceID() (r string, exists bool) {
	v := m.from_instance
	if v == nil {
		return
	}
	return *v, true
}

// OldFromInstanceID returns the old "from_instance_id" field's value of the ServiceDependency entity.
// If the ServiceDependency object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceDependencyMutation) OldFromInstanceID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFromInstanceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFromInstanceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFromInstanceID: %w", err)
	}
	return oldValue.FromInstanceID, nil
}

// ResetFromInstanceID resets all changes to the "from_instance_id" field.
func (m *ServiceDependencyMutation) ResetFromInstanceID() {
	m.from_instance = nil
}

// SetToInstanceID sets the "to_instance_id" field.
func (m *ServiceDependencyMutation) SetToInstanceID(s string) {
	m.to_instance = &s
}

// ToInstanceID returns the value of the "to_instance_id" field in the mutation.
func (m *ServiceDependencyMutation) ToInstanceID() (r string, exists bool) {
	v := m.to_instance
	if v == nil {
		return
	}
	return *v, true
}

// OldToInstanceID returns the old "to_instance_id" field's value of the ServiceDependency entity.
// If the ServiceDependency object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceDependencyMutation) OldToInstanceID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldToInstanceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldToInstanceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldToInstanceID: %w", err)
	}
	return oldValue.ToInstanceID, nil
}

// ResetToInstanceID resets all changes to the "to_instance_id" field.
func (m *ServiceDependencyMutation) ResetToInstanceID() {
	m.to_instance = nil
}

// SetDependencyType sets the "dependency_type" field.
func (m *ServiceDependencyMutation) SetDependencyType(st servicedependency.DependencyType) {
	m.dependency_type = &st
}

// DependencyType returns the value of the "dependency_type" field in the mutation.
func (m *ServiceDependencyMutation) DependencyType() (r servicedependency.DependencyType, exists bool) {
	v := m.dependency_type
	if v == nil {
		return
	}
	return *v, true
}

// OldDependencyType returns the old "dependency_type" field's value of the ServiceDependency entity.
// If the ServiceDependency object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceDependencyMutation) OldDependencyType(ctx context.Context) (v servicedependency.DependencyType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDependencyType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDependencyType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDependencyType: %w", err)
	}
	return oldValue.DependencyType, nil
}

// ResetDependencyType resets all changes to the "dependency_type" field.
func (m *ServiceDependencyMutation) ResetDependencyType() {
	m.dependency_type = nil
}

// SetAutoStart sets the "auto_start" field.
func (m *ServiceDependencyMutation) SetAutoStart(b bool) {
	m.auto_start = &b
}

// AutoStart returns the value of the "auto_start" field in the mutation.
func (m *ServiceDependencyMutation) AutoStart() (r bool, exists bool) {
	v := m.auto_start
	if v == nil {
		return
	}
	return *v, true
}

// OldAutoStart returns the old "auto_start" field's value of the ServiceDependency entity.
// If the ServiceDependency object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceDependencyMutation) OldAutoStart(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAutoStart is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAutoStart requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAutoStart: %w", err)
	}
	return oldValue.AutoStart, nil
}

// ResetAutoStart resets all changes to the "auto_start" field.
func (m *ServiceDependencyMutation) ResetAutoStart() {
	m.auto_start = nil
}

// SetHealthTimeoutSeconds sets the "health_timeout_seconds" field.
func (m *ServiceDependencyMutation) SetHealthTimeoutSeconds(i int) {
	m.health_timeout_seconds = &i
	m.addhealth_timeout_seconds = nil
}

// HealthTimeoutSeconds returns the value of the "health_timeout_seconds" field in the mutation.
func (m *ServiceDependencyMutation) HealthTimeoutSeconds() (r int, exists bool) {
	v := m.health_timeout_seconds
	if v == nil {
		return
	}
	return *v, true
}

// OldHealthTimeoutSeconds returns the old "health_timeout_seconds" field's value of the ServiceDependency entity.
// If the ServiceDependency object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceDependencyMutation) OldHealthTimeoutSeconds(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHealthTimeoutSeconds is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHealthTimeoutSeconds requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHealthTimeoutSeconds: %w", err)
	}
	return oldValue.HealthTimeoutSeconds, nil
}

// AddHealthTimeoutSeconds adds i to the "health_timeout_seconds" field.
func (m *ServiceDependencyMutation) AddHealthTimeoutSeconds(i int) {
	if m.addhealth_timeout_seconds != nil {
		*m.addhealth_timeout_seconds += i
	} else {
		m.addhealth_timeout_seconds = &i
	}
}

// AddedHealthTimeoutSeconds returns the value that was added to the "health_timeout_seconds" field in this mutation.
func (m *ServiceDependencyMutation) AddedHealthTimeoutSeconds() (r int, exists bool) {
	v := m.addhealth_timeout_seconds
	if v == nil {
		return
	}
	return *v, true
}

// ResetHealthTimeoutSeconds resets all changes to the "health_timeout_seconds" field.
func (m *ServiceDependencyMutation) ResetHealthTimeoutSeconds() {
	m.health_timeout_seconds = nil
	m.addhealth_timeout_seconds = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ServiceDependencyMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ServiceDependencyMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ServiceDependency entity.
// If the ServiceDependency object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceDependencyMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ServiceDependencyMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ServiceDependencyMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ServiceDependencyMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ServiceDependency entity.
// If the ServiceDependency object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceDependencyMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ServiceDependencyMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearFromInstance clears the "from_instance" edge to the ServiceInstance entity.
func (m *ServiceDependencyMutation) ClearFromInstance() {
	m.clearedfrom_instance = true
	m.clearedFields[servicedependency.FieldFromInstanceID] = struct{}{}
}

// FromInstanceCleared reports if the "from_instance" edge to the ServiceInstance entity was cleared.
func (m *ServiceDependencyMutation) FromInstanceCleared() bool {
	return m.clearedfrom_instance
}

// FromInstanceIDs returns the "from_instance" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// FromInstanceID instead. It exists only for internal usage by the builders.
func (m *ServiceDependencyMutation) FromInstanceIDs() (ids []string) {
	if id := m.from_instance; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetFromInstance resets all changes to the "from_instance" edge.
func (m *ServiceDependencyMutation) ResetFromInstance() {
	m.from_instance = nil
	m.clearedfrom_instance = false
}

// ClearToInstance clears the "to_instance" edge to the ServiceInstance entity.
func (m *ServiceDependencyMutation) ClearToInstance() {
	m.clearedto_instance = true
	m.clearedFields[servicedependency.FieldToInstanceID] = struct{}{}
}

// ToInstanceCleared reports if the "to_instance" edge to the ServiceInstance entity was cleared.
func (m *ServiceDependencyMutation) ToInstanceCleared() bool {
	return m.clearedto_instance
}

// ToInstanceIDs returns the "to_instance" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ToInstanceID instead. It exists only for internal usage by the builders.
func (m *ServiceDependencyMutation) ToInstanceIDs() (ids []string) {
	if id := m.to_instance; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetToInstance resets all changes to the "to_instance" edge.
func (m *ServiceDependencyMutation) ResetToInstance() {
	m.to_instance = nil
	m.clearedto_instance = false
}

// Where appends a list predicates to the ServiceDependencyMutation builder.
func (m *ServiceDependencyMutation) Where(ps ...predicate.ServiceDependency) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ServiceDependencyMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ServiceDependencyMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ServiceDependency, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ServiceDependencyMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ServiceDependencyMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ServiceDependency).
func (m *ServiceDependencyMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ServiceDependencyMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.from_instance != nil {
		fields = append(fields, servicedependency.FieldFromInstanceID)
	}
	if m.to_instance != nil {
		fields = append(fields, servicedependency.FieldToInstanceID)
	}
	if m.dependency_type != nil {
		fields = append(fields, servicedependency.FieldDependencyType)
	}
	if m.auto_start != nil {
		fields = append(fields, servicedependency.FieldAutoStart)
	}
	if m.health_timeout_seconds != nil {
		fields = append(fields, servicedependency.FieldHealthTimeoutSeconds)
	}
	if m.created_at != nil {
		fields = append(fields, servicedependency.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, servicedependency.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ServiceDependencyMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case servicedependency.FieldFromInstanceID:
		return m.FromInstanceID()
	case servicedependency.FieldToInstanceID:
		return m.ToInstanceID()
	case servicedependency.FieldDependencyType:
		return m.DependencyType()
	case servicedependency.FieldAutoStart:
		return m.AutoStart()
	case servicedependency.FieldHealthTimeoutSeconds:
		return m.HealthTimeoutSeconds()
	case servicedependency.FieldCreatedAt:
		return m.CreatedAt()
	case servicedependency.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ServiceDependencyMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case servicedependency.FieldFromInstanceID:
		return m.OldFromInstanceID(ctx)
	case servicedependency.FieldToInstanceID:
		return m.OldToInstanceID(ctx)
	case servicedependency.FieldDependencyType:
		return m.OldDependencyType(ctx)
	case servicedependency.FieldAutoStart:
		return m.OldAutoStart(ctx)
	case servicedependency.FieldHealthTimeoutSeconds:
		return m.OldHealthTimeoutSeconds(ctx)
	case servicedependency.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case servicedependency.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown ServiceDependency field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ServiceDependencyMutation) SetField(name string, value ent.Value) error {
	switch name {
	case servicedependency.FieldFromInstanceID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFromInstanceID(v)
		return nil
	case servicedependency.FieldToInstanceID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetToInstanceID(v)
		return nil
	case servicedependency.FieldDependencyType:
		v, ok := value.(servicedependency.DependencyType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDependencyType(v)
		return nil
	case servicedependency.FieldAutoStart:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAutoStart(v)
		return nil
	case servicedependency.FieldHealthTimeoutSeconds:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHealthTimeoutSeconds(v)
		return nil
	case servicedependency.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case servicedependency.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown ServiceDependency field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ServiceDependencyMutation) AddedFields() []string {
	var fields []string
	if m.addhealth_timeout_seconds != nil {
		fields = append(fields, servicedependency.FieldHealthTimeoutSeconds)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ServiceDependencyMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case servicedependency.FieldHealthTimeoutSeconds:
		return m.AddedHealthTimeoutSeconds()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ServiceDependencyMutation) AddField(name string, value ent.Value) error {
	switch name {
	case servicedependency.FieldHealthTimeoutSeconds:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddHealthTimeoutSeconds(v)
		return nil
	}
	return fmt.Errorf("unknown ServiceDependency numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ServiceDependencyMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ServiceDependencyMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ServiceDependencyMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ServiceDependency nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ServiceDependencyMutation) ResetField(name string) error {
	switch name {
	case servicedependency.FieldFromInstanceID:
		m.ResetFromInstanceID()
		return nil
	case servicedependency.FieldToInstanceID:
		m.ResetToInstanceID()
		return nil
	case servicedependency.FieldDependencyType:
		m.ResetDependencyType()
		return nil
	case servicedependency.FieldAutoStart:
		m.ResetAutoStart()
		return nil
	case servicedependency.FieldHealthTimeoutSeconds:
		m.ResetHealthTimeoutSeconds()
		return nil
	case servicedependency.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case servicedependency.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown ServiceDependency field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ServiceDependencyMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.from_instance != nil {
		edges = append(edges, servicedependency.EdgeFromInstance)
	}
	if m.to_instance != nil {
		edges = append(edges, servicedependency.EdgeToInstance)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ServiceDependencyMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case servicedependency.EdgeFromInstance:
		if id := m.from_instance; id != nil {
			return []ent.Value{*id}
		}
	case servicedependency.EdgeToInstance:
		if id := m.to_instance; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ServiceDependencyMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ServiceDependencyMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ServiceDependencyMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedfrom_instance {
		edges = append(edges, servicedependency.EdgeFromInstance)
	}
	if m.clearedto_instance {
		edges = append(edges, servicedependency.EdgeToInstance)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ServiceDependencyMutation) EdgeCleared(name string) bool {
	switch name {
	case servicedependency.EdgeFromInstance:
		return m.clearedfrom_instance
	case servicedependency.EdgeToInstance:
		return m.clearedto_instance
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ServiceDependencyMutation) ClearEdge(name string) error {
	switch name {
	case servicedependency.EdgeFromInstance:
		m.ClearFromInstance()
		return nil
	case servicedependency.EdgeToInstance:
		m.ClearToInstance()
		return nil
	}
	return fmt.Errorf("unknown ServiceDependency unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ServiceDependencyMutation) ResetEdge(name string) error {
	switch name {
	case servicedependency.EdgeFromInstance:
		m.ResetFromInstance()
		return nil
	case servicedependency.EdgeToInstance:
		m.ResetToInstance()
		return nil
	}
	return fmt.Errorf("unknown ServiceDependency edge %s", name)
}

// ServiceInstanceMutation represents an operation that mutates the ServiceInstance nodes in the graph.
type ServiceInstanceMutation struct {
	config
	op                               Op
	typ                              string
	id                               *string
	feature_id                       *string
	instance_name                    *string
	status                           *serviceinstance.Status
	vlan_id                          *int
	addvlan_id                       *int
	bind_ip                          *string
	ports                            *[]int
	appendports                      []int
	_config                          *map[string]interface{}
	binary_path                      *string
	binary_version                   *string
	binary_checksum                  *string
	memory_limit                     *int64
	addmemory_limit                  *int64
	cpu_weight                       *int
	addcpu_weight                    *int
	verification_enabled             *bool
	archive_hash                     *string
	binary_hash                      *string
	gpg_verified                     *bool
	gpg_key_id                       *string
	checksums_url                    *string
	verified_at                      *time.Time
	unavailable_reason               *string
	auto_start                       *bool
	health_status                    *serviceinstance.HealthStatus
	health_process_alive             *bool
	health_connection_status         *serviceinstance.HealthConnectionStatus
	health_latency_ms                *int
	addhealth_latency_ms             *int
	health_last_healthy_at           *time.Time
	health_consecutive_fails         *int
	addhealth_consecutive_fails      *int
	health_check_interval_seconds    *int
	addhealth_check_interval_seconds *int
	health_failure_threshold         *int
	addhealth_failure_threshold      *int
	quota_bytes                      *int64
	addquota_bytes                   *int64
	quota_period                     *serviceinstance.QuotaPeriod
	quota_action                     *serviceinstance.QuotaAction
	quota_used_bytes                 *int64
	addquota_used_bytes              *int64
	quota_reset_at                   *time.Time
	available_update_version         *string
	available_update_severity        *serviceinstance.AvailableUpdateSeverity
	last_update_check                *time.Time
	last_update_etag                 *string
	update_changelog_url             *string
	update_check_schedule            *string
	auto_apply_threshold             *serviceinstance.AutoApplyThreshold
	has_backup                       *bool
	backup_version                   *string
	last_updated_at                  *time.Time
	created_at                       *time.Time
	updated_at                       *time.Time
	clearedFields                    map[string]struct{}
	router                           *string
	clearedrouter                    bool
	port_allocations                 map[string]struct{}
	removedport_allocations          map[string]struct{}
	clearedport_allocations          bool
	vlan_allocations                 map[string]struct{}
	removedvlan_allocations          map[string]struct{}
	clearedvlan_allocations          bool
	virtual_interface                *string
	clearedvirtual_interface         bool
	dependencies                     map[string]struct{}
	removeddependencies              map[string]struct{}
	cleareddependencies              bool
	dependents                       map[string]struct{}
	removeddependents                map[string]struct{}
	cleareddependents                bool
	device_routings                  map[string]struct{}
	removeddevice_routings           map[string]struct{}
	cleareddevice_routings           bool
	diagnostic_results               map[string]struct{}
	removeddiagnostic_results        map[string]struct{}
	cleareddiagnostic_results        bool
	traffic_hourly                   map[string]struct{}
	removedtraffic_hourly            map[string]struct{}
	clearedtraffic_hourly            bool
	done                             bool
	oldValue                         func(context.Context) (*ServiceInstance, error)
	predicates                       []predicate.ServiceInstance
}

var _ ent.Mutation = (*ServiceInstanceMutation)(nil)

// serviceinstanceOption allows management of the mutation configuration using functional options.
type serviceinstanceOption func(*ServiceInstanceMutation)

// newServiceInstanceMutation creates new mutation for the ServiceInstance entity.
func newServiceInstanceMutation(c config, op Op, opts ...serviceinstanceOption) *ServiceInstanceMutation {
	m := &ServiceInstanceMutation{
		config:        c,
		op:            op,
		typ:           TypeServiceInstance,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withServiceInstanceID sets the ID field of the mutation.
func withServiceInstanceID(id string) serviceinstanceOption {
	return func(m *ServiceInstanceMutation) {
		var (
			err   error
			once  sync.Once
			value *ServiceInstance
		)
		m.oldValue = func(ctx context.Context) (*ServiceInstance, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ServiceInstance.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withServiceInstance sets the old ServiceInstance of the mutation.
func withServiceInstance(node *ServiceInstance) serviceinstanceOption {
	return func(m *ServiceInstanceMutation) {
		m.oldValue = func(context.Context) (*ServiceInstance, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ServiceInstanceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ServiceInstanceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ServiceInstance entities.
func (m *ServiceInstanceMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ServiceInstanceMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ServiceInstanceMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ServiceInstance.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetFeatureID sets the "feature_id" field.
func (m *ServiceInstanceMutation) SetFeatureID(s string) {
	m.feature_id = &s
}

// FeatureID returns the value of the "feature_id" field in the mutation.
func (m *ServiceInstanceMutation) FeatureID() (r string, exists bool) {
	v := m.feature_id
	if v == nil {
		return
	}
	return *v, true
}

// OldFeatureID returns the old "feature_id" field's value of the ServiceInstance entity.
// If the ServiceInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceInstanceMutation) OldFeatureID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFeatureID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFeatureID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFeatureID: %w", err)
	}
	return oldValue.FeatureID, nil
}

// ResetFeatureID resets all changes to the "feature_id" field.
func (m *ServiceInstanceMutation) ResetFeatureID() {
	m.feature_id = nil
}

// SetInstanceName sets the "instance_name" field.
func (m *ServiceInstanceMutation) SetInstanceName(s string) {
	m.instance_name = &s
}

// InstanceName returns the value of the "instance_name" field in the mutation.
func (m *ServiceInstanceMutation) InstanceName() (r string, exists bool) {
	v := m.instance_name
	if v == nil {
		return
	}
	return *v, true
}

// OldInstanceName returns the old "instance_name" field's value of the ServiceInstance entity.
// If the ServiceInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceInstanceMutation) OldInstanceName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInstanceName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInstanceName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInstanceName: %w", err)
	}
	return oldValue.InstanceName, nil
}

// ResetInstanceName resets all changes to the "instance_name" field.
func (m *ServiceInstanceMutation) ResetInstanceName() {
	m.instance_name = nil
}

// SetRouterID sets the "router_id" field.
func (m *ServiceInstanceMutation) SetRouterID(s string) {
	m.router = &s
}

// RouterID returns the value of the "router_id" field in the mutation.
func (m *ServiceInstanceMutation) RouterID() (r string, exists bool) {
	v := m.router
	if v == nil {
		return
	}
	return *v, true
}

// OldRouterID returns the old "router_id" field's value of the ServiceInstance entity.
// If the ServiceInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceInstanceMutation) OldRouterID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRouterID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRouterID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRouterID: %w", err)
	}
	return oldValue.RouterID, nil
}

// ResetRouterID resets all changes to the "router_id" field.
func (m *ServiceInstanceMutation) ResetRouterID() {
	m.router = nil
}

// SetStatus sets the "status" field.
func (m *ServiceInstanceMutation) SetStatus(s serviceinstance.Status) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *ServiceInstanceMutation) Status() (r serviceinstance.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the ServiceInstance entity.
// If the ServiceInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceInstanceMutation) OldStatus(ctx context.Context) (v serviceinstance.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *ServiceInstanceMutation) ResetStatus() {
	m.status = nil
}

// SetVlanID sets the "vlan_id" field.
func (m *ServiceInstanceMutation) SetVlanID(i int) {
	m.vlan_id = &i
	m.addvlan_id = nil
}

// VlanID returns the value of the "vlan_id" field in the mutation.
func (m *ServiceInstanceMutation) VlanID() (r int, exists bool) {
	v := m.vlan_id
	if v == nil {
		return
	}
	return *v, true
}

// OldVlanID returns the old "vlan_id" field's value of the ServiceInstance entity.
// If the ServiceInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceInstanceMutation) OldVlanID(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVlanID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVlanID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVlanID: %w", err)
	}
	return oldValue.VlanID, nil
}

// AddVlanID adds i to the "vlan_id" field.
func (m *ServiceInstanceMutation) AddVlanID(i int) {
	if m.addvlan_id != nil {
		*m.addvlan_id += i
	} else {
		m.addvlan_id = &i
	}
}

// AddedVlanID returns the value that was added to the "vlan_id" field in this mutation.
func (m *ServiceInstanceMutation) AddedVlanID() (r int, exists bool) {
	v := m.addvlan_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearVlanID clears the value of the "vlan_id" field.
func (m *ServiceInstanceMutation) ClearVlanID() {
	m.vlan_id = nil
	m.addvlan_id = nil
	m.clearedFields[serviceinstance.FieldVlanID] = struct{}{}
}

// VlanIDCleared returns if the "vlan_id" field was cleared in this mutation.
func (m *ServiceInstanceMutation) VlanIDCleared() bool {
	_, ok := m.clearedFields[serviceinstance.FieldVlanID]
	return ok
}

// ResetVlanID resets all changes to the "vlan_id" field.
func (m *ServiceInstanceMutation) ResetVlanID() {
	m.vlan_id = nil
	m.addvlan_id = nil
	delete(m.clearedFields, serviceinstance.FieldVlanID)
}

// SetBindIP sets the "bind_ip" field.
func (m *ServiceInstanceMutation) SetBindIP(s string) {
	m.bind_ip = &s
}

// BindIP returns the value of the "bind_ip" field in the mutation.
func (m *ServiceInstanceMutation) BindIP() (r string, exists bool) {
	v := m.bind_ip
	if v == nil {
		return
	}
	return *v, true
}

// OldBindIP returns the old "bind_ip" field's value of the ServiceInstance entity.
// If the ServiceInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceInstanceMutation) OldBindIP(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBindIP is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBindIP requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBindIP: %w", err)
	}
	return oldValue.BindIP, nil
}

// ClearBindIP clears the value of the "bind_ip" field.
func (m *ServiceInstanceMutation) ClearBindIP() {
	m.bind_ip = nil
	m.clearedFields[serviceinstance.FieldBindIP] = struct{}{}
}

// BindIPCleared returns if the "bind_ip" field was cleared in this mutation.
func (m *ServiceInstanceMutation) BindIPCleared() bool {
	_, ok := m.clearedFields[serviceinstance.FieldBindIP]
	return ok
}

// ResetBindIP resets all changes to the "bind_ip" field.
func (m *ServiceInstanceMutation) ResetBindIP() {
	m.bind_ip = nil
	delete(m.clearedFields, serviceinstance.FieldBindIP)
}

// SetPorts sets the "ports" field.
func (m *ServiceInstanceMutation) SetPorts(i []int) {
	m.ports = &i
	m.appendports = nil
}

// Ports returns the value of the "ports" field in the mutation.
func (m *ServiceInstanceMutation) Ports() (r []int, exists bool) {
	v := m.ports
	if v == nil {
		return
	}
	return *v, true
}

// OldPorts returns the old "ports" field's value of the ServiceInstance entity.
// If the ServiceInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceInstanceMutation) OldPorts(ctx context.Context) (v []int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPorts is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPorts requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPorts: %w", err)
	}
	return oldValue.Ports, nil
}

// AppendPorts adds i to the "ports" field.
func (m *ServiceInstanceMutation) AppendPorts(i []int) {
	m.appendports = append(m.appendports, i...)
}

// AppendedPorts returns the list of values that were appended to the "ports" field in this mutation.
func (m *ServiceInstanceMutation) AppendedPorts() ([]int, bool) {
	if len(m.appendports) == 0 {
		return nil, false
	}
	return m.appendports, true
}

// ClearPorts clears the value of the "ports" field.
func (m *ServiceInstanceMutation) ClearPorts() {
	m.ports = nil
	m.appendports = nil
	m.clearedFields[serviceinstance.FieldPorts] = struct{}{}
}

// PortsCleared returns if the "ports" field was cleared in this mutation.
func (m *ServiceInstanceMutation) PortsCleared() bool {
	_, ok := m.clearedFields[serviceinstance.FieldPorts]
	return ok
}

// ResetPorts resets all changes to the "ports" field.
func (m *ServiceInstanceMutation) ResetPorts() {
	m.ports = nil
	m.appendports = nil
	delete(m.clearedFields, serviceinstance.FieldPorts)
}

// SetConfig sets the "config" field.
func (m *ServiceInstanceMutation) SetConfig(value map[string]interface{}) {
	m._config = &value
}

// Config returns the value of the "config" field in the mutation.
func (m *ServiceInstanceMutation) Config() (r map[string]interface{}, exists bool) {
	v := m._config
	if v == nil {
		return
	}
	return *v, true
}

// OldConfig returns the old "config" field's value of the ServiceInstance entity.
// If the ServiceInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceInstanceMutation) OldConfig(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConfig is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConfig requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConfig: %w", err)
	}
	return oldValue.Config, nil
}

// ClearConfig clears the value of the "config" field.
func (m *ServiceInstanceMutation) ClearConfig() {
	m._config = nil
	m.clearedFields[serviceinstance.FieldConfig] = struct{}{}
}

// ConfigCleared returns if the "config" field was cleared in this mutation.
func (m *ServiceInstanceMutation) ConfigCleared() bool {
	_, ok := m.clearedFields[serviceinstance.FieldConfig]
	return ok
}

// ResetConfig resets all changes to the "config" field.
func (m *ServiceInstanceMutation) ResetConfig() {
	m._config = nil
	delete(m.clearedFields, serviceinstance.FieldConfig)
}

// SetBinaryPath sets the "binary_path" field.
func (m *ServiceInstanceMutation) SetBinaryPath(s string) {
	m.binary_path = &s
}

// BinaryPath returns the value of the "binary_path" field in the mutation.
func (m *ServiceInstanceMutation) BinaryPath() (r string, exists bool) {
	v := m.binary_path
	if v == nil {
		return
	}
	return *v, true
}

// OldBinaryPath returns the old "binary_path" field's value of the ServiceInstance entity.
// If the ServiceInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceInstanceMutation) OldBinaryPath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBinaryPath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBinaryPath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBinaryPath: %w", err)
	}
	return oldValue.BinaryPath, nil
}

// ClearBinaryPath clears the value of the "binary_path" field.
func (m *ServiceInstanceMutation) ClearBinaryPath() {
	m.binary_path = nil
	m.clearedFields[serviceinstance.FieldBinaryPath] = struct{}{}
}

// BinaryPathCleared returns if the "binary_path" field was cleared in this mutation.
func (m *ServiceInstanceMutation) BinaryPathCleared() bool {
	_, ok := m.clearedFields[serviceinstance.FieldBinaryPath]
	return ok
}

// ResetBinaryPath resets all changes to the "binary_path" field.
func (m *ServiceInstanceMutation) ResetBinaryPath() {
	m.binary_path = nil
	delete(m.clearedFields, serviceinstance.FieldBinaryPath)
}

// SetBinaryVersion sets the "binary_version" field.
func (m *ServiceInstanceMutation) SetBinaryVersion(s string) {
	m.binary_version = &s
}

// BinaryVersion returns the value of the "binary_version" field in the mutation.
func (m *ServiceInstanceMutation) BinaryVersion() (r string, exists bool) {
	v := m.binary_version
	if v == nil {
		return
	}
	return *v, true
}

// OldBinaryVersion returns the old "binary_version" field's value of the ServiceInstance entity.
// If the ServiceInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceInstanceMutation) OldBinaryVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBinaryVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBinaryVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBinaryVersion: %w", err)
	}
	return oldValue.BinaryVersion, nil
}

// ClearBinaryVersion clears the value of the "binary_version" field.
func (m *ServiceInstanceMutation) ClearBinaryVersion() {
	m.binary_version = nil
	m.clearedFields[serviceinstance.FieldBinaryVersion] = struct{}{}
}

// BinaryVersionCleared returns if the "binary_version" field was cleared in this mutation.
func (m *ServiceInstanceMutation) BinaryVersionCleared() bool {
	_, ok := m.clearedFields[serviceinstance.FieldBinaryVersion]
	return ok
}

// ResetBinaryVersion resets all changes to the "binary_version" field.
func (m *ServiceInstanceMutation) ResetBinaryVersion() {
	m.binary_version = nil
	delete(m.clearedFields, serviceinstance.FieldBinaryVersion)
}

// SetBinaryChecksum sets the "binary_checksum" field.
func (m *ServiceInstanceMutation) SetBinaryChecksum(s string) {
	m.binary_checksum = &s
}

// BinaryChecksum returns the value of the "binary_checksum" field in the mutation.
func (m *ServiceInstanceMutation) BinaryChecksum() (r string, exists bool) {
	v := m.binary_checksum
	if v == nil {
		return
	}
	return *v, true
}

// OldBinaryChecksum returns the old "binary_checksum" field's value of the ServiceInstance entity.
// If the ServiceInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceInstanceMutation) OldBinaryChecksum(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBinaryChecksum is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBinaryChecksum requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBinaryChecksum: %w", err)
	}
	return oldValue.BinaryChecksum, nil
}

// ClearBinaryChecksum clears the value of the "binary_checksum" field.
func (m *ServiceInstanceMutation) ClearBinaryChecksum() {
	m.binary_checksum = nil
	m.clearedFields[serviceinstance.FieldBinaryChecksum] = struct{}{}
}

// BinaryChecksumCleared returns if the "binary_checksum" field was cleared in this mutation.
func (m *ServiceInstanceMutation) BinaryChecksumCleared() bool {
	_, ok := m.clearedFields[serviceinstance.FieldBinaryChecksum]
	return ok
}

// ResetBinaryChecksum resets all changes to the "binary_checksum" field.
func (m *ServiceInstanceMutation) ResetBinaryChecksum() {
	m.binary_checksum = nil
	delete(m.clearedFields, serviceinstance.FieldBinaryChecksum)
}

// SetMemoryLimit sets the "memory_limit" field.
func (m *ServiceInstanceMutation) SetMemoryLimit(i int64) {
	m.memory_limit = &i
	m.addmemory_limit = nil
}

// MemoryLimit returns the value of the "memory_limit" field in the mutation.
func (m *ServiceInstanceMutation) MemoryLimit() (r int64, exists bool) {
	v := m.memory_limit
	if v == nil {
		return
	}
	return *v, true
}

// OldMemoryLimit returns the old "memory_limit" field's value of the ServiceInstance entity.
// If the ServiceInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceInstanceMutation) OldMemoryLimit(ctx context.Context) (v *int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMemoryLimit is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMemoryLimit requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMemoryLimit: %w", err)
	}
	return oldValue.MemoryLimit, nil
}

// AddMemoryLimit adds i to the "memory_limit" field.
func (m *ServiceInstanceMutation) AddMemoryLimit(i int64) {
	if m.addmemory_limit != nil {
		*m.addmemory_limit += i
	} else {
		m.addmemory_limit = &i
	}
}

// AddedMemoryLimit returns the value that was added to the "memory_limit" field in this mutation.
func (m *ServiceInstanceMutation) AddedMemoryLimit() (r int64, exists bool) {
	v := m.addmemory_limit
	if v == nil {
		return
	}
	return *v, true
}

// ClearMemoryLimit clears the value of the "memory_limit" field.
func (m *ServiceInstanceMutation) ClearMemoryLimit() {
	m.memory_limit = nil
	m.addmemory_limit = nil
	m.clearedFields[serviceinstance.FieldMemoryLimit] = struct{}{}
}

// MemoryLimitCleared returns if the "memory_limit" field was cleared in this mutation.
func (m *ServiceInstanceMutation) MemoryLimitCleared() bool {
	_, ok := m.clearedFields[serviceinstance.FieldMemoryLimit]
	return ok
}

// ResetMemoryLimit resets all changes to the "memory_limit" field.
func (m *ServiceInstanceMutation) ResetMemoryLimit() {
	m.memory_limit = nil
	m.addmemory_limit = nil
	delete(m.clearedFields, serviceinstance.FieldMemoryLimit)
}

// SetCPUWeight sets the "cpu_weight" field.
func (m *ServiceInstanceMutation) SetCPUWeight(i int) {
	m.cpu_weight = &i
	m.addcpu_weight = nil
}

// CPUWeight returns the value of the "cpu_weight" field in the mutation.
func (m *ServiceInstanceMutation) CPUWeight() (r int, exists bool) {
	v := m.cpu_weight
	if v == nil {
		return
	}
	return *v, true
}

// OldCPUWeight returns the old "cpu_weight" field's value of the ServiceInstance entity.
// If the ServiceInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceInstanceMutation) OldCPUWeight(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCPUWeight is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCPUWeight requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCPUWeight: %w", err)
	}
	return oldValue.CPUWeight, nil
}

// AddCPUWeight adds i to the "cpu_weight" field.
func (m *ServiceInstanceMutation) AddCPUWeight(i int) {
	if m.addcpu_weight != nil {
		*m.addcpu_weight += i
	} else {
		m.addcpu_weight = &i
	}
}

// AddedCPUWeight returns the value that was added to the "cpu_weight" field in this mutation.
func (m *ServiceInstanceMutation) AddedCPUWeight() (r int, exists bool) {
	v := m.addcpu_weight
	if v == nil {
		return
	}
	return *v, true
}

// ClearCPUWeight clears the value of the "cpu_weight" field.
func (m *ServiceInstanceMutation) ClearCPUWeight() {
	m.cpu_weight = nil
	m.addcpu_weight = nil
	m.clearedFields[serviceinstance.FieldCPUWeight] = struct{}{}
}

// CPUWeightCleared returns if the "cpu_weight" field was cleared in this mutation.
func (m *ServiceInstanceMutation) CPUWeightCleared() bool {
	_, ok := m.clearedFields[serviceinstance.FieldCPUWeight]
	return ok
}

// ResetCPUWeight resets all changes to the "cpu_weight" field.
func (m *ServiceInstanceMutation) ResetCPUWeight() {
	m.cpu_weight = nil
	m.addcpu_weight = nil
	delete(m.clearedFields, serviceinstance.FieldCPUWeight)
}

// SetVerificationEnabled sets the "verification_enabled" field.
func (m *ServiceInstanceMutation) SetVerificationEnabled(b bool) {
	m.verification_enabled = &b
}

// VerificationEnabled returns the value of the "verification_enabled" field in the mutation.
func (m *ServiceInstanceMutation) VerificationEnabled() (r bool, exists bool) {
	v := m.verification_enabled
	if v == nil {
		return
	}
	return *v, true
}

// OldVerificationEnabled returns the old "verification_enabled" field's value of the ServiceInstance entity.
// If the ServiceInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceInstanceMutation) OldVerificationEnabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVerificationEnabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVerificationEnabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVerificationEnabled: %w", err)
	}
	return oldValue.VerificationEnabled, nil
}

// ResetVerificationEnabled resets all changes to the "verification_enabled" field.
func (m *ServiceInstanceMutation) ResetVerificationEnabled() {
	m.verification_enabled = nil
}

// SetArchiveHash sets the "archive_hash" field.
func (m *ServiceInstanceMutation) SetArchiveHash(s string) {
	m.archive_hash = &s
}

// ArchiveHash returns the value of the "archive_hash" field in the mutation.
func (m *ServiceInstanceMutation) ArchiveHash() (r string, exists bool) {
	v := m.archive_hash
	if v == nil {
		return
	}
	return *v, true
}

// OldArchiveHash returns the old "archive_hash" field's value of the ServiceInstance entity.
// If the ServiceInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceInstanceMutation) OldArchiveHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldArchiveHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldArchiveHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldArchiveHash: %w", err)
	}
	return oldValue.ArchiveHash, nil
}

// ClearArchiveHash clears the value of the "archive_hash" field.
func (m *ServiceInstanceMutation) ClearArchiveHash() {
	m.archive_hash = nil
	m.clearedFields[serviceinstance.FieldArchiveHash] = struct{}{}
}

// ArchiveHashCleared returns if the "archive_hash" field was cleared in this mutation.
func (m *ServiceInstanceMutation) ArchiveHashCleared() bool {
	_, ok := m.clearedFields[serviceinstance.FieldArchiveHash]
	return ok
}

// ResetArchiveHash resets all changes to the "archive_hash" field.
func (m *ServiceInstanceMutation) ResetArchiveHash() {
	m.archive_hash = nil
	delete(m.clearedFields, serviceinstance.FieldArchiveHash)
}

// SetBinaryHash sets the "binary_hash" field.
func (m *ServiceInstanceMutation) SetBinaryHash(s string) {
	m.binary_hash = &s
}

// BinaryHash returns the value of the "binary_hash" field in the mutation.
func (m *ServiceInstanceMutation) BinaryHash() (r string, exists bool) {
	v := m.binary_hash
	if v == nil {
		return
	}
	return *v, true
}

// OldBinaryHash returns the old "binary_hash" field's value of the ServiceInstance entity.
// If the ServiceInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceInstanceMutation) OldBinaryHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBinaryHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBinaryHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBinaryHash: %w", err)
	}
	return oldValue.BinaryHash, nil
}

// ClearBinaryHash clears the value of the "binary_hash" field.
func (m *ServiceInstanceMutation) ClearBinaryHash() {
	m.binary_hash = nil
	m.clearedFields[serviceinstance.FieldBinaryHash] = struct{}{}
}

// BinaryHashCleared returns if the "binary_hash" field was cleared in this mutation.
func (m *ServiceInstanceMutation) BinaryHashCleared() bool {
	_, ok := m.clearedFields[serviceinstance.FieldBinaryHash]
	return ok
}

// ResetBinaryHash resets all changes to the "binary_hash" field.
func (m *ServiceInstanceMutation) ResetBinaryHash() {
	m.binary_hash = nil
	delete(m.clearedFields, serviceinstance.FieldBinaryHash)
}

// SetGpgVerified sets the "gpg_verified" field.
func (m *ServiceInstanceMutation) SetGpgVerified(b bool) {
	m.gpg_verified = &b
}

// GpgVerified returns the value of the "gpg_verified" field in the mutation.
func (m *ServiceInstanceMutation) GpgVerified() (r bool, exists bool) {
	v := m.gpg_verified
	if v == nil {
		return
	}
	return *v, true
}

// OldGpgVerified returns the old "gpg_verified" field's value of the ServiceInstance entity.
// If the ServiceInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceInstanceMutation) OldGpgVerified(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGpgVerified is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGpgVerified requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGpgVerified: %w", err)
	}
	return oldValue.GpgVerified, nil
}

// ResetGpgVerified resets all changes to the "gpg_verified" field.
func (m *ServiceInstanceMutation) ResetGpgVerified() {
	m.gpg_verified = nil
}

// SetGpgKeyID sets the "gpg_key_id" field.
func (m *ServiceInstanceMutation) SetGpgKeyID(s string) {
	m.gpg_key_id = &s
}

// GpgKeyID returns the value of the "gpg_key_id" field in the mutation.
func (m *ServiceInstanceMutation) GpgKeyID() (r string, exists bool) {
	v := m.gpg_key_id
	if v == nil {
		return
	}
	return *v, true
}

// OldGpgKeyID returns the old "gpg_key_id" field's value of the ServiceInstance entity.
// If the ServiceInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceInstanceMutation) OldGpgKeyID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGpgKeyID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGpgKeyID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGpgKeyID: %w", err)
	}
	return oldValue.GpgKeyID, nil
}

// ClearGpgKeyID clears the value of the "gpg_key_id" field.
func (m *ServiceInstanceMutation) ClearGpgKeyID() {
	m.gpg_key_id = nil
	m.clearedFields[serviceinstance.FieldGpgKeyID] = struct{}{}
}

// GpgKeyIDCleared returns if the "gpg_key_id" field was cleared in this mutation.
func (m *ServiceInstanceMutation) GpgKeyIDCleared() bool {
	_, ok := m.clearedFields[serviceinstance.FieldGpgKeyID]
	return ok
}

// ResetGpgKeyID resets all changes to the "gpg_key_id" field.
func (m *ServiceInstanceMutation) ResetGpgKeyID() {
	m.gpg_key_id = nil
	delete(m.clearedFields, serviceinstance.FieldGpgKeyID)
}

// SetChecksumsURL sets the "checksums_url" field.
func (m *ServiceInstanceMutation) SetChecksumsURL(s string) {
	m.checksums_url = &s
}

// ChecksumsURL returns the value of the "checksums_url" field in the mutation.
func (m *ServiceInstanceMutation) ChecksumsURL() (r string, exists bool) {
	v := m.checksums_url
	if v == nil {
		return
	}
	return *v, true
}

// OldChecksumsURL returns the old "checksums_url" field's value of the ServiceInstance entity.
// If the ServiceInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceInstanceMutation) OldChecksumsURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChecksumsURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChecksumsURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChecksumsURL: %w", err)
	}
	return oldValue.ChecksumsURL, nil
}

// ClearChecksumsURL clears the value of the "checksums_url" field.
func (m *ServiceInstanceMutation) ClearChecksumsURL() {
	m.checksums_url = nil
	m.clearedFields[serviceinstance.FieldChecksumsURL] = struct{}{}
}

// ChecksumsURLCleared returns if the "checksums_url" field was cleared in this mutation.
func (m *ServiceInstanceMutation) ChecksumsURLCleared() bool {
	_, ok := m.clearedFields[serviceinstance.FieldChecksumsURL]
	return ok
}

// ResetChecksumsURL resets all changes to the "checksums_url" field.
func (m *ServiceInstanceMutation) ResetChecksumsURL() {
	m.checksums_url = nil
	delete(m.clearedFields, serviceinstance.FieldChecksumsURL)
}

// SetVerifiedAt sets the "verified_at" field.
func (m *ServiceInstanceMutation) SetVerifiedAt(t time.Time) {
	m.verified_at = &t
}

// VerifiedAt returns the value of the "verified_at" field in the mutation.
func (m *ServiceInstanceMutation) VerifiedAt() (r time.Time, exists bool) {
	v := m.verified_at
	if v == nil {
		return
	}
	return *v, true
}

// OldVerifiedAt returns the old "verified_at" field's value of the ServiceInstance entity.
// If the ServiceInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceInstanceMutation) OldVerifiedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVerifiedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVerifiedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVerifiedAt: %w", err)
	}
	return oldValue.VerifiedAt, nil
}

// ClearVerifiedAt clears the value of the "verified_at" field.
func (m *ServiceInstanceMutation) ClearVerifiedAt() {
	m.verified_at = nil
	m.clearedFields[serviceinstance.FieldVerifiedAt] = struct{}{}
}

// VerifiedAtCleared returns if the "verified_at" field was cleared in this mutation.
func (m *ServiceInstanceMutation) VerifiedAtCleared() bool {
	_, ok := m.clearedFields[serviceinstance.FieldVerifiedAt]
	return ok
}

// ResetVerifiedAt resets all changes to the "verified_at" field.
func (m *ServiceInstanceMutation) ResetVerifiedAt() {
	m.verified_at = nil
	delete(m.clearedFields, serviceinstance.FieldVerifiedAt)
}

// SetUnavailableReason sets the "unavailable_reason" field.
func (m *ServiceInstanceMutation) SetUnavailableReason(s string) {
	m.unavailable_reason = &s
}

// UnavailableReason returns the value of the "unavailable_reason" field in the mutation.
func (m *ServiceInstanceMutation) UnavailableReason() (r string, exists bool) {
	v := m.unavailable_reason
	if v == nil {
		return
	}
	return *v, true
}

// OldUnavailableReason returns the old "unavailable_reason" field's value of the ServiceInstance entity.
// If the ServiceInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceInstanceMutation) OldUnavailableReason(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUnavailableReason is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUnavailableReason requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUnavailableReason: %w", err)
	}
	return oldValue.UnavailableReason, nil
}

// ClearUnavailableReason clears the value of the "unavailable_reason" field.
func (m *ServiceInstanceMutation) ClearUnavailableReason() {
	m.unavailable_reason = nil
	m.clearedFields[serviceinstance.FieldUnavailableReason] = struct{}{}
}

// UnavailableReasonCleared returns if the "unavailable_reason" field was cleared in this mutation.
func (m *ServiceInstanceMutation) UnavailableReasonCleared() bool {
	_, ok := m.clearedFields[serviceinstance.FieldUnavailableReason]
	return ok
}

// ResetUnavailableReason resets all changes to the "unavailable_reason" field.
func (m *ServiceInstanceMutation) ResetUnavailableReason() {
	m.unavailable_reason = nil
	delete(m.clearedFields, serviceinstance.FieldUnavailableReason)
}

// SetAutoStart sets the "auto_start" field.
func (m *ServiceInstanceMutation) SetAutoStart(b bool) {
	m.auto_start = &b
}

// AutoStart returns the value of the "auto_start" field in the mutation.
func (m *ServiceInstanceMutation) AutoStart() (r bool, exists bool) {
	v := m.auto_start
	if v == nil {
		return
	}
	return *v, true
}

// OldAutoStart returns the old "auto_start" field's value of the ServiceInstance entity.
// If the ServiceInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceInstanceMutation) OldAutoStart(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAutoStart is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAutoStart requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAutoStart: %w", err)
	}
	return oldValue.AutoStart, nil
}

// ResetAutoStart resets all changes to the "auto_start" field.
func (m *ServiceInstanceMutation) ResetAutoStart() {
	m.auto_start = nil
}

// SetHealthStatus sets the "health_status" field.
func (m *ServiceInstanceMutation) SetHealthStatus(ss serviceinstance.HealthStatus) {
	m.health_status = &ss
}

// HealthStatus returns the value of the "health_status" field in the mutation.
func (m *ServiceInstanceMutation) HealthStatus() (r serviceinstance.HealthStatus, exists bool) {
	v := m.health_status
	if v == nil {
		return
	}
	return *v, true
}

// OldHealthStatus returns the old "health_status" field's value of the ServiceInstance entity.
// If the ServiceInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceInstanceMutation) OldHealthStatus(ctx context.Context) (v serviceinstance.HealthStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHealthStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHealthStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHealthStatus: %w", err)
	}
	return oldValue.HealthStatus, nil
}

// ResetHealthStatus resets all changes to the "health_status" field.
func (m *ServiceInstanceMutation) ResetHealthStatus() {
	m.health_status = nil
}

// SetHealthProcessAlive sets the "health_process_alive" field.
func (m *ServiceInstanceMutation) SetHealthProcessAlive(b bool) {
	m.health_process_alive = &b
}

// HealthProcessAlive returns the value of the "health_process_alive" field in the mutation.
func (m *ServiceInstanceMutation) HealthProcessAlive() (r bool, exists bool) {
	v := m.health_process_alive
	if v == nil {
		return
	}
	return *v, true
}

// OldHealthProcessAlive returns the old "health_process_alive" field's value of the ServiceInstance entity.
// If the ServiceInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceInstanceMutation) OldHealthProcessAlive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHealthProcessAlive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHealthProcessAlive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHealthProcessAlive: %w", err)
	}
	return oldValue.HealthProcessAlive, nil
}

// ResetHealthProcessAlive resets all changes to the "health_process_alive" field.
func (m *ServiceInstanceMutation) ResetHealthProcessAlive() {
	m.health_process_alive = nil
}

// SetHealthConnectionStatus sets the "health_connection_status" field.
func (m *ServiceInstanceMutation) SetHealthConnectionStatus(scs serviceinstance.HealthConnectionStatus) {
	m.health_connection_status = &scs
}

// HealthConnectionStatus returns the value of the "health_connection_status" field in the mutation.
func (m *ServiceInstanceMutation) HealthConnectionStatus() (r serviceinstance.HealthConnectionStatus, exists bool) {
	v := m.health_connection_status
	if v == nil {
		return
	}
	return *v, true
}

// OldHealthConnectionStatus returns the old "health_connection_status" field's value of the ServiceInstance entity.
// If the ServiceInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceInstanceMutation) OldHealthConnectionStatus(ctx context.Context) (v serviceinstance.HealthConnectionStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHealthConnectionStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHealthConnectionStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHealthConnectionStatus: %w", err)
	}
	return oldValue.HealthConnectionStatus, nil
}

// ResetHealthConnectionStatus resets all changes to the "health_connection_status" field.
func (m *ServiceInstanceMutation) ResetHealthConnectionStatus() {
	m.health_connection_status = nil
}

// SetHealthLatencyMs sets the "health_latency_ms" field.
func (m *ServiceInstanceMutation) SetHealthLatencyMs(i int) {
	m.health_latency_ms = &i
	m.addhealth_latency_ms = nil
}

// HealthLatencyMs returns the value of the "health_latency_ms" field in the mutation.
func (m *ServiceInstanceMutation) HealthLatencyMs() (r int, exists bool) {
	v := m.health_latency_ms
	if v == nil {
		return
	}
	return *v, true
}

// OldHealthLatencyMs returns the old "health_latency_ms" field's value of the ServiceInstance entity.
// If the ServiceInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceInstanceMutation) OldHealthLatencyMs(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHealthLatencyMs is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHealthLatencyMs requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHealthLatencyMs: %w", err)
	}
	return oldValue.HealthLatencyMs, nil
}

// AddHealthLatencyMs adds i to the "health_latency_ms" field.
func (m *ServiceInstanceMutation) AddHealthLatencyMs(i int) {
	if m.addhealth_latency_ms != nil {
		*m.addhealth_latency_ms += i
	} else {
		m.addhealth_latency_ms = &i
	}
}

// AddedHealthLatencyMs returns the value that was added to the "health_latency_ms" field in this mutation.
func (m *ServiceInstanceMutation) AddedHealthLatencyMs() (r int, exists bool) {
	v := m.addhealth_latency_ms
	if v == nil {
		return
	}
	return *v, true
}

// ClearHealthLatencyMs clears the value of the "health_latency_ms" field.
func (m *ServiceInstanceMutation) ClearHealthLatencyMs() {
	m.health_latency_ms = nil
	m.addhealth_latency_ms = nil
	m.clearedFields[serviceinstance.FieldHealthLatencyMs] = struct{}{}
}

// HealthLatencyMsCleared returns if the "health_latency_ms" field was cleared in this mutation.
func (m *ServiceInstanceMutation) HealthLatencyMsCleared() bool {
	_, ok := m.clearedFields[serviceinstance.FieldHealthLatencyMs]
	return ok
}

// ResetHealthLatencyMs resets all changes to the "health_latency_ms" field.
func (m *ServiceInstanceMutation) ResetHealthLatencyMs() {
	m.health_latency_ms = nil
	m.addhealth_latency_ms = nil
	delete(m.clearedFields, serviceinstance.FieldHealthLatencyMs)
}

// SetHealthLastHealthyAt sets the "health_last_healthy_at" field.
func (m *ServiceInstanceMutation) SetHealthLastHealthyAt(t time.Time) {
	m.health_last_healthy_at = &t
}

// HealthLastHealthyAt returns the value of the "health_last_healthy_at" field in the mutation.
func (m *ServiceInstanceMutation) HealthLastHealthyAt() (r time.Time, exists bool) {
	v := m.health_last_healthy_at
	if v == nil {
		return
	}
	return *v, true
}

// OldHealthLastHealthyAt returns the old "health_last_healthy_at" field's value of the ServiceInstance entity.
// If the ServiceInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceInstanceMutation) OldHealthLastHealthyAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHealthLastHealthyAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHealthLastHealthyAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHealthLastHealthyAt: %w", err)
	}
	return oldValue.HealthLastHealthyAt, nil
}

// ClearHealthLastHealthyAt clears the value of the "health_last_healthy_at" field.
func (m *ServiceInstanceMutation) ClearHealthLastHealthyAt() {
	m.health_last_healthy_at = nil
	m.clearedFields[serviceinstance.FieldHealthLastHealthyAt] = struct{}{}
}

// HealthLastHealthyAtCleared returns if the "health_last_healthy_at" field was cleared in this mutation.
func (m *ServiceInstanceMutation) HealthLastHealthyAtCleared() bool {
	_, ok := m.clearedFields[serviceinstance.FieldHealthLastHealthyAt]
	return ok
}

// ResetHealthLastHealthyAt resets all changes to the "health_last_healthy_at" field.
func (m *ServiceInstanceMutation) ResetHealthLastHealthyAt() {
	m.health_last_healthy_at = nil
	delete(m.clearedFields, serviceinstance.FieldHealthLastHealthyAt)
}

// SetHealthConsecutiveFails sets the "health_consecutive_fails" field.
func (m *ServiceInstanceMutation) SetHealthConsecutiveFails(i int) {
	m.health_consecutive_fails = &i
	m.addhealth_consecutive_fails = nil
}

// HealthConsecutiveFails returns the value of the "health_consecutive_fails" field in the mutation.
func (m *ServiceInstanceMutation) HealthConsecutiveFails() (r int, exists bool) {
	v := m.health_consecutive_fails
	if v == nil {
		return
	}
	return *v, true
}

// OldHealthConsecutiveFails returns the old "health_consecutive_fails" field's value of the ServiceInstance entity.
// If the ServiceInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceInstanceMutation) OldHealthConsecutiveFails(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHealthConsecutiveFails is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHealthConsecutiveFails requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHealthConsecutiveFails: %w", err)
	}
	return oldValue.HealthConsecutiveFails, nil
}

// AddHealthConsecutiveFails adds i to the "health_consecutive_fails" field.
func (m *ServiceInstanceMutation) AddHealthConsecutiveFails(i int) {
	if m.addhealth_consecutive_fails != nil {
		*m.addhealth_consecutive_fails += i
	} else {
		m.addhealth_consecutive_fails = &i
	}
}

// AddedHealthConsecutiveFails returns the value that was added to the "health_consecutive_fails" field in this mutation.
func (m *ServiceInstanceMutation) AddedHealthConsecutiveFails() (r int, exists bool) {
	v := m.addhealth_consecutive_fails
	if v == nil {
		return
	}
	return *v, true
}

// ResetHealthConsecutiveFails resets all changes to the "health_consecutive_fails" field.
func (m *ServiceInstanceMutation) ResetHealthConsecutiveFails() {
	m.health_consecutive_fails = nil
	m.addhealth_consecutive_fails = nil
}

// SetHealthCheckIntervalSeconds sets the "health_check_interval_seconds" field.
func (m *ServiceInstanceMutation) SetHealthCheckIntervalSeconds(i int) {
	m.health_check_interval_seconds = &i
	m.addhealth_check_interval_seconds = nil
}

// HealthCheckIntervalSeconds returns the value of the "health_check_interval_seconds" field in the mutation.
func (m *ServiceInstanceMutation) HealthCheckIntervalSeconds() (r int, exists bool) {
	v := m.health_check_interval_seconds
	if v == nil {
		return
	}
	return *v, true
}

// OldHealthCheckIntervalSeconds returns the old "health_check_interval_seconds" field's value of the ServiceInstance entity.
// If the ServiceInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceInstanceMutation) OldHealthCheckIntervalSeconds(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHealthCheckIntervalSeconds is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHealthCheckIntervalSeconds requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHealthCheckIntervalSeconds: %w", err)
	}
	return oldValue.HealthCheckIntervalSeconds, nil
}

// AddHealthCheckIntervalSeconds adds i to the "health_check_interval_seconds" field.
func (m *ServiceInstanceMutation) AddHealthCheckIntervalSeconds(i int) {
	if m.addhealth_check_interval_seconds != nil {
		*m.addhealth_check_interval_seconds += i
	} else {
		m.addhealth_check_interval_seconds = &i
	}
}

// AddedHealthCheckIntervalSeconds returns the value that was added to the "health_check_interval_seconds" field in this mutation.
func (m *ServiceInstanceMutation) AddedHealthCheckIntervalSeconds() (r int, exists bool) {
	v := m.addhealth_check_interval_seconds
	if v == nil {
		return
	}
	return *v, true
}

// ResetHealthCheckIntervalSeconds resets all changes to the "health_check_interval_seconds" field.
func (m *ServiceInstanceMutation) ResetHealthCheckIntervalSeconds() {
	m.health_check_interval_seconds = nil
	m.addhealth_check_interval_seconds = nil
}

// SetHealthFailureThreshold sets the "health_failure_threshold" field.
func (m *ServiceInstanceMutation) SetHealthFailureThreshold(i int) {
	m.health_failure_threshold = &i
	m.addhealth_failure_threshold = nil
}

// HealthFailureThreshold returns the value of the "health_failure_threshold" field in the mutation.
func (m *ServiceInstanceMutation) HealthFailureThreshold() (r int, exists bool) {
	v := m.health_failure_threshold
	if v == nil {
		return
	}
	return *v, true
}

// OldHealthFailureThreshold returns the old "health_failure_threshold" field's value of the ServiceInstance entity.
// If the ServiceInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceInstanceMutation) OldHealthFailureThreshold(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHealthFailureThreshold is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHealthFailureThreshold requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHealthFailureThreshold: %w", err)
	}
	return oldValue.HealthFailureThreshold, nil
}

// AddHealthFailureThreshold adds i to the "health_failure_threshold" field.
func (m *ServiceInstanceMutation) AddHealthFailureThreshold(i int) {
	if m.addhealth_failure_threshold != nil {
		*m.addhealth_failure_threshold += i
	} else {
		m.addhealth_failure_threshold = &i
	}
}

// AddedHealthFailureThreshold returns the value that was added to the "health_failure_threshold" field in this mutation.
func (m *ServiceInstanceMutation) AddedHealthFailureThreshold() (r int, exists bool) {
	v := m.addhealth_failure_threshold
	if v == nil {
		return
	}
	return *v, true
}

// ResetHealthFailureThreshold resets all changes to the "health_failure_threshold" field.
func (m *ServiceInstanceMutation) ResetHealthFailureThreshold() {
	m.health_failure_threshold = nil
	m.addhealth_failure_threshold = nil
}

// SetQuotaBytes sets the "quota_bytes" field.
func (m *ServiceInstanceMutation) SetQuotaBytes(i int64) {
	m.quota_bytes = &i
	m.addquota_bytes = nil
}

// QuotaBytes returns the value of the "quota_bytes" field in the mutation.
func (m *ServiceInstanceMutation) QuotaBytes() (r int64, exists bool) {
	v := m.quota_bytes
	if v == nil {
		return
	}
	return *v, true
}

// OldQuotaBytes returns the old "quota_bytes" field's value of the ServiceInstance entity.
// If the ServiceInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceInstanceMutation) OldQuotaBytes(ctx context.Context) (v *int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQuotaBytes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQuotaBytes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQuotaBytes: %w", err)
	}
	return oldValue.QuotaBytes, nil
}

// AddQuotaBytes adds i to the "quota_bytes" field.
func (m *ServiceInstanceMutation) AddQuotaBytes(i int64) {
	if m.addquota_bytes != nil {
		*m.addquota_bytes += i
	} else {
		m.addquota_bytes = &i
	}
}

// AddedQuotaBytes returns the value that was added to the "quota_bytes" field in this mutation.
func (m *ServiceInstanceMutation) AddedQuotaBytes() (r int64, exists bool) {
	v := m.addquota_bytes
	if v == nil {
		return
	}
	return *v, true
}

// ClearQuotaBytes clears the value of the "quota_bytes" field.
func (m *ServiceInstanceMutation) ClearQuotaBytes() {
	m.quota_bytes = nil
	m.addquota_bytes = nil
	m.clearedFields[serviceinstance.FieldQuotaBytes] = struct{}{}
}

// QuotaBytesCleared returns if the "quota_bytes" field was cleared in this mutation.
func (m *ServiceInstanceMutation) QuotaBytesCleared() bool {
	_, ok := m.clearedFields[serviceinstance.FieldQuotaBytes]
	return ok
}

// ResetQuotaBytes resets all changes to the "quota_bytes" field.
func (m *ServiceInstanceMutation) ResetQuotaBytes() {
	m.quota_bytes = nil
	m.addquota_bytes = nil
	delete(m.clearedFields, serviceinstance.FieldQuotaBytes)
}

// SetQuotaPeriod sets the "quota_period" field.
func (m *ServiceInstanceMutation) SetQuotaPeriod(sp serviceinstance.QuotaPeriod) {
	m.quota_period = &sp
}

// QuotaPeriod returns the value of the "quota_period" field in the mutation.
func (m *ServiceInstanceMutation) QuotaPeriod() (r serviceinstance.QuotaPeriod, exists bool) {
	v := m.quota_period
	if v == nil {
		return
	}
	return *v, true
}

// OldQuotaPeriod returns the old "quota_period" field's value of the ServiceInstance entity.
// If the ServiceInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceInstanceMutation) OldQuotaPeriod(ctx context.Context) (v *serviceinstance.QuotaPeriod, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQuotaPeriod is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQuotaPeriod requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQuotaPeriod: %w", err)
	}
	return oldValue.QuotaPeriod, nil
}

// ClearQuotaPeriod clears the value of the "quota_period" field.
func (m *ServiceInstanceMutation) ClearQuotaPeriod() {
	m.quota_period = nil
	m.clearedFields[serviceinstance.FieldQuotaPeriod] = struct{}{}
}

// QuotaPeriodCleared returns if the "quota_period" field was cleared in this mutation.
func (m *ServiceInstanceMutation) QuotaPeriodCleared() bool {
	_, ok := m.clearedFields[serviceinstance.FieldQuotaPeriod]
	return ok
}

// ResetQuotaPeriod resets all changes to the "quota_period" field.
func (m *ServiceInstanceMutation) ResetQuotaPeriod() {
	m.quota_period = nil
	delete(m.clearedFields, serviceinstance.FieldQuotaPeriod)
}

// SetQuotaAction sets the "quota_action" field.
func (m *ServiceInstanceMutation) SetQuotaAction(sa serviceinstance.QuotaAction) {
	m.quota_action = &sa
}

// QuotaAction returns the value of the "quota_action" field in the mutation.
func (m *ServiceInstanceMutation) QuotaAction() (r serviceinstance.QuotaAction, exists bool) {
	v := m.quota_action
	if v == nil {
		return
	}
	return *v, true
}

// OldQuotaAction returns the old "quota_action" field's value of the ServiceInstance entity.
// If the ServiceInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceInstanceMutation) OldQuotaAction(ctx context.Context) (v *serviceinstance.QuotaAction, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQuotaAction is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQuotaAction requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQuotaAction: %w", err)
	}
	return oldValue.QuotaAction, nil
}

// ClearQuotaAction clears the value of the "quota_action" field.
func (m *ServiceInstanceMutation) ClearQuotaAction() {
	m.quota_action = nil
	m.clearedFields[serviceinstance.FieldQuotaAction] = struct{}{}
}

// QuotaActionCleared returns if the "quota_action" field was cleared in this mutation.
func (m *ServiceInstanceMutation) QuotaActionCleared() bool {
	_, ok := m.clearedFields[serviceinstance.FieldQuotaAction]
	return ok
}

// ResetQuotaAction resets all changes to the "quota_action" field.
func (m *ServiceInstanceMutation) ResetQuotaAction() {
	m.quota_action = nil
	delete(m.clearedFields, serviceinstance.FieldQuotaAction)
}

// SetQuotaUsedBytes sets the "quota_used_bytes" field.
func (m *ServiceInstanceMutation) SetQuotaUsedBytes(i int64) {
	m.quota_used_bytes = &i
	m.addquota_used_bytes = nil
}

// QuotaUsedBytes returns the value of the "quota_used_bytes" field in the mutation.
func (m *ServiceInstanceMutation) QuotaUsedBytes() (r int64, exists bool) {
	v := m.quota_used_bytes
	if v == nil {
		return
	}
	return *v, true
}

// OldQuotaUsedBytes returns the old "quota_used_bytes" field's value of the ServiceInstance entity.
// If the ServiceInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceInstanceMutation) OldQuotaUsedBytes(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQuotaUsedBytes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQuotaUsedBytes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQuotaUsedBytes: %w", err)
	}
	return oldValue.QuotaUsedBytes, nil
}

// AddQuotaUsedBytes adds i to the "quota_used_bytes" field.
func (m *ServiceInstanceMutation) AddQuotaUsedBytes(i int64) {
	if m.addquota_used_bytes != nil {
		*m.addquota_used_bytes += i
	} else {
		m.addquota_used_bytes = &i
	}
}

// AddedQuotaUsedBytes returns the value that was added to the "quota_used_bytes" field in this mutation.
func (m *ServiceInstanceMutation) AddedQuotaUsedBytes() (r int64, exists bool) {
	v := m.addquota_used_bytes
	if v == nil {
		return
	}
	return *v, true
}

// ResetQuotaUsedBytes resets all changes to the "quota_used_bytes" field.
func (m *ServiceInstanceMutation) ResetQuotaUsedBytes() {
	m.quota_used_bytes = nil
	m.addquota_used_bytes = nil
}

// SetQuotaResetAt sets the "quota_reset_at" field.
func (m *ServiceInstanceMutation) SetQuotaResetAt(t time.Time) {
	m.quota_reset_at = &t
}

// QuotaResetAt returns the value of the "quota_reset_at" field in the mutation.
func (m *ServiceInstanceMutation) QuotaResetAt() (r time.Time, exists bool) {
	v := m.quota_reset_at
	if v == nil {
		return
	}
	return *v, true
}

// OldQuotaResetAt returns the old "quota_reset_at" field's value of the ServiceInstance entity.
// If the ServiceInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceInstanceMutation) OldQuotaResetAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQuotaResetAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQuotaResetAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQuotaResetAt: %w", err)
	}
	return oldValue.QuotaResetAt, nil
}

// ClearQuotaResetAt clears the value of the "quota_reset_at" field.
func (m *ServiceInstanceMutation) ClearQuotaResetAt() {
	m.quota_reset_at = nil
	m.clearedFields[serviceinstance.FieldQuotaResetAt] = struct{}{}
}

// QuotaResetAtCleared returns if the "quota_reset_at" field was cleared in this mutation.
func (m *ServiceInstanceMutation) QuotaResetAtCleared() bool {
	_, ok := m.clearedFields[serviceinstance.FieldQuotaResetAt]
	return ok
}

// ResetQuotaResetAt resets all changes to the "quota_reset_at" field.
func (m *ServiceInstanceMutation) ResetQuotaResetAt() {
	m.quota_reset_at = nil
	delete(m.clearedFields, serviceinstance.FieldQuotaResetAt)
}

// SetAvailableUpdateVersion sets the "available_update_version" field.
func (m *ServiceInstanceMutation) SetAvailableUpdateVersion(s string) {
	m.available_update_version = &s
}

// AvailableUpdateVersion returns the value of the "available_update_version" field in the mutation.
func (m *ServiceInstanceMutation) AvailableUpdateVersion() (r string, exists bool) {
	v := m.available_update_version
	if v == nil {
		return
	}
	return *v, true
}

// OldAvailableUpdateVersion returns the old "available_update_version" field's value of the ServiceInstance entity.
// If the ServiceInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceInstanceMutation) OldAvailableUpdateVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAvailableUpdateVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAvailableUpdateVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAvailableUpdateVersion: %w", err)
	}
	return oldValue.AvailableUpdateVersion, nil
}

// ClearAvailableUpdateVersion clears the value of the "available_update_version" field.
func (m *ServiceInstanceMutation) ClearAvailableUpdateVersion() {
	m.available_update_version = nil
	m.clearedFields[serviceinstance.FieldAvailableUpdateVersion] = struct{}{}
}

// AvailableUpdateVersionCleared returns if the "available_update_version" field was cleared in this mutation.
func (m *ServiceInstanceMutation) AvailableUpdateVersionCleared() bool {
	_, ok := m.clearedFields[serviceinstance.FieldAvailableUpdateVersion]
	return ok
}

// ResetAvailableUpdateVersion resets all changes to the "available_update_version" field.
func (m *ServiceInstanceMutation) ResetAvailableUpdateVersion() {
	m.available_update_version = nil
	delete(m.clearedFields, serviceinstance.FieldAvailableUpdateVersion)
}

// SetAvailableUpdateSeverity sets the "available_update_severity" field.
func (m *ServiceInstanceMutation) SetAvailableUpdateSeverity(sus serviceinstance.AvailableUpdateSeverity) {
	m.available_update_severity = &sus
}

// AvailableUpdateSeverity returns the value of the "available_update_severity" field in the mutation.
func (m *ServiceInstanceMutation) AvailableUpdateSeverity() (r serviceinstance.AvailableUpdateSeverity, exists bool) {
	v := m.available_update_severity
	if v == nil {
		return
	}
	return *v, true
}

// OldAvailableUpdateSeverity returns the old "available_update_severity" field's value of the ServiceInstance entity.
// If the ServiceInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceInstanceMutation) OldAvailableUpdateSeverity(ctx context.Context) (v *serviceinstance.AvailableUpdateSeverity, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAvailableUpdateSeverity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAvailableUpdateSeverity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAvailableUpdateSeverity: %w", err)
	}
	return oldValue.AvailableUpdateSeverity, nil
}

// ClearAvailableUpdateSeverity clears the value of the "available_update_severity" field.
func (m *ServiceInstanceMutation) ClearAvailableUpdateSeverity() {
	m.available_update_severity = nil
	m.clearedFields[serviceinstance.FieldAvailableUpdateSeverity] = struct{}{}
}

// AvailableUpdateSeverityCleared returns if the "available_update_severity" field was cleared in this mutation.
func (m *ServiceInstanceMutation) AvailableUpdateSeverityCleared() bool {
	_, ok := m.clearedFields[serviceinstance.FieldAvailableUpdateSeverity]
	return ok
}

// ResetAvailableUpdateSeverity resets all changes to the "available_update_severity" field.
func (m *ServiceInstanceMutation) ResetAvailableUpdateSeverity() {
	m.available_update_severity = nil
	delete(m.clearedFields, serviceinstance.FieldAvailableUpdateSeverity)
}

// SetLastUpdateCheck sets the "last_update_check" field.
func (m *ServiceInstanceMutation) SetLastUpdateCheck(t time.Time) {
	m.last_update_check = &t
}

// LastUpdateCheck returns the value of the "last_update_check" field in the mutation.
func (m *ServiceInstanceMutation) LastUpdateCheck() (r time.Time, exists bool) {
	v := m.last_update_check
	if v == nil {
		return
	}
	return *v, true
}

// OldLastUpdateCheck returns the old "last_update_check" field's value of the ServiceInstance entity.
// If the ServiceInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceInstanceMutation) OldLastUpdateCheck(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastUpdateCheck is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastUpdateCheck requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastUpdateCheck: %w", err)
	}
	return oldValue.LastUpdateCheck, nil
}

// ClearLastUpdateCheck clears the value of the "last_update_check" field.
func (m *ServiceInstanceMutation) ClearLastUpdateCheck() {
	m.last_update_check = nil
	m.clearedFields[serviceinstance.FieldLastUpdateCheck] = struct{}{}
}

// LastUpdateCheckCleared returns if the "last_update_check" field was cleared in this mutation.
func (m *ServiceInstanceMutation) LastUpdateCheckCleared() bool {
	_, ok := m.clearedFields[serviceinstance.FieldLastUpdateCheck]
	return ok
}

// ResetLastUpdateCheck resets all changes to the "last_update_check" field.
func (m *ServiceInstanceMutation) ResetLastUpdateCheck() {
	m.last_update_check = nil
	delete(m.clearedFields, serviceinstance.FieldLastUpdateCheck)
}

// SetLastUpdateEtag sets the "last_update_etag" field.
func (m *ServiceInstanceMutation) SetLastUpdateEtag(s string) {
	m.last_update_etag = &s
}

// LastUpdateEtag returns the value of the "last_update_etag" field in the mutation.
func (m *ServiceInstanceMutation) LastUpdateEtag() (r string, exists bool) {
	v := m.last_update_etag
	if v == nil {
		return
	}
	return *v, true
}

// OldLastUpdateEtag returns the old "last_update_etag" field's value of the ServiceInstance entity.
// If the ServiceInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceInstanceMutation) OldLastUpdateEtag(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastUpdateEtag is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastUpdateEtag requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastUpdateEtag: %w", err)
	}
	return oldValue.LastUpdateEtag, nil
}

// ClearLastUpdateEtag clears the value of the "last_update_etag" field.
func (m *ServiceInstanceMutation) ClearLastUpdateEtag() {
	m.last_update_etag = nil
	m.clearedFields[serviceinstance.FieldLastUpdateEtag] = struct{}{}
}

// LastUpdateEtagCleared returns if the "last_update_etag" field was cleared in this mutation.
func (m *ServiceInstanceMutation) LastUpdateEtagCleared() bool {
	_, ok := m.clearedFields[serviceinstance.FieldLastUpdateEtag]
	return ok
}

// ResetLastUpdateEtag resets all changes to the "last_update_etag" field.
func (m *ServiceInstanceMutation) ResetLastUpdateEtag() {
	m.last_update_etag = nil
	delete(m.clearedFields, serviceinstance.FieldLastUpdateEtag)
}

// SetUpdateChangelogURL sets the "update_changelog_url" field.
func (m *ServiceInstanceMutation) SetUpdateChangelogURL(s string) {
	m.update_changelog_url = &s
}

// UpdateChangelogURL returns the value of the "update_changelog_url" field in the mutation.
func (m *ServiceInstanceMutation) UpdateChangelogURL() (r string, exists bool) {
	v := m.update_changelog_url
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateChangelogURL returns the old "update_changelog_url" field's value of the ServiceInstance entity.
// If the ServiceInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceInstanceMutation) OldUpdateChangelogURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateChangelogURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateChangelogURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateChangelogURL: %w", err)
	}
	return oldValue.UpdateChangelogURL, nil
}

// ClearUpdateChangelogURL clears the value of the "update_changelog_url" field.
func (m *ServiceInstanceMutation) ClearUpdateChangelogURL() {
	m.update_changelog_url = nil
	m.clearedFields[serviceinstance.FieldUpdateChangelogURL] = struct{}{}
}

// UpdateChangelogURLCleared returns if the "update_changelog_url" field was cleared in this mutation.
func (m *ServiceInstanceMutation) UpdateChangelogURLCleared() bool {
	_, ok := m.clearedFields[serviceinstance.FieldUpdateChangelogURL]
	return ok
}

// ResetUpdateChangelogURL resets all changes to the "update_changelog_url" field.
func (m *ServiceInstanceMutation) ResetUpdateChangelogURL() {
	m.update_changelog_url = nil
	delete(m.clearedFields, serviceinstance.FieldUpdateChangelogURL)
}

// SetUpdateCheckSchedule sets the "update_check_schedule" field.
func (m *ServiceInstanceMutation) SetUpdateCheckSchedule(s string) {
	m.update_check_schedule = &s
}

// UpdateCheckSchedule returns the value of the "update_check_schedule" field in the mutation.
func (m *ServiceInstanceMutation) UpdateCheckSchedule() (r string, exists bool) {
	v := m.update_check_schedule
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateCheckSchedule returns the old "update_check_schedule" field's value of the ServiceInstance entity.
// If the ServiceInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceInstanceMutation) OldUpdateCheckSchedule(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateCheckSchedule is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateCheckSchedule requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateCheckSchedule: %w", err)
	}
	return oldValue.UpdateCheckSchedule, nil
}

// ClearUpdateCheckSchedule clears the value of the "update_check_schedule" field.
func (m *ServiceInstanceMutation) ClearUpdateCheckSchedule() {
	m.update_check_schedule = nil
	m.clearedFields[serviceinstance.FieldUpdateCheckSchedule] = struct{}{}
}

// UpdateCheckScheduleCleared returns if the "update_check_schedule" field was cleared in this mutation.
func (m *ServiceInstanceMutation) UpdateCheckScheduleCleared() bool {
	_, ok := m.clearedFields[serviceinstance.FieldUpdateCheckSchedule]
	return ok
}

// ResetUpdateCheckSchedule resets all changes to the "update_check_schedule" field.
func (m *ServiceInstanceMutation) ResetUpdateCheckSchedule() {
	m.update_check_schedule = nil
	delete(m.clearedFields, serviceinstance.FieldUpdateCheckSchedule)
}

// SetAutoApplyThreshold sets the "auto_apply_threshold" field.
func (m *ServiceInstanceMutation) SetAutoApplyThreshold(sat serviceinstance.AutoApplyThreshold) {
	m.auto_apply_threshold = &sat
}

// AutoApplyThreshold returns the value of the "auto_apply_threshold" field in the mutation.
func (m *ServiceInstanceMutation) AutoApplyThreshold() (r serviceinstance.AutoApplyThreshold, exists bool) {
	v := m.auto_apply_threshold
	if v == nil {
		return
	}
	return *v, true
}

// OldAutoApplyThreshold returns the old "auto_apply_threshold" field's value of the ServiceInstance entity.
// If the ServiceInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceInstanceMutation) OldAutoApplyThreshold(ctx context.Context) (v *serviceinstance.AutoApplyThreshold, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAutoApplyThreshold is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAutoApplyThreshold requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAutoApplyThreshold: %w", err)
	}
	return oldValue.AutoApplyThreshold, nil
}

// ClearAutoApplyThreshold clears the value of the "auto_apply_threshold" field.
func (m *ServiceInstanceMutation) ClearAutoApplyThreshold() {
	m.auto_apply_threshold = nil
	m.clearedFields[serviceinstance.FieldAutoApplyThreshold] = struct{}{}
}

// AutoApplyThresholdCleared returns if the "auto_apply_threshold" field was cleared in this mutation.
func (m *ServiceInstanceMutation) AutoApplyThresholdCleared() bool {
	_, ok := m.clearedFields[serviceinstance.FieldAutoApplyThreshold]
	return ok
}

// ResetAutoApplyThreshold resets all changes to the "auto_apply_threshold" field.
func (m *ServiceInstanceMutation) ResetAutoApplyThreshold() {
	m.auto_apply_threshold = nil
	delete(m.clearedFields, serviceinstance.FieldAutoApplyThreshold)
}

// SetHasBackup sets the "has_backup" field.
func (m *ServiceInstanceMutation) SetHasBackup(b bool) {
	m.has_backup = &b
}

// HasBackup returns the value of the "has_backup" field in the mutation.
func (m *ServiceInstanceMutation) HasBackup() (r bool, exists bool) {
	v := m.has_backup
	if v == nil {
		return
	}
	return *v, true
}

// OldHasBackup returns the old "has_backup" field's value of the ServiceInstance entity.
// If the ServiceInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceInstanceMutation) OldHasBackup(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHasBackup is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHasBackup requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHasBackup: %w", err)
	}
	return oldValue.HasBackup, nil
}

// ResetHasBackup resets all changes to the "has_backup" field.
func (m *ServiceInstanceMutation) ResetHasBackup() {
	m.has_backup = nil
}

// SetBackupVersion sets the "backup_version" field.
func (m *ServiceInstanceMutation) SetBackupVersion(s string) {
	m.backup_version = &s
}

// BackupVersion returns the value of the "backup_version" field in the mutation.
func (m *ServiceInstanceMutation) BackupVersion() (r string, exists bool) {
	v := m.backup_version
	if v == nil {
		return
	}
	return *v, true
}

// OldBackupVersion returns the old "backup_version" field's value of the ServiceInstance entity.
// If the ServiceInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceInstanceMutation) OldBackupVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBackupVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBackupVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBackupVersion: %w", err)
	}
	return oldValue.BackupVersion, nil
}

// ClearBackupVersion clears the value of the "backup_version" field.
func (m *ServiceInstanceMutation) ClearBackupVersion() {
	m.backup_version = nil
	m.clearedFields[serviceinstance.FieldBackupVersion] = struct{}{}
}

// BackupVersionCleared returns if the "backup_version" field was cleared in this mutation.
func (m *ServiceInstanceMutation) BackupVersionCleared() bool {
	_, ok := m.clearedFields[serviceinstance.FieldBackupVersion]
	return ok
}

// ResetBackupVersion resets all changes to the "backup_version" field.
func (m *ServiceInstanceMutation) ResetBackupVersion() {
	m.backup_version = nil
	delete(m.clearedFields, serviceinstance.FieldBackupVersion)
}

// SetLastUpdatedAt sets the "last_updated_at" field.
func (m *ServiceInstanceMutation) SetLastUpdatedAt(t time.Time) {
	m.last_updated_at = &t
}

// LastUpdatedAt returns the value of the "last_updated_at" field in the mutation.
func (m *ServiceInstanceMutation) LastUpdatedAt() (r time.Time, exists bool) {
	v := m.last_updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldLastUpdatedAt returns the old "last_updated_at" field's value of the ServiceInstance entity.
// If the ServiceInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceInstanceMutation) OldLastUpdatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastUpdatedAt: %w", err)
	}
	return oldValue.LastUpdatedAt, nil
}

// ClearLastUpdatedAt clears the value of the "last_updated_at" field.
func (m *ServiceInstanceMutation) ClearLastUpdatedAt() {
	m.last_updated_at = nil
	m.clearedFields[serviceinstance.FieldLastUpdatedAt] = struct{}{}
}

// LastUpdatedAtCleared returns if the "last_updated_at" field was cleared in this mutation.
func (m *ServiceInstanceMutation) LastUpdatedAtCleared() bool {
	_, ok := m.clearedFields[serviceinstance.FieldLastUpdatedAt]
	return ok
}

// ResetLastUpdatedAt resets all changes to the "last_updated_at" field.
func (m *ServiceInstanceMutation) ResetLastUpdatedAt() {
	m.last_updated_at = nil
	delete(m.clearedFields, serviceinstance.FieldLastUpdatedAt)
}

// SetCreatedAt sets the "created_at" field.
func (m *ServiceInstanceMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ServiceInstanceMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ServiceInstance entity.
// If the ServiceInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceInstanceMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ServiceInstanceMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ServiceInstanceMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ServiceInstanceMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ServiceInstance entity.
// If the ServiceInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceInstanceMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ServiceInstanceMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearRouter clears the "router" edge to the Router entity.
func (m *ServiceInstanceMutation) ClearRouter() {
	m.clearedrouter = true
	m.clearedFields[serviceinstance.FieldRouterID] = struct{}{}
}

// RouterCleared reports if the "router" edge to the Router entity was cleared.
func (m *ServiceInstanceMutation) RouterCleared() bool {
	return m.clearedrouter
}

// RouterIDs returns the "router" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RouterID instead. It exists only for internal usage by the builders.
func (m *ServiceInstanceMutation) RouterIDs() (ids []string) {
	if id := m.router; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRouter resets all changes to the "router" edge.
func (m *ServiceInstanceMutation) ResetRouter() {
	m.router = nil
	m.clearedrouter = false
}

// AddPortAllocationIDs adds the "port_allocations" edge to the PortAllocation entity by ids.
func (m *ServiceInstanceMutation) AddPortAllocationIDs(ids ...string) {
	if m.port_allocations == nil {
		m.port_allocations = make(map[string]struct{})
	}
	for i := range ids {
		m.port_allocations[ids[i]] = struct{}{}
	}
}

// ClearPortAllocations clears the "port_allocations" edge to the PortAllocation entity.
func (m *ServiceInstanceMutation) ClearPortAllocations() {
	m.clearedport_allocations = true
}

// PortAllocationsCleared reports if the "port_allocations" edge to the PortAllocation entity was cleared.
func (m *ServiceInstanceMutation) PortAllocationsCleared() bool {
	return m.clearedport_allocations
}

// RemovePortAllocationIDs removes the "port_allocations" edge to the PortAllocation entity by IDs.
func (m *ServiceInstanceMutation) RemovePortAllocationIDs(ids ...string) {
	if m.removedport_allocations == nil {
		m.removedport_allocations = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.port_allocations, ids[i])
		m.removedport_allocations[ids[i]] = struct{}{}
	}
}

// RemovedPortAllocations returns the removed IDs of the "port_allocations" edge to the PortAllocation entity.
func (m *ServiceInstanceMutation) RemovedPortAllocationsIDs() (ids []string) {
	for id := range m.removedport_allocations {
		ids = append(ids, id)
	}
	return
}

// PortAllocationsIDs returns the "port_allocations" edge IDs in the mutation.
func (m *ServiceInstanceMutation) PortAllocationsIDs() (ids []string) {
	for id := range m.port_allocations {
		ids = append(ids, id)
	}
	return
}

// ResetPortAllocations resets all changes to the "port_allocations" edge.
func (m *ServiceInstanceMutation) ResetPortAllocations() {
	m.port_allocations = nil
	m.clearedport_allocations = false
	m.removedport_allocations = nil
}

// AddVlanAllocationIDs adds the "vlan_allocations" edge to the VLANAllocation entity by ids.
func (m *ServiceInstanceMutation) AddVlanAllocationIDs(ids ...string) {
	if m.vlan_allocations == nil {
		m.vlan_allocations = make(map[string]struct{})
	}
	for i := range ids {
		m.vlan_allocations[ids[i]] = struct{}{}
	}
}

// ClearVlanAllocations clears the "vlan_allocations" edge to the VLANAllocation entity.
func (m *ServiceInstanceMutation) ClearVlanAllocations() {
	m.clearedvlan_allocations = true
}

// VlanAllocationsCleared reports if the "vlan_allocations" edge to the VLANAllocation entity was cleared.
func (m *ServiceInstanceMutation) VlanAllocationsCleared() bool {
	return m.clearedvlan_allocations
}

// RemoveVlanAllocationIDs removes the "vlan_allocations" edge to the VLANAllocation entity by IDs.
func (m *ServiceInstanceMutation) RemoveVlanAllocationIDs(ids ...string) {
	if m.removedvlan_allocations == nil {
		m.removedvlan_allocations = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.vlan_allocations, ids[i])
		m.removedvlan_allocations[ids[i]] = struct{}{}
	}
}

// RemovedVlanAllocations returns the removed IDs of the "vlan_allocations" edge to the VLANAllocation entity.
func (m *ServiceInstanceMutation) RemovedVlanAllocationsIDs() (ids []string) {
	for id := range m.removedvlan_allocations {
		ids = append(ids, id)
	}
	return
}

// VlanAllocationsIDs returns the "vlan_allocations" edge IDs in the mutation.
func (m *ServiceInstanceMutation) VlanAllocationsIDs() (ids []string) {
	for id := range m.vlan_allocations {
		ids = append(ids, id)
	}
	return
}

// ResetVlanAllocations resets all changes to the "vlan_allocations" edge.
func (m *ServiceInstanceMutation) ResetVlanAllocations() {
	m.vlan_allocations = nil
	m.clearedvlan_allocations = false
	m.removedvlan_allocations = nil
}

// SetVirtualInterfaceID sets the "virtual_interface" edge to the VirtualInterface entity by id.
func (m *ServiceInstanceMutation) SetVirtualInterfaceID(id string) {
	m.virtual_interface = &id
}

// ClearVirtualInterface clears the "virtual_interface" edge to the VirtualInterface entity.
func (m *ServiceInstanceMutation) ClearVirtualInterface() {
	m.clearedvirtual_interface = true
}

// VirtualInterfaceCleared reports if the "virtual_interface" edge to the VirtualInterface entity was cleared.
func (m *ServiceInstanceMutation) VirtualInterfaceCleared() bool {
	return m.clearedvirtual_interface
}

// VirtualInterfaceID returns the "virtual_interface" edge ID in the mutation.
func (m *ServiceInstanceMutation) VirtualInterfaceID() (id string, exists bool) {
	if m.virtual_interface != nil {
		return *m.virtual_interface, true
	}
	return
}

// VirtualInterfaceIDs returns the "virtual_interface" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// VirtualInterfaceID instead. It exists only for internal usage by the builders.
func (m *ServiceInstanceMutation) VirtualInterfaceIDs() (ids []string) {
	if id := m.virtual_interface; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetVirtualInterface resets all changes to the "virtual_interface" edge.
func (m *ServiceInstanceMutation) ResetVirtualInterface() {
	m.virtual_interface = nil
	m.clearedvirtual_interface = false
}

// AddDependencyIDs adds the "dependencies" edge to the ServiceDependency entity by ids.
func (m *ServiceInstanceMutation) AddDependencyIDs(ids ...string) {
	if m.dependencies == nil {
		m.dependencies = make(map[string]struct{})
	}
	for i := range ids {
		m.dependencies[ids[i]] = struct{}{}
	}
}

// ClearDependencies clears the "dependencies" edge to the ServiceDependency entity.
func (m *ServiceInstanceMutation) ClearDependencies() {
	m.cleareddependencies = true
}

// DependenciesCleared reports if the "dependencies" edge to the ServiceDependency entity was cleared.
func (m *ServiceInstanceMutation) DependenciesCleared() bool {
	return m.cleareddependencies
}

// RemoveDependencyIDs removes the "dependencies" edge to the ServiceDependency entity by IDs.
func (m *ServiceInstanceMutation) RemoveDependencyIDs(ids ...string) {
	if m.removeddependencies == nil {
		m.removeddependencies = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.dependencies, ids[i])
		m.removeddependencies[ids[i]] = struct{}{}
	}
}

// RemovedDependencies returns the removed IDs of the "dependencies" edge to the ServiceDependency entity.
func (m *ServiceInstanceMutation) RemovedDependenciesIDs() (ids []string) {
	for id := range m.removeddependencies {
		ids = append(ids, id)
	}
	return
}

// DependenciesIDs returns the "dependencies" edge IDs in the mutation.
func (m *ServiceInstanceMutation) DependenciesIDs() (ids []string) {
	for id := range m.dependencies {
		ids = append(ids, id)
	}
	return
}

// ResetDependencies resets all changes to the "dependencies" edge.
func (m *ServiceInstanceMutation) ResetDependencies() {
	m.dependencies = nil
	m.cleareddependencies = false
	m.removeddependencies = nil
}

// AddDependentIDs adds the "dependents" edge to the ServiceDependency entity by ids.
func (m *ServiceInstanceMutation) AddDependentIDs(ids ...string) {
	if m.dependents == nil {
		m.dependents = make(map[string]struct{})
	}
	for i := range ids {
		m.dependents[ids[i]] = struct{}{}
	}
}

// ClearDependents clears the "dependents" edge to the ServiceDependency entity.
func (m *ServiceInstanceMutation) ClearDependents() {
	m.cleareddependents = true
}

// DependentsCleared reports if the "dependents" edge to the ServiceDependency entity was cleared.
func (m *ServiceInstanceMutation) DependentsCleared() bool {
	return m.cleareddependents
}

// RemoveDependentIDs removes the "dependents" edge to the ServiceDependency entity by IDs.
func (m *ServiceInstanceMutation) RemoveDependentIDs(ids ...string) {
	if m.removeddependents == nil {
		m.removeddependents = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.dependents, ids[i])
		m.removeddependents[ids[i]] = struct{}{}
	}
}

// RemovedDependents returns the removed IDs of the "dependents" edge to the ServiceDependency entity.
func (m *ServiceInstanceMutation) RemovedDependentsIDs() (ids []string) {
	for id := range m.removeddependents {
		ids = append(ids, id)
	}
	return
}

// DependentsIDs returns the "dependents" edge IDs in the mutation.
func (m *ServiceInstanceMutation) DependentsIDs() (ids []string) {
	for id := range m.dependents {
		ids = append(ids, id)
	}
	return
}

// ResetDependents resets all changes to the "dependents" edge.
func (m *ServiceInstanceMutation) ResetDependents() {
	m.dependents = nil
	m.cleareddependents = false
	m.removeddependents = nil
}

// AddDeviceRoutingIDs adds the "device_routings" edge to the DeviceRouting entity by ids.
func (m *ServiceInstanceMutation) AddDeviceRoutingIDs(ids ...string) {
	if m.device_routings == nil {
		m.device_routings = make(map[string]struct{})
	}
	for i := range ids {
		m.device_routings[ids[i]] = struct{}{}
	}
}

// ClearDeviceRoutings clears the "device_routings" edge to the DeviceRouting entity.
func (m *ServiceInstanceMutation) ClearDeviceRoutings() {
	m.cleareddevice_routings = true
}

// DeviceRoutingsCleared reports if the "device_routings" edge to the DeviceRouting entity was cleared.
func (m *ServiceInstanceMutation) DeviceRoutingsCleared() bool {
	return m.cleareddevice_routings
}

// RemoveDeviceRoutingIDs removes the "device_routings" edge to the DeviceRouting entity by IDs.
func (m *ServiceInstanceMutation) RemoveDeviceRoutingIDs(ids ...string) {
	if m.removeddevice_routings == nil {
		m.removeddevice_routings = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.device_routings, ids[i])
		m.removeddevice_routings[ids[i]] = struct{}{}
	}
}

// RemovedDeviceRoutings returns the removed IDs of the "device_routings" edge to the DeviceRouting entity.
func (m *ServiceInstanceMutation) RemovedDeviceRoutingsIDs() (ids []string) {
	for id := range m.removeddevice_routings {
		ids = append(ids, id)
	}
	return
}

// DeviceRoutingsIDs returns the "device_routings" edge IDs in the mutation.
func (m *ServiceInstanceMutation) DeviceRoutingsIDs() (ids []string) {
	for id := range m.device_routings {
		ids = append(ids, id)
	}
	return
}

// ResetDeviceRoutings resets all changes to the "device_routings" edge.
func (m *ServiceInstanceMutation) ResetDeviceRoutings() {
	m.device_routings = nil
	m.cleareddevice_routings = false
	m.removeddevice_routings = nil
}

// AddDiagnosticResultIDs adds the "diagnostic_results" edge to the DiagnosticResult entity by ids.
func (m *ServiceInstanceMutation) AddDiagnosticResultIDs(ids ...string) {
	if m.diagnostic_results == nil {
		m.diagnostic_results = make(map[string]struct{})
	}
	for i := range ids {
		m.diagnostic_results[ids[i]] = struct{}{}
	}
}

// ClearDiagnosticResults clears the "diagnostic_results" edge to the DiagnosticResult entity.
func (m *ServiceInstanceMutation) ClearDiagnosticResults() {
	m.cleareddiagnostic_results = true
}

// DiagnosticResultsCleared reports if the "diagnostic_results" edge to the DiagnosticResult entity was cleared.
func (m *ServiceInstanceMutation) DiagnosticResultsCleared() bool {
	return m.cleareddiagnostic_results
}

// RemoveDiagnosticResultIDs removes the "diagnostic_results" edge to the DiagnosticResult entity by IDs.
func (m *ServiceInstanceMutation) RemoveDiagnosticResultIDs(ids ...string) {
	if m.removeddiagnostic_results == nil {
		m.removeddiagnostic_results = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.diagnostic_results, ids[i])
		m.removeddiagnostic_results[ids[i]] = struct{}{}
	}
}

// RemovedDiagnosticResults returns the removed IDs of the "diagnostic_results" edge to the DiagnosticResult entity.
func (m *ServiceInstanceMutation) RemovedDiagnosticResultsIDs() (ids []string) {
	for id := range m.removeddiagnostic_results {
		ids = append(ids, id)
	}
	return
}

// DiagnosticResultsIDs returns the "diagnostic_results" edge IDs in the mutation.
func (m *ServiceInstanceMutation) DiagnosticResultsIDs() (ids []string) {
	for id := range m.diagnostic_results {
		ids = append(ids, id)
	}
	return
}

// ResetDiagnosticResults resets all changes to the "diagnostic_results" edge.
func (m *ServiceInstanceMutation) ResetDiagnosticResults() {
	m.diagnostic_results = nil
	m.cleareddiagnostic_results = false
	m.removeddiagnostic_results = nil
}

// AddTrafficHourlyIDs adds the "traffic_hourly" edge to the ServiceTrafficHourly entity by ids.
func (m *ServiceInstanceMutation) AddTrafficHourlyIDs(ids ...string) {
	if m.traffic_hourly == nil {
		m.traffic_hourly = make(map[string]struct{})
	}
	for i := range ids {
		m.traffic_hourly[ids[i]] = struct{}{}
	}
}

// ClearTrafficHourly clears the "traffic_hourly" edge to the ServiceTrafficHourly entity.
func (m *ServiceInstanceMutation) ClearTrafficHourly() {
	m.clearedtraffic_hourly = true
}

// TrafficHourlyCleared reports if the "traffic_hourly" edge to the ServiceTrafficHourly entity was cleared.
func (m *ServiceInstanceMutation) TrafficHourlyCleared() bool {
	return m.clearedtraffic_hourly
}

// RemoveTrafficHourlyIDs removes the "traffic_hourly" edge to the ServiceTrafficHourly entity by IDs.
func (m *ServiceInstanceMutation) RemoveTrafficHourlyIDs(ids ...string) {
	if m.removedtraffic_hourly == nil {
		m.removedtraffic_hourly = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.traffic_hourly, ids[i])
		m.removedtraffic_hourly[ids[i]] = struct{}{}
	}
}

// RemovedTrafficHourly returns the removed IDs of the "traffic_hourly" edge to the ServiceTrafficHourly entity.
func (m *ServiceInstanceMutation) RemovedTrafficHourlyIDs() (ids []string) {
	for id := range m.removedtraffic_hourly {
		ids = append(ids, id)
	}
	return
}

// TrafficHourlyIDs returns the "traffic_hourly" edge IDs in the mutation.
func (m *ServiceInstanceMutation) TrafficHourlyIDs() (ids []string) {
	for id := range m.traffic_hourly {
		ids = append(ids, id)
	}
	return
}

// ResetTrafficHourly resets all changes to the "traffic_hourly" edge.
func (m *ServiceInstanceMutation) ResetTrafficHourly() {
	m.traffic_hourly = nil
	m.clearedtraffic_hourly = false
	m.removedtraffic_hourly = nil
}

// Where appends a list predicates to the ServiceInstanceMutation builder.
func (m *ServiceInstanceMutation) Where(ps ...predicate.ServiceInstance) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ServiceInstanceMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ServiceInstanceMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ServiceInstance, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ServiceInstanceMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ServiceInstanceMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ServiceInstance).
func (m *ServiceInstanceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ServiceInstanceMutation) Fields() []string {
	fields := make([]string, 0, 47)
	if m.feature_id != nil {
		fields = append(fields, serviceinstance.FieldFeatureID)
	}
	if m.instance_name != nil {
		fields = append(fields, serviceinstance.FieldInstanceName)
	}
	if m.router != nil {
		fields = append(fields, serviceinstance.FieldRouterID)
	}
	if m.status != nil {
		fields = append(fields, serviceinstance.FieldStatus)
	}
	if m.vlan_id != nil {
		fields = append(fields, serviceinstance.FieldVlanID)
	}
	if m.bind_ip != nil {
		fields = append(fields, serviceinstance.FieldBindIP)
	}
	if m.ports != nil {
		fields = append(fields, serviceinstance.FieldPorts)
	}
	if m._config != nil {
		fields = append(fields, serviceinstance.FieldConfig)
	}
	if m.binary_path != nil {
		fields = append(fields, serviceinstance.FieldBinaryPath)
	}
	if m.binary_version != nil {
		fields = append(fields, serviceinstance.FieldBinaryVersion)
	}
	if m.binary_checksum != nil {
		fields = append(fields, serviceinstance.FieldBinaryChecksum)
	}
	if m.memory_limit != nil {
		fields = append(fields, serviceinstance.FieldMemoryLimit)
	}
	if m.cpu_weight != nil {
		fields = append(fields, serviceinstance.FieldCPUWeight)
	}
	if m.verification_enabled != nil {
		fields = append(fields, serviceinstance.FieldVerificationEnabled)
	}
	if m.archive_hash != nil {
		fields = append(fields, serviceinstance.FieldArchiveHash)
	}
	if m.binary_hash != nil {
		fields = append(fields, serviceinstance.FieldBinaryHash)
	}
	if m.gpg_verified != nil {
		fields = append(fields, serviceinstance.FieldGpgVerified)
	}
	if m.gpg_key_id != nil {
		fields = append(fields, serviceinstance.FieldGpgKeyID)
	}
	if m.checksums_url != nil {
		fields = append(fields, serviceinstance.FieldChecksumsURL)
	}
	if m.verified_at != nil {
		fields = append(fields, serviceinstance.FieldVerifiedAt)
	}
	if m.unavailable_reason != nil {
		fields = append(fields, serviceinstance.FieldUnavailableReason)
	}
	if m.auto_start != nil {
		fields = append(fields, serviceinstance.FieldAutoStart)
	}
	if m.health_status != nil {
		fields = append(fields, serviceinstance.FieldHealthStatus)
	}
	if m.health_process_alive != nil {
		fields = append(fields, serviceinstance.FieldHealthProcessAlive)
	}
	if m.health_connection_status != nil {
		fields = append(fields, serviceinstance.FieldHealthConnectionStatus)
	}
	if m.health_latency_ms != nil {
		fields = append(fields, serviceinstance.FieldHealthLatencyMs)
	}
	if m.health_last_healthy_at != nil {
		fields = append(fields, serviceinstance.FieldHealthLastHealthyAt)
	}
	if m.health_consecutive_fails != nil {
		fields = append(fields, serviceinstance.FieldHealthConsecutiveFails)
	}
	if m.health_check_interval_seconds != nil {
		fields = append(fields, serviceinstance.FieldHealthCheckIntervalSeconds)
	}
	if m.health_failure_threshold != nil {
		fields = append(fields, serviceinstance.FieldHealthFailureThreshold)
	}
	if m.quota_bytes != nil {
		fields = append(fields, serviceinstance.FieldQuotaBytes)
	}
	if m.quota_period != nil {
		fields = append(fields, serviceinstance.FieldQuotaPeriod)
	}
	if m.quota_action != nil {
		fields = append(fields, serviceinstance.FieldQuotaAction)
	}
	if m.quota_used_bytes != nil {
		fields = append(fields, serviceinstance.FieldQuotaUsedBytes)
	}
	if m.quota_reset_at != nil {
		fields = append(fields, serviceinstance.FieldQuotaResetAt)
	}
	if m.available_update_version != nil {
		fields = append(fields, serviceinstance.FieldAvailableUpdateVersion)
	}
	if m.available_update_severity != nil {
		fields = append(fields, serviceinstance.FieldAvailableUpdateSeverity)
	}
	if m.last_update_check != nil {
		fields = append(fields, serviceinstance.FieldLastUpdateCheck)
	}
	if m.last_update_etag != nil {
		fields = append(fields, serviceinstance.FieldLastUpdateEtag)
	}
	if m.update_changelog_url != nil {
		fields = append(fields, serviceinstance.FieldUpdateChangelogURL)
	}
	if m.update_check_schedule != nil {
		fields = append(fields, serviceinstance.FieldUpdateCheckSchedule)
	}
	if m.auto_apply_threshold != nil {
		fields = append(fields, serviceinstance.FieldAutoApplyThreshold)
	}
	if m.has_backup != nil {
		fields = append(fields, serviceinstance.FieldHasBackup)
	}
	if m.backup_version != nil {
		fields = append(fields, serviceinstance.FieldBackupVersion)
	}
	if m.last_updated_at != nil {
		fields = append(fields, serviceinstance.FieldLastUpdatedAt)
	}
	if m.created_at != nil {
		fields = append(fields, serviceinstance.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, serviceinstance.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ServiceInstanceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case serviceinstance.FieldFeatureID:
		return m.FeatureID()
	case serviceinstance.FieldInstanceName:
		return m.InstanceName()
	case serviceinstance.FieldRouterID:
		return m.RouterID()
	case serviceinstance.FieldStatus:
		return m.Status()
	case serviceinstance.FieldVlanID:
		return m.VlanID()
	case serviceinstance.FieldBindIP:
		return m.BindIP()
	case serviceinstance.FieldPorts:
		return m.Ports()
	case serviceinstance.FieldConfig:
		return m.Config()
	case serviceinstance.FieldBinaryPath:
		return m.BinaryPath()
	case serviceinstance.FieldBinaryVersion:
		return m.BinaryVersion()
	case serviceinstance.FieldBinaryChecksum:
		return m.BinaryChecksum()
	case serviceinstance.FieldMemoryLimit:
		return m.MemoryLimit()
	case serviceinstance.FieldCPUWeight:
		return m.CPUWeight()
	case serviceinstance.FieldVerificationEnabled:
		return m.VerificationEnabled()
	case serviceinstance.FieldArchiveHash:
		return m.ArchiveHash()
	case serviceinstance.FieldBinaryHash:
		return m.BinaryHash()
	case serviceinstance.FieldGpgVerified:
		return m.GpgVerified()
	case serviceinstance.FieldGpgKeyID:
		return m.GpgKeyID()
	case serviceinstance.FieldChecksumsURL:
		return m.ChecksumsURL()
	case serviceinstance.FieldVerifiedAt:
		return m.VerifiedAt()
	case serviceinstance.FieldUnavailableReason:
		return m.UnavailableReason()
	case serviceinstance.FieldAutoStart:
		return m.AutoStart()
	case serviceinstance.FieldHealthStatus:
		return m.HealthStatus()
	case serviceinstance.FieldHealthProcessAlive:
		return m.HealthProcessAlive()
	case serviceinstance.FieldHealthConnectionStatus:
		return m.HealthConnectionStatus()
	case serviceinstance.FieldHealthLatencyMs:
		return m.HealthLatencyMs()
	case serviceinstance.FieldHealthLastHealthyAt:
		return m.HealthLastHealthyAt()
	case serviceinstance.FieldHealthConsecutiveFails:
		return m.HealthConsecutiveFails()
	case serviceinstance.FieldHealthCheckIntervalSeconds:
		return m.HealthCheckIntervalSeconds()
	case serviceinstance.FieldHealthFailureThreshold:
		return m.HealthFailureThreshold()
	case serviceinstance.FieldQuotaBytes:
		return m.QuotaBytes()
	case serviceinstance.FieldQuotaPeriod:
		return m.QuotaPeriod()
	case serviceinstance.FieldQuotaAction:
		return m.QuotaAction()
	case serviceinstance.FieldQuotaUsedBytes:
		return m.QuotaUsedBytes()
	case serviceinstance.FieldQuotaResetAt:
		return m.QuotaResetAt()
	case serviceinstance.FieldAvailableUpdateVersion:
		return m.AvailableUpdateVersion()
	case serviceinstance.FieldAvailableUpdateSeverity:
		return m.AvailableUpdateSeverity()
	case serviceinstance.FieldLastUpdateCheck:
		return m.LastUpdateCheck()
	case serviceinstance.FieldLastUpdateEtag:
		return m.LastUpdateEtag()
	case serviceinstance.FieldUpdateChangelogURL:
		return m.UpdateChangelogURL()
	case serviceinstance.FieldUpdateCheckSchedule:
		return m.UpdateCheckSchedule()
	case serviceinstance.FieldAutoApplyThreshold:
		return m.AutoApplyThreshold()
	case serviceinstance.FieldHasBackup:
		return m.HasBackup()
	case serviceinstance.FieldBackupVersion:
		return m.BackupVersion()
	case serviceinstance.FieldLastUpdatedAt:
		return m.LastUpdatedAt()
	case serviceinstance.FieldCreatedAt:
		return m.CreatedAt()
	case serviceinstance.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ServiceInstanceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case serviceinstance.FieldFeatureID:
		return m.OldFeatureID(ctx)
	case serviceinstance.FieldInstanceName:
		return m.OldInstanceName(ctx)
	case serviceinstance.FieldRouterID:
		return m.OldRouterID(ctx)
	case serviceinstance.FieldStatus:
		return m.OldStatus(ctx)
	case serviceinstance.FieldVlanID:
		return m.OldVlanID(ctx)
	case serviceinstance.FieldBindIP:
		return m.OldBindIP(ctx)
	case serviceinstance.FieldPorts:
		return m.OldPorts(ctx)
	case serviceinstance.FieldConfig:
		return m.OldConfig(ctx)
	case serviceinstance.FieldBinaryPath:
		return m.OldBinaryPath(ctx)
	case serviceinstance.FieldBinaryVersion:
		return m.OldBinaryVersion(ctx)
	case serviceinstance.FieldBinaryChecksum:
		return m.OldBinaryChecksum(ctx)
	case serviceinstance.FieldMemoryLimit:
		return m.OldMemoryLimit(ctx)
	case serviceinstance.FieldCPUWeight:
		return m.OldCPUWeight(ctx)
	case serviceinstance.FieldVerificationEnabled:
		return m.OldVerificationEnabled(ctx)
	case serviceinstance.FieldArchiveHash:
		return m.OldArchiveHash(ctx)
	case serviceinstance.FieldBinaryHash:
		return m.OldBinaryHash(ctx)
	case serviceinstance.FieldGpgVerified:
		return m.OldGpgVerified(ctx)
	case serviceinstance.FieldGpgKeyID:
		return m.OldGpgKeyID(ctx)
	case serviceinstance.FieldChecksumsURL:
		return m.OldChecksumsURL(ctx)
	case serviceinstance.FieldVerifiedAt:
		return m.OldVerifiedAt(ctx)
	case serviceinstance.FieldUnavailableReason:
		return m.OldUnavailableReason(ctx)
	case serviceinstance.FieldAutoStart:
		return m.OldAutoStart(ctx)
	case serviceinstance.FieldHealthStatus:
		return m.OldHealthStatus(ctx)
	case serviceinstance.FieldHealthProcessAlive:
		return m.OldHealthProcessAlive(ctx)
	case serviceinstance.FieldHealthConnectionStatus:
		return m.OldHealthConnectionStatus(ctx)
	case serviceinstance.FieldHealthLatencyMs:
		return m.OldHealthLatencyMs(ctx)
	case serviceinstance.FieldHealthLastHealthyAt:
		return m.OldHealthLastHealthyAt(ctx)
	case serviceinstance.FieldHealthConsecutiveFails:
		return m.OldHealthConsecutiveFails(ctx)
	case serviceinstance.FieldHealthCheckIntervalSeconds:
		return m.OldHealthCheckIntervalSeconds(ctx)
	case serviceinstance.FieldHealthFailureThreshold:
		return m.OldHealthFailureThreshold(ctx)
	case serviceinstance.FieldQuotaBytes:
		return m.OldQuotaBytes(ctx)
	case serviceinstance.FieldQuotaPeriod:
		return m.OldQuotaPeriod(ctx)
	case serviceinstance.FieldQuotaAction:
		return m.OldQuotaAction(ctx)
	case serviceinstance.FieldQuotaUsedBytes:
		return m.OldQuotaUsedBytes(ctx)
	case serviceinstance.FieldQuotaResetAt:
		return m.OldQuotaResetAt(ctx)
	case serviceinstance.FieldAvailableUpdateVersion:
		return m.OldAvailableUpdateVersion(ctx)
	case serviceinstance.FieldAvailableUpdateSeverity:
		return m.OldAvailableUpdateSeverity(ctx)
	case serviceinstance.FieldLastUpdateCheck:
		return m.OldLastUpdateCheck(ctx)
	case serviceinstance.FieldLastUpdateEtag:
		return m.OldLastUpdateEtag(ctx)
	case serviceinstance.FieldUpdateChangelogURL:
		return m.OldUpdateChangelogURL(ctx)
	case serviceinstance.FieldUpdateCheckSchedule:
		return m.OldUpdateCheckSchedule(ctx)
	case serviceinstance.FieldAutoApplyThreshold:
		return m.OldAutoApplyThreshold(ctx)
	case serviceinstance.FieldHasBackup:
		return m.OldHasBackup(ctx)
	case serviceinstance.FieldBackupVersion:
		return m.OldBackupVersion(ctx)
	case serviceinstance.FieldLastUpdatedAt:
		return m.OldLastUpdatedAt(ctx)
	case serviceinstance.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case serviceinstance.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown ServiceInstance field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ServiceInstanceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case serviceinstance.FieldFeatureID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFeatureID(v)
		return nil
	case serviceinstance.FieldInstanceName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInstanceName(v)
		return nil
	case serviceinstance.FieldRouterID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRouterID(v)
		return nil
	case serviceinstance.FieldStatus:
		v, ok := value.(serviceinstance.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case serviceinstance.FieldVlanID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVlanID(v)
		return nil
	case serviceinstance.FieldBindIP:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBindIP(v)
		return nil
	case serviceinstance.FieldPorts:
		v, ok := value.([]int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPorts(v)
		return nil
	case serviceinstance.FieldConfig:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConfig(v)
		return nil
	case serviceinstance.FieldBinaryPath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBinaryPath(v)
		return nil
	case serviceinstance.FieldBinaryVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBinaryVersion(v)
		return nil
	case serviceinstance.FieldBinaryChecksum:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBinaryChecksum(v)
		return nil
	case serviceinstance.FieldMemoryLimit:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMemoryLimit(v)
		return nil
	case serviceinstance.FieldCPUWeight:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCPUWeight(v)
		return nil
	case serviceinstance.FieldVerificationEnabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVerificationEnabled(v)
		return nil
	case serviceinstance.FieldArchiveHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetArchiveHash(v)
		return nil
	case serviceinstance.FieldBinaryHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBinaryHash(v)
		return nil
	case serviceinstance.FieldGpgVerified:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGpgVerified(v)
		return nil
	case serviceinstance.FieldGpgKeyID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGpgKeyID(v)
		return nil
	case serviceinstance.FieldChecksumsURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChecksumsURL(v)
		return nil
	case serviceinstance.FieldVerifiedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVerifiedAt(v)
		return nil
	case serviceinstance.FieldUnavailableReason:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUnavailableReason(v)
		return nil
	case serviceinstance.FieldAutoStart:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAutoStart(v)
		return nil
	case serviceinstance.FieldHealthStatus:
		v, ok := value.(serviceinstance.HealthStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHealthStatus(v)
		return nil
	case serviceinstance.FieldHealthProcessAlive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHealthProcessAlive(v)
		return nil
	case serviceinstance.FieldHealthConnectionStatus:
		v, ok := value.(serviceinstance.HealthConnectionStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHealthConnectionStatus(v)
		return nil
	case serviceinstance.FieldHealthLatencyMs:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHealthLatencyMs(v)
		return nil
	case serviceinstance.FieldHealthLastHealthyAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHealthLastHealthyAt(v)
		return nil
	case serviceinstance.FieldHealthConsecutiveFails:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHealthConsecutiveFails(v)
		return nil
	case serviceinstance.FieldHealthCheckIntervalSeconds:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHealthCheckIntervalSeconds(v)
		return nil
	case serviceinstance.FieldHealthFailureThreshold:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHealthFailureThreshold(v)
		return nil
	case serviceinstance.FieldQuotaBytes:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQuotaBytes(v)
		return nil
	case serviceinstance.FieldQuotaPeriod:
		v, ok := value.(serviceinstance.QuotaPeriod)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQuotaPeriod(v)
		return nil
	case serviceinstance.FieldQuotaAction:
		v, ok := value.(serviceinstance.QuotaAction)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQuotaAction(v)
		return nil
	case serviceinstance.FieldQuotaUsedBytes:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQuotaUsedBytes(v)
		return nil
	case serviceinstance.FieldQuotaResetAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQuotaResetAt(v)
		return nil
	case serviceinstance.FieldAvailableUpdateVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAvailableUpdateVersion(v)
		return nil
	case serviceinstance.FieldAvailableUpdateSeverity:
		v, ok := value.(serviceinstance.AvailableUpdateSeverity)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAvailableUpdateSeverity(v)
		return nil
	case serviceinstance.FieldLastUpdateCheck:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastUpdateCheck(v)
		return nil
	case serviceinstance.FieldLastUpdateEtag:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastUpdateEtag(v)
		return nil
	case serviceinstance.FieldUpdateChangelogURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateChangelogURL(v)
		return nil
	case serviceinstance.FieldUpdateCheckSchedule:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateCheckSchedule(v)
		return nil
	case serviceinstance.FieldAutoApplyThreshold:
		v, ok := value.(serviceinstance.AutoApplyThreshold)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAutoApplyThreshold(v)
		return nil
	case serviceinstance.FieldHasBackup:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHasBackup(v)
		return nil
	case serviceinstance.FieldBackupVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBackupVersion(v)
		return nil
	case serviceinstance.FieldLastUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastUpdatedAt(v)
		return nil
	case serviceinstance.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case serviceinstance.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown ServiceInstance field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ServiceInstanceMutation) AddedFields() []string {
	var fields []string
	if m.addvlan_id != nil {
		fields = append(fields, serviceinstance.FieldVlanID)
	}
	if m.addmemory_limit != nil {
		fields = append(fields, serviceinstance.FieldMemoryLimit)
	}
	if m.addcpu_weight != nil {
		fields = append(fields, serviceinstance.FieldCPUWeight)
	}
	if m.addhealth_latency_ms != nil {
		fields = append(fields, serviceinstance.FieldHealthLatencyMs)
	}
	if m.addhealth_consecutive_fails != nil {
		fields = append(fields, serviceinstance.FieldHealthConsecutiveFails)
	}
	if m.addhealth_check_interval_seconds != nil {
		fields = append(fields, serviceinstance.FieldHealthCheckIntervalSeconds)
	}
	if m.addhealth_failure_threshold != nil {
		fields = append(fields, serviceinstance.FieldHealthFailureThreshold)
	}
	if m.addquota_bytes != nil {
		fields = append(fields, serviceinstance.FieldQuotaBytes)
	}
	if m.addquota_used_bytes != nil {
		fields = append(fields, serviceinstance.FieldQuotaUsedBytes)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ServiceInstanceMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case serviceinstance.FieldVlanID:
		return m.AddedVlanID()
	case serviceinstance.FieldMemoryLimit:
		return m.AddedMemoryLimit()
	case serviceinstance.FieldCPUWeight:
		return m.AddedCPUWeight()
	case serviceinstance.FieldHealthLatencyMs:
		return m.AddedHealthLatencyMs()
	case serviceinstance.FieldHealthConsecutiveFails:
		return m.AddedHealthConsecutiveFails()
	case serviceinstance.FieldHealthCheckIntervalSeconds:
		return m.AddedHealthCheckIntervalSeconds()
	case serviceinstance.FieldHealthFailureThreshold:
		return m.AddedHealthFailureThreshold()
	case serviceinstance.FieldQuotaBytes:
		return m.AddedQuotaBytes()
	case serviceinstance.FieldQuotaUsedBytes:
		return m.AddedQuotaUsedBytes()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ServiceInstanceMutation) AddField(name string, value ent.Value) error {
	switch name {
	case serviceinstance.FieldVlanID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVlanID(v)
		return nil
	case serviceinstance.FieldMemoryLimit:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMemoryLimit(v)
		return nil
	case serviceinstance.FieldCPUWeight:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCPUWeight(v)
		return nil
	case serviceinstance.FieldHealthLatencyMs:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddHealthLatencyMs(v)
		return nil
	case serviceinstance.FieldHealthConsecutiveFails:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddHealthConsecutiveFails(v)
		return nil
	case serviceinstance.FieldHealthCheckIntervalSeconds:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddHealthCheckIntervalSeconds(v)
		return nil
	case serviceinstance.FieldHealthFailureThreshold:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddHealthFailureThreshold(v)
		return nil
	case serviceinstance.FieldQuotaBytes:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddQuotaBytes(v)
		return nil
	case serviceinstance.FieldQuotaUsedBytes:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddQuotaUsedBytes(v)
		return nil
	}
	return fmt.Errorf("unknown ServiceInstance numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ServiceInstanceMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(serviceinstance.FieldVlanID) {
		fields = append(fields, serviceinstance.FieldVlanID)
	}
	if m.FieldCleared(serviceinstance.FieldBindIP) {
		fields = append(fields, serviceinstance.FieldBindIP)
	}
	if m.FieldCleared(serviceinstance.FieldPorts) {
		fields = append(fields, serviceinstance.FieldPorts)
	}
	if m.FieldCleared(serviceinstance.FieldConfig) {
		fields = append(fields, serviceinstance.FieldConfig)
	}
	if m.FieldCleared(serviceinstance.FieldBinaryPath) {
		fields = append(fields, serviceinstance.FieldBinaryPath)
	}
	if m.FieldCleared(serviceinstance.FieldBinaryVersion) {
		fields = append(fields, serviceinstance.FieldBinaryVersion)
	}
	if m.FieldCleared(serviceinstance.FieldBinaryChecksum) {
		fields = append(fields, serviceinstance.FieldBinaryChecksum)
	}
	if m.FieldCleared(serviceinstance.FieldMemoryLimit) {
		fields = append(fields, serviceinstance.FieldMemoryLimit)
	}
	if m.FieldCleared(serviceinstance.FieldCPUWeight) {
		fields = append(fields, serviceinstance.FieldCPUWeight)
	}
	if m.FieldCleared(serviceinstance.FieldArchiveHash) {
		fields = append(fields, serviceinstance.FieldArchiveHash)
	}
	if m.FieldCleared(serviceinstance.FieldBinaryHash) {
		fields = append(fields, serviceinstance.FieldBinaryHash)
	}
	if m.FieldCleared(serviceinstance.FieldGpgKeyID) {
		fields = append(fields, serviceinstance.FieldGpgKeyID)
	}
	if m.FieldCleared(serviceinstance.FieldChecksumsURL) {
		fields = append(fields, serviceinstance.FieldChecksumsURL)
	}
	if m.FieldCleared(serviceinstance.FieldVerifiedAt) {
		fields = append(fields, serviceinstance.FieldVerifiedAt)
	}
	if m.FieldCleared(serviceinstance.FieldUnavailableReason) {
		fields = append(fields, serviceinstance.FieldUnavailableReason)
	}
	if m.FieldCleared(serviceinstance.FieldHealthLatencyMs) {
		fields = append(fields, serviceinstance.FieldHealthLatencyMs)
	}
	if m.FieldCleared(serviceinstance.FieldHealthLastHealthyAt) {
		fields = append(fields, serviceinstance.FieldHealthLastHealthyAt)
	}
	if m.FieldCleared(serviceinstance.FieldQuotaBytes) {
		fields = append(fields, serviceinstance.FieldQuotaBytes)
	}
	if m.FieldCleared(serviceinstance.FieldQuotaPeriod) {
		fields = append(fields, serviceinstance.FieldQuotaPeriod)
	}
	if m.FieldCleared(serviceinstance.FieldQuotaAction) {
		fields = append(fields, serviceinstance.FieldQuotaAction)
	}
	if m.FieldCleared(serviceinstance.FieldQuotaResetAt) {
		fields = append(fields, serviceinstance.FieldQuotaResetAt)
	}
	if m.FieldCleared(serviceinstance.FieldAvailableUpdateVersion) {
		fields = append(fields, serviceinstance.FieldAvailableUpdateVersion)
	}
	if m.FieldCleared(serviceinstance.FieldAvailableUpdateSeverity) {
		fields = append(fields, serviceinstance.FieldAvailableUpdateSeverity)
	}
	if m.FieldCleared(serviceinstance.FieldLastUpdateCheck) {
		fields = append(fields, serviceinstance.FieldLastUpdateCheck)
	}
	if m.FieldCleared(serviceinstance.FieldLastUpdateEtag) {
		fields = append(fields, serviceinstance.FieldLastUpdateEtag)
	}
	if m.FieldCleared(serviceinstance.FieldUpdateChangelogURL) {
		fields = append(fields, serviceinstance.FieldUpdateChangelogURL)
	}
	if m.FieldCleared(serviceinstance.FieldUpdateCheckSchedule) {
		fields = append(fields, serviceinstance.FieldUpdateCheckSchedule)
	}
	if m.FieldCleared(serviceinstance.FieldAutoApplyThreshold) {
		fields = append(fields, serviceinstance.FieldAutoApplyThreshold)
	}
	if m.FieldCleared(serviceinstance.FieldBackupVersion) {
		fields = append(fields, serviceinstance.FieldBackupVersion)
	}
	if m.FieldCleared(serviceinstance.FieldLastUpdatedAt) {
		fields = append(fields, serviceinstance.FieldLastUpdatedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ServiceInstanceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ServiceInstanceMutation) ClearField(name string) error {
	switch name {
	case serviceinstance.FieldVlanID:
		m.ClearVlanID()
		return nil
	case serviceinstance.FieldBindIP:
		m.ClearBindIP()
		return nil
	case serviceinstance.FieldPorts:
		m.ClearPorts()
		return nil
	case serviceinstance.FieldConfig:
		m.ClearConfig()
		return nil
	case serviceinstance.FieldBinaryPath:
		m.ClearBinaryPath()
		return nil
	case serviceinstance.FieldBinaryVersion:
		m.ClearBinaryVersion()
		return nil
	case serviceinstance.FieldBinaryChecksum:
		m.ClearBinaryChecksum()
		return nil
	case serviceinstance.FieldMemoryLimit:
		m.ClearMemoryLimit()
		return nil
	case serviceinstance.FieldCPUWeight:
		m.ClearCPUWeight()
		return nil
	case serviceinstance.FieldArchiveHash:
		m.ClearArchiveHash()
		return nil
	case serviceinstance.FieldBinaryHash:
		m.ClearBinaryHash()
		return nil
	case serviceinstance.FieldGpgKeyID:
		m.ClearGpgKeyID()
		return nil
	case serviceinstance.FieldChecksumsURL:
		m.ClearChecksumsURL()
		return nil
	case serviceinstance.FieldVerifiedAt:
		m.ClearVerifiedAt()
		return nil
	case serviceinstance.FieldUnavailableReason:
		m.ClearUnavailableReason()
		return nil
	case serviceinstance.FieldHealthLatencyMs:
		m.ClearHealthLatencyMs()
		return nil
	case serviceinstance.FieldHealthLastHealthyAt:
		m.ClearHealthLastHealthyAt()
		return nil
	case serviceinstance.FieldQuotaBytes:
		m.ClearQuotaBytes()
		return nil
	case serviceinstance.FieldQuotaPeriod:
		m.ClearQuotaPeriod()
		return nil
	case serviceinstance.FieldQuotaAction:
		m.ClearQuotaAction()
		return nil
	case serviceinstance.FieldQuotaResetAt:
		m.ClearQuotaResetAt()
		return nil
	case serviceinstance.FieldAvailableUpdateVersion:
		m.ClearAvailableUpdateVersion()
		return nil
	case serviceinstance.FieldAvailableUpdateSeverity:
		m.ClearAvailableUpdateSeverity()
		return nil
	case serviceinstance.FieldLastUpdateCheck:
		m.ClearLastUpdateCheck()
		return nil
	case serviceinstance.FieldLastUpdateEtag:
		m.ClearLastUpdateEtag()
		return nil
	case serviceinstance.FieldUpdateChangelogURL:
		m.ClearUpdateChangelogURL()
		return nil
	case serviceinstance.FieldUpdateCheckSchedule:
		m.ClearUpdateCheckSchedule()
		return nil
	case serviceinstance.FieldAutoApplyThreshold:
		m.ClearAutoApplyThreshold()
		return nil
	case serviceinstance.FieldBackupVersion:
		m.ClearBackupVersion()
		return nil
	case serviceinstance.FieldLastUpdatedAt:
		m.ClearLastUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown ServiceInstance nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ServiceInstanceMutation) ResetField(name string) error {
	switch name {
	case serviceinstance.FieldFeatureID:
		m.ResetFeatureID()
		return nil
	case serviceinstance.FieldInstanceName:
		m.ResetInstanceName()
		return nil
	case serviceinstance.FieldRouterID:
		m.ResetRouterID()
		return nil
	case serviceinstance.FieldStatus:
		m.ResetStatus()
		return nil
	case serviceinstance.FieldVlanID:
		m.ResetVlanID()
		return nil
	case serviceinstance.FieldBindIP:
		m.ResetBindIP()
		return nil
	case serviceinstance.FieldPorts:
		m.ResetPorts()
		return nil
	case serviceinstance.FieldConfig:
		m.ResetConfig()
		return nil
	case serviceinstance.FieldBinaryPath:
		m.ResetBinaryPath()
		return nil
	case serviceinstance.FieldBinaryVersion:
		m.ResetBinaryVersion()
		return nil
	case serviceinstance.FieldBinaryChecksum:
		m.ResetBinaryChecksum()
		return nil
	case serviceinstance.FieldMemoryLimit:
		m.ResetMemoryLimit()
		return nil
	case serviceinstance.FieldCPUWeight:
		m.ResetCPUWeight()
		return nil
	case serviceinstance.FieldVerificationEnabled:
		m.ResetVerificationEnabled()
		return nil
	case serviceinstance.FieldArchiveHash:
		m.ResetArchiveHash()
		return nil
	case serviceinstance.FieldBinaryHash:
		m.ResetBinaryHash()
		return nil
	case serviceinstance.FieldGpgVerified:
		m.ResetGpgVerified()
		return nil
	case serviceinstance.FieldGpgKeyID:
		m.ResetGpgKeyID()
		return nil
	case serviceinstance.FieldChecksumsURL:
		m.ResetChecksumsURL()
		return nil
	case serviceinstance.FieldVerifiedAt:
		m.ResetVerifiedAt()
		return nil
	case serviceinstance.FieldUnavailableReason:
		m.ResetUnavailableReason()
		return nil
	case serviceinstance.FieldAutoStart:
		m.ResetAutoStart()
		return nil
	case serviceinstance.FieldHealthStatus:
		m.ResetHealthStatus()
		return nil
	case serviceinstance.FieldHealthProcessAlive:
		m.ResetHealthProcessAlive()
		return nil
	case serviceinstance.FieldHealthConnectionStatus:
		m.ResetHealthConnectionStatus()
		return nil
	case serviceinstance.FieldHealthLatencyMs:
		m.ResetHealthLatencyMs()
		return nil
	case serviceinstance.FieldHealthLastHealthyAt:
		m.ResetHealthLastHealthyAt()
		return nil
	case serviceinstance.FieldHealthConsecutiveFails:
		m.ResetHealthConsecutiveFails()
		return nil
	case serviceinstance.FieldHealthCheckIntervalSeconds:
		m.ResetHealthCheckIntervalSeconds()
		return nil
	case serviceinstance.FieldHealthFailureThreshold:
		m.ResetHealthFailureThreshold()
		return nil
	case serviceinstance.FieldQuotaBytes:
		m.ResetQuotaBytes()
		return nil
	case serviceinstance.FieldQuotaPeriod:
		m.ResetQuotaPeriod()
		return nil
	case serviceinstance.FieldQuotaAction:
		m.ResetQuotaAction()
		return nil
	case serviceinstance.FieldQuotaUsedBytes:
		m.ResetQuotaUsedBytes()
		return nil
	case serviceinstance.FieldQuotaResetAt:
		m.ResetQuotaResetAt()
		return nil
	case serviceinstance.FieldAvailableUpdateVersion:
		m.ResetAvailableUpdateVersion()
		return nil
	case serviceinstance.FieldAvailableUpdateSeverity:
		m.ResetAvailableUpdateSeverity()
		return nil
	case serviceinstance.FieldLastUpdateCheck:
		m.ResetLastUpdateCheck()
		return nil
	case serviceinstance.FieldLastUpdateEtag:
		m.ResetLastUpdateEtag()
		return nil
	case serviceinstance.FieldUpdateChangelogURL:
		m.ResetUpdateChangelogURL()
		return nil
	case serviceinstance.FieldUpdateCheckSchedule:
		m.ResetUpdateCheckSchedule()
		return nil
	case serviceinstance.FieldAutoApplyThreshold:
		m.ResetAutoApplyThreshold()
		return nil
	case serviceinstance.FieldHasBackup:
		m.ResetHasBackup()
		return nil
	case serviceinstance.FieldBackupVersion:
		m.ResetBackupVersion()
		return nil
	case serviceinstance.FieldLastUpdatedAt:
		m.ResetLastUpdatedAt()
		return nil
	case serviceinstance.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case serviceinstance.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown ServiceInstance field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ServiceInstanceMutation) AddedEdges() []string {
	edges := make([]string, 0, 9)
	if m.router != nil {
		edges = append(edges, serviceinstance.EdgeRouter)
	}
	if m.port_allocations != nil {
		edges = append(edges, serviceinstance.EdgePortAllocations)
	}
	if m.vlan_allocations != nil {
		edges = append(edges, serviceinstance.EdgeVlanAllocations)
	}
	if m.virtual_interface != nil {
		edges = append(edges, serviceinstance.EdgeVirtualInterface)
	}
	if m.dependencies != nil {
		edges = append(edges, serviceinstance.EdgeDependencies)
	}
	if m.dependents != nil {
		edges = append(edges, serviceinstance.EdgeDependents)
	}
	if m.device_routings != nil {
		edges = append(edges, serviceinstance.EdgeDeviceRoutings)
	}
	if m.diagnostic_results != nil {
		edges = append(edges, serviceinstance.EdgeDiagnosticResults)
	}
	if m.traffic_hourly != nil {
		edges = append(edges, serviceinstance.EdgeTrafficHourly)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ServiceInstanceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case serviceinstance.EdgeRouter:
		if id := m.router; id != nil {
			return []ent.Value{*id}
		}
	case serviceinstance.EdgePortAllocations:
		ids := make([]ent.Value, 0, len(m.port_allocations))
		for id := range m.port_allocations {
			ids = append(ids, id)
		}
		return ids
	case serviceinstance.EdgeVlanAllocations:
		ids := make([]ent.Value, 0, len(m.vlan_allocations))
		for id := range m.vlan_allocations {
			ids = append(ids, id)
		}
		return ids
	case serviceinstance.EdgeVirtualInterface:
		if id := m.virtual_interface; id != nil {
			return []ent.Value{*id}
		}
	case serviceinstance.EdgeDependencies:
		ids := make([]ent.Value, 0, len(m.dependencies))
		for id := range m.dependencies {
			ids = append(ids, id)
		}
		return ids
	case serviceinstance.EdgeDependents:
		ids := make([]ent.Value, 0, len(m.dependents))
		for id := range m.dependents {
			ids = append(ids, id)
		}
		return ids
	case serviceinstance.EdgeDeviceRoutings:
		ids := make([]ent.Value, 0, len(m.device_routings))
		for id := range m.device_routings {
			ids = append(ids, id)
		}
		return ids
	case serviceinstance.EdgeDiagnosticResults:
		ids := make([]ent.Value, 0, len(m.diagnostic_results))
		for id := range m.diagnostic_results {
			ids = append(ids, id)
		}
		return ids
	case serviceinstance.EdgeTrafficHourly:
		ids := make([]ent.Value, 0, len(m.traffic_hourly))
		for id := range m.traffic_hourly {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ServiceInstanceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 9)
	if m.removedport_allocations != nil {
		edges = append(edges, serviceinstance.EdgePortAllocations)
	}
	if m.removedvlan_allocations != nil {
		edges = append(edges, serviceinstance.EdgeVlanAllocations)
	}
	if m.removeddependencies != nil {
		edges = append(edges, serviceinstance.EdgeDependencies)
	}
	if m.removeddependents != nil {
		edges = append(edges, serviceinstance.EdgeDependents)
	}
	if m.removeddevice_routings != nil {
		edges = append(edges, serviceinstance.EdgeDeviceRoutings)
	}
	if m.removeddiagnostic_results != nil {
		edges = append(edges, serviceinstance.EdgeDiagnosticResults)
	}
	if m.removedtraffic_hourly != nil {
		edges = append(edges, serviceinstance.EdgeTrafficHourly)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ServiceInstanceMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case serviceinstance.EdgePortAllocations:
		ids := make([]ent.Value, 0, len(m.removedport_allocations))
		for id := range m.removedport_allocations {
			ids = append(ids, id)
		}
		return ids
	case serviceinstance.EdgeVlanAllocations:
		ids := make([]ent.Value, 0, len(m.removedvlan_allocations))
		for id := range m.removedvlan_allocations {
			ids = append(ids, id)
		}
		return ids
	case serviceinstance.EdgeDependencies:
		ids := make([]ent.Value, 0, len(m.removeddependencies))
		for id := range m.removeddependencies {
			ids = append(ids, id)
		}
		return ids
	case serviceinstance.EdgeDependents:
		ids := make([]ent.Value, 0, len(m.removeddependents))
		for id := range m.removeddependents {
			ids = append(ids, id)
		}
		return ids
	case serviceinstance.EdgeDeviceRoutings:
		ids := make([]ent.Value, 0, len(m.removeddevice_routings))
		for id := range m.removeddevice_routings {
			ids = append(ids, id)
		}
		return ids
	case serviceinstance.EdgeDiagnosticResults:
		ids := make([]ent.Value, 0, len(m.removeddiagnostic_results))
		for id := range m.removeddiagnostic_results {
			ids = append(ids, id)
		}
		return ids
	case serviceinstance.EdgeTrafficHourly:
		ids := make([]ent.Value, 0, len(m.removedtraffic_hourly))
		for id := range m.removedtraffic_hourly {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ServiceInstanceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 9)
	if m.clearedrouter {
		edges = append(edges, serviceinstance.EdgeRouter)
	}
	if m.clearedport_allocations {
		edges = append(edges, serviceinstance.EdgePortAllocations)
	}
	if m.clearedvlan_allocations {
		edges = append(edges, serviceinstance.EdgeVlanAllocations)
	}
	if m.clearedvirtual_interface {
		edges = append(edges, serviceinstance.EdgeVirtualInterface)
	}
	if m.cleareddependencies {
		edges = append(edges, serviceinstance.EdgeDependencies)
	}
	if m.cleareddependents {
		edges = append(edges, serviceinstance.EdgeDependents)
	}
	if m.cleareddevice_routings {
		edges = append(edges, serviceinstance.EdgeDeviceRoutings)
	}
	if m.cleareddiagnostic_results {
		edges = append(edges, serviceinstance.EdgeDiagnosticResults)
	}
	if m.clearedtraffic_hourly {
		edges = append(edges, serviceinstance.EdgeTrafficHourly)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ServiceInstanceMutation) EdgeCleared(name string) bool {
	switch name {
	case serviceinstance.EdgeRouter:
		return m.clearedrouter
	case serviceinstance.EdgePortAllocations:
		return m.clearedport_allocations
	case serviceinstance.EdgeVlanAllocations:
		return m.clearedvlan_allocations
	case serviceinstance.EdgeVirtualInterface:
		return m.clearedvirtual_interface
	case serviceinstance.EdgeDependencies:
		return m.cleareddependencies
	case serviceinstance.EdgeDependents:
		return m.cleareddependents
	case serviceinstance.EdgeDeviceRoutings:
		return m.cleareddevice_routings
	case serviceinstance.EdgeDiagnosticResults:
		return m.cleareddiagnostic_results
	case serviceinstance.EdgeTrafficHourly:
		return m.clearedtraffic_hourly
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ServiceInstanceMutation) ClearEdge(name string) error {
	switch name {
	case serviceinstance.EdgeRouter:
		m.ClearRouter()
		return nil
	case serviceinstance.EdgeVirtualInterface:
		m.ClearVirtualInterface()
		return nil
	}
	return fmt.Errorf("unknown ServiceInstance unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ServiceInstanceMutation) ResetEdge(name string) error {
	switch name {
	case serviceinstance.EdgeRouter:
		m.ResetRouter()
		return nil
	case serviceinstance.EdgePortAllocations:
		m.ResetPortAllocations()
		return nil
	case serviceinstance.EdgeVlanAllocations:
		m.ResetVlanAllocations()
		return nil
	case serviceinstance.EdgeVirtualInterface:
		m.ResetVirtualInterface()
		return nil
	case serviceinstance.EdgeDependencies:
		m.ResetDependencies()
		return nil
	case serviceinstance.EdgeDependents:
		m.ResetDependents()
		return nil
	case serviceinstance.EdgeDeviceRoutings:
		m.ResetDeviceRoutings()
		return nil
	case serviceinstance.EdgeDiagnosticResults:
		m.ResetDiagnosticResults()
		return nil
	case serviceinstance.EdgeTrafficHourly:
		m.ResetTrafficHourly()
		return nil
	}
	return fmt.Errorf("unknown ServiceInstance edge %s", name)
}

// ServiceTemplateMutation represents an operation that mutates the ServiceTemplate nodes in the graph.
type ServiceTemplateMutation struct {
	config
	op                      Op
	typ                     string
	id                      *string
	name                    *string
	description             *string
	category                *servicetemplate.Category
	scope                   *servicetemplate.Scope
	version                 *string
	is_built_in             *bool
	author                  *string
	services                *[]map[string]interface{}
	appendservices          []map[string]interface{}
	config_variables        *[]map[string]interface{}
	appendconfig_variables  []map[string]interface{}
	suggested_routing       *[]map[string]interface{}
	appendsuggested_routing []map[string]interface{}
	estimated_resources     *map[string]interface{}
	tags                    *[]string
	appendtags              []string
	prerequisites           *[]string
	appendprerequisites     []string
	documentation           *string
	examples                *[]string
	appendexamples          []string
	created_at              *time.Time
	updated_at              *time.Time
	clearedFields           map[string]struct{}
	router                  *string
	clearedrouter           bool
	done                    bool
	oldValue                func(context.Context) (*ServiceTemplate, error)
	predicates              []predicate.ServiceTemplate
}

var _ ent.Mutation = (*ServiceTemplateMutation)(nil)

// servicetemplateOption allows management of the mutation configuration using functional options.
type servicetemplateOption func(*ServiceTemplateMutation)

// newServiceTemplateMutation creates new mutation for the ServiceTemplate entity.
func newServiceTemplateMutation(c config, op Op, opts ...servicetemplateOption) *ServiceTemplateMutation {
	m := &ServiceTemplateMutation{
		config:        c,
		op:            op,
		typ:           TypeServiceTemplate,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withServiceTemplateID sets the ID field of the mutation.
func withServiceTemplateID(id string) servicetemplateOption {
	return func(m *ServiceTemplateMutation) {
		var (
			err   error
			once  sync.Once
			value *ServiceTemplate
		)
		m.oldValue = func(ctx context.Context) (*ServiceTemplate, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ServiceTemplate.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withServiceTemplate sets the old ServiceTemplate of the mutation.
func withServiceTemplate(node *ServiceTemplate) servicetemplateOption {
	return func(m *ServiceTemplateMutation) {
		m.oldValue = func(context.Context) (*ServiceTemplate, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ServiceTemplateMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ServiceTemplateMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ServiceTemplate entities.
func (m *ServiceTemplateMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ServiceTemplateMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ServiceTemplateMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ServiceTemplate.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *ServiceTemplateMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ServiceTemplateMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the ServiceTemplate entity.
// If the ServiceTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceTemplateMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ServiceTemplateMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *ServiceTemplateMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ServiceTemplateMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the ServiceTemplate entity.
// If the ServiceTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceTemplateMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *ServiceTemplateMutation) ResetDescription() {
	m.description = nil
}

// SetCategory sets the "category" field.
func (m *ServiceTemplateMutation) SetCategory(s servicetemplate.Category) {
	m.category = &s
}

// Category returns the value of the "category" field in the mutation.
func (m *ServiceTemplateMutation) Category() (r servicetemplate.Category, exists bool) {
	v := m.category
	if v == nil {
		return
	}
	return *v, true
}

// OldCategory returns the old "category" field's value of the ServiceTemplate entity.
// If the ServiceTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceTemplateMutation) OldCategory(ctx context.Context) (v servicetemplate.Category, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategory: %w", err)
	}
	return oldValue.Category, nil
}

// ResetCategory resets all changes to the "category" field.
func (m *ServiceTemplateMutation) ResetCategory() {
	m.category = nil
}

// SetScope sets the "scope" field.
func (m *ServiceTemplateMutation) SetScope(s servicetemplate.Scope) {
	m.scope = &s
}

// Scope returns the value of the "scope" field in the mutation.
func (m *ServiceTemplateMutation) Scope() (r servicetemplate.Scope, exists bool) {
	v := m.scope
	if v == nil {
		return
	}
	return *v, true
}

// OldScope returns the old "scope" field's value of the ServiceTemplate entity.
// If the ServiceTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceTemplateMutation) OldScope(ctx context.Context) (v servicetemplate.Scope, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScope is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScope requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScope: %w", err)
	}
	return oldValue.Scope, nil
}

// ResetScope resets all changes to the "scope" field.
func (m *ServiceTemplateMutation) ResetScope() {
	m.scope = nil
}

// SetVersion sets the "version" field.
func (m *ServiceTemplateMutation) SetVersion(s string) {
	m.version = &s
}

// Version returns the value of the "version" field in the mutation.
func (m *ServiceTemplateMutation) Version() (r string, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the ServiceTemplate entity.
// If the ServiceTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceTemplateMutation) OldVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// ResetVersion resets all changes to the "version" field.
func (m *ServiceTemplateMutation) ResetVersion() {
	m.version = nil
}

// SetIsBuiltIn sets the "is_built_in" field.
func (m *ServiceTemplateMutation) SetIsBuiltIn(b bool) {
	m.is_built_in = &b
}

// IsBuiltIn returns the value of the "is_built_in" field in the mutation.
func (m *ServiceTemplateMutation) IsBuiltIn() (r bool, exists bool) {
	v := m.is_built_in
	if v == nil {
		return
	}
	return *v, true
}

// OldIsBuiltIn returns the old "is_built_in" field's value of the ServiceTemplate entity.
// If the ServiceTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceTemplateMutation) OldIsBuiltIn(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsBuiltIn is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsBuiltIn requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsBuiltIn: %w", err)
	}
	return oldValue.IsBuiltIn, nil
}

// ResetIsBuiltIn resets all changes to the "is_built_in" field.
func (m *ServiceTemplateMutation) ResetIsBuiltIn() {
	m.is_built_in = nil
}

// SetAuthor sets the "author" field.
func (m *ServiceTemplateMutation) SetAuthor(s string) {
	m.author = &s
}

// Author returns the value of the "author" field in the mutation.
func (m *ServiceTemplateMutation) Author() (r string, exists bool) {
	v := m.author
	if v == nil {
		return
	}
	return *v, true
}

// OldAuthor returns the old "author" field's value of the ServiceTemplate entity.
// If the ServiceTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceTemplateMutation) OldAuthor(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAuthor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAuthor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAuthor: %w", err)
	}
	return oldValue.Author, nil
}

// ClearAuthor clears the value of the "author" field.
func (m *ServiceTemplateMutation) ClearAuthor() {
	m.author = nil
	m.clearedFields[servicetemplate.FieldAuthor] = struct{}{}
}

// AuthorCleared returns if the "author" field was cleared in this mutation.
func (m *ServiceTemplateMutation) AuthorCleared() bool {
	_, ok := m.clearedFields[servicetemplate.FieldAuthor]
	return ok
}

// ResetAuthor resets all changes to the "author" field.
func (m *ServiceTemplateMutation) ResetAuthor() {
	m.author = nil
	delete(m.clearedFields, servicetemplate.FieldAuthor)
}

// SetRouterID sets the "router_id" field.
func (m *ServiceTemplateMutation) SetRouterID(s string) {
	m.router = &s
}

// RouterID returns the value of the "router_id" field in the mutation.
func (m *ServiceTemplateMutation) RouterID() (r string, exists bool) {
	v := m.router
	if v == nil {
		return
	}
	return *v, true
}

// OldRouterID returns the old "router_id" field's value of the ServiceTemplate entity.
// If the ServiceTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceTemplateMutation) OldRouterID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRouterID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRouterID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRouterID: %w", err)
	}
	return oldValue.RouterID, nil
}

// ClearRouterID clears the value of the "router_id" field.
func (m *ServiceTemplateMutation) ClearRouterID() {
	m.router = nil
	m.clearedFields[servicetemplate.FieldRouterID] = struct{}{}
}

// RouterIDCleared returns if the "router_id" field was cleared in this mutation.
func (m *ServiceTemplateMutation) RouterIDCleared() bool {
	_, ok := m.clearedFields[servicetemplate.FieldRouterID]
	return ok
}

// ResetRouterID resets all changes to the "router_id" field.
func (m *ServiceTemplateMutation) ResetRouterID() {
	m.router = nil
	delete(m.clearedFields, servicetemplate.FieldRouterID)
}

// SetServices sets the "services" field.
func (m *ServiceTemplateMutation) SetServices(value []map[string]interface{}) {
	m.services = &value
	m.appendservices = nil
}

// Services returns the value of the "services" field in the mutation.
func (m *ServiceTemplateMutation) Services() (r []map[string]interface{}, exists bool) {
	v := m.services
	if v == nil {
		return
	}
	return *v, true
}

// OldServices returns the old "services" field's value of the ServiceTemplate entity.
// If the ServiceTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceTemplateMutation) OldServices(ctx context.Context) (v []map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldServices is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldServices requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldServices: %w", err)
	}
	return oldValue.Services, nil
}

// AppendServices adds value to the "services" field.
func (m *ServiceTemplateMutation) AppendServices(value []map[string]interface{}) {
	m.appendservices = append(m.appendservices, value...)
}

// AppendedServices returns the list of values that were appended to the "services" field in this mutation.
func (m *ServiceTemplateMutation) AppendedServices() ([]map[string]interface{}, bool) {
	if len(m.appendservices) == 0 {
		return nil, false
	}
	return m.appendservices, true
}

// ResetServices resets all changes to the "services" field.
func (m *ServiceTemplateMutation) ResetServices() {
	m.services = nil
	m.appendservices = nil
}

// SetConfigVariables sets the "config_variables" field.
func (m *ServiceTemplateMutation) SetConfigVariables(value []map[string]interface{}) {
	m.config_variables = &value
	m.appendconfig_variables = nil
}

// ConfigVariables returns the value of the "config_variables" field in the mutation.
func (m *ServiceTemplateMutation) ConfigVariables() (r []map[string]interface{}, exists bool) {
	v := m.config_variables
	if v == nil {
		return
	}
	return *v, true
}

// OldConfigVariables returns the old "config_variables" field's value of the ServiceTemplate entity.
// If the ServiceTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceTemplateMutation) OldConfigVariables(ctx context.Context) (v []map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConfigVariables is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConfigVariables requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConfigVariables: %w", err)
	}
	return oldValue.ConfigVariables, nil
}

// AppendConfigVariables adds value to the "config_variables" field.
func (m *ServiceTemplateMutation) AppendConfigVariables(value []map[string]interface{}) {
	m.appendconfig_variables = append(m.appendconfig_variables, value...)
}

// AppendedConfigVariables returns the list of values that were appended to the "config_variables" field in this mutation.
func (m *ServiceTemplateMutation) AppendedConfigVariables() ([]map[string]interface{}, bool) {
	if len(m.appendconfig_variables) == 0 {
		return nil, false
	}
	return m.appendconfig_variables, true
}

// ResetConfigVariables resets all changes to the "config_variables" field.
func (m *ServiceTemplateMutation) ResetConfigVariables() {
	m.config_variables = nil
	m.appendconfig_variables = nil
}

// SetSuggestedRouting sets the "suggested_routing" field.
func (m *ServiceTemplateMutation) SetSuggestedRouting(value []map[string]interface{}) {
	m.suggested_routing = &value
	m.appendsuggested_routing = nil
}

// SuggestedRouting returns the value of the "suggested_routing" field in the mutation.
func (m *ServiceTemplateMutation) SuggestedRouting() (r []map[string]interface{}, exists bool) {
	v := m.suggested_routing
	if v == nil {
		return
	}
	return *v, true
}

// OldSuggestedRouting returns the old "suggested_routing" field's value of the ServiceTemplate entity.
// If the ServiceTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceTemplateMutation) OldSuggestedRouting(ctx context.Context) (v []map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSuggestedRouting is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSuggestedRouting requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSuggestedRouting: %w", err)
	}
	return oldValue.SuggestedRouting, nil
}

// AppendSuggestedRouting adds value to the "suggested_routing" field.
func (m *ServiceTemplateMutation) AppendSuggestedRouting(value []map[string]interface{}) {
	m.appendsuggested_routing = append(m.appendsuggested_routing, value...)
}

// AppendedSuggestedRouting returns the list of values that were appended to the "suggested_routing" field in this mutation.
func (m *ServiceTemplateMutation) AppendedSuggestedRouting() ([]map[string]interface{}, bool) {
	if len(m.appendsuggested_routing) == 0 {
		return nil, false
	}
	return m.appendsuggested_routing, true
}

// ClearSuggestedRouting clears the value of the "suggested_routing" field.
func (m *ServiceTemplateMutation) ClearSuggestedRouting() {
	m.suggested_routing = nil
	m.appendsuggested_routing = nil
	m.clearedFields[servicetemplate.FieldSuggestedRouting] = struct{}{}
}

// SuggestedRoutingCleared returns if the "suggested_routing" field was cleared in this mutation.
func (m *ServiceTemplateMutation) SuggestedRoutingCleared() bool {
	_, ok := m.clearedFields[servicetemplate.FieldSuggestedRouting]
	return ok
}

// ResetSuggestedRouting resets all changes to the "suggested_routing" field.
func (m *ServiceTemplateMutation) ResetSuggestedRouting() {
	m.suggested_routing = nil
	m.appendsuggested_routing = nil
	delete(m.clearedFields, servicetemplate.FieldSuggestedRouting)
}

// SetEstimatedResources sets the "estimated_resources" field.
func (m *ServiceTemplateMutation) SetEstimatedResources(value map[string]interface{}) {
	m.estimated_resources = &value
}

// EstimatedResources returns the value of the "estimated_resources" field in the mutation.
func (m *ServiceTemplateMutation) EstimatedResources() (r map[string]interface{}, exists bool) {
	v := m.estimated_resources
	if v == nil {
		return
	}
	return *v, true
}

// OldEstimatedResources returns the old "estimated_resources" field's value of the ServiceTemplate entity.
// If the ServiceTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceTemplateMutation) OldEstimatedResources(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEstimatedResources is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEstimatedResources requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEstimatedResources: %w", err)
	}
	return oldValue.EstimatedResources, nil
}

// ClearEstimatedResources clears the value of the "estimated_resources" field.
func (m *ServiceTemplateMutation) ClearEstimatedResources() {
	m.estimated_resources = nil
	m.clearedFields[servicetemplate.FieldEstimatedResources] = struct{}{}
}

// EstimatedResourcesCleared returns if the "estimated_resources" field was cleared in this mutation.
func (m *ServiceTemplateMutation) EstimatedResourcesCleared() bool {
	_, ok := m.clearedFields[servicetemplate.FieldEstimatedResources]
	return ok
}

// ResetEstimatedResources resets all changes to the "estimated_resources" field.
func (m *ServiceTemplateMutation) ResetEstimatedResources() {
	m.estimated_resources = nil
	delete(m.clearedFields, servicetemplate.FieldEstimatedResources)
}

// SetTags sets the "tags" field.
func (m *ServiceTemplateMutation) SetTags(s []string) {
	m.tags = &s
	m.appendtags = nil
}

// Tags returns the value of the "tags" field in the mutation.
func (m *ServiceTemplateMutation) Tags() (r []string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the ServiceTemplate entity.
// If the ServiceTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceTemplateMutation) OldTags(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// AppendTags adds s to the "tags" field.
func (m *ServiceTemplateMutation) AppendTags(s []string) {
	m.appendtags = append(m.appendtags, s...)
}

// AppendedTags returns the list of values that were appended to the "tags" field in this mutation.
func (m *ServiceTemplateMutation) AppendedTags() ([]string, bool) {
	if len(m.appendtags) == 0 {
		return nil, false
	}
	return m.appendtags, true
}

// ClearTags clears the value of the "tags" field.
func (m *ServiceTemplateMutation) ClearTags() {
	m.tags = nil
	m.appendtags = nil
	m.clearedFields[servicetemplate.FieldTags] = struct{}{}
}

// TagsCleared returns if the "tags" field was cleared in this mutation.
func (m *ServiceTemplateMutation) TagsCleared() bool {
	_, ok := m.clearedFields[servicetemplate.FieldTags]
	return ok
}

// ResetTags resets all changes to the "tags" field.
func (m *ServiceTemplateMutation) ResetTags() {
	m.tags = nil
	m.appendtags = nil
	delete(m.clearedFields, servicetemplate.FieldTags)
}

// SetPrerequisites sets the "prerequisites" field.
func (m *ServiceTemplateMutation) SetPrerequisites(s []string) {
	m.prerequisites = &s
	m.appendprerequisites = nil
}

// Prerequisites returns the value of the "prerequisites" field in the mutation.
func (m *ServiceTemplateMutation) Prerequisites() (r []string, exists bool) {
	v := m.prerequisites
	if v == nil {
		return
	}
	return *v, true
}

// OldPrerequisites returns the old "prerequisites" field's value of the ServiceTemplate entity.
// If the ServiceTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceTemplateMutation) OldPrerequisites(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrerequisites is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrerequisites requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrerequisites: %w", err)
	}
	return oldValue.Prerequisites, nil
}

// AppendPrerequisites adds s to the "prerequisites" field.
func (m *ServiceTemplateMutation) AppendPrerequisites(s []string) {
	m.appendprerequisites = append(m.appendprerequisites, s...)
}

// AppendedPrerequisites returns the list of values that were appended to the "prerequisites" field in this mutation.
func (m *ServiceTemplateMutation) AppendedPrerequisites() ([]string, bool) {
	if len(m.appendprerequisites) == 0 {
		return nil, false
	}
	return m.appendprerequisites, true
}

// ClearPrerequisites clears the value of the "prerequisites" field.
func (m *ServiceTemplateMutation) ClearPrerequisites() {
	m.prerequisites = nil
	m.appendprerequisites = nil
	m.clearedFields[servicetemplate.FieldPrerequisites] = struct{}{}
}

// PrerequisitesCleared returns if the "prerequisites" field was cleared in this mutation.
func (m *ServiceTemplateMutation) PrerequisitesCleared() bool {
	_, ok := m.clearedFields[servicetemplate.FieldPrerequisites]
	return ok
}

// ResetPrerequisites resets all changes to the "prerequisites" field.
func (m *ServiceTemplateMutation) ResetPrerequisites() {
	m.prerequisites = nil
	m.appendprerequisites = nil
	delete(m.clearedFields, servicetemplate.FieldPrerequisites)
}

// SetDocumentation sets the "documentation" field.
func (m *ServiceTemplateMutation) SetDocumentation(s string) {
	m.documentation = &s
}

// Documentation returns the value of the "documentation" field in the mutation.
func (m *ServiceTemplateMutation) Documentation() (r string, exists bool) {
	v := m.documentation
	if v == nil {
		return
	}
	return *v, true
}

// OldDocumentation returns the old "documentation" field's value of the ServiceTemplate entity.
// If the ServiceTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceTemplateMutation) OldDocumentation(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDocumentation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDocumentation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDocumentation: %w", err)
	}
	return oldValue.Documentation, nil
}

// ClearDocumentation clears the value of the "documentation" field.
func (m *ServiceTemplateMutation) ClearDocumentation() {
	m.documentation = nil
	m.clearedFields[servicetemplate.FieldDocumentation] = struct{}{}
}

// DocumentationCleared returns if the "documentation" field was cleared in this mutation.
func (m *ServiceTemplateMutation) DocumentationCleared() bool {
	_, ok := m.clearedFields[servicetemplate.FieldDocumentation]
	return ok
}

// ResetDocumentation resets all changes to the "documentation" field.
func (m *ServiceTemplateMutation) ResetDocumentation() {
	m.documentation = nil
	delete(m.clearedFields, servicetemplate.FieldDocumentation)
}

// SetExamples sets the "examples" field.
func (m *ServiceTemplateMutation) SetExamples(s []string) {
	m.examples = &s
	m.appendexamples = nil
}

// Examples returns the value of the "examples" field in the mutation.
func (m *ServiceTemplateMutation) Examples() (r []string, exists bool) {
	v := m.examples
	if v == nil {
		return
	}
	return *v, true
}

// OldExamples returns the old "examples" field's value of the ServiceTemplate entity.
// If the ServiceTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceTemplateMutation) OldExamples(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExamples is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExamples requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExamples: %w", err)
	}
	return oldValue.Examples, nil
}

// AppendExamples adds s to the "examples" field.
func (m *ServiceTemplateMutation) AppendExamples(s []string) {
	m.appendexamples = append(m.appendexamples, s...)
}

// AppendedExamples returns the list of values that were appended to the "examples" field in this mutation.
func (m *ServiceTemplateMutation) AppendedExamples() ([]string, bool) {
	if len(m.appendexamples) == 0 {
		return nil, false
	}
	return m.appendexamples, true
}

// ClearExamples clears the value of the "examples" field.
func (m *ServiceTemplateMutation) ClearExamples() {
	m.examples = nil
	m.appendexamples = nil
	m.clearedFields[servicetemplate.FieldExamples] = struct{}{}
}

// ExamplesCleared returns if the "examples" field was cleared in this mutation.
func (m *ServiceTemplateMutation) ExamplesCleared() bool {
	_, ok := m.clearedFields[servicetemplate.FieldExamples]
	return ok
}

// ResetExamples resets all changes to the "examples" field.
func (m *ServiceTemplateMutation) ResetExamples() {
	m.examples = nil
	m.appendexamples = nil
	delete(m.clearedFields, servicetemplate.FieldExamples)
}

// SetCreatedAt sets the "created_at" field.
func (m *ServiceTemplateMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ServiceTemplateMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ServiceTemplate entity.
// If the ServiceTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceTemplateMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ServiceTemplateMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ServiceTemplateMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ServiceTemplateMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ServiceTemplate entity.
// If the ServiceTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceTemplateMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ServiceTemplateMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearRouter clears the "router" edge to the Router entity.
func (m *ServiceTemplateMutation) ClearRouter() {
	m.clearedrouter = true
	m.clearedFields[servicetemplate.FieldRouterID] = struct{}{}
}

// RouterCleared reports if the "router" edge to the Router entity was cleared.
func (m *ServiceTemplateMutation) RouterCleared() bool {
	return m.RouterIDCleared() || m.clearedrouter
}

// RouterIDs returns the "router" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RouterID instead. It exists only for internal usage by the builders.
func (m *ServiceTemplateMutation) RouterIDs() (ids []string) {
	if id := m.router; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRouter resets all changes to the "router" edge.
func (m *ServiceTemplateMutation) ResetRouter() {
	m.router = nil
	m.clearedrouter = false
}

// Where appends a list predicates to the ServiceTemplateMutation builder.
func (m *ServiceTemplateMutation) Where(ps ...predicate.ServiceTemplate) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ServiceTemplateMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ServiceTemplateMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ServiceTemplate, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ServiceTemplateMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ServiceTemplateMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ServiceTemplate).
func (m *ServiceTemplateMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ServiceTemplateMutation) Fields() []string {
	fields := make([]string, 0, 18)
	if m.name != nil {
		fields = append(fields, servicetemplate.FieldName)
	}
	if m.description != nil {
		fields = append(fields, servicetemplate.FieldDescription)
	}
	if m.category != nil {
		fields = append(fields, servicetemplate.FieldCategory)
	}
	if m.scope != nil {
		fields = append(fields, servicetemplate.FieldScope)
	}
	if m.version != nil {
		fields = append(fields, servicetemplate.FieldVersion)
	}
	if m.is_built_in != nil {
		fields = append(fields, servicetemplate.FieldIsBuiltIn)
	}
	if m.author != nil {
		fields = append(fields, servicetemplate.FieldAuthor)
	}
	if m.router != nil {
		fields = append(fields, servicetemplate.FieldRouterID)
	}
	if m.services != nil {
		fields = append(fields, servicetemplate.FieldServices)
	}
	if m.config_variables != nil {
		fields = append(fields, servicetemplate.FieldConfigVariables)
	}
	if m.suggested_routing != nil {
		fields = append(fields, servicetemplate.FieldSuggestedRouting)
	}
	if m.estimated_resources != nil {
		fields = append(fields, servicetemplate.FieldEstimatedResources)
	}
	if m.tags != nil {
		fields = append(fields, servicetemplate.FieldTags)
	}
	if m.prerequisites != nil {
		fields = append(fields, servicetemplate.FieldPrerequisites)
	}
	if m.documentation != nil {
		fields = append(fields, servicetemplate.FieldDocumentation)
	}
	if m.examples != nil {
		fields = append(fields, servicetemplate.FieldExamples)
	}
	if m.created_at != nil {
		fields = append(fields, servicetemplate.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, servicetemplate.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ServiceTemplateMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case servicetemplate.FieldName:
		return m.Name()
	case servicetemplate.FieldDescription:
		return m.Description()
	case servicetemplate.FieldCategory:
		return m.Category()
	case servicetemplate.FieldScope:
		return m.Scope()
	case servicetemplate.FieldVersion:
		return m.Version()
	case servicetemplate.FieldIsBuiltIn:
		return m.IsBuiltIn()
	case servicetemplate.FieldAuthor:
		return m.Author()
	case servicetemplate.FieldRouterID:
		return m.RouterID()
	case servicetemplate.FieldServices:
		return m.Services()
	case servicetemplate.FieldConfigVariables:
		return m.ConfigVariables()
	case servicetemplate.FieldSuggestedRouting:
		return m.SuggestedRouting()
	case servicetemplate.FieldEstimatedResources:
		return m.EstimatedResources()
	case servicetemplate.FieldTags:
		return m.Tags()
	case servicetemplate.FieldPrerequisites:
		return m.Prerequisites()
	case servicetemplate.FieldDocumentation:
		return m.Documentation()
	case servicetemplate.FieldExamples:
		return m.Examples()
	case servicetemplate.FieldCreatedAt:
		return m.CreatedAt()
	case servicetemplate.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ServiceTemplateMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case servicetemplate.FieldName:
		return m.OldName(ctx)
	case servicetemplate.FieldDescription:
		return m.OldDescription(ctx)
	case servicetemplate.FieldCategory:
		return m.OldCategory(ctx)
	case servicetemplate.FieldScope:
		return m.OldScope(ctx)
	case servicetemplate.FieldVersion:
		return m.OldVersion(ctx)
	case servicetemplate.FieldIsBuiltIn:
		return m.OldIsBuiltIn(ctx)
	case servicetemplate.FieldAuthor:
		return m.OldAuthor(ctx)
	case servicetemplate.FieldRouterID:
		return m.OldRouterID(ctx)
	case servicetemplate.FieldServices:
		return m.OldServices(ctx)
	case servicetemplate.FieldConfigVariables:
		return m.OldConfigVariables(ctx)
	case servicetemplate.FieldSuggestedRouting:
		return m.OldSuggestedRouting(ctx)
	case servicetemplate.FieldEstimatedResources:
		return m.OldEstimatedResources(ctx)
	case servicetemplate.FieldTags:
		return m.OldTags(ctx)
	case servicetemplate.FieldPrerequisites:
		return m.OldPrerequisites(ctx)
	case servicetemplate.FieldDocumentation:
		return m.OldDocumentation(ctx)
	case servicetemplate.FieldExamples:
		return m.OldExamples(ctx)
	case servicetemplate.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case servicetemplate.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown ServiceTemplate field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ServiceTemplateMutation) SetField(name string, value ent.Value) error {
	switch name {
	case servicetemplate.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case servicetemplate.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case servicetemplate.FieldCategory:
		v, ok := value.(servicetemplate.Category)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategory(v)
		return nil
	case servicetemplate.FieldScope:
		v, ok := value.(servicetemplate.Scope)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScope(v)
		return nil
	case servicetemplate.FieldVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case servicetemplate.FieldIsBuiltIn:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsBuiltIn(v)
		return nil
	case servicetemplate.FieldAuthor:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAuthor(v)
		return nil
	case servicetemplate.FieldRouterID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRouterID(v)
		return nil
	case servicetemplate.FieldServices:
		v, ok := value.([]map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetServices(v)
		return nil
	case servicetemplate.FieldConfigVariables:
		v, ok := value.([]map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConfigVariables(v)
		return nil
	case servicetemplate.FieldSuggestedRouting:
		v, ok := value.([]map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSuggestedRouting(v)
		return nil
	case servicetemplate.FieldEstimatedResources:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEstimatedResources(v)
		return nil
	case servicetemplate.FieldTags:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	case servicetemplate.FieldPrerequisites:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrerequisites(v)
		return nil
	case servicetemplate.FieldDocumentation:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDocumentation(v)
		return nil
	case servicetemplate.FieldExamples:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExamples(v)
		return nil
	case servicetemplate.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case servicetemplate.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown ServiceTemplate field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ServiceTemplateMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ServiceTemplateMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ServiceTemplateMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ServiceTemplate numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ServiceTemplateMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(servicetemplate.FieldAuthor) {
		fields = append(fields, servicetemplate.FieldAuthor)
	}
	if m.FieldCleared(servicetemplate.FieldRouterID) {
		fields = append(fields, servicetemplate.FieldRouterID)
	}
	if m.FieldCleared(servicetemplate.FieldSuggestedRouting) {
		fields = append(fields, servicetemplate.FieldSuggestedRouting)
	}
	if m.FieldCleared(servicetemplate.FieldEstimatedResources) {
		fields = append(fields, servicetemplate.FieldEstimatedResources)
	}
	if m.FieldCleared(servicetemplate.FieldTags) {
		fields = append(fields, servicetemplate.FieldTags)
	}
	if m.FieldCleared(servicetemplate.FieldPrerequisites) {
		fields = append(fields, servicetemplate.FieldPrerequisites)
	}
	if m.FieldCleared(servicetemplate.FieldDocumentation) {
		fields = append(fields, servicetemplate.FieldDocumentation)
	}
	if m.FieldCleared(servicetemplate.FieldExamples) {
		fields = append(fields, servicetemplate.FieldExamples)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ServiceTemplateMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ServiceTemplateMutation) ClearField(name string) error {
	switch name {
	case servicetemplate.FieldAuthor:
		m.ClearAuthor()
		return nil
	case servicetemplate.FieldRouterID:
		m.ClearRouterID()
		return nil
	case servicetemplate.FieldSuggestedRouting:
		m.ClearSuggestedRouting()
		return nil
	case servicetemplate.FieldEstimatedResources:
		m.ClearEstimatedResources()
		return nil
	case servicetemplate.FieldTags:
		m.ClearTags()
		return nil
	case servicetemplate.FieldPrerequisites:
		m.ClearPrerequisites()
		return nil
	case servicetemplate.FieldDocumentation:
		m.ClearDocumentation()
		return nil
	case servicetemplate.FieldExamples:
		m.ClearExamples()
		return nil
	}
	return fmt.Errorf("unknown ServiceTemplate nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ServiceTemplateMutation) ResetField(name string) error {
	switch name {
	case servicetemplate.FieldName:
		m.ResetName()
		return nil
	case servicetemplate.FieldDescription:
		m.ResetDescription()
		return nil
	case servicetemplate.FieldCategory:
		m.ResetCategory()
		return nil
	case servicetemplate.FieldScope:
		m.ResetScope()
		return nil
	case servicetemplate.FieldVersion:
		m.ResetVersion()
		return nil
	case servicetemplate.FieldIsBuiltIn:
		m.ResetIsBuiltIn()
		return nil
	case servicetemplate.FieldAuthor:
		m.ResetAuthor()
		return nil
	case servicetemplate.FieldRouterID:
		m.ResetRouterID()
		return nil
	case servicetemplate.FieldServices:
		m.ResetServices()
		return nil
	case servicetemplate.FieldConfigVariables:
		m.ResetConfigVariables()
		return nil
	case servicetemplate.FieldSuggestedRouting:
		m.ResetSuggestedRouting()
		return nil
	case servicetemplate.FieldEstimatedResources:
		m.ResetEstimatedResources()
		return nil
	case servicetemplate.FieldTags:
		m.ResetTags()
		return nil
	case servicetemplate.FieldPrerequisites:
		m.ResetPrerequisites()
		return nil
	case servicetemplate.FieldDocumentation:
		m.ResetDocumentation()
		return nil
	case servicetemplate.FieldExamples:
		m.ResetExamples()
		return nil
	case servicetemplate.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case servicetemplate.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown ServiceTemplate field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ServiceTemplateMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.router != nil {
		edges = append(edges, servicetemplate.EdgeRouter)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ServiceTemplateMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case servicetemplate.EdgeRouter:
		if id := m.router; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ServiceTemplateMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ServiceTemplateMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ServiceTemplateMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedrouter {
		edges = append(edges, servicetemplate.EdgeRouter)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ServiceTemplateMutation) EdgeCleared(name string) bool {
	switch name {
	case servicetemplate.EdgeRouter:
		return m.clearedrouter
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ServiceTemplateMutation) ClearEdge(name string) error {
	switch name {
	case servicetemplate.EdgeRouter:
		m.ClearRouter()
		return nil
	}
	return fmt.Errorf("unknown ServiceTemplate unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ServiceTemplateMutation) ResetEdge(name string) error {
	switch name {
	case servicetemplate.EdgeRouter:
		m.ResetRouter()
		return nil
	}
	return fmt.Errorf("unknown ServiceTemplate edge %s", name)
}

// ServiceTrafficHourlyMutation represents an operation that mutates the ServiceTrafficHourly nodes in the graph.
type ServiceTrafficHourlyMutation struct {
	config
	op                      Op
	typ                     string
	id                      *string
	hour_start              *time.Time
	tx_bytes                *int64
	addtx_bytes             *int64
	rx_bytes                *int64
	addrx_bytes             *int64
	tx_packets              *int64
	addtx_packets           *int64
	rx_packets              *int64
	addrx_packets           *int64
	created_at              *time.Time
	clearedFields           map[string]struct{}
	service_instance        *string
	clearedservice_instance bool
	done                    bool
	oldValue                func(context.Context) (*ServiceTrafficHourly, error)
	predicates              []predicate.ServiceTrafficHourly
}

var _ ent.Mutation = (*ServiceTrafficHourlyMutation)(nil)

// servicetraffichourlyOption allows management of the mutation configuration using functional options.
type servicetraffichourlyOption func(*ServiceTrafficHourlyMutation)

// newServiceTrafficHourlyMutation creates new mutation for the ServiceTrafficHourly entity.
func newServiceTrafficHourlyMutation(c config, op Op, opts ...servicetraffichourlyOption) *ServiceTrafficHourlyMutation {
	m := &ServiceTrafficHourlyMutation{
		config:        c,
		op:            op,
		typ:           TypeServiceTrafficHourly,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withServiceTrafficHourlyID sets the ID field of the mutation.
func withServiceTrafficHourlyID(id string) servicetraffichourlyOption {
	return func(m *ServiceTrafficHourlyMutation) {
		var (
			err   error
			once  sync.Once
			value *ServiceTrafficHourly
		)
		m.oldValue = func(ctx context.Context) (*ServiceTrafficHourly, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ServiceTrafficHourly.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withServiceTrafficHourly sets the old ServiceTrafficHourly of the mutation.
func withServiceTrafficHourly(node *ServiceTrafficHourly) servicetraffichourlyOption {
	return func(m *ServiceTrafficHourlyMutation) {
		m.oldValue = func(context.Context) (*ServiceTrafficHourly, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ServiceTrafficHourlyMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ServiceTrafficHourlyMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ServiceTrafficHourly entities.
func (m *ServiceTrafficHourlyMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ServiceTrafficHourlyMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ServiceTrafficHourlyMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ServiceTrafficHourly.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetInstanceID sets the "instance_id" field.
func (m *ServiceTrafficHourlyMutation) SetInstanceID(s string) {
	m.service_instance = &s
}

// InstanceID returns the value of the "instance_id" field in the mutation.
func (m *ServiceTrafficHourlyMutation) InstanceID() (r string, exists bool) {
	v := m.service_instance
	if v == nil {
		return
	}
	return *v, true
}

// OldInstanceID returns the old "instance_id" field's value of the ServiceTrafficHourly entity.
// If the ServiceTrafficHourly object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceTrafficHourlyMutation) OldInstanceID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInstanceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInstanceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInstanceID: %w", err)
	}
	return oldValue.InstanceID, nil
}

// ResetInstanceID resets all changes to the "instance_id" field.
func (m *ServiceTrafficHourlyMutation) ResetInstanceID() {
	m.service_instance = nil
}

// SetHourStart sets the "hour_start" field.
func (m *ServiceTrafficHourlyMutation) SetHourStart(t time.Time) {
	m.hour_start = &t
}

// HourStart returns the value of the "hour_start" field in the mutation.
func (m *ServiceTrafficHourlyMutation) HourStart() (r time.Time, exists bool) {
	v := m.hour_start
	if v == nil {
		return
	}
	return *v, true
}

// OldHourStart returns the old "hour_start" field's value of the ServiceTrafficHourly entity.
// If the ServiceTrafficHourly object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceTrafficHourlyMutation) OldHourStart(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHourStart is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHourStart requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHourStart: %w", err)
	}
	return oldValue.HourStart, nil
}

// ResetHourStart resets all changes to the "hour_start" field.
func (m *ServiceTrafficHourlyMutation) ResetHourStart() {
	m.hour_start = nil
}

// SetTxBytes sets the "tx_bytes" field.
func (m *ServiceTrafficHourlyMutation) SetTxBytes(i int64) {
	m.tx_bytes = &i
	m.addtx_bytes = nil
}

// TxBytes returns the value of the "tx_bytes" field in the mutation.
func (m *ServiceTrafficHourlyMutation) TxBytes() (r int64, exists bool) {
	v := m.tx_bytes
	if v == nil {
		return
	}
	return *v, true
}

// OldTxBytes returns the old "tx_bytes" field's value of the ServiceTrafficHourly entity.
// If the ServiceTrafficHourly object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceTrafficHourlyMutation) OldTxBytes(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTxBytes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTxBytes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTxBytes: %w", err)
	}
	return oldValue.TxBytes, nil
}

// AddTxBytes adds i to the "tx_bytes" field.
func (m *ServiceTrafficHourlyMutation) AddTxBytes(i int64) {
	if m.addtx_bytes != nil {
		*m.addtx_bytes += i
	} else {
		m.addtx_bytes = &i
	}
}

// AddedTxBytes returns the value that was added to the "tx_bytes" field in this mutation.
func (m *ServiceTrafficHourlyMutation) AddedTxBytes() (r int64, exists bool) {
	v := m.addtx_bytes
	if v == nil {
		return
	}
	return *v, true
}

// ResetTxBytes resets all changes to the "tx_bytes" field.
func (m *ServiceTrafficHourlyMutation) ResetTxBytes() {
	m.tx_bytes = nil
	m.addtx_bytes = nil
}

// SetRxBytes sets the "rx_bytes" field.
func (m *ServiceTrafficHourlyMutation) SetRxBytes(i int64) {
	m.rx_bytes = &i
	m.addrx_bytes = nil
}

// RxBytes returns the value of the "rx_bytes" field in the mutation.
func (m *ServiceTrafficHourlyMutation) RxBytes() (r int64, exists bool) {
	v := m.rx_bytes
	if v == nil {
		return
	}
	return *v, true
}

// OldRxBytes returns the old "rx_bytes" field's value of the ServiceTrafficHourly entity.
// If the ServiceTrafficHourly object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceTrafficHourlyMutation) OldRxBytes(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRxBytes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRxBytes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRxBytes: %w", err)
	}
	return oldValue.RxBytes, nil
}

// AddRxBytes adds i to the "rx_bytes" field.
func (m *ServiceTrafficHourlyMutation) AddRxBytes(i int64) {
	if m.addrx_bytes != nil {
		*m.addrx_bytes += i
	} else {
		m.addrx_bytes = &i
	}
}

// AddedRxBytes returns the value that was added to the "rx_bytes" field in this mutation.
func (m *ServiceTrafficHourlyMutation) AddedRxBytes() (r int64, exists bool) {
	v := m.addrx_bytes
	if v == nil {
		return
	}
	return *v, true
}

// ResetRxBytes resets all changes to the "rx_bytes" field.
func (m *ServiceTrafficHourlyMutation) ResetRxBytes() {
	m.rx_bytes = nil
	m.addrx_bytes = nil
}

// SetTxPackets sets the "tx_packets" field.
func (m *ServiceTrafficHourlyMutation) SetTxPackets(i int64) {
	m.tx_packets = &i
	m.addtx_packets = nil
}

// TxPackets returns the value of the "tx_packets" field in the mutation.
func (m *ServiceTrafficHourlyMutation) TxPackets() (r int64, exists bool) {
	v := m.tx_packets
	if v == nil {
		return
	}
	return *v, true
}

// OldTxPackets returns the old "tx_packets" field's value of the ServiceTrafficHourly entity.
// If the ServiceTrafficHourly object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceTrafficHourlyMutation) OldTxPackets(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTxPackets is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTxPackets requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTxPackets: %w", err)
	}
	return oldValue.TxPackets, nil
}

// AddTxPackets adds i to the "tx_packets" field.
func (m *ServiceTrafficHourlyMutation) AddTxPackets(i int64) {
	if m.addtx_packets != nil {
		*m.addtx_packets += i
	} else {
		m.addtx_packets = &i
	}
}

// AddedTxPackets returns the value that was added to the "tx_packets" field in this mutation.
func (m *ServiceTrafficHourlyMutation) AddedTxPackets() (r int64, exists bool) {
	v := m.addtx_packets
	if v == nil {
		return
	}
	return *v, true
}

// ResetTxPackets resets all changes to the "tx_packets" field.
func (m *ServiceTrafficHourlyMutation) ResetTxPackets() {
	m.tx_packets = nil
	m.addtx_packets = nil
}

// SetRxPackets sets the "rx_packets" field.
func (m *ServiceTrafficHourlyMutation) SetRxPackets(i int64) {
	m.rx_packets = &i
	m.addrx_packets = nil
}

// RxPackets returns the value of the "rx_packets" field in the mutation.
func (m *ServiceTrafficHourlyMutation) RxPackets() (r int64, exists bool) {
	v := m.rx_packets
	if v == nil {
		return
	}
	return *v, true
}

// OldRxPackets returns the old "rx_packets" field's value of the ServiceTrafficHourly entity.
// If the ServiceTrafficHourly object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceTrafficHourlyMutation) OldRxPackets(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRxPackets is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRxPackets requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRxPackets: %w", err)
	}
	return oldValue.RxPackets, nil
}

// AddRxPackets adds i to the "rx_packets" field.
func (m *ServiceTrafficHourlyMutation) AddRxPackets(i int64) {
	if m.addrx_packets != nil {
		*m.addrx_packets += i
	} else {
		m.addrx_packets = &i
	}
}

// AddedRxPackets returns the value that was added to the "rx_packets" field in this mutation.
func (m *ServiceTrafficHourlyMutation) AddedRxPackets() (r int64, exists bool) {
	v := m.addrx_packets
	if v == nil {
		return
	}
	return *v, true
}

// ResetRxPackets resets all changes to the "rx_packets" field.
func (m *ServiceTrafficHourlyMutation) ResetRxPackets() {
	m.rx_packets = nil
	m.addrx_packets = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ServiceTrafficHourlyMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ServiceTrafficHourlyMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ServiceTrafficHourly entity.
// If the ServiceTrafficHourly object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceTrafficHourlyMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ServiceTrafficHourlyMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetServiceInstanceID sets the "service_instance" edge to the ServiceInstance entity by id.
func (m *ServiceTrafficHourlyMutation) SetServiceInstanceID(id string) {
	m.service_instance = &id
}

// ClearServiceInstance clears the "service_instance" edge to the ServiceInstance entity.
func (m *ServiceTrafficHourlyMutation) ClearServiceInstance() {
	m.clearedservice_instance = true
	m.clearedFields[servicetraffichourly.FieldInstanceID] = struct{}{}
}

// ServiceInstanceCleared reports if the "service_instance" edge to the ServiceInstance entity was cleared.
func (m *ServiceTrafficHourlyMutation) ServiceInstanceCleared() bool {
	return m.clearedservice_instance
}

// ServiceInstanceID returns the "service_instance" edge ID in the mutation.
func (m *ServiceTrafficHourlyMutation) ServiceInstanceID() (id string, exists bool) {
	if m.service_instance != nil {
		return *m.service_instance, true
	}
	return
}

// ServiceInstanceIDs returns the "service_instance" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ServiceInstanceID instead. It exists only for internal usage by the builders.
func (m *ServiceTrafficHourlyMutation) ServiceInstanceIDs() (ids []string) {
	if id := m.service_instance; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetServiceInstance resets all changes to the "service_instance" edge.
func (m *ServiceTrafficHourlyMutation) ResetServiceInstance() {
	m.service_instance = nil
	m.clearedservice_instance = false
}

// Where appends a list predicates to the ServiceTrafficHourlyMutation builder.
func (m *ServiceTrafficHourlyMutation) Where(ps ...predicate.ServiceTrafficHourly) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ServiceTrafficHourlyMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ServiceTrafficHourlyMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ServiceTrafficHourly, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ServiceTrafficHourlyMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ServiceTrafficHourlyMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ServiceTrafficHourly).
func (m *ServiceTrafficHourlyMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ServiceTrafficHourlyMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.service_instance != nil {
		fields = append(fields, servicetraffichourly.FieldInstanceID)
	}
	if m.hour_start != nil {
		fields = append(fields, servicetraffichourly.FieldHourStart)
	}
	if m.tx_bytes != nil {
		fields = append(fields, servicetraffichourly.FieldTxBytes)
	}
	if m.rx_bytes != nil {
		fields = append(fields, servicetraffichourly.FieldRxBytes)
	}
	if m.tx_packets != nil {
		fields = append(fields, servicetraffichourly.FieldTxPackets)
	}
	if m.rx_packets != nil {
		fields = append(fields, servicetraffichourly.FieldRxPackets)
	}
	if m.created_at != nil {
		fields = append(fields, servicetraffichourly.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ServiceTrafficHourlyMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case servicetraffichourly.FieldInstanceID:
		return m.InstanceID()
	case servicetraffichourly.FieldHourStart:
		return m.HourStart()
	case servicetraffichourly.FieldTxBytes:
		return m.TxBytes()
	case servicetraffichourly.FieldRxBytes:
		return m.RxBytes()
	case servicetraffichourly.FieldTxPackets:
		return m.TxPackets()
	case servicetraffichourly.FieldRxPackets:
		return m.RxPackets()
	case servicetraffichourly.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ServiceTrafficHourlyMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case servicetraffichourly.FieldInstanceID:
		return m.OldInstanceID(ctx)
	case servicetraffichourly.FieldHourStart:
		return m.OldHourStart(ctx)
	case servicetraffichourly.FieldTxBytes:
		return m.OldTxBytes(ctx)
	case servicetraffichourly.FieldRxBytes:
		return m.OldRxBytes(ctx)
	case servicetraffichourly.FieldTxPackets:
		return m.OldTxPackets(ctx)
	case servicetraffichourly.FieldRxPackets:
		return m.OldRxPackets(ctx)
	case servicetraffichourly.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown ServiceTrafficHourly field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ServiceTrafficHourlyMutation) SetField(name string, value ent.Value) error {
	switch name {
	case servicetraffichourly.FieldInstanceID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInstanceID(v)
		return nil
	case servicetraffichourly.FieldHourStart:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHourStart(v)
		return nil
	case servicetraffichourly.FieldTxBytes:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTxBytes(v)
		return nil
	case servicetraffichourly.FieldRxBytes:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRxBytes(v)
		return nil
	case servicetraffichourly.FieldTxPackets:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTxPackets(v)
		return nil
	case servicetraffichourly.FieldRxPackets:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRxPackets(v)
		return nil
	case servicetraffichourly.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown ServiceTrafficHourly field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ServiceTrafficHourlyMutation) AddedFields() []string {
	var fields []string
	if m.addtx_bytes != nil {
		fields = append(fields, servicetraffichourly.FieldTxBytes)
	}
	if m.addrx_bytes != nil {
		fields = append(fields, servicetraffichourly.FieldRxBytes)
	}
	if m.addtx_packets != nil {
		fields = append(fields, servicetraffichourly.FieldTxPackets)
	}
	if m.addrx_packets != nil {
		fields = append(fields, servicetraffichourly.FieldRxPackets)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ServiceTrafficHourlyMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case servicetraffichourly.FieldTxBytes:
		return m.AddedTxBytes()
	case servicetraffichourly.FieldRxBytes:
		return m.AddedRxBytes()
	case servicetraffichourly.FieldTxPackets:
		return m.AddedTxPackets()
	case servicetraffichourly.FieldRxPackets:
		return m.AddedRxPackets()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ServiceTrafficHourlyMutation) AddField(name string, value ent.Value) error {
	switch name {
	case servicetraffichourly.FieldTxBytes:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTxBytes(v)
		return nil
	case servicetraffichourly.FieldRxBytes:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRxBytes(v)
		return nil
	case servicetraffichourly.FieldTxPackets:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTxPackets(v)
		return nil
	case servicetraffichourly.FieldRxPackets:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRxPackets(v)
		return nil
	}
	return fmt.Errorf("unknown ServiceTrafficHourly numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ServiceTrafficHourlyMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ServiceTrafficHourlyMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ServiceTrafficHourlyMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ServiceTrafficHourly nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ServiceTrafficHourlyMutation) ResetField(name string) error {
	switch name {
	case servicetraffichourly.FieldInstanceID:
		m.ResetInstanceID()
		return nil
	case servicetraffichourly.FieldHourStart:
		m.ResetHourStart()
		return nil
	case servicetraffichourly.FieldTxBytes:
		m.ResetTxBytes()
		return nil
	case servicetraffichourly.FieldRxBytes:
		m.ResetRxBytes()
		return nil
	case servicetraffichourly.FieldTxPackets:
		m.ResetTxPackets()
		return nil
	case servicetraffichourly.FieldRxPackets:
		m.ResetRxPackets()
		return nil
	case servicetraffichourly.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown ServiceTrafficHourly field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ServiceTrafficHourlyMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.service_instance != nil {
		edges = append(edges, servicetraffichourly.EdgeServiceInstance)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ServiceTrafficHourlyMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case servicetraffichourly.EdgeServiceInstance:
		if id := m.service_instance; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ServiceTrafficHourlyMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ServiceTrafficHourlyMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ServiceTrafficHourlyMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedservice_instance {
		edges = append(edges, servicetraffichourly.EdgeServiceInstance)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ServiceTrafficHourlyMutation) EdgeCleared(name string) bool {
	switch name {
	case servicetraffichourly.EdgeServiceInstance:
		return m.clearedservice_instance
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ServiceTrafficHourlyMutation) ClearEdge(name string) error {
	switch name {
	case servicetraffichourly.EdgeServiceInstance:
		m.ClearServiceInstance()
		return nil
	}
	return fmt.Errorf("unknown ServiceTrafficHourly unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ServiceTrafficHourlyMutation) ResetEdge(name string) error {
	switch name {
	case servicetraffichourly.EdgeServiceInstance:
		m.ResetServiceInstance()
		return nil
	}
	return fmt.Errorf("unknown ServiceTrafficHourly edge %s", name)
}

// SessionMutation represents an operation that mutates the Session nodes in the graph.
type SessionMutation struct {
	config
	op             Op
	typ            string
	id             *string
	token_id       *string
	token_family   *string
	user_agent     *string
	ip_address     *string
	expires_at     *time.Time
	last_activity  *time.Time
	revoked        *bool
	revoked_at     *time.Time
	revoked_reason *string
	created_at     *time.Time
	clearedFields  map[string]struct{}
	user           *string
	cleareduser    bool
	done           bool
	oldValue       func(context.Context) (*Session, error)
	predicates     []predicate.Session
}

var _ ent.Mutation = (*SessionMutation)(nil)

// sessionOption allows management of the mutation configuration using functional options.
type sessionOption func(*SessionMutation)

// newSessionMutation creates new mutation for the Session entity.
func newSessionMutation(c config, op Op, opts ...sessionOption) *SessionMutation {
	m := &SessionMutation{
		config:        c,
		op:            op,
		typ:           TypeSession,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSessionID sets the ID field of the mutation.
func withSessionID(id string) sessionOption {
	return func(m *SessionMutation) {
		var (
			err   error
			once  sync.Once
			value *Session
		)
		m.oldValue = func(ctx context.Context) (*Session, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Session.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSession sets the old Session of the mutation.
func withSession(node *Session) sessionOption {
	return func(m *SessionMutation) {
		m.oldValue = func(context.Context) (*Session, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SessionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SessionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Session entities.
func (m *SessionMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SessionMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SessionMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Session.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserID sets the "user_id" field.
func (m *SessionMutation) SetUserID(s string) {
	m.user = &s
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *SessionMutation) UserID() (r string, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldUserID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *SessionMutation) ResetUserID() {
	m.user = nil
}

// SetTokenID sets the "token_id" field.
func (m *SessionMutation) SetTokenID(s string) {
	m.token_id = &s
}

// TokenID returns the value of the "token_id" field in the mutation.
func (m *SessionMutation) TokenID() (r string, exists bool) {
	v := m.token_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTokenID returns the old "token_id" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldTokenID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTokenID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTokenID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTokenID: %w", err)
	}
	return oldValue.TokenID, nil
}

// ResetTokenID resets all changes to the "token_id" field.
func (m *SessionMutation) ResetTokenID() {
	m.token_id = nil
}

// SetTokenFamily sets the "token_family" field.
func (m *SessionMutation) SetTokenFamily(s string) {
	m.token_family = &s
}

// TokenFamily returns the value of the "token_family" field in the mutation.
func (m *SessionMutation) TokenFamily() (r string, exists bool) {
	v := m.token_family
	if v == nil {
		return
	}
	return *v, true
}

// OldTokenFamily returns the old "token_family" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldTokenFamily(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTokenFamily is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTokenFamily requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTokenFamily: %w", err)
	}
	return oldValue.TokenFamily, nil
}

// ClearTokenFamily clears the value of the "token_family" field.
func (m *SessionMutation) ClearTokenFamily() {
	m.token_family = nil
	m.clearedFields[session.FieldTokenFamily] = struct{}{}
}

// TokenFamilyCleared returns if the "token_family" field was cleared in this mutation.
func (m *SessionMutation) TokenFamilyCleared() bool {
	_, ok := m.clearedFields[session.FieldTokenFamily]
	return ok
}

// ResetTokenFamily resets all changes to the "token_family" field.
func (m *SessionMutation) ResetTokenFamily() {
	m.token_family = nil
	delete(m.clearedFields, session.FieldTokenFamily)
}

// SetUserAgent sets the "user_agent" field.
func (m *SessionMutation) SetUserAgent(s string) {
	m.user_agent = &s
}

// UserAgent returns the value of the "user_agent" field in the mutation.
func (m *SessionMutation) UserAgent() (r string, exists bool) {
	v := m.user_agent
	if v == nil {
		return
	}
	return *v, true
}

// OldUserAgent returns the old "user_agent" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldUserAgent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserAgent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserAgent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserAgent: %w", err)
	}
	return oldValue.UserAgent, nil
}

// ClearUserAgent clears the value of the "user_agent" field.
func (m *SessionMutation) ClearUserAgent() {
	m.user_agent = nil
	m.clearedFields[session.FieldUserAgent] = struct{}{}
}

// UserAgentCleared returns if the "user_agent" field was cleared in this mutation.
func (m *SessionMutation) UserAgentCleared() bool {
	_, ok := m.clearedFields[session.FieldUserAgent]
	return ok
}

// ResetUserAgent resets all changes to the "user_agent" field.
func (m *SessionMutation) ResetUserAgent() {
	m.user_agent = nil
	delete(m.clearedFields, session.FieldUserAgent)
}

// SetIPAddress sets the "ip_address" field.
func (m *SessionMutation) SetIPAddress(s string) {
	m.ip_address = &s
}

// IPAddress returns the value of the "ip_address" field in the mutation.
func (m *SessionMutation) IPAddress() (r string, exists bool) {
	v := m.ip_address
	if v == nil {
		return
	}
	return *v, true
}

// OldIPAddress returns the old "ip_address" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldIPAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIPAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIPAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIPAddress: %w", err)
	}
	return oldValue.IPAddress, nil
}

// ClearIPAddress clears the value of the "ip_address" field.
func (m *SessionMutation) ClearIPAddress() {
	m.ip_address = nil
	m.clearedFields[session.FieldIPAddress] = struct{}{}
}

// IPAddressCleared returns if the "ip_address" field was cleared in this mutation.
func (m *SessionMutation) IPAddressCleared() bool {
	_, ok := m.clearedFields[session.FieldIPAddress]
	return ok
}

// ResetIPAddress resets all changes to the "ip_address" field.
func (m *SessionMutation) ResetIPAddress() {
	m.ip_address = nil
	delete(m.clearedFields, session.FieldIPAddress)
}

// SetExpiresAt sets the "expires_at" field.
func (m *SessionMutation) SetExpiresAt(t time.Time) {
	m.expires_at = &t
}

// ExpiresAt returns the value of the "expires_at" field in the mutation.
func (m *SessionMutation) ExpiresAt() (r time.Time, exists bool) {
	v := m.expires_at
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiresAt returns the old "expires_at" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldExpiresAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiresAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiresAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiresAt: %w", err)
	}
	return oldValue.ExpiresAt, nil
}

// ResetExpiresAt resets all changes to the "expires_at" field.
func (m *SessionMutation) ResetExpiresAt() {
	m.expires_at = nil
}

// SetLastActivity sets the "last_activity" field.
func (m *SessionMutation) SetLastActivity(t time.Time) {
	m.last_activity = &t
}

// LastActivity returns the value of the "last_activity" field in the mutation.
func (m *SessionMutation) LastActivity() (r time.Time, exists bool) {
	v := m.last_activity
	if v == nil {
		return
	}
	return *v, true
}

// OldLastActivity returns the old "last_activity" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldLastActivity(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastActivity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastActivity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastActivity: %w", err)
	}
	return oldValue.LastActivity, nil
}

// ResetLastActivity resets all changes to the "last_activity" field.
func (m *SessionMutation) ResetLastActivity() {
	m.last_activity = nil
}

// SetRevoked sets the "revoked" field.
func (m *SessionMutation) SetRevoked(b bool) {
	m.revoked = &b
}

// Revoked returns the value of the "revoked" field in the mutation.
func (m *SessionMutation) Revoked() (r bool, exists bool) {
	v := m.revoked
	if v == nil {
		return
	}
	return *v, true
}

// OldRevoked returns the old "revoked" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldRevoked(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRevoked is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRevoked requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRevoked: %w", err)
	}
	return oldValue.Revoked, nil
}

// ResetRevoked resets all changes to the "revoked" field.
func (m *SessionMutation) ResetRevoked() {
	m.revoked = nil
}

// SetRevokedAt sets the "revoked_at" field.
func (m *SessionMutation) SetRevokedAt(t time.Time) {
	m.revoked_at = &t
}

// RevokedAt returns the value of the "revoked_at" field in the mutation.
func (m *SessionMutation) RevokedAt() (r time.Time, exists bool) {
	v := m.revoked_at
	if v == nil {
		return
	}
	return *v, true
}

// OldRevokedAt returns the old "revoked_at" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldRevokedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRevokedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRevokedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRevokedAt: %w", err)
	}
	return oldValue.RevokedAt, nil
}

// ClearRevokedAt clears the value of the "revoked_at" field.
func (m *SessionMutation) ClearRevokedAt() {
	m.revoked_at = nil
	m.clearedFields[session.FieldRevokedAt] = struct{}{}
}

// RevokedAtCleared returns if the "revoked_at" field was cleared in this mutation.
func (m *SessionMutation) RevokedAtCleared() bool {
	_, ok := m.clearedFields[session.FieldRevokedAt]
	return ok
}

// ResetRevokedAt resets all changes to the "revoked_at" field.
func (m *SessionMutation) ResetRevokedAt() {
	m.revoked_at = nil
	delete(m.clearedFields, session.FieldRevokedAt)
}

// SetRevokedReason sets the "revoked_reason" field.
func (m *SessionMutation) SetRevokedReason(s string) {
	m.revoked_reason = &s
}

// RevokedReason returns the value of the "revoked_reason" field in the mutation.
func (m *SessionMutation) RevokedReason() (r string, exists bool) {
	v := m.revoked_reason
	if v == nil {
		return
	}
	return *v, true
}

// OldRevokedReason returns the old "revoked_reason" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldRevokedReason(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRevokedReason is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRevokedReason requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRevokedReason: %w", err)
	}
	return oldValue.RevokedReason, nil
}

// ClearRevokedReason clears the value of the "revoked_reason" field.
func (m *SessionMutation) ClearRevokedReason() {
	m.revoked_reason = nil
	m.clearedFields[session.FieldRevokedReason] = struct{}{}
}

// RevokedReasonCleared returns if the "revoked_reason" field was cleared in this mutation.
func (m *SessionMutation) RevokedReasonCleared() bool {
	_, ok := m.clearedFields[session.FieldRevokedReason]
	return ok
}

// ResetRevokedReason resets all changes to the "revoked_reason" field.
func (m *SessionMutation) ResetRevokedReason() {
	m.revoked_reason = nil
	delete(m.clearedFields, session.FieldRevokedReason)
}

// SetCreatedAt sets the "created_at" field.
func (m *SessionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SessionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SessionMutation) ResetCreatedAt() {
	m.created_at = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *SessionMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[session.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *SessionMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *SessionMutation) UserIDs() (ids []string) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *SessionMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the SessionMutation builder.
func (m *SessionMutation) Where(ps ...predicate.Session) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SessionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SessionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Session, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SessionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SessionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Session).
func (m *SessionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SessionMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.user != nil {
		fields = append(fields, session.FieldUserID)
	}
	if m.token_id != nil {
		fields = append(fields, session.FieldTokenID)
	}
	if m.token_family != nil {
		fields = append(fields, session.FieldTokenFamily)
	}
	if m.user_agent != nil {
		fields = append(fields, session.FieldUserAgent)
	}
	if m.ip_address != nil {
		fields = append(fields, session.FieldIPAddress)
	}
	if m.expires_at != nil {
		fields = append(fields, session.FieldExpiresAt)
	}
	if m.last_activity != nil {
		fields = append(fields, session.FieldLastActivity)
	}
	if m.revoked != nil {
		fields = append(fields, session.FieldRevoked)
	}
	if m.revoked_at != nil {
		fields = append(fields, session.FieldRevokedAt)
	}
	if m.revoked_reason != nil {
		fields = append(fields, session.FieldRevokedReason)
	}
	if m.created_at != nil {
		fields = append(fields, session.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SessionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case session.FieldUserID:
		return m.UserID()
	case session.FieldTokenID:
		return m.TokenID()
	case session.FieldTokenFamily:
		return m.TokenFamily()
	case session.FieldUserAgent:
		return m.UserAgent()
	case session.FieldIPAddress:
		return m.IPAddress()
	case session.FieldExpiresAt:
		return m.ExpiresAt()
	case session.FieldLastActivity:
		return m.LastActivity()
	case session.FieldRevoked:
		return m.Revoked()
	case session.FieldRevokedAt:
		return m.RevokedAt()
	case session.FieldRevokedReason:
		return m.RevokedReason()
	case session.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SessionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case session.FieldUserID:
		return m.OldUserID(ctx)
	case session.FieldTokenID:
		return m.OldTokenID(ctx)
	case session.FieldTokenFamily:
		return m.OldTokenFamily(ctx)
	case session.FieldUserAgent:
		return m.OldUserAgent(ctx)
	case session.FieldIPAddress:
		return m.OldIPAddress(ctx)
	case session.FieldExpiresAt:
		return m.OldExpiresAt(ctx)
	case session.FieldLastActivity:
		return m.OldLastActivity(ctx)
	case session.FieldRevoked:
		return m.OldRevoked(ctx)
	case session.FieldRevokedAt:
		return m.OldRevokedAt(ctx)
	case session.FieldRevokedReason:
		return m.OldRevokedReason(ctx)
	case session.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Session field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SessionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case session.FieldUserID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case session.FieldTokenID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTokenID(v)
		return nil
	case session.FieldTokenFamily:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTokenFamily(v)
		return nil
	case session.FieldUserAgent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserAgent(v)
		return nil
	case session.FieldIPAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIPAddress(v)
		return nil
	case session.FieldExpiresAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiresAt(v)
		return nil
	case session.FieldLastActivity:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastActivity(v)
		return nil
	case session.FieldRevoked:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRevoked(v)
		return nil
	case session.FieldRevokedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRevokedAt(v)
		return nil
	case session.FieldRevokedReason:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRevokedReason(v)
		return nil
	case session.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Session field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SessionMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SessionMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SessionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Session numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SessionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(session.FieldTokenFamily) {
		fields = append(fields, session.FieldTokenFamily)
	}
	if m.FieldCleared(session.FieldUserAgent) {
		fields = append(fields, session.FieldUserAgent)
	}
	if m.FieldCleared(session.FieldIPAddress) {
		fields = append(fields, session.FieldIPAddress)
	}
	if m.FieldCleared(session.FieldRevokedAt) {
		fields = append(fields, session.FieldRevokedAt)
	}
	if m.FieldCleared(session.FieldRevokedReason) {
		fields = append(fields, session.FieldRevokedReason)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SessionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SessionMutation) ClearField(name string) error {
	switch name {
	case session.FieldTokenFamily:
		m.ClearTokenFamily()
		return nil
	case session.FieldUserAgent:
		m.ClearUserAgent()
		return nil
	case session.FieldIPAddress:
		m.ClearIPAddress()
		return nil
	case session.FieldRevokedAt:
		m.ClearRevokedAt()
		return nil
	case session.FieldRevokedReason:
		m.ClearRevokedReason()
		return nil
	}
	return fmt.Errorf("unknown Session nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SessionMutation) ResetField(name string) error {
	switch name {
	case session.FieldUserID:
		m.ResetUserID()
		return nil
	case session.FieldTokenID:
		m.ResetTokenID()
		return nil
	case session.FieldTokenFamily:
		m.ResetTokenFamily()
		return nil
	case session.FieldUserAgent:
		m.ResetUserAgent()
		return nil
	case session.FieldIPAddress:
		m.ResetIPAddress()
		return nil
	case session.FieldExpiresAt:
		m.ResetExpiresAt()
		return nil
	case session.FieldLastActivity:
		m.ResetLastActivity()
		return nil
	case session.FieldRevoked:
		m.ResetRevoked()
		return nil
	case session.FieldRevokedAt:
		m.ResetRevokedAt()
		return nil
	case session.FieldRevokedReason:
		m.ResetRevokedReason()
		return nil
	case session.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown Session field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SessionMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, session.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SessionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case session.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SessionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SessionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SessionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, session.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SessionMutation) EdgeCleared(name string) bool {
	switch name {
	case session.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SessionMutation) ClearEdge(name string) error {
	switch name {
	case session.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown Session unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SessionMutation) ResetEdge(name string) error {
	switch name {
	case session.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown Session edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op                  Op
	typ                 string
	id                  *string
	username            *string
	email               *string
	display_name        *string
	password_hash       *string
	role                *user.Role
	active              *bool
	mfa_enabled         *bool
	mfa_secret          *string
	last_login          *time.Time
	password_changed_at *time.Time
	created_at          *time.Time
	updated_at          *time.Time
	clearedFields       map[string]struct{}
	sessions            map[string]struct{}
	removedsessions     map[string]struct{}
	clearedsessions     bool
	api_keys            map[string]struct{}
	removedapi_keys     map[string]struct{}
	clearedapi_keys     bool
	done                bool
	oldValue            func(context.Context) (*User, error)
	predicates          []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id string) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of User entities.
func (m *UserMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUsername sets the "username" field.
func (m *UserMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *UserMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ResetUsername resets all changes to the "username" field.
func (m *UserMutation) ResetUsername() {
	m.username = nil
}

// SetEmail sets the "email" field.
func (m *UserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *UserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ClearEmail clears the value of the "email" field.
func (m *UserMutation) ClearEmail() {
	m.email = nil
	m.clearedFields[user.FieldEmail] = struct{}{}
}

// EmailCleared returns if the "email" field was cleared in this mutation.
func (m *UserMutation) EmailCleared() bool {
	_, ok := m.clearedFields[user.FieldEmail]
	return ok
}

// ResetEmail resets all changes to the "email" field.
func (m *UserMutation) ResetEmail() {
	m.email = nil
	delete(m.clearedFields, user.FieldEmail)
}

// SetDisplayName sets the "display_name" field.
func (m *UserMutation) SetDisplayName(s string) {
	m.display_name = &s
}

// DisplayName returns the value of the "display_name" field in the mutation.
func (m *UserMutation) DisplayName() (r string, exists bool) {
	v := m.display_name
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplayName returns the old "display_name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldDisplayName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplayName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplayName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplayName: %w", err)
	}
	return oldValue.DisplayName, nil
}

// ClearDisplayName clears the value of the "display_name" field.
func (m *UserMutation) ClearDisplayName() {
	m.display_name = nil
	m.clearedFields[user.FieldDisplayName] = struct{}{}
}

// DisplayNameCleared returns if the "display_name" field was cleared in this mutation.
func (m *UserMutation) DisplayNameCleared() bool {
	_, ok := m.clearedFields[user.FieldDisplayName]
	return ok
}

// ResetDisplayName resets all changes to the "display_name" field.
func (m *UserMutation) ResetDisplayName() {
	m.display_name = nil
	delete(m.clearedFields, user.FieldDisplayName)
}

// SetPasswordHash sets the "password_hash" field.
func (m *UserMutation) SetPasswordHash(s string) {
	m.password_hash = &s
}

// PasswordHash returns the value of the "password_hash" field in the mutation.
func (m *UserMutation) PasswordHash() (r string, exists bool) {
	v := m.password_hash
	if v == nil {
		return
	}
	return *v, true
}

// OldPasswordHash returns the old "password_hash" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPasswordHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPasswordHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPasswordHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPasswordHash: %w", err)
	}
	return oldValue.PasswordHash, nil
}

// ResetPasswordHash resets all changes to the "password_hash" field.
func (m *UserMutation) ResetPasswordHash() {
	m.password_hash = nil
}

// SetRole sets the "role" field.
func (m *UserMutation) SetRole(u user.Role) {
	m.role = &u
}

// Role returns the value of the "role" field in the mutation.
func (m *UserMutation) Role() (r user.Role, exists bool) {
	v := m.role
	if v == nil {
		return
	}
	return *v, true
}

// OldRole returns the old "role" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldRole(ctx context.Context) (v user.Role, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRole is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRole requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRole: %w", err)
	}
	return oldValue.Role, nil
}

// ResetRole resets all changes to the "role" field.
func (m *UserMutation) ResetRole() {
	m.role = nil
}

// SetActive sets the "active" field.
func (m *UserMutation) SetActive(b bool) {
	m.active = &b
}

// Active returns the value of the "active" field in the mutation.
func (m *UserMutation) Active() (r bool, exists bool) {
	v := m.active
	if v == nil {
		return
	}
	return *v, true
}

// OldActive returns the old "active" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActive: %w", err)
	}
	return oldValue.Active, nil
}

// ResetActive resets all changes to the "active" field.
func (m *UserMutation) ResetActive() {
	m.active = nil
}

// SetMfaEnabled sets the "mfa_enabled" field.
func (m *UserMutation) SetMfaEnabled(b bool) {
	m.mfa_enabled = &b
}

// MfaEnabled returns the value of the "mfa_enabled" field in the mutation.
func (m *UserMutation) MfaEnabled() (r bool, exists bool) {
	v := m.mfa_enabled
	if v == nil {
		return
	}
	return *v, true
}

// OldMfaEnabled returns the old "mfa_enabled" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldMfaEnabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMfaEnabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMfaEnabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMfaEnabled: %w", err)
	}
	return oldValue.MfaEnabled, nil
}

// ResetMfaEnabled resets all changes to the "mfa_enabled" field.
func (m *UserMutation) ResetMfaEnabled() {
	m.mfa_enabled = nil
}

// SetMfaSecret sets the "mfa_secret" field.
func (m *UserMutation) SetMfaSecret(s string) {
	m.mfa_secret = &s
}

// MfaSecret returns the value of the "mfa_secret" field in the mutation.
func (m *UserMutation) MfaSecret() (r string, exists bool) {
	v := m.mfa_secret
	if v == nil {
		return
	}
	return *v, true
}

// OldMfaSecret returns the old "mfa_secret" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldMfaSecret(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMfaSecret is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMfaSecret requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMfaSecret: %w", err)
	}
	return oldValue.MfaSecret, nil
}

// ClearMfaSecret clears the value of the "mfa_secret" field.
func (m *UserMutation) ClearMfaSecret() {
	m.mfa_secret = nil
	m.clearedFields[user.FieldMfaSecret] = struct{}{}
}

// MfaSecretCleared returns if the "mfa_secret" field was cleared in this mutation.
func (m *UserMutation) MfaSecretCleared() bool {
	_, ok := m.clearedFields[user.FieldMfaSecret]
	return ok
}

// ResetMfaSecret resets all changes to the "mfa_secret" field.
func (m *UserMutation) ResetMfaSecret() {
	m.mfa_secret = nil
	delete(m.clearedFields, user.FieldMfaSecret)
}

// SetLastLogin sets the "last_login" field.
func (m *UserMutation) SetLastLogin(t time.Time) {
	m.last_login = &t
}

// LastLogin returns the value of the "last_login" field in the mutation.
func (m *UserMutation) LastLogin() (r time.Time, exists bool) {
	v := m.last_login
	if v == nil {
		return
	}
	return *v, true
}

// OldLastLogin returns the old "last_login" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldLastLogin(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastLogin is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastLogin requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastLogin: %w", err)
	}
	return oldValue.LastLogin, nil
}

// ClearLastLogin clears the value of the "last_login" field.
func (m *UserMutation) ClearLastLogin() {
	m.last_login = nil
	m.clearedFields[user.FieldLastLogin] = struct{}{}
}

// LastLoginCleared returns if the "last_login" field was cleared in this mutation.
func (m *UserMutation) LastLoginCleared() bool {
	_, ok := m.clearedFields[user.FieldLastLogin]
	return ok
}

// ResetLastLogin resets all changes to the "last_login" field.
func (m *UserMutation) ResetLastLogin() {
	m.last_login = nil
	delete(m.clearedFields, user.FieldLastLogin)
}

// SetPasswordChangedAt sets the "password_changed_at" field.
func (m *UserMutation) SetPasswordChangedAt(t time.Time) {
	m.password_changed_at = &t
}

// PasswordChangedAt returns the value of the "password_changed_at" field in the mutation.
func (m *UserMutation) PasswordChangedAt() (r time.Time, exists bool) {
	v := m.password_changed_at
	if v == nil {
		return
	}
	return *v, true
}

// OldPasswordChangedAt returns the old "password_changed_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPasswordChangedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPasswordChangedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPasswordChangedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPasswordChangedAt: %w", err)
	}
	return oldValue.PasswordChangedAt, nil
}

// ResetPasswordChangedAt resets all changes to the "password_changed_at" field.
func (m *UserMutation) ResetPasswordChangedAt() {
	m.password_changed_at = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *UserMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// AddSessionIDs adds the "sessions" edge to the Session entity by ids.
func (m *UserMutation) AddSessionIDs(ids ...string) {
	if m.sessions == nil {
		m.sessions = make(map[string]struct{})
	}
	for i := range ids {
		m.sessions[ids[i]] = struct{}{}
	}
}

// ClearSessions clears the "sessions" edge to the Session entity.
func (m *UserMutation) ClearSessions() {
	m.clearedsessions = true
}

// SessionsCleared reports if the "sessions" edge to the Session entity was cleared.
func (m *UserMutation) SessionsCleared() bool {
	return m.clearedsessions
}

// RemoveSessionIDs removes the "sessions" edge to the Session entity by IDs.
func (m *UserMutation) RemoveSessionIDs(ids ...string) {
	if m.removedsessions == nil {
		m.removedsessions = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.sessions, ids[i])
		m.removedsessions[ids[i]] = struct{}{}
	}
}

// RemovedSessions returns the removed IDs of the "sessions" edge to the Session entity.
func (m *UserMutation) RemovedSessionsIDs() (ids []string) {
	for id := range m.removedsessions {
		ids = append(ids, id)
	}
	return
}

// SessionsIDs returns the "sessions" edge IDs in the mutation.
func (m *UserMutation) SessionsIDs() (ids []string) {
	for id := range m.sessions {
		ids = append(ids, id)
	}
	return
}

// ResetSessions resets all changes to the "sessions" edge.
func (m *UserMutation) ResetSessions() {
	m.sessions = nil
	m.clearedsessions = false
	m.removedsessions = nil
}

// AddAPIKeyIDs adds the "api_keys" edge to the APIKey entity by ids.
func (m *UserMutation) AddAPIKeyIDs(ids ...string) {
	if m.api_keys == nil {
		m.api_keys = make(map[string]struct{})
	}
	for i := range ids {
		m.api_keys[ids[i]] = struct{}{}
	}
}

// ClearAPIKeys clears the "api_keys" edge to the APIKey entity.
func (m *UserMutation) ClearAPIKeys() {
	m.clearedapi_keys = true
}

// APIKeysCleared reports if the "api_keys" edge to the APIKey entity was cleared.
func (m *UserMutation) APIKeysCleared() bool {
	return m.clearedapi_keys
}

// RemoveAPIKeyIDs removes the "api_keys" edge to the APIKey entity by IDs.
func (m *UserMutation) RemoveAPIKeyIDs(ids ...string) {
	if m.removedapi_keys == nil {
		m.removedapi_keys = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.api_keys, ids[i])
		m.removedapi_keys[ids[i]] = struct{}{}
	}
}

// RemovedAPIKeys returns the removed IDs of the "api_keys" edge to the APIKey entity.
func (m *UserMutation) RemovedAPIKeysIDs() (ids []string) {
	for id := range m.removedapi_keys {
		ids = append(ids, id)
	}
	return
}

// APIKeysIDs returns the "api_keys" edge IDs in the mutation.
func (m *UserMutation) APIKeysIDs() (ids []string) {
	for id := range m.api_keys {
		ids = append(ids, id)
	}
	return
}

// ResetAPIKeys resets all changes to the "api_keys" edge.
func (m *UserMutation) ResetAPIKeys() {
	m.api_keys = nil
	m.clearedapi_keys = false
	m.removedapi_keys = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.username != nil {
		fields = append(fields, user.FieldUsername)
	}
	if m.email != nil {
		fields = append(fields, user.FieldEmail)
	}
	if m.display_name != nil {
		fields = append(fields, user.FieldDisplayName)
	}
	if m.password_hash != nil {
		fields = append(fields, user.FieldPasswordHash)
	}
	if m.role != nil {
		fields = append(fields, user.FieldRole)
	}
	if m.active != nil {
		fields = append(fields, user.FieldActive)
	}
	if m.mfa_enabled != nil {
		fields = append(fields, user.FieldMfaEnabled)
	}
	if m.mfa_secret != nil {
		fields = append(fields, user.FieldMfaSecret)
	}
	if m.last_login != nil {
		fields = append(fields, user.FieldLastLogin)
	}
	if m.password_changed_at != nil {
		fields = append(fields, user.FieldPasswordChangedAt)
	}
	if m.created_at != nil {
		fields = append(fields, user.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, user.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldUsername:
		return m.Username()
	case user.FieldEmail:
		return m.Email()
	case user.FieldDisplayName:
		return m.DisplayName()
	case user.FieldPasswordHash:
		return m.PasswordHash()
	case user.FieldRole:
		return m.Role()
	case user.FieldActive:
		return m.Active()
	case user.FieldMfaEnabled:
		return m.MfaEnabled()
	case user.FieldMfaSecret:
		return m.MfaSecret()
	case user.FieldLastLogin:
		return m.LastLogin()
	case user.FieldPasswordChangedAt:
		return m.PasswordChangedAt()
	case user.FieldCreatedAt:
		return m.CreatedAt()
	case user.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldUsername:
		return m.OldUsername(ctx)
	case user.FieldEmail:
		return m.OldEmail(ctx)
	case user.FieldDisplayName:
		return m.OldDisplayName(ctx)
	case user.FieldPasswordHash:
		return m.OldPasswordHash(ctx)
	case user.FieldRole:
		return m.OldRole(ctx)
	case user.FieldActive:
		return m.OldActive(ctx)
	case user.FieldMfaEnabled:
		return m.OldMfaEnabled(ctx)
	case user.FieldMfaSecret:
		return m.OldMfaSecret(ctx)
	case user.FieldLastLogin:
		return m.OldLastLogin(ctx)
	case user.FieldPasswordChangedAt:
		return m.OldPasswordChangedAt(ctx)
	case user.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case user.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case user.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case user.FieldDisplayName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplayName(v)
		return nil
	case user.FieldPasswordHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPasswordHash(v)
		return nil
	case user.FieldRole:
		v, ok := value.(user.Role)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRole(v)
		return nil
	case user.FieldActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActive(v)
		return nil
	case user.FieldMfaEnabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMfaEnabled(v)
		return nil
	case user.FieldMfaSecret:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMfaSecret(v)
		return nil
	case user.FieldLastLogin:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastLogin(v)
		return nil
	case user.FieldPasswordChangedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPasswordChangedAt(v)
		return nil
	case user.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case user.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(user.FieldEmail) {
		fields = append(fields, user.FieldEmail)
	}
	if m.FieldCleared(user.FieldDisplayName) {
		fields = append(fields, user.FieldDisplayName)
	}
	if m.FieldCleared(user.FieldMfaSecret) {
		fields = append(fields, user.FieldMfaSecret)
	}
	if m.FieldCleared(user.FieldLastLogin) {
		fields = append(fields, user.FieldLastLogin)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	switch name {
	case user.FieldEmail:
		m.ClearEmail()
		return nil
	case user.FieldDisplayName:
		m.ClearDisplayName()
		return nil
	case user.FieldMfaSecret:
		m.ClearMfaSecret()
		return nil
	case user.FieldLastLogin:
		m.ClearLastLogin()
		return nil
	}
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldUsername:
		m.ResetUsername()
		return nil
	case user.FieldEmail:
		m.ResetEmail()
		return nil
	case user.FieldDisplayName:
		m.ResetDisplayName()
		return nil
	case user.FieldPasswordHash:
		m.ResetPasswordHash()
		return nil
	case user.FieldRole:
		m.ResetRole()
		return nil
	case user.FieldActive:
		m.ResetActive()
		return nil
	case user.FieldMfaEnabled:
		m.ResetMfaEnabled()
		return nil
	case user.FieldMfaSecret:
		m.ResetMfaSecret()
		return nil
	case user.FieldLastLogin:
		m.ResetLastLogin()
		return nil
	case user.FieldPasswordChangedAt:
		m.ResetPasswordChangedAt()
		return nil
	case user.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case user.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.sessions != nil {
		edges = append(edges, user.EdgeSessions)
	}
	if m.api_keys != nil {
		edges = append(edges, user.EdgeAPIKeys)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeSessions:
		ids := make([]ent.Value, 0, len(m.sessions))
		for id := range m.sessions {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeAPIKeys:
		ids := make([]ent.Value, 0, len(m.api_keys))
		for id := range m.api_keys {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedsessions != nil {
		edges = append(edges, user.EdgeSessions)
	}
	if m.removedapi_keys != nil {
		edges = append(edges, user.EdgeAPIKeys)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeSessions:
		ids := make([]ent.Value, 0, len(m.removedsessions))
		for id := range m.removedsessions {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeAPIKeys:
		ids := make([]ent.Value, 0, len(m.removedapi_keys))
		for id := range m.removedapi_keys {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedsessions {
		edges = append(edges, user.EdgeSessions)
	}
	if m.clearedapi_keys {
		edges = append(edges, user.EdgeAPIKeys)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeSessions:
		return m.clearedsessions
	case user.EdgeAPIKeys:
		return m.clearedapi_keys
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeSessions:
		m.ResetSessions()
		return nil
	case user.EdgeAPIKeys:
		m.ResetAPIKeys()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}

// VLANAllocationMutation represents an operation that mutates the VLANAllocation nodes in the graph.
type VLANAllocationMutation struct {
	config
	op                      Op
	typ                     string
	id                      *string
	vlan_id                 *int
	addvlan_id              *int
	service_type            *string
	subnet                  *string
	status                  *vlanallocation.Status
	allocated_at            *time.Time
	released_at             *time.Time
	clearedFields           map[string]struct{}
	router                  *string
	clearedrouter           bool
	service_instance        *string
	clearedservice_instance bool
	done                    bool
	oldValue                func(context.Context) (*VLANAllocation, error)
	predicates              []predicate.VLANAllocation
}

var _ ent.Mutation = (*VLANAllocationMutation)(nil)

// vlanallocationOption allows management of the mutation configuration using functional options.
type vlanallocationOption func(*VLANAllocationMutation)

// newVLANAllocationMutation creates new mutation for the VLANAllocation entity.
func newVLANAllocationMutation(c config, op Op, opts ...vlanallocationOption) *VLANAllocationMutation {
	m := &VLANAllocationMutation{
		config:        c,
		op:            op,
		typ:           TypeVLANAllocation,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withVLANAllocationID sets the ID field of the mutation.
func withVLANAllocationID(id string) vlanallocationOption {
	return func(m *VLANAllocationMutation) {
		var (
			err   error
			once  sync.Once
			value *VLANAllocation
		)
		m.oldValue = func(ctx context.Context) (*VLANAllocation, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().VLANAllocation.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withVLANAllocation sets the old VLANAllocation of the mutation.
func withVLANAllocation(node *VLANAllocation) vlanallocationOption {
	return func(m *VLANAllocationMutation) {
		m.oldValue = func(context.Context) (*VLANAllocation, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m VLANAllocationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m VLANAllocationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of VLANAllocation entities.
func (m *VLANAllocationMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *VLANAllocationMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *VLANAllocationMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().VLANAllocation.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetRouterID sets the "router_id" field.
func (m *VLANAllocationMutation) SetRouterID(s string) {
	m.router = &s
}

// RouterID returns the value of the "router_id" field in the mutation.
func (m *VLANAllocationMutation) RouterID() (r string, exists bool) {
	v := m.router
	if v == nil {
		return
	}
	return *v, true
}

// OldRouterID returns the old "router_id" field's value of the VLANAllocation entity.
// If the VLANAllocation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VLANAllocationMutation) OldRouterID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRouterID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRouterID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRouterID: %w", err)
	}
	return oldValue.RouterID, nil
}

// ResetRouterID resets all changes to the "router_id" field.
func (m *VLANAllocationMutation) ResetRouterID() {
	m.router = nil
}

// SetVlanID sets the "vlan_id" field.
func (m *VLANAllocationMutation) SetVlanID(i int) {
	m.vlan_id = &i
	m.addvlan_id = nil
}

// VlanID returns the value of the "vlan_id" field in the mutation.
func (m *VLANAllocationMutation) VlanID() (r int, exists bool) {
	v := m.vlan_id
	if v == nil {
		return
	}
	return *v, true
}

// OldVlanID returns the old "vlan_id" field's value of the VLANAllocation entity.
// If the VLANAllocation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VLANAllocationMutation) OldVlanID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVlanID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVlanID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVlanID: %w", err)
	}
	return oldValue.VlanID, nil
}

// AddVlanID adds i to the "vlan_id" field.
func (m *VLANAllocationMutation) AddVlanID(i int) {
	if m.addvlan_id != nil {
		*m.addvlan_id += i
	} else {
		m.addvlan_id = &i
	}
}

// AddedVlanID returns the value that was added to the "vlan_id" field in this mutation.
func (m *VLANAllocationMutation) AddedVlanID() (r int, exists bool) {
	v := m.addvlan_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetVlanID resets all changes to the "vlan_id" field.
func (m *VLANAllocationMutation) ResetVlanID() {
	m.vlan_id = nil
	m.addvlan_id = nil
}

// SetInstanceID sets the "instance_id" field.
func (m *VLANAllocationMutation) SetInstanceID(s string) {
	m.service_instance = &s
}

// InstanceID returns the value of the "instance_id" field in the mutation.
func (m *VLANAllocationMutation) InstanceID() (r string, exists bool) {
	v := m.service_instance
	if v == nil {
		return
	}
	return *v, true
}

// OldInstanceID returns the old "instance_id" field's value of the VLANAllocation entity.
// If the VLANAllocation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VLANAllocationMutation) OldInstanceID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInstanceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInstanceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInstanceID: %w", err)
	}
	return oldValue.InstanceID, nil
}

// ResetInstanceID resets all changes to the "instance_id" field.
func (m *VLANAllocationMutation) ResetInstanceID() {
	m.service_instance = nil
}

// SetServiceType sets the "service_type" field.
func (m *VLANAllocationMutation) SetServiceType(s string) {
	m.service_type = &s
}

// ServiceType returns the value of the "service_type" field in the mutation.
func (m *VLANAllocationMutation) ServiceType() (r string, exists bool) {
	v := m.service_type
	if v == nil {
		return
	}
	return *v, true
}

// OldServiceType returns the old "service_type" field's value of the VLANAllocation entity.
// If the VLANAllocation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VLANAllocationMutation) OldServiceType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldServiceType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldServiceType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldServiceType: %w", err)
	}
	return oldValue.ServiceType, nil
}

// ResetServiceType resets all changes to the "service_type" field.
func (m *VLANAllocationMutation) ResetServiceType() {
	m.service_type = nil
}

// SetSubnet sets the "subnet" field.
func (m *VLANAllocationMutation) SetSubnet(s string) {
	m.subnet = &s
}

// Subnet returns the value of the "subnet" field in the mutation.
func (m *VLANAllocationMutation) Subnet() (r string, exists bool) {
	v := m.subnet
	if v == nil {
		return
	}
	return *v, true
}

// OldSubnet returns the old "subnet" field's value of the VLANAllocation entity.
// If the VLANAllocation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VLANAllocationMutation) OldSubnet(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSubnet is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSubnet requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubnet: %w", err)
	}
	return oldValue.Subnet, nil
}

// ClearSubnet clears the value of the "subnet" field.
func (m *VLANAllocationMutation) ClearSubnet() {
	m.subnet = nil
	m.clearedFields[vlanallocation.FieldSubnet] = struct{}{}
}

// SubnetCleared returns if the "subnet" field was cleared in this mutation.
func (m *VLANAllocationMutation) SubnetCleared() bool {
	_, ok := m.clearedFields[vlanallocation.FieldSubnet]
	return ok
}

// ResetSubnet resets all changes to the "subnet" field.
func (m *VLANAllocationMutation) ResetSubnet() {
	m.subnet = nil
	delete(m.clearedFields, vlanallocation.FieldSubnet)
}

// SetStatus sets the "status" field.
func (m *VLANAllocationMutation) SetStatus(v vlanallocation.Status) {
	m.status = &v
}

// Status returns the value of the "status" field in the mutation.
func (m *VLANAllocationMutation) Status() (r vlanallocation.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the VLANAllocation entity.
// If the VLANAllocation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VLANAllocationMutation) OldStatus(ctx context.Context) (v vlanallocation.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *VLANAllocationMutation) ResetStatus() {
	m.status = nil
}

// SetAllocatedAt sets the "allocated_at" field.
func (m *VLANAllocationMutation) SetAllocatedAt(t time.Time) {
	m.allocated_at = &t
}

// AllocatedAt returns the value of the "allocated_at" field in the mutation.
func (m *VLANAllocationMutation) AllocatedAt() (r time.Time, exists bool) {
	v := m.allocated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldAllocatedAt returns the old "allocated_at" field's value of the VLANAllocation entity.
// If the VLANAllocation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VLANAllocationMutation) OldAllocatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAllocatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAllocatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAllocatedAt: %w", err)
	}
	return oldValue.AllocatedAt, nil
}

// ResetAllocatedAt resets all changes to the "allocated_at" field.
func (m *VLANAllocationMutation) ResetAllocatedAt() {
	m.allocated_at = nil
}

// SetReleasedAt sets the "released_at" field.
func (m *VLANAllocationMutation) SetReleasedAt(t time.Time) {
	m.released_at = &t
}

// ReleasedAt returns the value of the "released_at" field in the mutation.
func (m *VLANAllocationMutation) ReleasedAt() (r time.Time, exists bool) {
	v := m.released_at
	if v == nil {
		return
	}
	return *v, true
}

// OldReleasedAt returns the old "released_at" field's value of the VLANAllocation entity.
// If the VLANAllocation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VLANAllocationMutation) OldReleasedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReleasedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReleasedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReleasedAt: %w", err)
	}
	return oldValue.ReleasedAt, nil
}

// ClearReleasedAt clears the value of the "released_at" field.
func (m *VLANAllocationMutation) ClearReleasedAt() {
	m.released_at = nil
	m.clearedFields[vlanallocation.FieldReleasedAt] = struct{}{}
}

// ReleasedAtCleared returns if the "released_at" field was cleared in this mutation.
func (m *VLANAllocationMutation) ReleasedAtCleared() bool {
	_, ok := m.clearedFields[vlanallocation.FieldReleasedAt]
	return ok
}

// ResetReleasedAt resets all changes to the "released_at" field.
func (m *VLANAllocationMutation) ResetReleasedAt() {
	m.released_at = nil
	delete(m.clearedFields, vlanallocation.FieldReleasedAt)
}

// ClearRouter clears the "router" edge to the Router entity.
func (m *VLANAllocationMutation) ClearRouter() {
	m.clearedrouter = true
	m.clearedFields[vlanallocation.FieldRouterID] = struct{}{}
}

// RouterCleared reports if the "router" edge to the Router entity was cleared.
func (m *VLANAllocationMutation) RouterCleared() bool {
	return m.clearedrouter
}

// RouterIDs returns the "router" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RouterID instead. It exists only for internal usage by the builders.
func (m *VLANAllocationMutation) RouterIDs() (ids []string) {
	if id := m.router; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRouter resets all changes to the "router" edge.
func (m *VLANAllocationMutation) ResetRouter() {
	m.router = nil
	m.clearedrouter = false
}

// SetServiceInstanceID sets the "service_instance" edge to the ServiceInstance entity by id.
func (m *VLANAllocationMutation) SetServiceInstanceID(id string) {
	m.service_instance = &id
}

// ClearServiceInstance clears the "service_instance" edge to the ServiceInstance entity.
func (m *VLANAllocationMutation) ClearServiceInstance() {
	m.clearedservice_instance = true
	m.clearedFields[vlanallocation.FieldInstanceID] = struct{}{}
}

// ServiceInstanceCleared reports if the "service_instance" edge to the ServiceInstance entity was cleared.
func (m *VLANAllocationMutation) ServiceInstanceCleared() bool {
	return m.clearedservice_instance
}

// ServiceInstanceID returns the "service_instance" edge ID in the mutation.
func (m *VLANAllocationMutation) ServiceInstanceID() (id string, exists bool) {
	if m.service_instance != nil {
		return *m.service_instance, true
	}
	return
}

// ServiceInstanceIDs returns the "service_instance" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ServiceInstanceID instead. It exists only for internal usage by the builders.
func (m *VLANAllocationMutation) ServiceInstanceIDs() (ids []string) {
	if id := m.service_instance; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetServiceInstance resets all changes to the "service_instance" edge.
func (m *VLANAllocationMutation) ResetServiceInstance() {
	m.service_instance = nil
	m.clearedservice_instance = false
}

// Where appends a list predicates to the VLANAllocationMutation builder.
func (m *VLANAllocationMutation) Where(ps ...predicate.VLANAllocation) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the VLANAllocationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *VLANAllocationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.VLANAllocation, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *VLANAllocationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *VLANAllocationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (VLANAllocation).
func (m *VLANAllocationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *VLANAllocationMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.router != nil {
		fields = append(fields, vlanallocation.FieldRouterID)
	}
	if m.vlan_id != nil {
		fields = append(fields, vlanallocation.FieldVlanID)
	}
	if m.service_instance != nil {
		fields = append(fields, vlanallocation.FieldInstanceID)
	}
	if m.service_type != nil {
		fields = append(fields, vlanallocation.FieldServiceType)
	}
	if m.subnet != nil {
		fields = append(fields, vlanallocation.FieldSubnet)
	}
	if m.status != nil {
		fields = append(fields, vlanallocation.FieldStatus)
	}
	if m.allocated_at != nil {
		fields = append(fields, vlanallocation.FieldAllocatedAt)
	}
	if m.released_at != nil {
		fields = append(fields, vlanallocation.FieldReleasedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *VLANAllocationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case vlanallocation.FieldRouterID:
		return m.RouterID()
	case vlanallocation.FieldVlanID:
		return m.VlanID()
	case vlanallocation.FieldInstanceID:
		return m.InstanceID()
	case vlanallocation.FieldServiceType:
		return m.ServiceType()
	case vlanallocation.FieldSubnet:
		return m.Subnet()
	case vlanallocation.FieldStatus:
		return m.Status()
	case vlanallocation.FieldAllocatedAt:
		return m.AllocatedAt()
	case vlanallocation.FieldReleasedAt:
		return m.ReleasedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *VLANAllocationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case vlanallocation.FieldRouterID:
		return m.OldRouterID(ctx)
	case vlanallocation.FieldVlanID:
		return m.OldVlanID(ctx)
	case vlanallocation.FieldInstanceID:
		return m.OldInstanceID(ctx)
	case vlanallocation.FieldServiceType:
		return m.OldServiceType(ctx)
	case vlanallocation.FieldSubnet:
		return m.OldSubnet(ctx)
	case vlanallocation.FieldStatus:
		return m.OldStatus(ctx)
	case vlanallocation.FieldAllocatedAt:
		return m.OldAllocatedAt(ctx)
	case vlanallocation.FieldReleasedAt:
		return m.OldReleasedAt(ctx)
	}
	return nil, fmt.Errorf("unknown VLANAllocation field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VLANAllocationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case vlanallocation.FieldRouterID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRouterID(v)
		return nil
	case vlanallocation.FieldVlanID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVlanID(v)
		return nil
	case vlanallocation.FieldInstanceID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInstanceID(v)
		return nil
	case vlanallocation.FieldServiceType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetServiceType(v)
		return nil
	case vlanallocation.FieldSubnet:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubnet(v)
		return nil
	case vlanallocation.FieldStatus:
		v, ok := value.(vlanallocation.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case vlanallocation.FieldAllocatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAllocatedAt(v)
		return nil
	case vlanallocation.FieldReleasedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReleasedAt(v)
		return nil
	}
	return fmt.Errorf("unknown VLANAllocation field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *VLANAllocationMutation) AddedFields() []string {
	var fields []string
	if m.addvlan_id != nil {
		fields = append(fields, vlanallocation.FieldVlanID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *VLANAllocationMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case vlanallocation.FieldVlanID:
		return m.AddedVlanID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VLANAllocationMutation) AddField(name string, value ent.Value) error {
	switch name {
	case vlanallocation.FieldVlanID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVlanID(v)
		return nil
	}
	return fmt.Errorf("unknown VLANAllocation numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *VLANAllocationMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(vlanallocation.FieldSubnet) {
		fields = append(fields, vlanallocation.FieldSubnet)
	}
	if m.FieldCleared(vlanallocation.FieldReleasedAt) {
		fields = append(fields, vlanallocation.FieldReleasedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *VLANAllocationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *VLANAllocationMutation) ClearField(name string) error {
	switch name {
	case vlanallocation.FieldSubnet:
		m.ClearSubnet()
		return nil
	case vlanallocation.FieldReleasedAt:
		m.ClearReleasedAt()
		return nil
	}
	return fmt.Errorf("unknown VLANAllocation nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *VLANAllocationMutation) ResetField(name string) error {
	switch name {
	case vlanallocation.FieldRouterID:
		m.ResetRouterID()
		return nil
	case vlanallocation.FieldVlanID:
		m.ResetVlanID()
		return nil
	case vlanallocation.FieldInstanceID:
		m.ResetInstanceID()
		return nil
	case vlanallocation.FieldServiceType:
		m.ResetServiceType()
		return nil
	case vlanallocation.FieldSubnet:
		m.ResetSubnet()
		return nil
	case vlanallocation.FieldStatus:
		m.ResetStatus()
		return nil
	case vlanallocation.FieldAllocatedAt:
		m.ResetAllocatedAt()
		return nil
	case vlanallocation.FieldReleasedAt:
		m.ResetReleasedAt()
		return nil
	}
	return fmt.Errorf("unknown VLANAllocation field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *VLANAllocationMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.router != nil {
		edges = append(edges, vlanallocation.EdgeRouter)
	}
	if m.service_instance != nil {
		edges = append(edges, vlanallocation.EdgeServiceInstance)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *VLANAllocationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case vlanallocation.EdgeRouter:
		if id := m.router; id != nil {
			return []ent.Value{*id}
		}
	case vlanallocation.EdgeServiceInstance:
		if id := m.service_instance; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *VLANAllocationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *VLANAllocationMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *VLANAllocationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedrouter {
		edges = append(edges, vlanallocation.EdgeRouter)
	}
	if m.clearedservice_instance {
		edges = append(edges, vlanallocation.EdgeServiceInstance)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *VLANAllocationMutation) EdgeCleared(name string) bool {
	switch name {
	case vlanallocation.EdgeRouter:
		return m.clearedrouter
	case vlanallocation.EdgeServiceInstance:
		return m.clearedservice_instance
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *VLANAllocationMutation) ClearEdge(name string) error {
	switch name {
	case vlanallocation.EdgeRouter:
		m.ClearRouter()
		return nil
	case vlanallocation.EdgeServiceInstance:
		m.ClearServiceInstance()
		return nil
	}
	return fmt.Errorf("unknown VLANAllocation unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *VLANAllocationMutation) ResetEdge(name string) error {
	switch name {
	case vlanallocation.EdgeRouter:
		m.ResetRouter()
		return nil
	case vlanallocation.EdgeServiceInstance:
		m.ResetServiceInstance()
		return nil
	}
	return fmt.Errorf("unknown VLANAllocation edge %s", name)
}

// VirtualInterfaceMutation represents an operation that mutates the VirtualInterface nodes in the graph.
type VirtualInterfaceMutation struct {
	config
	op                     Op
	typ                    string
	id                     *string
	interface_name         *string
	vlan_id                *int
	addvlan_id             *int
	ip_address             *string
	gateway_type           *virtualinterface.GatewayType
	gateway_status         *virtualinterface.GatewayStatus
	tun_name               *string
	routing_mark           *string
	status                 *virtualinterface.Status
	created_at             *time.Time
	updated_at             *time.Time
	clearedFields          map[string]struct{}
	instance               *string
	clearedinstance        bool
	device_routings        map[string]struct{}
	removeddevice_routings map[string]struct{}
	cleareddevice_routings bool
	done                   bool
	oldValue               func(context.Context) (*VirtualInterface, error)
	predicates             []predicate.VirtualInterface
}

var _ ent.Mutation = (*VirtualInterfaceMutation)(nil)

// virtualinterfaceOption allows management of the mutation configuration using functional options.
type virtualinterfaceOption func(*VirtualInterfaceMutation)

// newVirtualInterfaceMutation creates new mutation for the VirtualInterface entity.
func newVirtualInterfaceMutation(c config, op Op, opts ...virtualinterfaceOption) *VirtualInterfaceMutation {
	m := &VirtualInterfaceMutation{
		config:        c,
		op:            op,
		typ:           TypeVirtualInterface,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withVirtualInterfaceID sets the ID field of the mutation.
func withVirtualInterfaceID(id string) virtualinterfaceOption {
	return func(m *VirtualInterfaceMutation) {
		var (
			err   error
			once  sync.Once
			value *VirtualInterface
		)
		m.oldValue = func(ctx context.Context) (*VirtualInterface, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().VirtualInterface.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withVirtualInterface sets the old VirtualInterface of the mutation.
func withVirtualInterface(node *VirtualInterface) virtualinterfaceOption {
	return func(m *VirtualInterfaceMutation) {
		m.oldValue = func(context.Context) (*VirtualInterface, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m VirtualInterfaceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m VirtualInterfaceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of VirtualInterface entities.
func (m *VirtualInterfaceMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *VirtualInterfaceMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *VirtualInterfaceMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().VirtualInterface.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetInstanceID sets the "instance_id" field.
func (m *VirtualInterfaceMutation) SetInstanceID(s string) {
	m.instance = &s
}

// InstanceID returns the value of the "instance_id" field in the mutation.
func (m *VirtualInterfaceMutation) InstanceID() (r string, exists bool) {
	v := m.instance
	if v == nil {
		return
	}
	return *v, true
}

// OldInstanceID returns the old "instance_id" field's value of the VirtualInterface entity.
// If the VirtualInterface object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VirtualInterfaceMutation) OldInstanceID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInstanceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInstanceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInstanceID: %w", err)
	}
	return oldValue.InstanceID, nil
}

// ResetInstanceID resets all changes to the "instance_id" field.
func (m *VirtualInterfaceMutation) ResetInstanceID() {
	m.instance = nil
}

// SetInterfaceName sets the "interface_name" field.
func (m *VirtualInterfaceMutation) SetInterfaceName(s string) {
	m.interface_name = &s
}

// InterfaceName returns the value of the "interface_name" field in the mutation.
func (m *VirtualInterfaceMutation) InterfaceName() (r string, exists bool) {
	v := m.interface_name
	if v == nil {
		return
	}
	return *v, true
}

// OldInterfaceName returns the old "interface_name" field's value of the VirtualInterface entity.
// If the VirtualInterface object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VirtualInterfaceMutation) OldInterfaceName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInterfaceName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInterfaceName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInterfaceName: %w", err)
	}
	return oldValue.InterfaceName, nil
}

// ResetInterfaceName resets all changes to the "interface_name" field.
func (m *VirtualInterfaceMutation) ResetInterfaceName() {
	m.interface_name = nil
}

// SetVlanID sets the "vlan_id" field.
func (m *VirtualInterfaceMutation) SetVlanID(i int) {
	m.vlan_id = &i
	m.addvlan_id = nil
}

// VlanID returns the value of the "vlan_id" field in the mutation.
func (m *VirtualInterfaceMutation) VlanID() (r int, exists bool) {
	v := m.vlan_id
	if v == nil {
		return
	}
	return *v, true
}

// OldVlanID returns the old "vlan_id" field's value of the VirtualInterface entity.
// If the VirtualInterface object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VirtualInterfaceMutation) OldVlanID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVlanID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVlanID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVlanID: %w", err)
	}
	return oldValue.VlanID, nil
}

// AddVlanID adds i to the "vlan_id" field.
func (m *VirtualInterfaceMutation) AddVlanID(i int) {
	if m.addvlan_id != nil {
		*m.addvlan_id += i
	} else {
		m.addvlan_id = &i
	}
}

// AddedVlanID returns the value that was added to the "vlan_id" field in this mutation.
func (m *VirtualInterfaceMutation) AddedVlanID() (r int, exists bool) {
	v := m.addvlan_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetVlanID resets all changes to the "vlan_id" field.
func (m *VirtualInterfaceMutation) ResetVlanID() {
	m.vlan_id = nil
	m.addvlan_id = nil
}

// SetIPAddress sets the "ip_address" field.
func (m *VirtualInterfaceMutation) SetIPAddress(s string) {
	m.ip_address = &s
}

// IPAddress returns the value of the "ip_address" field in the mutation.
func (m *VirtualInterfaceMutation) IPAddress() (r string, exists bool) {
	v := m.ip_address
	if v == nil {
		return
	}
	return *v, true
}

// OldIPAddress returns the old "ip_address" field's value of the VirtualInterface entity.
// If the VirtualInterface object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VirtualInterfaceMutation) OldIPAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIPAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIPAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIPAddress: %w", err)
	}
	return oldValue.IPAddress, nil
}

// ResetIPAddress resets all changes to the "ip_address" field.
func (m *VirtualInterfaceMutation) ResetIPAddress() {
	m.ip_address = nil
}

// SetGatewayType sets the "gateway_type" field.
func (m *VirtualInterfaceMutation) SetGatewayType(vt virtualinterface.GatewayType) {
	m.gateway_type = &vt
}

// GatewayType returns the value of the "gateway_type" field in the mutation.
func (m *VirtualInterfaceMutation) GatewayType() (r virtualinterface.GatewayType, exists bool) {
	v := m.gateway_type
	if v == nil {
		return
	}
	return *v, true
}

// OldGatewayType returns the old "gateway_type" field's value of the VirtualInterface entity.
// If the VirtualInterface object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VirtualInterfaceMutation) OldGatewayType(ctx context.Context) (v virtualinterface.GatewayType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGatewayType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGatewayType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGatewayType: %w", err)
	}
	return oldValue.GatewayType, nil
}

// ResetGatewayType resets all changes to the "gateway_type" field.
func (m *VirtualInterfaceMutation) ResetGatewayType() {
	m.gateway_type = nil
}

// SetGatewayStatus sets the "gateway_status" field.
func (m *VirtualInterfaceMutation) SetGatewayStatus(vs virtualinterface.GatewayStatus) {
	m.gateway_status = &vs
}

// GatewayStatus returns the value of the "gateway_status" field in the mutation.
func (m *VirtualInterfaceMutation) GatewayStatus() (r virtualinterface.GatewayStatus, exists bool) {
	v := m.gateway_status
	if v == nil {
		return
	}
	return *v, true
}

// OldGatewayStatus returns the old "gateway_status" field's value of the VirtualInterface entity.
// If the VirtualInterface object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VirtualInterfaceMutation) OldGatewayStatus(ctx context.Context) (v virtualinterface.GatewayStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGatewayStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGatewayStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGatewayStatus: %w", err)
	}
	return oldValue.GatewayStatus, nil
}

// ResetGatewayStatus resets all changes to the "gateway_status" field.
func (m *VirtualInterfaceMutation) ResetGatewayStatus() {
	m.gateway_status = nil
}

// SetTunName sets the "tun_name" field.
func (m *VirtualInterfaceMutation) SetTunName(s string) {
	m.tun_name = &s
}

// TunName returns the value of the "tun_name" field in the mutation.
func (m *VirtualInterfaceMutation) TunName() (r string, exists bool) {
	v := m.tun_name
	if v == nil {
		return
	}
	return *v, true
}

// OldTunName returns the old "tun_name" field's value of the VirtualInterface entity.
// If the VirtualInterface object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VirtualInterfaceMutation) OldTunName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTunName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTunName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTunName: %w", err)
	}
	return oldValue.TunName, nil
}

// ClearTunName clears the value of the "tun_name" field.
func (m *VirtualInterfaceMutation) ClearTunName() {
	m.tun_name = nil
	m.clearedFields[virtualinterface.FieldTunName] = struct{}{}
}

// TunNameCleared returns if the "tun_name" field was cleared in this mutation.
func (m *VirtualInterfaceMutation) TunNameCleared() bool {
	_, ok := m.clearedFields[virtualinterface.FieldTunName]
	return ok
}

// ResetTunName resets all changes to the "tun_name" field.
func (m *VirtualInterfaceMutation) ResetTunName() {
	m.tun_name = nil
	delete(m.clearedFields, virtualinterface.FieldTunName)
}

// SetRoutingMark sets the "routing_mark" field.
func (m *VirtualInterfaceMutation) SetRoutingMark(s string) {
	m.routing_mark = &s
}

// RoutingMark returns the value of the "routing_mark" field in the mutation.
func (m *VirtualInterfaceMutation) RoutingMark() (r string, exists bool) {
	v := m.routing_mark
	if v == nil {
		return
	}
	return *v, true
}

// OldRoutingMark returns the old "routing_mark" field's value of the VirtualInterface entity.
// If the VirtualInterface object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VirtualInterfaceMutation) OldRoutingMark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRoutingMark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRoutingMark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRoutingMark: %w", err)
	}
	return oldValue.RoutingMark, nil
}

// ResetRoutingMark resets all changes to the "routing_mark" field.
func (m *VirtualInterfaceMutation) ResetRoutingMark() {
	m.routing_mark = nil
}

// SetStatus sets the "status" field.
func (m *VirtualInterfaceMutation) SetStatus(v virtualinterface.Status) {
	m.status = &v
}

// Status returns the value of the "status" field in the mutation.
func (m *VirtualInterfaceMutation) Status() (r virtualinterface.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the VirtualInterface entity.
// If the VirtualInterface object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VirtualInterfaceMutation) OldStatus(ctx context.Context) (v virtualinterface.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *VirtualInterfaceMutation) ResetStatus() {
	m.status = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *VirtualInterfaceMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *VirtualInterfaceMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the VirtualInterface entity.
// If the VirtualInterface object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VirtualInterfaceMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *VirtualInterfaceMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *VirtualInterfaceMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *VirtualInterfaceMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the VirtualInterface entity.
// If the VirtualInterface object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VirtualInterfaceMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *VirtualInterfaceMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearInstance clears the "instance" edge to the ServiceInstance entity.
func (m *VirtualInterfaceMutation) ClearInstance() {
	m.clearedinstance = true
	m.clearedFields[virtualinterface.FieldInstanceID] = struct{}{}
}

// InstanceCleared reports if the "instance" edge to the ServiceInstance entity was cleared.
func (m *VirtualInterfaceMutation) InstanceCleared() bool {
	return m.clearedinstance
}

// InstanceIDs returns the "instance" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// InstanceID instead. It exists only for internal usage by the builders.
func (m *VirtualInterfaceMutation) InstanceIDs() (ids []string) {
	if id := m.instance; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetInstance resets all changes to the "instance" edge.
func (m *VirtualInterfaceMutation) ResetInstance() {
	m.instance = nil
	m.clearedinstance = false
}

// AddDeviceRoutingIDs adds the "device_routings" edge to the DeviceRouting entity by ids.
func (m *VirtualInterfaceMutation) AddDeviceRoutingIDs(ids ...string) {
	if m.device_routings == nil {
		m.device_routings = make(map[string]struct{})
	}
	for i := range ids {
		m.device_routings[ids[i]] = struct{}{}
	}
}

// ClearDeviceRoutings clears the "device_routings" edge to the DeviceRouting entity.
func (m *VirtualInterfaceMutation) ClearDeviceRoutings() {
	m.cleareddevice_routings = true
}

// DeviceRoutingsCleared reports if the "device_routings" edge to the DeviceRouting entity was cleared.
func (m *VirtualInterfaceMutation) DeviceRoutingsCleared() bool {
	return m.cleareddevice_routings
}

// RemoveDeviceRoutingIDs removes the "device_routings" edge to the DeviceRouting entity by IDs.
func (m *VirtualInterfaceMutation) RemoveDeviceRoutingIDs(ids ...string) {
	if m.removeddevice_routings == nil {
		m.removeddevice_routings = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.device_routings, ids[i])
		m.removeddevice_routings[ids[i]] = struct{}{}
	}
}

// RemovedDeviceRoutings returns the removed IDs of the "device_routings" edge to the DeviceRouting entity.
func (m *VirtualInterfaceMutation) RemovedDeviceRoutingsIDs() (ids []string) {
	for id := range m.removeddevice_routings {
		ids = append(ids, id)
	}
	return
}

// DeviceRoutingsIDs returns the "device_routings" edge IDs in the mutation.
func (m *VirtualInterfaceMutation) DeviceRoutingsIDs() (ids []string) {
	for id := range m.device_routings {
		ids = append(ids, id)
	}
	return
}

// ResetDeviceRoutings resets all changes to the "device_routings" edge.
func (m *VirtualInterfaceMutation) ResetDeviceRoutings() {
	m.device_routings = nil
	m.cleareddevice_routings = false
	m.removeddevice_routings = nil
}

// Where appends a list predicates to the VirtualInterfaceMutation builder.
func (m *VirtualInterfaceMutation) Where(ps ...predicate.VirtualInterface) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the VirtualInterfaceMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *VirtualInterfaceMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.VirtualInterface, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *VirtualInterfaceMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *VirtualInterfaceMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (VirtualInterface).
func (m *VirtualInterfaceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *VirtualInterfaceMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.instance != nil {
		fields = append(fields, virtualinterface.FieldInstanceID)
	}
	if m.interface_name != nil {
		fields = append(fields, virtualinterface.FieldInterfaceName)
	}
	if m.vlan_id != nil {
		fields = append(fields, virtualinterface.FieldVlanID)
	}
	if m.ip_address != nil {
		fields = append(fields, virtualinterface.FieldIPAddress)
	}
	if m.gateway_type != nil {
		fields = append(fields, virtualinterface.FieldGatewayType)
	}
	if m.gateway_status != nil {
		fields = append(fields, virtualinterface.FieldGatewayStatus)
	}
	if m.tun_name != nil {
		fields = append(fields, virtualinterface.FieldTunName)
	}
	if m.routing_mark != nil {
		fields = append(fields, virtualinterface.FieldRoutingMark)
	}
	if m.status != nil {
		fields = append(fields, virtualinterface.FieldStatus)
	}
	if m.created_at != nil {
		fields = append(fields, virtualinterface.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, virtualinterface.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *VirtualInterfaceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case virtualinterface.FieldInstanceID:
		return m.InstanceID()
	case virtualinterface.FieldInterfaceName:
		return m.InterfaceName()
	case virtualinterface.FieldVlanID:
		return m.VlanID()
	case virtualinterface.FieldIPAddress:
		return m.IPAddress()
	case virtualinterface.FieldGatewayType:
		return m.GatewayType()
	case virtualinterface.FieldGatewayStatus:
		return m.GatewayStatus()
	case virtualinterface.FieldTunName:
		return m.TunName()
	case virtualinterface.FieldRoutingMark:
		return m.RoutingMark()
	case virtualinterface.FieldStatus:
		return m.Status()
	case virtualinterface.FieldCreatedAt:
		return m.CreatedAt()
	case virtualinterface.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *VirtualInterfaceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case virtualinterface.FieldInstanceID:
		return m.OldInstanceID(ctx)
	case virtualinterface.FieldInterfaceName:
		return m.OldInterfaceName(ctx)
	case virtualinterface.FieldVlanID:
		return m.OldVlanID(ctx)
	case virtualinterface.FieldIPAddress:
		return m.OldIPAddress(ctx)
	case virtualinterface.FieldGatewayType:
		return m.OldGatewayType(ctx)
	case virtualinterface.FieldGatewayStatus:
		return m.OldGatewayStatus(ctx)
	case virtualinterface.FieldTunName:
		return m.OldTunName(ctx)
	case virtualinterface.FieldRoutingMark:
		return m.OldRoutingMark(ctx)
	case virtualinterface.FieldStatus:
		return m.OldStatus(ctx)
	case virtualinterface.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case virtualinterface.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown VirtualInterface field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VirtualInterfaceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case virtualinterface.FieldInstanceID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInstanceID(v)
		return nil
	case virtualinterface.FieldInterfaceName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInterfaceName(v)
		return nil
	case virtualinterface.FieldVlanID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVlanID(v)
		return nil
	case virtualinterface.FieldIPAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIPAddress(v)
		return nil
	case virtualinterface.FieldGatewayType:
		v, ok := value.(virtualinterface.GatewayType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGatewayType(v)
		return nil
	case virtualinterface.FieldGatewayStatus:
		v, ok := value.(virtualinterface.GatewayStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGatewayStatus(v)
		return nil
	case virtualinterface.FieldTunName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTunName(v)
		return nil
	case virtualinterface.FieldRoutingMark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRoutingMark(v)
		return nil
	case virtualinterface.FieldStatus:
		v, ok := value.(virtualinterface.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case virtualinterface.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case virtualinterface.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown VirtualInterface field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *VirtualInterfaceMutation) AddedFields() []string {
	var fields []string
	if m.addvlan_id != nil {
		fields = append(fields, virtualinterface.FieldVlanID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *VirtualInterfaceMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case virtualinterface.FieldVlanID:
		return m.AddedVlanID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VirtualInterfaceMutation) AddField(name string, value ent.Value) error {
	switch name {
	case virtualinterface.FieldVlanID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVlanID(v)
		return nil
	}
	return fmt.Errorf("unknown VirtualInterface numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *VirtualInterfaceMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(virtualinterface.FieldTunName) {
		fields = append(fields, virtualinterface.FieldTunName)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *VirtualInterfaceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *VirtualInterfaceMutation) ClearField(name string) error {
	switch name {
	case virtualinterface.FieldTunName:
		m.ClearTunName()
		return nil
	}
	return fmt.Errorf("unknown VirtualInterface nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *VirtualInterfaceMutation) ResetField(name string) error {
	switch name {
	case virtualinterface.FieldInstanceID:
		m.ResetInstanceID()
		return nil
	case virtualinterface.FieldInterfaceName:
		m.ResetInterfaceName()
		return nil
	case virtualinterface.FieldVlanID:
		m.ResetVlanID()
		return nil
	case virtualinterface.FieldIPAddress:
		m.ResetIPAddress()
		return nil
	case virtualinterface.FieldGatewayType:
		m.ResetGatewayType()
		return nil
	case virtualinterface.FieldGatewayStatus:
		m.ResetGatewayStatus()
		return nil
	case virtualinterface.FieldTunName:
		m.ResetTunName()
		return nil
	case virtualinterface.FieldRoutingMark:
		m.ResetRoutingMark()
		return nil
	case virtualinterface.FieldStatus:
		m.ResetStatus()
		return nil
	case virtualinterface.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case virtualinterface.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown VirtualInterface field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *VirtualInterfaceMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.instance != nil {
		edges = append(edges, virtualinterface.EdgeInstance)
	}
	if m.device_routings != nil {
		edges = append(edges, virtualinterface.EdgeDeviceRoutings)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *VirtualInterfaceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case virtualinterface.EdgeInstance:
		if id := m.instance; id != nil {
			return []ent.Value{*id}
		}
	case virtualinterface.EdgeDeviceRoutings:
		ids := make([]ent.Value, 0, len(m.device_routings))
		for id := range m.device_routings {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *VirtualInterfaceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removeddevice_routings != nil {
		edges = append(edges, virtualinterface.EdgeDeviceRoutings)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *VirtualInterfaceMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case virtualinterface.EdgeDeviceRoutings:
		ids := make([]ent.Value, 0, len(m.removeddevice_routings))
		for id := range m.removeddevice_routings {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *VirtualInterfaceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedinstance {
		edges = append(edges, virtualinterface.EdgeInstance)
	}
	if m.cleareddevice_routings {
		edges = append(edges, virtualinterface.EdgeDeviceRoutings)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *VirtualInterfaceMutation) EdgeCleared(name string) bool {
	switch name {
	case virtualinterface.EdgeInstance:
		return m.clearedinstance
	case virtualinterface.EdgeDeviceRoutings:
		return m.cleareddevice_routings
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *VirtualInterfaceMutation) ClearEdge(name string) error {
	switch name {
	case virtualinterface.EdgeInstance:
		m.ClearInstance()
		return nil
	}
	return fmt.Errorf("unknown VirtualInterface unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *VirtualInterfaceMutation) ResetEdge(name string) error {
	switch name {
	case virtualinterface.EdgeInstance:
		m.ResetInstance()
		return nil
	case virtualinterface.EdgeDeviceRoutings:
		m.ResetDeviceRoutings()
		return nil
	}
	return fmt.Errorf("unknown VirtualInterface edge %s", name)
}

// WebhookMutation represents an operation that mutates the Webhook nodes in the graph.
type WebhookMutation struct {
	config
	op                       Op
	typ                      string
	id                       *string
	name                     *string
	url                      *string
	auth_type                *webhook.AuthType
	auth_value_encrypted     *[]byte
	auth_nonce               *[]byte
	signing_secret_encrypted *[]byte
	signing_nonce            *[]byte
	headers                  *map[string]string
	template                 *webhook.Template
	custom_template          *string
	enabled                  *bool
	success_count            *int
	addsuccess_count         *int
	failure_count            *int
	addfailure_count         *int
	last_success_at          *time.Time
	last_failure_at          *time.Time
	created_at               *time.Time
	updated_at               *time.Time
	clearedFields            map[string]struct{}
	logs                     map[string]struct{}
	removedlogs              map[string]struct{}
	clearedlogs              bool
	done                     bool
	oldValue                 func(context.Context) (*Webhook, error)
	predicates               []predicate.Webhook
}

var _ ent.Mutation = (*WebhookMutation)(nil)

// webhookOption allows management of the mutation configuration using functional options.
type webhookOption func(*WebhookMutation)

// newWebhookMutation creates new mutation for the Webhook entity.
func newWebhookMutation(c config, op Op, opts ...webhookOption) *WebhookMutation {
	m := &WebhookMutation{
		config:        c,
		op:            op,
		typ:           TypeWebhook,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withWebhookID sets the ID field of the mutation.
func withWebhookID(id string) webhookOption {
	return func(m *WebhookMutation) {
		var (
			err   error
			once  sync.Once
			value *Webhook
		)
		m.oldValue = func(ctx context.Context) (*Webhook, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Webhook.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withWebhook sets the old Webhook of the mutation.
func withWebhook(node *Webhook) webhookOption {
	return func(m *WebhookMutation) {
		m.oldValue = func(context.Context) (*Webhook, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m WebhookMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m WebhookMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Webhook entities.
func (m *WebhookMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *WebhookMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *WebhookMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Webhook.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *WebhookMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *WebhookMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Webhook entity.
// If the Webhook object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebhookMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *WebhookMutation) ResetName() {
	m.name = nil
}

// SetURL sets the "url" field.
func (m *WebhookMutation) SetURL(s string) {
	m.url = &s
}

// URL returns the value of the "url" field in the mutation.
func (m *WebhookMutation) URL() (r string, exists bool) {
	v := m.url
	if v == nil {
		return
	}
	return *v, true
}

// OldURL returns the old "url" field's value of the Webhook entity.
// If the Webhook object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebhookMutation) OldURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldURL: %w", err)
	}
	return oldValue.URL, nil
}

// ResetURL resets all changes to the "url" field.
func (m *WebhookMutation) ResetURL() {
	m.url = nil
}

// SetAuthType sets the "auth_type" field.
func (m *WebhookMutation) SetAuthType(wt webhook.AuthType) {
	m.auth_type = &wt
}

// AuthType returns the value of the "auth_type" field in the mutation.
func (m *WebhookMutation) AuthType() (r webhook.AuthType, exists bool) {
	v := m.auth_type
	if v == nil {
		return
	}
	return *v, true
}

// OldAuthType returns the old "auth_type" field's value of the Webhook entity.
// If the Webhook object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebhookMutation) OldAuthType(ctx context.Context) (v webhook.AuthType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAuthType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAuthType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAuthType: %w", err)
	}
	return oldValue.AuthType, nil
}

// ResetAuthType resets all changes to the "auth_type" field.
func (m *WebhookMutation) ResetAuthType() {
	m.auth_type = nil
}

// SetAuthValueEncrypted sets the "auth_value_encrypted" field.
func (m *WebhookMutation) SetAuthValueEncrypted(b []byte) {
	m.auth_value_encrypted = &b
}

// AuthValueEncrypted returns the value of the "auth_value_encrypted" field in the mutation.
func (m *WebhookMutation) AuthValueEncrypted() (r []byte, exists bool) {
	v := m.auth_value_encrypted
	if v == nil {
		return
	}
	return *v, true
}

// OldAuthValueEncrypted returns the old "auth_value_encrypted" field's value of the Webhook entity.
// If the Webhook object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebhookMutation) OldAuthValueEncrypted(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAuthValueEncrypted is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAuthValueEncrypted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAuthValueEncrypted: %w", err)
	}
	return oldValue.AuthValueEncrypted, nil
}

// ClearAuthValueEncrypted clears the value of the "auth_value_encrypted" field.
func (m *WebhookMutation) ClearAuthValueEncrypted() {
	m.auth_value_encrypted = nil
	m.clearedFields[webhook.FieldAuthValueEncrypted] = struct{}{}
}

// AuthValueEncryptedCleared returns if the "auth_value_encrypted" field was cleared in this mutation.
func (m *WebhookMutation) AuthValueEncryptedCleared() bool {
	_, ok := m.clearedFields[webhook.FieldAuthValueEncrypted]
	return ok
}

// ResetAuthValueEncrypted resets all changes to the "auth_value_encrypted" field.
func (m *WebhookMutation) ResetAuthValueEncrypted() {
	m.auth_value_encrypted = nil
	delete(m.clearedFields, webhook.FieldAuthValueEncrypted)
}

// SetAuthNonce sets the "auth_nonce" field.
func (m *WebhookMutation) SetAuthNonce(b []byte) {
	m.auth_nonce = &b
}

// AuthNonce returns the value of the "auth_nonce" field in the mutation.
func (m *WebhookMutation) AuthNonce() (r []byte, exists bool) {
	v := m.auth_nonce
	if v == nil {
		return
	}
	return *v, true
}

// OldAuthNonce returns the old "auth_nonce" field's value of the Webhook entity.
// If the Webhook object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebhookMutation) OldAuthNonce(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAuthNonce is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAuthNonce requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAuthNonce: %w", err)
	}
	return oldValue.AuthNonce, nil
}

// ClearAuthNonce clears the value of the "auth_nonce" field.
func (m *WebhookMutation) ClearAuthNonce() {
	m.auth_nonce = nil
	m.clearedFields[webhook.FieldAuthNonce] = struct{}{}
}

// AuthNonceCleared returns if the "auth_nonce" field was cleared in this mutation.
func (m *WebhookMutation) AuthNonceCleared() bool {
	_, ok := m.clearedFields[webhook.FieldAuthNonce]
	return ok
}

// ResetAuthNonce resets all changes to the "auth_nonce" field.
func (m *WebhookMutation) ResetAuthNonce() {
	m.auth_nonce = nil
	delete(m.clearedFields, webhook.FieldAuthNonce)
}

// SetSigningSecretEncrypted sets the "signing_secret_encrypted" field.
func (m *WebhookMutation) SetSigningSecretEncrypted(b []byte) {
	m.signing_secret_encrypted = &b
}

// SigningSecretEncrypted returns the value of the "signing_secret_encrypted" field in the mutation.
func (m *WebhookMutation) SigningSecretEncrypted() (r []byte, exists bool) {
	v := m.signing_secret_encrypted
	if v == nil {
		return
	}
	return *v, true
}

// OldSigningSecretEncrypted returns the old "signing_secret_encrypted" field's value of the Webhook entity.
// If the Webhook object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebhookMutation) OldSigningSecretEncrypted(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSigningSecretEncrypted is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSigningSecretEncrypted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSigningSecretEncrypted: %w", err)
	}
	return oldValue.SigningSecretEncrypted, nil
}

// ClearSigningSecretEncrypted clears the value of the "signing_secret_encrypted" field.
func (m *WebhookMutation) ClearSigningSecretEncrypted() {
	m.signing_secret_encrypted = nil
	m.clearedFields[webhook.FieldSigningSecretEncrypted] = struct{}{}
}

// SigningSecretEncryptedCleared returns if the "signing_secret_encrypted" field was cleared in this mutation.
func (m *WebhookMutation) SigningSecretEncryptedCleared() bool {
	_, ok := m.clearedFields[webhook.FieldSigningSecretEncrypted]
	return ok
}

// ResetSigningSecretEncrypted resets all changes to the "signing_secret_encrypted" field.
func (m *WebhookMutation) ResetSigningSecretEncrypted() {
	m.signing_secret_encrypted = nil
	delete(m.clearedFields, webhook.FieldSigningSecretEncrypted)
}

// SetSigningNonce sets the "signing_nonce" field.
func (m *WebhookMutation) SetSigningNonce(b []byte) {
	m.signing_nonce = &b
}

// SigningNonce returns the value of the "signing_nonce" field in the mutation.
func (m *WebhookMutation) SigningNonce() (r []byte, exists bool) {
	v := m.signing_nonce
	if v == nil {
		return
	}
	return *v, true
}

// OldSigningNonce returns the old "signing_nonce" field's value of the Webhook entity.
// If the Webhook object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebhookMutation) OldSigningNonce(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSigningNonce is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSigningNonce requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSigningNonce: %w", err)
	}
	return oldValue.SigningNonce, nil
}

// ClearSigningNonce clears the value of the "signing_nonce" field.
func (m *WebhookMutation) ClearSigningNonce() {
	m.signing_nonce = nil
	m.clearedFields[webhook.FieldSigningNonce] = struct{}{}
}

// SigningNonceCleared returns if the "signing_nonce" field was cleared in this mutation.
func (m *WebhookMutation) SigningNonceCleared() bool {
	_, ok := m.clearedFields[webhook.FieldSigningNonce]
	return ok
}

// ResetSigningNonce resets all changes to the "signing_nonce" field.
func (m *WebhookMutation) ResetSigningNonce() {
	m.signing_nonce = nil
	delete(m.clearedFields, webhook.FieldSigningNonce)
}

// SetHeaders sets the "headers" field.
func (m *WebhookMutation) SetHeaders(value map[string]string) {
	m.headers = &value
}

// Headers returns the value of the "headers" field in the mutation.
func (m *WebhookMutation) Headers() (r map[string]string, exists bool) {
	v := m.headers
	if v == nil {
		return
	}
	return *v, true
}

// OldHeaders returns the old "headers" field's value of the Webhook entity.
// If the Webhook object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebhookMutation) OldHeaders(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHeaders is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHeaders requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHeaders: %w", err)
	}
	return oldValue.Headers, nil
}

// ClearHeaders clears the value of the "headers" field.
func (m *WebhookMutation) ClearHeaders() {
	m.headers = nil
	m.clearedFields[webhook.FieldHeaders] = struct{}{}
}

// HeadersCleared returns if the "headers" field was cleared in this mutation.
func (m *WebhookMutation) HeadersCleared() bool {
	_, ok := m.clearedFields[webhook.FieldHeaders]
	return ok
}

// ResetHeaders resets all changes to the "headers" field.
func (m *WebhookMutation) ResetHeaders() {
	m.headers = nil
	delete(m.clearedFields, webhook.FieldHeaders)
}

// SetTemplate sets the "template" field.
func (m *WebhookMutation) SetTemplate(w webhook.Template) {
	m.template = &w
}

// Template returns the value of the "template" field in the mutation.
func (m *WebhookMutation) Template() (r webhook.Template, exists bool) {
	v := m.template
	if v == nil {
		return
	}
	return *v, true
}

// OldTemplate returns the old "template" field's value of the Webhook entity.
// If the Webhook object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebhookMutation) OldTemplate(ctx context.Context) (v webhook.Template, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTemplate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTemplate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTemplate: %w", err)
	}
	return oldValue.Template, nil
}

// ResetTemplate resets all changes to the "template" field.
func (m *WebhookMutation) ResetTemplate() {
	m.template = nil
}

// SetCustomTemplate sets the "custom_template" field.
func (m *WebhookMutation) SetCustomTemplate(s string) {
	m.custom_template = &s
}

// CustomTemplate returns the value of the "custom_template" field in the mutation.
func (m *WebhookMutation) CustomTemplate() (r string, exists bool) {
	v := m.custom_template
	if v == nil {
		return
	}
	return *v, true
}

// OldCustomTemplate returns the old "custom_template" field's value of the Webhook entity.
// If the Webhook object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebhookMutation) OldCustomTemplate(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCustomTemplate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCustomTemplate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCustomTemplate: %w", err)
	}
	return oldValue.CustomTemplate, nil
}

// ClearCustomTemplate clears the value of the "custom_template" field.
func (m *WebhookMutation) ClearCustomTemplate() {
	m.custom_template = nil
	m.clearedFields[webhook.FieldCustomTemplate] = struct{}{}
}

// CustomTemplateCleared returns if the "custom_template" field was cleared in this mutation.
func (m *WebhookMutation) CustomTemplateCleared() bool {
	_, ok := m.clearedFields[webhook.FieldCustomTemplate]
	return ok
}

// ResetCustomTemplate resets all changes to the "custom_template" field.
func (m *WebhookMutation) ResetCustomTemplate() {
	m.custom_template = nil
	delete(m.clearedFields, webhook.FieldCustomTemplate)
}

// SetEnabled sets the "enabled" field.
func (m *WebhookMutation) SetEnabled(b bool) {
	m.enabled = &b
}

// Enabled returns the value of the "enabled" field in the mutation.
func (m *WebhookMutation) Enabled() (r bool, exists bool) {
	v := m.enabled
	if v == nil {
		return
	}
	return *v, true
}

// OldEnabled returns the old "enabled" field's value of the Webhook entity.
// If the Webhook object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebhookMutation) OldEnabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnabled: %w", err)
	}
	return oldValue.Enabled, nil
}

// ResetEnabled resets all changes to the "enabled" field.
func (m *WebhookMutation) ResetEnabled() {
	m.enabled = nil
}

// SetSuccessCount sets the "success_count" field.
func (m *WebhookMutation) SetSuccessCount(i int) {
	m.success_count = &i
	m.addsuccess_count = nil
}

// SuccessCount returns the value of the "success_count" field in the mutation.
func (m *WebhookMutation) SuccessCount() (r int, exists bool) {
	v := m.success_count
	if v == nil {
		return
	}
	return *v, true
}

// OldSuccessCount returns the old "success_count" field's value of the Webhook entity.
// If the Webhook object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebhookMutation) OldSuccessCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSuccessCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSuccessCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSuccessCount: %w", err)
	}
	return oldValue.SuccessCount, nil
}

// AddSuccessCount adds i to the "success_count" field.
func (m *WebhookMutation) AddSuccessCount(i int) {
	if m.addsuccess_count != nil {
		*m.addsuccess_count += i
	} else {
		m.addsuccess_count = &i
	}
}

// AddedSuccessCount returns the value that was added to the "success_count" field in this mutation.
func (m *WebhookMutation) AddedSuccessCount() (r int, exists bool) {
	v := m.addsuccess_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetSuccessCount resets all changes to the "success_count" field.
func (m *WebhookMutation) ResetSuccessCount() {
	m.success_count = nil
	m.addsuccess_count = nil
}

// SetFailureCount sets the "failure_count" field.
func (m *WebhookMutation) SetFailureCount(i int) {
	m.failure_count = &i
	m.addfailure_count = nil
}

// FailureCount returns the value of the "failure_count" field in the mutation.
func (m *WebhookMutation) FailureCount() (r int, exists bool) {
	v := m.failure_count
	if v == nil {
		return
	}
	return *v, true
}

// OldFailureCount returns the old "failure_count" field's value of the Webhook entity.
// If the Webhook object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebhookMutation) OldFailureCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFailureCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFailureCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFailureCount: %w", err)
	}
	return oldValue.FailureCount, nil
}

// AddFailureCount adds i to the "failure_count" field.
func (m *WebhookMutation) AddFailureCount(i int) {
	if m.addfailure_count != nil {
		*m.addfailure_count += i
	} else {
		m.addfailure_count = &i
	}
}

// AddedFailureCount returns the value that was added to the "failure_count" field in this mutation.
func (m *WebhookMutation) AddedFailureCount() (r int, exists bool) {
	v := m.addfailure_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetFailureCount resets all changes to the "failure_count" field.
func (m *WebhookMutation) ResetFailureCount() {
	m.failure_count = nil
	m.addfailure_count = nil
}

// SetLastSuccessAt sets the "last_success_at" field.
func (m *WebhookMutation) SetLastSuccessAt(t time.Time) {
	m.last_success_at = &t
}

// LastSuccessAt returns the value of the "last_success_at" field in the mutation.
func (m *WebhookMutation) LastSuccessAt() (r time.Time, exists bool) {
	v := m.last_success_at
	if v == nil {
		return
	}
	return *v, true
}

// OldLastSuccessAt returns the old "last_success_at" field's value of the Webhook entity.
// If the Webhook object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebhookMutation) OldLastSuccessAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastSuccessAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastSuccessAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastSuccessAt: %w", err)
	}
	return oldValue.LastSuccessAt, nil
}

// ClearLastSuccessAt clears the value of the "last_success_at" field.
func (m *WebhookMutation) ClearLastSuccessAt() {
	m.last_success_at = nil
	m.clearedFields[webhook.FieldLastSuccessAt] = struct{}{}
}

// LastSuccessAtCleared returns if the "last_success_at" field was cleared in this mutation.
func (m *WebhookMutation) LastSuccessAtCleared() bool {
	_, ok := m.clearedFields[webhook.FieldLastSuccessAt]
	return ok
}

// ResetLastSuccessAt resets all changes to the "last_success_at" field.
func (m *WebhookMutation) ResetLastSuccessAt() {
	m.last_success_at = nil
	delete(m.clearedFields, webhook.FieldLastSuccessAt)
}

// SetLastFailureAt sets the "last_failure_at" field.
func (m *WebhookMutation) SetLastFailureAt(t time.Time) {
	m.last_failure_at = &t
}

// LastFailureAt returns the value of the "last_failure_at" field in the mutation.
func (m *WebhookMutation) LastFailureAt() (r time.Time, exists bool) {
	v := m.last_failure_at
	if v == nil {
		return
	}
	return *v, true
}

// OldLastFailureAt returns the old "last_failure_at" field's value of the Webhook entity.
// If the Webhook object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebhookMutation) OldLastFailureAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastFailureAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastFailureAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastFailureAt: %w", err)
	}
	return oldValue.LastFailureAt, nil
}

// ClearLastFailureAt clears the value of the "last_failure_at" field.
func (m *WebhookMutation) ClearLastFailureAt() {
	m.last_failure_at = nil
	m.clearedFields[webhook.FieldLastFailureAt] = struct{}{}
}

// LastFailureAtCleared returns if the "last_failure_at" field was cleared in this mutation.
func (m *WebhookMutation) LastFailureAtCleared() bool {
	_, ok := m.clearedFields[webhook.FieldLastFailureAt]
	return ok
}

// ResetLastFailureAt resets all changes to the "last_failure_at" field.
func (m *WebhookMutation) ResetLastFailureAt() {
	m.last_failure_at = nil
	delete(m.clearedFields, webhook.FieldLastFailureAt)
}

// SetCreatedAt sets the "created_at" field.
func (m *WebhookMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *WebhookMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Webhook entity.
// If the Webhook object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebhookMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *WebhookMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *WebhookMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *WebhookMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Webhook entity.
// If the Webhook object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebhookMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *WebhookMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// AddLogIDs adds the "logs" edge to the NotificationLog entity by ids.
func (m *WebhookMutation) AddLogIDs(ids ...string) {
	if m.logs == nil {
		m.logs = make(map[string]struct{})
	}
	for i := range ids {
		m.logs[ids[i]] = struct{}{}
	}
}

// ClearLogs clears the "logs" edge to the NotificationLog entity.
func (m *WebhookMutation) ClearLogs() {
	m.clearedlogs = true
}

// LogsCleared reports if the "logs" edge to the NotificationLog entity was cleared.
func (m *WebhookMutation) LogsCleared() bool {
	return m.clearedlogs
}

// RemoveLogIDs removes the "logs" edge to the NotificationLog entity by IDs.
func (m *WebhookMutation) RemoveLogIDs(ids ...string) {
	if m.removedlogs == nil {
		m.removedlogs = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.logs, ids[i])
		m.removedlogs[ids[i]] = struct{}{}
	}
}

// RemovedLogs returns the removed IDs of the "logs" edge to the NotificationLog entity.
func (m *WebhookMutation) RemovedLogsIDs() (ids []string) {
	for id := range m.removedlogs {
		ids = append(ids, id)
	}
	return
}

// LogsIDs returns the "logs" edge IDs in the mutation.
func (m *WebhookMutation) LogsIDs() (ids []string) {
	for id := range m.logs {
		ids = append(ids, id)
	}
	return
}

// ResetLogs resets all changes to the "logs" edge.
func (m *WebhookMutation) ResetLogs() {
	m.logs = nil
	m.clearedlogs = false
	m.removedlogs = nil
}

// Where appends a list predicates to the WebhookMutation builder.
func (m *WebhookMutation) Where(ps ...predicate.Webhook) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the WebhookMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *WebhookMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Webhook, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *WebhookMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *WebhookMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Webhook).
func (m *WebhookMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *WebhookMutation) Fields() []string {
	fields := make([]string, 0, 17)
	if m.name != nil {
		fields = append(fields, webhook.FieldName)
	}
	if m.url != nil {
		fields = append(fields, webhook.FieldURL)
	}
	if m.auth_type != nil {
		fields = append(fields, webhook.FieldAuthType)
	}
	if m.auth_value_encrypted != nil {
		fields = append(fields, webhook.FieldAuthValueEncrypted)
	}
	if m.auth_nonce != nil {
		fields = append(fields, webhook.FieldAuthNonce)
	}
	if m.signing_secret_encrypted != nil {
		fields = append(fields, webhook.FieldSigningSecretEncrypted)
	}
	if m.signing_nonce != nil {
		fields = append(fields, webhook.FieldSigningNonce)
	}
	if m.headers != nil {
		fields = append(fields, webhook.FieldHeaders)
	}
	if m.template != nil {
		fields = append(fields, webhook.FieldTemplate)
	}
	if m.custom_template != nil {
		fields = append(fields, webhook.FieldCustomTemplate)
	}
	if m.enabled != nil {
		fields = append(fields, webhook.FieldEnabled)
	}
	if m.success_count != nil {
		fields = append(fields, webhook.FieldSuccessCount)
	}
	if m.failure_count != nil {
		fields = append(fields, webhook.FieldFailureCount)
	}
	if m.last_success_at != nil {
		fields = append(fields, webhook.FieldLastSuccessAt)
	}
	if m.last_failure_at != nil {
		fields = append(fields, webhook.FieldLastFailureAt)
	}
	if m.created_at != nil {
		fields = append(fields, webhook.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, webhook.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *WebhookMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case webhook.FieldName:
		return m.Name()
	case webhook.FieldURL:
		return m.URL()
	case webhook.FieldAuthType:
		return m.AuthType()
	case webhook.FieldAuthValueEncrypted:
		return m.AuthValueEncrypted()
	case webhook.FieldAuthNonce:
		return m.AuthNonce()
	case webhook.FieldSigningSecretEncrypted:
		return m.SigningSecretEncrypted()
	case webhook.FieldSigningNonce:
		return m.SigningNonce()
	case webhook.FieldHeaders:
		return m.Headers()
	case webhook.FieldTemplate:
		return m.Template()
	case webhook.FieldCustomTemplate:
		return m.CustomTemplate()
	case webhook.FieldEnabled:
		return m.Enabled()
	case webhook.FieldSuccessCount:
		return m.SuccessCount()
	case webhook.FieldFailureCount:
		return m.FailureCount()
	case webhook.FieldLastSuccessAt:
		return m.LastSuccessAt()
	case webhook.FieldLastFailureAt:
		return m.LastFailureAt()
	case webhook.FieldCreatedAt:
		return m.CreatedAt()
	case webhook.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *WebhookMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case webhook.FieldName:
		return m.OldName(ctx)
	case webhook.FieldURL:
		return m.OldURL(ctx)
	case webhook.FieldAuthType:
		return m.OldAuthType(ctx)
	case webhook.FieldAuthValueEncrypted:
		return m.OldAuthValueEncrypted(ctx)
	case webhook.FieldAuthNonce:
		return m.OldAuthNonce(ctx)
	case webhook.FieldSigningSecretEncrypted:
		return m.OldSigningSecretEncrypted(ctx)
	case webhook.FieldSigningNonce:
		return m.OldSigningNonce(ctx)
	case webhook.FieldHeaders:
		return m.OldHeaders(ctx)
	case webhook.FieldTemplate:
		return m.OldTemplate(ctx)
	case webhook.FieldCustomTemplate:
		return m.OldCustomTemplate(ctx)
	case webhook.FieldEnabled:
		return m.OldEnabled(ctx)
	case webhook.FieldSuccessCount:
		return m.OldSuccessCount(ctx)
	case webhook.FieldFailureCount:
		return m.OldFailureCount(ctx)
	case webhook.FieldLastSuccessAt:
		return m.OldLastSuccessAt(ctx)
	case webhook.FieldLastFailureAt:
		return m.OldLastFailureAt(ctx)
	case webhook.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case webhook.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Webhook field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WebhookMutation) SetField(name string, value ent.Value) error {
	switch name {
	case webhook.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case webhook.FieldURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetURL(v)
		return nil
	case webhook.FieldAuthType:
		v, ok := value.(webhook.AuthType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAuthType(v)
		return nil
	case webhook.FieldAuthValueEncrypted:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAuthValueEncrypted(v)
		return nil
	case webhook.FieldAuthNonce:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAuthNonce(v)
		return nil
	case webhook.FieldSigningSecretEncrypted:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSigningSecretEncrypted(v)
		return nil
	case webhook.FieldSigningNonce:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSigningNonce(v)
		return nil
	case webhook.FieldHeaders:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHeaders(v)
		return nil
	case webhook.FieldTemplate:
		v, ok := value.(webhook.Template)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTemplate(v)
		return nil
	case webhook.FieldCustomTemplate:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCustomTemplate(v)
		return nil
	case webhook.FieldEnabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnabled(v)
		return nil
	case webhook.FieldSuccessCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSuccessCount(v)
		return nil
	case webhook.FieldFailureCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFailureCount(v)
		return nil
	case webhook.FieldLastSuccessAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastSuccessAt(v)
		return nil
	case webhook.FieldLastFailureAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastFailureAt(v)
		return nil
	case webhook.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case webhook.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Webhook field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *WebhookMutation) AddedFields() []string {
	var fields []string
	if m.addsuccess_count != nil {
		fields = append(fields, webhook.FieldSuccessCount)
	}
	if m.addfailure_count != nil {
		fields = append(fields, webhook.FieldFailureCount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *WebhookMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case webhook.FieldSuccessCount:
		return m.AddedSuccessCount()
	case webhook.FieldFailureCount:
		return m.AddedFailureCount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WebhookMutation) AddField(name string, value ent.Value) error {
	switch name {
	case webhook.FieldSuccessCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSuccessCount(v)
		return nil
	case webhook.FieldFailureCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFailureCount(v)
		return nil
	}
	return fmt.Errorf("unknown Webhook numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *WebhookMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(webhook.FieldAuthValueEncrypted) {
		fields = append(fields, webhook.FieldAuthValueEncrypted)
	}
	if m.FieldCleared(webhook.FieldAuthNonce) {
		fields = append(fields, webhook.FieldAuthNonce)
	}
	if m.FieldCleared(webhook.FieldSigningSecretEncrypted) {
		fields = append(fields, webhook.FieldSigningSecretEncrypted)
	}
	if m.FieldCleared(webhook.FieldSigningNonce) {
		fields = append(fields, webhook.FieldSigningNonce)
	}
	if m.FieldCleared(webhook.FieldHeaders) {
		fields = append(fields, webhook.FieldHeaders)
	}
	if m.FieldCleared(webhook.FieldCustomTemplate) {
		fields = append(fields, webhook.FieldCustomTemplate)
	}
	if m.FieldCleared(webhook.FieldLastSuccessAt) {
		fields = append(fields, webhook.FieldLastSuccessAt)
	}
	if m.FieldCleared(webhook.FieldLastFailureAt) {
		fields = append(fields, webhook.FieldLastFailureAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *WebhookMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *WebhookMutation) ClearField(name string) error {
	switch name {
	case webhook.FieldAuthValueEncrypted:
		m.ClearAuthValueEncrypted()
		return nil
	case webhook.FieldAuthNonce:
		m.ClearAuthNonce()
		return nil
	case webhook.FieldSigningSecretEncrypted:
		m.ClearSigningSecretEncrypted()
		return nil
	case webhook.FieldSigningNonce:
		m.ClearSigningNonce()
		return nil
	case webhook.FieldHeaders:
		m.ClearHeaders()
		return nil
	case webhook.FieldCustomTemplate:
		m.ClearCustomTemplate()
		return nil
	case webhook.FieldLastSuccessAt:
		m.ClearLastSuccessAt()
		return nil
	case webhook.FieldLastFailureAt:
		m.ClearLastFailureAt()
		return nil
	}
	return fmt.Errorf("unknown Webhook nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *WebhookMutation) ResetField(name string) error {
	switch name {
	case webhook.FieldName:
		m.ResetName()
		return nil
	case webhook.FieldURL:
		m.ResetURL()
		return nil
	case webhook.FieldAuthType:
		m.ResetAuthType()
		return nil
	case webhook.FieldAuthValueEncrypted:
		m.ResetAuthValueEncrypted()
		return nil
	case webhook.FieldAuthNonce:
		m.ResetAuthNonce()
		return nil
	case webhook.FieldSigningSecretEncrypted:
		m.ResetSigningSecretEncrypted()
		return nil
	case webhook.FieldSigningNonce:
		m.ResetSigningNonce()
		return nil
	case webhook.FieldHeaders:
		m.ResetHeaders()
		return nil
	case webhook.FieldTemplate:
		m.ResetTemplate()
		return nil
	case webhook.FieldCustomTemplate:
		m.ResetCustomTemplate()
		return nil
	case webhook.FieldEnabled:
		m.ResetEnabled()
		return nil
	case webhook.FieldSuccessCount:
		m.ResetSuccessCount()
		return nil
	case webhook.FieldFailureCount:
		m.ResetFailureCount()
		return nil
	case webhook.FieldLastSuccessAt:
		m.ResetLastSuccessAt()
		return nil
	case webhook.FieldLastFailureAt:
		m.ResetLastFailureAt()
		return nil
	case webhook.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case webhook.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Webhook field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *WebhookMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.logs != nil {
		edges = append(edges, webhook.EdgeLogs)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *WebhookMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case webhook.EdgeLogs:
		ids := make([]ent.Value, 0, len(m.logs))
		for id := range m.logs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *WebhookMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedlogs != nil {
		edges = append(edges, webhook.EdgeLogs)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *WebhookMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case webhook.EdgeLogs:
		ids := make([]ent.Value, 0, len(m.removedlogs))
		for id := range m.removedlogs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *WebhookMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedlogs {
		edges = append(edges, webhook.EdgeLogs)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *WebhookMutation) EdgeCleared(name string) bool {
	switch name {
	case webhook.EdgeLogs:
		return m.clearedlogs
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *WebhookMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Webhook unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *WebhookMutation) ResetEdge(name string) error {
	switch name {
	case webhook.EdgeLogs:
		m.ResetLogs()
		return nil
	}
	return fmt.Errorf("unknown Webhook edge %s", name)
}
