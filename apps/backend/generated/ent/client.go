// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"log"
	"reflect"

	"backend/generated/ent/migrate"

	"backend/generated/ent/alert"
	"backend/generated/ent/alertdigestentry"
	"backend/generated/ent/alertescalation"
	"backend/generated/ent/alertrule"
	"backend/generated/ent/alertruletemplate"
	"backend/generated/ent/alerttemplate"
	"backend/generated/ent/apikey"
	"backend/generated/ent/chainhop"
	"backend/generated/ent/configsnapshot"
	"backend/generated/ent/devicerouting"
	"backend/generated/ent/diagnosticresult"
	"backend/generated/ent/globalsettings"
	"backend/generated/ent/notificationchannelconfig"
	"backend/generated/ent/notificationlog"
	"backend/generated/ent/notificationsettings"
	"backend/generated/ent/portallocation"
	"backend/generated/ent/portknocksequence"
	"backend/generated/ent/provisioningsession"
	"backend/generated/ent/resource"
	"backend/generated/ent/resourceevent"
	"backend/generated/ent/router"
	"backend/generated/ent/routercapability"
	"backend/generated/ent/routersecret"
	"backend/generated/ent/routingchain"
	"backend/generated/ent/routingschedule"
	"backend/generated/ent/servicedependency"
	"backend/generated/ent/serviceinstance"
	"backend/generated/ent/servicetemplate"
	"backend/generated/ent/servicetraffichourly"
	"backend/generated/ent/session"
	"backend/generated/ent/subnetallocation"
	"backend/generated/ent/user"
	"backend/generated/ent/version"
	"backend/generated/ent/virtualinterface"
	"backend/generated/ent/vlanallocation"
	"backend/generated/ent/webhook"

	"entgo.io/ent"
	"entgo.io/ent/dialect"
	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"github.com/google/uuid"

	"backend/generated/ent/internal"
	stdsql "database/sql"
)

// Client is the client that holds all ent builders.
type Client struct {
	config
	// Schema is the client for creating, migrating and dropping schema.
	Schema *migrate.Schema
	// APIKey is the client for interacting with the APIKey builders.
	APIKey *APIKeyClient
	// Alert is the client for interacting with the Alert builders.
	Alert *AlertClient
	// AlertDigestEntry is the client for interacting with the AlertDigestEntry builders.
	AlertDigestEntry *AlertDigestEntryClient
	// AlertEscalation is the client for interacting with the AlertEscalation builders.
	AlertEscalation *AlertEscalationClient
	// AlertRule is the client for interacting with the AlertRule builders.
	AlertRule *AlertRuleClient
	// AlertRuleTemplate is the client for interacting with the AlertRuleTemplate builders.
	AlertRuleTemplate *AlertRuleTemplateClient
	// AlertTemplate is the client for interacting with the AlertTemplate builders.
	AlertTemplate *AlertTemplateClient
	// ChainHop is the client for interacting with the ChainHop builders.
	ChainHop *ChainHopClient
	// ConfigSnapshot is the client for interacting with the ConfigSnapshot builders.
	ConfigSnapshot *ConfigSnapshotClient
	// DeviceRouting is the client for interacting with the DeviceRouting builders.
	DeviceRouting *DeviceRoutingClient
	// DiagnosticResult is the client for interacting with the DiagnosticResult builders.
	DiagnosticResult *DiagnosticResultClient
	// GlobalSettings is the client for interacting with the GlobalSettings builders.
	GlobalSettings *GlobalSettingsClient
	// NotificationChannelConfig is the client for interacting with the NotificationChannelConfig builders.
	NotificationChannelConfig *NotificationChannelConfigClient
	// NotificationLog is the client for interacting with the NotificationLog builders.
	NotificationLog *NotificationLogClient
	// NotificationSettings is the client for interacting with the NotificationSettings builders.
	NotificationSettings *NotificationSettingsClient
	// PortAllocation is the client for interacting with the PortAllocation builders.
	PortAllocation *PortAllocationClient
	// PortKnockSequence is the client for interacting with the PortKnockSequence builders.
	PortKnockSequence *PortKnockSequenceClient
	// ProvisioningSession is the client for interacting with the ProvisioningSession builders.
	ProvisioningSession *ProvisioningSessionClient
	// Resource is the client for interacting with the Resource builders.
	Resource *ResourceClient
	// ResourceEvent is the client for interacting with the ResourceEvent builders.
	ResourceEvent *ResourceEventClient
	// Router is the client for interacting with the Router builders.
	Router *RouterClient
	// RouterCapability is the client for interacting with the RouterCapability builders.
	RouterCapability *RouterCapabilityClient
	// RouterSecret is the client for interacting with the RouterSecret builders.
	RouterSecret *RouterSecretClient
	// RoutingChain is the client for interacting with the RoutingChain builders.
	RoutingChain *RoutingChainClient
	// RoutingSchedule is the client for interacting with the RoutingSchedule builders.
	RoutingSchedule *RoutingScheduleClient
	// ServiceDependency is the client for interacting with the ServiceDependency builders.
	ServiceDependency *ServiceDependencyClient
	// ServiceInstance is the client for interacting with the ServiceInstance builders.
	ServiceInstance *ServiceInstanceClient
	// ServiceTemplate is the client for interacting with the ServiceTemplate builders.
	ServiceTemplate *ServiceTemplateClient
	// ServiceTrafficHourly is the client for interacting with the ServiceTrafficHourly builders.
	ServiceTrafficHourly *ServiceTrafficHourlyClient
	// Session is the client for interacting with the Session builders.
	Session *SessionClient
	// SubnetAllocation is the client for interacting with the SubnetAllocation builders.
	SubnetAllocation *SubnetAllocationClient
	// User is the client for interacting with the User builders.
	User *UserClient
	// VLANAllocation is the client for interacting with the VLANAllocation builders.
	VLANAllocation *VLANAllocationClient
	// Version is the client for interacting with the Version builders.
	Version *VersionClient
	// VirtualInterface is the client for interacting with the VirtualInterface builders.
	VirtualInterface *VirtualInterfaceClient
	// Webhook is the client for interacting with the Webhook builders.
	Webhook *WebhookClient
}

// NewClient creates a new client configured with the given options.
func NewClient(opts ...Option) *Client {
	client := &Client{config: newConfig(opts...)}
	client.init()
	return client
}

func (c *Client) init() {
	c.Schema = migrate.NewSchema(c.driver)
	c.APIKey = NewAPIKeyClient(c.config)
	c.Alert = NewAlertClient(c.config)
	c.AlertDigestEntry = NewAlertDigestEntryClient(c.config)
	c.AlertEscalation = NewAlertEscalationClient(c.config)
	c.AlertRule = NewAlertRuleClient(c.config)
	c.AlertRuleTemplate = NewAlertRuleTemplateClient(c.config)
	c.AlertTemplate = NewAlertTemplateClient(c.config)
	c.ChainHop = NewChainHopClient(c.config)
	c.ConfigSnapshot = NewConfigSnapshotClient(c.config)
	c.DeviceRouting = NewDeviceRoutingClient(c.config)
	c.DiagnosticResult = NewDiagnosticResultClient(c.config)
	c.GlobalSettings = NewGlobalSettingsClient(c.config)
	c.NotificationChannelConfig = NewNotificationChannelConfigClient(c.config)
	c.NotificationLog = NewNotificationLogClient(c.config)
	c.NotificationSettings = NewNotificationSettingsClient(c.config)
	c.PortAllocation = NewPortAllocationClient(c.config)
	c.PortKnockSequence = NewPortKnockSequenceClient(c.config)
	c.ProvisioningSession = NewProvisioningSessionClient(c.config)
	c.Resource = NewResourceClient(c.config)
	c.ResourceEvent = NewResourceEventClient(c.config)
	c.Router = NewRouterClient(c.config)
	c.RouterCapability = NewRouterCapabilityClient(c.config)
	c.RouterSecret = NewRouterSecretClient(c.config)
	c.RoutingChain = NewRoutingChainClient(c.config)
	c.RoutingSchedule = NewRoutingScheduleClient(c.config)
	c.ServiceDependency = NewServiceDependencyClient(c.config)
	c.ServiceInstance = NewServiceInstanceClient(c.config)
	c.ServiceTemplate = NewServiceTemplateClient(c.config)
	c.ServiceTrafficHourly = NewServiceTrafficHourlyClient(c.config)
	c.Session = NewSessionClient(c.config)
	c.SubnetAllocation = NewSubnetAllocationClient(c.config)
	c.User = NewUserClient(c.config)
	c.VLANAllocation = NewVLANAllocationClient(c.config)
	c.Version = NewVersionClient(c.config)
	c.VirtualInterface = NewVirtualInterfaceClient(c.config)
	c.Webhook = NewWebhookClient(c.config)
}

type (
	// config is the configuration for the client and its builder.
	config struct {
		// driver used for executing database requests.
		driver dialect.Driver
		// debug enable a debug logging.
		debug bool
		// log used for logging on debug mode.
		log func(...any)
		// hooks to execute on mutations.
		hooks *hooks
		// interceptors to execute on queries.
		inters *inters
		// schemaConfig contains alternative names for all tables.
		schemaConfig SchemaConfig
	}
	// Option function to configure the client.
	Option func(*config)
)

// newConfig creates a new config for the client.
func newConfig(opts ...Option) config {
	cfg := config{log: log.Println, hooks: &hooks{}, inters: &inters{}}
	cfg.options(opts...)
	return cfg
}

// options applies the options on the config object.
func (c *config) options(opts ...Option) {
	for _, opt := range opts {
		opt(c)
	}
	if c.debug {
		c.driver = dialect.Debug(c.driver, c.log)
	}
}

// Debug enables debug logging on the ent.Driver.
func Debug() Option {
	return func(c *config) {
		c.debug = true
	}
}

// Log sets the logging function for debug mode.
func Log(fn func(...any)) Option {
	return func(c *config) {
		c.log = fn
	}
}

// Driver configures the client driver.
func Driver(driver dialect.Driver) Option {
	return func(c *config) {
		c.driver = driver
	}
}

// Open opens a database/sql.DB specified by the driver name and
// the data source name, and returns a new client attached to it.
// Optional parameters can be added for configuring the client.
func Open(driverName, dataSourceName string, options ...Option) (*Client, error) {
	switch driverName {
	case dialect.MySQL, dialect.Postgres, dialect.SQLite:
		drv, err := sql.Open(driverName, dataSourceName)
		if err != nil {
			return nil, err
		}
		return NewClient(append(options, Driver(drv))...), nil
	default:
		return nil, fmt.Errorf("unsupported driver: %q", driverName)
	}
}

// ErrTxStarted is returned when trying to start a new transaction from a transactional client.
var ErrTxStarted = errors.New("ent: cannot start a transaction within a transaction")

// Tx returns a new transactional client. The provided context
// is used until the transaction is committed or rolled back.
func (c *Client) Tx(ctx context.Context) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, ErrTxStarted
	}
	tx, err := newTx(ctx, c.driver)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = tx
	return &Tx{
		ctx:                       ctx,
		config:                    cfg,
		APIKey:                    NewAPIKeyClient(cfg),
		Alert:                     NewAlertClient(cfg),
		AlertDigestEntry:          NewAlertDigestEntryClient(cfg),
		AlertEscalation:           NewAlertEscalationClient(cfg),
		AlertRule:                 NewAlertRuleClient(cfg),
		AlertRuleTemplate:         NewAlertRuleTemplateClient(cfg),
		AlertTemplate:             NewAlertTemplateClient(cfg),
		ChainHop:                  NewChainHopClient(cfg),
		ConfigSnapshot:            NewConfigSnapshotClient(cfg),
		DeviceRouting:             NewDeviceRoutingClient(cfg),
		DiagnosticResult:          NewDiagnosticResultClient(cfg),
		GlobalSettings:            NewGlobalSettingsClient(cfg),
		NotificationChannelConfig: NewNotificationChannelConfigClient(cfg),
		NotificationLog:           NewNotificationLogClient(cfg),
		NotificationSettings:      NewNotificationSettingsClient(cfg),
		PortAllocation:            NewPortAllocationClient(cfg),
		PortKnockSequence:         NewPortKnockSequenceClient(cfg),
		ProvisioningSession:       NewProvisioningSessionClient(cfg),
		Resource:                  NewResourceClient(cfg),
		ResourceEvent:             NewResourceEventClient(cfg),
		Router:                    NewRouterClient(cfg),
		RouterCapability:          NewRouterCapabilityClient(cfg),
		RouterSecret:              NewRouterSecretClient(cfg),
		RoutingChain:              NewRoutingChainClient(cfg),
		RoutingSchedule:           NewRoutingScheduleClient(cfg),
		ServiceDependency:         NewServiceDependencyClient(cfg),
		ServiceInstance:           NewServiceInstanceClient(cfg),
		ServiceTemplate:           NewServiceTemplateClient(cfg),
		ServiceTrafficHourly:      NewServiceTrafficHourlyClient(cfg),
		Session:                   NewSessionClient(cfg),
		SubnetAllocation:          NewSubnetAllocationClient(cfg),
		User:                      NewUserClient(cfg),
		VLANAllocation:            NewVLANAllocationClient(cfg),
		Version:                   NewVersionClient(cfg),
		VirtualInterface:          NewVirtualInterfaceClient(cfg),
		Webhook:                   NewWebhookClient(cfg),
	}, nil
}

// BeginTx returns a transactional client with specified options.
func (c *Client) BeginTx(ctx context.Context, opts *sql.TxOptions) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, errors.New("ent: cannot start a transaction within a transaction")
	}
	tx, err := c.driver.(interface {
		BeginTx(context.Context, *sql.TxOptions) (dialect.Tx, error)
	}).BeginTx(ctx, opts)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = &txDriver{tx: tx, drv: c.driver}
	return &Tx{
		ctx:                       ctx,
		config:                    cfg,
		APIKey:                    NewAPIKeyClient(cfg),
		Alert:                     NewAlertClient(cfg),
		AlertDigestEntry:          NewAlertDigestEntryClient(cfg),
		AlertEscalation:           NewAlertEscalationClient(cfg),
		AlertRule:                 NewAlertRuleClient(cfg),
		AlertRuleTemplate:         NewAlertRuleTemplateClient(cfg),
		AlertTemplate:             NewAlertTemplateClient(cfg),
		ChainHop:                  NewChainHopClient(cfg),
		ConfigSnapshot:            NewConfigSnapshotClient(cfg),
		DeviceRouting:             NewDeviceRoutingClient(cfg),
		DiagnosticResult:          NewDiagnosticResultClient(cfg),
		GlobalSettings:            NewGlobalSettingsClient(cfg),
		NotificationChannelConfig: NewNotificationChannelConfigClient(cfg),
		NotificationLog:           NewNotificationLogClient(cfg),
		NotificationSettings:      NewNotificationSettingsClient(cfg),
		PortAllocation:            NewPortAllocationClient(cfg),
		PortKnockSequence:         NewPortKnockSequenceClient(cfg),
		ProvisioningSession:       NewProvisioningSessionClient(cfg),
		Resource:                  NewResourceClient(cfg),
		ResourceEvent:             NewResourceEventClient(cfg),
		Router:                    NewRouterClient(cfg),
		RouterCapability:          NewRouterCapabilityClient(cfg),
		RouterSecret:              NewRouterSecretClient(cfg),
		RoutingChain:              NewRoutingChainClient(cfg),
		RoutingSchedule:           NewRoutingScheduleClient(cfg),
		ServiceDependency:         NewServiceDependencyClient(cfg),
		ServiceInstance:           NewServiceInstanceClient(cfg),
		ServiceTemplate:           NewServiceTemplateClient(cfg),
		ServiceTrafficHourly:      NewServiceTrafficHourlyClient(cfg),
		Session:                   NewSessionClient(cfg),
		SubnetAllocation:          NewSubnetAllocationClient(cfg),
		User:                      NewUserClient(cfg),
		VLANAllocation:            NewVLANAllocationClient(cfg),
		Version:                   NewVersionClient(cfg),
		VirtualInterface:          NewVirtualInterfaceClient(cfg),
		Webhook:                   NewWebhookClient(cfg),
	}, nil
}

// Debug returns a new debug-client. It's used to get verbose logging on specific operations.
//
//	client.Debug().
//		APIKey.
//		Query().
//		Count(ctx)
func (c *Client) Debug() *Client {
	if c.debug {
		return c
	}
	cfg := c.config
	cfg.driver = dialect.Debug(c.driver, c.log)
	client := &Client{config: cfg}
	client.init()
	return client
}

// Close closes the database connection and prevents new queries from starting.
func (c *Client) Close() error {
	return c.driver.Close()
}

// Use adds the mutation hooks to all the entity clients.
// In order to add hooks to a specific client, call: `client.Node.Use(...)`.
func (c *Client) Use(hooks ...Hook) {
	for _, n := range []interface{ Use(...Hook) }{
		c.APIKey, c.Alert, c.AlertDigestEntry, c.AlertEscalation, c.AlertRule,
		c.AlertRuleTemplate, c.AlertTemplate, c.ChainHop, c.ConfigSnapshot,
		c.DeviceRouting, c.DiagnosticResult, c.GlobalSettings,
		c.NotificationChannelConfig, c.NotificationLog, c.NotificationSettings,
		c.PortAllocation, c.PortKnockSequence, c.ProvisioningSession, c.Resource,
		c.ResourceEvent, c.Router, c.RouterCapability, c.RouterSecret, c.RoutingChain,
		c.RoutingSchedule, c.ServiceDependency, c.ServiceInstance, c.ServiceTemplate,
		c.ServiceTrafficHourly, c.Session, c.SubnetAllocation, c.User,
		c.VLANAllocation, c.Version, c.VirtualInterface, c.Webhook,
	} {
		n.Use(hooks...)
	}
}

// Intercept adds the query interceptors to all the entity clients.
// In order to add interceptors to a specific client, call: `client.Node.Intercept(...)`.
func (c *Client) Intercept(interceptors ...Interceptor) {
	for _, n := range []interface{ Intercept(...Interceptor) }{
		c.APIKey, c.Alert, c.AlertDigestEntry, c.AlertEscalation, c.AlertRule,
		c.AlertRuleTemplate, c.AlertTemplate, c.ChainHop, c.ConfigSnapshot,
		c.DeviceRouting, c.DiagnosticResult, c.GlobalSettings,
		c.NotificationChannelConfig, c.NotificationLog, c.NotificationSettings,
		c.PortAllocation, c.PortKnockSequence, c.ProvisioningSession, c.Resource,
		c.ResourceEvent, c.Router, c.RouterCapability, c.RouterSecret, c.RoutingChain,
		c.RoutingSchedule, c.ServiceDependency, c.ServiceInstance, c.ServiceTemplate,
		c.ServiceTrafficHourly, c.Session, c.SubnetAllocation, c.User,
		c.VLANAllocation, c.Version, c.VirtualInterface, c.Webhook,
	} {
		n.Intercept(interceptors...)
	}
}

// Mutate implements the ent.Mutator interface.
func (c *Client) Mutate(ctx context.Context, m Mutation) (Value, error) {
	switch m := m.(type) {
	case *APIKeyMutation:
		return c.APIKey.mutate(ctx, m)
	case *AlertMutation:
		return c.Alert.mutate(ctx, m)
	case *AlertDigestEntryMutation:
		return c.AlertDigestEntry.mutate(ctx, m)
	case *AlertEscalationMutation:
		return c.AlertEscalation.mutate(ctx, m)
	case *AlertRuleMutation:
		return c.AlertRule.mutate(ctx, m)
	case *AlertRuleTemplateMutation:
		return c.AlertRuleTemplate.mutate(ctx, m)
	case *AlertTemplateMutation:
		return c.AlertTemplate.mutate(ctx, m)
	case *ChainHopMutation:
		return c.ChainHop.mutate(ctx, m)
	case *ConfigSnapshotMutation:
		return c.ConfigSnapshot.mutate(ctx, m)
	case *DeviceRoutingMutation:
		return c.DeviceRouting.mutate(ctx, m)
	case *DiagnosticResultMutation:
		return c.DiagnosticResult.mutate(ctx, m)
	case *GlobalSettingsMutation:
		return c.GlobalSettings.mutate(ctx, m)
	case *NotificationChannelConfigMutation:
		return c.NotificationChannelConfig.mutate(ctx, m)
	case *NotificationLogMutation:
		return c.NotificationLog.mutate(ctx, m)
	case *NotificationSettingsMutation:
		return c.NotificationSettings.mutate(ctx, m)
	case *PortAllocationMutation:
		return c.PortAllocation.mutate(ctx, m)
	case *PortKnockSequenceMutation:
		return c.PortKnockSequence.mutate(ctx, m)
	case *ProvisioningSessionMutation:
		return c.ProvisioningSession.mutate(ctx, m)
	case *ResourceMutation:
		return c.Resource.mutate(ctx, m)
	case *ResourceEventMutation:
		return c.ResourceEvent.mutate(ctx, m)
	case *RouterMutation:
		return c.Router.mutate(ctx, m)
	case *RouterCapabilityMutation:
		return c.RouterCapability.mutate(ctx, m)
	case *RouterSecretMutation:
		return c.RouterSecret.mutate(ctx, m)
	case *RoutingChainMutation:
		return c.RoutingChain.mutate(ctx, m)
	case *RoutingScheduleMutation:
		return c.RoutingSchedule.mutate(ctx, m)
	case *ServiceDependencyMutation:
		return c.ServiceDependency.mutate(ctx, m)
	case *ServiceInstanceMutation:
		return c.ServiceInstance.mutate(ctx, m)
	case *ServiceTemplateMutation:
		return c.ServiceTemplate.mutate(ctx, m)
	case *ServiceTrafficHourlyMutation:
		return c.ServiceTrafficHourly.mutate(ctx, m)
	case *SessionMutation:
		return c.Session.mutate(ctx, m)
	case *SubnetAllocationMutation:
		return c.SubnetAllocation.mutate(ctx, m)
	case *UserMutation:
		return c.User.mutate(ctx, m)
	case *VLANAllocationMutation:
		return c.VLANAllocation.mutate(ctx, m)
	case *VersionMutation:
		return c.Version.mutate(ctx, m)
	case *VirtualInterfaceMutation:
		return c.VirtualInterface.mutate(ctx, m)
	case *WebhookMutation:
		return c.Webhook.mutate(ctx, m)
	default:
		return nil, fmt.Errorf("ent: unknown mutation type %T", m)
	}
}

// APIKeyClient is a client for the APIKey schema.
type APIKeyClient struct {
	config
}

// NewAPIKeyClient returns a client for the APIKey from the given config.
func NewAPIKeyClient(c config) *APIKeyClient {
	return &APIKeyClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `apikey.Hooks(f(g(h())))`.
func (c *APIKeyClient) Use(hooks ...Hook) {
	c.hooks.APIKey = append(c.hooks.APIKey, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `apikey.Intercept(f(g(h())))`.
func (c *APIKeyClient) Intercept(interceptors ...Interceptor) {
	c.inters.APIKey = append(c.inters.APIKey, interceptors...)
}

// Create returns a builder for creating a APIKey entity.
func (c *APIKeyClient) Create() *APIKeyCreate {
	mutation := newAPIKeyMutation(c.config, OpCreate)
	return &APIKeyCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of APIKey entities.
func (c *APIKeyClient) CreateBulk(builders ...*APIKeyCreate) *APIKeyCreateBulk {
	return &APIKeyCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *APIKeyClient) MapCreateBulk(slice any, setFunc func(*APIKeyCreate, int)) *APIKeyCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &APIKeyCreateBulk{err: fmt.Errorf("calling to APIKeyClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*APIKeyCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &APIKeyCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for APIKey.
func (c *APIKeyClient) Update() *APIKeyUpdate {
	mutation := newAPIKeyMutation(c.config, OpUpdate)
	return &APIKeyUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *APIKeyClient) UpdateOne(_m *APIKey) *APIKeyUpdateOne {
	mutation := newAPIKeyMutation(c.config, OpUpdateOne, withAPIKey(_m))
	return &APIKeyUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *APIKeyClient) UpdateOneID(id string) *APIKeyUpdateOne {
	mutation := newAPIKeyMutation(c.config, OpUpdateOne, withAPIKeyID(id))
	return &APIKeyUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for APIKey.
func (c *APIKeyClient) Delete() *APIKeyDelete {
	mutation := newAPIKeyMutation(c.config, OpDelete)
	return &APIKeyDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *APIKeyClient) DeleteOne(_m *APIKey) *APIKeyDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *APIKeyClient) DeleteOneID(id string) *APIKeyDeleteOne {
	builder := c.Delete().Where(apikey.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &APIKeyDeleteOne{builder}
}

// Query returns a query builder for APIKey.
func (c *APIKeyClient) Query() *APIKeyQuery {
	return &APIKeyQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeAPIKey},
		inters: c.Interceptors(),
	}
}

// Get returns a APIKey entity by its id.
func (c *APIKeyClient) Get(ctx context.Context, id string) (*APIKey, error) {
	return c.Query().Where(apikey.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *APIKeyClient) GetX(ctx context.Context, id string) *APIKey {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a APIKey.
func (c *APIKeyClient) QueryUser(_m *APIKey) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(apikey.Table, apikey.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, apikey.UserTable, apikey.UserColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.User
		step.Edge.Schema = schemaConfig.APIKey
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *APIKeyClient) Hooks() []Hook {
	return c.hooks.APIKey
}

// Interceptors returns the client interceptors.
func (c *APIKeyClient) Interceptors() []Interceptor {
	return c.inters.APIKey
}

func (c *APIKeyClient) mutate(ctx context.Context, m *APIKeyMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&APIKeyCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&APIKeyUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&APIKeyUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&APIKeyDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown APIKey mutation op: %q", m.Op())
	}
}

// AlertClient is a client for the Alert schema.
type AlertClient struct {
	config
}

// NewAlertClient returns a client for the Alert from the given config.
func NewAlertClient(c config) *AlertClient {
	return &AlertClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `alert.Hooks(f(g(h())))`.
func (c *AlertClient) Use(hooks ...Hook) {
	c.hooks.Alert = append(c.hooks.Alert, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `alert.Intercept(f(g(h())))`.
func (c *AlertClient) Intercept(interceptors ...Interceptor) {
	c.inters.Alert = append(c.inters.Alert, interceptors...)
}

// Create returns a builder for creating a Alert entity.
func (c *AlertClient) Create() *AlertCreate {
	mutation := newAlertMutation(c.config, OpCreate)
	return &AlertCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Alert entities.
func (c *AlertClient) CreateBulk(builders ...*AlertCreate) *AlertCreateBulk {
	return &AlertCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *AlertClient) MapCreateBulk(slice any, setFunc func(*AlertCreate, int)) *AlertCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &AlertCreateBulk{err: fmt.Errorf("calling to AlertClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*AlertCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &AlertCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Alert.
func (c *AlertClient) Update() *AlertUpdate {
	mutation := newAlertMutation(c.config, OpUpdate)
	return &AlertUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AlertClient) UpdateOne(_m *Alert) *AlertUpdateOne {
	mutation := newAlertMutation(c.config, OpUpdateOne, withAlert(_m))
	return &AlertUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AlertClient) UpdateOneID(id string) *AlertUpdateOne {
	mutation := newAlertMutation(c.config, OpUpdateOne, withAlertID(id))
	return &AlertUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Alert.
func (c *AlertClient) Delete() *AlertDelete {
	mutation := newAlertMutation(c.config, OpDelete)
	return &AlertDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *AlertClient) DeleteOne(_m *Alert) *AlertDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *AlertClient) DeleteOneID(id string) *AlertDeleteOne {
	builder := c.Delete().Where(alert.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AlertDeleteOne{builder}
}

// Query returns a query builder for Alert.
func (c *AlertClient) Query() *AlertQuery {
	return &AlertQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeAlert},
		inters: c.Interceptors(),
	}
}

// Get returns a Alert entity by its id.
func (c *AlertClient) Get(ctx context.Context, id string) (*Alert, error) {
	return c.Query().Where(alert.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AlertClient) GetX(ctx context.Context, id string) *Alert {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryRule queries the rule edge of a Alert.
func (c *AlertClient) QueryRule(_m *Alert) *AlertRuleQuery {
	query := (&AlertRuleClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(alert.Table, alert.FieldID, id),
			sqlgraph.To(alertrule.Table, alertrule.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, alert.RuleTable, alert.RuleColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.AlertRule
		step.Edge.Schema = schemaConfig.Alert
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEscalations queries the escalations edge of a Alert.
func (c *AlertClient) QueryEscalations(_m *Alert) *AlertEscalationQuery {
	query := (&AlertEscalationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(alert.Table, alert.FieldID, id),
			sqlgraph.To(alertescalation.Table, alertescalation.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, alert.EscalationsTable, alert.EscalationsColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.AlertEscalation
		step.Edge.Schema = schemaConfig.AlertEscalation
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryNotificationLogs queries the notification_logs edge of a Alert.
func (c *AlertClient) QueryNotificationLogs(_m *Alert) *NotificationLogQuery {
	query := (&NotificationLogClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(alert.Table, alert.FieldID, id),
			sqlgraph.To(notificationlog.Table, notificationlog.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, alert.NotificationLogsTable, alert.NotificationLogsColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.NotificationLog
		step.Edge.Schema = schemaConfig.NotificationLog
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *AlertClient) Hooks() []Hook {
	return c.hooks.Alert
}

// Interceptors returns the client interceptors.
func (c *AlertClient) Interceptors() []Interceptor {
	return c.inters.Alert
}

func (c *AlertClient) mutate(ctx context.Context, m *AlertMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&AlertCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&AlertUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&AlertUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&AlertDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Alert mutation op: %q", m.Op())
	}
}

// AlertDigestEntryClient is a client for the AlertDigestEntry schema.
type AlertDigestEntryClient struct {
	config
}

// NewAlertDigestEntryClient returns a client for the AlertDigestEntry from the given config.
func NewAlertDigestEntryClient(c config) *AlertDigestEntryClient {
	return &AlertDigestEntryClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `alertdigestentry.Hooks(f(g(h())))`.
func (c *AlertDigestEntryClient) Use(hooks ...Hook) {
	c.hooks.AlertDigestEntry = append(c.hooks.AlertDigestEntry, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `alertdigestentry.Intercept(f(g(h())))`.
func (c *AlertDigestEntryClient) Intercept(interceptors ...Interceptor) {
	c.inters.AlertDigestEntry = append(c.inters.AlertDigestEntry, interceptors...)
}

// Create returns a builder for creating a AlertDigestEntry entity.
func (c *AlertDigestEntryClient) Create() *AlertDigestEntryCreate {
	mutation := newAlertDigestEntryMutation(c.config, OpCreate)
	return &AlertDigestEntryCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of AlertDigestEntry entities.
func (c *AlertDigestEntryClient) CreateBulk(builders ...*AlertDigestEntryCreate) *AlertDigestEntryCreateBulk {
	return &AlertDigestEntryCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *AlertDigestEntryClient) MapCreateBulk(slice any, setFunc func(*AlertDigestEntryCreate, int)) *AlertDigestEntryCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &AlertDigestEntryCreateBulk{err: fmt.Errorf("calling to AlertDigestEntryClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*AlertDigestEntryCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &AlertDigestEntryCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for AlertDigestEntry.
func (c *AlertDigestEntryClient) Update() *AlertDigestEntryUpdate {
	mutation := newAlertDigestEntryMutation(c.config, OpUpdate)
	return &AlertDigestEntryUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AlertDigestEntryClient) UpdateOne(_m *AlertDigestEntry) *AlertDigestEntryUpdateOne {
	mutation := newAlertDigestEntryMutation(c.config, OpUpdateOne, withAlertDigestEntry(_m))
	return &AlertDigestEntryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AlertDigestEntryClient) UpdateOneID(id uuid.UUID) *AlertDigestEntryUpdateOne {
	mutation := newAlertDigestEntryMutation(c.config, OpUpdateOne, withAlertDigestEntryID(id))
	return &AlertDigestEntryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for AlertDigestEntry.
func (c *AlertDigestEntryClient) Delete() *AlertDigestEntryDelete {
	mutation := newAlertDigestEntryMutation(c.config, OpDelete)
	return &AlertDigestEntryDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *AlertDigestEntryClient) DeleteOne(_m *AlertDigestEntry) *AlertDigestEntryDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *AlertDigestEntryClient) DeleteOneID(id uuid.UUID) *AlertDigestEntryDeleteOne {
	builder := c.Delete().Where(alertdigestentry.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AlertDigestEntryDeleteOne{builder}
}

// Query returns a query builder for AlertDigestEntry.
func (c *AlertDigestEntryClient) Query() *AlertDigestEntryQuery {
	return &AlertDigestEntryQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeAlertDigestEntry},
		inters: c.Interceptors(),
	}
}

// Get returns a AlertDigestEntry entity by its id.
func (c *AlertDigestEntryClient) Get(ctx context.Context, id uuid.UUID) (*AlertDigestEntry, error) {
	return c.Query().Where(alertdigestentry.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AlertDigestEntryClient) GetX(ctx context.Context, id uuid.UUID) *AlertDigestEntry {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *AlertDigestEntryClient) Hooks() []Hook {
	return c.hooks.AlertDigestEntry
}

// Interceptors returns the client interceptors.
func (c *AlertDigestEntryClient) Interceptors() []Interceptor {
	return c.inters.AlertDigestEntry
}

func (c *AlertDigestEntryClient) mutate(ctx context.Context, m *AlertDigestEntryMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&AlertDigestEntryCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&AlertDigestEntryUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&AlertDigestEntryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&AlertDigestEntryDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown AlertDigestEntry mutation op: %q", m.Op())
	}
}

// AlertEscalationClient is a client for the AlertEscalation schema.
type AlertEscalationClient struct {
	config
}

// NewAlertEscalationClient returns a client for the AlertEscalation from the given config.
func NewAlertEscalationClient(c config) *AlertEscalationClient {
	return &AlertEscalationClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `alertescalation.Hooks(f(g(h())))`.
func (c *AlertEscalationClient) Use(hooks ...Hook) {
	c.hooks.AlertEscalation = append(c.hooks.AlertEscalation, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `alertescalation.Intercept(f(g(h())))`.
func (c *AlertEscalationClient) Intercept(interceptors ...Interceptor) {
	c.inters.AlertEscalation = append(c.inters.AlertEscalation, interceptors...)
}

// Create returns a builder for creating a AlertEscalation entity.
func (c *AlertEscalationClient) Create() *AlertEscalationCreate {
	mutation := newAlertEscalationMutation(c.config, OpCreate)
	return &AlertEscalationCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of AlertEscalation entities.
func (c *AlertEscalationClient) CreateBulk(builders ...*AlertEscalationCreate) *AlertEscalationCreateBulk {
	return &AlertEscalationCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *AlertEscalationClient) MapCreateBulk(slice any, setFunc func(*AlertEscalationCreate, int)) *AlertEscalationCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &AlertEscalationCreateBulk{err: fmt.Errorf("calling to AlertEscalationClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*AlertEscalationCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &AlertEscalationCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for AlertEscalation.
func (c *AlertEscalationClient) Update() *AlertEscalationUpdate {
	mutation := newAlertEscalationMutation(c.config, OpUpdate)
	return &AlertEscalationUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AlertEscalationClient) UpdateOne(_m *AlertEscalation) *AlertEscalationUpdateOne {
	mutation := newAlertEscalationMutation(c.config, OpUpdateOne, withAlertEscalation(_m))
	return &AlertEscalationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AlertEscalationClient) UpdateOneID(id string) *AlertEscalationUpdateOne {
	mutation := newAlertEscalationMutation(c.config, OpUpdateOne, withAlertEscalationID(id))
	return &AlertEscalationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for AlertEscalation.
func (c *AlertEscalationClient) Delete() *AlertEscalationDelete {
	mutation := newAlertEscalationMutation(c.config, OpDelete)
	return &AlertEscalationDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *AlertEscalationClient) DeleteOne(_m *AlertEscalation) *AlertEscalationDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *AlertEscalationClient) DeleteOneID(id string) *AlertEscalationDeleteOne {
	builder := c.Delete().Where(alertescalation.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AlertEscalationDeleteOne{builder}
}

// Query returns a query builder for AlertEscalation.
func (c *AlertEscalationClient) Query() *AlertEscalationQuery {
	return &AlertEscalationQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeAlertEscalation},
		inters: c.Interceptors(),
	}
}

// Get returns a AlertEscalation entity by its id.
func (c *AlertEscalationClient) Get(ctx context.Context, id string) (*AlertEscalation, error) {
	return c.Query().Where(alertescalation.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AlertEscalationClient) GetX(ctx context.Context, id string) *AlertEscalation {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryAlert queries the alert edge of a AlertEscalation.
func (c *AlertEscalationClient) QueryAlert(_m *AlertEscalation) *AlertQuery {
	query := (&AlertClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(alertescalation.Table, alertescalation.FieldID, id),
			sqlgraph.To(alert.Table, alert.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, alertescalation.AlertTable, alertescalation.AlertColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Alert
		step.Edge.Schema = schemaConfig.AlertEscalation
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryRule queries the rule edge of a AlertEscalation.
func (c *AlertEscalationClient) QueryRule(_m *AlertEscalation) *AlertRuleQuery {
	query := (&AlertRuleClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(alertescalation.Table, alertescalation.FieldID, id),
			sqlgraph.To(alertrule.Table, alertrule.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, alertescalation.RuleTable, alertescalation.RuleColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.AlertRule
		step.Edge.Schema = schemaConfig.AlertEscalation
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *AlertEscalationClient) Hooks() []Hook {
	return c.hooks.AlertEscalation
}

// Interceptors returns the client interceptors.
func (c *AlertEscalationClient) Interceptors() []Interceptor {
	return c.inters.AlertEscalation
}

func (c *AlertEscalationClient) mutate(ctx context.Context, m *AlertEscalationMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&AlertEscalationCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&AlertEscalationUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&AlertEscalationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&AlertEscalationDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown AlertEscalation mutation op: %q", m.Op())
	}
}

// AlertRuleClient is a client for the AlertRule schema.
type AlertRuleClient struct {
	config
}

// NewAlertRuleClient returns a client for the AlertRule from the given config.
func NewAlertRuleClient(c config) *AlertRuleClient {
	return &AlertRuleClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `alertrule.Hooks(f(g(h())))`.
func (c *AlertRuleClient) Use(hooks ...Hook) {
	c.hooks.AlertRule = append(c.hooks.AlertRule, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `alertrule.Intercept(f(g(h())))`.
func (c *AlertRuleClient) Intercept(interceptors ...Interceptor) {
	c.inters.AlertRule = append(c.inters.AlertRule, interceptors...)
}

// Create returns a builder for creating a AlertRule entity.
func (c *AlertRuleClient) Create() *AlertRuleCreate {
	mutation := newAlertRuleMutation(c.config, OpCreate)
	return &AlertRuleCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of AlertRule entities.
func (c *AlertRuleClient) CreateBulk(builders ...*AlertRuleCreate) *AlertRuleCreateBulk {
	return &AlertRuleCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *AlertRuleClient) MapCreateBulk(slice any, setFunc func(*AlertRuleCreate, int)) *AlertRuleCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &AlertRuleCreateBulk{err: fmt.Errorf("calling to AlertRuleClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*AlertRuleCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &AlertRuleCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for AlertRule.
func (c *AlertRuleClient) Update() *AlertRuleUpdate {
	mutation := newAlertRuleMutation(c.config, OpUpdate)
	return &AlertRuleUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AlertRuleClient) UpdateOne(_m *AlertRule) *AlertRuleUpdateOne {
	mutation := newAlertRuleMutation(c.config, OpUpdateOne, withAlertRule(_m))
	return &AlertRuleUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AlertRuleClient) UpdateOneID(id string) *AlertRuleUpdateOne {
	mutation := newAlertRuleMutation(c.config, OpUpdateOne, withAlertRuleID(id))
	return &AlertRuleUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for AlertRule.
func (c *AlertRuleClient) Delete() *AlertRuleDelete {
	mutation := newAlertRuleMutation(c.config, OpDelete)
	return &AlertRuleDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *AlertRuleClient) DeleteOne(_m *AlertRule) *AlertRuleDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *AlertRuleClient) DeleteOneID(id string) *AlertRuleDeleteOne {
	builder := c.Delete().Where(alertrule.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AlertRuleDeleteOne{builder}
}

// Query returns a query builder for AlertRule.
func (c *AlertRuleClient) Query() *AlertRuleQuery {
	return &AlertRuleQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeAlertRule},
		inters: c.Interceptors(),
	}
}

// Get returns a AlertRule entity by its id.
func (c *AlertRuleClient) Get(ctx context.Context, id string) (*AlertRule, error) {
	return c.Query().Where(alertrule.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AlertRuleClient) GetX(ctx context.Context, id string) *AlertRule {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryAlerts queries the alerts edge of a AlertRule.
func (c *AlertRuleClient) QueryAlerts(_m *AlertRule) *AlertQuery {
	query := (&AlertClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(alertrule.Table, alertrule.FieldID, id),
			sqlgraph.To(alert.Table, alert.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, alertrule.AlertsTable, alertrule.AlertsColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Alert
		step.Edge.Schema = schemaConfig.Alert
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEscalations queries the escalations edge of a AlertRule.
func (c *AlertRuleClient) QueryEscalations(_m *AlertRule) *AlertEscalationQuery {
	query := (&AlertEscalationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(alertrule.Table, alertrule.FieldID, id),
			sqlgraph.To(alertescalation.Table, alertescalation.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, alertrule.EscalationsTable, alertrule.EscalationsColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.AlertEscalation
		step.Edge.Schema = schemaConfig.AlertEscalation
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *AlertRuleClient) Hooks() []Hook {
	return c.hooks.AlertRule
}

// Interceptors returns the client interceptors.
func (c *AlertRuleClient) Interceptors() []Interceptor {
	return c.inters.AlertRule
}

func (c *AlertRuleClient) mutate(ctx context.Context, m *AlertRuleMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&AlertRuleCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&AlertRuleUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&AlertRuleUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&AlertRuleDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown AlertRule mutation op: %q", m.Op())
	}
}

// AlertRuleTemplateClient is a client for the AlertRuleTemplate schema.
type AlertRuleTemplateClient struct {
	config
}

// NewAlertRuleTemplateClient returns a client for the AlertRuleTemplate from the given config.
func NewAlertRuleTemplateClient(c config) *AlertRuleTemplateClient {
	return &AlertRuleTemplateClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `alertruletemplate.Hooks(f(g(h())))`.
func (c *AlertRuleTemplateClient) Use(hooks ...Hook) {
	c.hooks.AlertRuleTemplate = append(c.hooks.AlertRuleTemplate, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `alertruletemplate.Intercept(f(g(h())))`.
func (c *AlertRuleTemplateClient) Intercept(interceptors ...Interceptor) {
	c.inters.AlertRuleTemplate = append(c.inters.AlertRuleTemplate, interceptors...)
}

// Create returns a builder for creating a AlertRuleTemplate entity.
func (c *AlertRuleTemplateClient) Create() *AlertRuleTemplateCreate {
	mutation := newAlertRuleTemplateMutation(c.config, OpCreate)
	return &AlertRuleTemplateCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of AlertRuleTemplate entities.
func (c *AlertRuleTemplateClient) CreateBulk(builders ...*AlertRuleTemplateCreate) *AlertRuleTemplateCreateBulk {
	return &AlertRuleTemplateCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *AlertRuleTemplateClient) MapCreateBulk(slice any, setFunc func(*AlertRuleTemplateCreate, int)) *AlertRuleTemplateCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &AlertRuleTemplateCreateBulk{err: fmt.Errorf("calling to AlertRuleTemplateClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*AlertRuleTemplateCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &AlertRuleTemplateCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for AlertRuleTemplate.
func (c *AlertRuleTemplateClient) Update() *AlertRuleTemplateUpdate {
	mutation := newAlertRuleTemplateMutation(c.config, OpUpdate)
	return &AlertRuleTemplateUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AlertRuleTemplateClient) UpdateOne(_m *AlertRuleTemplate) *AlertRuleTemplateUpdateOne {
	mutation := newAlertRuleTemplateMutation(c.config, OpUpdateOne, withAlertRuleTemplate(_m))
	return &AlertRuleTemplateUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AlertRuleTemplateClient) UpdateOneID(id string) *AlertRuleTemplateUpdateOne {
	mutation := newAlertRuleTemplateMutation(c.config, OpUpdateOne, withAlertRuleTemplateID(id))
	return &AlertRuleTemplateUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for AlertRuleTemplate.
func (c *AlertRuleTemplateClient) Delete() *AlertRuleTemplateDelete {
	mutation := newAlertRuleTemplateMutation(c.config, OpDelete)
	return &AlertRuleTemplateDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *AlertRuleTemplateClient) DeleteOne(_m *AlertRuleTemplate) *AlertRuleTemplateDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *AlertRuleTemplateClient) DeleteOneID(id string) *AlertRuleTemplateDeleteOne {
	builder := c.Delete().Where(alertruletemplate.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AlertRuleTemplateDeleteOne{builder}
}

// Query returns a query builder for AlertRuleTemplate.
func (c *AlertRuleTemplateClient) Query() *AlertRuleTemplateQuery {
	return &AlertRuleTemplateQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeAlertRuleTemplate},
		inters: c.Interceptors(),
	}
}

// Get returns a AlertRuleTemplate entity by its id.
func (c *AlertRuleTemplateClient) Get(ctx context.Context, id string) (*AlertRuleTemplate, error) {
	return c.Query().Where(alertruletemplate.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AlertRuleTemplateClient) GetX(ctx context.Context, id string) *AlertRuleTemplate {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *AlertRuleTemplateClient) Hooks() []Hook {
	return c.hooks.AlertRuleTemplate
}

// Interceptors returns the client interceptors.
func (c *AlertRuleTemplateClient) Interceptors() []Interceptor {
	return c.inters.AlertRuleTemplate
}

func (c *AlertRuleTemplateClient) mutate(ctx context.Context, m *AlertRuleTemplateMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&AlertRuleTemplateCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&AlertRuleTemplateUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&AlertRuleTemplateUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&AlertRuleTemplateDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown AlertRuleTemplate mutation op: %q", m.Op())
	}
}

// AlertTemplateClient is a client for the AlertTemplate schema.
type AlertTemplateClient struct {
	config
}

// NewAlertTemplateClient returns a client for the AlertTemplate from the given config.
func NewAlertTemplateClient(c config) *AlertTemplateClient {
	return &AlertTemplateClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `alerttemplate.Hooks(f(g(h())))`.
func (c *AlertTemplateClient) Use(hooks ...Hook) {
	c.hooks.AlertTemplate = append(c.hooks.AlertTemplate, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `alerttemplate.Intercept(f(g(h())))`.
func (c *AlertTemplateClient) Intercept(interceptors ...Interceptor) {
	c.inters.AlertTemplate = append(c.inters.AlertTemplate, interceptors...)
}

// Create returns a builder for creating a AlertTemplate entity.
func (c *AlertTemplateClient) Create() *AlertTemplateCreate {
	mutation := newAlertTemplateMutation(c.config, OpCreate)
	return &AlertTemplateCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of AlertTemplate entities.
func (c *AlertTemplateClient) CreateBulk(builders ...*AlertTemplateCreate) *AlertTemplateCreateBulk {
	return &AlertTemplateCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *AlertTemplateClient) MapCreateBulk(slice any, setFunc func(*AlertTemplateCreate, int)) *AlertTemplateCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &AlertTemplateCreateBulk{err: fmt.Errorf("calling to AlertTemplateClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*AlertTemplateCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &AlertTemplateCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for AlertTemplate.
func (c *AlertTemplateClient) Update() *AlertTemplateUpdate {
	mutation := newAlertTemplateMutation(c.config, OpUpdate)
	return &AlertTemplateUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AlertTemplateClient) UpdateOne(_m *AlertTemplate) *AlertTemplateUpdateOne {
	mutation := newAlertTemplateMutation(c.config, OpUpdateOne, withAlertTemplate(_m))
	return &AlertTemplateUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AlertTemplateClient) UpdateOneID(id string) *AlertTemplateUpdateOne {
	mutation := newAlertTemplateMutation(c.config, OpUpdateOne, withAlertTemplateID(id))
	return &AlertTemplateUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for AlertTemplate.
func (c *AlertTemplateClient) Delete() *AlertTemplateDelete {
	mutation := newAlertTemplateMutation(c.config, OpDelete)
	return &AlertTemplateDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *AlertTemplateClient) DeleteOne(_m *AlertTemplate) *AlertTemplateDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *AlertTemplateClient) DeleteOneID(id string) *AlertTemplateDeleteOne {
	builder := c.Delete().Where(alerttemplate.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AlertTemplateDeleteOne{builder}
}

// Query returns a query builder for AlertTemplate.
func (c *AlertTemplateClient) Query() *AlertTemplateQuery {
	return &AlertTemplateQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeAlertTemplate},
		inters: c.Interceptors(),
	}
}

// Get returns a AlertTemplate entity by its id.
func (c *AlertTemplateClient) Get(ctx context.Context, id string) (*AlertTemplate, error) {
	return c.Query().Where(alerttemplate.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AlertTemplateClient) GetX(ctx context.Context, id string) *AlertTemplate {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *AlertTemplateClient) Hooks() []Hook {
	return c.hooks.AlertTemplate
}

// Interceptors returns the client interceptors.
func (c *AlertTemplateClient) Interceptors() []Interceptor {
	return c.inters.AlertTemplate
}

func (c *AlertTemplateClient) mutate(ctx context.Context, m *AlertTemplateMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&AlertTemplateCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&AlertTemplateUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&AlertTemplateUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&AlertTemplateDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown AlertTemplate mutation op: %q", m.Op())
	}
}

// ChainHopClient is a client for the ChainHop schema.
type ChainHopClient struct {
	config
}

// NewChainHopClient returns a client for the ChainHop from the given config.
func NewChainHopClient(c config) *ChainHopClient {
	return &ChainHopClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `chainhop.Hooks(f(g(h())))`.
func (c *ChainHopClient) Use(hooks ...Hook) {
	c.hooks.ChainHop = append(c.hooks.ChainHop, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `chainhop.Intercept(f(g(h())))`.
func (c *ChainHopClient) Intercept(interceptors ...Interceptor) {
	c.inters.ChainHop = append(c.inters.ChainHop, interceptors...)
}

// Create returns a builder for creating a ChainHop entity.
func (c *ChainHopClient) Create() *ChainHopCreate {
	mutation := newChainHopMutation(c.config, OpCreate)
	return &ChainHopCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ChainHop entities.
func (c *ChainHopClient) CreateBulk(builders ...*ChainHopCreate) *ChainHopCreateBulk {
	return &ChainHopCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ChainHopClient) MapCreateBulk(slice any, setFunc func(*ChainHopCreate, int)) *ChainHopCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ChainHopCreateBulk{err: fmt.Errorf("calling to ChainHopClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ChainHopCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ChainHopCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ChainHop.
func (c *ChainHopClient) Update() *ChainHopUpdate {
	mutation := newChainHopMutation(c.config, OpUpdate)
	return &ChainHopUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ChainHopClient) UpdateOne(_m *ChainHop) *ChainHopUpdateOne {
	mutation := newChainHopMutation(c.config, OpUpdateOne, withChainHop(_m))
	return &ChainHopUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ChainHopClient) UpdateOneID(id string) *ChainHopUpdateOne {
	mutation := newChainHopMutation(c.config, OpUpdateOne, withChainHopID(id))
	return &ChainHopUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ChainHop.
func (c *ChainHopClient) Delete() *ChainHopDelete {
	mutation := newChainHopMutation(c.config, OpDelete)
	return &ChainHopDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ChainHopClient) DeleteOne(_m *ChainHop) *ChainHopDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ChainHopClient) DeleteOneID(id string) *ChainHopDeleteOne {
	builder := c.Delete().Where(chainhop.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ChainHopDeleteOne{builder}
}

// Query returns a query builder for ChainHop.
func (c *ChainHopClient) Query() *ChainHopQuery {
	return &ChainHopQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeChainHop},
		inters: c.Interceptors(),
	}
}

// Get returns a ChainHop entity by its id.
func (c *ChainHopClient) Get(ctx context.Context, id string) (*ChainHop, error) {
	return c.Query().Where(chainhop.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ChainHopClient) GetX(ctx context.Context, id string) *ChainHop {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryChain queries the chain edge of a ChainHop.
func (c *ChainHopClient) QueryChain(_m *ChainHop) *RoutingChainQuery {
	query := (&RoutingChainClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(chainhop.Table, chainhop.FieldID, id),
			sqlgraph.To(routingchain.Table, routingchain.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, chainhop.ChainTable, chainhop.ChainColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.RoutingChain
		step.Edge.Schema = schemaConfig.ChainHop
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryInterface queries the interface edge of a ChainHop.
func (c *ChainHopClient) QueryInterface(_m *ChainHop) *VirtualInterfaceQuery {
	query := (&VirtualInterfaceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(chainhop.Table, chainhop.FieldID, id),
			sqlgraph.To(virtualinterface.Table, virtualinterface.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, chainhop.InterfaceTable, chainhop.InterfaceColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.VirtualInterface
		step.Edge.Schema = schemaConfig.ChainHop
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ChainHopClient) Hooks() []Hook {
	return c.hooks.ChainHop
}

// Interceptors returns the client interceptors.
func (c *ChainHopClient) Interceptors() []Interceptor {
	return c.inters.ChainHop
}

func (c *ChainHopClient) mutate(ctx context.Context, m *ChainHopMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ChainHopCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ChainHopUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ChainHopUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ChainHopDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown ChainHop mutation op: %q", m.Op())
	}
}

// ConfigSnapshotClient is a client for the ConfigSnapshot schema.
type ConfigSnapshotClient struct {
	config
}

// NewConfigSnapshotClient returns a client for the ConfigSnapshot from the given config.
func NewConfigSnapshotClient(c config) *ConfigSnapshotClient {
	return &ConfigSnapshotClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `configsnapshot.Hooks(f(g(h())))`.
func (c *ConfigSnapshotClient) Use(hooks ...Hook) {
	c.hooks.ConfigSnapshot = append(c.hooks.ConfigSnapshot, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `configsnapshot.Intercept(f(g(h())))`.
func (c *ConfigSnapshotClient) Intercept(interceptors ...Interceptor) {
	c.inters.ConfigSnapshot = append(c.inters.ConfigSnapshot, interceptors...)
}

// Create returns a builder for creating a ConfigSnapshot entity.
func (c *ConfigSnapshotClient) Create() *ConfigSnapshotCreate {
	mutation := newConfigSnapshotMutation(c.config, OpCreate)
	return &ConfigSnapshotCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ConfigSnapshot entities.
func (c *ConfigSnapshotClient) CreateBulk(builders ...*ConfigSnapshotCreate) *ConfigSnapshotCreateBulk {
	return &ConfigSnapshotCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ConfigSnapshotClient) MapCreateBulk(slice any, setFunc func(*ConfigSnapshotCreate, int)) *ConfigSnapshotCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ConfigSnapshotCreateBulk{err: fmt.Errorf("calling to ConfigSnapshotClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ConfigSnapshotCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ConfigSnapshotCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ConfigSnapshot.
func (c *ConfigSnapshotClient) Update() *ConfigSnapshotUpdate {
	mutation := newConfigSnapshotMutation(c.config, OpUpdate)
	return &ConfigSnapshotUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ConfigSnapshotClient) UpdateOne(_m *ConfigSnapshot) *ConfigSnapshotUpdateOne {
	mutation := newConfigSnapshotMutation(c.config, OpUpdateOne, withConfigSnapshot(_m))
	return &ConfigSnapshotUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ConfigSnapshotClient) UpdateOneID(id string) *ConfigSnapshotUpdateOne {
	mutation := newConfigSnapshotMutation(c.config, OpUpdateOne, withConfigSnapshotID(id))
	return &ConfigSnapshotUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ConfigSnapshot.
func (c *ConfigSnapshotClient) Delete() *ConfigSnapshotDelete {
	mutation := newConfigSnapshotMutation(c.config, OpDelete)
	return &ConfigSnapshotDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ConfigSnapshotClient) DeleteOne(_m *ConfigSnapshot) *ConfigSnapshotDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ConfigSnapshotClient) DeleteOneID(id string) *ConfigSnapshotDeleteOne {
	builder := c.Delete().Where(configsnapshot.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ConfigSnapshotDeleteOne{builder}
}

// Query returns a query builder for ConfigSnapshot.
func (c *ConfigSnapshotClient) Query() *ConfigSnapshotQuery {
	return &ConfigSnapshotQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeConfigSnapshot},
		inters: c.Interceptors(),
	}
}

// Get returns a ConfigSnapshot entity by its id.
func (c *ConfigSnapshotClient) Get(ctx context.Context, id string) (*ConfigSnapshot, error) {
	return c.Query().Where(configsnapshot.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ConfigSnapshotClient) GetX(ctx context.Context, id string) *ConfigSnapshot {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *ConfigSnapshotClient) Hooks() []Hook {
	return c.hooks.ConfigSnapshot
}

// Interceptors returns the client interceptors.
func (c *ConfigSnapshotClient) Interceptors() []Interceptor {
	return c.inters.ConfigSnapshot
}

func (c *ConfigSnapshotClient) mutate(ctx context.Context, m *ConfigSnapshotMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ConfigSnapshotCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ConfigSnapshotUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ConfigSnapshotUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ConfigSnapshotDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown ConfigSnapshot mutation op: %q", m.Op())
	}
}

// DeviceRoutingClient is a client for the DeviceRouting schema.
type DeviceRoutingClient struct {
	config
}

// NewDeviceRoutingClient returns a client for the DeviceRouting from the given config.
func NewDeviceRoutingClient(c config) *DeviceRoutingClient {
	return &DeviceRoutingClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `devicerouting.Hooks(f(g(h())))`.
func (c *DeviceRoutingClient) Use(hooks ...Hook) {
	c.hooks.DeviceRouting = append(c.hooks.DeviceRouting, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `devicerouting.Intercept(f(g(h())))`.
func (c *DeviceRoutingClient) Intercept(interceptors ...Interceptor) {
	c.inters.DeviceRouting = append(c.inters.DeviceRouting, interceptors...)
}

// Create returns a builder for creating a DeviceRouting entity.
func (c *DeviceRoutingClient) Create() *DeviceRoutingCreate {
	mutation := newDeviceRoutingMutation(c.config, OpCreate)
	return &DeviceRoutingCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of DeviceRouting entities.
func (c *DeviceRoutingClient) CreateBulk(builders ...*DeviceRoutingCreate) *DeviceRoutingCreateBulk {
	return &DeviceRoutingCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *DeviceRoutingClient) MapCreateBulk(slice any, setFunc func(*DeviceRoutingCreate, int)) *DeviceRoutingCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &DeviceRoutingCreateBulk{err: fmt.Errorf("calling to DeviceRoutingClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*DeviceRoutingCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &DeviceRoutingCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for DeviceRouting.
func (c *DeviceRoutingClient) Update() *DeviceRoutingUpdate {
	mutation := newDeviceRoutingMutation(c.config, OpUpdate)
	return &DeviceRoutingUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *DeviceRoutingClient) UpdateOne(_m *DeviceRouting) *DeviceRoutingUpdateOne {
	mutation := newDeviceRoutingMutation(c.config, OpUpdateOne, withDeviceRouting(_m))
	return &DeviceRoutingUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *DeviceRoutingClient) UpdateOneID(id string) *DeviceRoutingUpdateOne {
	mutation := newDeviceRoutingMutation(c.config, OpUpdateOne, withDeviceRoutingID(id))
	return &DeviceRoutingUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for DeviceRouting.
func (c *DeviceRoutingClient) Delete() *DeviceRoutingDelete {
	mutation := newDeviceRoutingMutation(c.config, OpDelete)
	return &DeviceRoutingDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *DeviceRoutingClient) DeleteOne(_m *DeviceRouting) *DeviceRoutingDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *DeviceRoutingClient) DeleteOneID(id string) *DeviceRoutingDeleteOne {
	builder := c.Delete().Where(devicerouting.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &DeviceRoutingDeleteOne{builder}
}

// Query returns a query builder for DeviceRouting.
func (c *DeviceRoutingClient) Query() *DeviceRoutingQuery {
	return &DeviceRoutingQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeDeviceRouting},
		inters: c.Interceptors(),
	}
}

// Get returns a DeviceRouting entity by its id.
func (c *DeviceRoutingClient) Get(ctx context.Context, id string) (*DeviceRouting, error) {
	return c.Query().Where(devicerouting.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *DeviceRoutingClient) GetX(ctx context.Context, id string) *DeviceRouting {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryRouter queries the router edge of a DeviceRouting.
func (c *DeviceRoutingClient) QueryRouter(_m *DeviceRouting) *RouterQuery {
	query := (&RouterClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(devicerouting.Table, devicerouting.FieldID, id),
			sqlgraph.To(router.Table, router.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, devicerouting.RouterTable, devicerouting.RouterColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Router
		step.Edge.Schema = schemaConfig.DeviceRouting
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryInstance queries the instance edge of a DeviceRouting.
func (c *DeviceRoutingClient) QueryInstance(_m *DeviceRouting) *ServiceInstanceQuery {
	query := (&ServiceInstanceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(devicerouting.Table, devicerouting.FieldID, id),
			sqlgraph.To(serviceinstance.Table, serviceinstance.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, devicerouting.InstanceTable, devicerouting.InstanceColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.ServiceInstance
		step.Edge.Schema = schemaConfig.DeviceRouting
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryVirtualInterface queries the virtual_interface edge of a DeviceRouting.
func (c *DeviceRoutingClient) QueryVirtualInterface(_m *DeviceRouting) *VirtualInterfaceQuery {
	query := (&VirtualInterfaceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(devicerouting.Table, devicerouting.FieldID, id),
			sqlgraph.To(virtualinterface.Table, virtualinterface.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, devicerouting.VirtualInterfaceTable, devicerouting.VirtualInterfaceColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.VirtualInterface
		step.Edge.Schema = schemaConfig.DeviceRouting
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySchedules queries the schedules edge of a DeviceRouting.
func (c *DeviceRoutingClient) QuerySchedules(_m *DeviceRouting) *RoutingScheduleQuery {
	query := (&RoutingScheduleClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(devicerouting.Table, devicerouting.FieldID, id),
			sqlgraph.To(routingschedule.Table, routingschedule.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, devicerouting.SchedulesTable, devicerouting.SchedulesColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.RoutingSchedule
		step.Edge.Schema = schemaConfig.RoutingSchedule
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *DeviceRoutingClient) Hooks() []Hook {
	return c.hooks.DeviceRouting
}

// Interceptors returns the client interceptors.
func (c *DeviceRoutingClient) Interceptors() []Interceptor {
	return c.inters.DeviceRouting
}

func (c *DeviceRoutingClient) mutate(ctx context.Context, m *DeviceRoutingMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&DeviceRoutingCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&DeviceRoutingUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&DeviceRoutingUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&DeviceRoutingDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown DeviceRouting mutation op: %q", m.Op())
	}
}

// DiagnosticResultClient is a client for the DiagnosticResult schema.
type DiagnosticResultClient struct {
	config
}

// NewDiagnosticResultClient returns a client for the DiagnosticResult from the given config.
func NewDiagnosticResultClient(c config) *DiagnosticResultClient {
	return &DiagnosticResultClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `diagnosticresult.Hooks(f(g(h())))`.
func (c *DiagnosticResultClient) Use(hooks ...Hook) {
	c.hooks.DiagnosticResult = append(c.hooks.DiagnosticResult, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `diagnosticresult.Intercept(f(g(h())))`.
func (c *DiagnosticResultClient) Intercept(interceptors ...Interceptor) {
	c.inters.DiagnosticResult = append(c.inters.DiagnosticResult, interceptors...)
}

// Create returns a builder for creating a DiagnosticResult entity.
func (c *DiagnosticResultClient) Create() *DiagnosticResultCreate {
	mutation := newDiagnosticResultMutation(c.config, OpCreate)
	return &DiagnosticResultCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of DiagnosticResult entities.
func (c *DiagnosticResultClient) CreateBulk(builders ...*DiagnosticResultCreate) *DiagnosticResultCreateBulk {
	return &DiagnosticResultCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *DiagnosticResultClient) MapCreateBulk(slice any, setFunc func(*DiagnosticResultCreate, int)) *DiagnosticResultCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &DiagnosticResultCreateBulk{err: fmt.Errorf("calling to DiagnosticResultClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*DiagnosticResultCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &DiagnosticResultCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for DiagnosticResult.
func (c *DiagnosticResultClient) Update() *DiagnosticResultUpdate {
	mutation := newDiagnosticResultMutation(c.config, OpUpdate)
	return &DiagnosticResultUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *DiagnosticResultClient) UpdateOne(_m *DiagnosticResult) *DiagnosticResultUpdateOne {
	mutation := newDiagnosticResultMutation(c.config, OpUpdateOne, withDiagnosticResult(_m))
	return &DiagnosticResultUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *DiagnosticResultClient) UpdateOneID(id string) *DiagnosticResultUpdateOne {
	mutation := newDiagnosticResultMutation(c.config, OpUpdateOne, withDiagnosticResultID(id))
	return &DiagnosticResultUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for DiagnosticResult.
func (c *DiagnosticResultClient) Delete() *DiagnosticResultDelete {
	mutation := newDiagnosticResultMutation(c.config, OpDelete)
	return &DiagnosticResultDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *DiagnosticResultClient) DeleteOne(_m *DiagnosticResult) *DiagnosticResultDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *DiagnosticResultClient) DeleteOneID(id string) *DiagnosticResultDeleteOne {
	builder := c.Delete().Where(diagnosticresult.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &DiagnosticResultDeleteOne{builder}
}

// Query returns a query builder for DiagnosticResult.
func (c *DiagnosticResultClient) Query() *DiagnosticResultQuery {
	return &DiagnosticResultQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeDiagnosticResult},
		inters: c.Interceptors(),
	}
}

// Get returns a DiagnosticResult entity by its id.
func (c *DiagnosticResultClient) Get(ctx context.Context, id string) (*DiagnosticResult, error) {
	return c.Query().Where(diagnosticresult.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *DiagnosticResultClient) GetX(ctx context.Context, id string) *DiagnosticResult {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryServiceInstance queries the service_instance edge of a DiagnosticResult.
func (c *DiagnosticResultClient) QueryServiceInstance(_m *DiagnosticResult) *ServiceInstanceQuery {
	query := (&ServiceInstanceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(diagnosticresult.Table, diagnosticresult.FieldID, id),
			sqlgraph.To(serviceinstance.Table, serviceinstance.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, diagnosticresult.ServiceInstanceTable, diagnosticresult.ServiceInstanceColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.ServiceInstance
		step.Edge.Schema = schemaConfig.DiagnosticResult
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *DiagnosticResultClient) Hooks() []Hook {
	return c.hooks.DiagnosticResult
}

// Interceptors returns the client interceptors.
func (c *DiagnosticResultClient) Interceptors() []Interceptor {
	return c.inters.DiagnosticResult
}

func (c *DiagnosticResultClient) mutate(ctx context.Context, m *DiagnosticResultMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&DiagnosticResultCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&DiagnosticResultUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&DiagnosticResultUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&DiagnosticResultDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown DiagnosticResult mutation op: %q", m.Op())
	}
}

// GlobalSettingsClient is a client for the GlobalSettings schema.
type GlobalSettingsClient struct {
	config
}

// NewGlobalSettingsClient returns a client for the GlobalSettings from the given config.
func NewGlobalSettingsClient(c config) *GlobalSettingsClient {
	return &GlobalSettingsClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `globalsettings.Hooks(f(g(h())))`.
func (c *GlobalSettingsClient) Use(hooks ...Hook) {
	c.hooks.GlobalSettings = append(c.hooks.GlobalSettings, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `globalsettings.Intercept(f(g(h())))`.
func (c *GlobalSettingsClient) Intercept(interceptors ...Interceptor) {
	c.inters.GlobalSettings = append(c.inters.GlobalSettings, interceptors...)
}

// Create returns a builder for creating a GlobalSettings entity.
func (c *GlobalSettingsClient) Create() *GlobalSettingsCreate {
	mutation := newGlobalSettingsMutation(c.config, OpCreate)
	return &GlobalSettingsCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of GlobalSettings entities.
func (c *GlobalSettingsClient) CreateBulk(builders ...*GlobalSettingsCreate) *GlobalSettingsCreateBulk {
	return &GlobalSettingsCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *GlobalSettingsClient) MapCreateBulk(slice any, setFunc func(*GlobalSettingsCreate, int)) *GlobalSettingsCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &GlobalSettingsCreateBulk{err: fmt.Errorf("calling to GlobalSettingsClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*GlobalSettingsCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &GlobalSettingsCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for GlobalSettings.
func (c *GlobalSettingsClient) Update() *GlobalSettingsUpdate {
	mutation := newGlobalSettingsMutation(c.config, OpUpdate)
	return &GlobalSettingsUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *GlobalSettingsClient) UpdateOne(_m *GlobalSettings) *GlobalSettingsUpdateOne {
	mutation := newGlobalSettingsMutation(c.config, OpUpdateOne, withGlobalSettings(_m))
	return &GlobalSettingsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *GlobalSettingsClient) UpdateOneID(id string) *GlobalSettingsUpdateOne {
	mutation := newGlobalSettingsMutation(c.config, OpUpdateOne, withGlobalSettingsID(id))
	return &GlobalSettingsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for GlobalSettings.
func (c *GlobalSettingsClient) Delete() *GlobalSettingsDelete {
	mutation := newGlobalSettingsMutation(c.config, OpDelete)
	return &GlobalSettingsDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *GlobalSettingsClient) DeleteOne(_m *GlobalSettings) *GlobalSettingsDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *GlobalSettingsClient) DeleteOneID(id string) *GlobalSettingsDeleteOne {
	builder := c.Delete().Where(globalsettings.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &GlobalSettingsDeleteOne{builder}
}

// Query returns a query builder for GlobalSettings.
func (c *GlobalSettingsClient) Query() *GlobalSettingsQuery {
	return &GlobalSettingsQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeGlobalSettings},
		inters: c.Interceptors(),
	}
}

// Get returns a GlobalSettings entity by its id.
func (c *GlobalSettingsClient) Get(ctx context.Context, id string) (*GlobalSettings, error) {
	return c.Query().Where(globalsettings.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *GlobalSettingsClient) GetX(ctx context.Context, id string) *GlobalSettings {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *GlobalSettingsClient) Hooks() []Hook {
	return c.hooks.GlobalSettings
}

// Interceptors returns the client interceptors.
func (c *GlobalSettingsClient) Interceptors() []Interceptor {
	return c.inters.GlobalSettings
}

func (c *GlobalSettingsClient) mutate(ctx context.Context, m *GlobalSettingsMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&GlobalSettingsCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&GlobalSettingsUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&GlobalSettingsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&GlobalSettingsDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown GlobalSettings mutation op: %q", m.Op())
	}
}

// NotificationChannelConfigClient is a client for the NotificationChannelConfig schema.
type NotificationChannelConfigClient struct {
	config
}

// NewNotificationChannelConfigClient returns a client for the NotificationChannelConfig from the given config.
func NewNotificationChannelConfigClient(c config) *NotificationChannelConfigClient {
	return &NotificationChannelConfigClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `notificationchannelconfig.Hooks(f(g(h())))`.
func (c *NotificationChannelConfigClient) Use(hooks ...Hook) {
	c.hooks.NotificationChannelConfig = append(c.hooks.NotificationChannelConfig, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `notificationchannelconfig.Intercept(f(g(h())))`.
func (c *NotificationChannelConfigClient) Intercept(interceptors ...Interceptor) {
	c.inters.NotificationChannelConfig = append(c.inters.NotificationChannelConfig, interceptors...)
}

// Create returns a builder for creating a NotificationChannelConfig entity.
func (c *NotificationChannelConfigClient) Create() *NotificationChannelConfigCreate {
	mutation := newNotificationChannelConfigMutation(c.config, OpCreate)
	return &NotificationChannelConfigCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of NotificationChannelConfig entities.
func (c *NotificationChannelConfigClient) CreateBulk(builders ...*NotificationChannelConfigCreate) *NotificationChannelConfigCreateBulk {
	return &NotificationChannelConfigCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *NotificationChannelConfigClient) MapCreateBulk(slice any, setFunc func(*NotificationChannelConfigCreate, int)) *NotificationChannelConfigCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &NotificationChannelConfigCreateBulk{err: fmt.Errorf("calling to NotificationChannelConfigClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*NotificationChannelConfigCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &NotificationChannelConfigCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for NotificationChannelConfig.
func (c *NotificationChannelConfigClient) Update() *NotificationChannelConfigUpdate {
	mutation := newNotificationChannelConfigMutation(c.config, OpUpdate)
	return &NotificationChannelConfigUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *NotificationChannelConfigClient) UpdateOne(_m *NotificationChannelConfig) *NotificationChannelConfigUpdateOne {
	mutation := newNotificationChannelConfigMutation(c.config, OpUpdateOne, withNotificationChannelConfig(_m))
	return &NotificationChannelConfigUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *NotificationChannelConfigClient) UpdateOneID(id string) *NotificationChannelConfigUpdateOne {
	mutation := newNotificationChannelConfigMutation(c.config, OpUpdateOne, withNotificationChannelConfigID(id))
	return &NotificationChannelConfigUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for NotificationChannelConfig.
func (c *NotificationChannelConfigClient) Delete() *NotificationChannelConfigDelete {
	mutation := newNotificationChannelConfigMutation(c.config, OpDelete)
	return &NotificationChannelConfigDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *NotificationChannelConfigClient) DeleteOne(_m *NotificationChannelConfig) *NotificationChannelConfigDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *NotificationChannelConfigClient) DeleteOneID(id string) *NotificationChannelConfigDeleteOne {
	builder := c.Delete().Where(notificationchannelconfig.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &NotificationChannelConfigDeleteOne{builder}
}

// Query returns a query builder for NotificationChannelConfig.
func (c *NotificationChannelConfigClient) Query() *NotificationChannelConfigQuery {
	return &NotificationChannelConfigQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeNotificationChannelConfig},
		inters: c.Interceptors(),
	}
}

// Get returns a NotificationChannelConfig entity by its id.
func (c *NotificationChannelConfigClient) Get(ctx context.Context, id string) (*NotificationChannelConfig, error) {
	return c.Query().Where(notificationchannelconfig.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *NotificationChannelConfigClient) GetX(ctx context.Context, id string) *NotificationChannelConfig {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *NotificationChannelConfigClient) Hooks() []Hook {
	return c.hooks.NotificationChannelConfig
}

// Interceptors returns the client interceptors.
func (c *NotificationChannelConfigClient) Interceptors() []Interceptor {
	return c.inters.NotificationChannelConfig
}

func (c *NotificationChannelConfigClient) mutate(ctx context.Context, m *NotificationChannelConfigMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&NotificationChannelConfigCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&NotificationChannelConfigUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&NotificationChannelConfigUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&NotificationChannelConfigDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown NotificationChannelConfig mutation op: %q", m.Op())
	}
}

// NotificationLogClient is a client for the NotificationLog schema.
type NotificationLogClient struct {
	config
}

// NewNotificationLogClient returns a client for the NotificationLog from the given config.
func NewNotificationLogClient(c config) *NotificationLogClient {
	return &NotificationLogClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `notificationlog.Hooks(f(g(h())))`.
func (c *NotificationLogClient) Use(hooks ...Hook) {
	c.hooks.NotificationLog = append(c.hooks.NotificationLog, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `notificationlog.Intercept(f(g(h())))`.
func (c *NotificationLogClient) Intercept(interceptors ...Interceptor) {
	c.inters.NotificationLog = append(c.inters.NotificationLog, interceptors...)
}

// Create returns a builder for creating a NotificationLog entity.
func (c *NotificationLogClient) Create() *NotificationLogCreate {
	mutation := newNotificationLogMutation(c.config, OpCreate)
	return &NotificationLogCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of NotificationLog entities.
func (c *NotificationLogClient) CreateBulk(builders ...*NotificationLogCreate) *NotificationLogCreateBulk {
	return &NotificationLogCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *NotificationLogClient) MapCreateBulk(slice any, setFunc func(*NotificationLogCreate, int)) *NotificationLogCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &NotificationLogCreateBulk{err: fmt.Errorf("calling to NotificationLogClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*NotificationLogCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &NotificationLogCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for NotificationLog.
func (c *NotificationLogClient) Update() *NotificationLogUpdate {
	mutation := newNotificationLogMutation(c.config, OpUpdate)
	return &NotificationLogUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *NotificationLogClient) UpdateOne(_m *NotificationLog) *NotificationLogUpdateOne {
	mutation := newNotificationLogMutation(c.config, OpUpdateOne, withNotificationLog(_m))
	return &NotificationLogUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *NotificationLogClient) UpdateOneID(id string) *NotificationLogUpdateOne {
	mutation := newNotificationLogMutation(c.config, OpUpdateOne, withNotificationLogID(id))
	return &NotificationLogUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for NotificationLog.
func (c *NotificationLogClient) Delete() *NotificationLogDelete {
	mutation := newNotificationLogMutation(c.config, OpDelete)
	return &NotificationLogDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *NotificationLogClient) DeleteOne(_m *NotificationLog) *NotificationLogDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *NotificationLogClient) DeleteOneID(id string) *NotificationLogDeleteOne {
	builder := c.Delete().Where(notificationlog.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &NotificationLogDeleteOne{builder}
}

// Query returns a query builder for NotificationLog.
func (c *NotificationLogClient) Query() *NotificationLogQuery {
	return &NotificationLogQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeNotificationLog},
		inters: c.Interceptors(),
	}
}

// Get returns a NotificationLog entity by its id.
func (c *NotificationLogClient) Get(ctx context.Context, id string) (*NotificationLog, error) {
	return c.Query().Where(notificationlog.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *NotificationLogClient) GetX(ctx context.Context, id string) *NotificationLog {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryAlert queries the alert edge of a NotificationLog.
func (c *NotificationLogClient) QueryAlert(_m *NotificationLog) *AlertQuery {
	query := (&AlertClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(notificationlog.Table, notificationlog.FieldID, id),
			sqlgraph.To(alert.Table, alert.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, notificationlog.AlertTable, notificationlog.AlertColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Alert
		step.Edge.Schema = schemaConfig.NotificationLog
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryWebhook queries the webhook edge of a NotificationLog.
func (c *NotificationLogClient) QueryWebhook(_m *NotificationLog) *WebhookQuery {
	query := (&WebhookClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(notificationlog.Table, notificationlog.FieldID, id),
			sqlgraph.To(webhook.Table, webhook.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, notificationlog.WebhookTable, notificationlog.WebhookColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Webhook
		step.Edge.Schema = schemaConfig.NotificationLog
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *NotificationLogClient) Hooks() []Hook {
	return c.hooks.NotificationLog
}

// Interceptors returns the client interceptors.
func (c *NotificationLogClient) Interceptors() []Interceptor {
	return c.inters.NotificationLog
}

func (c *NotificationLogClient) mutate(ctx context.Context, m *NotificationLogMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&NotificationLogCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&NotificationLogUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&NotificationLogUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&NotificationLogDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown NotificationLog mutation op: %q", m.Op())
	}
}

// NotificationSettingsClient is a client for the NotificationSettings schema.
type NotificationSettingsClient struct {
	config
}

// NewNotificationSettingsClient returns a client for the NotificationSettings from the given config.
func NewNotificationSettingsClient(c config) *NotificationSettingsClient {
	return &NotificationSettingsClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `notificationsettings.Hooks(f(g(h())))`.
func (c *NotificationSettingsClient) Use(hooks ...Hook) {
	c.hooks.NotificationSettings = append(c.hooks.NotificationSettings, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `notificationsettings.Intercept(f(g(h())))`.
func (c *NotificationSettingsClient) Intercept(interceptors ...Interceptor) {
	c.inters.NotificationSettings = append(c.inters.NotificationSettings, interceptors...)
}

// Create returns a builder for creating a NotificationSettings entity.
func (c *NotificationSettingsClient) Create() *NotificationSettingsCreate {
	mutation := newNotificationSettingsMutation(c.config, OpCreate)
	return &NotificationSettingsCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of NotificationSettings entities.
func (c *NotificationSettingsClient) CreateBulk(builders ...*NotificationSettingsCreate) *NotificationSettingsCreateBulk {
	return &NotificationSettingsCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *NotificationSettingsClient) MapCreateBulk(slice any, setFunc func(*NotificationSettingsCreate, int)) *NotificationSettingsCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &NotificationSettingsCreateBulk{err: fmt.Errorf("calling to NotificationSettingsClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*NotificationSettingsCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &NotificationSettingsCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for NotificationSettings.
func (c *NotificationSettingsClient) Update() *NotificationSettingsUpdate {
	mutation := newNotificationSettingsMutation(c.config, OpUpdate)
	return &NotificationSettingsUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *NotificationSettingsClient) UpdateOne(_m *NotificationSettings) *NotificationSettingsUpdateOne {
	mutation := newNotificationSettingsMutation(c.config, OpUpdateOne, withNotificationSettings(_m))
	return &NotificationSettingsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *NotificationSettingsClient) UpdateOneID(id string) *NotificationSettingsUpdateOne {
	mutation := newNotificationSettingsMutation(c.config, OpUpdateOne, withNotificationSettingsID(id))
	return &NotificationSettingsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for NotificationSettings.
func (c *NotificationSettingsClient) Delete() *NotificationSettingsDelete {
	mutation := newNotificationSettingsMutation(c.config, OpDelete)
	return &NotificationSettingsDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *NotificationSettingsClient) DeleteOne(_m *NotificationSettings) *NotificationSettingsDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *NotificationSettingsClient) DeleteOneID(id string) *NotificationSettingsDeleteOne {
	builder := c.Delete().Where(notificationsettings.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &NotificationSettingsDeleteOne{builder}
}

// Query returns a query builder for NotificationSettings.
func (c *NotificationSettingsClient) Query() *NotificationSettingsQuery {
	return &NotificationSettingsQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeNotificationSettings},
		inters: c.Interceptors(),
	}
}

// Get returns a NotificationSettings entity by its id.
func (c *NotificationSettingsClient) Get(ctx context.Context, id string) (*NotificationSettings, error) {
	return c.Query().Where(notificationsettings.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *NotificationSettingsClient) GetX(ctx context.Context, id string) *NotificationSettings {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *NotificationSettingsClient) Hooks() []Hook {
	return c.hooks.NotificationSettings
}

// Interceptors returns the client interceptors.
func (c *NotificationSettingsClient) Interceptors() []Interceptor {
	return c.inters.NotificationSettings
}

func (c *NotificationSettingsClient) mutate(ctx context.Context, m *NotificationSettingsMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&NotificationSettingsCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&NotificationSettingsUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&NotificationSettingsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&NotificationSettingsDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown NotificationSettings mutation op: %q", m.Op())
	}
}

// PortAllocationClient is a client for the PortAllocation schema.
type PortAllocationClient struct {
	config
}

// NewPortAllocationClient returns a client for the PortAllocation from the given config.
func NewPortAllocationClient(c config) *PortAllocationClient {
	return &PortAllocationClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `portallocation.Hooks(f(g(h())))`.
func (c *PortAllocationClient) Use(hooks ...Hook) {
	c.hooks.PortAllocation = append(c.hooks.PortAllocation, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `portallocation.Intercept(f(g(h())))`.
func (c *PortAllocationClient) Intercept(interceptors ...Interceptor) {
	c.inters.PortAllocation = append(c.inters.PortAllocation, interceptors...)
}

// Create returns a builder for creating a PortAllocation entity.
func (c *PortAllocationClient) Create() *PortAllocationCreate {
	mutation := newPortAllocationMutation(c.config, OpCreate)
	return &PortAllocationCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of PortAllocation entities.
func (c *PortAllocationClient) CreateBulk(builders ...*PortAllocationCreate) *PortAllocationCreateBulk {
	return &PortAllocationCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *PortAllocationClient) MapCreateBulk(slice any, setFunc func(*PortAllocationCreate, int)) *PortAllocationCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &PortAllocationCreateBulk{err: fmt.Errorf("calling to PortAllocationClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*PortAllocationCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &PortAllocationCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for PortAllocation.
func (c *PortAllocationClient) Update() *PortAllocationUpdate {
	mutation := newPortAllocationMutation(c.config, OpUpdate)
	return &PortAllocationUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PortAllocationClient) UpdateOne(_m *PortAllocation) *PortAllocationUpdateOne {
	mutation := newPortAllocationMutation(c.config, OpUpdateOne, withPortAllocation(_m))
	return &PortAllocationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PortAllocationClient) UpdateOneID(id string) *PortAllocationUpdateOne {
	mutation := newPortAllocationMutation(c.config, OpUpdateOne, withPortAllocationID(id))
	return &PortAllocationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for PortAllocation.
func (c *PortAllocationClient) Delete() *PortAllocationDelete {
	mutation := newPortAllocationMutation(c.config, OpDelete)
	return &PortAllocationDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *PortAllocationClient) DeleteOne(_m *PortAllocation) *PortAllocationDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *PortAllocationClient) DeleteOneID(id string) *PortAllocationDeleteOne {
	builder := c.Delete().Where(portallocation.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PortAllocationDeleteOne{builder}
}

// Query returns a query builder for PortAllocation.
func (c *PortAllocationClient) Query() *PortAllocationQuery {
	return &PortAllocationQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypePortAllocation},
		inters: c.Interceptors(),
	}
}

// Get returns a PortAllocation entity by its id.
func (c *PortAllocationClient) Get(ctx context.Context, id string) (*PortAllocation, error) {
	return c.Query().Where(portallocation.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PortAllocationClient) GetX(ctx context.Context, id string) *PortAllocation {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryRouter queries the router edge of a PortAllocation.
func (c *PortAllocationClient) QueryRouter(_m *PortAllocation) *RouterQuery {
	query := (&RouterClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(portallocation.Table, portallocation.FieldID, id),
			sqlgraph.To(router.Table, router.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, portallocation.RouterTable, portallocation.RouterColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Router
		step.Edge.Schema = schemaConfig.PortAllocation
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryServiceInstance queries the service_instance edge of a PortAllocation.
func (c *PortAllocationClient) QueryServiceInstance(_m *PortAllocation) *ServiceInstanceQuery {
	query := (&ServiceInstanceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(portallocation.Table, portallocation.FieldID, id),
			sqlgraph.To(serviceinstance.Table, serviceinstance.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, portallocation.ServiceInstanceTable, portallocation.ServiceInstanceColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.ServiceInstance
		step.Edge.Schema = schemaConfig.PortAllocation
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *PortAllocationClient) Hooks() []Hook {
	return c.hooks.PortAllocation
}

// Interceptors returns the client interceptors.
func (c *PortAllocationClient) Interceptors() []Interceptor {
	return c.inters.PortAllocation
}

func (c *PortAllocationClient) mutate(ctx context.Context, m *PortAllocationMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&PortAllocationCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&PortAllocationUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&PortAllocationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&PortAllocationDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown PortAllocation mutation op: %q", m.Op())
	}
}

// PortKnockSequenceClient is a client for the PortKnockSequence schema.
type PortKnockSequenceClient struct {
	config
}

// NewPortKnockSequenceClient returns a client for the PortKnockSequence from the given config.
func NewPortKnockSequenceClient(c config) *PortKnockSequenceClient {
	return &PortKnockSequenceClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `portknocksequence.Hooks(f(g(h())))`.
func (c *PortKnockSequenceClient) Use(hooks ...Hook) {
	c.hooks.PortKnockSequence = append(c.hooks.PortKnockSequence, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `portknocksequence.Intercept(f(g(h())))`.
func (c *PortKnockSequenceClient) Intercept(interceptors ...Interceptor) {
	c.inters.PortKnockSequence = append(c.inters.PortKnockSequence, interceptors...)
}

// Create returns a builder for creating a PortKnockSequence entity.
func (c *PortKnockSequenceClient) Create() *PortKnockSequenceCreate {
	mutation := newPortKnockSequenceMutation(c.config, OpCreate)
	return &PortKnockSequenceCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of PortKnockSequence entities.
func (c *PortKnockSequenceClient) CreateBulk(builders ...*PortKnockSequenceCreate) *PortKnockSequenceCreateBulk {
	return &PortKnockSequenceCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *PortKnockSequenceClient) MapCreateBulk(slice any, setFunc func(*PortKnockSequenceCreate, int)) *PortKnockSequenceCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &PortKnockSequenceCreateBulk{err: fmt.Errorf("calling to PortKnockSequenceClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*PortKnockSequenceCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &PortKnockSequenceCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for PortKnockSequence.
func (c *PortKnockSequenceClient) Update() *PortKnockSequenceUpdate {
	mutation := newPortKnockSequenceMutation(c.config, OpUpdate)
	return &PortKnockSequenceUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PortKnockSequenceClient) UpdateOne(_m *PortKnockSequence) *PortKnockSequenceUpdateOne {
	mutation := newPortKnockSequenceMutation(c.config, OpUpdateOne, withPortKnockSequence(_m))
	return &PortKnockSequenceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PortKnockSequenceClient) UpdateOneID(id string) *PortKnockSequenceUpdateOne {
	mutation := newPortKnockSequenceMutation(c.config, OpUpdateOne, withPortKnockSequenceID(id))
	return &PortKnockSequenceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for PortKnockSequence.
func (c *PortKnockSequenceClient) Delete() *PortKnockSequenceDelete {
	mutation := newPortKnockSequenceMutation(c.config, OpDelete)
	return &PortKnockSequenceDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *PortKnockSequenceClient) DeleteOne(_m *PortKnockSequence) *PortKnockSequenceDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *PortKnockSequenceClient) DeleteOneID(id string) *PortKnockSequenceDeleteOne {
	builder := c.Delete().Where(portknocksequence.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PortKnockSequenceDeleteOne{builder}
}

// Query returns a query builder for PortKnockSequence.
func (c *PortKnockSequenceClient) Query() *PortKnockSequenceQuery {
	return &PortKnockSequenceQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypePortKnockSequence},
		inters: c.Interceptors(),
	}
}

// Get returns a PortKnockSequence entity by its id.
func (c *PortKnockSequenceClient) Get(ctx context.Context, id string) (*PortKnockSequence, error) {
	return c.Query().Where(portknocksequence.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PortKnockSequenceClient) GetX(ctx context.Context, id string) *PortKnockSequence {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryRouter queries the router edge of a PortKnockSequence.
func (c *PortKnockSequenceClient) QueryRouter(_m *PortKnockSequence) *RouterQuery {
	query := (&RouterClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(portknocksequence.Table, portknocksequence.FieldID, id),
			sqlgraph.To(router.Table, router.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, portknocksequence.RouterTable, portknocksequence.RouterColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Router
		step.Edge.Schema = schemaConfig.PortKnockSequence
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *PortKnockSequenceClient) Hooks() []Hook {
	return c.hooks.PortKnockSequence
}

// Interceptors returns the client interceptors.
func (c *PortKnockSequenceClient) Interceptors() []Interceptor {
	return c.inters.PortKnockSequence
}

func (c *PortKnockSequenceClient) mutate(ctx context.Context, m *PortKnockSequenceMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&PortKnockSequenceCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&PortKnockSequenceUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&PortKnockSequenceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&PortKnockSequenceDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown PortKnockSequence mutation op: %q", m.Op())
	}
}

// ProvisioningSessionClient is a client for the ProvisioningSession schema.
type ProvisioningSessionClient struct {
	config
}

// NewProvisioningSessionClient returns a client for the ProvisioningSession from the given config.
func NewProvisioningSessionClient(c config) *ProvisioningSessionClient {
	return &ProvisioningSessionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `provisioningsession.Hooks(f(g(h())))`.
func (c *ProvisioningSessionClient) Use(hooks ...Hook) {
	c.hooks.ProvisioningSession = append(c.hooks.ProvisioningSession, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `provisioningsession.Intercept(f(g(h())))`.
func (c *ProvisioningSessionClient) Intercept(interceptors ...Interceptor) {
	c.inters.ProvisioningSession = append(c.inters.ProvisioningSession, interceptors...)
}

// Create returns a builder for creating a ProvisioningSession entity.
func (c *ProvisioningSessionClient) Create() *ProvisioningSessionCreate {
	mutation := newProvisioningSessionMutation(c.config, OpCreate)
	return &ProvisioningSessionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ProvisioningSession entities.
func (c *ProvisioningSessionClient) CreateBulk(builders ...*ProvisioningSessionCreate) *ProvisioningSessionCreateBulk {
	return &ProvisioningSessionCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ProvisioningSessionClient) MapCreateBulk(slice any, setFunc func(*ProvisioningSessionCreate, int)) *ProvisioningSessionCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ProvisioningSessionCreateBulk{err: fmt.Errorf("calling to ProvisioningSessionClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ProvisioningSessionCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ProvisioningSessionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ProvisioningSession.
func (c *ProvisioningSessionClient) Update() *ProvisioningSessionUpdate {
	mutation := newProvisioningSessionMutation(c.config, OpUpdate)
	return &ProvisioningSessionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ProvisioningSessionClient) UpdateOne(_m *ProvisioningSession) *ProvisioningSessionUpdateOne {
	mutation := newProvisioningSessionMutation(c.config, OpUpdateOne, withProvisioningSession(_m))
	return &ProvisioningSessionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ProvisioningSessionClient) UpdateOneID(id string) *ProvisioningSessionUpdateOne {
	mutation := newProvisioningSessionMutation(c.config, OpUpdateOne, withProvisioningSessionID(id))
	return &ProvisioningSessionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ProvisioningSession.
func (c *ProvisioningSessionClient) Delete() *ProvisioningSessionDelete {
	mutation := newProvisioningSessionMutation(c.config, OpDelete)
	return &ProvisioningSessionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ProvisioningSessionClient) DeleteOne(_m *ProvisioningSession) *ProvisioningSessionDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ProvisioningSessionClient) DeleteOneID(id string) *ProvisioningSessionDeleteOne {
	builder := c.Delete().Where(provisioningsession.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ProvisioningSessionDeleteOne{builder}
}

// Query returns a query builder for ProvisioningSession.
func (c *ProvisioningSessionClient) Query() *ProvisioningSessionQuery {
	return &ProvisioningSessionQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeProvisioningSession},
		inters: c.Interceptors(),
	}
}

// Get returns a ProvisioningSession entity by its id.
func (c *ProvisioningSessionClient) Get(ctx context.Context, id string) (*ProvisioningSession, error) {
	return c.Query().Where(provisioningsession.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ProvisioningSessionClient) GetX(ctx context.Context, id string) *ProvisioningSession {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryRouter queries the router edge of a ProvisioningSession.
func (c *ProvisioningSessionClient) QueryRouter(_m *ProvisioningSession) *RouterQuery {
	query := (&RouterClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(provisioningsession.Table, provisioningsession.FieldID, id),
			sqlgraph.To(router.Table, router.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, provisioningsession.RouterTable, provisioningsession.RouterColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Router
		step.Edge.Schema = schemaConfig.ProvisioningSession
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ProvisioningSessionClient) Hooks() []Hook {
	return c.hooks.ProvisioningSession
}

// Interceptors returns the client interceptors.
func (c *ProvisioningSessionClient) Interceptors() []Interceptor {
	return c.inters.ProvisioningSession
}

func (c *ProvisioningSessionClient) mutate(ctx context.Context, m *ProvisioningSessionMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ProvisioningSessionCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ProvisioningSessionUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ProvisioningSessionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ProvisioningSessionDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown ProvisioningSession mutation op: %q", m.Op())
	}
}

// ResourceClient is a client for the Resource schema.
type ResourceClient struct {
	config
}

// NewResourceClient returns a client for the Resource from the given config.
func NewResourceClient(c config) *ResourceClient {
	return &ResourceClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `resource.Hooks(f(g(h())))`.
func (c *ResourceClient) Use(hooks ...Hook) {
	c.hooks.Resource = append(c.hooks.Resource, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `resource.Intercept(f(g(h())))`.
func (c *ResourceClient) Intercept(interceptors ...Interceptor) {
	c.inters.Resource = append(c.inters.Resource, interceptors...)
}

// Create returns a builder for creating a Resource entity.
func (c *ResourceClient) Create() *ResourceCreate {
	mutation := newResourceMutation(c.config, OpCreate)
	return &ResourceCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Resource entities.
func (c *ResourceClient) CreateBulk(builders ...*ResourceCreate) *ResourceCreateBulk {
	return &ResourceCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ResourceClient) MapCreateBulk(slice any, setFunc func(*ResourceCreate, int)) *ResourceCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ResourceCreateBulk{err: fmt.Errorf("calling to ResourceClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ResourceCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ResourceCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Resource.
func (c *ResourceClient) Update() *ResourceUpdate {
	mutation := newResourceMutation(c.config, OpUpdate)
	return &ResourceUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ResourceClient) UpdateOne(_m *Resource) *ResourceUpdateOne {
	mutation := newResourceMutation(c.config, OpUpdateOne, withResource(_m))
	return &ResourceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ResourceClient) UpdateOneID(id string) *ResourceUpdateOne {
	mutation := newResourceMutation(c.config, OpUpdateOne, withResourceID(id))
	return &ResourceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Resource.
func (c *ResourceClient) Delete() *ResourceDelete {
	mutation := newResourceMutation(c.config, OpDelete)
	return &ResourceDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ResourceClient) DeleteOne(_m *Resource) *ResourceDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ResourceClient) DeleteOneID(id string) *ResourceDeleteOne {
	builder := c.Delete().Where(resource.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ResourceDeleteOne{builder}
}

// Query returns a query builder for Resource.
func (c *ResourceClient) Query() *ResourceQuery {
	return &ResourceQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeResource},
		inters: c.Interceptors(),
	}
}

// Get returns a Resource entity by its id.
func (c *ResourceClient) Get(ctx context.Context, id string) (*Resource, error) {
	return c.Query().Where(resource.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ResourceClient) GetX(ctx context.Context, id string) *Resource {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryEvents queries the events edge of a Resource.
func (c *ResourceClient) QueryEvents(_m *Resource) *ResourceEventQuery {
	query := (&ResourceEventClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(resource.Table, resource.FieldID, id),
			sqlgraph.To(resourceevent.Table, resourceevent.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, resource.EventsTable, resource.EventsColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.ResourceEvent
		step.Edge.Schema = schemaConfig.ResourceEvent
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ResourceClient) Hooks() []Hook {
	return c.hooks.Resource
}

// Interceptors returns the client interceptors.
func (c *ResourceClient) Interceptors() []Interceptor {
	return c.inters.Resource
}

func (c *ResourceClient) mutate(ctx context.Context, m *ResourceMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ResourceCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ResourceUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ResourceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ResourceDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Resource mutation op: %q", m.Op())
	}
}

// ResourceEventClient is a client for the ResourceEvent schema.
type ResourceEventClient struct {
	config
}

// NewResourceEventClient returns a client for the ResourceEvent from the given config.
func NewResourceEventClient(c config) *ResourceEventClient {
	return &ResourceEventClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `resourceevent.Hooks(f(g(h())))`.
func (c *ResourceEventClient) Use(hooks ...Hook) {
	c.hooks.ResourceEvent = append(c.hooks.ResourceEvent, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `resourceevent.Intercept(f(g(h())))`.
func (c *ResourceEventClient) Intercept(interceptors ...Interceptor) {
	c.inters.ResourceEvent = append(c.inters.ResourceEvent, interceptors...)
}

// Create returns a builder for creating a ResourceEvent entity.
func (c *ResourceEventClient) Create() *ResourceEventCreate {
	mutation := newResourceEventMutation(c.config, OpCreate)
	return &ResourceEventCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ResourceEvent entities.
func (c *ResourceEventClient) CreateBulk(builders ...*ResourceEventCreate) *ResourceEventCreateBulk {
	return &ResourceEventCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ResourceEventClient) MapCreateBulk(slice any, setFunc func(*ResourceEventCreate, int)) *ResourceEventCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ResourceEventCreateBulk{err: fmt.Errorf("calling to ResourceEventClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ResourceEventCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ResourceEventCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ResourceEvent.
func (c *ResourceEventClient) Update() *ResourceEventUpdate {
	mutation := newResourceEventMutation(c.config, OpUpdate)
	return &ResourceEventUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ResourceEventClient) UpdateOne(_m *ResourceEvent) *ResourceEventUpdateOne {
	mutation := newResourceEventMutation(c.config, OpUpdateOne, withResourceEvent(_m))
	return &ResourceEventUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ResourceEventClient) UpdateOneID(id string) *ResourceEventUpdateOne {
	mutation := newResourceEventMutation(c.config, OpUpdateOne, withResourceEventID(id))
	return &ResourceEventUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ResourceEvent.
func (c *ResourceEventClient) Delete() *ResourceEventDelete {
	mutation := newResourceEventMutation(c.config, OpDelete)
	return &ResourceEventDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ResourceEventClient) DeleteOne(_m *ResourceEvent) *ResourceEventDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ResourceEventClient) DeleteOneID(id string) *ResourceEventDeleteOne {
	builder := c.Delete().Where(resourceevent.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ResourceEventDeleteOne{builder}
}

// Query returns a query builder for ResourceEvent.
func (c *ResourceEventClient) Query() *ResourceEventQuery {
	return &ResourceEventQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeResourceEvent},
		inters: c.Interceptors(),
	}
}

// Get returns a ResourceEvent entity by its id.
func (c *ResourceEventClient) Get(ctx context.Context, id string) (*ResourceEvent, error) {
	return c.Query().Where(resourceevent.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ResourceEventClient) GetX(ctx context.Context, id string) *ResourceEvent {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryResource queries the resource edge of a ResourceEvent.
func (c *ResourceEventClient) QueryResource(_m *ResourceEvent) *ResourceQuery {
	query := (&ResourceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(resourceevent.Table, resourceevent.FieldID, id),
			sqlgraph.To(resource.Table, resource.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, resourceevent.ResourceTable, resourceevent.ResourceColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Resource
		step.Edge.Schema = schemaConfig.ResourceEvent
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ResourceEventClient) Hooks() []Hook {
	return c.hooks.ResourceEvent
}

// Interceptors returns the client interceptors.
func (c *ResourceEventClient) Interceptors() []Interceptor {
	return c.inters.ResourceEvent
}

func (c *ResourceEventClient) mutate(ctx context.Context, m *ResourceEventMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ResourceEventCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ResourceEventUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ResourceEventUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ResourceEventDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown ResourceEvent mutation op: %q", m.Op())
	}
}

// RouterClient is a client for the Router schema.
type RouterClient struct {
	config
}

// NewRouterClient returns a client for the Router from the given config.
func NewRouterClient(c config) *RouterClient {
	return &RouterClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `router.Hooks(f(g(h())))`.
func (c *RouterClient) Use(hooks ...Hook) {
	c.hooks.Router = append(c.hooks.Router, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `router.Intercept(f(g(h())))`.
func (c *RouterClient) Intercept(interceptors ...Interceptor) {
	c.inters.Router = append(c.inters.Router, interceptors...)
}

// Create returns a builder for creating a Router entity.
func (c *RouterClient) Create() *RouterCreate {
	mutation := newRouterMutation(c.config, OpCreate)
	return &RouterCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Router entities.
func (c *RouterClient) CreateBulk(builders ...*RouterCreate) *RouterCreateBulk {
	return &RouterCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *RouterClient) MapCreateBulk(slice any, setFunc func(*RouterCreate, int)) *RouterCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &RouterCreateBulk{err: fmt.Errorf("calling to RouterClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*RouterCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &RouterCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Router.
func (c *RouterClient) Update() *RouterUpdate {
	mutation := newRouterMutation(c.config, OpUpdate)
	return &RouterUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *RouterClient) UpdateOne(_m *Router) *RouterUpdateOne {
	mutation := newRouterMutation(c.config, OpUpdateOne, withRouter(_m))
	return &RouterUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *RouterClient) UpdateOneID(id string) *RouterUpdateOne {
	mutation := newRouterMutation(c.config, OpUpdateOne, withRouterID(id))
	return &RouterUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Router.
func (c *RouterClient) Delete() *RouterDelete {
	mutation := newRouterMutation(c.config, OpDelete)
	return &RouterDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *RouterClient) DeleteOne(_m *Router) *RouterDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *RouterClient) DeleteOneID(id string) *RouterDeleteOne {
	builder := c.Delete().Where(router.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &RouterDeleteOne{builder}
}

// Query returns a query builder for Router.
func (c *RouterClient) Query() *RouterQuery {
	return &RouterQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeRouter},
		inters: c.Interceptors(),
	}
}

// Get returns a Router entity by its id.
func (c *RouterClient) Get(ctx context.Context, id string) (*Router, error) {
	return c.Query().Where(router.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *RouterClient) GetX(ctx context.Context, id string) *Router {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QuerySecrets queries the secrets edge of a Router.
func (c *RouterClient) QuerySecrets(_m *Router) *RouterSecretQuery {
	query := (&RouterSecretClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(router.Table, router.FieldID, id),
			sqlgraph.To(routersecret.Table, routersecret.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, router.SecretsTable, router.SecretsColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.RouterSecret
		step.Edge.Schema = schemaConfig.RouterSecret
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPortKnockSequences queries the port_knock_sequences edge of a Router.
func (c *RouterClient) QueryPortKnockSequences(_m *Router) *PortKnockSequenceQuery {
	query := (&PortKnockSequenceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(router.Table, router.FieldID, id),
			sqlgraph.To(portknocksequence.Table, portknocksequence.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, router.PortKnockSequencesTable, router.PortKnockSequencesColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.PortKnockSequence
		step.Edge.Schema = schemaConfig.PortKnockSequence
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryServiceInstances queries the service_instances edge of a Router.
func (c *RouterClient) QueryServiceInstances(_m *Router) *ServiceInstanceQuery {
	query := (&ServiceInstanceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(router.Table, router.FieldID, id),
			sqlgraph.To(serviceinstance.Table, serviceinstance.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, router.ServiceInstancesTable, router.ServiceInstancesColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.ServiceInstance
		step.Edge.Schema = schemaConfig.ServiceInstance
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPortAllocations queries the port_allocations edge of a Router.
func (c *RouterClient) QueryPortAllocations(_m *Router) *PortAllocationQuery {
	query := (&PortAllocationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(router.Table, router.FieldID, id),
			sqlgraph.To(portallocation.Table, portallocation.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, router.PortAllocationsTable, router.PortAllocationsColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.PortAllocation
		step.Edge.Schema = schemaConfig.PortAllocation
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryVlanAllocations queries the vlan_allocations edge of a Router.
func (c *RouterClient) QueryVlanAllocations(_m *Router) *VLANAllocationQuery {
	query := (&VLANAllocationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(router.Table, router.FieldID, id),
			sqlgraph.To(vlanallocation.Table, vlanallocation.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, router.VlanAllocationsTable, router.VlanAllocationsColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.VLANAllocation
		step.Edge.Schema = schemaConfig.VLANAllocation
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryDeviceRoutings queries the device_routings edge of a Router.
func (c *RouterClient) QueryDeviceRoutings(_m *Router) *DeviceRoutingQuery {
	query := (&DeviceRoutingClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(router.Table, router.FieldID, id),
			sqlgraph.To(devicerouting.Table, devicerouting.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, router.DeviceRoutingsTable, router.DeviceRoutingsColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.DeviceRouting
		step.Edge.Schema = schemaConfig.DeviceRouting
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryRoutingChains queries the routing_chains edge of a Router.
func (c *RouterClient) QueryRoutingChains(_m *Router) *RoutingChainQuery {
	query := (&RoutingChainClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(router.Table, router.FieldID, id),
			sqlgraph.To(routingchain.Table, routingchain.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, router.RoutingChainsTable, router.RoutingChainsColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.RoutingChain
		step.Edge.Schema = schemaConfig.RoutingChain
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryServiceTemplates queries the service_templates edge of a Router.
func (c *RouterClient) QueryServiceTemplates(_m *Router) *ServiceTemplateQuery {
	query := (&ServiceTemplateClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(router.Table, router.FieldID, id),
			sqlgraph.To(servicetemplate.Table, servicetemplate.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, router.ServiceTemplatesTable, router.ServiceTemplatesColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.ServiceTemplate
		step.Edge.Schema = schemaConfig.ServiceTemplate
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryProvisioningSessions queries the provisioning_sessions edge of a Router.
func (c *RouterClient) QueryProvisioningSessions(_m *Router) *ProvisioningSessionQuery {
	query := (&ProvisioningSessionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(router.Table, router.FieldID, id),
			sqlgraph.To(provisioningsession.Table, provisioningsession.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, router.ProvisioningSessionsTable, router.ProvisioningSessionsColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.ProvisioningSession
		step.Edge.Schema = schemaConfig.ProvisioningSession
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySubnetAllocations queries the subnet_allocations edge of a Router.
func (c *RouterClient) QuerySubnetAllocations(_m *Router) *SubnetAllocationQuery {
	query := (&SubnetAllocationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(router.Table, router.FieldID, id),
			sqlgraph.To(subnetallocation.Table, subnetallocation.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, router.SubnetAllocationsTable, router.SubnetAllocationsColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.SubnetAllocation
		step.Edge.Schema = schemaConfig.SubnetAllocation
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *RouterClient) Hooks() []Hook {
	return c.hooks.Router
}

// Interceptors returns the client interceptors.
func (c *RouterClient) Interceptors() []Interceptor {
	return c.inters.Router
}

func (c *RouterClient) mutate(ctx context.Context, m *RouterMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&RouterCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&RouterUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&RouterUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&RouterDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Router mutation op: %q", m.Op())
	}
}

// RouterCapabilityClient is a client for the RouterCapability schema.
type RouterCapabilityClient struct {
	config
}

// NewRouterCapabilityClient returns a client for the RouterCapability from the given config.
func NewRouterCapabilityClient(c config) *RouterCapabilityClient {
	return &RouterCapabilityClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `routercapability.Hooks(f(g(h())))`.
func (c *RouterCapabilityClient) Use(hooks ...Hook) {
	c.hooks.RouterCapability = append(c.hooks.RouterCapability, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `routercapability.Intercept(f(g(h())))`.
func (c *RouterCapabilityClient) Intercept(interceptors ...Interceptor) {
	c.inters.RouterCapability = append(c.inters.RouterCapability, interceptors...)
}

// Create returns a builder for creating a RouterCapability entity.
func (c *RouterCapabilityClient) Create() *RouterCapabilityCreate {
	mutation := newRouterCapabilityMutation(c.config, OpCreate)
	return &RouterCapabilityCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of RouterCapability entities.
func (c *RouterCapabilityClient) CreateBulk(builders ...*RouterCapabilityCreate) *RouterCapabilityCreateBulk {
	return &RouterCapabilityCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *RouterCapabilityClient) MapCreateBulk(slice any, setFunc func(*RouterCapabilityCreate, int)) *RouterCapabilityCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &RouterCapabilityCreateBulk{err: fmt.Errorf("calling to RouterCapabilityClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*RouterCapabilityCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &RouterCapabilityCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for RouterCapability.
func (c *RouterCapabilityClient) Update() *RouterCapabilityUpdate {
	mutation := newRouterCapabilityMutation(c.config, OpUpdate)
	return &RouterCapabilityUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *RouterCapabilityClient) UpdateOne(_m *RouterCapability) *RouterCapabilityUpdateOne {
	mutation := newRouterCapabilityMutation(c.config, OpUpdateOne, withRouterCapability(_m))
	return &RouterCapabilityUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *RouterCapabilityClient) UpdateOneID(id string) *RouterCapabilityUpdateOne {
	mutation := newRouterCapabilityMutation(c.config, OpUpdateOne, withRouterCapabilityID(id))
	return &RouterCapabilityUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for RouterCapability.
func (c *RouterCapabilityClient) Delete() *RouterCapabilityDelete {
	mutation := newRouterCapabilityMutation(c.config, OpDelete)
	return &RouterCapabilityDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *RouterCapabilityClient) DeleteOne(_m *RouterCapability) *RouterCapabilityDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *RouterCapabilityClient) DeleteOneID(id string) *RouterCapabilityDeleteOne {
	builder := c.Delete().Where(routercapability.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &RouterCapabilityDeleteOne{builder}
}

// Query returns a query builder for RouterCapability.
func (c *RouterCapabilityClient) Query() *RouterCapabilityQuery {
	return &RouterCapabilityQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeRouterCapability},
		inters: c.Interceptors(),
	}
}

// Get returns a RouterCapability entity by its id.
func (c *RouterCapabilityClient) Get(ctx context.Context, id string) (*RouterCapability, error) {
	return c.Query().Where(routercapability.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *RouterCapabilityClient) GetX(ctx context.Context, id string) *RouterCapability {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *RouterCapabilityClient) Hooks() []Hook {
	return c.hooks.RouterCapability
}

// Interceptors returns the client interceptors.
func (c *RouterCapabilityClient) Interceptors() []Interceptor {
	return c.inters.RouterCapability
}

func (c *RouterCapabilityClient) mutate(ctx context.Context, m *RouterCapabilityMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&RouterCapabilityCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&RouterCapabilityUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&RouterCapabilityUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&RouterCapabilityDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown RouterCapability mutation op: %q", m.Op())
	}
}

// RouterSecretClient is a client for the RouterSecret schema.
type RouterSecretClient struct {
	config
}

// NewRouterSecretClient returns a client for the RouterSecret from the given config.
func NewRouterSecretClient(c config) *RouterSecretClient {
	return &RouterSecretClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `routersecret.Hooks(f(g(h())))`.
func (c *RouterSecretClient) Use(hooks ...Hook) {
	c.hooks.RouterSecret = append(c.hooks.RouterSecret, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `routersecret.Intercept(f(g(h())))`.
func (c *RouterSecretClient) Intercept(interceptors ...Interceptor) {
	c.inters.RouterSecret = append(c.inters.RouterSecret, interceptors...)
}

// Create returns a builder for creating a RouterSecret entity.
func (c *RouterSecretClient) Create() *RouterSecretCreate {
	mutation := newRouterSecretMutation(c.config, OpCreate)
	return &RouterSecretCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of RouterSecret entities.
func (c *RouterSecretClient) CreateBulk(builders ...*RouterSecretCreate) *RouterSecretCreateBulk {
	return &RouterSecretCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *RouterSecretClient) MapCreateBulk(slice any, setFunc func(*RouterSecretCreate, int)) *RouterSecretCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &RouterSecretCreateBulk{err: fmt.Errorf("calling to RouterSecretClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*RouterSecretCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &RouterSecretCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for RouterSecret.
func (c *RouterSecretClient) Update() *RouterSecretUpdate {
	mutation := newRouterSecretMutation(c.config, OpUpdate)
	return &RouterSecretUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *RouterSecretClient) UpdateOne(_m *RouterSecret) *RouterSecretUpdateOne {
	mutation := newRouterSecretMutation(c.config, OpUpdateOne, withRouterSecret(_m))
	return &RouterSecretUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *RouterSecretClient) UpdateOneID(id string) *RouterSecretUpdateOne {
	mutation := newRouterSecretMutation(c.config, OpUpdateOne, withRouterSecretID(id))
	return &RouterSecretUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for RouterSecret.
func (c *RouterSecretClient) Delete() *RouterSecretDelete {
	mutation := newRouterSecretMutation(c.config, OpDelete)
	return &RouterSecretDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *RouterSecretClient) DeleteOne(_m *RouterSecret) *RouterSecretDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *RouterSecretClient) DeleteOneID(id string) *RouterSecretDeleteOne {
	builder := c.Delete().Where(routersecret.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &RouterSecretDeleteOne{builder}
}

// Query returns a query builder for RouterSecret.
func (c *RouterSecretClient) Query() *RouterSecretQuery {
	return &RouterSecretQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeRouterSecret},
		inters: c.Interceptors(),
	}
}

// Get returns a RouterSecret entity by its id.
func (c *RouterSecretClient) Get(ctx context.Context, id string) (*RouterSecret, error) {
	return c.Query().Where(routersecret.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *RouterSecretClient) GetX(ctx context.Context, id string) *RouterSecret {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryRouter queries the router edge of a RouterSecret.
func (c *RouterSecretClient) QueryRouter(_m *RouterSecret) *RouterQuery {
	query := (&RouterClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(routersecret.Table, routersecret.FieldID, id),
			sqlgraph.To(router.Table, router.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, routersecret.RouterTable, routersecret.RouterColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Router
		step.Edge.Schema = schemaConfig.RouterSecret
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *RouterSecretClient) Hooks() []Hook {
	return c.hooks.RouterSecret
}

// Interceptors returns the client interceptors.
func (c *RouterSecretClient) Interceptors() []Interceptor {
	return c.inters.RouterSecret
}

func (c *RouterSecretClient) mutate(ctx context.Context, m *RouterSecretMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&RouterSecretCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&RouterSecretUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&RouterSecretUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&RouterSecretDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown RouterSecret mutation op: %q", m.Op())
	}
}

// RoutingChainClient is a client for the RoutingChain schema.
type RoutingChainClient struct {
	config
}

// NewRoutingChainClient returns a client for the RoutingChain from the given config.
func NewRoutingChainClient(c config) *RoutingChainClient {
	return &RoutingChainClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `routingchain.Hooks(f(g(h())))`.
func (c *RoutingChainClient) Use(hooks ...Hook) {
	c.hooks.RoutingChain = append(c.hooks.RoutingChain, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `routingchain.Intercept(f(g(h())))`.
func (c *RoutingChainClient) Intercept(interceptors ...Interceptor) {
	c.inters.RoutingChain = append(c.inters.RoutingChain, interceptors...)
}

// Create returns a builder for creating a RoutingChain entity.
func (c *RoutingChainClient) Create() *RoutingChainCreate {
	mutation := newRoutingChainMutation(c.config, OpCreate)
	return &RoutingChainCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of RoutingChain entities.
func (c *RoutingChainClient) CreateBulk(builders ...*RoutingChainCreate) *RoutingChainCreateBulk {
	return &RoutingChainCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *RoutingChainClient) MapCreateBulk(slice any, setFunc func(*RoutingChainCreate, int)) *RoutingChainCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &RoutingChainCreateBulk{err: fmt.Errorf("calling to RoutingChainClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*RoutingChainCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &RoutingChainCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for RoutingChain.
func (c *RoutingChainClient) Update() *RoutingChainUpdate {
	mutation := newRoutingChainMutation(c.config, OpUpdate)
	return &RoutingChainUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *RoutingChainClient) UpdateOne(_m *RoutingChain) *RoutingChainUpdateOne {
	mutation := newRoutingChainMutation(c.config, OpUpdateOne, withRoutingChain(_m))
	return &RoutingChainUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *RoutingChainClient) UpdateOneID(id string) *RoutingChainUpdateOne {
	mutation := newRoutingChainMutation(c.config, OpUpdateOne, withRoutingChainID(id))
	return &RoutingChainUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for RoutingChain.
func (c *RoutingChainClient) Delete() *RoutingChainDelete {
	mutation := newRoutingChainMutation(c.config, OpDelete)
	return &RoutingChainDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *RoutingChainClient) DeleteOne(_m *RoutingChain) *RoutingChainDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *RoutingChainClient) DeleteOneID(id string) *RoutingChainDeleteOne {
	builder := c.Delete().Where(routingchain.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &RoutingChainDeleteOne{builder}
}

// Query returns a query builder for RoutingChain.
func (c *RoutingChainClient) Query() *RoutingChainQuery {
	return &RoutingChainQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeRoutingChain},
		inters: c.Interceptors(),
	}
}

// Get returns a RoutingChain entity by its id.
func (c *RoutingChainClient) Get(ctx context.Context, id string) (*RoutingChain, error) {
	return c.Query().Where(routingchain.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *RoutingChainClient) GetX(ctx context.Context, id string) *RoutingChain {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryRouter queries the router edge of a RoutingChain.
func (c *RoutingChainClient) QueryRouter(_m *RoutingChain) *RouterQuery {
	query := (&RouterClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(routingchain.Table, routingchain.FieldID, id),
			sqlgraph.To(router.Table, router.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, routingchain.RouterTable, routingchain.RouterColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Router
		step.Edge.Schema = schemaConfig.RoutingChain
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryHops queries the hops edge of a RoutingChain.
func (c *RoutingChainClient) QueryHops(_m *RoutingChain) *ChainHopQuery {
	query := (&ChainHopClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(routingchain.Table, routingchain.FieldID, id),
			sqlgraph.To(chainhop.Table, chainhop.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, routingchain.HopsTable, routingchain.HopsColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.ChainHop
		step.Edge.Schema = schemaConfig.ChainHop
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *RoutingChainClient) Hooks() []Hook {
	return c.hooks.RoutingChain
}

// Interceptors returns the client interceptors.
func (c *RoutingChainClient) Interceptors() []Interceptor {
	return c.inters.RoutingChain
}

func (c *RoutingChainClient) mutate(ctx context.Context, m *RoutingChainMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&RoutingChainCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&RoutingChainUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&RoutingChainUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&RoutingChainDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown RoutingChain mutation op: %q", m.Op())
	}
}

// RoutingScheduleClient is a client for the RoutingSchedule schema.
type RoutingScheduleClient struct {
	config
}

// NewRoutingScheduleClient returns a client for the RoutingSchedule from the given config.
func NewRoutingScheduleClient(c config) *RoutingScheduleClient {
	return &RoutingScheduleClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `routingschedule.Hooks(f(g(h())))`.
func (c *RoutingScheduleClient) Use(hooks ...Hook) {
	c.hooks.RoutingSchedule = append(c.hooks.RoutingSchedule, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `routingschedule.Intercept(f(g(h())))`.
func (c *RoutingScheduleClient) Intercept(interceptors ...Interceptor) {
	c.inters.RoutingSchedule = append(c.inters.RoutingSchedule, interceptors...)
}

// Create returns a builder for creating a RoutingSchedule entity.
func (c *RoutingScheduleClient) Create() *RoutingScheduleCreate {
	mutation := newRoutingScheduleMutation(c.config, OpCreate)
	return &RoutingScheduleCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of RoutingSchedule entities.
func (c *RoutingScheduleClient) CreateBulk(builders ...*RoutingScheduleCreate) *RoutingScheduleCreateBulk {
	return &RoutingScheduleCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *RoutingScheduleClient) MapCreateBulk(slice any, setFunc func(*RoutingScheduleCreate, int)) *RoutingScheduleCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &RoutingScheduleCreateBulk{err: fmt.Errorf("calling to RoutingScheduleClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*RoutingScheduleCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &RoutingScheduleCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for RoutingSchedule.
func (c *RoutingScheduleClient) Update() *RoutingScheduleUpdate {
	mutation := newRoutingScheduleMutation(c.config, OpUpdate)
	return &RoutingScheduleUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *RoutingScheduleClient) UpdateOne(_m *RoutingSchedule) *RoutingScheduleUpdateOne {
	mutation := newRoutingScheduleMutation(c.config, OpUpdateOne, withRoutingSchedule(_m))
	return &RoutingScheduleUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *RoutingScheduleClient) UpdateOneID(id string) *RoutingScheduleUpdateOne {
	mutation := newRoutingScheduleMutation(c.config, OpUpdateOne, withRoutingScheduleID(id))
	return &RoutingScheduleUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for RoutingSchedule.
func (c *RoutingScheduleClient) Delete() *RoutingScheduleDelete {
	mutation := newRoutingScheduleMutation(c.config, OpDelete)
	return &RoutingScheduleDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *RoutingScheduleClient) DeleteOne(_m *RoutingSchedule) *RoutingScheduleDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *RoutingScheduleClient) DeleteOneID(id string) *RoutingScheduleDeleteOne {
	builder := c.Delete().Where(routingschedule.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &RoutingScheduleDeleteOne{builder}
}

// Query returns a query builder for RoutingSchedule.
func (c *RoutingScheduleClient) Query() *RoutingScheduleQuery {
	return &RoutingScheduleQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeRoutingSchedule},
		inters: c.Interceptors(),
	}
}

// Get returns a RoutingSchedule entity by its id.
func (c *RoutingScheduleClient) Get(ctx context.Context, id string) (*RoutingSchedule, error) {
	return c.Query().Where(routingschedule.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *RoutingScheduleClient) GetX(ctx context.Context, id string) *RoutingSchedule {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryDeviceRouting queries the device_routing edge of a RoutingSchedule.
func (c *RoutingScheduleClient) QueryDeviceRouting(_m *RoutingSchedule) *DeviceRoutingQuery {
	query := (&DeviceRoutingClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(routingschedule.Table, routingschedule.FieldID, id),
			sqlgraph.To(devicerouting.Table, devicerouting.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, routingschedule.DeviceRoutingTable, routingschedule.DeviceRoutingColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.DeviceRouting
		step.Edge.Schema = schemaConfig.RoutingSchedule
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *RoutingScheduleClient) Hooks() []Hook {
	return c.hooks.RoutingSchedule
}

// Interceptors returns the client interceptors.
func (c *RoutingScheduleClient) Interceptors() []Interceptor {
	return c.inters.RoutingSchedule
}

func (c *RoutingScheduleClient) mutate(ctx context.Context, m *RoutingScheduleMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&RoutingScheduleCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&RoutingScheduleUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&RoutingScheduleUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&RoutingScheduleDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown RoutingSchedule mutation op: %q", m.Op())
	}
}

// ServiceDependencyClient is a client for the ServiceDependency schema.
type ServiceDependencyClient struct {
	config
}

// NewServiceDependencyClient returns a client for the ServiceDependency from the given config.
func NewServiceDependencyClient(c config) *ServiceDependencyClient {
	return &ServiceDependencyClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `servicedependency.Hooks(f(g(h())))`.
func (c *ServiceDependencyClient) Use(hooks ...Hook) {
	c.hooks.ServiceDependency = append(c.hooks.ServiceDependency, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `servicedependency.Intercept(f(g(h())))`.
func (c *ServiceDependencyClient) Intercept(interceptors ...Interceptor) {
	c.inters.ServiceDependency = append(c.inters.ServiceDependency, interceptors...)
}

// Create returns a builder for creating a ServiceDependency entity.
func (c *ServiceDependencyClient) Create() *ServiceDependencyCreate {
	mutation := newServiceDependencyMutation(c.config, OpCreate)
	return &ServiceDependencyCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ServiceDependency entities.
func (c *ServiceDependencyClient) CreateBulk(builders ...*ServiceDependencyCreate) *ServiceDependencyCreateBulk {
	return &ServiceDependencyCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ServiceDependencyClient) MapCreateBulk(slice any, setFunc func(*ServiceDependencyCreate, int)) *ServiceDependencyCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ServiceDependencyCreateBulk{err: fmt.Errorf("calling to ServiceDependencyClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ServiceDependencyCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ServiceDependencyCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ServiceDependency.
func (c *ServiceDependencyClient) Update() *ServiceDependencyUpdate {
	mutation := newServiceDependencyMutation(c.config, OpUpdate)
	return &ServiceDependencyUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ServiceDependencyClient) UpdateOne(_m *ServiceDependency) *ServiceDependencyUpdateOne {
	mutation := newServiceDependencyMutation(c.config, OpUpdateOne, withServiceDependency(_m))
	return &ServiceDependencyUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ServiceDependencyClient) UpdateOneID(id string) *ServiceDependencyUpdateOne {
	mutation := newServiceDependencyMutation(c.config, OpUpdateOne, withServiceDependencyID(id))
	return &ServiceDependencyUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ServiceDependency.
func (c *ServiceDependencyClient) Delete() *ServiceDependencyDelete {
	mutation := newServiceDependencyMutation(c.config, OpDelete)
	return &ServiceDependencyDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ServiceDependencyClient) DeleteOne(_m *ServiceDependency) *ServiceDependencyDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ServiceDependencyClient) DeleteOneID(id string) *ServiceDependencyDeleteOne {
	builder := c.Delete().Where(servicedependency.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ServiceDependencyDeleteOne{builder}
}

// Query returns a query builder for ServiceDependency.
func (c *ServiceDependencyClient) Query() *ServiceDependencyQuery {
	return &ServiceDependencyQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeServiceDependency},
		inters: c.Interceptors(),
	}
}

// Get returns a ServiceDependency entity by its id.
func (c *ServiceDependencyClient) Get(ctx context.Context, id string) (*ServiceDependency, error) {
	return c.Query().Where(servicedependency.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ServiceDependencyClient) GetX(ctx context.Context, id string) *ServiceDependency {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryFromInstance queries the from_instance edge of a ServiceDependency.
func (c *ServiceDependencyClient) QueryFromInstance(_m *ServiceDependency) *ServiceInstanceQuery {
	query := (&ServiceInstanceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(servicedependency.Table, servicedependency.FieldID, id),
			sqlgraph.To(serviceinstance.Table, serviceinstance.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, servicedependency.FromInstanceTable, servicedependency.FromInstanceColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.ServiceInstance
		step.Edge.Schema = schemaConfig.ServiceDependency
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryToInstance queries the to_instance edge of a ServiceDependency.
func (c *ServiceDependencyClient) QueryToInstance(_m *ServiceDependency) *ServiceInstanceQuery {
	query := (&ServiceInstanceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(servicedependency.Table, servicedependency.FieldID, id),
			sqlgraph.To(serviceinstance.Table, serviceinstance.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, servicedependency.ToInstanceTable, servicedependency.ToInstanceColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.ServiceInstance
		step.Edge.Schema = schemaConfig.ServiceDependency
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ServiceDependencyClient) Hooks() []Hook {
	return c.hooks.ServiceDependency
}

// Interceptors returns the client interceptors.
func (c *ServiceDependencyClient) Interceptors() []Interceptor {
	return c.inters.ServiceDependency
}

func (c *ServiceDependencyClient) mutate(ctx context.Context, m *ServiceDependencyMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ServiceDependencyCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ServiceDependencyUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ServiceDependencyUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ServiceDependencyDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown ServiceDependency mutation op: %q", m.Op())
	}
}

// ServiceInstanceClient is a client for the ServiceInstance schema.
type ServiceInstanceClient struct {
	config
}

// NewServiceInstanceClient returns a client for the ServiceInstance from the given config.
func NewServiceInstanceClient(c config) *ServiceInstanceClient {
	return &ServiceInstanceClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `serviceinstance.Hooks(f(g(h())))`.
func (c *ServiceInstanceClient) Use(hooks ...Hook) {
	c.hooks.ServiceInstance = append(c.hooks.ServiceInstance, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `serviceinstance.Intercept(f(g(h())))`.
func (c *ServiceInstanceClient) Intercept(interceptors ...Interceptor) {
	c.inters.ServiceInstance = append(c.inters.ServiceInstance, interceptors...)
}

// Create returns a builder for creating a ServiceInstance entity.
func (c *ServiceInstanceClient) Create() *ServiceInstanceCreate {
	mutation := newServiceInstanceMutation(c.config, OpCreate)
	return &ServiceInstanceCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ServiceInstance entities.
func (c *ServiceInstanceClient) CreateBulk(builders ...*ServiceInstanceCreate) *ServiceInstanceCreateBulk {
	return &ServiceInstanceCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ServiceInstanceClient) MapCreateBulk(slice any, setFunc func(*ServiceInstanceCreate, int)) *ServiceInstanceCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ServiceInstanceCreateBulk{err: fmt.Errorf("calling to ServiceInstanceClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ServiceInstanceCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ServiceInstanceCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ServiceInstance.
func (c *ServiceInstanceClient) Update() *ServiceInstanceUpdate {
	mutation := newServiceInstanceMutation(c.config, OpUpdate)
	return &ServiceInstanceUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ServiceInstanceClient) UpdateOne(_m *ServiceInstance) *ServiceInstanceUpdateOne {
	mutation := newServiceInstanceMutation(c.config, OpUpdateOne, withServiceInstance(_m))
	return &ServiceInstanceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ServiceInstanceClient) UpdateOneID(id string) *ServiceInstanceUpdateOne {
	mutation := newServiceInstanceMutation(c.config, OpUpdateOne, withServiceInstanceID(id))
	return &ServiceInstanceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ServiceInstance.
func (c *ServiceInstanceClient) Delete() *ServiceInstanceDelete {
	mutation := newServiceInstanceMutation(c.config, OpDelete)
	return &ServiceInstanceDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ServiceInstanceClient) DeleteOne(_m *ServiceInstance) *ServiceInstanceDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ServiceInstanceClient) DeleteOneID(id string) *ServiceInstanceDeleteOne {
	builder := c.Delete().Where(serviceinstance.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ServiceInstanceDeleteOne{builder}
}

// Query returns a query builder for ServiceInstance.
func (c *ServiceInstanceClient) Query() *ServiceInstanceQuery {
	return &ServiceInstanceQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeServiceInstance},
		inters: c.Interceptors(),
	}
}

// Get returns a ServiceInstance entity by its id.
func (c *ServiceInstanceClient) Get(ctx context.Context, id string) (*ServiceInstance, error) {
	return c.Query().Where(serviceinstance.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ServiceInstanceClient) GetX(ctx context.Context, id string) *ServiceInstance {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryRouter queries the router edge of a ServiceInstance.
func (c *ServiceInstanceClient) QueryRouter(_m *ServiceInstance) *RouterQuery {
	query := (&RouterClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(serviceinstance.Table, serviceinstance.FieldID, id),
			sqlgraph.To(router.Table, router.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, serviceinstance.RouterTable, serviceinstance.RouterColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Router
		step.Edge.Schema = schemaConfig.ServiceInstance
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPortAllocations queries the port_allocations edge of a ServiceInstance.
func (c *ServiceInstanceClient) QueryPortAllocations(_m *ServiceInstance) *PortAllocationQuery {
	query := (&PortAllocationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(serviceinstance.Table, serviceinstance.FieldID, id),
			sqlgraph.To(portallocation.Table, portallocation.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, serviceinstance.PortAllocationsTable, serviceinstance.PortAllocationsColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.PortAllocation
		step.Edge.Schema = schemaConfig.PortAllocation
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryVlanAllocations queries the vlan_allocations edge of a ServiceInstance.
func (c *ServiceInstanceClient) QueryVlanAllocations(_m *ServiceInstance) *VLANAllocationQuery {
	query := (&VLANAllocationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(serviceinstance.Table, serviceinstance.FieldID, id),
			sqlgraph.To(vlanallocation.Table, vlanallocation.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, serviceinstance.VlanAllocationsTable, serviceinstance.VlanAllocationsColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.VLANAllocation
		step.Edge.Schema = schemaConfig.VLANAllocation
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryVirtualInterface queries the virtual_interface edge of a ServiceInstance.
func (c *ServiceInstanceClient) QueryVirtualInterface(_m *ServiceInstance) *VirtualInterfaceQuery {
	query := (&VirtualInterfaceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(serviceinstance.Table, serviceinstance.FieldID, id),
			sqlgraph.To(virtualinterface.Table, virtualinterface.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, serviceinstance.VirtualInterfaceTable, serviceinstance.VirtualInterfaceColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.VirtualInterface
		step.Edge.Schema = schemaConfig.VirtualInterface
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryDependencies queries the dependencies edge of a ServiceInstance.
func (c *ServiceInstanceClient) QueryDependencies(_m *ServiceInstance) *ServiceDependencyQuery {
	query := (&ServiceDependencyClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(serviceinstance.Table, serviceinstance.FieldID, id),
			sqlgraph.To(servicedependency.Table, servicedependency.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, serviceinstance.DependenciesTable, serviceinstance.DependenciesColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.ServiceDependency
		step.Edge.Schema = schemaConfig.ServiceDependency
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryDependents queries the dependents edge of a ServiceInstance.
func (c *ServiceInstanceClient) QueryDependents(_m *ServiceInstance) *ServiceDependencyQuery {
	query := (&ServiceDependencyClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(serviceinstance.Table, serviceinstance.FieldID, id),
			sqlgraph.To(servicedependency.Table, servicedependency.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, serviceinstance.DependentsTable, serviceinstance.DependentsColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.ServiceDependency
		step.Edge.Schema = schemaConfig.ServiceDependency
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryDeviceRoutings queries the device_routings edge of a ServiceInstance.
func (c *ServiceInstanceClient) QueryDeviceRoutings(_m *ServiceInstance) *DeviceRoutingQuery {
	query := (&DeviceRoutingClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(serviceinstance.Table, serviceinstance.FieldID, id),
			sqlgraph.To(devicerouting.Table, devicerouting.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, serviceinstance.DeviceRoutingsTable, serviceinstance.DeviceRoutingsColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.DeviceRouting
		step.Edge.Schema = schemaConfig.DeviceRouting
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryDiagnosticResults queries the diagnostic_results edge of a ServiceInstance.
func (c *ServiceInstanceClient) QueryDiagnosticResults(_m *ServiceInstance) *DiagnosticResultQuery {
	query := (&DiagnosticResultClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(serviceinstance.Table, serviceinstance.FieldID, id),
			sqlgraph.To(diagnosticresult.Table, diagnosticresult.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, serviceinstance.DiagnosticResultsTable, serviceinstance.DiagnosticResultsColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.DiagnosticResult
		step.Edge.Schema = schemaConfig.DiagnosticResult
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTrafficHourly queries the traffic_hourly edge of a ServiceInstance.
func (c *ServiceInstanceClient) QueryTrafficHourly(_m *ServiceInstance) *ServiceTrafficHourlyQuery {
	query := (&ServiceTrafficHourlyClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(serviceinstance.Table, serviceinstance.FieldID, id),
			sqlgraph.To(servicetraffichourly.Table, servicetraffichourly.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, serviceinstance.TrafficHourlyTable, serviceinstance.TrafficHourlyColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.ServiceTrafficHourly
		step.Edge.Schema = schemaConfig.ServiceTrafficHourly
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ServiceInstanceClient) Hooks() []Hook {
	return c.hooks.ServiceInstance
}

// Interceptors returns the client interceptors.
func (c *ServiceInstanceClient) Interceptors() []Interceptor {
	return c.inters.ServiceInstance
}

func (c *ServiceInstanceClient) mutate(ctx context.Context, m *ServiceInstanceMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ServiceInstanceCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ServiceInstanceUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ServiceInstanceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ServiceInstanceDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown ServiceInstance mutation op: %q", m.Op())
	}
}

// ServiceTemplateClient is a client for the ServiceTemplate schema.
type ServiceTemplateClient struct {
	config
}

// NewServiceTemplateClient returns a client for the ServiceTemplate from the given config.
func NewServiceTemplateClient(c config) *ServiceTemplateClient {
	return &ServiceTemplateClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `servicetemplate.Hooks(f(g(h())))`.
func (c *ServiceTemplateClient) Use(hooks ...Hook) {
	c.hooks.ServiceTemplate = append(c.hooks.ServiceTemplate, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `servicetemplate.Intercept(f(g(h())))`.
func (c *ServiceTemplateClient) Intercept(interceptors ...Interceptor) {
	c.inters.ServiceTemplate = append(c.inters.ServiceTemplate, interceptors...)
}

// Create returns a builder for creating a ServiceTemplate entity.
func (c *ServiceTemplateClient) Create() *ServiceTemplateCreate {
	mutation := newServiceTemplateMutation(c.config, OpCreate)
	return &ServiceTemplateCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ServiceTemplate entities.
func (c *ServiceTemplateClient) CreateBulk(builders ...*ServiceTemplateCreate) *ServiceTemplateCreateBulk {
	return &ServiceTemplateCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ServiceTemplateClient) MapCreateBulk(slice any, setFunc func(*ServiceTemplateCreate, int)) *ServiceTemplateCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ServiceTemplateCreateBulk{err: fmt.Errorf("calling to ServiceTemplateClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ServiceTemplateCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ServiceTemplateCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ServiceTemplate.
func (c *ServiceTemplateClient) Update() *ServiceTemplateUpdate {
	mutation := newServiceTemplateMutation(c.config, OpUpdate)
	return &ServiceTemplateUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ServiceTemplateClient) UpdateOne(_m *ServiceTemplate) *ServiceTemplateUpdateOne {
	mutation := newServiceTemplateMutation(c.config, OpUpdateOne, withServiceTemplate(_m))
	return &ServiceTemplateUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ServiceTemplateClient) UpdateOneID(id string) *ServiceTemplateUpdateOne {
	mutation := newServiceTemplateMutation(c.config, OpUpdateOne, withServiceTemplateID(id))
	return &ServiceTemplateUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ServiceTemplate.
func (c *ServiceTemplateClient) Delete() *ServiceTemplateDelete {
	mutation := newServiceTemplateMutation(c.config, OpDelete)
	return &ServiceTemplateDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ServiceTemplateClient) DeleteOne(_m *ServiceTemplate) *ServiceTemplateDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ServiceTemplateClient) DeleteOneID(id string) *ServiceTemplateDeleteOne {
	builder := c.Delete().Where(servicetemplate.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ServiceTemplateDeleteOne{builder}
}

// Query returns a query builder for ServiceTemplate.
func (c *ServiceTemplateClient) Query() *ServiceTemplateQuery {
	return &ServiceTemplateQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeServiceTemplate},
		inters: c.Interceptors(),
	}
}

// Get returns a ServiceTemplate entity by its id.
func (c *ServiceTemplateClient) Get(ctx context.Context, id string) (*ServiceTemplate, error) {
	return c.Query().Where(servicetemplate.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ServiceTemplateClient) GetX(ctx context.Context, id string) *ServiceTemplate {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryRouter queries the router edge of a ServiceTemplate.
func (c *ServiceTemplateClient) QueryRouter(_m *ServiceTemplate) *RouterQuery {
	query := (&RouterClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(servicetemplate.Table, servicetemplate.FieldID, id),
			sqlgraph.To(router.Table, router.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, servicetemplate.RouterTable, servicetemplate.RouterColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Router
		step.Edge.Schema = schemaConfig.ServiceTemplate
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ServiceTemplateClient) Hooks() []Hook {
	return c.hooks.ServiceTemplate
}

// Interceptors returns the client interceptors.
func (c *ServiceTemplateClient) Interceptors() []Interceptor {
	return c.inters.ServiceTemplate
}

func (c *ServiceTemplateClient) mutate(ctx context.Context, m *ServiceTemplateMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ServiceTemplateCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ServiceTemplateUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ServiceTemplateUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ServiceTemplateDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown ServiceTemplate mutation op: %q", m.Op())
	}
}

// ServiceTrafficHourlyClient is a client for the ServiceTrafficHourly schema.
type ServiceTrafficHourlyClient struct {
	config
}

// NewServiceTrafficHourlyClient returns a client for the ServiceTrafficHourly from the given config.
func NewServiceTrafficHourlyClient(c config) *ServiceTrafficHourlyClient {
	return &ServiceTrafficHourlyClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `servicetraffichourly.Hooks(f(g(h())))`.
func (c *ServiceTrafficHourlyClient) Use(hooks ...Hook) {
	c.hooks.ServiceTrafficHourly = append(c.hooks.ServiceTrafficHourly, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `servicetraffichourly.Intercept(f(g(h())))`.
func (c *ServiceTrafficHourlyClient) Intercept(interceptors ...Interceptor) {
	c.inters.ServiceTrafficHourly = append(c.inters.ServiceTrafficHourly, interceptors...)
}

// Create returns a builder for creating a ServiceTrafficHourly entity.
func (c *ServiceTrafficHourlyClient) Create() *ServiceTrafficHourlyCreate {
	mutation := newServiceTrafficHourlyMutation(c.config, OpCreate)
	return &ServiceTrafficHourlyCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ServiceTrafficHourly entities.
func (c *ServiceTrafficHourlyClient) CreateBulk(builders ...*ServiceTrafficHourlyCreate) *ServiceTrafficHourlyCreateBulk {
	return &ServiceTrafficHourlyCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ServiceTrafficHourlyClient) MapCreateBulk(slice any, setFunc func(*ServiceTrafficHourlyCreate, int)) *ServiceTrafficHourlyCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ServiceTrafficHourlyCreateBulk{err: fmt.Errorf("calling to ServiceTrafficHourlyClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ServiceTrafficHourlyCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ServiceTrafficHourlyCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ServiceTrafficHourly.
func (c *ServiceTrafficHourlyClient) Update() *ServiceTrafficHourlyUpdate {
	mutation := newServiceTrafficHourlyMutation(c.config, OpUpdate)
	return &ServiceTrafficHourlyUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ServiceTrafficHourlyClient) UpdateOne(_m *ServiceTrafficHourly) *ServiceTrafficHourlyUpdateOne {
	mutation := newServiceTrafficHourlyMutation(c.config, OpUpdateOne, withServiceTrafficHourly(_m))
	return &ServiceTrafficHourlyUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ServiceTrafficHourlyClient) UpdateOneID(id string) *ServiceTrafficHourlyUpdateOne {
	mutation := newServiceTrafficHourlyMutation(c.config, OpUpdateOne, withServiceTrafficHourlyID(id))
	return &ServiceTrafficHourlyUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ServiceTrafficHourly.
func (c *ServiceTrafficHourlyClient) Delete() *ServiceTrafficHourlyDelete {
	mutation := newServiceTrafficHourlyMutation(c.config, OpDelete)
	return &ServiceTrafficHourlyDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ServiceTrafficHourlyClient) DeleteOne(_m *ServiceTrafficHourly) *ServiceTrafficHourlyDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ServiceTrafficHourlyClient) DeleteOneID(id string) *ServiceTrafficHourlyDeleteOne {
	builder := c.Delete().Where(servicetraffichourly.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ServiceTrafficHourlyDeleteOne{builder}
}

// Query returns a query builder for ServiceTrafficHourly.
func (c *ServiceTrafficHourlyClient) Query() *ServiceTrafficHourlyQuery {
	return &ServiceTrafficHourlyQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeServiceTrafficHourly},
		inters: c.Interceptors(),
	}
}

// Get returns a ServiceTrafficHourly entity by its id.
func (c *ServiceTrafficHourlyClient) Get(ctx context.Context, id string) (*ServiceTrafficHourly, error) {
	return c.Query().Where(servicetraffichourly.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ServiceTrafficHourlyClient) GetX(ctx context.Context, id string) *ServiceTrafficHourly {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryServiceInstance queries the service_instance edge of a ServiceTrafficHourly.
func (c *ServiceTrafficHourlyClient) QueryServiceInstance(_m *ServiceTrafficHourly) *ServiceInstanceQuery {
	query := (&ServiceInstanceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(servicetraffichourly.Table, servicetraffichourly.FieldID, id),
			sqlgraph.To(serviceinstance.Table, serviceinstance.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, servicetraffichourly.ServiceInstanceTable, servicetraffichourly.ServiceInstanceColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.ServiceInstance
		step.Edge.Schema = schemaConfig.ServiceTrafficHourly
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ServiceTrafficHourlyClient) Hooks() []Hook {
	return c.hooks.ServiceTrafficHourly
}

// Interceptors returns the client interceptors.
func (c *ServiceTrafficHourlyClient) Interceptors() []Interceptor {
	return c.inters.ServiceTrafficHourly
}

func (c *ServiceTrafficHourlyClient) mutate(ctx context.Context, m *ServiceTrafficHourlyMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ServiceTrafficHourlyCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ServiceTrafficHourlyUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ServiceTrafficHourlyUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ServiceTrafficHourlyDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown ServiceTrafficHourly mutation op: %q", m.Op())
	}
}

// SessionClient is a client for the Session schema.
type SessionClient struct {
	config
}

// NewSessionClient returns a client for the Session from the given config.
func NewSessionClient(c config) *SessionClient {
	return &SessionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `session.Hooks(f(g(h())))`.
func (c *SessionClient) Use(hooks ...Hook) {
	c.hooks.Session = append(c.hooks.Session, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `session.Intercept(f(g(h())))`.
func (c *SessionClient) Intercept(interceptors ...Interceptor) {
	c.inters.Session = append(c.inters.Session, interceptors...)
}

// Create returns a builder for creating a Session entity.
func (c *SessionClient) Create() *SessionCreate {
	mutation := newSessionMutation(c.config, OpCreate)
	return &SessionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Session entities.
func (c *SessionClient) CreateBulk(builders ...*SessionCreate) *SessionCreateBulk {
	return &SessionCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *SessionClient) MapCreateBulk(slice any, setFunc func(*SessionCreate, int)) *SessionCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &SessionCreateBulk{err: fmt.Errorf("calling to SessionClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*SessionCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &SessionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Session.
func (c *SessionClient) Update() *SessionUpdate {
	mutation := newSessionMutation(c.config, OpUpdate)
	return &SessionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *SessionClient) UpdateOne(_m *Session) *SessionUpdateOne {
	mutation := newSessionMutation(c.config, OpUpdateOne, withSession(_m))
	return &SessionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *SessionClient) UpdateOneID(id string) *SessionUpdateOne {
	mutation := newSessionMutation(c.config, OpUpdateOne, withSessionID(id))
	return &SessionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Session.
func (c *SessionClient) Delete() *SessionDelete {
	mutation := newSessionMutation(c.config, OpDelete)
	return &SessionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *SessionClient) DeleteOne(_m *Session) *SessionDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *SessionClient) DeleteOneID(id string) *SessionDeleteOne {
	builder := c.Delete().Where(session.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &SessionDeleteOne{builder}
}

// Query returns a query builder for Session.
func (c *SessionClient) Query() *SessionQuery {
	return &SessionQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeSession},
		inters: c.Interceptors(),
	}
}

// Get returns a Session entity by its id.
func (c *SessionClient) Get(ctx context.Context, id string) (*Session, error) {
	return c.Query().Where(session.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *SessionClient) GetX(ctx context.Context, id string) *Session {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a Session.
func (c *SessionClient) QueryUser(_m *Session) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(session.Table, session.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, session.UserTable, session.UserColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.User
		step.Edge.Schema = schemaConfig.Session
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *SessionClient) Hooks() []Hook {
	return c.hooks.Session
}

// Interceptors returns the client interceptors.
func (c *SessionClient) Interceptors() []Interceptor {
	return c.inters.Session
}

func (c *SessionClient) mutate(ctx context.Context, m *SessionMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&SessionCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&SessionUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&SessionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&SessionDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Session mutation op: %q", m.Op())
	}
}

// SubnetAllocationClient is a client for the SubnetAllocation schema.
type SubnetAllocationClient struct {
	config
}

// NewSubnetAllocationClient returns a client for the SubnetAllocation from the given config.
func NewSubnetAllocationClient(c config) *SubnetAllocationClient {
	return &SubnetAllocationClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `subnetallocation.Hooks(f(g(h())))`.
func (c *SubnetAllocationClient) Use(hooks ...Hook) {
	c.hooks.SubnetAllocation = append(c.hooks.SubnetAllocation, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `subnetallocation.Intercept(f(g(h())))`.
func (c *SubnetAllocationClient) Intercept(interceptors ...Interceptor) {
	c.inters.SubnetAllocation = append(c.inters.SubnetAllocation, interceptors...)
}

// Create returns a builder for creating a SubnetAllocation entity.
func (c *SubnetAllocationClient) Create() *SubnetAllocationCreate {
	mutation := newSubnetAllocationMutation(c.config, OpCreate)
	return &SubnetAllocationCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of SubnetAllocation entities.
func (c *SubnetAllocationClient) CreateBulk(builders ...*SubnetAllocationCreate) *SubnetAllocationCreateBulk {
	return &SubnetAllocationCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *SubnetAllocationClient) MapCreateBulk(slice any, setFunc func(*SubnetAllocationCreate, int)) *SubnetAllocationCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &SubnetAllocationCreateBulk{err: fmt.Errorf("calling to SubnetAllocationClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*SubnetAllocationCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &SubnetAllocationCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for SubnetAllocation.
func (c *SubnetAllocationClient) Update() *SubnetAllocationUpdate {
	mutation := newSubnetAllocationMutation(c.config, OpUpdate)
	return &SubnetAllocationUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *SubnetAllocationClient) UpdateOne(_m *SubnetAllocation) *SubnetAllocationUpdateOne {
	mutation := newSubnetAllocationMutation(c.config, OpUpdateOne, withSubnetAllocation(_m))
	return &SubnetAllocationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *SubnetAllocationClient) UpdateOneID(id string) *SubnetAllocationUpdateOne {
	mutation := newSubnetAllocationMutation(c.config, OpUpdateOne, withSubnetAllocationID(id))
	return &SubnetAllocationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for SubnetAllocation.
func (c *SubnetAllocationClient) Delete() *SubnetAllocationDelete {
	mutation := newSubnetAllocationMutation(c.config, OpDelete)
	return &SubnetAllocationDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *SubnetAllocationClient) DeleteOne(_m *SubnetAllocation) *SubnetAllocationDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *SubnetAllocationClient) DeleteOneID(id string) *SubnetAllocationDeleteOne {
	builder := c.Delete().Where(subnetallocation.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &SubnetAllocationDeleteOne{builder}
}

// Query returns a query builder for SubnetAllocation.
func (c *SubnetAllocationClient) Query() *SubnetAllocationQuery {
	return &SubnetAllocationQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeSubnetAllocation},
		inters: c.Interceptors(),
	}
}

// Get returns a SubnetAllocation entity by its id.
func (c *SubnetAllocationClient) Get(ctx context.Context, id string) (*SubnetAllocation, error) {
	return c.Query().Where(subnetallocation.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *SubnetAllocationClient) GetX(ctx context.Context, id string) *SubnetAllocation {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryRouter queries the router edge of a SubnetAllocation.
func (c *SubnetAllocationClient) QueryRouter(_m *SubnetAllocation) *RouterQuery {
	query := (&RouterClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(subnetallocation.Table, subnetallocation.FieldID, id),
			sqlgraph.To(router.Table, router.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, subnetallocation.RouterTable, subnetallocation.RouterColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Router
		step.Edge.Schema = schemaConfig.SubnetAllocation
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *SubnetAllocationClient) Hooks() []Hook {
	return c.hooks.SubnetAllocation
}

// Interceptors returns the client interceptors.
func (c *SubnetAllocationClient) Interceptors() []Interceptor {
	return c.inters.SubnetAllocation
}

func (c *SubnetAllocationClient) mutate(ctx context.Context, m *SubnetAllocationMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&SubnetAllocationCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&SubnetAllocationUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&SubnetAllocationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&SubnetAllocationDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown SubnetAllocation mutation op: %q", m.Op())
	}
}

// UserClient is a client for the User schema.
type UserClient struct {
	config
}

// NewUserClient returns a client for the User from the given config.
func NewUserClient(c config) *UserClient {
	return &UserClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `user.Hooks(f(g(h())))`.
func (c *UserClient) Use(hooks ...Hook) {
	c.hooks.User = append(c.hooks.User, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `user.Intercept(f(g(h())))`.
func (c *UserClient) Intercept(interceptors ...Interceptor) {
	c.inters.User = append(c.inters.User, interceptors...)
}

// Create returns a builder for creating a User entity.
func (c *UserClient) Create() *UserCreate {
	mutation := newUserMutation(c.config, OpCreate)
	return &UserCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of User entities.
func (c *UserClient) CreateBulk(builders ...*UserCreate) *UserCreateBulk {
	return &UserCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *UserClient) MapCreateBulk(slice any, setFunc func(*UserCreate, int)) *UserCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &UserCreateBulk{err: fmt.Errorf("calling to UserClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*UserCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &UserCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for User.
func (c *UserClient) Update() *UserUpdate {
	mutation := newUserMutation(c.config, OpUpdate)
	return &UserUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UserClient) UpdateOne(_m *User) *UserUpdateOne {
	mutation := newUserMutation(c.config, OpUpdateOne, withUser(_m))
	return &UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *UserClient) UpdateOneID(id string) *UserUpdateOne {
	mutation := newUserMutation(c.config, OpUpdateOne, withUserID(id))
	return &UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for User.
func (c *UserClient) Delete() *UserDelete {
	mutation := newUserMutation(c.config, OpDelete)
	return &UserDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *UserClient) DeleteOne(_m *User) *UserDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *UserClient) DeleteOneID(id string) *UserDeleteOne {
	builder := c.Delete().Where(user.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &UserDeleteOne{builder}
}

// Query returns a query builder for User.
func (c *UserClient) Query() *UserQuery {
	return &UserQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeUser},
		inters: c.Interceptors(),
	}
}

// Get returns a User entity by its id.
func (c *UserClient) Get(ctx context.Context, id string) (*User, error) {
	return c.Query().Where(user.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *UserClient) GetX(ctx context.Context, id string) *User {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QuerySessions queries the sessions edge of a User.
func (c *UserClient) QuerySessions(_m *User) *SessionQuery {
	query := (&SessionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(session.Table, session.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.SessionsTable, user.SessionsColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Session
		step.Edge.Schema = schemaConfig.Session
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAPIKeys queries the api_keys edge of a User.
func (c *UserClient) QueryAPIKeys(_m *User) *APIKeyQuery {
	query := (&APIKeyClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(apikey.Table, apikey.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.APIKeysTable, user.APIKeysColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.APIKey
		step.Edge.Schema = schemaConfig.APIKey
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *UserClient) Hooks() []Hook {
	return c.hooks.User
}

// Interceptors returns the client interceptors.
func (c *UserClient) Interceptors() []Interceptor {
	return c.inters.User
}

func (c *UserClient) mutate(ctx context.Context, m *UserMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&UserCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&UserUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&UserDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown User mutation op: %q", m.Op())
	}
}

// VLANAllocationClient is a client for the VLANAllocation schema.
type VLANAllocationClient struct {
	config
}

// NewVLANAllocationClient returns a client for the VLANAllocation from the given config.
func NewVLANAllocationClient(c config) *VLANAllocationClient {
	return &VLANAllocationClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `vlanallocation.Hooks(f(g(h())))`.
func (c *VLANAllocationClient) Use(hooks ...Hook) {
	c.hooks.VLANAllocation = append(c.hooks.VLANAllocation, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `vlanallocation.Intercept(f(g(h())))`.
func (c *VLANAllocationClient) Intercept(interceptors ...Interceptor) {
	c.inters.VLANAllocation = append(c.inters.VLANAllocation, interceptors...)
}

// Create returns a builder for creating a VLANAllocation entity.
func (c *VLANAllocationClient) Create() *VLANAllocationCreate {
	mutation := newVLANAllocationMutation(c.config, OpCreate)
	return &VLANAllocationCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of VLANAllocation entities.
func (c *VLANAllocationClient) CreateBulk(builders ...*VLANAllocationCreate) *VLANAllocationCreateBulk {
	return &VLANAllocationCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *VLANAllocationClient) MapCreateBulk(slice any, setFunc func(*VLANAllocationCreate, int)) *VLANAllocationCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &VLANAllocationCreateBulk{err: fmt.Errorf("calling to VLANAllocationClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*VLANAllocationCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &VLANAllocationCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for VLANAllocation.
func (c *VLANAllocationClient) Update() *VLANAllocationUpdate {
	mutation := newVLANAllocationMutation(c.config, OpUpdate)
	return &VLANAllocationUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *VLANAllocationClient) UpdateOne(_m *VLANAllocation) *VLANAllocationUpdateOne {
	mutation := newVLANAllocationMutation(c.config, OpUpdateOne, withVLANAllocation(_m))
	return &VLANAllocationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *VLANAllocationClient) UpdateOneID(id string) *VLANAllocationUpdateOne {
	mutation := newVLANAllocationMutation(c.config, OpUpdateOne, withVLANAllocationID(id))
	return &VLANAllocationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for VLANAllocation.
func (c *VLANAllocationClient) Delete() *VLANAllocationDelete {
	mutation := newVLANAllocationMutation(c.config, OpDelete)
	return &VLANAllocationDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *VLANAllocationClient) DeleteOne(_m *VLANAllocation) *VLANAllocationDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *VLANAllocationClient) DeleteOneID(id string) *VLANAllocationDeleteOne {
	builder := c.Delete().Where(vlanallocation.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &VLANAllocationDeleteOne{builder}
}

// Query returns a query builder for VLANAllocation.
func (c *VLANAllocationClient) Query() *VLANAllocationQuery {
	return &VLANAllocationQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeVLANAllocation},
		inters: c.Interceptors(),
	}
}

// Get returns a VLANAllocation entity by its id.
func (c *VLANAllocationClient) Get(ctx context.Context, id string) (*VLANAllocation, error) {
	return c.Query().Where(vlanallocation.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *VLANAllocationClient) GetX(ctx context.Context, id string) *VLANAllocation {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryRouter queries the router edge of a VLANAllocation.
func (c *VLANAllocationClient) QueryRouter(_m *VLANAllocation) *RouterQuery {
	query := (&RouterClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(vlanallocation.Table, vlanallocation.FieldID, id),
			sqlgraph.To(router.Table, router.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, vlanallocation.RouterTable, vlanallocation.RouterColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Router
		step.Edge.Schema = schemaConfig.VLANAllocation
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryServiceInstance queries the service_instance edge of a VLANAllocation.
func (c *VLANAllocationClient) QueryServiceInstance(_m *VLANAllocation) *ServiceInstanceQuery {
	query := (&ServiceInstanceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(vlanallocation.Table, vlanallocation.FieldID, id),
			sqlgraph.To(serviceinstance.Table, serviceinstance.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, vlanallocation.ServiceInstanceTable, vlanallocation.ServiceInstanceColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.ServiceInstance
		step.Edge.Schema = schemaConfig.VLANAllocation
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *VLANAllocationClient) Hooks() []Hook {
	return c.hooks.VLANAllocation
}

// Interceptors returns the client interceptors.
func (c *VLANAllocationClient) Interceptors() []Interceptor {
	return c.inters.VLANAllocation
}

func (c *VLANAllocationClient) mutate(ctx context.Context, m *VLANAllocationMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&VLANAllocationCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&VLANAllocationUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&VLANAllocationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&VLANAllocationDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown VLANAllocation mutation op: %q", m.Op())
	}
}

// VersionClient is a client for the Version schema.
type VersionClient struct {
	config
}

// NewVersionClient returns a client for the Version from the given config.
func NewVersionClient(c config) *VersionClient {
	return &VersionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `version.Hooks(f(g(h())))`.
func (c *VersionClient) Use(hooks ...Hook) {
	c.hooks.Version = append(c.hooks.Version, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `version.Intercept(f(g(h())))`.
func (c *VersionClient) Intercept(interceptors ...Interceptor) {
	c.inters.Version = append(c.inters.Version, interceptors...)
}

// Create returns a builder for creating a Version entity.
func (c *VersionClient) Create() *VersionCreate {
	mutation := newVersionMutation(c.config, OpCreate)
	return &VersionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Version entities.
func (c *VersionClient) CreateBulk(builders ...*VersionCreate) *VersionCreateBulk {
	return &VersionCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *VersionClient) MapCreateBulk(slice any, setFunc func(*VersionCreate, int)) *VersionCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &VersionCreateBulk{err: fmt.Errorf("calling to VersionClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*VersionCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &VersionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Version.
func (c *VersionClient) Update() *VersionUpdate {
	mutation := newVersionMutation(c.config, OpUpdate)
	return &VersionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *VersionClient) UpdateOne(_m *Version) *VersionUpdateOne {
	mutation := newVersionMutation(c.config, OpUpdateOne, withVersion(_m))
	return &VersionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *VersionClient) UpdateOneID(id string) *VersionUpdateOne {
	mutation := newVersionMutation(c.config, OpUpdateOne, withVersionID(id))
	return &VersionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Version.
func (c *VersionClient) Delete() *VersionDelete {
	mutation := newVersionMutation(c.config, OpDelete)
	return &VersionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *VersionClient) DeleteOne(_m *Version) *VersionDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *VersionClient) DeleteOneID(id string) *VersionDeleteOne {
	builder := c.Delete().Where(version.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &VersionDeleteOne{builder}
}

// Query returns a query builder for Version.
func (c *VersionClient) Query() *VersionQuery {
	return &VersionQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeVersion},
		inters: c.Interceptors(),
	}
}

// Get returns a Version entity by its id.
func (c *VersionClient) Get(ctx context.Context, id string) (*Version, error) {
	return c.Query().Where(version.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *VersionClient) GetX(ctx context.Context, id string) *Version {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *VersionClient) Hooks() []Hook {
	return c.hooks.Version
}

// Interceptors returns the client interceptors.
func (c *VersionClient) Interceptors() []Interceptor {
	return c.inters.Version
}

func (c *VersionClient) mutate(ctx context.Context, m *VersionMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&VersionCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&VersionUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&VersionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&VersionDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Version mutation op: %q", m.Op())
	}
}

// VirtualInterfaceClient is a client for the VirtualInterface schema.
type VirtualInterfaceClient struct {
	config
}

// NewVirtualInterfaceClient returns a client for the VirtualInterface from the given config.
func NewVirtualInterfaceClient(c config) *VirtualInterfaceClient {
	return &VirtualInterfaceClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `virtualinterface.Hooks(f(g(h())))`.
func (c *VirtualInterfaceClient) Use(hooks ...Hook) {
	c.hooks.VirtualInterface = append(c.hooks.VirtualInterface, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `virtualinterface.Intercept(f(g(h())))`.
func (c *VirtualInterfaceClient) Intercept(interceptors ...Interceptor) {
	c.inters.VirtualInterface = append(c.inters.VirtualInterface, interceptors...)
}

// Create returns a builder for creating a VirtualInterface entity.
func (c *VirtualInterfaceClient) Create() *VirtualInterfaceCreate {
	mutation := newVirtualInterfaceMutation(c.config, OpCreate)
	return &VirtualInterfaceCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of VirtualInterface entities.
func (c *VirtualInterfaceClient) CreateBulk(builders ...*VirtualInterfaceCreate) *VirtualInterfaceCreateBulk {
	return &VirtualInterfaceCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *VirtualInterfaceClient) MapCreateBulk(slice any, setFunc func(*VirtualInterfaceCreate, int)) *VirtualInterfaceCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &VirtualInterfaceCreateBulk{err: fmt.Errorf("calling to VirtualInterfaceClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*VirtualInterfaceCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &VirtualInterfaceCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for VirtualInterface.
func (c *VirtualInterfaceClient) Update() *VirtualInterfaceUpdate {
	mutation := newVirtualInterfaceMutation(c.config, OpUpdate)
	return &VirtualInterfaceUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *VirtualInterfaceClient) UpdateOne(_m *VirtualInterface) *VirtualInterfaceUpdateOne {
	mutation := newVirtualInterfaceMutation(c.config, OpUpdateOne, withVirtualInterface(_m))
	return &VirtualInterfaceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *VirtualInterfaceClient) UpdateOneID(id string) *VirtualInterfaceUpdateOne {
	mutation := newVirtualInterfaceMutation(c.config, OpUpdateOne, withVirtualInterfaceID(id))
	return &VirtualInterfaceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for VirtualInterface.
func (c *VirtualInterfaceClient) Delete() *VirtualInterfaceDelete {
	mutation := newVirtualInterfaceMutation(c.config, OpDelete)
	return &VirtualInterfaceDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *VirtualInterfaceClient) DeleteOne(_m *VirtualInterface) *VirtualInterfaceDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *VirtualInterfaceClient) DeleteOneID(id string) *VirtualInterfaceDeleteOne {
	builder := c.Delete().Where(virtualinterface.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &VirtualInterfaceDeleteOne{builder}
}

// Query returns a query builder for VirtualInterface.
func (c *VirtualInterfaceClient) Query() *VirtualInterfaceQuery {
	return &VirtualInterfaceQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeVirtualInterface},
		inters: c.Interceptors(),
	}
}

// Get returns a VirtualInterface entity by its id.
func (c *VirtualInterfaceClient) Get(ctx context.Context, id string) (*VirtualInterface, error) {
	return c.Query().Where(virtualinterface.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *VirtualInterfaceClient) GetX(ctx context.Context, id string) *VirtualInterface {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryInstance queries the instance edge of a VirtualInterface.
func (c *VirtualInterfaceClient) QueryInstance(_m *VirtualInterface) *ServiceInstanceQuery {
	query := (&ServiceInstanceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(virtualinterface.Table, virtualinterface.FieldID, id),
			sqlgraph.To(serviceinstance.Table, serviceinstance.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, virtualinterface.InstanceTable, virtualinterface.InstanceColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.ServiceInstance
		step.Edge.Schema = schemaConfig.VirtualInterface
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryDeviceRoutings queries the device_routings edge of a VirtualInterface.
func (c *VirtualInterfaceClient) QueryDeviceRoutings(_m *VirtualInterface) *DeviceRoutingQuery {
	query := (&DeviceRoutingClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(virtualinterface.Table, virtualinterface.FieldID, id),
			sqlgraph.To(devicerouting.Table, devicerouting.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, virtualinterface.DeviceRoutingsTable, virtualinterface.DeviceRoutingsColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.DeviceRouting
		step.Edge.Schema = schemaConfig.DeviceRouting
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *VirtualInterfaceClient) Hooks() []Hook {
	return c.hooks.VirtualInterface
}

// Interceptors returns the client interceptors.
func (c *VirtualInterfaceClient) Interceptors() []Interceptor {
	return c.inters.VirtualInterface
}

func (c *VirtualInterfaceClient) mutate(ctx context.Context, m *VirtualInterfaceMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&VirtualInterfaceCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&VirtualInterfaceUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&VirtualInterfaceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&VirtualInterfaceDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown VirtualInterface mutation op: %q", m.Op())
	}
}

// WebhookClient is a client for the Webhook schema.
type WebhookClient struct {
	config
}

// NewWebhookClient returns a client for the Webhook from the given config.
func NewWebhookClient(c config) *WebhookClient {
	return &WebhookClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `webhook.Hooks(f(g(h())))`.
func (c *WebhookClient) Use(hooks ...Hook) {
	c.hooks.Webhook = append(c.hooks.Webhook, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `webhook.Intercept(f(g(h())))`.
func (c *WebhookClient) Intercept(interceptors ...Interceptor) {
	c.inters.Webhook = append(c.inters.Webhook, interceptors...)
}

// Create returns a builder for creating a Webhook entity.
func (c *WebhookClient) Create() *WebhookCreate {
	mutation := newWebhookMutation(c.config, OpCreate)
	return &WebhookCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Webhook entities.
func (c *WebhookClient) CreateBulk(builders ...*WebhookCreate) *WebhookCreateBulk {
	return &WebhookCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *WebhookClient) MapCreateBulk(slice any, setFunc func(*WebhookCreate, int)) *WebhookCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &WebhookCreateBulk{err: fmt.Errorf("calling to WebhookClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*WebhookCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &WebhookCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Webhook.
func (c *WebhookClient) Update() *WebhookUpdate {
	mutation := newWebhookMutation(c.config, OpUpdate)
	return &WebhookUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *WebhookClient) UpdateOne(_m *Webhook) *WebhookUpdateOne {
	mutation := newWebhookMutation(c.config, OpUpdateOne, withWebhook(_m))
	return &WebhookUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *WebhookClient) UpdateOneID(id string) *WebhookUpdateOne {
	mutation := newWebhookMutation(c.config, OpUpdateOne, withWebhookID(id))
	return &WebhookUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Webhook.
func (c *WebhookClient) Delete() *WebhookDelete {
	mutation := newWebhookMutation(c.config, OpDelete)
	return &WebhookDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *WebhookClient) DeleteOne(_m *Webhook) *WebhookDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *WebhookClient) DeleteOneID(id string) *WebhookDeleteOne {
	builder := c.Delete().Where(webhook.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &WebhookDeleteOne{builder}
}

// Query returns a query builder for Webhook.
func (c *WebhookClient) Query() *WebhookQuery {
	return &WebhookQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeWebhook},
		inters: c.Interceptors(),
	}
}

// Get returns a Webhook entity by its id.
func (c *WebhookClient) Get(ctx context.Context, id string) (*Webhook, error) {
	return c.Query().Where(webhook.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *WebhookClient) GetX(ctx context.Context, id string) *Webhook {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryLogs queries the logs edge of a Webhook.
func (c *WebhookClient) QueryLogs(_m *Webhook) *NotificationLogQuery {
	query := (&NotificationLogClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(webhook.Table, webhook.FieldID, id),
			sqlgraph.To(notificationlog.Table, notificationlog.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, webhook.LogsTable, webhook.LogsColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.NotificationLog
		step.Edge.Schema = schemaConfig.NotificationLog
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *WebhookClient) Hooks() []Hook {
	return c.hooks.Webhook
}

// Interceptors returns the client interceptors.
func (c *WebhookClient) Interceptors() []Interceptor {
	return c.inters.Webhook
}

func (c *WebhookClient) mutate(ctx context.Context, m *WebhookMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&WebhookCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&WebhookUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&WebhookUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&WebhookDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Webhook mutation op: %q", m.Op())
	}
}

// hooks and interceptors per client, for fast access.
type (
	hooks struct {
		APIKey, Alert, AlertDigestEntry, AlertEscalation, AlertRule, AlertRuleTemplate,
		AlertTemplate, ChainHop, ConfigSnapshot, DeviceRouting, DiagnosticResult,
		GlobalSettings, NotificationChannelConfig, NotificationLog,
		NotificationSettings, PortAllocation, PortKnockSequence, ProvisioningSession,
		Resource, ResourceEvent, Router, RouterCapability, RouterSecret, RoutingChain,
		RoutingSchedule, ServiceDependency, ServiceInstance, ServiceTemplate,
		ServiceTrafficHourly, Session, SubnetAllocation, User, VLANAllocation, Version,
		VirtualInterface, Webhook []ent.Hook
	}
	inters struct {
		APIKey, Alert, AlertDigestEntry, AlertEscalation, AlertRule, AlertRuleTemplate,
		AlertTemplate, ChainHop, ConfigSnapshot, DeviceRouting, DiagnosticResult,
		GlobalSettings, NotificationChannelConfig, NotificationLog,
		NotificationSettings, PortAllocation, PortKnockSequence, ProvisioningSession,
		Resource, ResourceEvent, Router, RouterCapability, RouterSecret, RoutingChain,
		RoutingSchedule, ServiceDependency, ServiceInstance, ServiceTemplate,
		ServiceTrafficHourly, Session, SubnetAllocation, User, VLANAllocation, Version,
		VirtualInterface, Webhook []ent.Interceptor
	}
)

// SchemaConfig represents alternative schema names for all tables
// that can be passed at runtime.
type SchemaConfig = internal.SchemaConfig

// AlternateSchemas allows alternate schema names to be
// passed into ent operations.
func AlternateSchema(schemaConfig SchemaConfig) Option {
	return func(c *config) {
		c.schemaConfig = schemaConfig
	}
}

// ExecContext allows calling the underlying ExecContext method of the driver if it is supported by it.
// See, database/sql#DB.ExecContext for more information.
func (c *config) ExecContext(ctx context.Context, query string, args ...any) (stdsql.Result, error) {
	ex, ok := c.driver.(interface {
		ExecContext(context.Context, string, ...any) (stdsql.Result, error)
	})
	if !ok {
		return nil, fmt.Errorf("Driver.ExecContext is not supported")
	}
	return ex.ExecContext(ctx, query, args...)
}

// QueryContext allows calling the underlying QueryContext method of the driver if it is supported by it.
// See, database/sql#DB.QueryContext for more information.
func (c *config) QueryContext(ctx context.Context, query string, args ...any) (*stdsql.Rows, error) {
	q, ok := c.driver.(interface {
		QueryContext(context.Context, string, ...any) (*stdsql.Rows, error)
	})
	if !ok {
		return nil, fmt.Errorf("Driver.QueryContext is not supported")
	}
	return q.QueryContext(ctx, query, args...)
}
