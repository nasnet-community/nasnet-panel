// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package graph

import (
	"backend/graph/model"
	"bytes"
	"context"
	"errors"
	"fmt"
	"io"
	"strconv"
	"sync"
	"sync/atomic"
	"time"

	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"
	gqlparser "github.com/vektah/gqlparser/v2"
	"github.com/vektah/gqlparser/v2/ast"
)

// region    ************************** generated!.gotpl **************************

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		schema:     cfg.Schema,
		resolvers:  cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
	}
}

type Config struct {
	Schema     *ast.Schema
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
	Mutation() MutationResolver
	Query() QueryResolver
	Subscription() SubscriptionResolver
}

type DirectiveRoot struct {
	Auth       func(ctx context.Context, obj interface{}, next graphql.Resolver, requires *string) (res interface{}, err error)
	Capability func(ctx context.Context, obj interface{}, next graphql.Resolver, requires []string) (res interface{}, err error)
	Sensitive  func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error)
	Validate   func(ctx context.Context, obj interface{}, next graphql.Resolver, min *int, max *int, minLength *int, maxLength *int, pattern *string, format *model.ValidateFormat) (res interface{}, err error)
}

type ComplexityRoot struct {
	AddRouterPayload struct {
		ConnectionResult func(childComplexity int) int
		Errors           func(childComplexity int) int
		Router           func(childComplexity int) int
		ValidationErrors func(childComplexity int) int
	}

	AuthPayload struct {
		ExpiresAt func(childComplexity int) int
		Token     func(childComplexity int) int
		User      func(childComplexity int) int
	}

	AuthStatus struct {
		Error     func(childComplexity int) int
		ErrorCode func(childComplexity int) int
		Success   func(childComplexity int) int
		Tested    func(childComplexity int) int
	}

	CancelScanPayload struct {
		Errors func(childComplexity int) int
		Task   func(childComplexity int) int
	}

	CapabilityEntry struct {
		Capability  func(childComplexity int) int
		Description func(childComplexity int) int
		Guidance    func(childComplexity int) int
		Level       func(childComplexity int) int
	}

	CircuitBreakerEvent struct {
		ConsecutiveFailures func(childComplexity int) int
		NewState            func(childComplexity int) int
		PreviousState       func(childComplexity int) int
		RouterID            func(childComplexity int) int
		Timestamp           func(childComplexity int) int
	}

	CircuitBreakerStatus struct {
		CooldownRemainingSeconds func(childComplexity int) int
		FailureCount             func(childComplexity int) int
		FailureThreshold         func(childComplexity int) int
		LastFailureAt            func(childComplexity int) int
		LastSuccessAt            func(childComplexity int) int
		RouterID                 func(childComplexity int) int
		State                    func(childComplexity int) int
	}

	ConfigProgress struct {
		CurrentStep func(childComplexity int) int
		Message     func(childComplexity int) int
		OperationID func(childComplexity int) int
		Percentage  func(childComplexity int) int
		Status      func(childComplexity int) int
		Timestamp   func(childComplexity int) int
		TotalSteps  func(childComplexity int) int
	}

	ConnectRouterPayload struct {
		Errors func(childComplexity int) int
		Router func(childComplexity int) int
	}

	ConnectionAttempt struct {
		EndedAt       func(childComplexity int) int
		ErrorCategory func(childComplexity int) int
		ErrorCode     func(childComplexity int) int
		ErrorMessage  func(childComplexity int) int
		Protocol      func(childComplexity int) int
		StartedAt     func(childComplexity int) int
		Success       func(childComplexity int) int
	}

	ConnectionDetails struct {
		CircuitBreakerState   func(childComplexity int) int
		ConnectedAt           func(childComplexity int) int
		DisconnectReason      func(childComplexity int) int
		DisconnectedAt        func(childComplexity int) int
		HealthChecksFailed    func(childComplexity int) int
		HealthChecksPassed    func(childComplexity int) int
		IsLegacyProtocol      func(childComplexity int) int
		LastError             func(childComplexity int) int
		LastErrorTime         func(childComplexity int) int
		LastHealthCheck       func(childComplexity int) int
		NextReconnectAt       func(childComplexity int) int
		PreferredProtocol     func(childComplexity int) int
		Protocol              func(childComplexity int) int
		ReconnectAttempts     func(childComplexity int) int
		SecurityWarning       func(childComplexity int) int
		State                 func(childComplexity int) int
		UpgradeRecommendation func(childComplexity int) int
		Uptime                func(childComplexity int) int
		Version               func(childComplexity int) int
	}

	ConnectionError struct {
		Code            func(childComplexity int) int
		Message         func(childComplexity int) int
		Protocol        func(childComplexity int) int
		Retryable       func(childComplexity int) int
		SuggestedAction func(childComplexity int) int
		TimeoutMs       func(childComplexity int) int
	}

	ConnectionStats struct {
		Connected        func(childComplexity int) int
		Connecting       func(childComplexity int) int
		Disconnected     func(childComplexity int) int
		Error            func(childComplexity int) int
		Reconnecting     func(childComplexity int) int
		TotalConnections func(childComplexity int) int
	}

	ConnectionTestResult struct {
		Architecture       func(childComplexity int) int
		BoardName          func(childComplexity int) int
		Error              func(childComplexity int) int
		ProtocolUsed       func(childComplexity int) int
		ProtocolsAttempted func(childComplexity int) int
		ResponseTimeMs     func(childComplexity int) int
		RouterModel        func(childComplexity int) int
		RouterVersion      func(childComplexity int) int
		Success            func(childComplexity int) int
		SupportsContainers func(childComplexity int) int
		Uptime             func(childComplexity int) int
	}

	ContainerInfo struct {
		Enabled                  func(childComplexity int) int
		MaxContainers            func(childComplexity int) int
		PackageInstalled         func(childComplexity int) int
		RegistryConfigured       func(childComplexity int) int
		StorageAvailable         func(childComplexity int) int
		SupportsNetworkNamespace func(childComplexity int) int
	}

	CreateRouterPayload struct {
		Errors func(childComplexity int) int
		Router func(childComplexity int) int
	}

	CredentialTestResult struct {
		Error          func(childComplexity int) int
		ResponseTimeMs func(childComplexity int) int
		RouterID       func(childComplexity int) int
		RouterName     func(childComplexity int) int
		Status         func(childComplexity int) int
		Success        func(childComplexity int) int
	}

	CredentialUpdatePayload struct {
		Credentials func(childComplexity int) int
		ErrorCode   func(childComplexity int) int
		Errors      func(childComplexity int) int
		Message     func(childComplexity int) int
		Success     func(childComplexity int) int
	}

	DeleteRouterPayload struct {
		DeletedRouterID func(childComplexity int) int
		Errors          func(childComplexity int) int
		Success         func(childComplexity int) int
	}

	DiagnosticReport struct {
		AuthStatus       func(childComplexity int) int
		NetworkReachable func(childComplexity int) int
		PortStatus       func(childComplexity int) int
		RawReport        func(childComplexity int) int
		RouterID         func(childComplexity int) int
		Suggestions      func(childComplexity int) int
		TLSStatus        func(childComplexity int) int
		Timestamp        func(childComplexity int) int
	}

	DiagnosticSuggestion struct {
		Action      func(childComplexity int) int
		Description func(childComplexity int) int
		DocsURL     func(childComplexity int) int
		Severity    func(childComplexity int) int
		Title       func(childComplexity int) int
	}

	DisconnectRouterPayload struct {
		Errors func(childComplexity int) int
		Router func(childComplexity int) int
	}

	DiscoveredDevice struct {
		Confidence   func(childComplexity int) int
		DeviceType   func(childComplexity int) int
		Hostname     func(childComplexity int) int
		IP           func(childComplexity int) int
		Ports        func(childComplexity int) int
		RouterOSInfo func(childComplexity int) int
		Services     func(childComplexity int) int
		Vendor       func(childComplexity int) int
	}

	ErrorExtensions struct {
		Category             func(childComplexity int) int
		Code                 func(childComplexity int) int
		DocsURL              func(childComplexity int) int
		Field                func(childComplexity int) int
		Recoverable          func(childComplexity int) int
		RequestID            func(childComplexity int) int
		SuggestedFix         func(childComplexity int) int
		TroubleshootingSteps func(childComplexity int) int
		Value                func(childComplexity int) int
	}

	ExportConfigPayload struct {
		Config          func(childComplexity int) int
		Errors          func(childComplexity int) int
		SecurityWarning func(childComplexity int) int
		Success         func(childComplexity int) int
	}

	FeatureCompatibilityInfo struct {
		DependsOn        func(childComplexity int) int
		FeatureID        func(childComplexity int) int
		MaxVersion       func(childComplexity int) int
		MinVersion       func(childComplexity int) int
		MinVersionChr    func(childComplexity int) int
		Name             func(childComplexity int) int
		RequiredPackages func(childComplexity int) int
		UpgradeURL       func(childComplexity int) int
	}

	FeatureSupport struct {
		FeatureID        func(childComplexity int) int
		Level            func(childComplexity int) int
		MissingPackages  func(childComplexity int) int
		Name             func(childComplexity int) int
		Reason           func(childComplexity int) int
		RequiredPackages func(childComplexity int) int
		RequiredVersion  func(childComplexity int) int
		Supported        func(childComplexity int) int
		UpgradeURL       func(childComplexity int) int
	}

	HardwareInfo struct {
		Architecture     func(childComplexity int) int
		AvailableStorage func(childComplexity int) int
		BoardName        func(childComplexity int) int
		CPUCount         func(childComplexity int) int
		HasLTEModule     func(childComplexity int) int
		HasWirelessChip  func(childComplexity int) int
		Model            func(childComplexity int) int
		TotalMemory      func(childComplexity int) int
	}

	HealthCheckResult struct {
		CheckedAt      func(childComplexity int) int
		Error          func(childComplexity int) int
		Healthy        func(childComplexity int) int
		ResponseTimeMs func(childComplexity int) int
		RouterID       func(childComplexity int) int
	}

	HealthStatus struct {
		CheckedAt        func(childComplexity int) int
		ConnectedRouters func(childComplexity int) int
		Status           func(childComplexity int) int
		Uptime           func(childComplexity int) int
		Version          func(childComplexity int) int
	}

	Interface struct {
		Comment    func(childComplexity int) int
		Enabled    func(childComplexity int) int
		ID         func(childComplexity int) int
		MacAddress func(childComplexity int) int
		Mtu        func(childComplexity int) int
		Name       func(childComplexity int) int
		Running    func(childComplexity int) int
		RxBytes    func(childComplexity int) int
		TxBytes    func(childComplexity int) int
		Type       func(childComplexity int) int
	}

	InterfaceConnection struct {
		Edges      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	InterfaceEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	InterfaceTrafficEvent struct {
		InterfaceID   func(childComplexity int) int
		InterfaceName func(childComplexity int) int
		RxRate        func(childComplexity int) int
		RxTotal       func(childComplexity int) int
		Timestamp     func(childComplexity int) int
		TxRate        func(childComplexity int) int
		TxTotal       func(childComplexity int) int
	}

	Mutation struct {
		AddRouter               func(childComplexity int, input model.AddRouterInput) int
		AutoScanGateways        func(childComplexity int) int
		CancelScan              func(childComplexity int, taskID string) int
		ChangePassword          func(childComplexity int, currentPassword string, newPassword string) int
		CheckRouterHealth       func(childComplexity int, routerID string) int
		ConnectRouter           func(childComplexity int, id string) int
		CreateRouter            func(childComplexity int, input model.CreateRouterInput) int
		DeleteRouter            func(childComplexity int, id string) int
		DisconnectRouter        func(childComplexity int, id string) int
		ExportRouterConfig      func(childComplexity int, input model.ExportConfigInput) int
		Login                   func(childComplexity int, username string, password string) int
		Logout                  func(childComplexity int) int
		ReconnectRouter         func(childComplexity int, routerID string) int
		RefreshCapabilities     func(childComplexity int, routerID string) int
		ResetCircuitBreaker     func(childComplexity int, routerID string) int
		RevokeAllSessions       func(childComplexity int, userID string) int
		RevokeSession           func(childComplexity int, sessionID string) int
		RunDiagnostics          func(childComplexity int, routerID string) int
		ScanNetwork             func(childComplexity int, input model.ScanNetworkInput) int
		SetPreferredProtocol    func(childComplexity int, routerID string, protocol model.Protocol) int
		TestAllCredentials      func(childComplexity int) int
		TestRouterConnection    func(childComplexity int, id string) int
		TestRouterCredentials   func(childComplexity int, input model.AddRouterInput) int
		UpdateRouter            func(childComplexity int, id string, input model.UpdateRouterInput) int
		UpdateRouterCredentials func(childComplexity int, routerID string, input model.CredentialsInput) int
	}

	MutationError struct {
		Code    func(childComplexity int) int
		Field   func(childComplexity int) int
		Message func(childComplexity int) int
	}

	PageInfo struct {
		EndCursor       func(childComplexity int) int
		HasNextPage     func(childComplexity int) int
		HasPreviousPage func(childComplexity int) int
		StartCursor     func(childComplexity int) int
	}

	PortStatus struct {
		Error          func(childComplexity int) int
		Open           func(childComplexity int) int
		Port           func(childComplexity int) int
		ResponseTimeMs func(childComplexity int) int
		Service        func(childComplexity int) int
	}

	Query struct {
		CircuitBreakerStatus   func(childComplexity int, routerID string) int
		CompatibilityMatrix    func(childComplexity int) int
		ConnectionAttempts     func(childComplexity int, routerID string, limit *int) int
		ConnectionDetails      func(childComplexity int, routerID string) int
		ConnectionStats        func(childComplexity int) int
		Health                 func(childComplexity int) int
		Interface              func(childComplexity int, routerID string, id string) int
		Interfaces             func(childComplexity int, routerID string, typeArg *model.InterfaceType, pagination *model.PaginationInput) int
		IsFeatureSupported     func(childComplexity int, routerID string, featureID string) int
		Me                     func(childComplexity int) int
		MySessions             func(childComplexity int) int
		Node                   func(childComplexity int, id string) int
		Router                 func(childComplexity int, id string) int
		RouterCapabilities     func(childComplexity int, routerID string) int
		RouterCredentials      func(childComplexity int, routerID string) int
		RouterHealth           func(childComplexity int, routerID string) int
		Routers                func(childComplexity int, status *model.ConnectionStatus, pagination *model.PaginationInput) int
		ScanHistory            func(childComplexity int, limit *int) int
		ScanStatus             func(childComplexity int, taskID string) int
		SupportedFeatures      func(childComplexity int, routerID string) int
		UnsupportedFeatures    func(childComplexity int, routerID string) int
		UpgradeRecommendation  func(childComplexity int, routerID string, featureID string) int
		UpgradeRecommendations func(childComplexity int, routerID string) int
		Version                func(childComplexity int) int
	}

	ReconnectRouterPayload struct {
		ConnectionDetails func(childComplexity int) int
		Errors            func(childComplexity int) int
		Initiated         func(childComplexity int) int
		Router            func(childComplexity int) int
		WaitTimeMs        func(childComplexity int) int
	}

	RefreshCapabilitiesPayload struct {
		Capabilities func(childComplexity int) int
		Errors       func(childComplexity int) int
	}

	ResourceUpdatedEvent struct {
		ChangeType    func(childComplexity int) int
		ChangedFields func(childComplexity int) int
		ResourceID    func(childComplexity int) int
		ResourceType  func(childComplexity int) int
		RouterID      func(childComplexity int) int
		Timestamp     func(childComplexity int) int
		Version       func(childComplexity int) int
	}

	Router struct {
		Capabilities  func(childComplexity int) int
		CreatedAt     func(childComplexity int) int
		Host          func(childComplexity int) int
		ID            func(childComplexity int) int
		LastConnected func(childComplexity int) int
		Model         func(childComplexity int) int
		Name          func(childComplexity int) int
		Platform      func(childComplexity int) int
		Port          func(childComplexity int) int
		Status        func(childComplexity int) int
		UpdatedAt     func(childComplexity int) int
		Uptime        func(childComplexity int) int
		Version       func(childComplexity int) int
	}

	RouterAddedEvent struct {
		AddedBy      func(childComplexity int) int
		ProtocolUsed func(childComplexity int) int
		Router       func(childComplexity int) int
		Timestamp    func(childComplexity int) int
	}

	RouterCapabilities struct {
		Capabilities        func(childComplexity int) int
		Container           func(childComplexity int) int
		DetectedAt          func(childComplexity int) int
		ExpiresAt           func(childComplexity int) int
		Hardware            func(childComplexity int) int
		IsRefreshing        func(childComplexity int) int
		RouterOSVersion     func(childComplexity int) int
		Software            func(childComplexity int) int
		SupportedFeatures   func(childComplexity int) int
		UnsupportedFeatures func(childComplexity int) int
		VifRequirements     func(childComplexity int) int
	}

	RouterConnection struct {
		Edges      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	RouterCredentials struct {
		CreatedAt        func(childComplexity int) int
		EncryptionStatus func(childComplexity int) int
		HasPassword      func(childComplexity int) int
		KeyVersion       func(childComplexity int) int
		LastUpdated      func(childComplexity int) int
		RouterID         func(childComplexity int) int
		Username         func(childComplexity int) int
	}

	RouterEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	RouterOSInfo struct {
		Architecture func(childComplexity int) int
		BoardName    func(childComplexity int) int
		Platform     func(childComplexity int) int
		Version      func(childComplexity int) int
	}

	RouterOSVersion struct {
		Channel         func(childComplexity int) int
		IsAtLeast       func(childComplexity int, version string) int
		IsChr           func(childComplexity int) int
		Major           func(childComplexity int) int
		Minor           func(childComplexity int) int
		Patch           func(childComplexity int) int
		Raw             func(childComplexity int) int
		SupportsFeature func(childComplexity int, featureID string) int
	}

	RouterStatusEvent struct {
		NewStatus      func(childComplexity int) int
		PreviousStatus func(childComplexity int) int
		Router         func(childComplexity int) int
		Timestamp      func(childComplexity int) int
	}

	ScanNetworkPayload struct {
		Errors func(childComplexity int) int
		Task   func(childComplexity int) int
	}

	ScanProgressEvent struct {
		CurrentIP    func(childComplexity int) int
		DevicesFound func(childComplexity int) int
		Progress     func(childComplexity int) int
		Status       func(childComplexity int) int
		TaskID       func(childComplexity int) int
		Timestamp    func(childComplexity int) int
	}

	ScanTask struct {
		EndTime    func(childComplexity int) int
		Error      func(childComplexity int) int
		ID         func(childComplexity int) int
		Progress   func(childComplexity int) int
		Results    func(childComplexity int) int
		ScannedIPs func(childComplexity int) int
		StartTime  func(childComplexity int) int
		Status     func(childComplexity int) int
		Subnet     func(childComplexity int) int
		TotalIPs   func(childComplexity int) int
	}

	Session struct {
		CreatedAt    func(childComplexity int) int
		ID           func(childComplexity int) int
		IPAddress    func(childComplexity int) int
		IsCurrent    func(childComplexity int) int
		LastActivity func(childComplexity int) int
		UserAgent    func(childComplexity int) int
	}

	SetPreferredProtocolPayload struct {
		ConnectionDetails func(childComplexity int) int
		Errors            func(childComplexity int) int
		Router            func(childComplexity int) int
	}

	SoftwareInfo struct {
		InstalledPackages func(childComplexity int) int
		LicenseLevel      func(childComplexity int) int
		UpdateChannel     func(childComplexity int) int
		Version           func(childComplexity int) int
		VersionMajor      func(childComplexity int) int
		VersionMinor      func(childComplexity int) int
		VersionPatch      func(childComplexity int) int
	}

	Subscription struct {
		CircuitBreakerChanged      func(childComplexity int, routerID string) int
		CircuitBreakerStateChanged func(childComplexity int, routerID *string) int
		ConfigApplyProgress        func(childComplexity int, operationID string) int
		ConnectionHealth           func(childComplexity int, routerID *string) int
		InterfaceTraffic           func(childComplexity int, routerID string, interfaceID *string) int
		ResourceUpdated            func(childComplexity int, resourceID *string) int
		RouterAdded                func(childComplexity int) int
		RouterStatusChanged        func(childComplexity int, routerID *string) int
		ScanProgress               func(childComplexity int, taskID string) int
	}

	TLSStatus struct {
		Error     func(childComplexity int) int
		ExpiresAt func(childComplexity int) int
		Issuer    func(childComplexity int) int
		Subject   func(childComplexity int) int
		Valid     func(childComplexity int) int
	}

	TestAllCredentialsPayload struct {
		FailureCount func(childComplexity int) int
		Results      func(childComplexity int) int
		SuccessCount func(childComplexity int) int
		TotalRouters func(childComplexity int) int
	}

	TestConnectionPayload struct {
		Error          func(childComplexity int) int
		ResponseTimeMs func(childComplexity int) int
		Success        func(childComplexity int) int
		Version        func(childComplexity int) int
	}

	UpdateRouterPayload struct {
		Errors func(childComplexity int) int
		Router func(childComplexity int) int
	}

	UpgradeImpact struct {
		BackupRecommended func(childComplexity int) int
		BreakingChanges   func(childComplexity int) int
		EstimatedDowntime func(childComplexity int) int
		RequiresReboot    func(childComplexity int) int
	}

	UpgradeRecommendation struct {
		CurrentVersion   func(childComplexity int) int
		DocumentationURL func(childComplexity int) int
		FeatureID        func(childComplexity int) int
		FeatureName      func(childComplexity int) int
		Impact           func(childComplexity int) int
		IsMajorUpgrade   func(childComplexity int) int
		Priority         func(childComplexity int) int
		RequiredVersion  func(childComplexity int) int
		Steps            func(childComplexity int) int
		Warnings         func(childComplexity int) int
	}

	UpgradeStep struct {
		Command     func(childComplexity int) int
		Description func(childComplexity int) int
		Optional    func(childComplexity int) int
		Step        func(childComplexity int) int
		Title       func(childComplexity int) int
	}

	User struct {
		CreatedAt   func(childComplexity int) int
		DisplayName func(childComplexity int) int
		Email       func(childComplexity int) int
		ID          func(childComplexity int) int
		LastLoginAt func(childComplexity int) int
		Role        func(childComplexity int) int
		Username    func(childComplexity int) int
	}

	VIFGuidanceStep struct {
		Completed     func(childComplexity int) int
		Description   func(childComplexity int) int
		RouterCommand func(childComplexity int) int
		Step          func(childComplexity int) int
		Title         func(childComplexity int) int
	}

	VIFRequirements struct {
		ContainerEnabled  func(childComplexity int) int
		ContainerPackage  func(childComplexity int) int
		GuidanceSteps     func(childComplexity int) int
		Met               func(childComplexity int) int
		MissingReasons    func(childComplexity int) int
		NetworkNamespace  func(childComplexity int) int
		RouterOSVersion   func(childComplexity int) int
		SufficientStorage func(childComplexity int) int
	}

	ValidationError struct {
		Code          func(childComplexity int) int
		Field         func(childComplexity int) int
		Message       func(childComplexity int) int
		ProvidedValue func(childComplexity int) int
		Suggestion    func(childComplexity int) int
	}
}

type MutationResolver interface {
	CreateRouter(ctx context.Context, input model.CreateRouterInput) (*model.CreateRouterPayload, error)
	UpdateRouter(ctx context.Context, id string, input model.UpdateRouterInput) (*model.UpdateRouterPayload, error)
	DeleteRouter(ctx context.Context, id string) (*model.DeleteRouterPayload, error)
	TestRouterConnection(ctx context.Context, id string) (*model.TestConnectionPayload, error)
	ConnectRouter(ctx context.Context, id string) (*model.ConnectRouterPayload, error)
	DisconnectRouter(ctx context.Context, id string) (*model.DisconnectRouterPayload, error)
	RefreshCapabilities(ctx context.Context, routerID string) (*model.RefreshCapabilitiesPayload, error)
	Login(ctx context.Context, username string, password string) (*model.AuthPayload, error)
	Logout(ctx context.Context) (bool, error)
	ChangePassword(ctx context.Context, currentPassword string, newPassword string) (bool, error)
	RevokeAllSessions(ctx context.Context, userID string) (bool, error)
	RevokeSession(ctx context.Context, sessionID string) (bool, error)
	SetPreferredProtocol(ctx context.Context, routerID string, protocol model.Protocol) (*model.SetPreferredProtocolPayload, error)
	ReconnectRouter(ctx context.Context, routerID string) (*model.ReconnectRouterPayload, error)
	CheckRouterHealth(ctx context.Context, routerID string) (*model.HealthCheckResult, error)
	UpdateRouterCredentials(ctx context.Context, routerID string, input model.CredentialsInput) (*model.CredentialUpdatePayload, error)
	TestAllCredentials(ctx context.Context) (*model.TestAllCredentialsPayload, error)
	ExportRouterConfig(ctx context.Context, input model.ExportConfigInput) (*model.ExportConfigPayload, error)
	RunDiagnostics(ctx context.Context, routerID string) (*model.DiagnosticReport, error)
	ResetCircuitBreaker(ctx context.Context, routerID string) (*model.CircuitBreakerStatus, error)
	AddRouter(ctx context.Context, input model.AddRouterInput) (*model.AddRouterPayload, error)
	TestRouterCredentials(ctx context.Context, input model.AddRouterInput) (*model.ConnectionTestResult, error)
	ScanNetwork(ctx context.Context, input model.ScanNetworkInput) (*model.ScanNetworkPayload, error)
	AutoScanGateways(ctx context.Context) (*model.ScanNetworkPayload, error)
	CancelScan(ctx context.Context, taskID string) (*model.CancelScanPayload, error)
}
type QueryResolver interface {
	Node(ctx context.Context, id string) (model.Node, error)
	Health(ctx context.Context) (*model.HealthStatus, error)
	Version(ctx context.Context) (string, error)
	Router(ctx context.Context, id string) (*model.Router, error)
	Routers(ctx context.Context, status *model.ConnectionStatus, pagination *model.PaginationInput) (*model.RouterConnection, error)
	Interface(ctx context.Context, routerID string, id string) (*model.Interface, error)
	Interfaces(ctx context.Context, routerID string, typeArg *model.InterfaceType, pagination *model.PaginationInput) (*model.InterfaceConnection, error)
	RouterCapabilities(ctx context.Context, routerID string) (*model.RouterCapabilities, error)
	IsFeatureSupported(ctx context.Context, routerID string, featureID string) (*model.FeatureSupport, error)
	SupportedFeatures(ctx context.Context, routerID string) ([]*model.FeatureSupport, error)
	UnsupportedFeatures(ctx context.Context, routerID string) ([]*model.FeatureSupport, error)
	CompatibilityMatrix(ctx context.Context) ([]*model.FeatureCompatibilityInfo, error)
	UpgradeRecommendation(ctx context.Context, routerID string, featureID string) (*model.UpgradeRecommendation, error)
	UpgradeRecommendations(ctx context.Context, routerID string) ([]*model.UpgradeRecommendation, error)
	Me(ctx context.Context) (*model.User, error)
	MySessions(ctx context.Context) ([]*model.Session, error)
	ConnectionDetails(ctx context.Context, routerID string) (*model.ConnectionDetails, error)
	RouterHealth(ctx context.Context, routerID string) (*model.HealthCheckResult, error)
	ConnectionStats(ctx context.Context) (*model.ConnectionStats, error)
	RouterCredentials(ctx context.Context, routerID string) (*model.RouterCredentials, error)
	ConnectionAttempts(ctx context.Context, routerID string, limit *int) ([]*model.ConnectionAttempt, error)
	CircuitBreakerStatus(ctx context.Context, routerID string) (*model.CircuitBreakerStatus, error)
	ScanStatus(ctx context.Context, taskID string) (*model.ScanTask, error)
	ScanHistory(ctx context.Context, limit *int) ([]*model.ScanTask, error)
}
type SubscriptionResolver interface {
	RouterStatusChanged(ctx context.Context, routerID *string) (<-chan *model.RouterStatusEvent, error)
	InterfaceTraffic(ctx context.Context, routerID string, interfaceID *string) (<-chan *model.InterfaceTrafficEvent, error)
	ResourceUpdated(ctx context.Context, resourceID *string) (<-chan *model.ResourceUpdatedEvent, error)
	ConfigApplyProgress(ctx context.Context, operationID string) (<-chan *model.ConfigProgress, error)
	ConnectionHealth(ctx context.Context, routerID *string) (<-chan *model.HealthCheckResult, error)
	CircuitBreakerChanged(ctx context.Context, routerID string) (<-chan *model.CircuitBreakerEvent, error)
	CircuitBreakerStateChanged(ctx context.Context, routerID *string) (<-chan *model.CircuitBreakerStatus, error)
	RouterAdded(ctx context.Context) (<-chan *model.RouterAddedEvent, error)
	ScanProgress(ctx context.Context, taskID string) (<-chan *model.ScanProgressEvent, error)
}

type executableSchema struct {
	schema     *ast.Schema
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	if e.schema != nil {
		return e.schema
	}
	return parsedSchema
}

func (e *executableSchema) Complexity(typeName, field string, childComplexity int, rawArgs map[string]interface{}) (int, bool) {
	ec := executionContext{nil, e, 0, 0, nil}
	_ = ec
	switch typeName + "." + field {

	case "AddRouterPayload.connectionResult":
		if e.complexity.AddRouterPayload.ConnectionResult == nil {
			break
		}

		return e.complexity.AddRouterPayload.ConnectionResult(childComplexity), true

	case "AddRouterPayload.errors":
		if e.complexity.AddRouterPayload.Errors == nil {
			break
		}

		return e.complexity.AddRouterPayload.Errors(childComplexity), true

	case "AddRouterPayload.router":
		if e.complexity.AddRouterPayload.Router == nil {
			break
		}

		return e.complexity.AddRouterPayload.Router(childComplexity), true

	case "AddRouterPayload.validationErrors":
		if e.complexity.AddRouterPayload.ValidationErrors == nil {
			break
		}

		return e.complexity.AddRouterPayload.ValidationErrors(childComplexity), true

	case "AuthPayload.expiresAt":
		if e.complexity.AuthPayload.ExpiresAt == nil {
			break
		}

		return e.complexity.AuthPayload.ExpiresAt(childComplexity), true

	case "AuthPayload.token":
		if e.complexity.AuthPayload.Token == nil {
			break
		}

		return e.complexity.AuthPayload.Token(childComplexity), true

	case "AuthPayload.user":
		if e.complexity.AuthPayload.User == nil {
			break
		}

		return e.complexity.AuthPayload.User(childComplexity), true

	case "AuthStatus.error":
		if e.complexity.AuthStatus.Error == nil {
			break
		}

		return e.complexity.AuthStatus.Error(childComplexity), true

	case "AuthStatus.errorCode":
		if e.complexity.AuthStatus.ErrorCode == nil {
			break
		}

		return e.complexity.AuthStatus.ErrorCode(childComplexity), true

	case "AuthStatus.success":
		if e.complexity.AuthStatus.Success == nil {
			break
		}

		return e.complexity.AuthStatus.Success(childComplexity), true

	case "AuthStatus.tested":
		if e.complexity.AuthStatus.Tested == nil {
			break
		}

		return e.complexity.AuthStatus.Tested(childComplexity), true

	case "CancelScanPayload.errors":
		if e.complexity.CancelScanPayload.Errors == nil {
			break
		}

		return e.complexity.CancelScanPayload.Errors(childComplexity), true

	case "CancelScanPayload.task":
		if e.complexity.CancelScanPayload.Task == nil {
			break
		}

		return e.complexity.CancelScanPayload.Task(childComplexity), true

	case "CapabilityEntry.capability":
		if e.complexity.CapabilityEntry.Capability == nil {
			break
		}

		return e.complexity.CapabilityEntry.Capability(childComplexity), true

	case "CapabilityEntry.description":
		if e.complexity.CapabilityEntry.Description == nil {
			break
		}

		return e.complexity.CapabilityEntry.Description(childComplexity), true

	case "CapabilityEntry.guidance":
		if e.complexity.CapabilityEntry.Guidance == nil {
			break
		}

		return e.complexity.CapabilityEntry.Guidance(childComplexity), true

	case "CapabilityEntry.level":
		if e.complexity.CapabilityEntry.Level == nil {
			break
		}

		return e.complexity.CapabilityEntry.Level(childComplexity), true

	case "CircuitBreakerEvent.consecutiveFailures":
		if e.complexity.CircuitBreakerEvent.ConsecutiveFailures == nil {
			break
		}

		return e.complexity.CircuitBreakerEvent.ConsecutiveFailures(childComplexity), true

	case "CircuitBreakerEvent.newState":
		if e.complexity.CircuitBreakerEvent.NewState == nil {
			break
		}

		return e.complexity.CircuitBreakerEvent.NewState(childComplexity), true

	case "CircuitBreakerEvent.previousState":
		if e.complexity.CircuitBreakerEvent.PreviousState == nil {
			break
		}

		return e.complexity.CircuitBreakerEvent.PreviousState(childComplexity), true

	case "CircuitBreakerEvent.routerId":
		if e.complexity.CircuitBreakerEvent.RouterID == nil {
			break
		}

		return e.complexity.CircuitBreakerEvent.RouterID(childComplexity), true

	case "CircuitBreakerEvent.timestamp":
		if e.complexity.CircuitBreakerEvent.Timestamp == nil {
			break
		}

		return e.complexity.CircuitBreakerEvent.Timestamp(childComplexity), true

	case "CircuitBreakerStatus.cooldownRemainingSeconds":
		if e.complexity.CircuitBreakerStatus.CooldownRemainingSeconds == nil {
			break
		}

		return e.complexity.CircuitBreakerStatus.CooldownRemainingSeconds(childComplexity), true

	case "CircuitBreakerStatus.failureCount":
		if e.complexity.CircuitBreakerStatus.FailureCount == nil {
			break
		}

		return e.complexity.CircuitBreakerStatus.FailureCount(childComplexity), true

	case "CircuitBreakerStatus.failureThreshold":
		if e.complexity.CircuitBreakerStatus.FailureThreshold == nil {
			break
		}

		return e.complexity.CircuitBreakerStatus.FailureThreshold(childComplexity), true

	case "CircuitBreakerStatus.lastFailureAt":
		if e.complexity.CircuitBreakerStatus.LastFailureAt == nil {
			break
		}

		return e.complexity.CircuitBreakerStatus.LastFailureAt(childComplexity), true

	case "CircuitBreakerStatus.lastSuccessAt":
		if e.complexity.CircuitBreakerStatus.LastSuccessAt == nil {
			break
		}

		return e.complexity.CircuitBreakerStatus.LastSuccessAt(childComplexity), true

	case "CircuitBreakerStatus.routerId":
		if e.complexity.CircuitBreakerStatus.RouterID == nil {
			break
		}

		return e.complexity.CircuitBreakerStatus.RouterID(childComplexity), true

	case "CircuitBreakerStatus.state":
		if e.complexity.CircuitBreakerStatus.State == nil {
			break
		}

		return e.complexity.CircuitBreakerStatus.State(childComplexity), true

	case "ConfigProgress.currentStep":
		if e.complexity.ConfigProgress.CurrentStep == nil {
			break
		}

		return e.complexity.ConfigProgress.CurrentStep(childComplexity), true

	case "ConfigProgress.message":
		if e.complexity.ConfigProgress.Message == nil {
			break
		}

		return e.complexity.ConfigProgress.Message(childComplexity), true

	case "ConfigProgress.operationId":
		if e.complexity.ConfigProgress.OperationID == nil {
			break
		}

		return e.complexity.ConfigProgress.OperationID(childComplexity), true

	case "ConfigProgress.percentage":
		if e.complexity.ConfigProgress.Percentage == nil {
			break
		}

		return e.complexity.ConfigProgress.Percentage(childComplexity), true

	case "ConfigProgress.status":
		if e.complexity.ConfigProgress.Status == nil {
			break
		}

		return e.complexity.ConfigProgress.Status(childComplexity), true

	case "ConfigProgress.timestamp":
		if e.complexity.ConfigProgress.Timestamp == nil {
			break
		}

		return e.complexity.ConfigProgress.Timestamp(childComplexity), true

	case "ConfigProgress.totalSteps":
		if e.complexity.ConfigProgress.TotalSteps == nil {
			break
		}

		return e.complexity.ConfigProgress.TotalSteps(childComplexity), true

	case "ConnectRouterPayload.errors":
		if e.complexity.ConnectRouterPayload.Errors == nil {
			break
		}

		return e.complexity.ConnectRouterPayload.Errors(childComplexity), true

	case "ConnectRouterPayload.router":
		if e.complexity.ConnectRouterPayload.Router == nil {
			break
		}

		return e.complexity.ConnectRouterPayload.Router(childComplexity), true

	case "ConnectionAttempt.endedAt":
		if e.complexity.ConnectionAttempt.EndedAt == nil {
			break
		}

		return e.complexity.ConnectionAttempt.EndedAt(childComplexity), true

	case "ConnectionAttempt.errorCategory":
		if e.complexity.ConnectionAttempt.ErrorCategory == nil {
			break
		}

		return e.complexity.ConnectionAttempt.ErrorCategory(childComplexity), true

	case "ConnectionAttempt.errorCode":
		if e.complexity.ConnectionAttempt.ErrorCode == nil {
			break
		}

		return e.complexity.ConnectionAttempt.ErrorCode(childComplexity), true

	case "ConnectionAttempt.errorMessage":
		if e.complexity.ConnectionAttempt.ErrorMessage == nil {
			break
		}

		return e.complexity.ConnectionAttempt.ErrorMessage(childComplexity), true

	case "ConnectionAttempt.protocol":
		if e.complexity.ConnectionAttempt.Protocol == nil {
			break
		}

		return e.complexity.ConnectionAttempt.Protocol(childComplexity), true

	case "ConnectionAttempt.startedAt":
		if e.complexity.ConnectionAttempt.StartedAt == nil {
			break
		}

		return e.complexity.ConnectionAttempt.StartedAt(childComplexity), true

	case "ConnectionAttempt.success":
		if e.complexity.ConnectionAttempt.Success == nil {
			break
		}

		return e.complexity.ConnectionAttempt.Success(childComplexity), true

	case "ConnectionDetails.circuitBreakerState":
		if e.complexity.ConnectionDetails.CircuitBreakerState == nil {
			break
		}

		return e.complexity.ConnectionDetails.CircuitBreakerState(childComplexity), true

	case "ConnectionDetails.connectedAt":
		if e.complexity.ConnectionDetails.ConnectedAt == nil {
			break
		}

		return e.complexity.ConnectionDetails.ConnectedAt(childComplexity), true

	case "ConnectionDetails.disconnectReason":
		if e.complexity.ConnectionDetails.DisconnectReason == nil {
			break
		}

		return e.complexity.ConnectionDetails.DisconnectReason(childComplexity), true

	case "ConnectionDetails.disconnectedAt":
		if e.complexity.ConnectionDetails.DisconnectedAt == nil {
			break
		}

		return e.complexity.ConnectionDetails.DisconnectedAt(childComplexity), true

	case "ConnectionDetails.healthChecksFailed":
		if e.complexity.ConnectionDetails.HealthChecksFailed == nil {
			break
		}

		return e.complexity.ConnectionDetails.HealthChecksFailed(childComplexity), true

	case "ConnectionDetails.healthChecksPassed":
		if e.complexity.ConnectionDetails.HealthChecksPassed == nil {
			break
		}

		return e.complexity.ConnectionDetails.HealthChecksPassed(childComplexity), true

	case "ConnectionDetails.isLegacyProtocol":
		if e.complexity.ConnectionDetails.IsLegacyProtocol == nil {
			break
		}

		return e.complexity.ConnectionDetails.IsLegacyProtocol(childComplexity), true

	case "ConnectionDetails.lastError":
		if e.complexity.ConnectionDetails.LastError == nil {
			break
		}

		return e.complexity.ConnectionDetails.LastError(childComplexity), true

	case "ConnectionDetails.lastErrorTime":
		if e.complexity.ConnectionDetails.LastErrorTime == nil {
			break
		}

		return e.complexity.ConnectionDetails.LastErrorTime(childComplexity), true

	case "ConnectionDetails.lastHealthCheck":
		if e.complexity.ConnectionDetails.LastHealthCheck == nil {
			break
		}

		return e.complexity.ConnectionDetails.LastHealthCheck(childComplexity), true

	case "ConnectionDetails.nextReconnectAt":
		if e.complexity.ConnectionDetails.NextReconnectAt == nil {
			break
		}

		return e.complexity.ConnectionDetails.NextReconnectAt(childComplexity), true

	case "ConnectionDetails.preferredProtocol":
		if e.complexity.ConnectionDetails.PreferredProtocol == nil {
			break
		}

		return e.complexity.ConnectionDetails.PreferredProtocol(childComplexity), true

	case "ConnectionDetails.protocol":
		if e.complexity.ConnectionDetails.Protocol == nil {
			break
		}

		return e.complexity.ConnectionDetails.Protocol(childComplexity), true

	case "ConnectionDetails.reconnectAttempts":
		if e.complexity.ConnectionDetails.ReconnectAttempts == nil {
			break
		}

		return e.complexity.ConnectionDetails.ReconnectAttempts(childComplexity), true

	case "ConnectionDetails.securityWarning":
		if e.complexity.ConnectionDetails.SecurityWarning == nil {
			break
		}

		return e.complexity.ConnectionDetails.SecurityWarning(childComplexity), true

	case "ConnectionDetails.state":
		if e.complexity.ConnectionDetails.State == nil {
			break
		}

		return e.complexity.ConnectionDetails.State(childComplexity), true

	case "ConnectionDetails.upgradeRecommendation":
		if e.complexity.ConnectionDetails.UpgradeRecommendation == nil {
			break
		}

		return e.complexity.ConnectionDetails.UpgradeRecommendation(childComplexity), true

	case "ConnectionDetails.uptime":
		if e.complexity.ConnectionDetails.Uptime == nil {
			break
		}

		return e.complexity.ConnectionDetails.Uptime(childComplexity), true

	case "ConnectionDetails.version":
		if e.complexity.ConnectionDetails.Version == nil {
			break
		}

		return e.complexity.ConnectionDetails.Version(childComplexity), true

	case "ConnectionError.code":
		if e.complexity.ConnectionError.Code == nil {
			break
		}

		return e.complexity.ConnectionError.Code(childComplexity), true

	case "ConnectionError.message":
		if e.complexity.ConnectionError.Message == nil {
			break
		}

		return e.complexity.ConnectionError.Message(childComplexity), true

	case "ConnectionError.protocol":
		if e.complexity.ConnectionError.Protocol == nil {
			break
		}

		return e.complexity.ConnectionError.Protocol(childComplexity), true

	case "ConnectionError.retryable":
		if e.complexity.ConnectionError.Retryable == nil {
			break
		}

		return e.complexity.ConnectionError.Retryable(childComplexity), true

	case "ConnectionError.suggestedAction":
		if e.complexity.ConnectionError.SuggestedAction == nil {
			break
		}

		return e.complexity.ConnectionError.SuggestedAction(childComplexity), true

	case "ConnectionError.timeoutMs":
		if e.complexity.ConnectionError.TimeoutMs == nil {
			break
		}

		return e.complexity.ConnectionError.TimeoutMs(childComplexity), true

	case "ConnectionStats.connected":
		if e.complexity.ConnectionStats.Connected == nil {
			break
		}

		return e.complexity.ConnectionStats.Connected(childComplexity), true

	case "ConnectionStats.connecting":
		if e.complexity.ConnectionStats.Connecting == nil {
			break
		}

		return e.complexity.ConnectionStats.Connecting(childComplexity), true

	case "ConnectionStats.disconnected":
		if e.complexity.ConnectionStats.Disconnected == nil {
			break
		}

		return e.complexity.ConnectionStats.Disconnected(childComplexity), true

	case "ConnectionStats.error":
		if e.complexity.ConnectionStats.Error == nil {
			break
		}

		return e.complexity.ConnectionStats.Error(childComplexity), true

	case "ConnectionStats.reconnecting":
		if e.complexity.ConnectionStats.Reconnecting == nil {
			break
		}

		return e.complexity.ConnectionStats.Reconnecting(childComplexity), true

	case "ConnectionStats.totalConnections":
		if e.complexity.ConnectionStats.TotalConnections == nil {
			break
		}

		return e.complexity.ConnectionStats.TotalConnections(childComplexity), true

	case "ConnectionTestResult.architecture":
		if e.complexity.ConnectionTestResult.Architecture == nil {
			break
		}

		return e.complexity.ConnectionTestResult.Architecture(childComplexity), true

	case "ConnectionTestResult.boardName":
		if e.complexity.ConnectionTestResult.BoardName == nil {
			break
		}

		return e.complexity.ConnectionTestResult.BoardName(childComplexity), true

	case "ConnectionTestResult.error":
		if e.complexity.ConnectionTestResult.Error == nil {
			break
		}

		return e.complexity.ConnectionTestResult.Error(childComplexity), true

	case "ConnectionTestResult.protocolUsed":
		if e.complexity.ConnectionTestResult.ProtocolUsed == nil {
			break
		}

		return e.complexity.ConnectionTestResult.ProtocolUsed(childComplexity), true

	case "ConnectionTestResult.protocolsAttempted":
		if e.complexity.ConnectionTestResult.ProtocolsAttempted == nil {
			break
		}

		return e.complexity.ConnectionTestResult.ProtocolsAttempted(childComplexity), true

	case "ConnectionTestResult.responseTimeMs":
		if e.complexity.ConnectionTestResult.ResponseTimeMs == nil {
			break
		}

		return e.complexity.ConnectionTestResult.ResponseTimeMs(childComplexity), true

	case "ConnectionTestResult.routerModel":
		if e.complexity.ConnectionTestResult.RouterModel == nil {
			break
		}

		return e.complexity.ConnectionTestResult.RouterModel(childComplexity), true

	case "ConnectionTestResult.routerVersion":
		if e.complexity.ConnectionTestResult.RouterVersion == nil {
			break
		}

		return e.complexity.ConnectionTestResult.RouterVersion(childComplexity), true

	case "ConnectionTestResult.success":
		if e.complexity.ConnectionTestResult.Success == nil {
			break
		}

		return e.complexity.ConnectionTestResult.Success(childComplexity), true

	case "ConnectionTestResult.supportsContainers":
		if e.complexity.ConnectionTestResult.SupportsContainers == nil {
			break
		}

		return e.complexity.ConnectionTestResult.SupportsContainers(childComplexity), true

	case "ConnectionTestResult.uptime":
		if e.complexity.ConnectionTestResult.Uptime == nil {
			break
		}

		return e.complexity.ConnectionTestResult.Uptime(childComplexity), true

	case "ContainerInfo.enabled":
		if e.complexity.ContainerInfo.Enabled == nil {
			break
		}

		return e.complexity.ContainerInfo.Enabled(childComplexity), true

	case "ContainerInfo.maxContainers":
		if e.complexity.ContainerInfo.MaxContainers == nil {
			break
		}

		return e.complexity.ContainerInfo.MaxContainers(childComplexity), true

	case "ContainerInfo.packageInstalled":
		if e.complexity.ContainerInfo.PackageInstalled == nil {
			break
		}

		return e.complexity.ContainerInfo.PackageInstalled(childComplexity), true

	case "ContainerInfo.registryConfigured":
		if e.complexity.ContainerInfo.RegistryConfigured == nil {
			break
		}

		return e.complexity.ContainerInfo.RegistryConfigured(childComplexity), true

	case "ContainerInfo.storageAvailable":
		if e.complexity.ContainerInfo.StorageAvailable == nil {
			break
		}

		return e.complexity.ContainerInfo.StorageAvailable(childComplexity), true

	case "ContainerInfo.supportsNetworkNamespace":
		if e.complexity.ContainerInfo.SupportsNetworkNamespace == nil {
			break
		}

		return e.complexity.ContainerInfo.SupportsNetworkNamespace(childComplexity), true

	case "CreateRouterPayload.errors":
		if e.complexity.CreateRouterPayload.Errors == nil {
			break
		}

		return e.complexity.CreateRouterPayload.Errors(childComplexity), true

	case "CreateRouterPayload.router":
		if e.complexity.CreateRouterPayload.Router == nil {
			break
		}

		return e.complexity.CreateRouterPayload.Router(childComplexity), true

	case "CredentialTestResult.error":
		if e.complexity.CredentialTestResult.Error == nil {
			break
		}

		return e.complexity.CredentialTestResult.Error(childComplexity), true

	case "CredentialTestResult.responseTimeMs":
		if e.complexity.CredentialTestResult.ResponseTimeMs == nil {
			break
		}

		return e.complexity.CredentialTestResult.ResponseTimeMs(childComplexity), true

	case "CredentialTestResult.routerId":
		if e.complexity.CredentialTestResult.RouterID == nil {
			break
		}

		return e.complexity.CredentialTestResult.RouterID(childComplexity), true

	case "CredentialTestResult.routerName":
		if e.complexity.CredentialTestResult.RouterName == nil {
			break
		}

		return e.complexity.CredentialTestResult.RouterName(childComplexity), true

	case "CredentialTestResult.status":
		if e.complexity.CredentialTestResult.Status == nil {
			break
		}

		return e.complexity.CredentialTestResult.Status(childComplexity), true

	case "CredentialTestResult.success":
		if e.complexity.CredentialTestResult.Success == nil {
			break
		}

		return e.complexity.CredentialTestResult.Success(childComplexity), true

	case "CredentialUpdatePayload.credentials":
		if e.complexity.CredentialUpdatePayload.Credentials == nil {
			break
		}

		return e.complexity.CredentialUpdatePayload.Credentials(childComplexity), true

	case "CredentialUpdatePayload.errorCode":
		if e.complexity.CredentialUpdatePayload.ErrorCode == nil {
			break
		}

		return e.complexity.CredentialUpdatePayload.ErrorCode(childComplexity), true

	case "CredentialUpdatePayload.errors":
		if e.complexity.CredentialUpdatePayload.Errors == nil {
			break
		}

		return e.complexity.CredentialUpdatePayload.Errors(childComplexity), true

	case "CredentialUpdatePayload.message":
		if e.complexity.CredentialUpdatePayload.Message == nil {
			break
		}

		return e.complexity.CredentialUpdatePayload.Message(childComplexity), true

	case "CredentialUpdatePayload.success":
		if e.complexity.CredentialUpdatePayload.Success == nil {
			break
		}

		return e.complexity.CredentialUpdatePayload.Success(childComplexity), true

	case "DeleteRouterPayload.deletedRouterId":
		if e.complexity.DeleteRouterPayload.DeletedRouterID == nil {
			break
		}

		return e.complexity.DeleteRouterPayload.DeletedRouterID(childComplexity), true

	case "DeleteRouterPayload.errors":
		if e.complexity.DeleteRouterPayload.Errors == nil {
			break
		}

		return e.complexity.DeleteRouterPayload.Errors(childComplexity), true

	case "DeleteRouterPayload.success":
		if e.complexity.DeleteRouterPayload.Success == nil {
			break
		}

		return e.complexity.DeleteRouterPayload.Success(childComplexity), true

	case "DiagnosticReport.authStatus":
		if e.complexity.DiagnosticReport.AuthStatus == nil {
			break
		}

		return e.complexity.DiagnosticReport.AuthStatus(childComplexity), true

	case "DiagnosticReport.networkReachable":
		if e.complexity.DiagnosticReport.NetworkReachable == nil {
			break
		}

		return e.complexity.DiagnosticReport.NetworkReachable(childComplexity), true

	case "DiagnosticReport.portStatus":
		if e.complexity.DiagnosticReport.PortStatus == nil {
			break
		}

		return e.complexity.DiagnosticReport.PortStatus(childComplexity), true

	case "DiagnosticReport.rawReport":
		if e.complexity.DiagnosticReport.RawReport == nil {
			break
		}

		return e.complexity.DiagnosticReport.RawReport(childComplexity), true

	case "DiagnosticReport.routerId":
		if e.complexity.DiagnosticReport.RouterID == nil {
			break
		}

		return e.complexity.DiagnosticReport.RouterID(childComplexity), true

	case "DiagnosticReport.suggestions":
		if e.complexity.DiagnosticReport.Suggestions == nil {
			break
		}

		return e.complexity.DiagnosticReport.Suggestions(childComplexity), true

	case "DiagnosticReport.tlsStatus":
		if e.complexity.DiagnosticReport.TLSStatus == nil {
			break
		}

		return e.complexity.DiagnosticReport.TLSStatus(childComplexity), true

	case "DiagnosticReport.timestamp":
		if e.complexity.DiagnosticReport.Timestamp == nil {
			break
		}

		return e.complexity.DiagnosticReport.Timestamp(childComplexity), true

	case "DiagnosticSuggestion.action":
		if e.complexity.DiagnosticSuggestion.Action == nil {
			break
		}

		return e.complexity.DiagnosticSuggestion.Action(childComplexity), true

	case "DiagnosticSuggestion.description":
		if e.complexity.DiagnosticSuggestion.Description == nil {
			break
		}

		return e.complexity.DiagnosticSuggestion.Description(childComplexity), true

	case "DiagnosticSuggestion.docsUrl":
		if e.complexity.DiagnosticSuggestion.DocsURL == nil {
			break
		}

		return e.complexity.DiagnosticSuggestion.DocsURL(childComplexity), true

	case "DiagnosticSuggestion.severity":
		if e.complexity.DiagnosticSuggestion.Severity == nil {
			break
		}

		return e.complexity.DiagnosticSuggestion.Severity(childComplexity), true

	case "DiagnosticSuggestion.title":
		if e.complexity.DiagnosticSuggestion.Title == nil {
			break
		}

		return e.complexity.DiagnosticSuggestion.Title(childComplexity), true

	case "DisconnectRouterPayload.errors":
		if e.complexity.DisconnectRouterPayload.Errors == nil {
			break
		}

		return e.complexity.DisconnectRouterPayload.Errors(childComplexity), true

	case "DisconnectRouterPayload.router":
		if e.complexity.DisconnectRouterPayload.Router == nil {
			break
		}

		return e.complexity.DisconnectRouterPayload.Router(childComplexity), true

	case "DiscoveredDevice.confidence":
		if e.complexity.DiscoveredDevice.Confidence == nil {
			break
		}

		return e.complexity.DiscoveredDevice.Confidence(childComplexity), true

	case "DiscoveredDevice.deviceType":
		if e.complexity.DiscoveredDevice.DeviceType == nil {
			break
		}

		return e.complexity.DiscoveredDevice.DeviceType(childComplexity), true

	case "DiscoveredDevice.hostname":
		if e.complexity.DiscoveredDevice.Hostname == nil {
			break
		}

		return e.complexity.DiscoveredDevice.Hostname(childComplexity), true

	case "DiscoveredDevice.ip":
		if e.complexity.DiscoveredDevice.IP == nil {
			break
		}

		return e.complexity.DiscoveredDevice.IP(childComplexity), true

	case "DiscoveredDevice.ports":
		if e.complexity.DiscoveredDevice.Ports == nil {
			break
		}

		return e.complexity.DiscoveredDevice.Ports(childComplexity), true

	case "DiscoveredDevice.routerOSInfo":
		if e.complexity.DiscoveredDevice.RouterOSInfo == nil {
			break
		}

		return e.complexity.DiscoveredDevice.RouterOSInfo(childComplexity), true

	case "DiscoveredDevice.services":
		if e.complexity.DiscoveredDevice.Services == nil {
			break
		}

		return e.complexity.DiscoveredDevice.Services(childComplexity), true

	case "DiscoveredDevice.vendor":
		if e.complexity.DiscoveredDevice.Vendor == nil {
			break
		}

		return e.complexity.DiscoveredDevice.Vendor(childComplexity), true

	case "ErrorExtensions.category":
		if e.complexity.ErrorExtensions.Category == nil {
			break
		}

		return e.complexity.ErrorExtensions.Category(childComplexity), true

	case "ErrorExtensions.code":
		if e.complexity.ErrorExtensions.Code == nil {
			break
		}

		return e.complexity.ErrorExtensions.Code(childComplexity), true

	case "ErrorExtensions.docsUrl":
		if e.complexity.ErrorExtensions.DocsURL == nil {
			break
		}

		return e.complexity.ErrorExtensions.DocsURL(childComplexity), true

	case "ErrorExtensions.field":
		if e.complexity.ErrorExtensions.Field == nil {
			break
		}

		return e.complexity.ErrorExtensions.Field(childComplexity), true

	case "ErrorExtensions.recoverable":
		if e.complexity.ErrorExtensions.Recoverable == nil {
			break
		}

		return e.complexity.ErrorExtensions.Recoverable(childComplexity), true

	case "ErrorExtensions.requestId":
		if e.complexity.ErrorExtensions.RequestID == nil {
			break
		}

		return e.complexity.ErrorExtensions.RequestID(childComplexity), true

	case "ErrorExtensions.suggestedFix":
		if e.complexity.ErrorExtensions.SuggestedFix == nil {
			break
		}

		return e.complexity.ErrorExtensions.SuggestedFix(childComplexity), true

	case "ErrorExtensions.troubleshootingSteps":
		if e.complexity.ErrorExtensions.TroubleshootingSteps == nil {
			break
		}

		return e.complexity.ErrorExtensions.TroubleshootingSteps(childComplexity), true

	case "ErrorExtensions.value":
		if e.complexity.ErrorExtensions.Value == nil {
			break
		}

		return e.complexity.ErrorExtensions.Value(childComplexity), true

	case "ExportConfigPayload.config":
		if e.complexity.ExportConfigPayload.Config == nil {
			break
		}

		return e.complexity.ExportConfigPayload.Config(childComplexity), true

	case "ExportConfigPayload.errors":
		if e.complexity.ExportConfigPayload.Errors == nil {
			break
		}

		return e.complexity.ExportConfigPayload.Errors(childComplexity), true

	case "ExportConfigPayload.securityWarning":
		if e.complexity.ExportConfigPayload.SecurityWarning == nil {
			break
		}

		return e.complexity.ExportConfigPayload.SecurityWarning(childComplexity), true

	case "ExportConfigPayload.success":
		if e.complexity.ExportConfigPayload.Success == nil {
			break
		}

		return e.complexity.ExportConfigPayload.Success(childComplexity), true

	case "FeatureCompatibilityInfo.dependsOn":
		if e.complexity.FeatureCompatibilityInfo.DependsOn == nil {
			break
		}

		return e.complexity.FeatureCompatibilityInfo.DependsOn(childComplexity), true

	case "FeatureCompatibilityInfo.featureId":
		if e.complexity.FeatureCompatibilityInfo.FeatureID == nil {
			break
		}

		return e.complexity.FeatureCompatibilityInfo.FeatureID(childComplexity), true

	case "FeatureCompatibilityInfo.maxVersion":
		if e.complexity.FeatureCompatibilityInfo.MaxVersion == nil {
			break
		}

		return e.complexity.FeatureCompatibilityInfo.MaxVersion(childComplexity), true

	case "FeatureCompatibilityInfo.minVersion":
		if e.complexity.FeatureCompatibilityInfo.MinVersion == nil {
			break
		}

		return e.complexity.FeatureCompatibilityInfo.MinVersion(childComplexity), true

	case "FeatureCompatibilityInfo.minVersionCHR":
		if e.complexity.FeatureCompatibilityInfo.MinVersionChr == nil {
			break
		}

		return e.complexity.FeatureCompatibilityInfo.MinVersionChr(childComplexity), true

	case "FeatureCompatibilityInfo.name":
		if e.complexity.FeatureCompatibilityInfo.Name == nil {
			break
		}

		return e.complexity.FeatureCompatibilityInfo.Name(childComplexity), true

	case "FeatureCompatibilityInfo.requiredPackages":
		if e.complexity.FeatureCompatibilityInfo.RequiredPackages == nil {
			break
		}

		return e.complexity.FeatureCompatibilityInfo.RequiredPackages(childComplexity), true

	case "FeatureCompatibilityInfo.upgradeUrl":
		if e.complexity.FeatureCompatibilityInfo.UpgradeURL == nil {
			break
		}

		return e.complexity.FeatureCompatibilityInfo.UpgradeURL(childComplexity), true

	case "FeatureSupport.featureId":
		if e.complexity.FeatureSupport.FeatureID == nil {
			break
		}

		return e.complexity.FeatureSupport.FeatureID(childComplexity), true

	case "FeatureSupport.level":
		if e.complexity.FeatureSupport.Level == nil {
			break
		}

		return e.complexity.FeatureSupport.Level(childComplexity), true

	case "FeatureSupport.missingPackages":
		if e.complexity.FeatureSupport.MissingPackages == nil {
			break
		}

		return e.complexity.FeatureSupport.MissingPackages(childComplexity), true

	case "FeatureSupport.name":
		if e.complexity.FeatureSupport.Name == nil {
			break
		}

		return e.complexity.FeatureSupport.Name(childComplexity), true

	case "FeatureSupport.reason":
		if e.complexity.FeatureSupport.Reason == nil {
			break
		}

		return e.complexity.FeatureSupport.Reason(childComplexity), true

	case "FeatureSupport.requiredPackages":
		if e.complexity.FeatureSupport.RequiredPackages == nil {
			break
		}

		return e.complexity.FeatureSupport.RequiredPackages(childComplexity), true

	case "FeatureSupport.requiredVersion":
		if e.complexity.FeatureSupport.RequiredVersion == nil {
			break
		}

		return e.complexity.FeatureSupport.RequiredVersion(childComplexity), true

	case "FeatureSupport.supported":
		if e.complexity.FeatureSupport.Supported == nil {
			break
		}

		return e.complexity.FeatureSupport.Supported(childComplexity), true

	case "FeatureSupport.upgradeUrl":
		if e.complexity.FeatureSupport.UpgradeURL == nil {
			break
		}

		return e.complexity.FeatureSupport.UpgradeURL(childComplexity), true

	case "HardwareInfo.architecture":
		if e.complexity.HardwareInfo.Architecture == nil {
			break
		}

		return e.complexity.HardwareInfo.Architecture(childComplexity), true

	case "HardwareInfo.availableStorage":
		if e.complexity.HardwareInfo.AvailableStorage == nil {
			break
		}

		return e.complexity.HardwareInfo.AvailableStorage(childComplexity), true

	case "HardwareInfo.boardName":
		if e.complexity.HardwareInfo.BoardName == nil {
			break
		}

		return e.complexity.HardwareInfo.BoardName(childComplexity), true

	case "HardwareInfo.cpuCount":
		if e.complexity.HardwareInfo.CPUCount == nil {
			break
		}

		return e.complexity.HardwareInfo.CPUCount(childComplexity), true

	case "HardwareInfo.hasLTEModule":
		if e.complexity.HardwareInfo.HasLTEModule == nil {
			break
		}

		return e.complexity.HardwareInfo.HasLTEModule(childComplexity), true

	case "HardwareInfo.hasWirelessChip":
		if e.complexity.HardwareInfo.HasWirelessChip == nil {
			break
		}

		return e.complexity.HardwareInfo.HasWirelessChip(childComplexity), true

	case "HardwareInfo.model":
		if e.complexity.HardwareInfo.Model == nil {
			break
		}

		return e.complexity.HardwareInfo.Model(childComplexity), true

	case "HardwareInfo.totalMemory":
		if e.complexity.HardwareInfo.TotalMemory == nil {
			break
		}

		return e.complexity.HardwareInfo.TotalMemory(childComplexity), true

	case "HealthCheckResult.checkedAt":
		if e.complexity.HealthCheckResult.CheckedAt == nil {
			break
		}

		return e.complexity.HealthCheckResult.CheckedAt(childComplexity), true

	case "HealthCheckResult.error":
		if e.complexity.HealthCheckResult.Error == nil {
			break
		}

		return e.complexity.HealthCheckResult.Error(childComplexity), true

	case "HealthCheckResult.healthy":
		if e.complexity.HealthCheckResult.Healthy == nil {
			break
		}

		return e.complexity.HealthCheckResult.Healthy(childComplexity), true

	case "HealthCheckResult.responseTimeMs":
		if e.complexity.HealthCheckResult.ResponseTimeMs == nil {
			break
		}

		return e.complexity.HealthCheckResult.ResponseTimeMs(childComplexity), true

	case "HealthCheckResult.routerId":
		if e.complexity.HealthCheckResult.RouterID == nil {
			break
		}

		return e.complexity.HealthCheckResult.RouterID(childComplexity), true

	case "HealthStatus.checkedAt":
		if e.complexity.HealthStatus.CheckedAt == nil {
			break
		}

		return e.complexity.HealthStatus.CheckedAt(childComplexity), true

	case "HealthStatus.connectedRouters":
		if e.complexity.HealthStatus.ConnectedRouters == nil {
			break
		}

		return e.complexity.HealthStatus.ConnectedRouters(childComplexity), true

	case "HealthStatus.status":
		if e.complexity.HealthStatus.Status == nil {
			break
		}

		return e.complexity.HealthStatus.Status(childComplexity), true

	case "HealthStatus.uptime":
		if e.complexity.HealthStatus.Uptime == nil {
			break
		}

		return e.complexity.HealthStatus.Uptime(childComplexity), true

	case "HealthStatus.version":
		if e.complexity.HealthStatus.Version == nil {
			break
		}

		return e.complexity.HealthStatus.Version(childComplexity), true

	case "Interface.comment":
		if e.complexity.Interface.Comment == nil {
			break
		}

		return e.complexity.Interface.Comment(childComplexity), true

	case "Interface.enabled":
		if e.complexity.Interface.Enabled == nil {
			break
		}

		return e.complexity.Interface.Enabled(childComplexity), true

	case "Interface.id":
		if e.complexity.Interface.ID == nil {
			break
		}

		return e.complexity.Interface.ID(childComplexity), true

	case "Interface.macAddress":
		if e.complexity.Interface.MacAddress == nil {
			break
		}

		return e.complexity.Interface.MacAddress(childComplexity), true

	case "Interface.mtu":
		if e.complexity.Interface.Mtu == nil {
			break
		}

		return e.complexity.Interface.Mtu(childComplexity), true

	case "Interface.name":
		if e.complexity.Interface.Name == nil {
			break
		}

		return e.complexity.Interface.Name(childComplexity), true

	case "Interface.running":
		if e.complexity.Interface.Running == nil {
			break
		}

		return e.complexity.Interface.Running(childComplexity), true

	case "Interface.rxBytes":
		if e.complexity.Interface.RxBytes == nil {
			break
		}

		return e.complexity.Interface.RxBytes(childComplexity), true

	case "Interface.txBytes":
		if e.complexity.Interface.TxBytes == nil {
			break
		}

		return e.complexity.Interface.TxBytes(childComplexity), true

	case "Interface.type":
		if e.complexity.Interface.Type == nil {
			break
		}

		return e.complexity.Interface.Type(childComplexity), true

	case "InterfaceConnection.edges":
		if e.complexity.InterfaceConnection.Edges == nil {
			break
		}

		return e.complexity.InterfaceConnection.Edges(childComplexity), true

	case "InterfaceConnection.pageInfo":
		if e.complexity.InterfaceConnection.PageInfo == nil {
			break
		}

		return e.complexity.InterfaceConnection.PageInfo(childComplexity), true

	case "InterfaceConnection.totalCount":
		if e.complexity.InterfaceConnection.TotalCount == nil {
			break
		}

		return e.complexity.InterfaceConnection.TotalCount(childComplexity), true

	case "InterfaceEdge.cursor":
		if e.complexity.InterfaceEdge.Cursor == nil {
			break
		}

		return e.complexity.InterfaceEdge.Cursor(childComplexity), true

	case "InterfaceEdge.node":
		if e.complexity.InterfaceEdge.Node == nil {
			break
		}

		return e.complexity.InterfaceEdge.Node(childComplexity), true

	case "InterfaceTrafficEvent.interfaceId":
		if e.complexity.InterfaceTrafficEvent.InterfaceID == nil {
			break
		}

		return e.complexity.InterfaceTrafficEvent.InterfaceID(childComplexity), true

	case "InterfaceTrafficEvent.interfaceName":
		if e.complexity.InterfaceTrafficEvent.InterfaceName == nil {
			break
		}

		return e.complexity.InterfaceTrafficEvent.InterfaceName(childComplexity), true

	case "InterfaceTrafficEvent.rxRate":
		if e.complexity.InterfaceTrafficEvent.RxRate == nil {
			break
		}

		return e.complexity.InterfaceTrafficEvent.RxRate(childComplexity), true

	case "InterfaceTrafficEvent.rxTotal":
		if e.complexity.InterfaceTrafficEvent.RxTotal == nil {
			break
		}

		return e.complexity.InterfaceTrafficEvent.RxTotal(childComplexity), true

	case "InterfaceTrafficEvent.timestamp":
		if e.complexity.InterfaceTrafficEvent.Timestamp == nil {
			break
		}

		return e.complexity.InterfaceTrafficEvent.Timestamp(childComplexity), true

	case "InterfaceTrafficEvent.txRate":
		if e.complexity.InterfaceTrafficEvent.TxRate == nil {
			break
		}

		return e.complexity.InterfaceTrafficEvent.TxRate(childComplexity), true

	case "InterfaceTrafficEvent.txTotal":
		if e.complexity.InterfaceTrafficEvent.TxTotal == nil {
			break
		}

		return e.complexity.InterfaceTrafficEvent.TxTotal(childComplexity), true

	case "Mutation.addRouter":
		if e.complexity.Mutation.AddRouter == nil {
			break
		}

		args, err := ec.field_Mutation_addRouter_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.AddRouter(childComplexity, args["input"].(model.AddRouterInput)), true

	case "Mutation.autoScanGateways":
		if e.complexity.Mutation.AutoScanGateways == nil {
			break
		}

		return e.complexity.Mutation.AutoScanGateways(childComplexity), true

	case "Mutation.cancelScan":
		if e.complexity.Mutation.CancelScan == nil {
			break
		}

		args, err := ec.field_Mutation_cancelScan_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CancelScan(childComplexity, args["taskId"].(string)), true

	case "Mutation.changePassword":
		if e.complexity.Mutation.ChangePassword == nil {
			break
		}

		args, err := ec.field_Mutation_changePassword_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.ChangePassword(childComplexity, args["currentPassword"].(string), args["newPassword"].(string)), true

	case "Mutation.checkRouterHealth":
		if e.complexity.Mutation.CheckRouterHealth == nil {
			break
		}

		args, err := ec.field_Mutation_checkRouterHealth_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CheckRouterHealth(childComplexity, args["routerId"].(string)), true

	case "Mutation.connectRouter":
		if e.complexity.Mutation.ConnectRouter == nil {
			break
		}

		args, err := ec.field_Mutation_connectRouter_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.ConnectRouter(childComplexity, args["id"].(string)), true

	case "Mutation.createRouter":
		if e.complexity.Mutation.CreateRouter == nil {
			break
		}

		args, err := ec.field_Mutation_createRouter_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateRouter(childComplexity, args["input"].(model.CreateRouterInput)), true

	case "Mutation.deleteRouter":
		if e.complexity.Mutation.DeleteRouter == nil {
			break
		}

		args, err := ec.field_Mutation_deleteRouter_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteRouter(childComplexity, args["id"].(string)), true

	case "Mutation.disconnectRouter":
		if e.complexity.Mutation.DisconnectRouter == nil {
			break
		}

		args, err := ec.field_Mutation_disconnectRouter_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DisconnectRouter(childComplexity, args["id"].(string)), true

	case "Mutation.exportRouterConfig":
		if e.complexity.Mutation.ExportRouterConfig == nil {
			break
		}

		args, err := ec.field_Mutation_exportRouterConfig_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.ExportRouterConfig(childComplexity, args["input"].(model.ExportConfigInput)), true

	case "Mutation.login":
		if e.complexity.Mutation.Login == nil {
			break
		}

		args, err := ec.field_Mutation_login_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.Login(childComplexity, args["username"].(string), args["password"].(string)), true

	case "Mutation.logout":
		if e.complexity.Mutation.Logout == nil {
			break
		}

		return e.complexity.Mutation.Logout(childComplexity), true

	case "Mutation.reconnectRouter":
		if e.complexity.Mutation.ReconnectRouter == nil {
			break
		}

		args, err := ec.field_Mutation_reconnectRouter_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.ReconnectRouter(childComplexity, args["routerId"].(string)), true

	case "Mutation.refreshCapabilities":
		if e.complexity.Mutation.RefreshCapabilities == nil {
			break
		}

		args, err := ec.field_Mutation_refreshCapabilities_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.RefreshCapabilities(childComplexity, args["routerId"].(string)), true

	case "Mutation.resetCircuitBreaker":
		if e.complexity.Mutation.ResetCircuitBreaker == nil {
			break
		}

		args, err := ec.field_Mutation_resetCircuitBreaker_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.ResetCircuitBreaker(childComplexity, args["routerId"].(string)), true

	case "Mutation.revokeAllSessions":
		if e.complexity.Mutation.RevokeAllSessions == nil {
			break
		}

		args, err := ec.field_Mutation_revokeAllSessions_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.RevokeAllSessions(childComplexity, args["userId"].(string)), true

	case "Mutation.revokeSession":
		if e.complexity.Mutation.RevokeSession == nil {
			break
		}

		args, err := ec.field_Mutation_revokeSession_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.RevokeSession(childComplexity, args["sessionId"].(string)), true

	case "Mutation.runDiagnostics":
		if e.complexity.Mutation.RunDiagnostics == nil {
			break
		}

		args, err := ec.field_Mutation_runDiagnostics_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.RunDiagnostics(childComplexity, args["routerId"].(string)), true

	case "Mutation.scanNetwork":
		if e.complexity.Mutation.ScanNetwork == nil {
			break
		}

		args, err := ec.field_Mutation_scanNetwork_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.ScanNetwork(childComplexity, args["input"].(model.ScanNetworkInput)), true

	case "Mutation.setPreferredProtocol":
		if e.complexity.Mutation.SetPreferredProtocol == nil {
			break
		}

		args, err := ec.field_Mutation_setPreferredProtocol_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.SetPreferredProtocol(childComplexity, args["routerId"].(string), args["protocol"].(model.Protocol)), true

	case "Mutation.testAllCredentials":
		if e.complexity.Mutation.TestAllCredentials == nil {
			break
		}

		return e.complexity.Mutation.TestAllCredentials(childComplexity), true

	case "Mutation.testRouterConnection":
		if e.complexity.Mutation.TestRouterConnection == nil {
			break
		}

		args, err := ec.field_Mutation_testRouterConnection_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.TestRouterConnection(childComplexity, args["id"].(string)), true

	case "Mutation.testRouterCredentials":
		if e.complexity.Mutation.TestRouterCredentials == nil {
			break
		}

		args, err := ec.field_Mutation_testRouterCredentials_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.TestRouterCredentials(childComplexity, args["input"].(model.AddRouterInput)), true

	case "Mutation.updateRouter":
		if e.complexity.Mutation.UpdateRouter == nil {
			break
		}

		args, err := ec.field_Mutation_updateRouter_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateRouter(childComplexity, args["id"].(string), args["input"].(model.UpdateRouterInput)), true

	case "Mutation.updateRouterCredentials":
		if e.complexity.Mutation.UpdateRouterCredentials == nil {
			break
		}

		args, err := ec.field_Mutation_updateRouterCredentials_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateRouterCredentials(childComplexity, args["routerId"].(string), args["input"].(model.CredentialsInput)), true

	case "MutationError.code":
		if e.complexity.MutationError.Code == nil {
			break
		}

		return e.complexity.MutationError.Code(childComplexity), true

	case "MutationError.field":
		if e.complexity.MutationError.Field == nil {
			break
		}

		return e.complexity.MutationError.Field(childComplexity), true

	case "MutationError.message":
		if e.complexity.MutationError.Message == nil {
			break
		}

		return e.complexity.MutationError.Message(childComplexity), true

	case "PageInfo.endCursor":
		if e.complexity.PageInfo.EndCursor == nil {
			break
		}

		return e.complexity.PageInfo.EndCursor(childComplexity), true

	case "PageInfo.hasNextPage":
		if e.complexity.PageInfo.HasNextPage == nil {
			break
		}

		return e.complexity.PageInfo.HasNextPage(childComplexity), true

	case "PageInfo.hasPreviousPage":
		if e.complexity.PageInfo.HasPreviousPage == nil {
			break
		}

		return e.complexity.PageInfo.HasPreviousPage(childComplexity), true

	case "PageInfo.startCursor":
		if e.complexity.PageInfo.StartCursor == nil {
			break
		}

		return e.complexity.PageInfo.StartCursor(childComplexity), true

	case "PortStatus.error":
		if e.complexity.PortStatus.Error == nil {
			break
		}

		return e.complexity.PortStatus.Error(childComplexity), true

	case "PortStatus.open":
		if e.complexity.PortStatus.Open == nil {
			break
		}

		return e.complexity.PortStatus.Open(childComplexity), true

	case "PortStatus.port":
		if e.complexity.PortStatus.Port == nil {
			break
		}

		return e.complexity.PortStatus.Port(childComplexity), true

	case "PortStatus.responseTimeMs":
		if e.complexity.PortStatus.ResponseTimeMs == nil {
			break
		}

		return e.complexity.PortStatus.ResponseTimeMs(childComplexity), true

	case "PortStatus.service":
		if e.complexity.PortStatus.Service == nil {
			break
		}

		return e.complexity.PortStatus.Service(childComplexity), true

	case "Query.circuitBreakerStatus":
		if e.complexity.Query.CircuitBreakerStatus == nil {
			break
		}

		args, err := ec.field_Query_circuitBreakerStatus_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.CircuitBreakerStatus(childComplexity, args["routerId"].(string)), true

	case "Query.compatibilityMatrix":
		if e.complexity.Query.CompatibilityMatrix == nil {
			break
		}

		return e.complexity.Query.CompatibilityMatrix(childComplexity), true

	case "Query.connectionAttempts":
		if e.complexity.Query.ConnectionAttempts == nil {
			break
		}

		args, err := ec.field_Query_connectionAttempts_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.ConnectionAttempts(childComplexity, args["routerId"].(string), args["limit"].(*int)), true

	case "Query.connectionDetails":
		if e.complexity.Query.ConnectionDetails == nil {
			break
		}

		args, err := ec.field_Query_connectionDetails_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.ConnectionDetails(childComplexity, args["routerId"].(string)), true

	case "Query.connectionStats":
		if e.complexity.Query.ConnectionStats == nil {
			break
		}

		return e.complexity.Query.ConnectionStats(childComplexity), true

	case "Query.health":
		if e.complexity.Query.Health == nil {
			break
		}

		return e.complexity.Query.Health(childComplexity), true

	case "Query.interface":
		if e.complexity.Query.Interface == nil {
			break
		}

		args, err := ec.field_Query_interface_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Interface(childComplexity, args["routerId"].(string), args["id"].(string)), true

	case "Query.interfaces":
		if e.complexity.Query.Interfaces == nil {
			break
		}

		args, err := ec.field_Query_interfaces_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Interfaces(childComplexity, args["routerId"].(string), args["type"].(*model.InterfaceType), args["pagination"].(*model.PaginationInput)), true

	case "Query.isFeatureSupported":
		if e.complexity.Query.IsFeatureSupported == nil {
			break
		}

		args, err := ec.field_Query_isFeatureSupported_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.IsFeatureSupported(childComplexity, args["routerId"].(string), args["featureId"].(string)), true

	case "Query.me":
		if e.complexity.Query.Me == nil {
			break
		}

		return e.complexity.Query.Me(childComplexity), true

	case "Query.mySessions":
		if e.complexity.Query.MySessions == nil {
			break
		}

		return e.complexity.Query.MySessions(childComplexity), true

	case "Query.node":
		if e.complexity.Query.Node == nil {
			break
		}

		args, err := ec.field_Query_node_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Node(childComplexity, args["id"].(string)), true

	case "Query.router":
		if e.complexity.Query.Router == nil {
			break
		}

		args, err := ec.field_Query_router_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Router(childComplexity, args["id"].(string)), true

	case "Query.routerCapabilities":
		if e.complexity.Query.RouterCapabilities == nil {
			break
		}

		args, err := ec.field_Query_routerCapabilities_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.RouterCapabilities(childComplexity, args["routerId"].(string)), true

	case "Query.routerCredentials":
		if e.complexity.Query.RouterCredentials == nil {
			break
		}

		args, err := ec.field_Query_routerCredentials_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.RouterCredentials(childComplexity, args["routerId"].(string)), true

	case "Query.routerHealth":
		if e.complexity.Query.RouterHealth == nil {
			break
		}

		args, err := ec.field_Query_routerHealth_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.RouterHealth(childComplexity, args["routerId"].(string)), true

	case "Query.routers":
		if e.complexity.Query.Routers == nil {
			break
		}

		args, err := ec.field_Query_routers_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Routers(childComplexity, args["status"].(*model.ConnectionStatus), args["pagination"].(*model.PaginationInput)), true

	case "Query.scanHistory":
		if e.complexity.Query.ScanHistory == nil {
			break
		}

		args, err := ec.field_Query_scanHistory_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.ScanHistory(childComplexity, args["limit"].(*int)), true

	case "Query.scanStatus":
		if e.complexity.Query.ScanStatus == nil {
			break
		}

		args, err := ec.field_Query_scanStatus_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.ScanStatus(childComplexity, args["taskId"].(string)), true

	case "Query.supportedFeatures":
		if e.complexity.Query.SupportedFeatures == nil {
			break
		}

		args, err := ec.field_Query_supportedFeatures_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.SupportedFeatures(childComplexity, args["routerId"].(string)), true

	case "Query.unsupportedFeatures":
		if e.complexity.Query.UnsupportedFeatures == nil {
			break
		}

		args, err := ec.field_Query_unsupportedFeatures_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.UnsupportedFeatures(childComplexity, args["routerId"].(string)), true

	case "Query.upgradeRecommendation":
		if e.complexity.Query.UpgradeRecommendation == nil {
			break
		}

		args, err := ec.field_Query_upgradeRecommendation_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.UpgradeRecommendation(childComplexity, args["routerId"].(string), args["featureId"].(string)), true

	case "Query.upgradeRecommendations":
		if e.complexity.Query.UpgradeRecommendations == nil {
			break
		}

		args, err := ec.field_Query_upgradeRecommendations_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.UpgradeRecommendations(childComplexity, args["routerId"].(string)), true

	case "Query.version":
		if e.complexity.Query.Version == nil {
			break
		}

		return e.complexity.Query.Version(childComplexity), true

	case "ReconnectRouterPayload.connectionDetails":
		if e.complexity.ReconnectRouterPayload.ConnectionDetails == nil {
			break
		}

		return e.complexity.ReconnectRouterPayload.ConnectionDetails(childComplexity), true

	case "ReconnectRouterPayload.errors":
		if e.complexity.ReconnectRouterPayload.Errors == nil {
			break
		}

		return e.complexity.ReconnectRouterPayload.Errors(childComplexity), true

	case "ReconnectRouterPayload.initiated":
		if e.complexity.ReconnectRouterPayload.Initiated == nil {
			break
		}

		return e.complexity.ReconnectRouterPayload.Initiated(childComplexity), true

	case "ReconnectRouterPayload.router":
		if e.complexity.ReconnectRouterPayload.Router == nil {
			break
		}

		return e.complexity.ReconnectRouterPayload.Router(childComplexity), true

	case "ReconnectRouterPayload.waitTimeMs":
		if e.complexity.ReconnectRouterPayload.WaitTimeMs == nil {
			break
		}

		return e.complexity.ReconnectRouterPayload.WaitTimeMs(childComplexity), true

	case "RefreshCapabilitiesPayload.capabilities":
		if e.complexity.RefreshCapabilitiesPayload.Capabilities == nil {
			break
		}

		return e.complexity.RefreshCapabilitiesPayload.Capabilities(childComplexity), true

	case "RefreshCapabilitiesPayload.errors":
		if e.complexity.RefreshCapabilitiesPayload.Errors == nil {
			break
		}

		return e.complexity.RefreshCapabilitiesPayload.Errors(childComplexity), true

	case "ResourceUpdatedEvent.changeType":
		if e.complexity.ResourceUpdatedEvent.ChangeType == nil {
			break
		}

		return e.complexity.ResourceUpdatedEvent.ChangeType(childComplexity), true

	case "ResourceUpdatedEvent.changedFields":
		if e.complexity.ResourceUpdatedEvent.ChangedFields == nil {
			break
		}

		return e.complexity.ResourceUpdatedEvent.ChangedFields(childComplexity), true

	case "ResourceUpdatedEvent.resourceId":
		if e.complexity.ResourceUpdatedEvent.ResourceID == nil {
			break
		}

		return e.complexity.ResourceUpdatedEvent.ResourceID(childComplexity), true

	case "ResourceUpdatedEvent.resourceType":
		if e.complexity.ResourceUpdatedEvent.ResourceType == nil {
			break
		}

		return e.complexity.ResourceUpdatedEvent.ResourceType(childComplexity), true

	case "ResourceUpdatedEvent.routerId":
		if e.complexity.ResourceUpdatedEvent.RouterID == nil {
			break
		}

		return e.complexity.ResourceUpdatedEvent.RouterID(childComplexity), true

	case "ResourceUpdatedEvent.timestamp":
		if e.complexity.ResourceUpdatedEvent.Timestamp == nil {
			break
		}

		return e.complexity.ResourceUpdatedEvent.Timestamp(childComplexity), true

	case "ResourceUpdatedEvent.version":
		if e.complexity.ResourceUpdatedEvent.Version == nil {
			break
		}

		return e.complexity.ResourceUpdatedEvent.Version(childComplexity), true

	case "Router.capabilities":
		if e.complexity.Router.Capabilities == nil {
			break
		}

		return e.complexity.Router.Capabilities(childComplexity), true

	case "Router.createdAt":
		if e.complexity.Router.CreatedAt == nil {
			break
		}

		return e.complexity.Router.CreatedAt(childComplexity), true

	case "Router.host":
		if e.complexity.Router.Host == nil {
			break
		}

		return e.complexity.Router.Host(childComplexity), true

	case "Router.id":
		if e.complexity.Router.ID == nil {
			break
		}

		return e.complexity.Router.ID(childComplexity), true

	case "Router.lastConnected":
		if e.complexity.Router.LastConnected == nil {
			break
		}

		return e.complexity.Router.LastConnected(childComplexity), true

	case "Router.model":
		if e.complexity.Router.Model == nil {
			break
		}

		return e.complexity.Router.Model(childComplexity), true

	case "Router.name":
		if e.complexity.Router.Name == nil {
			break
		}

		return e.complexity.Router.Name(childComplexity), true

	case "Router.platform":
		if e.complexity.Router.Platform == nil {
			break
		}

		return e.complexity.Router.Platform(childComplexity), true

	case "Router.port":
		if e.complexity.Router.Port == nil {
			break
		}

		return e.complexity.Router.Port(childComplexity), true

	case "Router.status":
		if e.complexity.Router.Status == nil {
			break
		}

		return e.complexity.Router.Status(childComplexity), true

	case "Router.updatedAt":
		if e.complexity.Router.UpdatedAt == nil {
			break
		}

		return e.complexity.Router.UpdatedAt(childComplexity), true

	case "Router.uptime":
		if e.complexity.Router.Uptime == nil {
			break
		}

		return e.complexity.Router.Uptime(childComplexity), true

	case "Router.version":
		if e.complexity.Router.Version == nil {
			break
		}

		return e.complexity.Router.Version(childComplexity), true

	case "RouterAddedEvent.addedBy":
		if e.complexity.RouterAddedEvent.AddedBy == nil {
			break
		}

		return e.complexity.RouterAddedEvent.AddedBy(childComplexity), true

	case "RouterAddedEvent.protocolUsed":
		if e.complexity.RouterAddedEvent.ProtocolUsed == nil {
			break
		}

		return e.complexity.RouterAddedEvent.ProtocolUsed(childComplexity), true

	case "RouterAddedEvent.router":
		if e.complexity.RouterAddedEvent.Router == nil {
			break
		}

		return e.complexity.RouterAddedEvent.Router(childComplexity), true

	case "RouterAddedEvent.timestamp":
		if e.complexity.RouterAddedEvent.Timestamp == nil {
			break
		}

		return e.complexity.RouterAddedEvent.Timestamp(childComplexity), true

	case "RouterCapabilities.capabilities":
		if e.complexity.RouterCapabilities.Capabilities == nil {
			break
		}

		return e.complexity.RouterCapabilities.Capabilities(childComplexity), true

	case "RouterCapabilities.container":
		if e.complexity.RouterCapabilities.Container == nil {
			break
		}

		return e.complexity.RouterCapabilities.Container(childComplexity), true

	case "RouterCapabilities.detectedAt":
		if e.complexity.RouterCapabilities.DetectedAt == nil {
			break
		}

		return e.complexity.RouterCapabilities.DetectedAt(childComplexity), true

	case "RouterCapabilities.expiresAt":
		if e.complexity.RouterCapabilities.ExpiresAt == nil {
			break
		}

		return e.complexity.RouterCapabilities.ExpiresAt(childComplexity), true

	case "RouterCapabilities.hardware":
		if e.complexity.RouterCapabilities.Hardware == nil {
			break
		}

		return e.complexity.RouterCapabilities.Hardware(childComplexity), true

	case "RouterCapabilities.isRefreshing":
		if e.complexity.RouterCapabilities.IsRefreshing == nil {
			break
		}

		return e.complexity.RouterCapabilities.IsRefreshing(childComplexity), true

	case "RouterCapabilities.routerOSVersion":
		if e.complexity.RouterCapabilities.RouterOSVersion == nil {
			break
		}

		return e.complexity.RouterCapabilities.RouterOSVersion(childComplexity), true

	case "RouterCapabilities.software":
		if e.complexity.RouterCapabilities.Software == nil {
			break
		}

		return e.complexity.RouterCapabilities.Software(childComplexity), true

	case "RouterCapabilities.supportedFeatures":
		if e.complexity.RouterCapabilities.SupportedFeatures == nil {
			break
		}

		return e.complexity.RouterCapabilities.SupportedFeatures(childComplexity), true

	case "RouterCapabilities.unsupportedFeatures":
		if e.complexity.RouterCapabilities.UnsupportedFeatures == nil {
			break
		}

		return e.complexity.RouterCapabilities.UnsupportedFeatures(childComplexity), true

	case "RouterCapabilities.vifRequirements":
		if e.complexity.RouterCapabilities.VifRequirements == nil {
			break
		}

		return e.complexity.RouterCapabilities.VifRequirements(childComplexity), true

	case "RouterConnection.edges":
		if e.complexity.RouterConnection.Edges == nil {
			break
		}

		return e.complexity.RouterConnection.Edges(childComplexity), true

	case "RouterConnection.pageInfo":
		if e.complexity.RouterConnection.PageInfo == nil {
			break
		}

		return e.complexity.RouterConnection.PageInfo(childComplexity), true

	case "RouterConnection.totalCount":
		if e.complexity.RouterConnection.TotalCount == nil {
			break
		}

		return e.complexity.RouterConnection.TotalCount(childComplexity), true

	case "RouterCredentials.createdAt":
		if e.complexity.RouterCredentials.CreatedAt == nil {
			break
		}

		return e.complexity.RouterCredentials.CreatedAt(childComplexity), true

	case "RouterCredentials.encryptionStatus":
		if e.complexity.RouterCredentials.EncryptionStatus == nil {
			break
		}

		return e.complexity.RouterCredentials.EncryptionStatus(childComplexity), true

	case "RouterCredentials.hasPassword":
		if e.complexity.RouterCredentials.HasPassword == nil {
			break
		}

		return e.complexity.RouterCredentials.HasPassword(childComplexity), true

	case "RouterCredentials.keyVersion":
		if e.complexity.RouterCredentials.KeyVersion == nil {
			break
		}

		return e.complexity.RouterCredentials.KeyVersion(childComplexity), true

	case "RouterCredentials.lastUpdated":
		if e.complexity.RouterCredentials.LastUpdated == nil {
			break
		}

		return e.complexity.RouterCredentials.LastUpdated(childComplexity), true

	case "RouterCredentials.routerId":
		if e.complexity.RouterCredentials.RouterID == nil {
			break
		}

		return e.complexity.RouterCredentials.RouterID(childComplexity), true

	case "RouterCredentials.username":
		if e.complexity.RouterCredentials.Username == nil {
			break
		}

		return e.complexity.RouterCredentials.Username(childComplexity), true

	case "RouterEdge.cursor":
		if e.complexity.RouterEdge.Cursor == nil {
			break
		}

		return e.complexity.RouterEdge.Cursor(childComplexity), true

	case "RouterEdge.node":
		if e.complexity.RouterEdge.Node == nil {
			break
		}

		return e.complexity.RouterEdge.Node(childComplexity), true

	case "RouterOSInfo.architecture":
		if e.complexity.RouterOSInfo.Architecture == nil {
			break
		}

		return e.complexity.RouterOSInfo.Architecture(childComplexity), true

	case "RouterOSInfo.boardName":
		if e.complexity.RouterOSInfo.BoardName == nil {
			break
		}

		return e.complexity.RouterOSInfo.BoardName(childComplexity), true

	case "RouterOSInfo.platform":
		if e.complexity.RouterOSInfo.Platform == nil {
			break
		}

		return e.complexity.RouterOSInfo.Platform(childComplexity), true

	case "RouterOSInfo.version":
		if e.complexity.RouterOSInfo.Version == nil {
			break
		}

		return e.complexity.RouterOSInfo.Version(childComplexity), true

	case "RouterOSVersion.channel":
		if e.complexity.RouterOSVersion.Channel == nil {
			break
		}

		return e.complexity.RouterOSVersion.Channel(childComplexity), true

	case "RouterOSVersion.isAtLeast":
		if e.complexity.RouterOSVersion.IsAtLeast == nil {
			break
		}

		args, err := ec.field_RouterOSVersion_isAtLeast_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.RouterOSVersion.IsAtLeast(childComplexity, args["version"].(string)), true

	case "RouterOSVersion.isCHR":
		if e.complexity.RouterOSVersion.IsChr == nil {
			break
		}

		return e.complexity.RouterOSVersion.IsChr(childComplexity), true

	case "RouterOSVersion.major":
		if e.complexity.RouterOSVersion.Major == nil {
			break
		}

		return e.complexity.RouterOSVersion.Major(childComplexity), true

	case "RouterOSVersion.minor":
		if e.complexity.RouterOSVersion.Minor == nil {
			break
		}

		return e.complexity.RouterOSVersion.Minor(childComplexity), true

	case "RouterOSVersion.patch":
		if e.complexity.RouterOSVersion.Patch == nil {
			break
		}

		return e.complexity.RouterOSVersion.Patch(childComplexity), true

	case "RouterOSVersion.raw":
		if e.complexity.RouterOSVersion.Raw == nil {
			break
		}

		return e.complexity.RouterOSVersion.Raw(childComplexity), true

	case "RouterOSVersion.supportsFeature":
		if e.complexity.RouterOSVersion.SupportsFeature == nil {
			break
		}

		args, err := ec.field_RouterOSVersion_supportsFeature_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.RouterOSVersion.SupportsFeature(childComplexity, args["featureId"].(string)), true

	case "RouterStatusEvent.newStatus":
		if e.complexity.RouterStatusEvent.NewStatus == nil {
			break
		}

		return e.complexity.RouterStatusEvent.NewStatus(childComplexity), true

	case "RouterStatusEvent.previousStatus":
		if e.complexity.RouterStatusEvent.PreviousStatus == nil {
			break
		}

		return e.complexity.RouterStatusEvent.PreviousStatus(childComplexity), true

	case "RouterStatusEvent.router":
		if e.complexity.RouterStatusEvent.Router == nil {
			break
		}

		return e.complexity.RouterStatusEvent.Router(childComplexity), true

	case "RouterStatusEvent.timestamp":
		if e.complexity.RouterStatusEvent.Timestamp == nil {
			break
		}

		return e.complexity.RouterStatusEvent.Timestamp(childComplexity), true

	case "ScanNetworkPayload.errors":
		if e.complexity.ScanNetworkPayload.Errors == nil {
			break
		}

		return e.complexity.ScanNetworkPayload.Errors(childComplexity), true

	case "ScanNetworkPayload.task":
		if e.complexity.ScanNetworkPayload.Task == nil {
			break
		}

		return e.complexity.ScanNetworkPayload.Task(childComplexity), true

	case "ScanProgressEvent.currentIP":
		if e.complexity.ScanProgressEvent.CurrentIP == nil {
			break
		}

		return e.complexity.ScanProgressEvent.CurrentIP(childComplexity), true

	case "ScanProgressEvent.devicesFound":
		if e.complexity.ScanProgressEvent.DevicesFound == nil {
			break
		}

		return e.complexity.ScanProgressEvent.DevicesFound(childComplexity), true

	case "ScanProgressEvent.progress":
		if e.complexity.ScanProgressEvent.Progress == nil {
			break
		}

		return e.complexity.ScanProgressEvent.Progress(childComplexity), true

	case "ScanProgressEvent.status":
		if e.complexity.ScanProgressEvent.Status == nil {
			break
		}

		return e.complexity.ScanProgressEvent.Status(childComplexity), true

	case "ScanProgressEvent.taskId":
		if e.complexity.ScanProgressEvent.TaskID == nil {
			break
		}

		return e.complexity.ScanProgressEvent.TaskID(childComplexity), true

	case "ScanProgressEvent.timestamp":
		if e.complexity.ScanProgressEvent.Timestamp == nil {
			break
		}

		return e.complexity.ScanProgressEvent.Timestamp(childComplexity), true

	case "ScanTask.endTime":
		if e.complexity.ScanTask.EndTime == nil {
			break
		}

		return e.complexity.ScanTask.EndTime(childComplexity), true

	case "ScanTask.error":
		if e.complexity.ScanTask.Error == nil {
			break
		}

		return e.complexity.ScanTask.Error(childComplexity), true

	case "ScanTask.id":
		if e.complexity.ScanTask.ID == nil {
			break
		}

		return e.complexity.ScanTask.ID(childComplexity), true

	case "ScanTask.progress":
		if e.complexity.ScanTask.Progress == nil {
			break
		}

		return e.complexity.ScanTask.Progress(childComplexity), true

	case "ScanTask.results":
		if e.complexity.ScanTask.Results == nil {
			break
		}

		return e.complexity.ScanTask.Results(childComplexity), true

	case "ScanTask.scannedIPs":
		if e.complexity.ScanTask.ScannedIPs == nil {
			break
		}

		return e.complexity.ScanTask.ScannedIPs(childComplexity), true

	case "ScanTask.startTime":
		if e.complexity.ScanTask.StartTime == nil {
			break
		}

		return e.complexity.ScanTask.StartTime(childComplexity), true

	case "ScanTask.status":
		if e.complexity.ScanTask.Status == nil {
			break
		}

		return e.complexity.ScanTask.Status(childComplexity), true

	case "ScanTask.subnet":
		if e.complexity.ScanTask.Subnet == nil {
			break
		}

		return e.complexity.ScanTask.Subnet(childComplexity), true

	case "ScanTask.totalIPs":
		if e.complexity.ScanTask.TotalIPs == nil {
			break
		}

		return e.complexity.ScanTask.TotalIPs(childComplexity), true

	case "Session.createdAt":
		if e.complexity.Session.CreatedAt == nil {
			break
		}

		return e.complexity.Session.CreatedAt(childComplexity), true

	case "Session.id":
		if e.complexity.Session.ID == nil {
			break
		}

		return e.complexity.Session.ID(childComplexity), true

	case "Session.ipAddress":
		if e.complexity.Session.IPAddress == nil {
			break
		}

		return e.complexity.Session.IPAddress(childComplexity), true

	case "Session.isCurrent":
		if e.complexity.Session.IsCurrent == nil {
			break
		}

		return e.complexity.Session.IsCurrent(childComplexity), true

	case "Session.lastActivity":
		if e.complexity.Session.LastActivity == nil {
			break
		}

		return e.complexity.Session.LastActivity(childComplexity), true

	case "Session.userAgent":
		if e.complexity.Session.UserAgent == nil {
			break
		}

		return e.complexity.Session.UserAgent(childComplexity), true

	case "SetPreferredProtocolPayload.connectionDetails":
		if e.complexity.SetPreferredProtocolPayload.ConnectionDetails == nil {
			break
		}

		return e.complexity.SetPreferredProtocolPayload.ConnectionDetails(childComplexity), true

	case "SetPreferredProtocolPayload.errors":
		if e.complexity.SetPreferredProtocolPayload.Errors == nil {
			break
		}

		return e.complexity.SetPreferredProtocolPayload.Errors(childComplexity), true

	case "SetPreferredProtocolPayload.router":
		if e.complexity.SetPreferredProtocolPayload.Router == nil {
			break
		}

		return e.complexity.SetPreferredProtocolPayload.Router(childComplexity), true

	case "SoftwareInfo.installedPackages":
		if e.complexity.SoftwareInfo.InstalledPackages == nil {
			break
		}

		return e.complexity.SoftwareInfo.InstalledPackages(childComplexity), true

	case "SoftwareInfo.licenseLevel":
		if e.complexity.SoftwareInfo.LicenseLevel == nil {
			break
		}

		return e.complexity.SoftwareInfo.LicenseLevel(childComplexity), true

	case "SoftwareInfo.updateChannel":
		if e.complexity.SoftwareInfo.UpdateChannel == nil {
			break
		}

		return e.complexity.SoftwareInfo.UpdateChannel(childComplexity), true

	case "SoftwareInfo.version":
		if e.complexity.SoftwareInfo.Version == nil {
			break
		}

		return e.complexity.SoftwareInfo.Version(childComplexity), true

	case "SoftwareInfo.versionMajor":
		if e.complexity.SoftwareInfo.VersionMajor == nil {
			break
		}

		return e.complexity.SoftwareInfo.VersionMajor(childComplexity), true

	case "SoftwareInfo.versionMinor":
		if e.complexity.SoftwareInfo.VersionMinor == nil {
			break
		}

		return e.complexity.SoftwareInfo.VersionMinor(childComplexity), true

	case "SoftwareInfo.versionPatch":
		if e.complexity.SoftwareInfo.VersionPatch == nil {
			break
		}

		return e.complexity.SoftwareInfo.VersionPatch(childComplexity), true

	case "Subscription.circuitBreakerChanged":
		if e.complexity.Subscription.CircuitBreakerChanged == nil {
			break
		}

		args, err := ec.field_Subscription_circuitBreakerChanged_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Subscription.CircuitBreakerChanged(childComplexity, args["routerId"].(string)), true

	case "Subscription.circuitBreakerStateChanged":
		if e.complexity.Subscription.CircuitBreakerStateChanged == nil {
			break
		}

		args, err := ec.field_Subscription_circuitBreakerStateChanged_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Subscription.CircuitBreakerStateChanged(childComplexity, args["routerId"].(*string)), true

	case "Subscription.configApplyProgress":
		if e.complexity.Subscription.ConfigApplyProgress == nil {
			break
		}

		args, err := ec.field_Subscription_configApplyProgress_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Subscription.ConfigApplyProgress(childComplexity, args["operationId"].(string)), true

	case "Subscription.connectionHealth":
		if e.complexity.Subscription.ConnectionHealth == nil {
			break
		}

		args, err := ec.field_Subscription_connectionHealth_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Subscription.ConnectionHealth(childComplexity, args["routerId"].(*string)), true

	case "Subscription.interfaceTraffic":
		if e.complexity.Subscription.InterfaceTraffic == nil {
			break
		}

		args, err := ec.field_Subscription_interfaceTraffic_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Subscription.InterfaceTraffic(childComplexity, args["routerId"].(string), args["interfaceId"].(*string)), true

	case "Subscription.resourceUpdated":
		if e.complexity.Subscription.ResourceUpdated == nil {
			break
		}

		args, err := ec.field_Subscription_resourceUpdated_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Subscription.ResourceUpdated(childComplexity, args["resourceId"].(*string)), true

	case "Subscription.routerAdded":
		if e.complexity.Subscription.RouterAdded == nil {
			break
		}

		return e.complexity.Subscription.RouterAdded(childComplexity), true

	case "Subscription.routerStatusChanged":
		if e.complexity.Subscription.RouterStatusChanged == nil {
			break
		}

		args, err := ec.field_Subscription_routerStatusChanged_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Subscription.RouterStatusChanged(childComplexity, args["routerId"].(*string)), true

	case "Subscription.scanProgress":
		if e.complexity.Subscription.ScanProgress == nil {
			break
		}

		args, err := ec.field_Subscription_scanProgress_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Subscription.ScanProgress(childComplexity, args["taskId"].(string)), true

	case "TLSStatus.error":
		if e.complexity.TLSStatus.Error == nil {
			break
		}

		return e.complexity.TLSStatus.Error(childComplexity), true

	case "TLSStatus.expiresAt":
		if e.complexity.TLSStatus.ExpiresAt == nil {
			break
		}

		return e.complexity.TLSStatus.ExpiresAt(childComplexity), true

	case "TLSStatus.issuer":
		if e.complexity.TLSStatus.Issuer == nil {
			break
		}

		return e.complexity.TLSStatus.Issuer(childComplexity), true

	case "TLSStatus.subject":
		if e.complexity.TLSStatus.Subject == nil {
			break
		}

		return e.complexity.TLSStatus.Subject(childComplexity), true

	case "TLSStatus.valid":
		if e.complexity.TLSStatus.Valid == nil {
			break
		}

		return e.complexity.TLSStatus.Valid(childComplexity), true

	case "TestAllCredentialsPayload.failureCount":
		if e.complexity.TestAllCredentialsPayload.FailureCount == nil {
			break
		}

		return e.complexity.TestAllCredentialsPayload.FailureCount(childComplexity), true

	case "TestAllCredentialsPayload.results":
		if e.complexity.TestAllCredentialsPayload.Results == nil {
			break
		}

		return e.complexity.TestAllCredentialsPayload.Results(childComplexity), true

	case "TestAllCredentialsPayload.successCount":
		if e.complexity.TestAllCredentialsPayload.SuccessCount == nil {
			break
		}

		return e.complexity.TestAllCredentialsPayload.SuccessCount(childComplexity), true

	case "TestAllCredentialsPayload.totalRouters":
		if e.complexity.TestAllCredentialsPayload.TotalRouters == nil {
			break
		}

		return e.complexity.TestAllCredentialsPayload.TotalRouters(childComplexity), true

	case "TestConnectionPayload.error":
		if e.complexity.TestConnectionPayload.Error == nil {
			break
		}

		return e.complexity.TestConnectionPayload.Error(childComplexity), true

	case "TestConnectionPayload.responseTimeMs":
		if e.complexity.TestConnectionPayload.ResponseTimeMs == nil {
			break
		}

		return e.complexity.TestConnectionPayload.ResponseTimeMs(childComplexity), true

	case "TestConnectionPayload.success":
		if e.complexity.TestConnectionPayload.Success == nil {
			break
		}

		return e.complexity.TestConnectionPayload.Success(childComplexity), true

	case "TestConnectionPayload.version":
		if e.complexity.TestConnectionPayload.Version == nil {
			break
		}

		return e.complexity.TestConnectionPayload.Version(childComplexity), true

	case "UpdateRouterPayload.errors":
		if e.complexity.UpdateRouterPayload.Errors == nil {
			break
		}

		return e.complexity.UpdateRouterPayload.Errors(childComplexity), true

	case "UpdateRouterPayload.router":
		if e.complexity.UpdateRouterPayload.Router == nil {
			break
		}

		return e.complexity.UpdateRouterPayload.Router(childComplexity), true

	case "UpgradeImpact.backupRecommended":
		if e.complexity.UpgradeImpact.BackupRecommended == nil {
			break
		}

		return e.complexity.UpgradeImpact.BackupRecommended(childComplexity), true

	case "UpgradeImpact.breakingChanges":
		if e.complexity.UpgradeImpact.BreakingChanges == nil {
			break
		}

		return e.complexity.UpgradeImpact.BreakingChanges(childComplexity), true

	case "UpgradeImpact.estimatedDowntime":
		if e.complexity.UpgradeImpact.EstimatedDowntime == nil {
			break
		}

		return e.complexity.UpgradeImpact.EstimatedDowntime(childComplexity), true

	case "UpgradeImpact.requiresReboot":
		if e.complexity.UpgradeImpact.RequiresReboot == nil {
			break
		}

		return e.complexity.UpgradeImpact.RequiresReboot(childComplexity), true

	case "UpgradeRecommendation.currentVersion":
		if e.complexity.UpgradeRecommendation.CurrentVersion == nil {
			break
		}

		return e.complexity.UpgradeRecommendation.CurrentVersion(childComplexity), true

	case "UpgradeRecommendation.documentationUrl":
		if e.complexity.UpgradeRecommendation.DocumentationURL == nil {
			break
		}

		return e.complexity.UpgradeRecommendation.DocumentationURL(childComplexity), true

	case "UpgradeRecommendation.featureId":
		if e.complexity.UpgradeRecommendation.FeatureID == nil {
			break
		}

		return e.complexity.UpgradeRecommendation.FeatureID(childComplexity), true

	case "UpgradeRecommendation.featureName":
		if e.complexity.UpgradeRecommendation.FeatureName == nil {
			break
		}

		return e.complexity.UpgradeRecommendation.FeatureName(childComplexity), true

	case "UpgradeRecommendation.impact":
		if e.complexity.UpgradeRecommendation.Impact == nil {
			break
		}

		return e.complexity.UpgradeRecommendation.Impact(childComplexity), true

	case "UpgradeRecommendation.isMajorUpgrade":
		if e.complexity.UpgradeRecommendation.IsMajorUpgrade == nil {
			break
		}

		return e.complexity.UpgradeRecommendation.IsMajorUpgrade(childComplexity), true

	case "UpgradeRecommendation.priority":
		if e.complexity.UpgradeRecommendation.Priority == nil {
			break
		}

		return e.complexity.UpgradeRecommendation.Priority(childComplexity), true

	case "UpgradeRecommendation.requiredVersion":
		if e.complexity.UpgradeRecommendation.RequiredVersion == nil {
			break
		}

		return e.complexity.UpgradeRecommendation.RequiredVersion(childComplexity), true

	case "UpgradeRecommendation.steps":
		if e.complexity.UpgradeRecommendation.Steps == nil {
			break
		}

		return e.complexity.UpgradeRecommendation.Steps(childComplexity), true

	case "UpgradeRecommendation.warnings":
		if e.complexity.UpgradeRecommendation.Warnings == nil {
			break
		}

		return e.complexity.UpgradeRecommendation.Warnings(childComplexity), true

	case "UpgradeStep.command":
		if e.complexity.UpgradeStep.Command == nil {
			break
		}

		return e.complexity.UpgradeStep.Command(childComplexity), true

	case "UpgradeStep.description":
		if e.complexity.UpgradeStep.Description == nil {
			break
		}

		return e.complexity.UpgradeStep.Description(childComplexity), true

	case "UpgradeStep.optional":
		if e.complexity.UpgradeStep.Optional == nil {
			break
		}

		return e.complexity.UpgradeStep.Optional(childComplexity), true

	case "UpgradeStep.step":
		if e.complexity.UpgradeStep.Step == nil {
			break
		}

		return e.complexity.UpgradeStep.Step(childComplexity), true

	case "UpgradeStep.title":
		if e.complexity.UpgradeStep.Title == nil {
			break
		}

		return e.complexity.UpgradeStep.Title(childComplexity), true

	case "User.createdAt":
		if e.complexity.User.CreatedAt == nil {
			break
		}

		return e.complexity.User.CreatedAt(childComplexity), true

	case "User.displayName":
		if e.complexity.User.DisplayName == nil {
			break
		}

		return e.complexity.User.DisplayName(childComplexity), true

	case "User.email":
		if e.complexity.User.Email == nil {
			break
		}

		return e.complexity.User.Email(childComplexity), true

	case "User.id":
		if e.complexity.User.ID == nil {
			break
		}

		return e.complexity.User.ID(childComplexity), true

	case "User.lastLoginAt":
		if e.complexity.User.LastLoginAt == nil {
			break
		}

		return e.complexity.User.LastLoginAt(childComplexity), true

	case "User.role":
		if e.complexity.User.Role == nil {
			break
		}

		return e.complexity.User.Role(childComplexity), true

	case "User.username":
		if e.complexity.User.Username == nil {
			break
		}

		return e.complexity.User.Username(childComplexity), true

	case "VIFGuidanceStep.completed":
		if e.complexity.VIFGuidanceStep.Completed == nil {
			break
		}

		return e.complexity.VIFGuidanceStep.Completed(childComplexity), true

	case "VIFGuidanceStep.description":
		if e.complexity.VIFGuidanceStep.Description == nil {
			break
		}

		return e.complexity.VIFGuidanceStep.Description(childComplexity), true

	case "VIFGuidanceStep.routerCommand":
		if e.complexity.VIFGuidanceStep.RouterCommand == nil {
			break
		}

		return e.complexity.VIFGuidanceStep.RouterCommand(childComplexity), true

	case "VIFGuidanceStep.step":
		if e.complexity.VIFGuidanceStep.Step == nil {
			break
		}

		return e.complexity.VIFGuidanceStep.Step(childComplexity), true

	case "VIFGuidanceStep.title":
		if e.complexity.VIFGuidanceStep.Title == nil {
			break
		}

		return e.complexity.VIFGuidanceStep.Title(childComplexity), true

	case "VIFRequirements.containerEnabled":
		if e.complexity.VIFRequirements.ContainerEnabled == nil {
			break
		}

		return e.complexity.VIFRequirements.ContainerEnabled(childComplexity), true

	case "VIFRequirements.containerPackage":
		if e.complexity.VIFRequirements.ContainerPackage == nil {
			break
		}

		return e.complexity.VIFRequirements.ContainerPackage(childComplexity), true

	case "VIFRequirements.guidanceSteps":
		if e.complexity.VIFRequirements.GuidanceSteps == nil {
			break
		}

		return e.complexity.VIFRequirements.GuidanceSteps(childComplexity), true

	case "VIFRequirements.met":
		if e.complexity.VIFRequirements.Met == nil {
			break
		}

		return e.complexity.VIFRequirements.Met(childComplexity), true

	case "VIFRequirements.missingReasons":
		if e.complexity.VIFRequirements.MissingReasons == nil {
			break
		}

		return e.complexity.VIFRequirements.MissingReasons(childComplexity), true

	case "VIFRequirements.networkNamespace":
		if e.complexity.VIFRequirements.NetworkNamespace == nil {
			break
		}

		return e.complexity.VIFRequirements.NetworkNamespace(childComplexity), true

	case "VIFRequirements.routerOSVersion":
		if e.complexity.VIFRequirements.RouterOSVersion == nil {
			break
		}

		return e.complexity.VIFRequirements.RouterOSVersion(childComplexity), true

	case "VIFRequirements.sufficientStorage":
		if e.complexity.VIFRequirements.SufficientStorage == nil {
			break
		}

		return e.complexity.VIFRequirements.SufficientStorage(childComplexity), true

	case "ValidationError.code":
		if e.complexity.ValidationError.Code == nil {
			break
		}

		return e.complexity.ValidationError.Code(childComplexity), true

	case "ValidationError.field":
		if e.complexity.ValidationError.Field == nil {
			break
		}

		return e.complexity.ValidationError.Field(childComplexity), true

	case "ValidationError.message":
		if e.complexity.ValidationError.Message == nil {
			break
		}

		return e.complexity.ValidationError.Message(childComplexity), true

	case "ValidationError.providedValue":
		if e.complexity.ValidationError.ProvidedValue == nil {
			break
		}

		return e.complexity.ValidationError.ProvidedValue(childComplexity), true

	case "ValidationError.suggestion":
		if e.complexity.ValidationError.Suggestion == nil {
			break
		}

		return e.complexity.ValidationError.Suggestion(childComplexity), true

	}
	return 0, false
}

func (e *executableSchema) Exec(ctx context.Context) graphql.ResponseHandler {
	rc := graphql.GetOperationContext(ctx)
	ec := executionContext{rc, e, 0, 0, make(chan graphql.DeferredResult)}
	inputUnmarshalMap := graphql.BuildUnmarshalerMap(
		ec.unmarshalInputAddRouterInput,
		ec.unmarshalInputCreateRouterInput,
		ec.unmarshalInputCredentialsInput,
		ec.unmarshalInputExportConfigInput,
		ec.unmarshalInputFeatureCompatibilityInput,
		ec.unmarshalInputPaginationInput,
		ec.unmarshalInputScanNetworkInput,
		ec.unmarshalInputUpdateRouterInput,
	)
	first := true

	switch rc.Operation.Operation {
	case ast.Query:
		return func(ctx context.Context) *graphql.Response {
			var response graphql.Response
			var data graphql.Marshaler
			if first {
				first = false
				ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
				data = ec._Query(ctx, rc.Operation.SelectionSet)
			} else {
				if atomic.LoadInt32(&ec.pendingDeferred) > 0 {
					result := <-ec.deferredResults
					atomic.AddInt32(&ec.pendingDeferred, -1)
					data = result.Result
					response.Path = result.Path
					response.Label = result.Label
					response.Errors = result.Errors
				} else {
					return nil
				}
			}
			var buf bytes.Buffer
			data.MarshalGQL(&buf)
			response.Data = buf.Bytes()
			if atomic.LoadInt32(&ec.deferred) > 0 {
				hasNext := atomic.LoadInt32(&ec.pendingDeferred) > 0
				response.HasNext = &hasNext
			}

			return &response
		}
	case ast.Mutation:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
			data := ec._Mutation(ctx, rc.Operation.SelectionSet)
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}
	case ast.Subscription:
		next := ec._Subscription(ctx, rc.Operation.SelectionSet)

		var buf bytes.Buffer
		return func(ctx context.Context) *graphql.Response {
			buf.Reset()
			data := next(ctx)

			if data == nil {
				return nil
			}
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}

	default:
		return graphql.OneShot(graphql.ErrorResponse(ctx, "unsupported GraphQL operation"))
	}
}

type executionContext struct {
	*graphql.OperationContext
	*executableSchema
	deferred        int32
	pendingDeferred int32
	deferredResults chan graphql.DeferredResult
}

func (ec *executionContext) processDeferredGroup(dg graphql.DeferredGroup) {
	atomic.AddInt32(&ec.pendingDeferred, 1)
	go func() {
		ctx := graphql.WithFreshResponseContext(dg.Context)
		dg.FieldSet.Dispatch(ctx)
		ds := graphql.DeferredResult{
			Path:   dg.Path,
			Label:  dg.Label,
			Result: dg.FieldSet,
			Errors: graphql.GetErrors(ctx),
		}
		// null fields should bubble up
		if dg.FieldSet.Invalids > 0 {
			ds.Result = graphql.Null
		}
		ec.deferredResults <- ds
	}()
}

func (ec *executionContext) introspectSchema() (*introspection.Schema, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapSchema(ec.Schema()), nil
}

func (ec *executionContext) introspectType(name string) (*introspection.Type, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapTypeFromDef(ec.Schema(), ec.Schema().Types[name]), nil
}

var sources = []*ast.Source{
	{Name: "../../../schema/auth.graphql", Input: `# =============================================================================
# Authentication Schema for NasNetConnect
# =============================================================================
# Defines authentication types, queries, and mutations.
# Implements JWT-based authentication with sliding sessions.
# =============================================================================

# -----------------------------------------------------------------------------
# Auth Types
# -----------------------------------------------------------------------------

"""
Authentication payload returned on successful login
"""
type AuthPayload {
  "JWT access token"
  token: String!
  "Authenticated user"
  user: User!
  "Token expiration timestamp"
  expiresAt: DateTime!
}

"""
User account in NasNetConnect
"""
type User implements Node {
  "User ULID"
  id: ID!
  "Unique username"
  username: String!
  "User role for authorization"
  role: UserRole!
  "Email address (if provided)"
  email: String
  "Display name"
  displayName: String
  "Account creation timestamp"
  createdAt: DateTime!
  "Last successful login"
  lastLoginAt: DateTime
}

"""
User roles for authorization
"""
enum UserRole {
  "Full administrative access"
  ADMIN
  "Can view and modify but not delete or manage users"
  OPERATOR
  "Read-only access"
  VIEWER
}

"""
Active user session
"""
type Session {
  "Session ULID"
  id: ID!
  "Client IP address"
  ipAddress: String
  "Client user agent"
  userAgent: String
  "Session creation time"
  createdAt: DateTime!
  "Last activity time"
  lastActivity: DateTime!
  "Whether this is the current session"
  isCurrent: Boolean!
}

# -----------------------------------------------------------------------------
# Auth Queries
# -----------------------------------------------------------------------------

extend type Query {
  "Get current authenticated user"
  me: User @auth

  "Get all active sessions for the current user"
  mySessions: [Session!]! @auth
}

# -----------------------------------------------------------------------------
# Auth Mutations
# -----------------------------------------------------------------------------

extend type Mutation {
  "Authenticate and receive a JWT token"
  login(
    "Username"
    username: String!
    "Password"
    password: String! @sensitive
  ): AuthPayload!

  "Invalidate current session and clear tokens"
  logout: Boolean! @auth

  "Change the current user's password"
  changePassword(
    "Current password for verification"
    currentPassword: String! @sensitive
    "New password (must meet policy requirements)"
    newPassword: String! @sensitive
  ): Boolean! @auth

  "Revoke all sessions for a user (admin only)"
  revokeAllSessions(
    "User ID to revoke sessions for"
    userId: ID!
  ): Boolean! @auth(requires: "admin")

  "Revoke a specific session"
  revokeSession(
    "Session ID to revoke"
    sessionId: ID!
  ): Boolean! @auth
}

# -----------------------------------------------------------------------------
# Auth Errors
# -----------------------------------------------------------------------------

"""
Authentication error codes
"""
enum AuthErrorCode {
  "Invalid username or password"
  INVALID_CREDENTIALS
  "Session has expired"
  SESSION_EXPIRED
  "Token is invalid or malformed"
  TOKEN_INVALID
  "Token has expired"
  TOKEN_EXPIRED
  "Insufficient permissions"
  INSUFFICIENT_ROLE
  "Too many login attempts"
  RATE_LIMITED
  "Password does not meet requirements"
  PASSWORD_POLICY_VIOLATION
}
`, BuiltIn: false},
	{Name: "../../../schema/connection.graphql", Input: `# =============================================================================
# Connection Management GraphQL Schema Extension
# =============================================================================
# This schema provides types and operations for managing persistent router
# connections with automatic reconnection, circuit breaker, and health monitoring.
# Story: NAS-3.5 - Implement Connection Management
# =============================================================================

# -----------------------------------------------------------------------------
# Connection Types
# -----------------------------------------------------------------------------

"""
Protocol used for router communication
"""
enum Protocol {
  "REST API protocol (RouterOS 7.1+)"
  REST
  "Binary API protocol (port 8728)"
  API
  "TLS-encrypted binary API (port 8729)"
  API_SSL
  "SSH protocol (port 22)"
  SSH
  "Telnet protocol (port 23)"
  TELNET
}

"""
Reason for router disconnection
"""
enum DisconnectReason {
  "Unknown reason"
  UNKNOWN
  "User manually disconnected"
  MANUAL
  "Network failure"
  NETWORK_FAILURE
  "Authentication failed"
  AUTH_FAILURE
  "Connection timed out"
  TIMEOUT
  "Circuit breaker is open"
  CIRCUIT_OPEN
  "Application shutting down"
  SHUTDOWN
}

"""
Circuit breaker state
"""
enum CircuitBreakerState {
  "Circuit is closed (normal operation)"
  CLOSED
  "Circuit is open (blocking requests)"
  OPEN
  "Circuit is half-open (testing recovery)"
  HALF_OPEN
}

"""
Detailed connection status for a router
"""
type ConnectionDetails {
  "Current connection state"
  state: ConnectionStatus!

  "Protocol currently in use"
  protocol: Protocol

  "User's preferred protocol (if set)"
  preferredProtocol: Protocol

  "When the connection was established"
  connectedAt: DateTime

  "Connection uptime duration"
  uptime: Duration

  "When the last disconnection occurred"
  disconnectedAt: DateTime

  "Most recent error message"
  lastError: String

  "When the last error occurred"
  lastErrorTime: DateTime

  "Reason for disconnection"
  disconnectReason: DisconnectReason

  "Number of reconnection attempts made"
  reconnectAttempts: Int!

  "When the next reconnection attempt will be made"
  nextReconnectAt: DateTime

  "Current circuit breaker state"
  circuitBreakerState: CircuitBreakerState!

  "Router version (if connected)"
  version: String

  "When the last health check was performed"
  lastHealthCheck: DateTime

  "Consecutive passed health checks"
  healthChecksPassed: Int!

  "Consecutive failed health checks"
  healthChecksFailed: Int!

  "Security warning if using insecure protocol (e.g., Telnet)"
  securityWarning: String

  "Recommendation for upgrading to a more secure protocol"
  upgradeRecommendation: String

  "Whether the current protocol is considered legacy/insecure"
  isLegacyProtocol: Boolean!
}

"""
Health check result for a router
"""
type HealthCheckResult {
  "Router ID"
  routerId: ID!

  "Whether the router is healthy"
  healthy: Boolean!

  "When the check was performed"
  checkedAt: DateTime!

  "Response time in milliseconds"
  responseTimeMs: Int

  "Error message if unhealthy"
  error: String
}

"""
Connection manager statistics
"""
type ConnectionStats {
  "Total number of connections"
  totalConnections: Int!

  "Number of connected routers"
  connected: Int!

  "Number of connecting routers"
  connecting: Int!

  "Number of disconnected routers"
  disconnected: Int!

  "Number of reconnecting routers"
  reconnecting: Int!

  "Number of routers in error state"
  error: Int!
}

# -----------------------------------------------------------------------------
# Query Extensions
# -----------------------------------------------------------------------------

extend type Query {
  "Get detailed connection status for a router"
  connectionDetails(routerId: ID!): ConnectionDetails

  "Get health check result for a router"
  routerHealth(routerId: ID!): HealthCheckResult

  "Get connection manager statistics"
  connectionStats: ConnectionStats!
}

# -----------------------------------------------------------------------------
# Mutation Extensions
# -----------------------------------------------------------------------------

extend type Mutation {
  "Set preferred protocol for a router"
  setPreferredProtocol(
    "Router ID"
    routerId: ID!
    "Preferred protocol"
    protocol: Protocol!
  ): SetPreferredProtocolPayload!

  "Manually trigger reconnection to a router"
  reconnectRouter(
    "Router ID"
    routerId: ID!
  ): ReconnectRouterPayload!

  "Perform immediate health check on a router"
  checkRouterHealth(
    "Router ID"
    routerId: ID!
  ): HealthCheckResult!
}

# -----------------------------------------------------------------------------
# Mutation Payloads
# -----------------------------------------------------------------------------

type SetPreferredProtocolPayload {
  "The updated router"
  router: Router
  "Updated connection details"
  connectionDetails: ConnectionDetails
  "Errors that occurred"
  errors: [MutationError!]
}

type ReconnectRouterPayload {
  "The router being reconnected"
  router: Router
  "Updated connection details"
  connectionDetails: ConnectionDetails
  "Whether reconnection was initiated"
  initiated: Boolean!
  "Rate limit wait time if rate limited"
  waitTimeMs: Int
  "Errors that occurred"
  errors: [MutationError!]
}

# -----------------------------------------------------------------------------
# Subscription Extensions
# -----------------------------------------------------------------------------

extend type Subscription {
  "Subscribe to connection health updates"
  connectionHealth(
    "Router ID to monitor (optional, all routers if not specified)"
    routerId: ID
  ): HealthCheckResult!

  "Subscribe to circuit breaker state changes"
  circuitBreakerChanged(
    "Router ID to monitor"
    routerId: ID!
  ): CircuitBreakerEvent!
}

"""
Event emitted when circuit breaker state changes
"""
type CircuitBreakerEvent {
  "Router ID"
  routerId: ID!
  "Previous state"
  previousState: CircuitBreakerState!
  "New state"
  newState: CircuitBreakerState!
  "Consecutive failures that triggered the change"
  consecutiveFailures: Int!
  "When the state changed"
  timestamp: DateTime!
}
`, BuiltIn: false},
	{Name: "../../../schema/credentials.graphql", Input: `# =============================================================================
# Credential Management GraphQL Schema
# =============================================================================
# This schema defines types and operations for managing router credentials.
#
# Security Notes:
# - Passwords are NEVER returned in any query or mutation response
# - All credential fields use AES-256-GCM encryption at rest
# - Credential changes are logged to the audit trail (without values)
# - The @sensitive directive marks fields that should be redacted in logs
# =============================================================================

# -----------------------------------------------------------------------------
# Credential Types
# -----------------------------------------------------------------------------

"""
Router credential information (non-sensitive).
Password is never included - only metadata about credentials.
"""
type RouterCredentials {
  "Router ID these credentials belong to"
  routerId: ID!
  "Username for router authentication"
  username: String!
  "Whether a password is stored"
  hasPassword: Boolean!
  "Encryption algorithm used (always 'AES-256-GCM')"
  encryptionStatus: String!
  "Encryption key version (for rotation tracking)"
  keyVersion: Int!
  "When credentials were last updated"
  lastUpdated: DateTime!
  "When credentials were first created"
  createdAt: DateTime!
}

"""
Input for updating router credentials.
Both username and password must be provided.
"""
input CredentialsInput {
  "Username for router authentication"
  username: String! @validate(minLength: 1, maxLength: 64) @sensitive
  "Password for router authentication"
  password: String! @validate(minLength: 1, maxLength: 128) @sensitive
}

"""
Result of updating router credentials.
"""
type CredentialUpdatePayload {
  "Whether the update was successful"
  success: Boolean!
  "Human-readable message about the operation"
  message: String!
  "Updated credential info (without password)"
  credentials: RouterCredentials
  "Error code if update failed"
  errorCode: CredentialErrorCode
  "Errors that occurred during update"
  errors: [MutationError!]
}

"""
Error codes specific to credential operations.
"""
enum CredentialErrorCode {
  "Authentication failed with new credentials"
  AUTH_FAILED
  "Connection timed out when testing credentials"
  TIMEOUT
  "Connection was refused"
  CONNECTION_REFUSED
  "Router not found"
  ROUTER_NOT_FOUND
  "Credentials not found for router"
  CREDENTIALS_NOT_FOUND
  "Encryption failed"
  ENCRYPTION_FAILED
  "Decryption failed (key may have rotated)"
  DECRYPTION_FAILED
  "Invalid input provided"
  INVALID_INPUT
}

# -----------------------------------------------------------------------------
# Bulk Testing Types
# -----------------------------------------------------------------------------

"""
Result of testing all router credentials.
"""
type TestAllCredentialsPayload {
  "Total number of routers tested"
  totalRouters: Int!
  "Number of successful credential tests"
  successCount: Int!
  "Number of failed credential tests"
  failureCount: Int!
  "Per-router test results"
  results: [CredentialTestResult!]!
}

"""
Result of testing a single router's credentials.
"""
type CredentialTestResult {
  "Router ID that was tested"
  routerId: ID!
  "Router name for display"
  routerName: String!
  "Whether the test was successful"
  success: Boolean!
  "Connection status"
  status: CredentialTestStatus!
  "Response time in milliseconds (if successful)"
  responseTimeMs: Int
  "Error message if test failed"
  error: String
}

"""
Status of a credential test.
"""
enum CredentialTestStatus {
  "Credentials are valid and connection succeeded"
  SUCCESS
  "Authentication failed"
  AUTH_FAILED
  "Connection timed out"
  TIMEOUT
  "Connection was refused"
  CONNECTION_REFUSED
  "Network unreachable"
  NETWORK_ERROR
  "No credentials stored for this router"
  NO_CREDENTIALS
  "Unknown error occurred"
  ERROR
}

# -----------------------------------------------------------------------------
# Export Security Types
# -----------------------------------------------------------------------------

"""
Options for exporting router configuration.
"""
input ExportConfigInput {
  "Router ID to export configuration from"
  routerId: ID!
  "Whether to include credentials (requires encryptionKey if true)"
  includeCredentials: Boolean
  "User-provided encryption key for credential export (required if includeCredentials is true)"
  encryptionKey: String @sensitive
}

"""
Result of exporting router configuration.
"""
type ExportConfigPayload {
  "Whether the export was successful"
  success: Boolean!
  "Exported configuration data (JSON format)"
  config: JSON
  "Security warning message about credential handling"
  securityWarning: String
  "Errors that occurred during export"
  errors: [MutationError!]
}

# -----------------------------------------------------------------------------
# Query Extensions
# -----------------------------------------------------------------------------

extend type Query {
  "Get credential information for a router (password is never returned)"
  routerCredentials(routerId: ID!): RouterCredentials @auth
}

# -----------------------------------------------------------------------------
# Mutation Extensions
# -----------------------------------------------------------------------------

extend type Mutation {
  """
  Update router credentials.
  Tests the new credentials before saving.
  Old credentials are preserved if the test fails.
  """
  updateRouterCredentials(
    routerId: ID!
    input: CredentialsInput!
  ): CredentialUpdatePayload! @auth

  """
  Test all router credentials in parallel.
  Returns aggregate results with per-router status.
  """
  testAllCredentials: TestAllCredentialsPayload! @auth

  """
  Export router configuration with optional credential handling.
  Credentials are excluded by default for security.
  If includeCredentials is true, an encryptionKey must be provided.
  """
  exportRouterConfig(input: ExportConfigInput!): ExportConfigPayload! @auth
}
`, BuiltIn: false},
	{Name: "../../../schema/diagnostics.graphql", Input: `# =============================================================================
# Connection Diagnostics GraphQL Schema Extension
# =============================================================================
# This schema provides types and operations for diagnosing router connection
# issues, providing actionable troubleshooting suggestions, and exposing
# circuit breaker state.
# Story: NAS-3.10 - Implement Connection Diagnostics
# =============================================================================

# -----------------------------------------------------------------------------
# Diagnostic Types
# -----------------------------------------------------------------------------

"""
Severity level for diagnostic suggestions
"""
enum SuggestionSeverity {
  "Informational message, no action required"
  INFO
  "Warning that may affect functionality"
  WARNING
  "Error that needs to be addressed"
  ERROR
  "Critical issue blocking connectivity"
  CRITICAL
}

"""
Category of connection error for classification
"""
enum ErrorCategory {
  "Connection or response timeout"
  TIMEOUT
  "Connection actively refused"
  REFUSED
  "Authentication failed"
  AUTH_FAILED
  "Protocol-level error"
  PROTOCOL_ERROR
  "Network unreachable or DNS failure"
  NETWORK_ERROR
  "TLS/SSL certificate or handshake error"
  TLS_ERROR
}

"""
Status of a single port check
"""
type PortStatus {
  "Port number checked"
  port: Int!
  "Service name (API, API-SSL, SSH, Telnet, HTTP, HTTPS)"
  service: String!
  "Whether the port is open and accepting connections"
  open: Boolean!
  "Response time in milliseconds (if port is open)"
  responseTimeMs: Int
  "Error message (if port is closed)"
  error: String
}

"""
TLS certificate status for secure connections
"""
type TLSStatus {
  "Whether the certificate is valid"
  valid: Boolean!
  "Certificate issuer"
  issuer: String
  "Certificate subject"
  subject: String
  "Certificate expiration date"
  expiresAt: DateTime
  "Error message (if certificate is invalid)"
  error: String
}

"""
Authentication test status
"""
type AuthStatus {
  "Whether authentication was tested"
  tested: Boolean!
  "Whether authentication succeeded"
  success: Boolean!
  "Error message (if authentication failed)"
  error: String
  "Error code mapped to ErrorCodes (A5xx)"
  errorCode: String
}

"""
Actionable diagnostic suggestion
"""
type DiagnosticSuggestion {
  "Severity level of the issue"
  severity: SuggestionSeverity!
  "Short title describing the issue"
  title: String!
  "Detailed description of the issue"
  description: String!
  "Recommended action to resolve the issue"
  action: String!
  "Link to relevant documentation"
  docsUrl: String
}

"""
Comprehensive diagnostic report for a router
"""
type DiagnosticReport {
  "Router ID being diagnosed"
  routerId: ID!
  "When the diagnostic was run"
  timestamp: DateTime!
  "Whether the router is reachable on the network"
  networkReachable: Boolean!
  "Status of each checked port"
  portStatus: [PortStatus!]!
  "TLS certificate status (if TLS ports were checked)"
  tlsStatus: TLSStatus
  "Authentication test status"
  authStatus: AuthStatus!
  "Actionable suggestions based on diagnostic results"
  suggestions: [DiagnosticSuggestion!]!
  "Raw text report for clipboard/export"
  rawReport: String!
}

"""
Record of a single protocol connection attempt
"""
type ConnectionAttempt {
  "Protocol that was attempted"
  protocol: Protocol!
  "When the attempt started"
  startedAt: DateTime!
  "When the attempt ended"
  endedAt: DateTime!
  "Whether the attempt succeeded"
  success: Boolean!
  "Error code if failed"
  errorCode: String
  "Error message if failed"
  errorMessage: String
  "Error category for classification"
  errorCategory: ErrorCategory
}

"""
Circuit breaker status for a router
"""
type CircuitBreakerStatus {
  "Router ID"
  routerId: ID!
  "Current circuit breaker state"
  state: CircuitBreakerState!
  "Number of consecutive failures"
  failureCount: Int!
  "Failure threshold before circuit opens"
  failureThreshold: Int!
  "Seconds until auto-retry (when circuit is open)"
  cooldownRemainingSeconds: Int
  "When the last failure occurred"
  lastFailureAt: DateTime
  "When the last success occurred"
  lastSuccessAt: DateTime
}

# -----------------------------------------------------------------------------
# Query Extensions
# -----------------------------------------------------------------------------

extend type Query {
  """
  Get recent connection attempts for a router.
  Returns the most recent attempts, ordered newest first.
  """
  connectionAttempts(
    "Router ID to get attempts for"
    routerId: ID!
    "Maximum number of attempts to return (default: 10)"
    limit: Int = 10
  ): [ConnectionAttempt!]!

  """
  Get circuit breaker status for a router.
  Shows current state, failure counts, and cooldown timing.
  """
  circuitBreakerStatus(routerId: ID!): CircuitBreakerStatus!
}

# -----------------------------------------------------------------------------
# Mutation Extensions
# -----------------------------------------------------------------------------

extend type Mutation {
  """
  Run comprehensive diagnostics on a router connection.
  Performs network reachability check, port scanning, TLS validation,
  and authentication testing. Rate limited to 1 request per 10 seconds per router.
  """
  runDiagnostics(routerId: ID!): DiagnosticReport!

  """
  Manually reset the circuit breaker for a router.
  This allows immediate reconnection attempts even if the circuit is open.
  Use with caution as it bypasses the backoff protection.
  """
  resetCircuitBreaker(routerId: ID!): CircuitBreakerStatus!
}

# -----------------------------------------------------------------------------
# Subscription Extensions
# -----------------------------------------------------------------------------

extend type Subscription {
  """
  Subscribe to circuit breaker state changes for a router.
  Emits an event whenever the circuit breaker transitions between states.
  """
  circuitBreakerStateChanged(
    "Router ID to monitor (optional, all routers if not specified)"
    routerId: ID
  ): CircuitBreakerStatus!
}
`, BuiltIn: false},
	{Name: "../../../schema/directives.graphql", Input: `# =============================================================================
# Custom Directive Definitions for NasNetConnect
# =============================================================================
# These directives enable:
# 1. Input validation (@validate) - Generates Zod schemas
# 2. Platform mapping (@mikrotik, @openwrt, @vyos) - Multi-platform support
# 3. Capability gating (@capability) - Feature-based access control
# =============================================================================

# -----------------------------------------------------------------------------
# Validation Directive
# -----------------------------------------------------------------------------
# Used to define validation constraints on input fields and field definitions.
# These constraints are:
# - Processed by graphql-codegen to generate Zod validation schemas
# - Used by gqlgen for server-side validation
#
# Example usage:
#   input CreateUserInput {
#     username: String! @validate(minLength: 3, maxLength: 32, pattern: "^[a-z0-9_]+$")
#     email: String! @validate(format: EMAIL)
#     age: Int @validate(min: 0, max: 150)
#   }
# -----------------------------------------------------------------------------
directive @validate(
  "Minimum value for numeric types"
  min: Int
  "Maximum value for numeric types"
  max: Int
  "Minimum length for string types"
  minLength: Int
  "Maximum length for string types"
  maxLength: Int
  "Regular expression pattern for string validation"
  pattern: String
  "Predefined format validation (EMAIL, URL, UUID, IPV4, IPV6, MAC, CIDR)"
  format: ValidateFormat
) on INPUT_FIELD_DEFINITION | FIELD_DEFINITION | ARGUMENT_DEFINITION

"""
Predefined validation formats for common data types
"""
enum ValidateFormat {
  EMAIL
  URL
  UUID
  IPV4
  IPV6
  MAC
  CIDR
  HOSTNAME
  FQDN
}

# -----------------------------------------------------------------------------
# Platform Mapping Directives
# -----------------------------------------------------------------------------
# These directives map GraphQL fields to platform-specific API paths.
# The resolver layer uses these to translate operations to router commands.
#
# Example usage:
#   type Interface {
#     name: String! @mikrotik(path: "/interface", field: "name") @openwrt(ubus: "network.interface", field: "interface")
#   }
# -----------------------------------------------------------------------------

"""
Maps field to MikroTik RouterOS API path and command
"""
directive @mikrotik(
  "RouterOS API path (e.g., '/ip/address', '/interface/ethernet')"
  path: String!
  "Field name in RouterOS response if different from GraphQL field"
  field: String
  "RouterOS command (print, add, set, remove) - defaults to contextual"
  cmd: String
) on FIELD_DEFINITION | OBJECT

"""
Maps field to OpenWrt ubus call
"""
directive @openwrt(
  "Ubus namespace and method (e.g., 'network.interface', 'system.board')"
  ubus: String!
  "Method to call (list, call, etc.)"
  method: String
  "Field name in ubus response if different from GraphQL field"
  field: String
) on FIELD_DEFINITION | OBJECT

"""
Maps field to VyOS configuration path
"""
directive @vyos(
  "VyOS configuration path (e.g., 'interfaces ethernet eth0')"
  path: String!
  "Field name in VyOS response if different from GraphQL field"
  field: String
) on FIELD_DEFINITION | OBJECT

# -----------------------------------------------------------------------------
# Capability Directive
# -----------------------------------------------------------------------------
# Gates field access based on router capabilities.
# Resolver checks if connected router has required capabilities before
# attempting to fetch/mutate the field.
#
# Example usage:
#   type WirelessInterface {
#     channel: Int! @capability(requires: ["wireless"])
#     wifiWave2: Boolean @capability(requires: ["wireless", "wifi-wave2"])
#   }
# -----------------------------------------------------------------------------
directive @capability(
  "List of required capability identifiers"
  requires: [String!]!
) on FIELD_DEFINITION | OBJECT

# -----------------------------------------------------------------------------
# Subscription Directive
# -----------------------------------------------------------------------------
# Marks a field as subscribable for real-time updates.
#
# Example usage:
#   type Subscription {
#     interfaceTraffic(interfaceId: ID!): TrafficUpdate! @realtime(interval: 1000)
#   }
# -----------------------------------------------------------------------------
directive @realtime(
  "Update interval in milliseconds"
  interval: Int
  "Topic/channel name for pub/sub"
  topic: String
) on FIELD_DEFINITION

# -----------------------------------------------------------------------------
# Caching Directive
# -----------------------------------------------------------------------------
# Hints for client-side and server-side caching behavior.
#
# Example usage:
#   type SystemInfo {
#     version: String! @cache(maxAge: 3600)
#     uptime: Duration! @cache(maxAge: 5)
#   }
# -----------------------------------------------------------------------------
directive @cache(
  "Maximum age in seconds"
  maxAge: Int!
  "Cache scope (PRIVATE for user-specific, PUBLIC for shared)"
  scope: CacheScope
) on FIELD_DEFINITION

enum CacheScope {
  PRIVATE
  PUBLIC
}

# -----------------------------------------------------------------------------
# Deprecated with migration hint
# -----------------------------------------------------------------------------
# Extended deprecation with migration guidance.
#
# Example usage:
#   type Query {
#     oldEndpoint: Data @deprecated(reason: "Use newEndpoint", replacement: "newEndpoint")
#   }
# -----------------------------------------------------------------------------
directive @migrateFrom(
  "The old field/type name this replaces"
  field: String!
  "Version when migration should be complete"
  removeInVersion: String
) on FIELD_DEFINITION | OBJECT | INPUT_FIELD_DEFINITION

# -----------------------------------------------------------------------------
# Sensitive Data Directive
# -----------------------------------------------------------------------------
# Marks fields containing sensitive data that should be redacted in logs
# and stripped from error responses in production mode.
#
# Example usage:
#   input CredentialsInput {
#     username: String!
#     password: String! @sensitive
#     apiKey: String @sensitive
#   }
#
#   type RouterSecret {
#     encryptedPassword: String! @sensitive
#     sshKey: String @sensitive
#   }
# -----------------------------------------------------------------------------
"""
Marks field as containing sensitive data (passwords, tokens, keys).
Values are redacted in logs and error responses.
"""
directive @sensitive on FIELD_DEFINITION | INPUT_FIELD_DEFINITION | ARGUMENT_DEFINITION

# -----------------------------------------------------------------------------
# Auth Directive
# -----------------------------------------------------------------------------
# Requires authentication and optional role/permission checks.
# Must be authenticated to access fields with this directive.
#
# Example usage:
#   type Mutation {
#     deleteRouter(id: ID!): Boolean! @auth(requires: "admin")
#     updateSettings: Settings! @auth  # Just requires authentication
#   }
# -----------------------------------------------------------------------------
"""
Requires authentication to access this field.
Optionally requires a specific role or permission.
"""
directive @auth(
  "Required role or permission level (e.g., 'admin', 'operator', 'viewer')"
  requires: String
) on FIELD_DEFINITION | OBJECT
`, BuiltIn: false},
	{Name: "../../../schema/router-add.graphql", Input: `# =============================================================================
# Router Addition GraphQL Schema Extension
# =============================================================================
# This schema provides types and operations for manually adding routers with
# credential validation, protocol preference, and connection testing.
# Story: NAS-3.8 - Implement Manual Router Addition Flow
# =============================================================================

# -----------------------------------------------------------------------------
# Protocol Preference Enum
# -----------------------------------------------------------------------------

"""
User preference for which protocol to use when connecting to a router.
AUTO will try protocols in the recommended fallback order.
"""
enum ProtocolPreference {
  "Automatically detect best protocol (REST -> API -> API_SSL -> SSH -> Telnet)"
  AUTO
  "Force REST API protocol (RouterOS 7.1+)"
  REST
  "Force Binary API protocol (port 8728)"
  API
  "Force TLS-encrypted binary API (port 8729)"
  API_SSL
  "Force SSH protocol (port 22)"
  SSH
  "Force Telnet protocol (port 23, insecure - use only as last resort)"
  TELNET
}

# -----------------------------------------------------------------------------
# Input Types
# -----------------------------------------------------------------------------

"""
Input for manually adding a new router with full credentials and protocol preference.
This is the primary input type for the addRouter mutation.
"""
input AddRouterInput {
  """
  Router hostname or IP address.
  Can be an IPv4 address (e.g., '192.168.88.1'), IPv6 address, or hostname (e.g., 'router.local').
  Hostnames will trigger DNS resolution with caching.
  """
  host: String! @validate(minLength: 1, maxLength: 253)

  """
  Connection port. If not specified, defaults to protocol-specific port:
  - REST: 443 (or 80 for HTTP)
  - API: 8728
  - API_SSL: 8729
  - SSH: 22
  - Telnet: 23
  """
  port: Int @validate(min: 1, max: 65535)

  """
  Username for authentication.
  For MikroTik routers, this is typically 'admin' or a custom user.
  """
  username: String! @validate(minLength: 1, maxLength: 64)

  """
  Password for authentication.
  This value is encrypted before storage and never logged.
  """
  password: String! @sensitive

  """
  Protocol preference for connection.
  Defaults to AUTO which tries protocols in recommended order.
  """
  protocolPreference: ProtocolPreference

  """
  User-friendly display name for the router.
  If not provided, a name will be generated from the host.
  """
  name: String @validate(maxLength: 128)
}

# -----------------------------------------------------------------------------
# Connection Test Result
# -----------------------------------------------------------------------------

"""
Result of a connection test attempt, including protocol detection results.
"""
type ConnectionTestResult {
  "Whether the connection was successful"
  success: Boolean!

  "Protocol that was successfully used"
  protocolUsed: Protocol

  "Response time in milliseconds"
  responseTimeMs: Int

  "RouterOS version detected (if connection succeeded)"
  routerVersion: String

  "Router model detected (if connection succeeded)"
  routerModel: String

  "Router board name (if connection succeeded)"
  boardName: String

  "Uptime of the router (if connection succeeded)"
  uptime: Duration

  "List of protocols that were attempted"
  protocolsAttempted: [Protocol!]!

  "Whether the router supports containers"
  supportsContainers: Boolean

  "Architecture of the router (arm, arm64, x86, etc.)"
  architecture: String

  "Error details if connection failed"
  error: ConnectionError
}

"""
Detailed error information for connection failures.
Used to provide actionable feedback to the user.
"""
type ConnectionError {
  "Error code for programmatic handling"
  code: ConnectionErrorCode!

  "Human-readable error message"
  message: String!

  "Protocol that failed (if specific to a protocol)"
  protocol: Protocol

  "Whether the error is likely transient and retryable"
  retryable: Boolean!

  "Suggested user action to resolve the error"
  suggestedAction: String

  "Timeout in milliseconds (if timeout error)"
  timeoutMs: Int
}

"""
Error codes for connection failures.
Each code has specific meaning and recovery suggestions.
"""
enum ConnectionErrorCode {
  "Authentication failed - invalid username or password"
  AUTH_FAILED
  "Network unreachable - cannot reach the host"
  NETWORK_UNREACHABLE
  "Connection refused - port is closed or blocked"
  CONNECTION_REFUSED
  "No compatible protocol found after trying all options"
  PROTOCOL_MISMATCH
  "Connection or response timed out"
  TIMEOUT
  "DNS resolution failed for hostname"
  DNS_FAILED
  "Router with same host/port already exists"
  DUPLICATE_ROUTER
  "TLS/SSL handshake failed"
  TLS_ERROR
  "Router responded but is not a MikroTik device"
  NOT_MIKROTIK
  "Unknown or unexpected error"
  UNKNOWN
}

# -----------------------------------------------------------------------------
# Mutation Payload
# -----------------------------------------------------------------------------

"""
Payload returned from the addRouter mutation.
Contains either the created router or validation/connection errors.
"""
type AddRouterPayload {
  "The newly created router (null if errors occurred)"
  router: Router

  "Connection test result from initial connection attempt"
  connectionResult: ConnectionTestResult

  "Field-level validation errors for retry"
  validationErrors: [ValidationError!]

  "General errors that occurred during creation"
  errors: [MutationError!]
}

"""
Field-level validation error with suggestions for fixing.
"""
type ValidationError {
  "Field path that failed validation (e.g., 'input.host', 'input.port')"
  field: String!

  "Error code for the validation failure"
  code: String!

  "Human-readable error message"
  message: String!

  "Suggestion for fixing the validation error"
  suggestion: String

  "The invalid value (redacted for sensitive fields)"
  providedValue: String
}

# -----------------------------------------------------------------------------
# Mutation Extension
# -----------------------------------------------------------------------------

extend type Mutation {
  """
  Add a new router by entering its IP address and credentials.

  This mutation will:
  1. Validate input fields (host format, port range, etc.)
  2. Check for duplicate routers (same host/port)
  3. Resolve hostname to IP if necessary (with DNS caching)
  4. Test connection using protocol preference (or auto-detect)
  5. Store router with encrypted credentials on success
  6. Emit RouterAddedEvent for real-time updates

  Returns validation errors if input is invalid, or connection errors
  if the router cannot be reached or authenticated.
  """
  addRouter(input: AddRouterInput!): AddRouterPayload!

  """
  Test connection to a router without adding it.
  Useful for validating credentials before committing.
  """
  testRouterCredentials(input: AddRouterInput!): ConnectionTestResult!
}

# -----------------------------------------------------------------------------
# Subscription Extension
# -----------------------------------------------------------------------------

extend type Subscription {
  """
  Subscribe to router addition events.
  Emits when a new router is successfully added to the system.
  """
  routerAdded: RouterAddedEvent!
}

"""
Event emitted when a new router is added.
"""
type RouterAddedEvent {
  "The newly added router"
  router: Router!

  "Protocol used for initial connection"
  protocolUsed: Protocol!

  "User who added the router (if authenticated)"
  addedBy: String

  "Timestamp of addition"
  timestamp: DateTime!
}
`, BuiltIn: false},
	{Name: "../../../schema/scalars.graphql", Input: `# =============================================================================
# Custom Scalar Definitions for NasNetConnect
# =============================================================================
# These scalars provide type safety for network-specific data types.
# Generated code will map these to appropriate language types.
# =============================================================================

"""
ISO 8601 datetime string (e.g., "2024-01-15T10:30:00Z")
"""
scalar DateTime

"""
Arbitrary JSON data for flexible configuration
"""
scalar JSON

"""
IPv4 address string (e.g., "192.168.1.1")
Validated format: XXX.XXX.XXX.XXX where XXX is 0-255
"""
scalar IPv4

"""
IPv6 address string (e.g., "2001:0db8:85a3:0000:0000:8a2e:0370:7334")
"""
scalar IPv6

"""
MAC address string (e.g., "00:1A:2B:3C:4D:5E" or "00-1A-2B-3C-4D-5E")
"""
scalar MAC

"""
CIDR notation for network address (e.g., "192.168.1.0/24")
"""
scalar CIDR

"""
TCP/UDP port number (1-65535)
"""
scalar Port

"""
Port range string (e.g., "80", "80-443", "80,443,8080")
"""
scalar PortRange

"""
Duration string in RouterOS format (e.g., "1d2h3m4s", "30s", "5m")
"""
scalar Duration

"""
Bandwidth string with unit (e.g., "10M", "1G", "100k")
"""
scalar Bandwidth

"""
Size in bytes with optional unit (e.g., "1024", "1k", "1M", "1G")
"""
scalar Size

"""
ULID (Universally Unique Lexicographically Sortable Identifier)
A 26-character string that is time-sortable and globally unique.
Example: "01ARZ3NDEKTSV4RRFFQ69G5FAV"
"""
scalar ULID
`, BuiltIn: false},
	{Name: "../../../schema/scanner.graphql", Input: `# =============================================================================
# Network Scanner GraphQL Schema
# =============================================================================
# Types for router auto-discovery and network scanning functionality.
# Enables users to discover MikroTik routers on their network without knowing
# their IP addresses.
#
# Story: NAS-3.4 - Implement Router Auto Scanner
# =============================================================================

# -----------------------------------------------------------------------------
# Scan Status Enum
# -----------------------------------------------------------------------------

"""
Status of a network scan operation
"""
enum ScanStatus {
  "Scan is queued and waiting to start"
  PENDING
  "Scan is actively running"
  RUNNING
  "Scan completed successfully"
  COMPLETED
  "Scan was cancelled by user"
  CANCELLED
  "Scan failed with an error"
  FAILED
}

# -----------------------------------------------------------------------------
# Core Types
# -----------------------------------------------------------------------------

"""
Information about a discovered RouterOS device
"""
type RouterOSInfo {
  "RouterOS version string (e.g., '7.12', '6.49.8')"
  version: String
  "Router board name (e.g., 'hAP ac', 'CCR2004-1G-12S+2XS')"
  boardName: String
  "CPU architecture (e.g., 'arm', 'x86', 'mips')"
  architecture: String
  "Platform identifier"
  platform: String
}

"""
A device discovered during a network scan.
Only confirmed MikroTik devices are returned (confidence >= 40).
"""
type DiscoveredDevice {
  "IP address of the discovered device"
  ip: String!
  "Hostname (if reverse DNS resolves)"
  hostname: String
  "Open ports found on the device"
  ports: [Int!]!
  "Device type classification"
  deviceType: String!
  "Device vendor (always 'MikroTik' for returned results)"
  vendor: String
  "RouterOS-specific information (version, board, architecture)"
  routerOSInfo: RouterOSInfo
  "Confidence score for RouterOS detection (40-100)"
  confidence: Int!
  "Detected services (mikrotik-api, mikrotik-winbox, mikrotik-rest, etc.)"
  services: [String!]!
}

"""
A network scan task that tracks scan progress and results.
Scans are asynchronous - start with mutation, poll/subscribe for progress.
"""
type ScanTask {
  "Unique task identifier"
  id: ID!
  "Target subnet (CIDR notation, IP range, or gateway scan indicator)"
  subnet: String!
  "Current scan status"
  status: ScanStatus!
  "Scan progress percentage (0-100)"
  progress: Int!
  "Discovered devices (populated as scan progresses)"
  results: [DiscoveredDevice!]!
  "When the scan was started"
  startTime: DateTime!
  "When the scan completed (null if still running)"
  endTime: DateTime
  "Error message if scan failed"
  error: String
  "Total IPs to scan (for progress calculation)"
  totalIPs: Int
  "Number of IPs scanned so far"
  scannedIPs: Int
}

"""
Real-time progress event for scan subscriptions
"""
type ScanProgressEvent {
  "Task ID this event belongs to"
  taskId: ID!
  "Current progress percentage (0-100)"
  progress: Int!
  "Number of MikroTik devices found so far"
  devicesFound: Int!
  "IP address currently being scanned"
  currentIP: String
  "Current scan status"
  status: ScanStatus!
  "Timestamp of this progress update"
  timestamp: DateTime!
}

# -----------------------------------------------------------------------------
# Input Types
# -----------------------------------------------------------------------------

"""
Input for starting a network scan
"""
input ScanNetworkInput {
  "Target subnet in CIDR notation (e.g., '192.168.88.0/24') or IP range (e.g., '192.168.1.1-192.168.1.100')"
  subnet: String! @validate(minLength: 7, maxLength: 43)
}

# -----------------------------------------------------------------------------
# Mutation Payloads
# -----------------------------------------------------------------------------

type ScanNetworkPayload {
  "The created scan task"
  task: ScanTask
  "Errors that occurred"
  errors: [MutationError!]
}

type CancelScanPayload {
  "The cancelled scan task"
  task: ScanTask
  "Errors that occurred"
  errors: [MutationError!]
}

# -----------------------------------------------------------------------------
# Query Extensions
# -----------------------------------------------------------------------------

extend type Query {
  "Get the status of a scan task by ID"
  scanStatus(taskId: ID!): ScanTask

  "Get scan history (recent scans)"
  scanHistory(
    "Maximum number of results to return"
    limit: Int = 10
  ): [ScanTask!]!
}

# -----------------------------------------------------------------------------
# Mutation Extensions
# -----------------------------------------------------------------------------

extend type Mutation {
  """
  Start a network scan for MikroTik routers.
  Returns a task ID that can be used to track progress via subscription or polling.

  Supported subnet formats:
  - CIDR: "192.168.88.0/24" (scans 254 usable IPs)
  - Range: "192.168.1.1-192.168.1.100" (scans specified range)
  - Single IP: "192.168.88.1" (scans one IP)

  Performance: /24 scan completes in 1-2 seconds with 20 concurrent workers.
  """
  scanNetwork(input: ScanNetworkInput!): ScanNetworkPayload!

  """
  Start an automatic gateway scan.
  Scans common gateway IPs (192.168.0-255.1) to find MikroTik routers.
  This is useful when the user doesn't know which subnet to scan.

  Only returns verified MikroTik RouterOS devices (confidence >= 40).
  """
  autoScanGateways: ScanNetworkPayload!

  """
  Cancel a running scan.
  The scan will stop within 1 second and partial results are preserved.
  """
  cancelScan(taskId: ID!): CancelScanPayload!
}

# -----------------------------------------------------------------------------
# Subscription Extensions
# -----------------------------------------------------------------------------

extend type Subscription {
  """
  Subscribe to real-time scan progress updates.
  Emits events every 5% progress or every 2 seconds, whichever is sooner.
  """
  scanProgress(taskId: ID!): ScanProgressEvent!
}
`, BuiltIn: false},
	{Name: "../../../schema/schema.graphql", Input: `# =============================================================================
# NasNetConnect GraphQL Schema
# =============================================================================
# This is the main schema file defining queries, mutations, and subscriptions.
# It serves as the single source of truth for the API contract.
#
# Schema Structure:
# - scalars.graphql - Custom scalar type definitions
# - directives.graphql - Custom directive definitions
# - schema.graphql - This file (types, queries, mutations, subscriptions)
#
# Code Generation:
# - TypeScript: graphql-codegen generates types, hooks, and Zod schemas
# - Go: gqlgen generates structs, resolvers, and validators
# =============================================================================

# -----------------------------------------------------------------------------
# Core Interfaces
# -----------------------------------------------------------------------------

"""
Relay Node interface for global object identification
"""
interface Node {
  "Globally unique identifier"
  id: ID!
}

"""
Connection interface for paginated results (Relay pagination)
"""
interface Connection {
  "Pagination information"
  pageInfo: PageInfo!
  "Total count of items (if available)"
  totalCount: Int
}

"""
Edge interface for connection edges
"""
interface Edge {
  "Cursor for pagination"
  cursor: String!
}

# -----------------------------------------------------------------------------
# Pagination Types
# -----------------------------------------------------------------------------

"""
Information about pagination in a connection
"""
type PageInfo {
  "When paginating forwards, are there more items?"
  hasNextPage: Boolean!
  "When paginating backwards, are there more items?"
  hasPreviousPage: Boolean!
  "Cursor for the first edge"
  startCursor: String
  "Cursor for the last edge"
  endCursor: String
}

"""
Standard pagination input arguments
"""
input PaginationInput {
  "Number of items to fetch"
  first: Int
  "Cursor to fetch items after"
  after: String
  "Number of items to fetch from the end"
  last: Int
  "Cursor to fetch items before"
  before: String
}

# -----------------------------------------------------------------------------
# Health & System Types
# -----------------------------------------------------------------------------

"""
Overall system health status
"""
type HealthStatus {
  "Service status"
  status: ServiceStatus!
  "Service version"
  version: String!
  "Server uptime"
  uptime: Duration
  "Connected router count"
  connectedRouters: Int!
  "Last health check timestamp"
  checkedAt: DateTime!
}

"""
Service operational status
"""
enum ServiceStatus {
  "Service is fully operational"
  HEALTHY
  "Service is operational with degraded performance"
  DEGRADED
  "Service is not operational"
  UNHEALTHY
}

"""
Router connection status
"""
enum ConnectionStatus {
  "Actively connected and responsive"
  CONNECTED
  "Connection attempt in progress"
  CONNECTING
  "Not connected"
  DISCONNECTED
  "Connection failed with error"
  ERROR
}

# -----------------------------------------------------------------------------
# Router Types
# -----------------------------------------------------------------------------

"""
A managed router device
"""
type Router implements Node {
  "Unique router identifier"
  id: ID!
  "User-friendly display name"
  name: String!
  "Router hostname or IP address"
  host: String!
  "Connection port"
  port: Int!
  "Current connection status"
  status: ConnectionStatus!
  "Router platform type"
  platform: RouterPlatform!
  "RouterOS version (if connected)"
  version: String @mikrotik(path: "/system/resource", field: "version")
  "Router model"
  model: String @mikrotik(path: "/system/routerboard", field: "model")
  "System uptime"
  uptime: Duration @mikrotik(path: "/system/resource", field: "uptime")
  "Last successful connection time"
  lastConnected: DateTime
  "When the router was added to NasNet"
  createdAt: DateTime!
  "Last update timestamp"
  updatedAt: DateTime!
  "Detected router capabilities (requires connection)"
  capabilities: RouterCapabilities
}

"""
Supported router platforms
"""
enum RouterPlatform {
  "MikroTik RouterOS"
  MIKROTIK
  "OpenWrt"
  OPENWRT
  "VyOS"
  VYOS
  "Generic/Unknown"
  GENERIC
}

"""
Input for creating a new router connection
"""
input CreateRouterInput {
  "User-friendly display name"
  name: String! @validate(minLength: 1, maxLength: 64)
  "Router hostname or IP address"
  host: String! @validate(minLength: 1, maxLength: 255)
  "Connection port (default: 8728 for MikroTik API)"
  port: Int @validate(min: 1, max: 65535)
  "Username for authentication"
  username: String! @validate(minLength: 1, maxLength: 64)
  "Password for authentication"
  password: String! @validate(minLength: 1, maxLength: 128)
  "Router platform type"
  platform: RouterPlatform
}

"""
Input for updating router settings
"""
input UpdateRouterInput {
  "Updated display name"
  name: String @validate(minLength: 1, maxLength: 64)
  "Updated hostname or IP address"
  host: String @validate(minLength: 1, maxLength: 255)
  "Updated connection port"
  port: Int @validate(min: 1, max: 65535)
  "Updated username"
  username: String @validate(minLength: 1, maxLength: 64)
  "Updated password"
  password: String @validate(minLength: 1, maxLength: 128)
}

# -----------------------------------------------------------------------------
# Interface Types (Network Interfaces)
# -----------------------------------------------------------------------------

"""
A network interface on a router
"""
type Interface implements Node {
  "Unique interface identifier"
  id: ID!
  "Interface name (e.g., ether1, wlan1)"
  name: String! @mikrotik(path: "/interface", field: "name")
  "Interface type"
  type: InterfaceType! @mikrotik(path: "/interface", field: "type")
  "Whether the interface is enabled"
  enabled: Boolean! @mikrotik(path: "/interface", field: "disabled")
  "Whether the interface is running (link up)"
  running: Boolean! @mikrotik(path: "/interface", field: "running")
  "MAC address"
  macAddress: MAC @mikrotik(path: "/interface", field: "mac-address")
  "MTU setting"
  mtu: Int @mikrotik(path: "/interface", field: "mtu")
  "User comment"
  comment: String @mikrotik(path: "/interface", field: "comment")
  "TX bytes"
  txBytes: Size @mikrotik(path: "/interface", field: "tx-byte")
  "RX bytes"
  rxBytes: Size @mikrotik(path: "/interface", field: "rx-byte")
}

"""
Types of network interfaces
"""
enum InterfaceType {
  ETHERNET
  VLAN
  BRIDGE
  WIRELESS
  TUNNEL
  PPP
  BONDING
  LOOPBACK
  VIRTUAL
  OTHER
}

# -----------------------------------------------------------------------------
# Query Root
# -----------------------------------------------------------------------------

type Query {
  "Fetch any node by its global ID"
  node(id: ID!): Node

  "Get system health status"
  health: HealthStatus!

  "Get current API version"
  version: String!

  # Router Queries
  "Get a router by ID"
  router(id: ID!): Router
  "List all managed routers"
  routers(
    "Filter by connection status"
    status: ConnectionStatus
    "Pagination parameters"
    pagination: PaginationInput
  ): RouterConnection!

  # Interface Queries (require active router connection)
  "Get a network interface by ID"
  interface(
    "Router to query"
    routerId: ID!
    "Interface ID"
    id: ID!
  ): Interface @capability(requires: ["interface"])

  "List interfaces on a router"
  interfaces(
    "Router to query"
    routerId: ID!
    "Filter by interface type"
    type: InterfaceType
    "Pagination parameters"
    pagination: PaginationInput
  ): InterfaceConnection! @capability(requires: ["interface"])

  # Capability Queries
  "Get router capabilities by router ID"
  routerCapabilities(routerId: ID!): RouterCapabilities

  # Version Compatibility Queries
  "Check if a feature is supported on a specific router"
  isFeatureSupported(
    "Router to check"
    routerId: ID!
    "Feature identifier"
    featureId: String!
  ): FeatureSupport!

  "Get all features supported by a router"
  supportedFeatures(routerId: ID!): [FeatureSupport!]!

  "Get features not supported by a router with upgrade guidance"
  unsupportedFeatures(routerId: ID!): [FeatureSupport!]!

  "Get the compatibility matrix for all known features"
  compatibilityMatrix: [FeatureCompatibilityInfo!]!

  # Upgrade Recommendation Queries
  "Get upgrade recommendation for a specific feature on a router"
  upgradeRecommendation(
    "Router to check"
    routerId: ID!
    "Feature to enable"
    featureId: String!
  ): UpgradeRecommendation

  "Get all upgrade recommendations for a router"
  upgradeRecommendations(routerId: ID!): [UpgradeRecommendation!]!
}

"""
Information about a feature in the compatibility matrix
"""
type FeatureCompatibilityInfo {
  "Feature identifier"
  featureId: String!
  "Human-readable feature name"
  name: String!
  "Minimum RouterOS version required"
  minVersion: String!
  "Maximum RouterOS version supported (if any)"
  maxVersion: String
  "Minimum version for CHR (if different)"
  minVersionCHR: String
  "Required packages"
  requiredPackages: [String!]!
  "Feature dependencies"
  dependsOn: [String!]!
  "URL to MikroTik documentation"
  upgradeUrl: String
}

# -----------------------------------------------------------------------------
# Mutation Root
# -----------------------------------------------------------------------------

type Mutation {
  # Router Management
  "Add a new router to manage"
  createRouter(input: CreateRouterInput!): CreateRouterPayload!
  "Update router settings"
  updateRouter(id: ID!, input: UpdateRouterInput!): UpdateRouterPayload!
  "Remove a router"
  deleteRouter(id: ID!): DeleteRouterPayload!
  "Test connection to a router"
  testRouterConnection(id: ID!): TestConnectionPayload!
  "Connect to a router"
  connectRouter(id: ID!): ConnectRouterPayload!
  "Disconnect from a router"
  disconnectRouter(id: ID!): DisconnectRouterPayload!

  # Capability Management
  "Force refresh router capabilities (invalidates cache)"
  refreshCapabilities(routerId: ID!): RefreshCapabilitiesPayload!
}

# -----------------------------------------------------------------------------
# Subscription Root
# -----------------------------------------------------------------------------

type Subscription {
  "Subscribe to router status changes"
  routerStatusChanged(routerId: ID): RouterStatusEvent!

  "Subscribe to interface traffic updates"
  interfaceTraffic(
    routerId: ID!
    interfaceId: ID
  ): InterfaceTrafficEvent! @realtime(interval: 1000)

  "Subscribe to resource updates (create, update, delete)"
  resourceUpdated(resourceId: ID): ResourceUpdatedEvent!

  "Subscribe to configuration apply progress"
  configApplyProgress(operationId: ID!): ConfigProgress!
}

# -----------------------------------------------------------------------------
# Connection Types (Relay Pagination)
# -----------------------------------------------------------------------------

type RouterConnection implements Connection {
  edges: [RouterEdge!]!
  pageInfo: PageInfo!
  totalCount: Int
}

type RouterEdge implements Edge {
  node: Router!
  cursor: String!
}

type InterfaceConnection implements Connection {
  edges: [InterfaceEdge!]!
  pageInfo: PageInfo!
  totalCount: Int
}

type InterfaceEdge implements Edge {
  node: Interface!
  cursor: String!
}

# -----------------------------------------------------------------------------
# Mutation Payloads
# -----------------------------------------------------------------------------

"""
Standard error type for mutations
"""
type MutationError {
  "Error code for programmatic handling"
  code: String!
  "Human-readable error message"
  message: String!
  "Field that caused the error (if applicable)"
  field: String
}

"""
Rich error extensions for detailed error diagnostics.
Included in GraphQL error responses under the 'extensions' key.
"""
type ErrorExtensions {
  "Error code for programmatic handling (e.g., 'V400', 'R200')"
  code: String!
  "Error category (validation, protocol, network, auth, resource, internal)"
  category: String!
  "Field path that caused the error (e.g., 'input.listenPort')"
  field: String
  "The invalid value (redacted in production for sensitive fields)"
  value: JSON
  "User-friendly suggestion for fixing the error"
  suggestedFix: String
  "Link to relevant documentation"
  docsUrl: String
  "Request correlation ID for support and debugging"
  requestId: String!
  "Whether the error is recoverable (can be retried)"
  recoverable: Boolean!
  "Additional troubleshooting steps for complex errors"
  troubleshootingSteps: [String!]
}

type CreateRouterPayload {
  "The created router"
  router: Router
  "Errors that occurred during creation"
  errors: [MutationError!]
}

type UpdateRouterPayload {
  "The updated router"
  router: Router
  "Errors that occurred during update"
  errors: [MutationError!]
}

type DeleteRouterPayload {
  "Whether deletion was successful"
  success: Boolean!
  "ID of the deleted router"
  deletedRouterId: ID
  "Errors that occurred during deletion"
  errors: [MutationError!]
}

type TestConnectionPayload {
  "Whether the connection test succeeded"
  success: Boolean!
  "Response time in milliseconds"
  responseTimeMs: Int
  "Router version if connection succeeded"
  version: String
  "Error message if connection failed"
  error: String
}

type ConnectRouterPayload {
  "The router that was connected"
  router: Router
  "Errors that occurred during connection"
  errors: [MutationError!]
}

type DisconnectRouterPayload {
  "The router that was disconnected"
  router: Router
  "Errors that occurred during disconnection"
  errors: [MutationError!]
}

# -----------------------------------------------------------------------------
# Subscription Events
# -----------------------------------------------------------------------------

type RouterStatusEvent {
  "The router whose status changed"
  router: Router!
  "Previous status"
  previousStatus: ConnectionStatus!
  "New status"
  newStatus: ConnectionStatus!
  "Timestamp of the change"
  timestamp: DateTime!
}

type InterfaceTrafficEvent {
  "Interface ID"
  interfaceId: ID!
  "Interface name"
  interfaceName: String!
  "TX rate in bytes per second"
  txRate: Size!
  "RX rate in bytes per second"
  rxRate: Size!
  "Total TX bytes"
  txTotal: Size!
  "Total RX bytes"
  rxTotal: Size!
  "Timestamp"
  timestamp: DateTime!
}

"""
Event emitted when a router resource is updated
"""
type ResourceUpdatedEvent {
  "Unique resource identifier"
  resourceId: ID!
  "Type of resource (interface, firewall-rule, dhcp-lease, etc.)"
  resourceType: String!
  "Router this resource belongs to"
  routerId: ID!
  "New version number after update"
  version: Int!
  "Fields that were changed"
  changedFields: [String!]!
  "Type of change (create, update, delete)"
  changeType: ChangeType!
  "Timestamp of the update"
  timestamp: DateTime!
}

"""
Type of change for resource events
"""
enum ChangeType {
  CREATE
  UPDATE
  DELETE
}

"""
Progress information for configuration apply operations
"""
type ConfigProgress {
  "Unique operation identifier"
  operationId: ID!
  "Current status of the operation"
  status: ConfigApplyStatus!
  "Completion percentage (0-100)"
  percentage: Int!
  "Human-readable progress message"
  message: String!
  "Current step number"
  currentStep: Int
  "Total number of steps"
  totalSteps: Int
  "Timestamp of this progress update"
  timestamp: DateTime!
}

"""
Status of a configuration apply operation
"""
enum ConfigApplyStatus {
  PENDING
  VALIDATING
  APPLYING
  VERIFYING
  COMPLETED
  FAILED
  ROLLED_BACK
}

# -----------------------------------------------------------------------------
# Capability Types
# -----------------------------------------------------------------------------

"""
Feature capability categories detected on routers.
Used to determine what features are available on a specific router.
"""
enum Capability {
  "Container/Docker support"
  CONTAINER
  "Virtual Interface Factory support"
  VIF
  "Wireless/WiFi support"
  WIRELESS
  "Advanced routing features"
  ROUTING
  "Firewall features"
  FIREWALL
  "MPLS support"
  MPLS
  "IPv6 support"
  IPV6
  "Hotspot features"
  HOTSPOT
  "User Manager features"
  USER_MANAGER
  "Dude monitoring support"
  DUDE
  "WireGuard VPN support"
  WIREGUARD
  "ZeroTier support"
  ZEROTIER
}

"""
Capability support level for a feature.
Determines how the feature appears in the UI.
"""
enum CapabilityLevel {
  "Feature not supported (hide in UI)"
  NONE
  "Limited support (show with warnings)"
  BASIC
  "Full RouterOS native support"
  ADVANCED
  "Complete support including container-based features"
  FULL
}

"""
Single capability with its support level and guidance
"""
type CapabilityEntry {
  "Capability category"
  capability: Capability!
  "Support level"
  level: CapabilityLevel!
  "Human-readable description of support"
  description: String
  "Actionable message if feature unavailable"
  guidance: String
}

"""
Hardware information detected from router
"""
type HardwareInfo {
  "CPU architecture (arm, arm64, x86_64, etc.)"
  architecture: String!
  "Router model name"
  model: String
  "Board name"
  boardName: String
  "Total RAM in bytes"
  totalMemory: Size!
  "Available storage in bytes"
  availableStorage: Size!
  "Number of CPU cores"
  cpuCount: Int!
  "Whether wireless hardware is present"
  hasWirelessChip: Boolean!
  "Whether LTE/cellular hardware is present"
  hasLTEModule: Boolean!
}

"""
Software information detected from router
"""
type SoftwareInfo {
  "RouterOS version string"
  version: String!
  "Parsed major version number"
  versionMajor: Int!
  "Parsed minor version number"
  versionMinor: Int!
  "Parsed patch version number"
  versionPatch: Int
  "List of installed packages"
  installedPackages: [String!]!
  "License level (0-6)"
  licenseLevel: Int!
  "Update channel (stable, testing, development)"
  updateChannel: String
}

"""
Container-specific capability information
"""
type ContainerInfo {
  "Whether container package is installed"
  packageInstalled: Boolean!
  "Whether container feature is enabled in system settings"
  enabled: Boolean!
  "Whether a container registry is configured"
  registryConfigured: Boolean!
  "Available storage for container images in bytes"
  storageAvailable: Size!
  "Whether network namespace is supported"
  supportsNetworkNamespace: Boolean!
  "Maximum number of containers supported"
  maxContainers: Int
}

"""
VIF (Virtual Interface Factory) requirements check result
"""
type VIFRequirements {
  "Whether all VIF requirements are satisfied"
  met: Boolean!
  "Whether RouterOS version is sufficient (7.13+)"
  routerOSVersion: Boolean!
  "Whether container package is installed"
  containerPackage: Boolean!
  "Whether container feature is enabled"
  containerEnabled: Boolean!
  "Whether there's sufficient storage (>100MB)"
  sufficientStorage: Boolean!
  "Whether network namespace is supported"
  networkNamespace: Boolean!
  "Human-readable reasons why VIF is not available"
  missingReasons: [String!]!
  "Step-by-step guidance for enabling VIF"
  guidanceSteps: [VIFGuidanceStep!]!
}

"""
Single step in VIF enablement guidance
"""
type VIFGuidanceStep {
  "Step number (1-based)"
  step: Int!
  "Short title for the step"
  title: String!
  "Detailed instruction"
  description: String!
  "Whether this requirement is already met"
  completed: Boolean!
  "RouterOS command to execute (if applicable)"
  routerCommand: String
}

"""
Complete router capabilities detected from system inspection
"""
type RouterCapabilities {
  "Hardware information"
  hardware: HardwareInfo!
  "Software information"
  software: SoftwareInfo!
  "Container-specific capabilities"
  container: ContainerInfo!
  "Capability entries with support levels"
  capabilities: [CapabilityEntry!]!
  "VIF requirements check"
  vifRequirements: VIFRequirements!
  "Features supported by this router's version and configuration"
  supportedFeatures: [FeatureSupport!]!
  "Features not supported by this router (with upgrade guidance)"
  unsupportedFeatures: [FeatureSupport!]!
  "Parsed RouterOS version with comparison helpers"
  routerOSVersion: RouterOSVersion!
  "When capabilities were detected"
  detectedAt: DateTime!
  "When cache expires (24h TTL)"
  expiresAt: DateTime!
  "Whether cache is stale and refresh is in progress"
  isRefreshing: Boolean!
}

"""
Parsed RouterOS version with semantic versioning
"""
type RouterOSVersion {
  "Full version string (e.g., '7.13.2')"
  raw: String!
  "Major version number"
  major: Int!
  "Minor version number"
  minor: Int!
  "Patch version number"
  patch: Int!
  "Version channel (stable, beta, rc, long-term)"
  channel: String
  "Whether this is a Cloud Hosted Router (CHR)"
  isCHR: Boolean!
  "Check if this version supports a specific feature"
  supportsFeature(featureId: String!): Boolean!
  "Check if version is at least the given version (e.g., '7.1')"
  isAtLeast(version: String!): Boolean!
}

"""
Feature support information based on RouterOS version
"""
type FeatureSupport {
  "Feature identifier (e.g., 'rest_api', 'container', 'wireguard')"
  featureId: String!
  "Human-readable feature name"
  name: String!
  "Whether the feature is supported on this router"
  supported: Boolean!
  "Capability level (none, basic, advanced, full)"
  level: CapabilityLevel!
  "Reason why the feature is not supported (if applicable)"
  reason: String
  "Minimum RouterOS version required for this feature"
  requiredVersion: String
  "URL to MikroTik documentation for upgrade guidance"
  upgradeUrl: String
  "Required packages that need to be installed"
  requiredPackages: [String!]
  "Missing packages (if any)"
  missingPackages: [String!]
}

"""
Input for checking feature compatibility
"""
input FeatureCompatibilityInput {
  "Feature identifier to check"
  featureId: String!
  "Whether to check for CHR-specific requirements"
  isCHR: Boolean
}

"""
Upgrade recommendation for enabling a feature
"""
type UpgradeRecommendation {
  "Feature that requires upgrade"
  featureId: String!
  "Human-readable feature name"
  featureName: String!
  "Current RouterOS version"
  currentVersion: String!
  "Minimum required version for this feature"
  requiredVersion: String!
  "Whether this is a major version upgrade (e.g., 6.x to 7.x)"
  isMajorUpgrade: Boolean!
  "Priority level (critical, high, medium, low)"
  priority: UpgradePriority!
  "Steps to complete the upgrade"
  steps: [UpgradeStep!]!
  "Estimated impact on router operation"
  impact: UpgradeImpact!
  "URL to MikroTik upgrade documentation"
  documentationUrl: String
  "Warnings or important notes about this upgrade"
  warnings: [String!]!
}

"""
Priority level for upgrade recommendations
"""
enum UpgradePriority {
  "Security-related, should upgrade immediately"
  CRITICAL
  "Highly recommended for stability/features"
  HIGH
  "Recommended but not urgent"
  MEDIUM
  "Nice to have, optional"
  LOW
}

"""
Impact assessment for an upgrade
"""
type UpgradeImpact {
  "Whether reboot is required"
  requiresReboot: Boolean!
  "Estimated downtime description"
  estimatedDowntime: String
  "Whether configuration backup is recommended before upgrade"
  backupRecommended: Boolean!
  "Potential breaking changes to be aware of"
  breakingChanges: [String!]!
}

"""
Single step in an upgrade process
"""
type UpgradeStep {
  "Step number (1-based)"
  step: Int!
  "Step title"
  title: String!
  "Detailed instructions"
  description: String!
  "RouterOS command to execute (if applicable)"
  command: String
  "Whether this step is optional"
  optional: Boolean!
}

"""
Payload for refreshCapabilities mutation
"""
type RefreshCapabilitiesPayload {
  "Updated capabilities after refresh"
  capabilities: RouterCapabilities
  "Errors during refresh"
  errors: [MutationError!]
}
`, BuiltIn: false},
}
var parsedSchema = gqlparser.MustLoadSchema(sources...)

// endregion ************************** generated!.gotpl **************************

// region    ***************************** args.gotpl *****************************

func (ec *executionContext) dir_auth_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["requires"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("requires"))
		arg0, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["requires"] = arg0
	return args, nil
}

func (ec *executionContext) dir_capability_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []string
	if tmp, ok := rawArgs["requires"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("requires"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["requires"] = arg0
	return args, nil
}

func (ec *executionContext) dir_validate_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *int
	if tmp, ok := rawArgs["min"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("min"))
		arg0, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["min"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["max"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("max"))
		arg1, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["max"] = arg1
	var arg2 *int
	if tmp, ok := rawArgs["minLength"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("minLength"))
		arg2, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["minLength"] = arg2
	var arg3 *int
	if tmp, ok := rawArgs["maxLength"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("maxLength"))
		arg3, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["maxLength"] = arg3
	var arg4 *string
	if tmp, ok := rawArgs["pattern"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pattern"))
		arg4, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["pattern"] = arg4
	var arg5 *model.ValidateFormat
	if tmp, ok := rawArgs["format"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("format"))
		arg5, err = ec.unmarshalOValidateFormat2backendgraphmodelValidateFormat(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["format"] = arg5
	return args, nil
}

func (ec *executionContext) field_Mutation_addRouter_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.AddRouterInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNAddRouterInput2backendgraphmodelAddRouterInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_cancelScan_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["taskId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("taskId"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["taskId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_changePassword_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["currentPassword"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("currentPassword"))
		directive0 := func(ctx context.Context) (interface{}, error) { return ec.unmarshalNString2string(ctx, tmp) }
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Sensitive == nil {
				return nil, errors.New("directive sensitive is not implemented")
			}
			return ec.directives.Sensitive(ctx, rawArgs, directive0)
		}

		tmp, err = directive1(ctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if data, ok := tmp.(string); ok {
			arg0 = data
		} else {
			return nil, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp))
		}
	}
	args["currentPassword"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["newPassword"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("newPassword"))
		directive0 := func(ctx context.Context) (interface{}, error) { return ec.unmarshalNString2string(ctx, tmp) }
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Sensitive == nil {
				return nil, errors.New("directive sensitive is not implemented")
			}
			return ec.directives.Sensitive(ctx, rawArgs, directive0)
		}

		tmp, err = directive1(ctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if data, ok := tmp.(string); ok {
			arg1 = data
		} else {
			return nil, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp))
		}
	}
	args["newPassword"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_checkRouterHealth_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["routerId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("routerId"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["routerId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_connectRouter_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_createRouter_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.CreateRouterInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNCreateRouterInput2backendgraphmodelCreateRouterInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_deleteRouter_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_disconnectRouter_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_exportRouterConfig_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.ExportConfigInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNExportConfigInput2backendgraphmodelExportConfigInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_login_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["username"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("username"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["username"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["password"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("password"))
		directive0 := func(ctx context.Context) (interface{}, error) { return ec.unmarshalNString2string(ctx, tmp) }
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Sensitive == nil {
				return nil, errors.New("directive sensitive is not implemented")
			}
			return ec.directives.Sensitive(ctx, rawArgs, directive0)
		}

		tmp, err = directive1(ctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if data, ok := tmp.(string); ok {
			arg1 = data
		} else {
			return nil, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp))
		}
	}
	args["password"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_reconnectRouter_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["routerId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("routerId"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["routerId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_refreshCapabilities_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["routerId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("routerId"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["routerId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_resetCircuitBreaker_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["routerId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("routerId"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["routerId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_revokeAllSessions_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["userId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userId"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["userId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_revokeSession_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["sessionId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sessionId"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["sessionId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_runDiagnostics_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["routerId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("routerId"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["routerId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_scanNetwork_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.ScanNetworkInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNScanNetworkInput2backendgraphmodelScanNetworkInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_setPreferredProtocol_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["routerId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("routerId"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["routerId"] = arg0
	var arg1 model.Protocol
	if tmp, ok := rawArgs["protocol"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("protocol"))
		arg1, err = ec.unmarshalNProtocol2backendgraphmodelProtocol(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["protocol"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_testRouterConnection_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_testRouterCredentials_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.AddRouterInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNAddRouterInput2backendgraphmodelAddRouterInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_updateRouterCredentials_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["routerId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("routerId"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["routerId"] = arg0
	var arg1 model.CredentialsInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg1, err = ec.unmarshalNCredentialsInput2backendgraphmodelCredentialsInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_updateRouter_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	var arg1 model.UpdateRouterInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg1, err = ec.unmarshalNUpdateRouterInput2backendgraphmodelUpdateRouterInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query___type_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_circuitBreakerStatus_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["routerId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("routerId"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["routerId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_connectionAttempts_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["routerId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("routerId"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["routerId"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["limit"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("limit"))
		arg1, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query_connectionDetails_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["routerId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("routerId"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["routerId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_interface_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["routerId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("routerId"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["routerId"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg1, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query_interfaces_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["routerId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("routerId"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["routerId"] = arg0
	var arg1 *model.InterfaceType
	if tmp, ok := rawArgs["type"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("type"))
		arg1, err = ec.unmarshalOInterfaceType2backendgraphmodelInterfaceType(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["type"] = arg1
	var arg2 *model.PaginationInput
	if tmp, ok := rawArgs["pagination"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pagination"))
		arg2, err = ec.unmarshalOPaginationInput2backendgraphmodelPaginationInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["pagination"] = arg2
	return args, nil
}

func (ec *executionContext) field_Query_isFeatureSupported_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["routerId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("routerId"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["routerId"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["featureId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("featureId"))
		arg1, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["featureId"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query_node_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_routerCapabilities_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["routerId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("routerId"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["routerId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_routerCredentials_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["routerId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("routerId"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["routerId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_routerHealth_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["routerId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("routerId"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["routerId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_router_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_routers_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *model.ConnectionStatus
	if tmp, ok := rawArgs["status"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("status"))
		arg0, err = ec.unmarshalOConnectionStatus2backendgraphmodelConnectionStatus(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["status"] = arg0
	var arg1 *model.PaginationInput
	if tmp, ok := rawArgs["pagination"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pagination"))
		arg1, err = ec.unmarshalOPaginationInput2backendgraphmodelPaginationInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["pagination"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query_scanHistory_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *int
	if tmp, ok := rawArgs["limit"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("limit"))
		arg0, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_scanStatus_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["taskId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("taskId"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["taskId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_supportedFeatures_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["routerId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("routerId"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["routerId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_unsupportedFeatures_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["routerId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("routerId"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["routerId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_upgradeRecommendation_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["routerId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("routerId"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["routerId"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["featureId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("featureId"))
		arg1, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["featureId"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query_upgradeRecommendations_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["routerId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("routerId"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["routerId"] = arg0
	return args, nil
}

func (ec *executionContext) field_RouterOSVersion_isAtLeast_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["version"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("version"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["version"] = arg0
	return args, nil
}

func (ec *executionContext) field_RouterOSVersion_supportsFeature_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["featureId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("featureId"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["featureId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Subscription_circuitBreakerChanged_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["routerId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("routerId"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["routerId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Subscription_circuitBreakerStateChanged_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["routerId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("routerId"))
		arg0, err = ec.unmarshalOID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["routerId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Subscription_configApplyProgress_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["operationId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("operationId"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["operationId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Subscription_connectionHealth_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["routerId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("routerId"))
		arg0, err = ec.unmarshalOID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["routerId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Subscription_interfaceTraffic_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["routerId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("routerId"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["routerId"] = arg0
	var arg1 *string
	if tmp, ok := rawArgs["interfaceId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("interfaceId"))
		arg1, err = ec.unmarshalOID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["interfaceId"] = arg1
	return args, nil
}

func (ec *executionContext) field_Subscription_resourceUpdated_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["resourceId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("resourceId"))
		arg0, err = ec.unmarshalOID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["resourceId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Subscription_routerStatusChanged_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["routerId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("routerId"))
		arg0, err = ec.unmarshalOID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["routerId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Subscription_scanProgress_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["taskId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("taskId"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["taskId"] = arg0
	return args, nil
}

func (ec *executionContext) field___Type_enumValues_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 bool
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("includeDeprecated"))
		arg0, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["includeDeprecated"] = arg0
	return args, nil
}

func (ec *executionContext) field___Type_fields_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 bool
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("includeDeprecated"))
		arg0, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["includeDeprecated"] = arg0
	return args, nil
}

// endregion ***************************** args.gotpl *****************************

// region    ************************** directives.gotpl **************************

// endregion ************************** directives.gotpl **************************

// region    **************************** field.gotpl *****************************

func (ec *executionContext) _AddRouterPayload_router(ctx context.Context, field graphql.CollectedField, obj *model.AddRouterPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AddRouterPayload_router(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Router, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Router)
	fc.Result = res
	return ec.marshalORouter2backendgraphmodelRouter(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AddRouterPayload_router(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AddRouterPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Router_id(ctx, field)
			case "name":
				return ec.fieldContext_Router_name(ctx, field)
			case "host":
				return ec.fieldContext_Router_host(ctx, field)
			case "port":
				return ec.fieldContext_Router_port(ctx, field)
			case "status":
				return ec.fieldContext_Router_status(ctx, field)
			case "platform":
				return ec.fieldContext_Router_platform(ctx, field)
			case "version":
				return ec.fieldContext_Router_version(ctx, field)
			case "model":
				return ec.fieldContext_Router_model(ctx, field)
			case "uptime":
				return ec.fieldContext_Router_uptime(ctx, field)
			case "lastConnected":
				return ec.fieldContext_Router_lastConnected(ctx, field)
			case "createdAt":
				return ec.fieldContext_Router_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Router_updatedAt(ctx, field)
			case "capabilities":
				return ec.fieldContext_Router_capabilities(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Router", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _AddRouterPayload_connectionResult(ctx context.Context, field graphql.CollectedField, obj *model.AddRouterPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AddRouterPayload_connectionResult(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ConnectionResult, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.ConnectionTestResult)
	fc.Result = res
	return ec.marshalOConnectionTestResult2backendgraphmodelConnectionTestResult(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AddRouterPayload_connectionResult(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AddRouterPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "success":
				return ec.fieldContext_ConnectionTestResult_success(ctx, field)
			case "protocolUsed":
				return ec.fieldContext_ConnectionTestResult_protocolUsed(ctx, field)
			case "responseTimeMs":
				return ec.fieldContext_ConnectionTestResult_responseTimeMs(ctx, field)
			case "routerVersion":
				return ec.fieldContext_ConnectionTestResult_routerVersion(ctx, field)
			case "routerModel":
				return ec.fieldContext_ConnectionTestResult_routerModel(ctx, field)
			case "boardName":
				return ec.fieldContext_ConnectionTestResult_boardName(ctx, field)
			case "uptime":
				return ec.fieldContext_ConnectionTestResult_uptime(ctx, field)
			case "protocolsAttempted":
				return ec.fieldContext_ConnectionTestResult_protocolsAttempted(ctx, field)
			case "supportsContainers":
				return ec.fieldContext_ConnectionTestResult_supportsContainers(ctx, field)
			case "architecture":
				return ec.fieldContext_ConnectionTestResult_architecture(ctx, field)
			case "error":
				return ec.fieldContext_ConnectionTestResult_error(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ConnectionTestResult", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _AddRouterPayload_validationErrors(ctx context.Context, field graphql.CollectedField, obj *model.AddRouterPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AddRouterPayload_validationErrors(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ValidationErrors, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.ValidationError)
	fc.Result = res
	return ec.marshalOValidationError2backendgraphmodelValidationError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AddRouterPayload_validationErrors(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AddRouterPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "field":
				return ec.fieldContext_ValidationError_field(ctx, field)
			case "code":
				return ec.fieldContext_ValidationError_code(ctx, field)
			case "message":
				return ec.fieldContext_ValidationError_message(ctx, field)
			case "suggestion":
				return ec.fieldContext_ValidationError_suggestion(ctx, field)
			case "providedValue":
				return ec.fieldContext_ValidationError_providedValue(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ValidationError", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _AddRouterPayload_errors(ctx context.Context, field graphql.CollectedField, obj *model.AddRouterPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AddRouterPayload_errors(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Errors, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.MutationError)
	fc.Result = res
	return ec.marshalOMutationError2backendgraphmodelMutationError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AddRouterPayload_errors(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AddRouterPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "code":
				return ec.fieldContext_MutationError_code(ctx, field)
			case "message":
				return ec.fieldContext_MutationError_message(ctx, field)
			case "field":
				return ec.fieldContext_MutationError_field(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MutationError", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _AuthPayload_token(ctx context.Context, field graphql.CollectedField, obj *model.AuthPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AuthPayload_token(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Token, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AuthPayload_token(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AuthPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AuthPayload_user(ctx context.Context, field graphql.CollectedField, obj *model.AuthPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AuthPayload_user(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.User, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.User)
	fc.Result = res
	return ec.marshalNUser2backendgraphmodelUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AuthPayload_user(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AuthPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "username":
				return ec.fieldContext_User_username(ctx, field)
			case "role":
				return ec.fieldContext_User_role(ctx, field)
			case "email":
				return ec.fieldContext_User_email(ctx, field)
			case "displayName":
				return ec.fieldContext_User_displayName(ctx, field)
			case "createdAt":
				return ec.fieldContext_User_createdAt(ctx, field)
			case "lastLoginAt":
				return ec.fieldContext_User_lastLoginAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _AuthPayload_expiresAt(ctx context.Context, field graphql.CollectedField, obj *model.AuthPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AuthPayload_expiresAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ExpiresAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNDateTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AuthPayload_expiresAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AuthPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DateTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AuthStatus_tested(ctx context.Context, field graphql.CollectedField, obj *model.AuthStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AuthStatus_tested(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Tested, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AuthStatus_tested(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AuthStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AuthStatus_success(ctx context.Context, field graphql.CollectedField, obj *model.AuthStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AuthStatus_success(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Success, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AuthStatus_success(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AuthStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AuthStatus_error(ctx context.Context, field graphql.CollectedField, obj *model.AuthStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AuthStatus_error(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Error, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AuthStatus_error(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AuthStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AuthStatus_errorCode(ctx context.Context, field graphql.CollectedField, obj *model.AuthStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AuthStatus_errorCode(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ErrorCode, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AuthStatus_errorCode(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AuthStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CancelScanPayload_task(ctx context.Context, field graphql.CollectedField, obj *model.CancelScanPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CancelScanPayload_task(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Task, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.ScanTask)
	fc.Result = res
	return ec.marshalOScanTask2backendgraphmodelScanTask(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CancelScanPayload_task(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CancelScanPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ScanTask_id(ctx, field)
			case "subnet":
				return ec.fieldContext_ScanTask_subnet(ctx, field)
			case "status":
				return ec.fieldContext_ScanTask_status(ctx, field)
			case "progress":
				return ec.fieldContext_ScanTask_progress(ctx, field)
			case "results":
				return ec.fieldContext_ScanTask_results(ctx, field)
			case "startTime":
				return ec.fieldContext_ScanTask_startTime(ctx, field)
			case "endTime":
				return ec.fieldContext_ScanTask_endTime(ctx, field)
			case "error":
				return ec.fieldContext_ScanTask_error(ctx, field)
			case "totalIPs":
				return ec.fieldContext_ScanTask_totalIPs(ctx, field)
			case "scannedIPs":
				return ec.fieldContext_ScanTask_scannedIPs(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ScanTask", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CancelScanPayload_errors(ctx context.Context, field graphql.CollectedField, obj *model.CancelScanPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CancelScanPayload_errors(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Errors, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.MutationError)
	fc.Result = res
	return ec.marshalOMutationError2backendgraphmodelMutationError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CancelScanPayload_errors(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CancelScanPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "code":
				return ec.fieldContext_MutationError_code(ctx, field)
			case "message":
				return ec.fieldContext_MutationError_message(ctx, field)
			case "field":
				return ec.fieldContext_MutationError_field(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MutationError", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CapabilityEntry_capability(ctx context.Context, field graphql.CollectedField, obj *model.CapabilityEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CapabilityEntry_capability(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Capability, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.Capability)
	fc.Result = res
	return ec.marshalNCapability2backendgraphmodelCapability(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CapabilityEntry_capability(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CapabilityEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Capability does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CapabilityEntry_level(ctx context.Context, field graphql.CollectedField, obj *model.CapabilityEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CapabilityEntry_level(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Level, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.CapabilityLevel)
	fc.Result = res
	return ec.marshalNCapabilityLevel2backendgraphmodelCapabilityLevel(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CapabilityEntry_level(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CapabilityEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type CapabilityLevel does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CapabilityEntry_description(ctx context.Context, field graphql.CollectedField, obj *model.CapabilityEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CapabilityEntry_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CapabilityEntry_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CapabilityEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CapabilityEntry_guidance(ctx context.Context, field graphql.CollectedField, obj *model.CapabilityEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CapabilityEntry_guidance(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Guidance, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CapabilityEntry_guidance(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CapabilityEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CircuitBreakerEvent_routerId(ctx context.Context, field graphql.CollectedField, obj *model.CircuitBreakerEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CircuitBreakerEvent_routerId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RouterID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CircuitBreakerEvent_routerId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CircuitBreakerEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CircuitBreakerEvent_previousState(ctx context.Context, field graphql.CollectedField, obj *model.CircuitBreakerEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CircuitBreakerEvent_previousState(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PreviousState, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.CircuitBreakerState)
	fc.Result = res
	return ec.marshalNCircuitBreakerState2backendgraphmodelCircuitBreakerState(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CircuitBreakerEvent_previousState(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CircuitBreakerEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type CircuitBreakerState does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CircuitBreakerEvent_newState(ctx context.Context, field graphql.CollectedField, obj *model.CircuitBreakerEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CircuitBreakerEvent_newState(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NewState, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.CircuitBreakerState)
	fc.Result = res
	return ec.marshalNCircuitBreakerState2backendgraphmodelCircuitBreakerState(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CircuitBreakerEvent_newState(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CircuitBreakerEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type CircuitBreakerState does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CircuitBreakerEvent_consecutiveFailures(ctx context.Context, field graphql.CollectedField, obj *model.CircuitBreakerEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CircuitBreakerEvent_consecutiveFailures(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ConsecutiveFailures, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CircuitBreakerEvent_consecutiveFailures(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CircuitBreakerEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CircuitBreakerEvent_timestamp(ctx context.Context, field graphql.CollectedField, obj *model.CircuitBreakerEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CircuitBreakerEvent_timestamp(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Timestamp, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNDateTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CircuitBreakerEvent_timestamp(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CircuitBreakerEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DateTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CircuitBreakerStatus_routerId(ctx context.Context, field graphql.CollectedField, obj *model.CircuitBreakerStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CircuitBreakerStatus_routerId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RouterID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CircuitBreakerStatus_routerId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CircuitBreakerStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CircuitBreakerStatus_state(ctx context.Context, field graphql.CollectedField, obj *model.CircuitBreakerStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CircuitBreakerStatus_state(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.State, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.CircuitBreakerState)
	fc.Result = res
	return ec.marshalNCircuitBreakerState2backendgraphmodelCircuitBreakerState(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CircuitBreakerStatus_state(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CircuitBreakerStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type CircuitBreakerState does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CircuitBreakerStatus_failureCount(ctx context.Context, field graphql.CollectedField, obj *model.CircuitBreakerStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CircuitBreakerStatus_failureCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FailureCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CircuitBreakerStatus_failureCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CircuitBreakerStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CircuitBreakerStatus_failureThreshold(ctx context.Context, field graphql.CollectedField, obj *model.CircuitBreakerStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CircuitBreakerStatus_failureThreshold(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FailureThreshold, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CircuitBreakerStatus_failureThreshold(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CircuitBreakerStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CircuitBreakerStatus_cooldownRemainingSeconds(ctx context.Context, field graphql.CollectedField, obj *model.CircuitBreakerStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CircuitBreakerStatus_cooldownRemainingSeconds(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CooldownRemainingSeconds, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CircuitBreakerStatus_cooldownRemainingSeconds(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CircuitBreakerStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CircuitBreakerStatus_lastFailureAt(ctx context.Context, field graphql.CollectedField, obj *model.CircuitBreakerStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CircuitBreakerStatus_lastFailureAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LastFailureAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalODateTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CircuitBreakerStatus_lastFailureAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CircuitBreakerStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DateTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CircuitBreakerStatus_lastSuccessAt(ctx context.Context, field graphql.CollectedField, obj *model.CircuitBreakerStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CircuitBreakerStatus_lastSuccessAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LastSuccessAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalODateTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CircuitBreakerStatus_lastSuccessAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CircuitBreakerStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DateTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ConfigProgress_operationId(ctx context.Context, field graphql.CollectedField, obj *model.ConfigProgress) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ConfigProgress_operationId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OperationID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ConfigProgress_operationId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ConfigProgress",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ConfigProgress_status(ctx context.Context, field graphql.CollectedField, obj *model.ConfigProgress) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ConfigProgress_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.ConfigApplyStatus)
	fc.Result = res
	return ec.marshalNConfigApplyStatus2backendgraphmodelConfigApplyStatus(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ConfigProgress_status(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ConfigProgress",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ConfigApplyStatus does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ConfigProgress_percentage(ctx context.Context, field graphql.CollectedField, obj *model.ConfigProgress) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ConfigProgress_percentage(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Percentage, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ConfigProgress_percentage(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ConfigProgress",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ConfigProgress_message(ctx context.Context, field graphql.CollectedField, obj *model.ConfigProgress) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ConfigProgress_message(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ConfigProgress_message(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ConfigProgress",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ConfigProgress_currentStep(ctx context.Context, field graphql.CollectedField, obj *model.ConfigProgress) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ConfigProgress_currentStep(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CurrentStep, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ConfigProgress_currentStep(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ConfigProgress",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ConfigProgress_totalSteps(ctx context.Context, field graphql.CollectedField, obj *model.ConfigProgress) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ConfigProgress_totalSteps(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalSteps, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ConfigProgress_totalSteps(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ConfigProgress",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ConfigProgress_timestamp(ctx context.Context, field graphql.CollectedField, obj *model.ConfigProgress) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ConfigProgress_timestamp(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Timestamp, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNDateTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ConfigProgress_timestamp(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ConfigProgress",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DateTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ConnectRouterPayload_router(ctx context.Context, field graphql.CollectedField, obj *model.ConnectRouterPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ConnectRouterPayload_router(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Router, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Router)
	fc.Result = res
	return ec.marshalORouter2backendgraphmodelRouter(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ConnectRouterPayload_router(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ConnectRouterPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Router_id(ctx, field)
			case "name":
				return ec.fieldContext_Router_name(ctx, field)
			case "host":
				return ec.fieldContext_Router_host(ctx, field)
			case "port":
				return ec.fieldContext_Router_port(ctx, field)
			case "status":
				return ec.fieldContext_Router_status(ctx, field)
			case "platform":
				return ec.fieldContext_Router_platform(ctx, field)
			case "version":
				return ec.fieldContext_Router_version(ctx, field)
			case "model":
				return ec.fieldContext_Router_model(ctx, field)
			case "uptime":
				return ec.fieldContext_Router_uptime(ctx, field)
			case "lastConnected":
				return ec.fieldContext_Router_lastConnected(ctx, field)
			case "createdAt":
				return ec.fieldContext_Router_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Router_updatedAt(ctx, field)
			case "capabilities":
				return ec.fieldContext_Router_capabilities(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Router", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ConnectRouterPayload_errors(ctx context.Context, field graphql.CollectedField, obj *model.ConnectRouterPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ConnectRouterPayload_errors(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Errors, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.MutationError)
	fc.Result = res
	return ec.marshalOMutationError2backendgraphmodelMutationError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ConnectRouterPayload_errors(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ConnectRouterPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "code":
				return ec.fieldContext_MutationError_code(ctx, field)
			case "message":
				return ec.fieldContext_MutationError_message(ctx, field)
			case "field":
				return ec.fieldContext_MutationError_field(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MutationError", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ConnectionAttempt_protocol(ctx context.Context, field graphql.CollectedField, obj *model.ConnectionAttempt) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ConnectionAttempt_protocol(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Protocol, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.Protocol)
	fc.Result = res
	return ec.marshalNProtocol2backendgraphmodelProtocol(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ConnectionAttempt_protocol(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ConnectionAttempt",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Protocol does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ConnectionAttempt_startedAt(ctx context.Context, field graphql.CollectedField, obj *model.ConnectionAttempt) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ConnectionAttempt_startedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StartedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNDateTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ConnectionAttempt_startedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ConnectionAttempt",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DateTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ConnectionAttempt_endedAt(ctx context.Context, field graphql.CollectedField, obj *model.ConnectionAttempt) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ConnectionAttempt_endedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EndedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNDateTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ConnectionAttempt_endedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ConnectionAttempt",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DateTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ConnectionAttempt_success(ctx context.Context, field graphql.CollectedField, obj *model.ConnectionAttempt) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ConnectionAttempt_success(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Success, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ConnectionAttempt_success(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ConnectionAttempt",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ConnectionAttempt_errorCode(ctx context.Context, field graphql.CollectedField, obj *model.ConnectionAttempt) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ConnectionAttempt_errorCode(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ErrorCode, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ConnectionAttempt_errorCode(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ConnectionAttempt",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ConnectionAttempt_errorMessage(ctx context.Context, field graphql.CollectedField, obj *model.ConnectionAttempt) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ConnectionAttempt_errorMessage(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ErrorMessage, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ConnectionAttempt_errorMessage(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ConnectionAttempt",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ConnectionAttempt_errorCategory(ctx context.Context, field graphql.CollectedField, obj *model.ConnectionAttempt) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ConnectionAttempt_errorCategory(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ErrorCategory, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.ErrorCategory)
	fc.Result = res
	return ec.marshalOErrorCategory2backendgraphmodelErrorCategory(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ConnectionAttempt_errorCategory(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ConnectionAttempt",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ErrorCategory does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ConnectionDetails_state(ctx context.Context, field graphql.CollectedField, obj *model.ConnectionDetails) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ConnectionDetails_state(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.State, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.ConnectionStatus)
	fc.Result = res
	return ec.marshalNConnectionStatus2backendgraphmodelConnectionStatus(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ConnectionDetails_state(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ConnectionDetails",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ConnectionStatus does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ConnectionDetails_protocol(ctx context.Context, field graphql.CollectedField, obj *model.ConnectionDetails) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ConnectionDetails_protocol(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Protocol, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Protocol)
	fc.Result = res
	return ec.marshalOProtocol2backendgraphmodelProtocol(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ConnectionDetails_protocol(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ConnectionDetails",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Protocol does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ConnectionDetails_preferredProtocol(ctx context.Context, field graphql.CollectedField, obj *model.ConnectionDetails) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ConnectionDetails_preferredProtocol(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PreferredProtocol, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Protocol)
	fc.Result = res
	return ec.marshalOProtocol2backendgraphmodelProtocol(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ConnectionDetails_preferredProtocol(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ConnectionDetails",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Protocol does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ConnectionDetails_connectedAt(ctx context.Context, field graphql.CollectedField, obj *model.ConnectionDetails) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ConnectionDetails_connectedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ConnectedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalODateTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ConnectionDetails_connectedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ConnectionDetails",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DateTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ConnectionDetails_uptime(ctx context.Context, field graphql.CollectedField, obj *model.ConnectionDetails) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ConnectionDetails_uptime(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Uptime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Duration)
	fc.Result = res
	return ec.marshalODuration2backendgraphmodelDuration(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ConnectionDetails_uptime(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ConnectionDetails",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Duration does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ConnectionDetails_disconnectedAt(ctx context.Context, field graphql.CollectedField, obj *model.ConnectionDetails) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ConnectionDetails_disconnectedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DisconnectedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalODateTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ConnectionDetails_disconnectedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ConnectionDetails",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DateTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ConnectionDetails_lastError(ctx context.Context, field graphql.CollectedField, obj *model.ConnectionDetails) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ConnectionDetails_lastError(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LastError, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ConnectionDetails_lastError(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ConnectionDetails",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ConnectionDetails_lastErrorTime(ctx context.Context, field graphql.CollectedField, obj *model.ConnectionDetails) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ConnectionDetails_lastErrorTime(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LastErrorTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalODateTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ConnectionDetails_lastErrorTime(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ConnectionDetails",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DateTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ConnectionDetails_disconnectReason(ctx context.Context, field graphql.CollectedField, obj *model.ConnectionDetails) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ConnectionDetails_disconnectReason(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DisconnectReason, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.DisconnectReason)
	fc.Result = res
	return ec.marshalODisconnectReason2backendgraphmodelDisconnectReason(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ConnectionDetails_disconnectReason(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ConnectionDetails",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DisconnectReason does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ConnectionDetails_reconnectAttempts(ctx context.Context, field graphql.CollectedField, obj *model.ConnectionDetails) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ConnectionDetails_reconnectAttempts(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ReconnectAttempts, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ConnectionDetails_reconnectAttempts(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ConnectionDetails",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ConnectionDetails_nextReconnectAt(ctx context.Context, field graphql.CollectedField, obj *model.ConnectionDetails) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ConnectionDetails_nextReconnectAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NextReconnectAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalODateTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ConnectionDetails_nextReconnectAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ConnectionDetails",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DateTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ConnectionDetails_circuitBreakerState(ctx context.Context, field graphql.CollectedField, obj *model.ConnectionDetails) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ConnectionDetails_circuitBreakerState(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CircuitBreakerState, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.CircuitBreakerState)
	fc.Result = res
	return ec.marshalNCircuitBreakerState2backendgraphmodelCircuitBreakerState(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ConnectionDetails_circuitBreakerState(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ConnectionDetails",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type CircuitBreakerState does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ConnectionDetails_version(ctx context.Context, field graphql.CollectedField, obj *model.ConnectionDetails) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ConnectionDetails_version(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Version, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ConnectionDetails_version(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ConnectionDetails",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ConnectionDetails_lastHealthCheck(ctx context.Context, field graphql.CollectedField, obj *model.ConnectionDetails) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ConnectionDetails_lastHealthCheck(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LastHealthCheck, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalODateTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ConnectionDetails_lastHealthCheck(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ConnectionDetails",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DateTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ConnectionDetails_healthChecksPassed(ctx context.Context, field graphql.CollectedField, obj *model.ConnectionDetails) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ConnectionDetails_healthChecksPassed(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HealthChecksPassed, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ConnectionDetails_healthChecksPassed(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ConnectionDetails",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ConnectionDetails_healthChecksFailed(ctx context.Context, field graphql.CollectedField, obj *model.ConnectionDetails) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ConnectionDetails_healthChecksFailed(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HealthChecksFailed, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ConnectionDetails_healthChecksFailed(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ConnectionDetails",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ConnectionDetails_securityWarning(ctx context.Context, field graphql.CollectedField, obj *model.ConnectionDetails) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ConnectionDetails_securityWarning(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SecurityWarning, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ConnectionDetails_securityWarning(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ConnectionDetails",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ConnectionDetails_upgradeRecommendation(ctx context.Context, field graphql.CollectedField, obj *model.ConnectionDetails) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ConnectionDetails_upgradeRecommendation(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpgradeRecommendation, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ConnectionDetails_upgradeRecommendation(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ConnectionDetails",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ConnectionDetails_isLegacyProtocol(ctx context.Context, field graphql.CollectedField, obj *model.ConnectionDetails) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ConnectionDetails_isLegacyProtocol(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsLegacyProtocol, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ConnectionDetails_isLegacyProtocol(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ConnectionDetails",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ConnectionError_code(ctx context.Context, field graphql.CollectedField, obj *model.ConnectionError) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ConnectionError_code(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Code, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.ConnectionErrorCode)
	fc.Result = res
	return ec.marshalNConnectionErrorCode2backendgraphmodelConnectionErrorCode(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ConnectionError_code(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ConnectionError",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ConnectionErrorCode does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ConnectionError_message(ctx context.Context, field graphql.CollectedField, obj *model.ConnectionError) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ConnectionError_message(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ConnectionError_message(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ConnectionError",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ConnectionError_protocol(ctx context.Context, field graphql.CollectedField, obj *model.ConnectionError) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ConnectionError_protocol(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Protocol, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Protocol)
	fc.Result = res
	return ec.marshalOProtocol2backendgraphmodelProtocol(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ConnectionError_protocol(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ConnectionError",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Protocol does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ConnectionError_retryable(ctx context.Context, field graphql.CollectedField, obj *model.ConnectionError) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ConnectionError_retryable(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Retryable, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ConnectionError_retryable(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ConnectionError",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ConnectionError_suggestedAction(ctx context.Context, field graphql.CollectedField, obj *model.ConnectionError) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ConnectionError_suggestedAction(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SuggestedAction, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ConnectionError_suggestedAction(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ConnectionError",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ConnectionError_timeoutMs(ctx context.Context, field graphql.CollectedField, obj *model.ConnectionError) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ConnectionError_timeoutMs(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TimeoutMs, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ConnectionError_timeoutMs(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ConnectionError",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ConnectionStats_totalConnections(ctx context.Context, field graphql.CollectedField, obj *model.ConnectionStats) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ConnectionStats_totalConnections(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalConnections, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ConnectionStats_totalConnections(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ConnectionStats",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ConnectionStats_connected(ctx context.Context, field graphql.CollectedField, obj *model.ConnectionStats) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ConnectionStats_connected(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Connected, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ConnectionStats_connected(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ConnectionStats",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ConnectionStats_connecting(ctx context.Context, field graphql.CollectedField, obj *model.ConnectionStats) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ConnectionStats_connecting(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Connecting, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ConnectionStats_connecting(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ConnectionStats",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ConnectionStats_disconnected(ctx context.Context, field graphql.CollectedField, obj *model.ConnectionStats) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ConnectionStats_disconnected(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Disconnected, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ConnectionStats_disconnected(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ConnectionStats",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ConnectionStats_reconnecting(ctx context.Context, field graphql.CollectedField, obj *model.ConnectionStats) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ConnectionStats_reconnecting(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Reconnecting, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ConnectionStats_reconnecting(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ConnectionStats",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ConnectionStats_error(ctx context.Context, field graphql.CollectedField, obj *model.ConnectionStats) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ConnectionStats_error(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Error, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ConnectionStats_error(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ConnectionStats",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ConnectionTestResult_success(ctx context.Context, field graphql.CollectedField, obj *model.ConnectionTestResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ConnectionTestResult_success(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Success, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ConnectionTestResult_success(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ConnectionTestResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ConnectionTestResult_protocolUsed(ctx context.Context, field graphql.CollectedField, obj *model.ConnectionTestResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ConnectionTestResult_protocolUsed(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ProtocolUsed, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Protocol)
	fc.Result = res
	return ec.marshalOProtocol2backendgraphmodelProtocol(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ConnectionTestResult_protocolUsed(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ConnectionTestResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Protocol does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ConnectionTestResult_responseTimeMs(ctx context.Context, field graphql.CollectedField, obj *model.ConnectionTestResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ConnectionTestResult_responseTimeMs(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ResponseTimeMs, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ConnectionTestResult_responseTimeMs(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ConnectionTestResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ConnectionTestResult_routerVersion(ctx context.Context, field graphql.CollectedField, obj *model.ConnectionTestResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ConnectionTestResult_routerVersion(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RouterVersion, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ConnectionTestResult_routerVersion(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ConnectionTestResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ConnectionTestResult_routerModel(ctx context.Context, field graphql.CollectedField, obj *model.ConnectionTestResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ConnectionTestResult_routerModel(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RouterModel, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ConnectionTestResult_routerModel(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ConnectionTestResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ConnectionTestResult_boardName(ctx context.Context, field graphql.CollectedField, obj *model.ConnectionTestResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ConnectionTestResult_boardName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BoardName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ConnectionTestResult_boardName(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ConnectionTestResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ConnectionTestResult_uptime(ctx context.Context, field graphql.CollectedField, obj *model.ConnectionTestResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ConnectionTestResult_uptime(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Uptime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Duration)
	fc.Result = res
	return ec.marshalODuration2backendgraphmodelDuration(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ConnectionTestResult_uptime(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ConnectionTestResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Duration does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ConnectionTestResult_protocolsAttempted(ctx context.Context, field graphql.CollectedField, obj *model.ConnectionTestResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ConnectionTestResult_protocolsAttempted(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ProtocolsAttempted, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]model.Protocol)
	fc.Result = res
	return ec.marshalNProtocol2backendgraphmodelProtocol(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ConnectionTestResult_protocolsAttempted(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ConnectionTestResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Protocol does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ConnectionTestResult_supportsContainers(ctx context.Context, field graphql.CollectedField, obj *model.ConnectionTestResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ConnectionTestResult_supportsContainers(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SupportsContainers, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ConnectionTestResult_supportsContainers(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ConnectionTestResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ConnectionTestResult_architecture(ctx context.Context, field graphql.CollectedField, obj *model.ConnectionTestResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ConnectionTestResult_architecture(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Architecture, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ConnectionTestResult_architecture(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ConnectionTestResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ConnectionTestResult_error(ctx context.Context, field graphql.CollectedField, obj *model.ConnectionTestResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ConnectionTestResult_error(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Error, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.ConnectionError)
	fc.Result = res
	return ec.marshalOConnectionError2backendgraphmodelConnectionError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ConnectionTestResult_error(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ConnectionTestResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "code":
				return ec.fieldContext_ConnectionError_code(ctx, field)
			case "message":
				return ec.fieldContext_ConnectionError_message(ctx, field)
			case "protocol":
				return ec.fieldContext_ConnectionError_protocol(ctx, field)
			case "retryable":
				return ec.fieldContext_ConnectionError_retryable(ctx, field)
			case "suggestedAction":
				return ec.fieldContext_ConnectionError_suggestedAction(ctx, field)
			case "timeoutMs":
				return ec.fieldContext_ConnectionError_timeoutMs(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ConnectionError", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ContainerInfo_packageInstalled(ctx context.Context, field graphql.CollectedField, obj *model.ContainerInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ContainerInfo_packageInstalled(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PackageInstalled, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ContainerInfo_packageInstalled(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ContainerInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ContainerInfo_enabled(ctx context.Context, field graphql.CollectedField, obj *model.ContainerInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ContainerInfo_enabled(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Enabled, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ContainerInfo_enabled(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ContainerInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ContainerInfo_registryConfigured(ctx context.Context, field graphql.CollectedField, obj *model.ContainerInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ContainerInfo_registryConfigured(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RegistryConfigured, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ContainerInfo_registryConfigured(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ContainerInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ContainerInfo_storageAvailable(ctx context.Context, field graphql.CollectedField, obj *model.ContainerInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ContainerInfo_storageAvailable(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StorageAvailable, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.Size)
	fc.Result = res
	return ec.marshalNSize2backendgraphmodelSize(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ContainerInfo_storageAvailable(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ContainerInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Size does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ContainerInfo_supportsNetworkNamespace(ctx context.Context, field graphql.CollectedField, obj *model.ContainerInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ContainerInfo_supportsNetworkNamespace(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SupportsNetworkNamespace, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ContainerInfo_supportsNetworkNamespace(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ContainerInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ContainerInfo_maxContainers(ctx context.Context, field graphql.CollectedField, obj *model.ContainerInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ContainerInfo_maxContainers(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MaxContainers, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ContainerInfo_maxContainers(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ContainerInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CreateRouterPayload_router(ctx context.Context, field graphql.CollectedField, obj *model.CreateRouterPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CreateRouterPayload_router(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Router, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Router)
	fc.Result = res
	return ec.marshalORouter2backendgraphmodelRouter(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CreateRouterPayload_router(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CreateRouterPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Router_id(ctx, field)
			case "name":
				return ec.fieldContext_Router_name(ctx, field)
			case "host":
				return ec.fieldContext_Router_host(ctx, field)
			case "port":
				return ec.fieldContext_Router_port(ctx, field)
			case "status":
				return ec.fieldContext_Router_status(ctx, field)
			case "platform":
				return ec.fieldContext_Router_platform(ctx, field)
			case "version":
				return ec.fieldContext_Router_version(ctx, field)
			case "model":
				return ec.fieldContext_Router_model(ctx, field)
			case "uptime":
				return ec.fieldContext_Router_uptime(ctx, field)
			case "lastConnected":
				return ec.fieldContext_Router_lastConnected(ctx, field)
			case "createdAt":
				return ec.fieldContext_Router_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Router_updatedAt(ctx, field)
			case "capabilities":
				return ec.fieldContext_Router_capabilities(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Router", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CreateRouterPayload_errors(ctx context.Context, field graphql.CollectedField, obj *model.CreateRouterPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CreateRouterPayload_errors(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Errors, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.MutationError)
	fc.Result = res
	return ec.marshalOMutationError2backendgraphmodelMutationError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CreateRouterPayload_errors(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CreateRouterPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "code":
				return ec.fieldContext_MutationError_code(ctx, field)
			case "message":
				return ec.fieldContext_MutationError_message(ctx, field)
			case "field":
				return ec.fieldContext_MutationError_field(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MutationError", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CredentialTestResult_routerId(ctx context.Context, field graphql.CollectedField, obj *model.CredentialTestResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CredentialTestResult_routerId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RouterID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CredentialTestResult_routerId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CredentialTestResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CredentialTestResult_routerName(ctx context.Context, field graphql.CollectedField, obj *model.CredentialTestResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CredentialTestResult_routerName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RouterName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CredentialTestResult_routerName(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CredentialTestResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CredentialTestResult_success(ctx context.Context, field graphql.CollectedField, obj *model.CredentialTestResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CredentialTestResult_success(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Success, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CredentialTestResult_success(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CredentialTestResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CredentialTestResult_status(ctx context.Context, field graphql.CollectedField, obj *model.CredentialTestResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CredentialTestResult_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.CredentialTestStatus)
	fc.Result = res
	return ec.marshalNCredentialTestStatus2backendgraphmodelCredentialTestStatus(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CredentialTestResult_status(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CredentialTestResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type CredentialTestStatus does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CredentialTestResult_responseTimeMs(ctx context.Context, field graphql.CollectedField, obj *model.CredentialTestResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CredentialTestResult_responseTimeMs(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ResponseTimeMs, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CredentialTestResult_responseTimeMs(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CredentialTestResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CredentialTestResult_error(ctx context.Context, field graphql.CollectedField, obj *model.CredentialTestResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CredentialTestResult_error(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Error, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CredentialTestResult_error(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CredentialTestResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CredentialUpdatePayload_success(ctx context.Context, field graphql.CollectedField, obj *model.CredentialUpdatePayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CredentialUpdatePayload_success(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Success, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CredentialUpdatePayload_success(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CredentialUpdatePayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CredentialUpdatePayload_message(ctx context.Context, field graphql.CollectedField, obj *model.CredentialUpdatePayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CredentialUpdatePayload_message(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CredentialUpdatePayload_message(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CredentialUpdatePayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CredentialUpdatePayload_credentials(ctx context.Context, field graphql.CollectedField, obj *model.CredentialUpdatePayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CredentialUpdatePayload_credentials(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Credentials, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.RouterCredentials)
	fc.Result = res
	return ec.marshalORouterCredentials2backendgraphmodelRouterCredentials(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CredentialUpdatePayload_credentials(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CredentialUpdatePayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "routerId":
				return ec.fieldContext_RouterCredentials_routerId(ctx, field)
			case "username":
				return ec.fieldContext_RouterCredentials_username(ctx, field)
			case "hasPassword":
				return ec.fieldContext_RouterCredentials_hasPassword(ctx, field)
			case "encryptionStatus":
				return ec.fieldContext_RouterCredentials_encryptionStatus(ctx, field)
			case "keyVersion":
				return ec.fieldContext_RouterCredentials_keyVersion(ctx, field)
			case "lastUpdated":
				return ec.fieldContext_RouterCredentials_lastUpdated(ctx, field)
			case "createdAt":
				return ec.fieldContext_RouterCredentials_createdAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RouterCredentials", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CredentialUpdatePayload_errorCode(ctx context.Context, field graphql.CollectedField, obj *model.CredentialUpdatePayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CredentialUpdatePayload_errorCode(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ErrorCode, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.CredentialErrorCode)
	fc.Result = res
	return ec.marshalOCredentialErrorCode2backendgraphmodelCredentialErrorCode(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CredentialUpdatePayload_errorCode(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CredentialUpdatePayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type CredentialErrorCode does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CredentialUpdatePayload_errors(ctx context.Context, field graphql.CollectedField, obj *model.CredentialUpdatePayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CredentialUpdatePayload_errors(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Errors, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.MutationError)
	fc.Result = res
	return ec.marshalOMutationError2backendgraphmodelMutationError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CredentialUpdatePayload_errors(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CredentialUpdatePayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "code":
				return ec.fieldContext_MutationError_code(ctx, field)
			case "message":
				return ec.fieldContext_MutationError_message(ctx, field)
			case "field":
				return ec.fieldContext_MutationError_field(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MutationError", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _DeleteRouterPayload_success(ctx context.Context, field graphql.CollectedField, obj *model.DeleteRouterPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DeleteRouterPayload_success(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Success, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DeleteRouterPayload_success(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DeleteRouterPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DeleteRouterPayload_deletedRouterId(ctx context.Context, field graphql.CollectedField, obj *model.DeleteRouterPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DeleteRouterPayload_deletedRouterId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeletedRouterID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DeleteRouterPayload_deletedRouterId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DeleteRouterPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DeleteRouterPayload_errors(ctx context.Context, field graphql.CollectedField, obj *model.DeleteRouterPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DeleteRouterPayload_errors(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Errors, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.MutationError)
	fc.Result = res
	return ec.marshalOMutationError2backendgraphmodelMutationError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DeleteRouterPayload_errors(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DeleteRouterPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "code":
				return ec.fieldContext_MutationError_code(ctx, field)
			case "message":
				return ec.fieldContext_MutationError_message(ctx, field)
			case "field":
				return ec.fieldContext_MutationError_field(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MutationError", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _DiagnosticReport_routerId(ctx context.Context, field graphql.CollectedField, obj *model.DiagnosticReport) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DiagnosticReport_routerId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RouterID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DiagnosticReport_routerId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DiagnosticReport",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DiagnosticReport_timestamp(ctx context.Context, field graphql.CollectedField, obj *model.DiagnosticReport) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DiagnosticReport_timestamp(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Timestamp, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNDateTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DiagnosticReport_timestamp(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DiagnosticReport",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DateTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DiagnosticReport_networkReachable(ctx context.Context, field graphql.CollectedField, obj *model.DiagnosticReport) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DiagnosticReport_networkReachable(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NetworkReachable, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DiagnosticReport_networkReachable(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DiagnosticReport",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DiagnosticReport_portStatus(ctx context.Context, field graphql.CollectedField, obj *model.DiagnosticReport) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DiagnosticReport_portStatus(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PortStatus, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.PortStatus)
	fc.Result = res
	return ec.marshalNPortStatus2backendgraphmodelPortStatus(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DiagnosticReport_portStatus(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DiagnosticReport",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "port":
				return ec.fieldContext_PortStatus_port(ctx, field)
			case "service":
				return ec.fieldContext_PortStatus_service(ctx, field)
			case "open":
				return ec.fieldContext_PortStatus_open(ctx, field)
			case "responseTimeMs":
				return ec.fieldContext_PortStatus_responseTimeMs(ctx, field)
			case "error":
				return ec.fieldContext_PortStatus_error(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PortStatus", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _DiagnosticReport_tlsStatus(ctx context.Context, field graphql.CollectedField, obj *model.DiagnosticReport) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DiagnosticReport_tlsStatus(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TLSStatus, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.TLSStatus)
	fc.Result = res
	return ec.marshalOTLSStatus2backendgraphmodelTLSStatus(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DiagnosticReport_tlsStatus(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DiagnosticReport",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "valid":
				return ec.fieldContext_TLSStatus_valid(ctx, field)
			case "issuer":
				return ec.fieldContext_TLSStatus_issuer(ctx, field)
			case "subject":
				return ec.fieldContext_TLSStatus_subject(ctx, field)
			case "expiresAt":
				return ec.fieldContext_TLSStatus_expiresAt(ctx, field)
			case "error":
				return ec.fieldContext_TLSStatus_error(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TLSStatus", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _DiagnosticReport_authStatus(ctx context.Context, field graphql.CollectedField, obj *model.DiagnosticReport) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DiagnosticReport_authStatus(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AuthStatus, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.AuthStatus)
	fc.Result = res
	return ec.marshalNAuthStatus2backendgraphmodelAuthStatus(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DiagnosticReport_authStatus(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DiagnosticReport",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "tested":
				return ec.fieldContext_AuthStatus_tested(ctx, field)
			case "success":
				return ec.fieldContext_AuthStatus_success(ctx, field)
			case "error":
				return ec.fieldContext_AuthStatus_error(ctx, field)
			case "errorCode":
				return ec.fieldContext_AuthStatus_errorCode(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type AuthStatus", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _DiagnosticReport_suggestions(ctx context.Context, field graphql.CollectedField, obj *model.DiagnosticReport) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DiagnosticReport_suggestions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Suggestions, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.DiagnosticSuggestion)
	fc.Result = res
	return ec.marshalNDiagnosticSuggestion2backendgraphmodelDiagnosticSuggestion(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DiagnosticReport_suggestions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DiagnosticReport",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "severity":
				return ec.fieldContext_DiagnosticSuggestion_severity(ctx, field)
			case "title":
				return ec.fieldContext_DiagnosticSuggestion_title(ctx, field)
			case "description":
				return ec.fieldContext_DiagnosticSuggestion_description(ctx, field)
			case "action":
				return ec.fieldContext_DiagnosticSuggestion_action(ctx, field)
			case "docsUrl":
				return ec.fieldContext_DiagnosticSuggestion_docsUrl(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DiagnosticSuggestion", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _DiagnosticReport_rawReport(ctx context.Context, field graphql.CollectedField, obj *model.DiagnosticReport) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DiagnosticReport_rawReport(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RawReport, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DiagnosticReport_rawReport(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DiagnosticReport",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DiagnosticSuggestion_severity(ctx context.Context, field graphql.CollectedField, obj *model.DiagnosticSuggestion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DiagnosticSuggestion_severity(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Severity, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.SuggestionSeverity)
	fc.Result = res
	return ec.marshalNSuggestionSeverity2backendgraphmodelSuggestionSeverity(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DiagnosticSuggestion_severity(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DiagnosticSuggestion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type SuggestionSeverity does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DiagnosticSuggestion_title(ctx context.Context, field graphql.CollectedField, obj *model.DiagnosticSuggestion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DiagnosticSuggestion_title(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Title, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DiagnosticSuggestion_title(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DiagnosticSuggestion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DiagnosticSuggestion_description(ctx context.Context, field graphql.CollectedField, obj *model.DiagnosticSuggestion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DiagnosticSuggestion_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DiagnosticSuggestion_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DiagnosticSuggestion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DiagnosticSuggestion_action(ctx context.Context, field graphql.CollectedField, obj *model.DiagnosticSuggestion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DiagnosticSuggestion_action(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Action, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DiagnosticSuggestion_action(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DiagnosticSuggestion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DiagnosticSuggestion_docsUrl(ctx context.Context, field graphql.CollectedField, obj *model.DiagnosticSuggestion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DiagnosticSuggestion_docsUrl(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DocsURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DiagnosticSuggestion_docsUrl(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DiagnosticSuggestion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DisconnectRouterPayload_router(ctx context.Context, field graphql.CollectedField, obj *model.DisconnectRouterPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DisconnectRouterPayload_router(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Router, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Router)
	fc.Result = res
	return ec.marshalORouter2backendgraphmodelRouter(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DisconnectRouterPayload_router(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DisconnectRouterPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Router_id(ctx, field)
			case "name":
				return ec.fieldContext_Router_name(ctx, field)
			case "host":
				return ec.fieldContext_Router_host(ctx, field)
			case "port":
				return ec.fieldContext_Router_port(ctx, field)
			case "status":
				return ec.fieldContext_Router_status(ctx, field)
			case "platform":
				return ec.fieldContext_Router_platform(ctx, field)
			case "version":
				return ec.fieldContext_Router_version(ctx, field)
			case "model":
				return ec.fieldContext_Router_model(ctx, field)
			case "uptime":
				return ec.fieldContext_Router_uptime(ctx, field)
			case "lastConnected":
				return ec.fieldContext_Router_lastConnected(ctx, field)
			case "createdAt":
				return ec.fieldContext_Router_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Router_updatedAt(ctx, field)
			case "capabilities":
				return ec.fieldContext_Router_capabilities(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Router", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _DisconnectRouterPayload_errors(ctx context.Context, field graphql.CollectedField, obj *model.DisconnectRouterPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DisconnectRouterPayload_errors(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Errors, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.MutationError)
	fc.Result = res
	return ec.marshalOMutationError2backendgraphmodelMutationError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DisconnectRouterPayload_errors(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DisconnectRouterPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "code":
				return ec.fieldContext_MutationError_code(ctx, field)
			case "message":
				return ec.fieldContext_MutationError_message(ctx, field)
			case "field":
				return ec.fieldContext_MutationError_field(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MutationError", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _DiscoveredDevice_ip(ctx context.Context, field graphql.CollectedField, obj *model.DiscoveredDevice) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DiscoveredDevice_ip(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IP, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DiscoveredDevice_ip(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DiscoveredDevice",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DiscoveredDevice_hostname(ctx context.Context, field graphql.CollectedField, obj *model.DiscoveredDevice) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DiscoveredDevice_hostname(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Hostname, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DiscoveredDevice_hostname(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DiscoveredDevice",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DiscoveredDevice_ports(ctx context.Context, field graphql.CollectedField, obj *model.DiscoveredDevice) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DiscoveredDevice_ports(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Ports, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DiscoveredDevice_ports(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DiscoveredDevice",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DiscoveredDevice_deviceType(ctx context.Context, field graphql.CollectedField, obj *model.DiscoveredDevice) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DiscoveredDevice_deviceType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeviceType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DiscoveredDevice_deviceType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DiscoveredDevice",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DiscoveredDevice_vendor(ctx context.Context, field graphql.CollectedField, obj *model.DiscoveredDevice) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DiscoveredDevice_vendor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Vendor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DiscoveredDevice_vendor(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DiscoveredDevice",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DiscoveredDevice_routerOSInfo(ctx context.Context, field graphql.CollectedField, obj *model.DiscoveredDevice) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DiscoveredDevice_routerOSInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RouterOSInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.RouterOSInfo)
	fc.Result = res
	return ec.marshalORouterOSInfo2backendgraphmodelRouterOSInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DiscoveredDevice_routerOSInfo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DiscoveredDevice",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "version":
				return ec.fieldContext_RouterOSInfo_version(ctx, field)
			case "boardName":
				return ec.fieldContext_RouterOSInfo_boardName(ctx, field)
			case "architecture":
				return ec.fieldContext_RouterOSInfo_architecture(ctx, field)
			case "platform":
				return ec.fieldContext_RouterOSInfo_platform(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RouterOSInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _DiscoveredDevice_confidence(ctx context.Context, field graphql.CollectedField, obj *model.DiscoveredDevice) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DiscoveredDevice_confidence(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Confidence, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DiscoveredDevice_confidence(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DiscoveredDevice",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DiscoveredDevice_services(ctx context.Context, field graphql.CollectedField, obj *model.DiscoveredDevice) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DiscoveredDevice_services(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Services, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DiscoveredDevice_services(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DiscoveredDevice",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ErrorExtensions_code(ctx context.Context, field graphql.CollectedField, obj *model.ErrorExtensions) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ErrorExtensions_code(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Code, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ErrorExtensions_code(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ErrorExtensions",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ErrorExtensions_category(ctx context.Context, field graphql.CollectedField, obj *model.ErrorExtensions) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ErrorExtensions_category(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Category, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ErrorExtensions_category(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ErrorExtensions",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ErrorExtensions_field(ctx context.Context, field graphql.CollectedField, obj *model.ErrorExtensions) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ErrorExtensions_field(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Field, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ErrorExtensions_field(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ErrorExtensions",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ErrorExtensions_value(ctx context.Context, field graphql.CollectedField, obj *model.ErrorExtensions) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ErrorExtensions_value(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Value, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOJSON2map(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ErrorExtensions_value(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ErrorExtensions",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type JSON does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ErrorExtensions_suggestedFix(ctx context.Context, field graphql.CollectedField, obj *model.ErrorExtensions) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ErrorExtensions_suggestedFix(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SuggestedFix, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ErrorExtensions_suggestedFix(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ErrorExtensions",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ErrorExtensions_docsUrl(ctx context.Context, field graphql.CollectedField, obj *model.ErrorExtensions) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ErrorExtensions_docsUrl(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DocsURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ErrorExtensions_docsUrl(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ErrorExtensions",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ErrorExtensions_requestId(ctx context.Context, field graphql.CollectedField, obj *model.ErrorExtensions) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ErrorExtensions_requestId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RequestID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ErrorExtensions_requestId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ErrorExtensions",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ErrorExtensions_recoverable(ctx context.Context, field graphql.CollectedField, obj *model.ErrorExtensions) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ErrorExtensions_recoverable(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Recoverable, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ErrorExtensions_recoverable(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ErrorExtensions",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ErrorExtensions_troubleshootingSteps(ctx context.Context, field graphql.CollectedField, obj *model.ErrorExtensions) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ErrorExtensions_troubleshootingSteps(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TroubleshootingSteps, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ErrorExtensions_troubleshootingSteps(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ErrorExtensions",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ExportConfigPayload_success(ctx context.Context, field graphql.CollectedField, obj *model.ExportConfigPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ExportConfigPayload_success(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Success, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ExportConfigPayload_success(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ExportConfigPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ExportConfigPayload_config(ctx context.Context, field graphql.CollectedField, obj *model.ExportConfigPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ExportConfigPayload_config(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Config, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOJSON2map(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ExportConfigPayload_config(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ExportConfigPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type JSON does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ExportConfigPayload_securityWarning(ctx context.Context, field graphql.CollectedField, obj *model.ExportConfigPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ExportConfigPayload_securityWarning(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SecurityWarning, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ExportConfigPayload_securityWarning(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ExportConfigPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ExportConfigPayload_errors(ctx context.Context, field graphql.CollectedField, obj *model.ExportConfigPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ExportConfigPayload_errors(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Errors, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.MutationError)
	fc.Result = res
	return ec.marshalOMutationError2backendgraphmodelMutationError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ExportConfigPayload_errors(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ExportConfigPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "code":
				return ec.fieldContext_MutationError_code(ctx, field)
			case "message":
				return ec.fieldContext_MutationError_message(ctx, field)
			case "field":
				return ec.fieldContext_MutationError_field(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MutationError", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeatureCompatibilityInfo_featureId(ctx context.Context, field graphql.CollectedField, obj *model.FeatureCompatibilityInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeatureCompatibilityInfo_featureId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FeatureID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeatureCompatibilityInfo_featureId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeatureCompatibilityInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeatureCompatibilityInfo_name(ctx context.Context, field graphql.CollectedField, obj *model.FeatureCompatibilityInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeatureCompatibilityInfo_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeatureCompatibilityInfo_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeatureCompatibilityInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeatureCompatibilityInfo_minVersion(ctx context.Context, field graphql.CollectedField, obj *model.FeatureCompatibilityInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeatureCompatibilityInfo_minVersion(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MinVersion, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeatureCompatibilityInfo_minVersion(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeatureCompatibilityInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeatureCompatibilityInfo_maxVersion(ctx context.Context, field graphql.CollectedField, obj *model.FeatureCompatibilityInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeatureCompatibilityInfo_maxVersion(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MaxVersion, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeatureCompatibilityInfo_maxVersion(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeatureCompatibilityInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeatureCompatibilityInfo_minVersionCHR(ctx context.Context, field graphql.CollectedField, obj *model.FeatureCompatibilityInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeatureCompatibilityInfo_minVersionCHR(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MinVersionChr, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeatureCompatibilityInfo_minVersionCHR(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeatureCompatibilityInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeatureCompatibilityInfo_requiredPackages(ctx context.Context, field graphql.CollectedField, obj *model.FeatureCompatibilityInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeatureCompatibilityInfo_requiredPackages(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RequiredPackages, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeatureCompatibilityInfo_requiredPackages(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeatureCompatibilityInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeatureCompatibilityInfo_dependsOn(ctx context.Context, field graphql.CollectedField, obj *model.FeatureCompatibilityInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeatureCompatibilityInfo_dependsOn(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DependsOn, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeatureCompatibilityInfo_dependsOn(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeatureCompatibilityInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeatureCompatibilityInfo_upgradeUrl(ctx context.Context, field graphql.CollectedField, obj *model.FeatureCompatibilityInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeatureCompatibilityInfo_upgradeUrl(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpgradeURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeatureCompatibilityInfo_upgradeUrl(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeatureCompatibilityInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeatureSupport_featureId(ctx context.Context, field graphql.CollectedField, obj *model.FeatureSupport) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeatureSupport_featureId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FeatureID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeatureSupport_featureId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeatureSupport",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeatureSupport_name(ctx context.Context, field graphql.CollectedField, obj *model.FeatureSupport) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeatureSupport_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeatureSupport_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeatureSupport",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeatureSupport_supported(ctx context.Context, field graphql.CollectedField, obj *model.FeatureSupport) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeatureSupport_supported(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Supported, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeatureSupport_supported(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeatureSupport",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeatureSupport_level(ctx context.Context, field graphql.CollectedField, obj *model.FeatureSupport) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeatureSupport_level(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Level, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.CapabilityLevel)
	fc.Result = res
	return ec.marshalNCapabilityLevel2backendgraphmodelCapabilityLevel(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeatureSupport_level(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeatureSupport",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type CapabilityLevel does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeatureSupport_reason(ctx context.Context, field graphql.CollectedField, obj *model.FeatureSupport) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeatureSupport_reason(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Reason, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeatureSupport_reason(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeatureSupport",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeatureSupport_requiredVersion(ctx context.Context, field graphql.CollectedField, obj *model.FeatureSupport) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeatureSupport_requiredVersion(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RequiredVersion, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeatureSupport_requiredVersion(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeatureSupport",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeatureSupport_upgradeUrl(ctx context.Context, field graphql.CollectedField, obj *model.FeatureSupport) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeatureSupport_upgradeUrl(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpgradeURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeatureSupport_upgradeUrl(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeatureSupport",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeatureSupport_requiredPackages(ctx context.Context, field graphql.CollectedField, obj *model.FeatureSupport) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeatureSupport_requiredPackages(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RequiredPackages, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeatureSupport_requiredPackages(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeatureSupport",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeatureSupport_missingPackages(ctx context.Context, field graphql.CollectedField, obj *model.FeatureSupport) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeatureSupport_missingPackages(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MissingPackages, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeatureSupport_missingPackages(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeatureSupport",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HardwareInfo_architecture(ctx context.Context, field graphql.CollectedField, obj *model.HardwareInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HardwareInfo_architecture(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Architecture, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HardwareInfo_architecture(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HardwareInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HardwareInfo_model(ctx context.Context, field graphql.CollectedField, obj *model.HardwareInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HardwareInfo_model(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Model, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HardwareInfo_model(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HardwareInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HardwareInfo_boardName(ctx context.Context, field graphql.CollectedField, obj *model.HardwareInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HardwareInfo_boardName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BoardName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HardwareInfo_boardName(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HardwareInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HardwareInfo_totalMemory(ctx context.Context, field graphql.CollectedField, obj *model.HardwareInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HardwareInfo_totalMemory(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalMemory, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.Size)
	fc.Result = res
	return ec.marshalNSize2backendgraphmodelSize(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HardwareInfo_totalMemory(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HardwareInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Size does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HardwareInfo_availableStorage(ctx context.Context, field graphql.CollectedField, obj *model.HardwareInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HardwareInfo_availableStorage(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AvailableStorage, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.Size)
	fc.Result = res
	return ec.marshalNSize2backendgraphmodelSize(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HardwareInfo_availableStorage(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HardwareInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Size does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HardwareInfo_cpuCount(ctx context.Context, field graphql.CollectedField, obj *model.HardwareInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HardwareInfo_cpuCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CPUCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HardwareInfo_cpuCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HardwareInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HardwareInfo_hasWirelessChip(ctx context.Context, field graphql.CollectedField, obj *model.HardwareInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HardwareInfo_hasWirelessChip(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HasWirelessChip, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HardwareInfo_hasWirelessChip(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HardwareInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HardwareInfo_hasLTEModule(ctx context.Context, field graphql.CollectedField, obj *model.HardwareInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HardwareInfo_hasLTEModule(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HasLTEModule, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HardwareInfo_hasLTEModule(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HardwareInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HealthCheckResult_routerId(ctx context.Context, field graphql.CollectedField, obj *model.HealthCheckResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HealthCheckResult_routerId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RouterID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HealthCheckResult_routerId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HealthCheckResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HealthCheckResult_healthy(ctx context.Context, field graphql.CollectedField, obj *model.HealthCheckResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HealthCheckResult_healthy(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Healthy, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HealthCheckResult_healthy(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HealthCheckResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HealthCheckResult_checkedAt(ctx context.Context, field graphql.CollectedField, obj *model.HealthCheckResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HealthCheckResult_checkedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CheckedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNDateTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HealthCheckResult_checkedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HealthCheckResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DateTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HealthCheckResult_responseTimeMs(ctx context.Context, field graphql.CollectedField, obj *model.HealthCheckResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HealthCheckResult_responseTimeMs(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ResponseTimeMs, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HealthCheckResult_responseTimeMs(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HealthCheckResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HealthCheckResult_error(ctx context.Context, field graphql.CollectedField, obj *model.HealthCheckResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HealthCheckResult_error(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Error, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HealthCheckResult_error(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HealthCheckResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HealthStatus_status(ctx context.Context, field graphql.CollectedField, obj *model.HealthStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HealthStatus_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.ServiceStatus)
	fc.Result = res
	return ec.marshalNServiceStatus2backendgraphmodelServiceStatus(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HealthStatus_status(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HealthStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ServiceStatus does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HealthStatus_version(ctx context.Context, field graphql.CollectedField, obj *model.HealthStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HealthStatus_version(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Version, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HealthStatus_version(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HealthStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HealthStatus_uptime(ctx context.Context, field graphql.CollectedField, obj *model.HealthStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HealthStatus_uptime(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Uptime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Duration)
	fc.Result = res
	return ec.marshalODuration2backendgraphmodelDuration(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HealthStatus_uptime(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HealthStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Duration does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HealthStatus_connectedRouters(ctx context.Context, field graphql.CollectedField, obj *model.HealthStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HealthStatus_connectedRouters(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ConnectedRouters, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HealthStatus_connectedRouters(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HealthStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HealthStatus_checkedAt(ctx context.Context, field graphql.CollectedField, obj *model.HealthStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HealthStatus_checkedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CheckedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNDateTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HealthStatus_checkedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HealthStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DateTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Interface_id(ctx context.Context, field graphql.CollectedField, obj *model.Interface) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Interface_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Interface_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Interface",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Interface_name(ctx context.Context, field graphql.CollectedField, obj *model.Interface) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Interface_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Interface_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Interface",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Interface_type(ctx context.Context, field graphql.CollectedField, obj *model.Interface) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Interface_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.InterfaceType)
	fc.Result = res
	return ec.marshalNInterfaceType2backendgraphmodelInterfaceType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Interface_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Interface",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type InterfaceType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Interface_enabled(ctx context.Context, field graphql.CollectedField, obj *model.Interface) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Interface_enabled(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Enabled, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Interface_enabled(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Interface",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Interface_running(ctx context.Context, field graphql.CollectedField, obj *model.Interface) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Interface_running(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Running, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Interface_running(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Interface",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Interface_macAddress(ctx context.Context, field graphql.CollectedField, obj *model.Interface) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Interface_macAddress(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MacAddress, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.MAC)
	fc.Result = res
	return ec.marshalOMAC2backendgraphmodelMAC(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Interface_macAddress(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Interface",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type MAC does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Interface_mtu(ctx context.Context, field graphql.CollectedField, obj *model.Interface) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Interface_mtu(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Mtu, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Interface_mtu(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Interface",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Interface_comment(ctx context.Context, field graphql.CollectedField, obj *model.Interface) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Interface_comment(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Comment, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Interface_comment(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Interface",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Interface_txBytes(ctx context.Context, field graphql.CollectedField, obj *model.Interface) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Interface_txBytes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TxBytes, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Size)
	fc.Result = res
	return ec.marshalOSize2backendgraphmodelSize(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Interface_txBytes(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Interface",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Size does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Interface_rxBytes(ctx context.Context, field graphql.CollectedField, obj *model.Interface) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Interface_rxBytes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RxBytes, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Size)
	fc.Result = res
	return ec.marshalOSize2backendgraphmodelSize(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Interface_rxBytes(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Interface",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Size does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _InterfaceConnection_edges(ctx context.Context, field graphql.CollectedField, obj *model.InterfaceConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_InterfaceConnection_edges(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Edges, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.InterfaceEdge)
	fc.Result = res
	return ec.marshalNInterfaceEdge2backendgraphmodelInterfaceEdge(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_InterfaceConnection_edges(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "InterfaceConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "node":
				return ec.fieldContext_InterfaceEdge_node(ctx, field)
			case "cursor":
				return ec.fieldContext_InterfaceEdge_cursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type InterfaceEdge", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _InterfaceConnection_pageInfo(ctx context.Context, field graphql.CollectedField, obj *model.InterfaceConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_InterfaceConnection_pageInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.PageInfo)
	fc.Result = res
	return ec.marshalNPageInfo2backendgraphmodelPageInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_InterfaceConnection_pageInfo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "InterfaceConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			case "hasPreviousPage":
				return ec.fieldContext_PageInfo_hasPreviousPage(ctx, field)
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _InterfaceConnection_totalCount(ctx context.Context, field graphql.CollectedField, obj *model.InterfaceConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_InterfaceConnection_totalCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_InterfaceConnection_totalCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "InterfaceConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _InterfaceEdge_node(ctx context.Context, field graphql.CollectedField, obj *model.InterfaceEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_InterfaceEdge_node(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Node, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Interface)
	fc.Result = res
	return ec.marshalNInterface2backendgraphmodelInterface(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_InterfaceEdge_node(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "InterfaceEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Interface_id(ctx, field)
			case "name":
				return ec.fieldContext_Interface_name(ctx, field)
			case "type":
				return ec.fieldContext_Interface_type(ctx, field)
			case "enabled":
				return ec.fieldContext_Interface_enabled(ctx, field)
			case "running":
				return ec.fieldContext_Interface_running(ctx, field)
			case "macAddress":
				return ec.fieldContext_Interface_macAddress(ctx, field)
			case "mtu":
				return ec.fieldContext_Interface_mtu(ctx, field)
			case "comment":
				return ec.fieldContext_Interface_comment(ctx, field)
			case "txBytes":
				return ec.fieldContext_Interface_txBytes(ctx, field)
			case "rxBytes":
				return ec.fieldContext_Interface_rxBytes(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Interface", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _InterfaceEdge_cursor(ctx context.Context, field graphql.CollectedField, obj *model.InterfaceEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_InterfaceEdge_cursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_InterfaceEdge_cursor(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "InterfaceEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _InterfaceTrafficEvent_interfaceId(ctx context.Context, field graphql.CollectedField, obj *model.InterfaceTrafficEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_InterfaceTrafficEvent_interfaceId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.InterfaceID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_InterfaceTrafficEvent_interfaceId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "InterfaceTrafficEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _InterfaceTrafficEvent_interfaceName(ctx context.Context, field graphql.CollectedField, obj *model.InterfaceTrafficEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_InterfaceTrafficEvent_interfaceName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.InterfaceName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_InterfaceTrafficEvent_interfaceName(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "InterfaceTrafficEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _InterfaceTrafficEvent_txRate(ctx context.Context, field graphql.CollectedField, obj *model.InterfaceTrafficEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_InterfaceTrafficEvent_txRate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TxRate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.Size)
	fc.Result = res
	return ec.marshalNSize2backendgraphmodelSize(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_InterfaceTrafficEvent_txRate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "InterfaceTrafficEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Size does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _InterfaceTrafficEvent_rxRate(ctx context.Context, field graphql.CollectedField, obj *model.InterfaceTrafficEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_InterfaceTrafficEvent_rxRate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RxRate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.Size)
	fc.Result = res
	return ec.marshalNSize2backendgraphmodelSize(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_InterfaceTrafficEvent_rxRate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "InterfaceTrafficEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Size does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _InterfaceTrafficEvent_txTotal(ctx context.Context, field graphql.CollectedField, obj *model.InterfaceTrafficEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_InterfaceTrafficEvent_txTotal(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TxTotal, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.Size)
	fc.Result = res
	return ec.marshalNSize2backendgraphmodelSize(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_InterfaceTrafficEvent_txTotal(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "InterfaceTrafficEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Size does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _InterfaceTrafficEvent_rxTotal(ctx context.Context, field graphql.CollectedField, obj *model.InterfaceTrafficEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_InterfaceTrafficEvent_rxTotal(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RxTotal, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.Size)
	fc.Result = res
	return ec.marshalNSize2backendgraphmodelSize(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_InterfaceTrafficEvent_rxTotal(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "InterfaceTrafficEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Size does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _InterfaceTrafficEvent_timestamp(ctx context.Context, field graphql.CollectedField, obj *model.InterfaceTrafficEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_InterfaceTrafficEvent_timestamp(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Timestamp, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNDateTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_InterfaceTrafficEvent_timestamp(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "InterfaceTrafficEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DateTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createRouter(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_createRouter(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CreateRouter(rctx, fc.Args["input"].(model.CreateRouterInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.CreateRouterPayload)
	fc.Result = res
	return ec.marshalNCreateRouterPayload2backendgraphmodelCreateRouterPayload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_createRouter(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "router":
				return ec.fieldContext_CreateRouterPayload_router(ctx, field)
			case "errors":
				return ec.fieldContext_CreateRouterPayload_errors(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CreateRouterPayload", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createRouter_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateRouter(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateRouter(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UpdateRouter(rctx, fc.Args["id"].(string), fc.Args["input"].(model.UpdateRouterInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.UpdateRouterPayload)
	fc.Result = res
	return ec.marshalNUpdateRouterPayload2backendgraphmodelUpdateRouterPayload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateRouter(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "router":
				return ec.fieldContext_UpdateRouterPayload_router(ctx, field)
			case "errors":
				return ec.fieldContext_UpdateRouterPayload_errors(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UpdateRouterPayload", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateRouter_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_deleteRouter(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_deleteRouter(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().DeleteRouter(rctx, fc.Args["id"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.DeleteRouterPayload)
	fc.Result = res
	return ec.marshalNDeleteRouterPayload2backendgraphmodelDeleteRouterPayload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_deleteRouter(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "success":
				return ec.fieldContext_DeleteRouterPayload_success(ctx, field)
			case "deletedRouterId":
				return ec.fieldContext_DeleteRouterPayload_deletedRouterId(ctx, field)
			case "errors":
				return ec.fieldContext_DeleteRouterPayload_errors(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DeleteRouterPayload", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deleteRouter_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_testRouterConnection(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_testRouterConnection(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().TestRouterConnection(rctx, fc.Args["id"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.TestConnectionPayload)
	fc.Result = res
	return ec.marshalNTestConnectionPayload2backendgraphmodelTestConnectionPayload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_testRouterConnection(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "success":
				return ec.fieldContext_TestConnectionPayload_success(ctx, field)
			case "responseTimeMs":
				return ec.fieldContext_TestConnectionPayload_responseTimeMs(ctx, field)
			case "version":
				return ec.fieldContext_TestConnectionPayload_version(ctx, field)
			case "error":
				return ec.fieldContext_TestConnectionPayload_error(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TestConnectionPayload", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_testRouterConnection_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_connectRouter(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_connectRouter(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().ConnectRouter(rctx, fc.Args["id"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.ConnectRouterPayload)
	fc.Result = res
	return ec.marshalNConnectRouterPayload2backendgraphmodelConnectRouterPayload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_connectRouter(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "router":
				return ec.fieldContext_ConnectRouterPayload_router(ctx, field)
			case "errors":
				return ec.fieldContext_ConnectRouterPayload_errors(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ConnectRouterPayload", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_connectRouter_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_disconnectRouter(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_disconnectRouter(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().DisconnectRouter(rctx, fc.Args["id"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.DisconnectRouterPayload)
	fc.Result = res
	return ec.marshalNDisconnectRouterPayload2backendgraphmodelDisconnectRouterPayload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_disconnectRouter(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "router":
				return ec.fieldContext_DisconnectRouterPayload_router(ctx, field)
			case "errors":
				return ec.fieldContext_DisconnectRouterPayload_errors(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DisconnectRouterPayload", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_disconnectRouter_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_refreshCapabilities(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_refreshCapabilities(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().RefreshCapabilities(rctx, fc.Args["routerId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.RefreshCapabilitiesPayload)
	fc.Result = res
	return ec.marshalNRefreshCapabilitiesPayload2backendgraphmodelRefreshCapabilitiesPayload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_refreshCapabilities(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "capabilities":
				return ec.fieldContext_RefreshCapabilitiesPayload_capabilities(ctx, field)
			case "errors":
				return ec.fieldContext_RefreshCapabilitiesPayload_errors(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RefreshCapabilitiesPayload", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_refreshCapabilities_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_login(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_login(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().Login(rctx, fc.Args["username"].(string), fc.Args["password"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.AuthPayload)
	fc.Result = res
	return ec.marshalNAuthPayload2backendgraphmodelAuthPayload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_login(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "token":
				return ec.fieldContext_AuthPayload_token(ctx, field)
			case "user":
				return ec.fieldContext_AuthPayload_user(ctx, field)
			case "expiresAt":
				return ec.fieldContext_AuthPayload_expiresAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type AuthPayload", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_login_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_logout(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_logout(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().Logout(rctx)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Auth == nil {
				return nil, errors.New("directive auth is not implemented")
			}
			return ec.directives.Auth(ctx, nil, directive0, nil)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_logout(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_changePassword(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_changePassword(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().ChangePassword(rctx, fc.Args["currentPassword"].(string), fc.Args["newPassword"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Auth == nil {
				return nil, errors.New("directive auth is not implemented")
			}
			return ec.directives.Auth(ctx, nil, directive0, nil)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_changePassword(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_changePassword_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_revokeAllSessions(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_revokeAllSessions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().RevokeAllSessions(rctx, fc.Args["userId"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			requires, err := ec.unmarshalOString2string(ctx, "admin")
			if err != nil {
				return nil, err
			}
			if ec.directives.Auth == nil {
				return nil, errors.New("directive auth is not implemented")
			}
			return ec.directives.Auth(ctx, nil, directive0, requires)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_revokeAllSessions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_revokeAllSessions_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_revokeSession(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_revokeSession(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().RevokeSession(rctx, fc.Args["sessionId"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Auth == nil {
				return nil, errors.New("directive auth is not implemented")
			}
			return ec.directives.Auth(ctx, nil, directive0, nil)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_revokeSession(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_revokeSession_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_setPreferredProtocol(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_setPreferredProtocol(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().SetPreferredProtocol(rctx, fc.Args["routerId"].(string), fc.Args["protocol"].(model.Protocol))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.SetPreferredProtocolPayload)
	fc.Result = res
	return ec.marshalNSetPreferredProtocolPayload2backendgraphmodelSetPreferredProtocolPayload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_setPreferredProtocol(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "router":
				return ec.fieldContext_SetPreferredProtocolPayload_router(ctx, field)
			case "connectionDetails":
				return ec.fieldContext_SetPreferredProtocolPayload_connectionDetails(ctx, field)
			case "errors":
				return ec.fieldContext_SetPreferredProtocolPayload_errors(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SetPreferredProtocolPayload", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_setPreferredProtocol_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_reconnectRouter(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_reconnectRouter(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().ReconnectRouter(rctx, fc.Args["routerId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.ReconnectRouterPayload)
	fc.Result = res
	return ec.marshalNReconnectRouterPayload2backendgraphmodelReconnectRouterPayload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_reconnectRouter(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "router":
				return ec.fieldContext_ReconnectRouterPayload_router(ctx, field)
			case "connectionDetails":
				return ec.fieldContext_ReconnectRouterPayload_connectionDetails(ctx, field)
			case "initiated":
				return ec.fieldContext_ReconnectRouterPayload_initiated(ctx, field)
			case "waitTimeMs":
				return ec.fieldContext_ReconnectRouterPayload_waitTimeMs(ctx, field)
			case "errors":
				return ec.fieldContext_ReconnectRouterPayload_errors(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ReconnectRouterPayload", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_reconnectRouter_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_checkRouterHealth(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_checkRouterHealth(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CheckRouterHealth(rctx, fc.Args["routerId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.HealthCheckResult)
	fc.Result = res
	return ec.marshalNHealthCheckResult2backendgraphmodelHealthCheckResult(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_checkRouterHealth(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "routerId":
				return ec.fieldContext_HealthCheckResult_routerId(ctx, field)
			case "healthy":
				return ec.fieldContext_HealthCheckResult_healthy(ctx, field)
			case "checkedAt":
				return ec.fieldContext_HealthCheckResult_checkedAt(ctx, field)
			case "responseTimeMs":
				return ec.fieldContext_HealthCheckResult_responseTimeMs(ctx, field)
			case "error":
				return ec.fieldContext_HealthCheckResult_error(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type HealthCheckResult", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_checkRouterHealth_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateRouterCredentials(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateRouterCredentials(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().UpdateRouterCredentials(rctx, fc.Args["routerId"].(string), fc.Args["input"].(model.CredentialsInput))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Auth == nil {
				return nil, errors.New("directive auth is not implemented")
			}
			return ec.directives.Auth(ctx, nil, directive0, nil)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.CredentialUpdatePayload); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *backend/graph/model.CredentialUpdatePayload`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.CredentialUpdatePayload)
	fc.Result = res
	return ec.marshalNCredentialUpdatePayload2backendgraphmodelCredentialUpdatePayload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateRouterCredentials(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "success":
				return ec.fieldContext_CredentialUpdatePayload_success(ctx, field)
			case "message":
				return ec.fieldContext_CredentialUpdatePayload_message(ctx, field)
			case "credentials":
				return ec.fieldContext_CredentialUpdatePayload_credentials(ctx, field)
			case "errorCode":
				return ec.fieldContext_CredentialUpdatePayload_errorCode(ctx, field)
			case "errors":
				return ec.fieldContext_CredentialUpdatePayload_errors(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CredentialUpdatePayload", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateRouterCredentials_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_testAllCredentials(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_testAllCredentials(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().TestAllCredentials(rctx)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Auth == nil {
				return nil, errors.New("directive auth is not implemented")
			}
			return ec.directives.Auth(ctx, nil, directive0, nil)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.TestAllCredentialsPayload); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *backend/graph/model.TestAllCredentialsPayload`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.TestAllCredentialsPayload)
	fc.Result = res
	return ec.marshalNTestAllCredentialsPayload2backendgraphmodelTestAllCredentialsPayload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_testAllCredentials(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "totalRouters":
				return ec.fieldContext_TestAllCredentialsPayload_totalRouters(ctx, field)
			case "successCount":
				return ec.fieldContext_TestAllCredentialsPayload_successCount(ctx, field)
			case "failureCount":
				return ec.fieldContext_TestAllCredentialsPayload_failureCount(ctx, field)
			case "results":
				return ec.fieldContext_TestAllCredentialsPayload_results(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TestAllCredentialsPayload", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_exportRouterConfig(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_exportRouterConfig(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().ExportRouterConfig(rctx, fc.Args["input"].(model.ExportConfigInput))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Auth == nil {
				return nil, errors.New("directive auth is not implemented")
			}
			return ec.directives.Auth(ctx, nil, directive0, nil)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.ExportConfigPayload); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *backend/graph/model.ExportConfigPayload`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.ExportConfigPayload)
	fc.Result = res
	return ec.marshalNExportConfigPayload2backendgraphmodelExportConfigPayload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_exportRouterConfig(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "success":
				return ec.fieldContext_ExportConfigPayload_success(ctx, field)
			case "config":
				return ec.fieldContext_ExportConfigPayload_config(ctx, field)
			case "securityWarning":
				return ec.fieldContext_ExportConfigPayload_securityWarning(ctx, field)
			case "errors":
				return ec.fieldContext_ExportConfigPayload_errors(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ExportConfigPayload", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_exportRouterConfig_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_runDiagnostics(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_runDiagnostics(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().RunDiagnostics(rctx, fc.Args["routerId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.DiagnosticReport)
	fc.Result = res
	return ec.marshalNDiagnosticReport2backendgraphmodelDiagnosticReport(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_runDiagnostics(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "routerId":
				return ec.fieldContext_DiagnosticReport_routerId(ctx, field)
			case "timestamp":
				return ec.fieldContext_DiagnosticReport_timestamp(ctx, field)
			case "networkReachable":
				return ec.fieldContext_DiagnosticReport_networkReachable(ctx, field)
			case "portStatus":
				return ec.fieldContext_DiagnosticReport_portStatus(ctx, field)
			case "tlsStatus":
				return ec.fieldContext_DiagnosticReport_tlsStatus(ctx, field)
			case "authStatus":
				return ec.fieldContext_DiagnosticReport_authStatus(ctx, field)
			case "suggestions":
				return ec.fieldContext_DiagnosticReport_suggestions(ctx, field)
			case "rawReport":
				return ec.fieldContext_DiagnosticReport_rawReport(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DiagnosticReport", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_runDiagnostics_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_resetCircuitBreaker(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_resetCircuitBreaker(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().ResetCircuitBreaker(rctx, fc.Args["routerId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.CircuitBreakerStatus)
	fc.Result = res
	return ec.marshalNCircuitBreakerStatus2backendgraphmodelCircuitBreakerStatus(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_resetCircuitBreaker(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "routerId":
				return ec.fieldContext_CircuitBreakerStatus_routerId(ctx, field)
			case "state":
				return ec.fieldContext_CircuitBreakerStatus_state(ctx, field)
			case "failureCount":
				return ec.fieldContext_CircuitBreakerStatus_failureCount(ctx, field)
			case "failureThreshold":
				return ec.fieldContext_CircuitBreakerStatus_failureThreshold(ctx, field)
			case "cooldownRemainingSeconds":
				return ec.fieldContext_CircuitBreakerStatus_cooldownRemainingSeconds(ctx, field)
			case "lastFailureAt":
				return ec.fieldContext_CircuitBreakerStatus_lastFailureAt(ctx, field)
			case "lastSuccessAt":
				return ec.fieldContext_CircuitBreakerStatus_lastSuccessAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CircuitBreakerStatus", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_resetCircuitBreaker_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_addRouter(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_addRouter(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().AddRouter(rctx, fc.Args["input"].(model.AddRouterInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.AddRouterPayload)
	fc.Result = res
	return ec.marshalNAddRouterPayload2backendgraphmodelAddRouterPayload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_addRouter(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "router":
				return ec.fieldContext_AddRouterPayload_router(ctx, field)
			case "connectionResult":
				return ec.fieldContext_AddRouterPayload_connectionResult(ctx, field)
			case "validationErrors":
				return ec.fieldContext_AddRouterPayload_validationErrors(ctx, field)
			case "errors":
				return ec.fieldContext_AddRouterPayload_errors(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type AddRouterPayload", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_addRouter_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_testRouterCredentials(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_testRouterCredentials(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().TestRouterCredentials(rctx, fc.Args["input"].(model.AddRouterInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.ConnectionTestResult)
	fc.Result = res
	return ec.marshalNConnectionTestResult2backendgraphmodelConnectionTestResult(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_testRouterCredentials(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "success":
				return ec.fieldContext_ConnectionTestResult_success(ctx, field)
			case "protocolUsed":
				return ec.fieldContext_ConnectionTestResult_protocolUsed(ctx, field)
			case "responseTimeMs":
				return ec.fieldContext_ConnectionTestResult_responseTimeMs(ctx, field)
			case "routerVersion":
				return ec.fieldContext_ConnectionTestResult_routerVersion(ctx, field)
			case "routerModel":
				return ec.fieldContext_ConnectionTestResult_routerModel(ctx, field)
			case "boardName":
				return ec.fieldContext_ConnectionTestResult_boardName(ctx, field)
			case "uptime":
				return ec.fieldContext_ConnectionTestResult_uptime(ctx, field)
			case "protocolsAttempted":
				return ec.fieldContext_ConnectionTestResult_protocolsAttempted(ctx, field)
			case "supportsContainers":
				return ec.fieldContext_ConnectionTestResult_supportsContainers(ctx, field)
			case "architecture":
				return ec.fieldContext_ConnectionTestResult_architecture(ctx, field)
			case "error":
				return ec.fieldContext_ConnectionTestResult_error(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ConnectionTestResult", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_testRouterCredentials_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_scanNetwork(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_scanNetwork(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().ScanNetwork(rctx, fc.Args["input"].(model.ScanNetworkInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.ScanNetworkPayload)
	fc.Result = res
	return ec.marshalNScanNetworkPayload2backendgraphmodelScanNetworkPayload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_scanNetwork(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "task":
				return ec.fieldContext_ScanNetworkPayload_task(ctx, field)
			case "errors":
				return ec.fieldContext_ScanNetworkPayload_errors(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ScanNetworkPayload", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_scanNetwork_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_autoScanGateways(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_autoScanGateways(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().AutoScanGateways(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.ScanNetworkPayload)
	fc.Result = res
	return ec.marshalNScanNetworkPayload2backendgraphmodelScanNetworkPayload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_autoScanGateways(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "task":
				return ec.fieldContext_ScanNetworkPayload_task(ctx, field)
			case "errors":
				return ec.fieldContext_ScanNetworkPayload_errors(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ScanNetworkPayload", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_cancelScan(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_cancelScan(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CancelScan(rctx, fc.Args["taskId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.CancelScanPayload)
	fc.Result = res
	return ec.marshalNCancelScanPayload2backendgraphmodelCancelScanPayload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_cancelScan(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "task":
				return ec.fieldContext_CancelScanPayload_task(ctx, field)
			case "errors":
				return ec.fieldContext_CancelScanPayload_errors(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CancelScanPayload", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_cancelScan_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _MutationError_code(ctx context.Context, field graphql.CollectedField, obj *model.MutationError) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MutationError_code(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Code, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MutationError_code(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MutationError",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MutationError_message(ctx context.Context, field graphql.CollectedField, obj *model.MutationError) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MutationError_message(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MutationError_message(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MutationError",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MutationError_field(ctx context.Context, field graphql.CollectedField, obj *model.MutationError) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MutationError_field(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Field, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MutationError_field(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MutationError",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PageInfo_hasNextPage(ctx context.Context, field graphql.CollectedField, obj *model.PageInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PageInfo_hasNextPage(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HasNextPage, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PageInfo_hasNextPage(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PageInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PageInfo_hasPreviousPage(ctx context.Context, field graphql.CollectedField, obj *model.PageInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PageInfo_hasPreviousPage(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HasPreviousPage, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PageInfo_hasPreviousPage(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PageInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PageInfo_startCursor(ctx context.Context, field graphql.CollectedField, obj *model.PageInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PageInfo_startCursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StartCursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PageInfo_startCursor(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PageInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PageInfo_endCursor(ctx context.Context, field graphql.CollectedField, obj *model.PageInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PageInfo_endCursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EndCursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PageInfo_endCursor(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PageInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PortStatus_port(ctx context.Context, field graphql.CollectedField, obj *model.PortStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PortStatus_port(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Port, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PortStatus_port(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PortStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PortStatus_service(ctx context.Context, field graphql.CollectedField, obj *model.PortStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PortStatus_service(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Service, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PortStatus_service(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PortStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PortStatus_open(ctx context.Context, field graphql.CollectedField, obj *model.PortStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PortStatus_open(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Open, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PortStatus_open(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PortStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PortStatus_responseTimeMs(ctx context.Context, field graphql.CollectedField, obj *model.PortStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PortStatus_responseTimeMs(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ResponseTimeMs, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PortStatus_responseTimeMs(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PortStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PortStatus_error(ctx context.Context, field graphql.CollectedField, obj *model.PortStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PortStatus_error(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Error, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PortStatus_error(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PortStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_node(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_node(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Node(rctx, fc.Args["id"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(model.Node)
	fc.Result = res
	return ec.marshalONode2backendgraphmodelNode(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_node(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("FieldContext.Child cannot be called on type INTERFACE")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_node_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_health(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_health(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Health(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.HealthStatus)
	fc.Result = res
	return ec.marshalNHealthStatus2backendgraphmodelHealthStatus(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_health(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "status":
				return ec.fieldContext_HealthStatus_status(ctx, field)
			case "version":
				return ec.fieldContext_HealthStatus_version(ctx, field)
			case "uptime":
				return ec.fieldContext_HealthStatus_uptime(ctx, field)
			case "connectedRouters":
				return ec.fieldContext_HealthStatus_connectedRouters(ctx, field)
			case "checkedAt":
				return ec.fieldContext_HealthStatus_checkedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type HealthStatus", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_version(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_version(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Version(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_version(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_router(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_router(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Router(rctx, fc.Args["id"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Router)
	fc.Result = res
	return ec.marshalORouter2backendgraphmodelRouter(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_router(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Router_id(ctx, field)
			case "name":
				return ec.fieldContext_Router_name(ctx, field)
			case "host":
				return ec.fieldContext_Router_host(ctx, field)
			case "port":
				return ec.fieldContext_Router_port(ctx, field)
			case "status":
				return ec.fieldContext_Router_status(ctx, field)
			case "platform":
				return ec.fieldContext_Router_platform(ctx, field)
			case "version":
				return ec.fieldContext_Router_version(ctx, field)
			case "model":
				return ec.fieldContext_Router_model(ctx, field)
			case "uptime":
				return ec.fieldContext_Router_uptime(ctx, field)
			case "lastConnected":
				return ec.fieldContext_Router_lastConnected(ctx, field)
			case "createdAt":
				return ec.fieldContext_Router_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Router_updatedAt(ctx, field)
			case "capabilities":
				return ec.fieldContext_Router_capabilities(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Router", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_router_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_routers(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_routers(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Routers(rctx, fc.Args["status"].(*model.ConnectionStatus), fc.Args["pagination"].(*model.PaginationInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.RouterConnection)
	fc.Result = res
	return ec.marshalNRouterConnection2backendgraphmodelRouterConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_routers(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "edges":
				return ec.fieldContext_RouterConnection_edges(ctx, field)
			case "pageInfo":
				return ec.fieldContext_RouterConnection_pageInfo(ctx, field)
			case "totalCount":
				return ec.fieldContext_RouterConnection_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RouterConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_routers_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_interface(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_interface(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().Interface(rctx, fc.Args["routerId"].(string), fc.Args["id"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			requires, err := ec.unmarshalNString2string(ctx, []interface{}{"interface"})
			if err != nil {
				return nil, err
			}
			if ec.directives.Capability == nil {
				return nil, errors.New("directive capability is not implemented")
			}
			return ec.directives.Capability(ctx, nil, directive0, requires)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.Interface); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *backend/graph/model.Interface`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Interface)
	fc.Result = res
	return ec.marshalOInterface2backendgraphmodelInterface(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_interface(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Interface_id(ctx, field)
			case "name":
				return ec.fieldContext_Interface_name(ctx, field)
			case "type":
				return ec.fieldContext_Interface_type(ctx, field)
			case "enabled":
				return ec.fieldContext_Interface_enabled(ctx, field)
			case "running":
				return ec.fieldContext_Interface_running(ctx, field)
			case "macAddress":
				return ec.fieldContext_Interface_macAddress(ctx, field)
			case "mtu":
				return ec.fieldContext_Interface_mtu(ctx, field)
			case "comment":
				return ec.fieldContext_Interface_comment(ctx, field)
			case "txBytes":
				return ec.fieldContext_Interface_txBytes(ctx, field)
			case "rxBytes":
				return ec.fieldContext_Interface_rxBytes(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Interface", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_interface_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_interfaces(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_interfaces(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().Interfaces(rctx, fc.Args["routerId"].(string), fc.Args["type"].(*model.InterfaceType), fc.Args["pagination"].(*model.PaginationInput))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			requires, err := ec.unmarshalNString2string(ctx, []interface{}{"interface"})
			if err != nil {
				return nil, err
			}
			if ec.directives.Capability == nil {
				return nil, errors.New("directive capability is not implemented")
			}
			return ec.directives.Capability(ctx, nil, directive0, requires)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.InterfaceConnection); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *backend/graph/model.InterfaceConnection`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.InterfaceConnection)
	fc.Result = res
	return ec.marshalNInterfaceConnection2backendgraphmodelInterfaceConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_interfaces(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "edges":
				return ec.fieldContext_InterfaceConnection_edges(ctx, field)
			case "pageInfo":
				return ec.fieldContext_InterfaceConnection_pageInfo(ctx, field)
			case "totalCount":
				return ec.fieldContext_InterfaceConnection_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type InterfaceConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_interfaces_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_routerCapabilities(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_routerCapabilities(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().RouterCapabilities(rctx, fc.Args["routerId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.RouterCapabilities)
	fc.Result = res
	return ec.marshalORouterCapabilities2backendgraphmodelRouterCapabilities(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_routerCapabilities(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hardware":
				return ec.fieldContext_RouterCapabilities_hardware(ctx, field)
			case "software":
				return ec.fieldContext_RouterCapabilities_software(ctx, field)
			case "container":
				return ec.fieldContext_RouterCapabilities_container(ctx, field)
			case "capabilities":
				return ec.fieldContext_RouterCapabilities_capabilities(ctx, field)
			case "vifRequirements":
				return ec.fieldContext_RouterCapabilities_vifRequirements(ctx, field)
			case "supportedFeatures":
				return ec.fieldContext_RouterCapabilities_supportedFeatures(ctx, field)
			case "unsupportedFeatures":
				return ec.fieldContext_RouterCapabilities_unsupportedFeatures(ctx, field)
			case "routerOSVersion":
				return ec.fieldContext_RouterCapabilities_routerOSVersion(ctx, field)
			case "detectedAt":
				return ec.fieldContext_RouterCapabilities_detectedAt(ctx, field)
			case "expiresAt":
				return ec.fieldContext_RouterCapabilities_expiresAt(ctx, field)
			case "isRefreshing":
				return ec.fieldContext_RouterCapabilities_isRefreshing(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RouterCapabilities", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_routerCapabilities_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_isFeatureSupported(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_isFeatureSupported(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().IsFeatureSupported(rctx, fc.Args["routerId"].(string), fc.Args["featureId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.FeatureSupport)
	fc.Result = res
	return ec.marshalNFeatureSupport2backendgraphmodelFeatureSupport(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_isFeatureSupported(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "featureId":
				return ec.fieldContext_FeatureSupport_featureId(ctx, field)
			case "name":
				return ec.fieldContext_FeatureSupport_name(ctx, field)
			case "supported":
				return ec.fieldContext_FeatureSupport_supported(ctx, field)
			case "level":
				return ec.fieldContext_FeatureSupport_level(ctx, field)
			case "reason":
				return ec.fieldContext_FeatureSupport_reason(ctx, field)
			case "requiredVersion":
				return ec.fieldContext_FeatureSupport_requiredVersion(ctx, field)
			case "upgradeUrl":
				return ec.fieldContext_FeatureSupport_upgradeUrl(ctx, field)
			case "requiredPackages":
				return ec.fieldContext_FeatureSupport_requiredPackages(ctx, field)
			case "missingPackages":
				return ec.fieldContext_FeatureSupport_missingPackages(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FeatureSupport", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_isFeatureSupported_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_supportedFeatures(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_supportedFeatures(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().SupportedFeatures(rctx, fc.Args["routerId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.FeatureSupport)
	fc.Result = res
	return ec.marshalNFeatureSupport2backendgraphmodelFeatureSupport(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_supportedFeatures(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "featureId":
				return ec.fieldContext_FeatureSupport_featureId(ctx, field)
			case "name":
				return ec.fieldContext_FeatureSupport_name(ctx, field)
			case "supported":
				return ec.fieldContext_FeatureSupport_supported(ctx, field)
			case "level":
				return ec.fieldContext_FeatureSupport_level(ctx, field)
			case "reason":
				return ec.fieldContext_FeatureSupport_reason(ctx, field)
			case "requiredVersion":
				return ec.fieldContext_FeatureSupport_requiredVersion(ctx, field)
			case "upgradeUrl":
				return ec.fieldContext_FeatureSupport_upgradeUrl(ctx, field)
			case "requiredPackages":
				return ec.fieldContext_FeatureSupport_requiredPackages(ctx, field)
			case "missingPackages":
				return ec.fieldContext_FeatureSupport_missingPackages(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FeatureSupport", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_supportedFeatures_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_unsupportedFeatures(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_unsupportedFeatures(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().UnsupportedFeatures(rctx, fc.Args["routerId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.FeatureSupport)
	fc.Result = res
	return ec.marshalNFeatureSupport2backendgraphmodelFeatureSupport(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_unsupportedFeatures(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "featureId":
				return ec.fieldContext_FeatureSupport_featureId(ctx, field)
			case "name":
				return ec.fieldContext_FeatureSupport_name(ctx, field)
			case "supported":
				return ec.fieldContext_FeatureSupport_supported(ctx, field)
			case "level":
				return ec.fieldContext_FeatureSupport_level(ctx, field)
			case "reason":
				return ec.fieldContext_FeatureSupport_reason(ctx, field)
			case "requiredVersion":
				return ec.fieldContext_FeatureSupport_requiredVersion(ctx, field)
			case "upgradeUrl":
				return ec.fieldContext_FeatureSupport_upgradeUrl(ctx, field)
			case "requiredPackages":
				return ec.fieldContext_FeatureSupport_requiredPackages(ctx, field)
			case "missingPackages":
				return ec.fieldContext_FeatureSupport_missingPackages(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FeatureSupport", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_unsupportedFeatures_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_compatibilityMatrix(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_compatibilityMatrix(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().CompatibilityMatrix(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.FeatureCompatibilityInfo)
	fc.Result = res
	return ec.marshalNFeatureCompatibilityInfo2backendgraphmodelFeatureCompatibilityInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_compatibilityMatrix(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "featureId":
				return ec.fieldContext_FeatureCompatibilityInfo_featureId(ctx, field)
			case "name":
				return ec.fieldContext_FeatureCompatibilityInfo_name(ctx, field)
			case "minVersion":
				return ec.fieldContext_FeatureCompatibilityInfo_minVersion(ctx, field)
			case "maxVersion":
				return ec.fieldContext_FeatureCompatibilityInfo_maxVersion(ctx, field)
			case "minVersionCHR":
				return ec.fieldContext_FeatureCompatibilityInfo_minVersionCHR(ctx, field)
			case "requiredPackages":
				return ec.fieldContext_FeatureCompatibilityInfo_requiredPackages(ctx, field)
			case "dependsOn":
				return ec.fieldContext_FeatureCompatibilityInfo_dependsOn(ctx, field)
			case "upgradeUrl":
				return ec.fieldContext_FeatureCompatibilityInfo_upgradeUrl(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FeatureCompatibilityInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_upgradeRecommendation(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_upgradeRecommendation(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().UpgradeRecommendation(rctx, fc.Args["routerId"].(string), fc.Args["featureId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.UpgradeRecommendation)
	fc.Result = res
	return ec.marshalOUpgradeRecommendation2backendgraphmodelUpgradeRecommendation(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_upgradeRecommendation(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "featureId":
				return ec.fieldContext_UpgradeRecommendation_featureId(ctx, field)
			case "featureName":
				return ec.fieldContext_UpgradeRecommendation_featureName(ctx, field)
			case "currentVersion":
				return ec.fieldContext_UpgradeRecommendation_currentVersion(ctx, field)
			case "requiredVersion":
				return ec.fieldContext_UpgradeRecommendation_requiredVersion(ctx, field)
			case "isMajorUpgrade":
				return ec.fieldContext_UpgradeRecommendation_isMajorUpgrade(ctx, field)
			case "priority":
				return ec.fieldContext_UpgradeRecommendation_priority(ctx, field)
			case "steps":
				return ec.fieldContext_UpgradeRecommendation_steps(ctx, field)
			case "impact":
				return ec.fieldContext_UpgradeRecommendation_impact(ctx, field)
			case "documentationUrl":
				return ec.fieldContext_UpgradeRecommendation_documentationUrl(ctx, field)
			case "warnings":
				return ec.fieldContext_UpgradeRecommendation_warnings(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UpgradeRecommendation", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_upgradeRecommendation_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_upgradeRecommendations(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_upgradeRecommendations(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().UpgradeRecommendations(rctx, fc.Args["routerId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.UpgradeRecommendation)
	fc.Result = res
	return ec.marshalNUpgradeRecommendation2backendgraphmodelUpgradeRecommendation(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_upgradeRecommendations(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "featureId":
				return ec.fieldContext_UpgradeRecommendation_featureId(ctx, field)
			case "featureName":
				return ec.fieldContext_UpgradeRecommendation_featureName(ctx, field)
			case "currentVersion":
				return ec.fieldContext_UpgradeRecommendation_currentVersion(ctx, field)
			case "requiredVersion":
				return ec.fieldContext_UpgradeRecommendation_requiredVersion(ctx, field)
			case "isMajorUpgrade":
				return ec.fieldContext_UpgradeRecommendation_isMajorUpgrade(ctx, field)
			case "priority":
				return ec.fieldContext_UpgradeRecommendation_priority(ctx, field)
			case "steps":
				return ec.fieldContext_UpgradeRecommendation_steps(ctx, field)
			case "impact":
				return ec.fieldContext_UpgradeRecommendation_impact(ctx, field)
			case "documentationUrl":
				return ec.fieldContext_UpgradeRecommendation_documentationUrl(ctx, field)
			case "warnings":
				return ec.fieldContext_UpgradeRecommendation_warnings(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UpgradeRecommendation", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_upgradeRecommendations_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_me(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_me(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().Me(rctx)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Auth == nil {
				return nil, errors.New("directive auth is not implemented")
			}
			return ec.directives.Auth(ctx, nil, directive0, nil)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.User); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *backend/graph/model.User`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.User)
	fc.Result = res
	return ec.marshalOUser2backendgraphmodelUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_me(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "username":
				return ec.fieldContext_User_username(ctx, field)
			case "role":
				return ec.fieldContext_User_role(ctx, field)
			case "email":
				return ec.fieldContext_User_email(ctx, field)
			case "displayName":
				return ec.fieldContext_User_displayName(ctx, field)
			case "createdAt":
				return ec.fieldContext_User_createdAt(ctx, field)
			case "lastLoginAt":
				return ec.fieldContext_User_lastLoginAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_mySessions(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_mySessions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().MySessions(rctx)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Auth == nil {
				return nil, errors.New("directive auth is not implemented")
			}
			return ec.directives.Auth(ctx, nil, directive0, nil)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*model.Session); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*backend/graph/model.Session`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.Session)
	fc.Result = res
	return ec.marshalNSession2backendgraphmodelSession(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_mySessions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Session_id(ctx, field)
			case "ipAddress":
				return ec.fieldContext_Session_ipAddress(ctx, field)
			case "userAgent":
				return ec.fieldContext_Session_userAgent(ctx, field)
			case "createdAt":
				return ec.fieldContext_Session_createdAt(ctx, field)
			case "lastActivity":
				return ec.fieldContext_Session_lastActivity(ctx, field)
			case "isCurrent":
				return ec.fieldContext_Session_isCurrent(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Session", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_connectionDetails(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_connectionDetails(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().ConnectionDetails(rctx, fc.Args["routerId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.ConnectionDetails)
	fc.Result = res
	return ec.marshalOConnectionDetails2backendgraphmodelConnectionDetails(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_connectionDetails(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "state":
				return ec.fieldContext_ConnectionDetails_state(ctx, field)
			case "protocol":
				return ec.fieldContext_ConnectionDetails_protocol(ctx, field)
			case "preferredProtocol":
				return ec.fieldContext_ConnectionDetails_preferredProtocol(ctx, field)
			case "connectedAt":
				return ec.fieldContext_ConnectionDetails_connectedAt(ctx, field)
			case "uptime":
				return ec.fieldContext_ConnectionDetails_uptime(ctx, field)
			case "disconnectedAt":
				return ec.fieldContext_ConnectionDetails_disconnectedAt(ctx, field)
			case "lastError":
				return ec.fieldContext_ConnectionDetails_lastError(ctx, field)
			case "lastErrorTime":
				return ec.fieldContext_ConnectionDetails_lastErrorTime(ctx, field)
			case "disconnectReason":
				return ec.fieldContext_ConnectionDetails_disconnectReason(ctx, field)
			case "reconnectAttempts":
				return ec.fieldContext_ConnectionDetails_reconnectAttempts(ctx, field)
			case "nextReconnectAt":
				return ec.fieldContext_ConnectionDetails_nextReconnectAt(ctx, field)
			case "circuitBreakerState":
				return ec.fieldContext_ConnectionDetails_circuitBreakerState(ctx, field)
			case "version":
				return ec.fieldContext_ConnectionDetails_version(ctx, field)
			case "lastHealthCheck":
				return ec.fieldContext_ConnectionDetails_lastHealthCheck(ctx, field)
			case "healthChecksPassed":
				return ec.fieldContext_ConnectionDetails_healthChecksPassed(ctx, field)
			case "healthChecksFailed":
				return ec.fieldContext_ConnectionDetails_healthChecksFailed(ctx, field)
			case "securityWarning":
				return ec.fieldContext_ConnectionDetails_securityWarning(ctx, field)
			case "upgradeRecommendation":
				return ec.fieldContext_ConnectionDetails_upgradeRecommendation(ctx, field)
			case "isLegacyProtocol":
				return ec.fieldContext_ConnectionDetails_isLegacyProtocol(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ConnectionDetails", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_connectionDetails_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_routerHealth(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_routerHealth(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().RouterHealth(rctx, fc.Args["routerId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.HealthCheckResult)
	fc.Result = res
	return ec.marshalOHealthCheckResult2backendgraphmodelHealthCheckResult(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_routerHealth(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "routerId":
				return ec.fieldContext_HealthCheckResult_routerId(ctx, field)
			case "healthy":
				return ec.fieldContext_HealthCheckResult_healthy(ctx, field)
			case "checkedAt":
				return ec.fieldContext_HealthCheckResult_checkedAt(ctx, field)
			case "responseTimeMs":
				return ec.fieldContext_HealthCheckResult_responseTimeMs(ctx, field)
			case "error":
				return ec.fieldContext_HealthCheckResult_error(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type HealthCheckResult", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_routerHealth_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_connectionStats(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_connectionStats(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().ConnectionStats(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.ConnectionStats)
	fc.Result = res
	return ec.marshalNConnectionStats2backendgraphmodelConnectionStats(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_connectionStats(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "totalConnections":
				return ec.fieldContext_ConnectionStats_totalConnections(ctx, field)
			case "connected":
				return ec.fieldContext_ConnectionStats_connected(ctx, field)
			case "connecting":
				return ec.fieldContext_ConnectionStats_connecting(ctx, field)
			case "disconnected":
				return ec.fieldContext_ConnectionStats_disconnected(ctx, field)
			case "reconnecting":
				return ec.fieldContext_ConnectionStats_reconnecting(ctx, field)
			case "error":
				return ec.fieldContext_ConnectionStats_error(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ConnectionStats", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_routerCredentials(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_routerCredentials(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().RouterCredentials(rctx, fc.Args["routerId"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Auth == nil {
				return nil, errors.New("directive auth is not implemented")
			}
			return ec.directives.Auth(ctx, nil, directive0, nil)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.RouterCredentials); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *backend/graph/model.RouterCredentials`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.RouterCredentials)
	fc.Result = res
	return ec.marshalORouterCredentials2backendgraphmodelRouterCredentials(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_routerCredentials(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "routerId":
				return ec.fieldContext_RouterCredentials_routerId(ctx, field)
			case "username":
				return ec.fieldContext_RouterCredentials_username(ctx, field)
			case "hasPassword":
				return ec.fieldContext_RouterCredentials_hasPassword(ctx, field)
			case "encryptionStatus":
				return ec.fieldContext_RouterCredentials_encryptionStatus(ctx, field)
			case "keyVersion":
				return ec.fieldContext_RouterCredentials_keyVersion(ctx, field)
			case "lastUpdated":
				return ec.fieldContext_RouterCredentials_lastUpdated(ctx, field)
			case "createdAt":
				return ec.fieldContext_RouterCredentials_createdAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RouterCredentials", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_routerCredentials_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_connectionAttempts(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_connectionAttempts(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().ConnectionAttempts(rctx, fc.Args["routerId"].(string), fc.Args["limit"].(*int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.ConnectionAttempt)
	fc.Result = res
	return ec.marshalNConnectionAttempt2backendgraphmodelConnectionAttempt(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_connectionAttempts(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "protocol":
				return ec.fieldContext_ConnectionAttempt_protocol(ctx, field)
			case "startedAt":
				return ec.fieldContext_ConnectionAttempt_startedAt(ctx, field)
			case "endedAt":
				return ec.fieldContext_ConnectionAttempt_endedAt(ctx, field)
			case "success":
				return ec.fieldContext_ConnectionAttempt_success(ctx, field)
			case "errorCode":
				return ec.fieldContext_ConnectionAttempt_errorCode(ctx, field)
			case "errorMessage":
				return ec.fieldContext_ConnectionAttempt_errorMessage(ctx, field)
			case "errorCategory":
				return ec.fieldContext_ConnectionAttempt_errorCategory(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ConnectionAttempt", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_connectionAttempts_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_circuitBreakerStatus(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_circuitBreakerStatus(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().CircuitBreakerStatus(rctx, fc.Args["routerId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.CircuitBreakerStatus)
	fc.Result = res
	return ec.marshalNCircuitBreakerStatus2backendgraphmodelCircuitBreakerStatus(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_circuitBreakerStatus(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "routerId":
				return ec.fieldContext_CircuitBreakerStatus_routerId(ctx, field)
			case "state":
				return ec.fieldContext_CircuitBreakerStatus_state(ctx, field)
			case "failureCount":
				return ec.fieldContext_CircuitBreakerStatus_failureCount(ctx, field)
			case "failureThreshold":
				return ec.fieldContext_CircuitBreakerStatus_failureThreshold(ctx, field)
			case "cooldownRemainingSeconds":
				return ec.fieldContext_CircuitBreakerStatus_cooldownRemainingSeconds(ctx, field)
			case "lastFailureAt":
				return ec.fieldContext_CircuitBreakerStatus_lastFailureAt(ctx, field)
			case "lastSuccessAt":
				return ec.fieldContext_CircuitBreakerStatus_lastSuccessAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CircuitBreakerStatus", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_circuitBreakerStatus_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_scanStatus(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_scanStatus(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().ScanStatus(rctx, fc.Args["taskId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.ScanTask)
	fc.Result = res
	return ec.marshalOScanTask2backendgraphmodelScanTask(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_scanStatus(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ScanTask_id(ctx, field)
			case "subnet":
				return ec.fieldContext_ScanTask_subnet(ctx, field)
			case "status":
				return ec.fieldContext_ScanTask_status(ctx, field)
			case "progress":
				return ec.fieldContext_ScanTask_progress(ctx, field)
			case "results":
				return ec.fieldContext_ScanTask_results(ctx, field)
			case "startTime":
				return ec.fieldContext_ScanTask_startTime(ctx, field)
			case "endTime":
				return ec.fieldContext_ScanTask_endTime(ctx, field)
			case "error":
				return ec.fieldContext_ScanTask_error(ctx, field)
			case "totalIPs":
				return ec.fieldContext_ScanTask_totalIPs(ctx, field)
			case "scannedIPs":
				return ec.fieldContext_ScanTask_scannedIPs(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ScanTask", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_scanStatus_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_scanHistory(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_scanHistory(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().ScanHistory(rctx, fc.Args["limit"].(*int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.ScanTask)
	fc.Result = res
	return ec.marshalNScanTask2backendgraphmodelScanTask(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_scanHistory(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ScanTask_id(ctx, field)
			case "subnet":
				return ec.fieldContext_ScanTask_subnet(ctx, field)
			case "status":
				return ec.fieldContext_ScanTask_status(ctx, field)
			case "progress":
				return ec.fieldContext_ScanTask_progress(ctx, field)
			case "results":
				return ec.fieldContext_ScanTask_results(ctx, field)
			case "startTime":
				return ec.fieldContext_ScanTask_startTime(ctx, field)
			case "endTime":
				return ec.fieldContext_ScanTask_endTime(ctx, field)
			case "error":
				return ec.fieldContext_ScanTask_error(ctx, field)
			case "totalIPs":
				return ec.fieldContext_ScanTask_totalIPs(ctx, field)
			case "scannedIPs":
				return ec.fieldContext_ScanTask_scannedIPs(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ScanTask", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_scanHistory_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query___type(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query___type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectType(fc.Args["name"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query___type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query___type_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query___schema(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query___schema(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectSchema()
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Schema)
	fc.Result = res
	return ec.marshalO__Schema2githubcom99designsgqlgengraphqlintrospectionSchema(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query___schema(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "description":
				return ec.fieldContext___Schema_description(ctx, field)
			case "types":
				return ec.fieldContext___Schema_types(ctx, field)
			case "queryType":
				return ec.fieldContext___Schema_queryType(ctx, field)
			case "mutationType":
				return ec.fieldContext___Schema_mutationType(ctx, field)
			case "subscriptionType":
				return ec.fieldContext___Schema_subscriptionType(ctx, field)
			case "directives":
				return ec.fieldContext___Schema_directives(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Schema", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ReconnectRouterPayload_router(ctx context.Context, field graphql.CollectedField, obj *model.ReconnectRouterPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ReconnectRouterPayload_router(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Router, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Router)
	fc.Result = res
	return ec.marshalORouter2backendgraphmodelRouter(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ReconnectRouterPayload_router(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ReconnectRouterPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Router_id(ctx, field)
			case "name":
				return ec.fieldContext_Router_name(ctx, field)
			case "host":
				return ec.fieldContext_Router_host(ctx, field)
			case "port":
				return ec.fieldContext_Router_port(ctx, field)
			case "status":
				return ec.fieldContext_Router_status(ctx, field)
			case "platform":
				return ec.fieldContext_Router_platform(ctx, field)
			case "version":
				return ec.fieldContext_Router_version(ctx, field)
			case "model":
				return ec.fieldContext_Router_model(ctx, field)
			case "uptime":
				return ec.fieldContext_Router_uptime(ctx, field)
			case "lastConnected":
				return ec.fieldContext_Router_lastConnected(ctx, field)
			case "createdAt":
				return ec.fieldContext_Router_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Router_updatedAt(ctx, field)
			case "capabilities":
				return ec.fieldContext_Router_capabilities(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Router", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ReconnectRouterPayload_connectionDetails(ctx context.Context, field graphql.CollectedField, obj *model.ReconnectRouterPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ReconnectRouterPayload_connectionDetails(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ConnectionDetails, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.ConnectionDetails)
	fc.Result = res
	return ec.marshalOConnectionDetails2backendgraphmodelConnectionDetails(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ReconnectRouterPayload_connectionDetails(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ReconnectRouterPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "state":
				return ec.fieldContext_ConnectionDetails_state(ctx, field)
			case "protocol":
				return ec.fieldContext_ConnectionDetails_protocol(ctx, field)
			case "preferredProtocol":
				return ec.fieldContext_ConnectionDetails_preferredProtocol(ctx, field)
			case "connectedAt":
				return ec.fieldContext_ConnectionDetails_connectedAt(ctx, field)
			case "uptime":
				return ec.fieldContext_ConnectionDetails_uptime(ctx, field)
			case "disconnectedAt":
				return ec.fieldContext_ConnectionDetails_disconnectedAt(ctx, field)
			case "lastError":
				return ec.fieldContext_ConnectionDetails_lastError(ctx, field)
			case "lastErrorTime":
				return ec.fieldContext_ConnectionDetails_lastErrorTime(ctx, field)
			case "disconnectReason":
				return ec.fieldContext_ConnectionDetails_disconnectReason(ctx, field)
			case "reconnectAttempts":
				return ec.fieldContext_ConnectionDetails_reconnectAttempts(ctx, field)
			case "nextReconnectAt":
				return ec.fieldContext_ConnectionDetails_nextReconnectAt(ctx, field)
			case "circuitBreakerState":
				return ec.fieldContext_ConnectionDetails_circuitBreakerState(ctx, field)
			case "version":
				return ec.fieldContext_ConnectionDetails_version(ctx, field)
			case "lastHealthCheck":
				return ec.fieldContext_ConnectionDetails_lastHealthCheck(ctx, field)
			case "healthChecksPassed":
				return ec.fieldContext_ConnectionDetails_healthChecksPassed(ctx, field)
			case "healthChecksFailed":
				return ec.fieldContext_ConnectionDetails_healthChecksFailed(ctx, field)
			case "securityWarning":
				return ec.fieldContext_ConnectionDetails_securityWarning(ctx, field)
			case "upgradeRecommendation":
				return ec.fieldContext_ConnectionDetails_upgradeRecommendation(ctx, field)
			case "isLegacyProtocol":
				return ec.fieldContext_ConnectionDetails_isLegacyProtocol(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ConnectionDetails", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ReconnectRouterPayload_initiated(ctx context.Context, field graphql.CollectedField, obj *model.ReconnectRouterPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ReconnectRouterPayload_initiated(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Initiated, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ReconnectRouterPayload_initiated(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ReconnectRouterPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ReconnectRouterPayload_waitTimeMs(ctx context.Context, field graphql.CollectedField, obj *model.ReconnectRouterPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ReconnectRouterPayload_waitTimeMs(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.WaitTimeMs, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ReconnectRouterPayload_waitTimeMs(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ReconnectRouterPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ReconnectRouterPayload_errors(ctx context.Context, field graphql.CollectedField, obj *model.ReconnectRouterPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ReconnectRouterPayload_errors(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Errors, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.MutationError)
	fc.Result = res
	return ec.marshalOMutationError2backendgraphmodelMutationError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ReconnectRouterPayload_errors(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ReconnectRouterPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "code":
				return ec.fieldContext_MutationError_code(ctx, field)
			case "message":
				return ec.fieldContext_MutationError_message(ctx, field)
			case "field":
				return ec.fieldContext_MutationError_field(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MutationError", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RefreshCapabilitiesPayload_capabilities(ctx context.Context, field graphql.CollectedField, obj *model.RefreshCapabilitiesPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RefreshCapabilitiesPayload_capabilities(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Capabilities, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.RouterCapabilities)
	fc.Result = res
	return ec.marshalORouterCapabilities2backendgraphmodelRouterCapabilities(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RefreshCapabilitiesPayload_capabilities(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RefreshCapabilitiesPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hardware":
				return ec.fieldContext_RouterCapabilities_hardware(ctx, field)
			case "software":
				return ec.fieldContext_RouterCapabilities_software(ctx, field)
			case "container":
				return ec.fieldContext_RouterCapabilities_container(ctx, field)
			case "capabilities":
				return ec.fieldContext_RouterCapabilities_capabilities(ctx, field)
			case "vifRequirements":
				return ec.fieldContext_RouterCapabilities_vifRequirements(ctx, field)
			case "supportedFeatures":
				return ec.fieldContext_RouterCapabilities_supportedFeatures(ctx, field)
			case "unsupportedFeatures":
				return ec.fieldContext_RouterCapabilities_unsupportedFeatures(ctx, field)
			case "routerOSVersion":
				return ec.fieldContext_RouterCapabilities_routerOSVersion(ctx, field)
			case "detectedAt":
				return ec.fieldContext_RouterCapabilities_detectedAt(ctx, field)
			case "expiresAt":
				return ec.fieldContext_RouterCapabilities_expiresAt(ctx, field)
			case "isRefreshing":
				return ec.fieldContext_RouterCapabilities_isRefreshing(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RouterCapabilities", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RefreshCapabilitiesPayload_errors(ctx context.Context, field graphql.CollectedField, obj *model.RefreshCapabilitiesPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RefreshCapabilitiesPayload_errors(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Errors, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.MutationError)
	fc.Result = res
	return ec.marshalOMutationError2backendgraphmodelMutationError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RefreshCapabilitiesPayload_errors(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RefreshCapabilitiesPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "code":
				return ec.fieldContext_MutationError_code(ctx, field)
			case "message":
				return ec.fieldContext_MutationError_message(ctx, field)
			case "field":
				return ec.fieldContext_MutationError_field(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MutationError", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ResourceUpdatedEvent_resourceId(ctx context.Context, field graphql.CollectedField, obj *model.ResourceUpdatedEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ResourceUpdatedEvent_resourceId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ResourceID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ResourceUpdatedEvent_resourceId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ResourceUpdatedEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ResourceUpdatedEvent_resourceType(ctx context.Context, field graphql.CollectedField, obj *model.ResourceUpdatedEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ResourceUpdatedEvent_resourceType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ResourceType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ResourceUpdatedEvent_resourceType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ResourceUpdatedEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ResourceUpdatedEvent_routerId(ctx context.Context, field graphql.CollectedField, obj *model.ResourceUpdatedEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ResourceUpdatedEvent_routerId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RouterID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ResourceUpdatedEvent_routerId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ResourceUpdatedEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ResourceUpdatedEvent_version(ctx context.Context, field graphql.CollectedField, obj *model.ResourceUpdatedEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ResourceUpdatedEvent_version(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Version, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ResourceUpdatedEvent_version(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ResourceUpdatedEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ResourceUpdatedEvent_changedFields(ctx context.Context, field graphql.CollectedField, obj *model.ResourceUpdatedEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ResourceUpdatedEvent_changedFields(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ChangedFields, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ResourceUpdatedEvent_changedFields(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ResourceUpdatedEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ResourceUpdatedEvent_changeType(ctx context.Context, field graphql.CollectedField, obj *model.ResourceUpdatedEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ResourceUpdatedEvent_changeType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ChangeType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.ChangeType)
	fc.Result = res
	return ec.marshalNChangeType2backendgraphmodelChangeType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ResourceUpdatedEvent_changeType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ResourceUpdatedEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ChangeType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ResourceUpdatedEvent_timestamp(ctx context.Context, field graphql.CollectedField, obj *model.ResourceUpdatedEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ResourceUpdatedEvent_timestamp(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Timestamp, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNDateTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ResourceUpdatedEvent_timestamp(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ResourceUpdatedEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DateTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Router_id(ctx context.Context, field graphql.CollectedField, obj *model.Router) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Router_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Router_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Router",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Router_name(ctx context.Context, field graphql.CollectedField, obj *model.Router) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Router_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Router_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Router",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Router_host(ctx context.Context, field graphql.CollectedField, obj *model.Router) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Router_host(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Host, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Router_host(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Router",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Router_port(ctx context.Context, field graphql.CollectedField, obj *model.Router) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Router_port(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Port, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Router_port(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Router",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Router_status(ctx context.Context, field graphql.CollectedField, obj *model.Router) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Router_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.ConnectionStatus)
	fc.Result = res
	return ec.marshalNConnectionStatus2backendgraphmodelConnectionStatus(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Router_status(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Router",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ConnectionStatus does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Router_platform(ctx context.Context, field graphql.CollectedField, obj *model.Router) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Router_platform(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Platform, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.RouterPlatform)
	fc.Result = res
	return ec.marshalNRouterPlatform2backendgraphmodelRouterPlatform(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Router_platform(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Router",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type RouterPlatform does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Router_version(ctx context.Context, field graphql.CollectedField, obj *model.Router) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Router_version(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Version, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Router_version(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Router",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Router_model(ctx context.Context, field graphql.CollectedField, obj *model.Router) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Router_model(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Model, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Router_model(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Router",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Router_uptime(ctx context.Context, field graphql.CollectedField, obj *model.Router) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Router_uptime(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Uptime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Duration)
	fc.Result = res
	return ec.marshalODuration2backendgraphmodelDuration(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Router_uptime(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Router",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Duration does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Router_lastConnected(ctx context.Context, field graphql.CollectedField, obj *model.Router) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Router_lastConnected(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LastConnected, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalODateTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Router_lastConnected(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Router",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DateTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Router_createdAt(ctx context.Context, field graphql.CollectedField, obj *model.Router) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Router_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNDateTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Router_createdAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Router",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DateTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Router_updatedAt(ctx context.Context, field graphql.CollectedField, obj *model.Router) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Router_updatedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNDateTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Router_updatedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Router",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DateTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Router_capabilities(ctx context.Context, field graphql.CollectedField, obj *model.Router) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Router_capabilities(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Capabilities, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.RouterCapabilities)
	fc.Result = res
	return ec.marshalORouterCapabilities2backendgraphmodelRouterCapabilities(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Router_capabilities(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Router",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hardware":
				return ec.fieldContext_RouterCapabilities_hardware(ctx, field)
			case "software":
				return ec.fieldContext_RouterCapabilities_software(ctx, field)
			case "container":
				return ec.fieldContext_RouterCapabilities_container(ctx, field)
			case "capabilities":
				return ec.fieldContext_RouterCapabilities_capabilities(ctx, field)
			case "vifRequirements":
				return ec.fieldContext_RouterCapabilities_vifRequirements(ctx, field)
			case "supportedFeatures":
				return ec.fieldContext_RouterCapabilities_supportedFeatures(ctx, field)
			case "unsupportedFeatures":
				return ec.fieldContext_RouterCapabilities_unsupportedFeatures(ctx, field)
			case "routerOSVersion":
				return ec.fieldContext_RouterCapabilities_routerOSVersion(ctx, field)
			case "detectedAt":
				return ec.fieldContext_RouterCapabilities_detectedAt(ctx, field)
			case "expiresAt":
				return ec.fieldContext_RouterCapabilities_expiresAt(ctx, field)
			case "isRefreshing":
				return ec.fieldContext_RouterCapabilities_isRefreshing(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RouterCapabilities", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RouterAddedEvent_router(ctx context.Context, field graphql.CollectedField, obj *model.RouterAddedEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RouterAddedEvent_router(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Router, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Router)
	fc.Result = res
	return ec.marshalNRouter2backendgraphmodelRouter(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RouterAddedEvent_router(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RouterAddedEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Router_id(ctx, field)
			case "name":
				return ec.fieldContext_Router_name(ctx, field)
			case "host":
				return ec.fieldContext_Router_host(ctx, field)
			case "port":
				return ec.fieldContext_Router_port(ctx, field)
			case "status":
				return ec.fieldContext_Router_status(ctx, field)
			case "platform":
				return ec.fieldContext_Router_platform(ctx, field)
			case "version":
				return ec.fieldContext_Router_version(ctx, field)
			case "model":
				return ec.fieldContext_Router_model(ctx, field)
			case "uptime":
				return ec.fieldContext_Router_uptime(ctx, field)
			case "lastConnected":
				return ec.fieldContext_Router_lastConnected(ctx, field)
			case "createdAt":
				return ec.fieldContext_Router_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Router_updatedAt(ctx, field)
			case "capabilities":
				return ec.fieldContext_Router_capabilities(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Router", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RouterAddedEvent_protocolUsed(ctx context.Context, field graphql.CollectedField, obj *model.RouterAddedEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RouterAddedEvent_protocolUsed(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ProtocolUsed, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.Protocol)
	fc.Result = res
	return ec.marshalNProtocol2backendgraphmodelProtocol(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RouterAddedEvent_protocolUsed(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RouterAddedEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Protocol does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RouterAddedEvent_addedBy(ctx context.Context, field graphql.CollectedField, obj *model.RouterAddedEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RouterAddedEvent_addedBy(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AddedBy, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RouterAddedEvent_addedBy(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RouterAddedEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RouterAddedEvent_timestamp(ctx context.Context, field graphql.CollectedField, obj *model.RouterAddedEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RouterAddedEvent_timestamp(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Timestamp, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNDateTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RouterAddedEvent_timestamp(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RouterAddedEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DateTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RouterCapabilities_hardware(ctx context.Context, field graphql.CollectedField, obj *model.RouterCapabilities) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RouterCapabilities_hardware(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Hardware, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.HardwareInfo)
	fc.Result = res
	return ec.marshalNHardwareInfo2backendgraphmodelHardwareInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RouterCapabilities_hardware(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RouterCapabilities",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "architecture":
				return ec.fieldContext_HardwareInfo_architecture(ctx, field)
			case "model":
				return ec.fieldContext_HardwareInfo_model(ctx, field)
			case "boardName":
				return ec.fieldContext_HardwareInfo_boardName(ctx, field)
			case "totalMemory":
				return ec.fieldContext_HardwareInfo_totalMemory(ctx, field)
			case "availableStorage":
				return ec.fieldContext_HardwareInfo_availableStorage(ctx, field)
			case "cpuCount":
				return ec.fieldContext_HardwareInfo_cpuCount(ctx, field)
			case "hasWirelessChip":
				return ec.fieldContext_HardwareInfo_hasWirelessChip(ctx, field)
			case "hasLTEModule":
				return ec.fieldContext_HardwareInfo_hasLTEModule(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type HardwareInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RouterCapabilities_software(ctx context.Context, field graphql.CollectedField, obj *model.RouterCapabilities) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RouterCapabilities_software(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Software, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.SoftwareInfo)
	fc.Result = res
	return ec.marshalNSoftwareInfo2backendgraphmodelSoftwareInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RouterCapabilities_software(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RouterCapabilities",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "version":
				return ec.fieldContext_SoftwareInfo_version(ctx, field)
			case "versionMajor":
				return ec.fieldContext_SoftwareInfo_versionMajor(ctx, field)
			case "versionMinor":
				return ec.fieldContext_SoftwareInfo_versionMinor(ctx, field)
			case "versionPatch":
				return ec.fieldContext_SoftwareInfo_versionPatch(ctx, field)
			case "installedPackages":
				return ec.fieldContext_SoftwareInfo_installedPackages(ctx, field)
			case "licenseLevel":
				return ec.fieldContext_SoftwareInfo_licenseLevel(ctx, field)
			case "updateChannel":
				return ec.fieldContext_SoftwareInfo_updateChannel(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SoftwareInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RouterCapabilities_container(ctx context.Context, field graphql.CollectedField, obj *model.RouterCapabilities) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RouterCapabilities_container(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Container, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.ContainerInfo)
	fc.Result = res
	return ec.marshalNContainerInfo2backendgraphmodelContainerInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RouterCapabilities_container(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RouterCapabilities",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "packageInstalled":
				return ec.fieldContext_ContainerInfo_packageInstalled(ctx, field)
			case "enabled":
				return ec.fieldContext_ContainerInfo_enabled(ctx, field)
			case "registryConfigured":
				return ec.fieldContext_ContainerInfo_registryConfigured(ctx, field)
			case "storageAvailable":
				return ec.fieldContext_ContainerInfo_storageAvailable(ctx, field)
			case "supportsNetworkNamespace":
				return ec.fieldContext_ContainerInfo_supportsNetworkNamespace(ctx, field)
			case "maxContainers":
				return ec.fieldContext_ContainerInfo_maxContainers(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ContainerInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RouterCapabilities_capabilities(ctx context.Context, field graphql.CollectedField, obj *model.RouterCapabilities) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RouterCapabilities_capabilities(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Capabilities, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.CapabilityEntry)
	fc.Result = res
	return ec.marshalNCapabilityEntry2backendgraphmodelCapabilityEntry(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RouterCapabilities_capabilities(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RouterCapabilities",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "capability":
				return ec.fieldContext_CapabilityEntry_capability(ctx, field)
			case "level":
				return ec.fieldContext_CapabilityEntry_level(ctx, field)
			case "description":
				return ec.fieldContext_CapabilityEntry_description(ctx, field)
			case "guidance":
				return ec.fieldContext_CapabilityEntry_guidance(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CapabilityEntry", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RouterCapabilities_vifRequirements(ctx context.Context, field graphql.CollectedField, obj *model.RouterCapabilities) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RouterCapabilities_vifRequirements(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.VifRequirements, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.VIFRequirements)
	fc.Result = res
	return ec.marshalNVIFRequirements2backendgraphmodelVIFRequirements(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RouterCapabilities_vifRequirements(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RouterCapabilities",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "met":
				return ec.fieldContext_VIFRequirements_met(ctx, field)
			case "routerOSVersion":
				return ec.fieldContext_VIFRequirements_routerOSVersion(ctx, field)
			case "containerPackage":
				return ec.fieldContext_VIFRequirements_containerPackage(ctx, field)
			case "containerEnabled":
				return ec.fieldContext_VIFRequirements_containerEnabled(ctx, field)
			case "sufficientStorage":
				return ec.fieldContext_VIFRequirements_sufficientStorage(ctx, field)
			case "networkNamespace":
				return ec.fieldContext_VIFRequirements_networkNamespace(ctx, field)
			case "missingReasons":
				return ec.fieldContext_VIFRequirements_missingReasons(ctx, field)
			case "guidanceSteps":
				return ec.fieldContext_VIFRequirements_guidanceSteps(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type VIFRequirements", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RouterCapabilities_supportedFeatures(ctx context.Context, field graphql.CollectedField, obj *model.RouterCapabilities) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RouterCapabilities_supportedFeatures(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SupportedFeatures, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.FeatureSupport)
	fc.Result = res
	return ec.marshalNFeatureSupport2backendgraphmodelFeatureSupport(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RouterCapabilities_supportedFeatures(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RouterCapabilities",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "featureId":
				return ec.fieldContext_FeatureSupport_featureId(ctx, field)
			case "name":
				return ec.fieldContext_FeatureSupport_name(ctx, field)
			case "supported":
				return ec.fieldContext_FeatureSupport_supported(ctx, field)
			case "level":
				return ec.fieldContext_FeatureSupport_level(ctx, field)
			case "reason":
				return ec.fieldContext_FeatureSupport_reason(ctx, field)
			case "requiredVersion":
				return ec.fieldContext_FeatureSupport_requiredVersion(ctx, field)
			case "upgradeUrl":
				return ec.fieldContext_FeatureSupport_upgradeUrl(ctx, field)
			case "requiredPackages":
				return ec.fieldContext_FeatureSupport_requiredPackages(ctx, field)
			case "missingPackages":
				return ec.fieldContext_FeatureSupport_missingPackages(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FeatureSupport", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RouterCapabilities_unsupportedFeatures(ctx context.Context, field graphql.CollectedField, obj *model.RouterCapabilities) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RouterCapabilities_unsupportedFeatures(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UnsupportedFeatures, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.FeatureSupport)
	fc.Result = res
	return ec.marshalNFeatureSupport2backendgraphmodelFeatureSupport(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RouterCapabilities_unsupportedFeatures(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RouterCapabilities",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "featureId":
				return ec.fieldContext_FeatureSupport_featureId(ctx, field)
			case "name":
				return ec.fieldContext_FeatureSupport_name(ctx, field)
			case "supported":
				return ec.fieldContext_FeatureSupport_supported(ctx, field)
			case "level":
				return ec.fieldContext_FeatureSupport_level(ctx, field)
			case "reason":
				return ec.fieldContext_FeatureSupport_reason(ctx, field)
			case "requiredVersion":
				return ec.fieldContext_FeatureSupport_requiredVersion(ctx, field)
			case "upgradeUrl":
				return ec.fieldContext_FeatureSupport_upgradeUrl(ctx, field)
			case "requiredPackages":
				return ec.fieldContext_FeatureSupport_requiredPackages(ctx, field)
			case "missingPackages":
				return ec.fieldContext_FeatureSupport_missingPackages(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FeatureSupport", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RouterCapabilities_routerOSVersion(ctx context.Context, field graphql.CollectedField, obj *model.RouterCapabilities) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RouterCapabilities_routerOSVersion(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RouterOSVersion, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.RouterOSVersion)
	fc.Result = res
	return ec.marshalNRouterOSVersion2backendgraphmodelRouterOSVersion(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RouterCapabilities_routerOSVersion(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RouterCapabilities",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "raw":
				return ec.fieldContext_RouterOSVersion_raw(ctx, field)
			case "major":
				return ec.fieldContext_RouterOSVersion_major(ctx, field)
			case "minor":
				return ec.fieldContext_RouterOSVersion_minor(ctx, field)
			case "patch":
				return ec.fieldContext_RouterOSVersion_patch(ctx, field)
			case "channel":
				return ec.fieldContext_RouterOSVersion_channel(ctx, field)
			case "isCHR":
				return ec.fieldContext_RouterOSVersion_isCHR(ctx, field)
			case "supportsFeature":
				return ec.fieldContext_RouterOSVersion_supportsFeature(ctx, field)
			case "isAtLeast":
				return ec.fieldContext_RouterOSVersion_isAtLeast(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RouterOSVersion", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RouterCapabilities_detectedAt(ctx context.Context, field graphql.CollectedField, obj *model.RouterCapabilities) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RouterCapabilities_detectedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DetectedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNDateTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RouterCapabilities_detectedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RouterCapabilities",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DateTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RouterCapabilities_expiresAt(ctx context.Context, field graphql.CollectedField, obj *model.RouterCapabilities) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RouterCapabilities_expiresAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ExpiresAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNDateTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RouterCapabilities_expiresAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RouterCapabilities",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DateTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RouterCapabilities_isRefreshing(ctx context.Context, field graphql.CollectedField, obj *model.RouterCapabilities) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RouterCapabilities_isRefreshing(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsRefreshing, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RouterCapabilities_isRefreshing(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RouterCapabilities",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RouterConnection_edges(ctx context.Context, field graphql.CollectedField, obj *model.RouterConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RouterConnection_edges(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Edges, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.RouterEdge)
	fc.Result = res
	return ec.marshalNRouterEdge2backendgraphmodelRouterEdge(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RouterConnection_edges(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RouterConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "node":
				return ec.fieldContext_RouterEdge_node(ctx, field)
			case "cursor":
				return ec.fieldContext_RouterEdge_cursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RouterEdge", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RouterConnection_pageInfo(ctx context.Context, field graphql.CollectedField, obj *model.RouterConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RouterConnection_pageInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.PageInfo)
	fc.Result = res
	return ec.marshalNPageInfo2backendgraphmodelPageInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RouterConnection_pageInfo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RouterConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			case "hasPreviousPage":
				return ec.fieldContext_PageInfo_hasPreviousPage(ctx, field)
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RouterConnection_totalCount(ctx context.Context, field graphql.CollectedField, obj *model.RouterConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RouterConnection_totalCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RouterConnection_totalCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RouterConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RouterCredentials_routerId(ctx context.Context, field graphql.CollectedField, obj *model.RouterCredentials) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RouterCredentials_routerId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RouterID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RouterCredentials_routerId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RouterCredentials",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RouterCredentials_username(ctx context.Context, field graphql.CollectedField, obj *model.RouterCredentials) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RouterCredentials_username(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Username, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RouterCredentials_username(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RouterCredentials",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RouterCredentials_hasPassword(ctx context.Context, field graphql.CollectedField, obj *model.RouterCredentials) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RouterCredentials_hasPassword(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HasPassword, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RouterCredentials_hasPassword(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RouterCredentials",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RouterCredentials_encryptionStatus(ctx context.Context, field graphql.CollectedField, obj *model.RouterCredentials) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RouterCredentials_encryptionStatus(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EncryptionStatus, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RouterCredentials_encryptionStatus(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RouterCredentials",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RouterCredentials_keyVersion(ctx context.Context, field graphql.CollectedField, obj *model.RouterCredentials) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RouterCredentials_keyVersion(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.KeyVersion, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RouterCredentials_keyVersion(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RouterCredentials",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RouterCredentials_lastUpdated(ctx context.Context, field graphql.CollectedField, obj *model.RouterCredentials) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RouterCredentials_lastUpdated(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LastUpdated, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNDateTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RouterCredentials_lastUpdated(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RouterCredentials",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DateTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RouterCredentials_createdAt(ctx context.Context, field graphql.CollectedField, obj *model.RouterCredentials) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RouterCredentials_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNDateTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RouterCredentials_createdAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RouterCredentials",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DateTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RouterEdge_node(ctx context.Context, field graphql.CollectedField, obj *model.RouterEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RouterEdge_node(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Node, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Router)
	fc.Result = res
	return ec.marshalNRouter2backendgraphmodelRouter(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RouterEdge_node(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RouterEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Router_id(ctx, field)
			case "name":
				return ec.fieldContext_Router_name(ctx, field)
			case "host":
				return ec.fieldContext_Router_host(ctx, field)
			case "port":
				return ec.fieldContext_Router_port(ctx, field)
			case "status":
				return ec.fieldContext_Router_status(ctx, field)
			case "platform":
				return ec.fieldContext_Router_platform(ctx, field)
			case "version":
				return ec.fieldContext_Router_version(ctx, field)
			case "model":
				return ec.fieldContext_Router_model(ctx, field)
			case "uptime":
				return ec.fieldContext_Router_uptime(ctx, field)
			case "lastConnected":
				return ec.fieldContext_Router_lastConnected(ctx, field)
			case "createdAt":
				return ec.fieldContext_Router_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Router_updatedAt(ctx, field)
			case "capabilities":
				return ec.fieldContext_Router_capabilities(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Router", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RouterEdge_cursor(ctx context.Context, field graphql.CollectedField, obj *model.RouterEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RouterEdge_cursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RouterEdge_cursor(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RouterEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RouterOSInfo_version(ctx context.Context, field graphql.CollectedField, obj *model.RouterOSInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RouterOSInfo_version(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Version, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RouterOSInfo_version(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RouterOSInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RouterOSInfo_boardName(ctx context.Context, field graphql.CollectedField, obj *model.RouterOSInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RouterOSInfo_boardName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BoardName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RouterOSInfo_boardName(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RouterOSInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RouterOSInfo_architecture(ctx context.Context, field graphql.CollectedField, obj *model.RouterOSInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RouterOSInfo_architecture(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Architecture, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RouterOSInfo_architecture(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RouterOSInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RouterOSInfo_platform(ctx context.Context, field graphql.CollectedField, obj *model.RouterOSInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RouterOSInfo_platform(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Platform, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RouterOSInfo_platform(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RouterOSInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RouterOSVersion_raw(ctx context.Context, field graphql.CollectedField, obj *model.RouterOSVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RouterOSVersion_raw(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Raw, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RouterOSVersion_raw(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RouterOSVersion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RouterOSVersion_major(ctx context.Context, field graphql.CollectedField, obj *model.RouterOSVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RouterOSVersion_major(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Major, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RouterOSVersion_major(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RouterOSVersion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RouterOSVersion_minor(ctx context.Context, field graphql.CollectedField, obj *model.RouterOSVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RouterOSVersion_minor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Minor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RouterOSVersion_minor(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RouterOSVersion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RouterOSVersion_patch(ctx context.Context, field graphql.CollectedField, obj *model.RouterOSVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RouterOSVersion_patch(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Patch, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RouterOSVersion_patch(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RouterOSVersion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RouterOSVersion_channel(ctx context.Context, field graphql.CollectedField, obj *model.RouterOSVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RouterOSVersion_channel(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Channel, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RouterOSVersion_channel(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RouterOSVersion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RouterOSVersion_isCHR(ctx context.Context, field graphql.CollectedField, obj *model.RouterOSVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RouterOSVersion_isCHR(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsChr, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RouterOSVersion_isCHR(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RouterOSVersion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RouterOSVersion_supportsFeature(ctx context.Context, field graphql.CollectedField, obj *model.RouterOSVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RouterOSVersion_supportsFeature(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SupportsFeature, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RouterOSVersion_supportsFeature(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RouterOSVersion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_RouterOSVersion_supportsFeature_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _RouterOSVersion_isAtLeast(ctx context.Context, field graphql.CollectedField, obj *model.RouterOSVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RouterOSVersion_isAtLeast(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsAtLeast, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RouterOSVersion_isAtLeast(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RouterOSVersion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_RouterOSVersion_isAtLeast_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _RouterStatusEvent_router(ctx context.Context, field graphql.CollectedField, obj *model.RouterStatusEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RouterStatusEvent_router(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Router, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Router)
	fc.Result = res
	return ec.marshalNRouter2backendgraphmodelRouter(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RouterStatusEvent_router(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RouterStatusEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Router_id(ctx, field)
			case "name":
				return ec.fieldContext_Router_name(ctx, field)
			case "host":
				return ec.fieldContext_Router_host(ctx, field)
			case "port":
				return ec.fieldContext_Router_port(ctx, field)
			case "status":
				return ec.fieldContext_Router_status(ctx, field)
			case "platform":
				return ec.fieldContext_Router_platform(ctx, field)
			case "version":
				return ec.fieldContext_Router_version(ctx, field)
			case "model":
				return ec.fieldContext_Router_model(ctx, field)
			case "uptime":
				return ec.fieldContext_Router_uptime(ctx, field)
			case "lastConnected":
				return ec.fieldContext_Router_lastConnected(ctx, field)
			case "createdAt":
				return ec.fieldContext_Router_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Router_updatedAt(ctx, field)
			case "capabilities":
				return ec.fieldContext_Router_capabilities(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Router", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RouterStatusEvent_previousStatus(ctx context.Context, field graphql.CollectedField, obj *model.RouterStatusEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RouterStatusEvent_previousStatus(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PreviousStatus, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.ConnectionStatus)
	fc.Result = res
	return ec.marshalNConnectionStatus2backendgraphmodelConnectionStatus(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RouterStatusEvent_previousStatus(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RouterStatusEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ConnectionStatus does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RouterStatusEvent_newStatus(ctx context.Context, field graphql.CollectedField, obj *model.RouterStatusEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RouterStatusEvent_newStatus(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NewStatus, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.ConnectionStatus)
	fc.Result = res
	return ec.marshalNConnectionStatus2backendgraphmodelConnectionStatus(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RouterStatusEvent_newStatus(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RouterStatusEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ConnectionStatus does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RouterStatusEvent_timestamp(ctx context.Context, field graphql.CollectedField, obj *model.RouterStatusEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RouterStatusEvent_timestamp(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Timestamp, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNDateTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RouterStatusEvent_timestamp(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RouterStatusEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DateTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ScanNetworkPayload_task(ctx context.Context, field graphql.CollectedField, obj *model.ScanNetworkPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ScanNetworkPayload_task(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Task, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.ScanTask)
	fc.Result = res
	return ec.marshalOScanTask2backendgraphmodelScanTask(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ScanNetworkPayload_task(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ScanNetworkPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ScanTask_id(ctx, field)
			case "subnet":
				return ec.fieldContext_ScanTask_subnet(ctx, field)
			case "status":
				return ec.fieldContext_ScanTask_status(ctx, field)
			case "progress":
				return ec.fieldContext_ScanTask_progress(ctx, field)
			case "results":
				return ec.fieldContext_ScanTask_results(ctx, field)
			case "startTime":
				return ec.fieldContext_ScanTask_startTime(ctx, field)
			case "endTime":
				return ec.fieldContext_ScanTask_endTime(ctx, field)
			case "error":
				return ec.fieldContext_ScanTask_error(ctx, field)
			case "totalIPs":
				return ec.fieldContext_ScanTask_totalIPs(ctx, field)
			case "scannedIPs":
				return ec.fieldContext_ScanTask_scannedIPs(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ScanTask", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ScanNetworkPayload_errors(ctx context.Context, field graphql.CollectedField, obj *model.ScanNetworkPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ScanNetworkPayload_errors(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Errors, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.MutationError)
	fc.Result = res
	return ec.marshalOMutationError2backendgraphmodelMutationError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ScanNetworkPayload_errors(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ScanNetworkPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "code":
				return ec.fieldContext_MutationError_code(ctx, field)
			case "message":
				return ec.fieldContext_MutationError_message(ctx, field)
			case "field":
				return ec.fieldContext_MutationError_field(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MutationError", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ScanProgressEvent_taskId(ctx context.Context, field graphql.CollectedField, obj *model.ScanProgressEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ScanProgressEvent_taskId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TaskID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ScanProgressEvent_taskId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ScanProgressEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ScanProgressEvent_progress(ctx context.Context, field graphql.CollectedField, obj *model.ScanProgressEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ScanProgressEvent_progress(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Progress, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ScanProgressEvent_progress(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ScanProgressEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ScanProgressEvent_devicesFound(ctx context.Context, field graphql.CollectedField, obj *model.ScanProgressEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ScanProgressEvent_devicesFound(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DevicesFound, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ScanProgressEvent_devicesFound(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ScanProgressEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ScanProgressEvent_currentIP(ctx context.Context, field graphql.CollectedField, obj *model.ScanProgressEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ScanProgressEvent_currentIP(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CurrentIP, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ScanProgressEvent_currentIP(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ScanProgressEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ScanProgressEvent_status(ctx context.Context, field graphql.CollectedField, obj *model.ScanProgressEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ScanProgressEvent_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.ScanStatus)
	fc.Result = res
	return ec.marshalNScanStatus2backendgraphmodelScanStatus(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ScanProgressEvent_status(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ScanProgressEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ScanStatus does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ScanProgressEvent_timestamp(ctx context.Context, field graphql.CollectedField, obj *model.ScanProgressEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ScanProgressEvent_timestamp(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Timestamp, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNDateTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ScanProgressEvent_timestamp(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ScanProgressEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DateTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ScanTask_id(ctx context.Context, field graphql.CollectedField, obj *model.ScanTask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ScanTask_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ScanTask_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ScanTask",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ScanTask_subnet(ctx context.Context, field graphql.CollectedField, obj *model.ScanTask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ScanTask_subnet(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Subnet, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ScanTask_subnet(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ScanTask",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ScanTask_status(ctx context.Context, field graphql.CollectedField, obj *model.ScanTask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ScanTask_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.ScanStatus)
	fc.Result = res
	return ec.marshalNScanStatus2backendgraphmodelScanStatus(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ScanTask_status(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ScanTask",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ScanStatus does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ScanTask_progress(ctx context.Context, field graphql.CollectedField, obj *model.ScanTask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ScanTask_progress(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Progress, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ScanTask_progress(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ScanTask",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ScanTask_results(ctx context.Context, field graphql.CollectedField, obj *model.ScanTask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ScanTask_results(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Results, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.DiscoveredDevice)
	fc.Result = res
	return ec.marshalNDiscoveredDevice2backendgraphmodelDiscoveredDevice(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ScanTask_results(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ScanTask",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "ip":
				return ec.fieldContext_DiscoveredDevice_ip(ctx, field)
			case "hostname":
				return ec.fieldContext_DiscoveredDevice_hostname(ctx, field)
			case "ports":
				return ec.fieldContext_DiscoveredDevice_ports(ctx, field)
			case "deviceType":
				return ec.fieldContext_DiscoveredDevice_deviceType(ctx, field)
			case "vendor":
				return ec.fieldContext_DiscoveredDevice_vendor(ctx, field)
			case "routerOSInfo":
				return ec.fieldContext_DiscoveredDevice_routerOSInfo(ctx, field)
			case "confidence":
				return ec.fieldContext_DiscoveredDevice_confidence(ctx, field)
			case "services":
				return ec.fieldContext_DiscoveredDevice_services(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DiscoveredDevice", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ScanTask_startTime(ctx context.Context, field graphql.CollectedField, obj *model.ScanTask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ScanTask_startTime(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StartTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNDateTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ScanTask_startTime(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ScanTask",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DateTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ScanTask_endTime(ctx context.Context, field graphql.CollectedField, obj *model.ScanTask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ScanTask_endTime(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EndTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalODateTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ScanTask_endTime(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ScanTask",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DateTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ScanTask_error(ctx context.Context, field graphql.CollectedField, obj *model.ScanTask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ScanTask_error(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Error, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ScanTask_error(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ScanTask",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ScanTask_totalIPs(ctx context.Context, field graphql.CollectedField, obj *model.ScanTask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ScanTask_totalIPs(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalIPs, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ScanTask_totalIPs(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ScanTask",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ScanTask_scannedIPs(ctx context.Context, field graphql.CollectedField, obj *model.ScanTask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ScanTask_scannedIPs(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ScannedIPs, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ScanTask_scannedIPs(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ScanTask",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Session_id(ctx context.Context, field graphql.CollectedField, obj *model.Session) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Session_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Session_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Session",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Session_ipAddress(ctx context.Context, field graphql.CollectedField, obj *model.Session) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Session_ipAddress(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IPAddress, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Session_ipAddress(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Session",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Session_userAgent(ctx context.Context, field graphql.CollectedField, obj *model.Session) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Session_userAgent(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UserAgent, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Session_userAgent(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Session",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Session_createdAt(ctx context.Context, field graphql.CollectedField, obj *model.Session) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Session_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNDateTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Session_createdAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Session",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DateTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Session_lastActivity(ctx context.Context, field graphql.CollectedField, obj *model.Session) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Session_lastActivity(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LastActivity, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNDateTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Session_lastActivity(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Session",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DateTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Session_isCurrent(ctx context.Context, field graphql.CollectedField, obj *model.Session) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Session_isCurrent(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsCurrent, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Session_isCurrent(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Session",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SetPreferredProtocolPayload_router(ctx context.Context, field graphql.CollectedField, obj *model.SetPreferredProtocolPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SetPreferredProtocolPayload_router(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Router, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Router)
	fc.Result = res
	return ec.marshalORouter2backendgraphmodelRouter(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SetPreferredProtocolPayload_router(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SetPreferredProtocolPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Router_id(ctx, field)
			case "name":
				return ec.fieldContext_Router_name(ctx, field)
			case "host":
				return ec.fieldContext_Router_host(ctx, field)
			case "port":
				return ec.fieldContext_Router_port(ctx, field)
			case "status":
				return ec.fieldContext_Router_status(ctx, field)
			case "platform":
				return ec.fieldContext_Router_platform(ctx, field)
			case "version":
				return ec.fieldContext_Router_version(ctx, field)
			case "model":
				return ec.fieldContext_Router_model(ctx, field)
			case "uptime":
				return ec.fieldContext_Router_uptime(ctx, field)
			case "lastConnected":
				return ec.fieldContext_Router_lastConnected(ctx, field)
			case "createdAt":
				return ec.fieldContext_Router_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Router_updatedAt(ctx, field)
			case "capabilities":
				return ec.fieldContext_Router_capabilities(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Router", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SetPreferredProtocolPayload_connectionDetails(ctx context.Context, field graphql.CollectedField, obj *model.SetPreferredProtocolPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SetPreferredProtocolPayload_connectionDetails(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ConnectionDetails, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.ConnectionDetails)
	fc.Result = res
	return ec.marshalOConnectionDetails2backendgraphmodelConnectionDetails(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SetPreferredProtocolPayload_connectionDetails(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SetPreferredProtocolPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "state":
				return ec.fieldContext_ConnectionDetails_state(ctx, field)
			case "protocol":
				return ec.fieldContext_ConnectionDetails_protocol(ctx, field)
			case "preferredProtocol":
				return ec.fieldContext_ConnectionDetails_preferredProtocol(ctx, field)
			case "connectedAt":
				return ec.fieldContext_ConnectionDetails_connectedAt(ctx, field)
			case "uptime":
				return ec.fieldContext_ConnectionDetails_uptime(ctx, field)
			case "disconnectedAt":
				return ec.fieldContext_ConnectionDetails_disconnectedAt(ctx, field)
			case "lastError":
				return ec.fieldContext_ConnectionDetails_lastError(ctx, field)
			case "lastErrorTime":
				return ec.fieldContext_ConnectionDetails_lastErrorTime(ctx, field)
			case "disconnectReason":
				return ec.fieldContext_ConnectionDetails_disconnectReason(ctx, field)
			case "reconnectAttempts":
				return ec.fieldContext_ConnectionDetails_reconnectAttempts(ctx, field)
			case "nextReconnectAt":
				return ec.fieldContext_ConnectionDetails_nextReconnectAt(ctx, field)
			case "circuitBreakerState":
				return ec.fieldContext_ConnectionDetails_circuitBreakerState(ctx, field)
			case "version":
				return ec.fieldContext_ConnectionDetails_version(ctx, field)
			case "lastHealthCheck":
				return ec.fieldContext_ConnectionDetails_lastHealthCheck(ctx, field)
			case "healthChecksPassed":
				return ec.fieldContext_ConnectionDetails_healthChecksPassed(ctx, field)
			case "healthChecksFailed":
				return ec.fieldContext_ConnectionDetails_healthChecksFailed(ctx, field)
			case "securityWarning":
				return ec.fieldContext_ConnectionDetails_securityWarning(ctx, field)
			case "upgradeRecommendation":
				return ec.fieldContext_ConnectionDetails_upgradeRecommendation(ctx, field)
			case "isLegacyProtocol":
				return ec.fieldContext_ConnectionDetails_isLegacyProtocol(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ConnectionDetails", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SetPreferredProtocolPayload_errors(ctx context.Context, field graphql.CollectedField, obj *model.SetPreferredProtocolPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SetPreferredProtocolPayload_errors(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Errors, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.MutationError)
	fc.Result = res
	return ec.marshalOMutationError2backendgraphmodelMutationError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SetPreferredProtocolPayload_errors(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SetPreferredProtocolPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "code":
				return ec.fieldContext_MutationError_code(ctx, field)
			case "message":
				return ec.fieldContext_MutationError_message(ctx, field)
			case "field":
				return ec.fieldContext_MutationError_field(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MutationError", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SoftwareInfo_version(ctx context.Context, field graphql.CollectedField, obj *model.SoftwareInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SoftwareInfo_version(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Version, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SoftwareInfo_version(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SoftwareInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SoftwareInfo_versionMajor(ctx context.Context, field graphql.CollectedField, obj *model.SoftwareInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SoftwareInfo_versionMajor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.VersionMajor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SoftwareInfo_versionMajor(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SoftwareInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SoftwareInfo_versionMinor(ctx context.Context, field graphql.CollectedField, obj *model.SoftwareInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SoftwareInfo_versionMinor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.VersionMinor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SoftwareInfo_versionMinor(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SoftwareInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SoftwareInfo_versionPatch(ctx context.Context, field graphql.CollectedField, obj *model.SoftwareInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SoftwareInfo_versionPatch(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.VersionPatch, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SoftwareInfo_versionPatch(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SoftwareInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SoftwareInfo_installedPackages(ctx context.Context, field graphql.CollectedField, obj *model.SoftwareInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SoftwareInfo_installedPackages(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.InstalledPackages, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SoftwareInfo_installedPackages(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SoftwareInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SoftwareInfo_licenseLevel(ctx context.Context, field graphql.CollectedField, obj *model.SoftwareInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SoftwareInfo_licenseLevel(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LicenseLevel, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SoftwareInfo_licenseLevel(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SoftwareInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SoftwareInfo_updateChannel(ctx context.Context, field graphql.CollectedField, obj *model.SoftwareInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SoftwareInfo_updateChannel(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdateChannel, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SoftwareInfo_updateChannel(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SoftwareInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Subscription_routerStatusChanged(ctx context.Context, field graphql.CollectedField) (ret func(ctx context.Context) graphql.Marshaler) {
	fc, err := ec.fieldContext_Subscription_routerStatusChanged(ctx, field)
	if err != nil {
		return nil
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = nil
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Subscription().RouterStatusChanged(rctx, fc.Args["routerId"].(*string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return nil
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return nil
	}
	return func(ctx context.Context) graphql.Marshaler {
		select {
		case res, ok := <-resTmp.(<-chan *model.RouterStatusEvent):
			if !ok {
				return nil
			}
			return graphql.WriterFunc(func(w io.Writer) {
				w.Write([]byte{'{'})
				graphql.MarshalString(field.Alias).MarshalGQL(w)
				w.Write([]byte{':'})
				ec.marshalNRouterStatusEvent2backendgraphmodelRouterStatusEvent(ctx, field.Selections, res).MarshalGQL(w)
				w.Write([]byte{'}'})
			})
		case <-ctx.Done():
			return nil
		}
	}
}

func (ec *executionContext) fieldContext_Subscription_routerStatusChanged(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Subscription",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "router":
				return ec.fieldContext_RouterStatusEvent_router(ctx, field)
			case "previousStatus":
				return ec.fieldContext_RouterStatusEvent_previousStatus(ctx, field)
			case "newStatus":
				return ec.fieldContext_RouterStatusEvent_newStatus(ctx, field)
			case "timestamp":
				return ec.fieldContext_RouterStatusEvent_timestamp(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RouterStatusEvent", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Subscription_routerStatusChanged_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Subscription_interfaceTraffic(ctx context.Context, field graphql.CollectedField) (ret func(ctx context.Context) graphql.Marshaler) {
	fc, err := ec.fieldContext_Subscription_interfaceTraffic(ctx, field)
	if err != nil {
		return nil
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = nil
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Subscription().InterfaceTraffic(rctx, fc.Args["routerId"].(string), fc.Args["interfaceId"].(*string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return nil
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return nil
	}
	return func(ctx context.Context) graphql.Marshaler {
		select {
		case res, ok := <-resTmp.(<-chan *model.InterfaceTrafficEvent):
			if !ok {
				return nil
			}
			return graphql.WriterFunc(func(w io.Writer) {
				w.Write([]byte{'{'})
				graphql.MarshalString(field.Alias).MarshalGQL(w)
				w.Write([]byte{':'})
				ec.marshalNInterfaceTrafficEvent2backendgraphmodelInterfaceTrafficEvent(ctx, field.Selections, res).MarshalGQL(w)
				w.Write([]byte{'}'})
			})
		case <-ctx.Done():
			return nil
		}
	}
}

func (ec *executionContext) fieldContext_Subscription_interfaceTraffic(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Subscription",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "interfaceId":
				return ec.fieldContext_InterfaceTrafficEvent_interfaceId(ctx, field)
			case "interfaceName":
				return ec.fieldContext_InterfaceTrafficEvent_interfaceName(ctx, field)
			case "txRate":
				return ec.fieldContext_InterfaceTrafficEvent_txRate(ctx, field)
			case "rxRate":
				return ec.fieldContext_InterfaceTrafficEvent_rxRate(ctx, field)
			case "txTotal":
				return ec.fieldContext_InterfaceTrafficEvent_txTotal(ctx, field)
			case "rxTotal":
				return ec.fieldContext_InterfaceTrafficEvent_rxTotal(ctx, field)
			case "timestamp":
				return ec.fieldContext_InterfaceTrafficEvent_timestamp(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type InterfaceTrafficEvent", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Subscription_interfaceTraffic_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Subscription_resourceUpdated(ctx context.Context, field graphql.CollectedField) (ret func(ctx context.Context) graphql.Marshaler) {
	fc, err := ec.fieldContext_Subscription_resourceUpdated(ctx, field)
	if err != nil {
		return nil
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = nil
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Subscription().ResourceUpdated(rctx, fc.Args["resourceId"].(*string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return nil
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return nil
	}
	return func(ctx context.Context) graphql.Marshaler {
		select {
		case res, ok := <-resTmp.(<-chan *model.ResourceUpdatedEvent):
			if !ok {
				return nil
			}
			return graphql.WriterFunc(func(w io.Writer) {
				w.Write([]byte{'{'})
				graphql.MarshalString(field.Alias).MarshalGQL(w)
				w.Write([]byte{':'})
				ec.marshalNResourceUpdatedEvent2backendgraphmodelResourceUpdatedEvent(ctx, field.Selections, res).MarshalGQL(w)
				w.Write([]byte{'}'})
			})
		case <-ctx.Done():
			return nil
		}
	}
}

func (ec *executionContext) fieldContext_Subscription_resourceUpdated(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Subscription",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "resourceId":
				return ec.fieldContext_ResourceUpdatedEvent_resourceId(ctx, field)
			case "resourceType":
				return ec.fieldContext_ResourceUpdatedEvent_resourceType(ctx, field)
			case "routerId":
				return ec.fieldContext_ResourceUpdatedEvent_routerId(ctx, field)
			case "version":
				return ec.fieldContext_ResourceUpdatedEvent_version(ctx, field)
			case "changedFields":
				return ec.fieldContext_ResourceUpdatedEvent_changedFields(ctx, field)
			case "changeType":
				return ec.fieldContext_ResourceUpdatedEvent_changeType(ctx, field)
			case "timestamp":
				return ec.fieldContext_ResourceUpdatedEvent_timestamp(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ResourceUpdatedEvent", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Subscription_resourceUpdated_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Subscription_configApplyProgress(ctx context.Context, field graphql.CollectedField) (ret func(ctx context.Context) graphql.Marshaler) {
	fc, err := ec.fieldContext_Subscription_configApplyProgress(ctx, field)
	if err != nil {
		return nil
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = nil
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Subscription().ConfigApplyProgress(rctx, fc.Args["operationId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return nil
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return nil
	}
	return func(ctx context.Context) graphql.Marshaler {
		select {
		case res, ok := <-resTmp.(<-chan *model.ConfigProgress):
			if !ok {
				return nil
			}
			return graphql.WriterFunc(func(w io.Writer) {
				w.Write([]byte{'{'})
				graphql.MarshalString(field.Alias).MarshalGQL(w)
				w.Write([]byte{':'})
				ec.marshalNConfigProgress2backendgraphmodelConfigProgress(ctx, field.Selections, res).MarshalGQL(w)
				w.Write([]byte{'}'})
			})
		case <-ctx.Done():
			return nil
		}
	}
}

func (ec *executionContext) fieldContext_Subscription_configApplyProgress(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Subscription",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "operationId":
				return ec.fieldContext_ConfigProgress_operationId(ctx, field)
			case "status":
				return ec.fieldContext_ConfigProgress_status(ctx, field)
			case "percentage":
				return ec.fieldContext_ConfigProgress_percentage(ctx, field)
			case "message":
				return ec.fieldContext_ConfigProgress_message(ctx, field)
			case "currentStep":
				return ec.fieldContext_ConfigProgress_currentStep(ctx, field)
			case "totalSteps":
				return ec.fieldContext_ConfigProgress_totalSteps(ctx, field)
			case "timestamp":
				return ec.fieldContext_ConfigProgress_timestamp(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ConfigProgress", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Subscription_configApplyProgress_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Subscription_connectionHealth(ctx context.Context, field graphql.CollectedField) (ret func(ctx context.Context) graphql.Marshaler) {
	fc, err := ec.fieldContext_Subscription_connectionHealth(ctx, field)
	if err != nil {
		return nil
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = nil
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Subscription().ConnectionHealth(rctx, fc.Args["routerId"].(*string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return nil
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return nil
	}
	return func(ctx context.Context) graphql.Marshaler {
		select {
		case res, ok := <-resTmp.(<-chan *model.HealthCheckResult):
			if !ok {
				return nil
			}
			return graphql.WriterFunc(func(w io.Writer) {
				w.Write([]byte{'{'})
				graphql.MarshalString(field.Alias).MarshalGQL(w)
				w.Write([]byte{':'})
				ec.marshalNHealthCheckResult2backendgraphmodelHealthCheckResult(ctx, field.Selections, res).MarshalGQL(w)
				w.Write([]byte{'}'})
			})
		case <-ctx.Done():
			return nil
		}
	}
}

func (ec *executionContext) fieldContext_Subscription_connectionHealth(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Subscription",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "routerId":
				return ec.fieldContext_HealthCheckResult_routerId(ctx, field)
			case "healthy":
				return ec.fieldContext_HealthCheckResult_healthy(ctx, field)
			case "checkedAt":
				return ec.fieldContext_HealthCheckResult_checkedAt(ctx, field)
			case "responseTimeMs":
				return ec.fieldContext_HealthCheckResult_responseTimeMs(ctx, field)
			case "error":
				return ec.fieldContext_HealthCheckResult_error(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type HealthCheckResult", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Subscription_connectionHealth_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Subscription_circuitBreakerChanged(ctx context.Context, field graphql.CollectedField) (ret func(ctx context.Context) graphql.Marshaler) {
	fc, err := ec.fieldContext_Subscription_circuitBreakerChanged(ctx, field)
	if err != nil {
		return nil
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = nil
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Subscription().CircuitBreakerChanged(rctx, fc.Args["routerId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return nil
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return nil
	}
	return func(ctx context.Context) graphql.Marshaler {
		select {
		case res, ok := <-resTmp.(<-chan *model.CircuitBreakerEvent):
			if !ok {
				return nil
			}
			return graphql.WriterFunc(func(w io.Writer) {
				w.Write([]byte{'{'})
				graphql.MarshalString(field.Alias).MarshalGQL(w)
				w.Write([]byte{':'})
				ec.marshalNCircuitBreakerEvent2backendgraphmodelCircuitBreakerEvent(ctx, field.Selections, res).MarshalGQL(w)
				w.Write([]byte{'}'})
			})
		case <-ctx.Done():
			return nil
		}
	}
}

func (ec *executionContext) fieldContext_Subscription_circuitBreakerChanged(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Subscription",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "routerId":
				return ec.fieldContext_CircuitBreakerEvent_routerId(ctx, field)
			case "previousState":
				return ec.fieldContext_CircuitBreakerEvent_previousState(ctx, field)
			case "newState":
				return ec.fieldContext_CircuitBreakerEvent_newState(ctx, field)
			case "consecutiveFailures":
				return ec.fieldContext_CircuitBreakerEvent_consecutiveFailures(ctx, field)
			case "timestamp":
				return ec.fieldContext_CircuitBreakerEvent_timestamp(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CircuitBreakerEvent", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Subscription_circuitBreakerChanged_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Subscription_circuitBreakerStateChanged(ctx context.Context, field graphql.CollectedField) (ret func(ctx context.Context) graphql.Marshaler) {
	fc, err := ec.fieldContext_Subscription_circuitBreakerStateChanged(ctx, field)
	if err != nil {
		return nil
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = nil
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Subscription().CircuitBreakerStateChanged(rctx, fc.Args["routerId"].(*string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return nil
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return nil
	}
	return func(ctx context.Context) graphql.Marshaler {
		select {
		case res, ok := <-resTmp.(<-chan *model.CircuitBreakerStatus):
			if !ok {
				return nil
			}
			return graphql.WriterFunc(func(w io.Writer) {
				w.Write([]byte{'{'})
				graphql.MarshalString(field.Alias).MarshalGQL(w)
				w.Write([]byte{':'})
				ec.marshalNCircuitBreakerStatus2backendgraphmodelCircuitBreakerStatus(ctx, field.Selections, res).MarshalGQL(w)
				w.Write([]byte{'}'})
			})
		case <-ctx.Done():
			return nil
		}
	}
}

func (ec *executionContext) fieldContext_Subscription_circuitBreakerStateChanged(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Subscription",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "routerId":
				return ec.fieldContext_CircuitBreakerStatus_routerId(ctx, field)
			case "state":
				return ec.fieldContext_CircuitBreakerStatus_state(ctx, field)
			case "failureCount":
				return ec.fieldContext_CircuitBreakerStatus_failureCount(ctx, field)
			case "failureThreshold":
				return ec.fieldContext_CircuitBreakerStatus_failureThreshold(ctx, field)
			case "cooldownRemainingSeconds":
				return ec.fieldContext_CircuitBreakerStatus_cooldownRemainingSeconds(ctx, field)
			case "lastFailureAt":
				return ec.fieldContext_CircuitBreakerStatus_lastFailureAt(ctx, field)
			case "lastSuccessAt":
				return ec.fieldContext_CircuitBreakerStatus_lastSuccessAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CircuitBreakerStatus", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Subscription_circuitBreakerStateChanged_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Subscription_routerAdded(ctx context.Context, field graphql.CollectedField) (ret func(ctx context.Context) graphql.Marshaler) {
	fc, err := ec.fieldContext_Subscription_routerAdded(ctx, field)
	if err != nil {
		return nil
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = nil
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Subscription().RouterAdded(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return nil
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return nil
	}
	return func(ctx context.Context) graphql.Marshaler {
		select {
		case res, ok := <-resTmp.(<-chan *model.RouterAddedEvent):
			if !ok {
				return nil
			}
			return graphql.WriterFunc(func(w io.Writer) {
				w.Write([]byte{'{'})
				graphql.MarshalString(field.Alias).MarshalGQL(w)
				w.Write([]byte{':'})
				ec.marshalNRouterAddedEvent2backendgraphmodelRouterAddedEvent(ctx, field.Selections, res).MarshalGQL(w)
				w.Write([]byte{'}'})
			})
		case <-ctx.Done():
			return nil
		}
	}
}

func (ec *executionContext) fieldContext_Subscription_routerAdded(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Subscription",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "router":
				return ec.fieldContext_RouterAddedEvent_router(ctx, field)
			case "protocolUsed":
				return ec.fieldContext_RouterAddedEvent_protocolUsed(ctx, field)
			case "addedBy":
				return ec.fieldContext_RouterAddedEvent_addedBy(ctx, field)
			case "timestamp":
				return ec.fieldContext_RouterAddedEvent_timestamp(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RouterAddedEvent", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Subscription_scanProgress(ctx context.Context, field graphql.CollectedField) (ret func(ctx context.Context) graphql.Marshaler) {
	fc, err := ec.fieldContext_Subscription_scanProgress(ctx, field)
	if err != nil {
		return nil
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = nil
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Subscription().ScanProgress(rctx, fc.Args["taskId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return nil
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return nil
	}
	return func(ctx context.Context) graphql.Marshaler {
		select {
		case res, ok := <-resTmp.(<-chan *model.ScanProgressEvent):
			if !ok {
				return nil
			}
			return graphql.WriterFunc(func(w io.Writer) {
				w.Write([]byte{'{'})
				graphql.MarshalString(field.Alias).MarshalGQL(w)
				w.Write([]byte{':'})
				ec.marshalNScanProgressEvent2backendgraphmodelScanProgressEvent(ctx, field.Selections, res).MarshalGQL(w)
				w.Write([]byte{'}'})
			})
		case <-ctx.Done():
			return nil
		}
	}
}

func (ec *executionContext) fieldContext_Subscription_scanProgress(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Subscription",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "taskId":
				return ec.fieldContext_ScanProgressEvent_taskId(ctx, field)
			case "progress":
				return ec.fieldContext_ScanProgressEvent_progress(ctx, field)
			case "devicesFound":
				return ec.fieldContext_ScanProgressEvent_devicesFound(ctx, field)
			case "currentIP":
				return ec.fieldContext_ScanProgressEvent_currentIP(ctx, field)
			case "status":
				return ec.fieldContext_ScanProgressEvent_status(ctx, field)
			case "timestamp":
				return ec.fieldContext_ScanProgressEvent_timestamp(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ScanProgressEvent", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Subscription_scanProgress_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _TLSStatus_valid(ctx context.Context, field graphql.CollectedField, obj *model.TLSStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TLSStatus_valid(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Valid, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TLSStatus_valid(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TLSStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TLSStatus_issuer(ctx context.Context, field graphql.CollectedField, obj *model.TLSStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TLSStatus_issuer(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Issuer, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TLSStatus_issuer(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TLSStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TLSStatus_subject(ctx context.Context, field graphql.CollectedField, obj *model.TLSStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TLSStatus_subject(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Subject, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TLSStatus_subject(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TLSStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TLSStatus_expiresAt(ctx context.Context, field graphql.CollectedField, obj *model.TLSStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TLSStatus_expiresAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ExpiresAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalODateTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TLSStatus_expiresAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TLSStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DateTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TLSStatus_error(ctx context.Context, field graphql.CollectedField, obj *model.TLSStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TLSStatus_error(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Error, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TLSStatus_error(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TLSStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TestAllCredentialsPayload_totalRouters(ctx context.Context, field graphql.CollectedField, obj *model.TestAllCredentialsPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TestAllCredentialsPayload_totalRouters(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalRouters, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TestAllCredentialsPayload_totalRouters(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TestAllCredentialsPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TestAllCredentialsPayload_successCount(ctx context.Context, field graphql.CollectedField, obj *model.TestAllCredentialsPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TestAllCredentialsPayload_successCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SuccessCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TestAllCredentialsPayload_successCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TestAllCredentialsPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TestAllCredentialsPayload_failureCount(ctx context.Context, field graphql.CollectedField, obj *model.TestAllCredentialsPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TestAllCredentialsPayload_failureCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FailureCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TestAllCredentialsPayload_failureCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TestAllCredentialsPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TestAllCredentialsPayload_results(ctx context.Context, field graphql.CollectedField, obj *model.TestAllCredentialsPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TestAllCredentialsPayload_results(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Results, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.CredentialTestResult)
	fc.Result = res
	return ec.marshalNCredentialTestResult2backendgraphmodelCredentialTestResult(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TestAllCredentialsPayload_results(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TestAllCredentialsPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "routerId":
				return ec.fieldContext_CredentialTestResult_routerId(ctx, field)
			case "routerName":
				return ec.fieldContext_CredentialTestResult_routerName(ctx, field)
			case "success":
				return ec.fieldContext_CredentialTestResult_success(ctx, field)
			case "status":
				return ec.fieldContext_CredentialTestResult_status(ctx, field)
			case "responseTimeMs":
				return ec.fieldContext_CredentialTestResult_responseTimeMs(ctx, field)
			case "error":
				return ec.fieldContext_CredentialTestResult_error(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CredentialTestResult", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TestConnectionPayload_success(ctx context.Context, field graphql.CollectedField, obj *model.TestConnectionPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TestConnectionPayload_success(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Success, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TestConnectionPayload_success(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TestConnectionPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TestConnectionPayload_responseTimeMs(ctx context.Context, field graphql.CollectedField, obj *model.TestConnectionPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TestConnectionPayload_responseTimeMs(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ResponseTimeMs, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TestConnectionPayload_responseTimeMs(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TestConnectionPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TestConnectionPayload_version(ctx context.Context, field graphql.CollectedField, obj *model.TestConnectionPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TestConnectionPayload_version(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Version, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TestConnectionPayload_version(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TestConnectionPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TestConnectionPayload_error(ctx context.Context, field graphql.CollectedField, obj *model.TestConnectionPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TestConnectionPayload_error(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Error, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TestConnectionPayload_error(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TestConnectionPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UpdateRouterPayload_router(ctx context.Context, field graphql.CollectedField, obj *model.UpdateRouterPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UpdateRouterPayload_router(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Router, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Router)
	fc.Result = res
	return ec.marshalORouter2backendgraphmodelRouter(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UpdateRouterPayload_router(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UpdateRouterPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Router_id(ctx, field)
			case "name":
				return ec.fieldContext_Router_name(ctx, field)
			case "host":
				return ec.fieldContext_Router_host(ctx, field)
			case "port":
				return ec.fieldContext_Router_port(ctx, field)
			case "status":
				return ec.fieldContext_Router_status(ctx, field)
			case "platform":
				return ec.fieldContext_Router_platform(ctx, field)
			case "version":
				return ec.fieldContext_Router_version(ctx, field)
			case "model":
				return ec.fieldContext_Router_model(ctx, field)
			case "uptime":
				return ec.fieldContext_Router_uptime(ctx, field)
			case "lastConnected":
				return ec.fieldContext_Router_lastConnected(ctx, field)
			case "createdAt":
				return ec.fieldContext_Router_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Router_updatedAt(ctx, field)
			case "capabilities":
				return ec.fieldContext_Router_capabilities(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Router", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _UpdateRouterPayload_errors(ctx context.Context, field graphql.CollectedField, obj *model.UpdateRouterPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UpdateRouterPayload_errors(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Errors, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.MutationError)
	fc.Result = res
	return ec.marshalOMutationError2backendgraphmodelMutationError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UpdateRouterPayload_errors(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UpdateRouterPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "code":
				return ec.fieldContext_MutationError_code(ctx, field)
			case "message":
				return ec.fieldContext_MutationError_message(ctx, field)
			case "field":
				return ec.fieldContext_MutationError_field(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MutationError", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _UpgradeImpact_requiresReboot(ctx context.Context, field graphql.CollectedField, obj *model.UpgradeImpact) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UpgradeImpact_requiresReboot(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RequiresReboot, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UpgradeImpact_requiresReboot(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UpgradeImpact",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UpgradeImpact_estimatedDowntime(ctx context.Context, field graphql.CollectedField, obj *model.UpgradeImpact) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UpgradeImpact_estimatedDowntime(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EstimatedDowntime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UpgradeImpact_estimatedDowntime(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UpgradeImpact",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UpgradeImpact_backupRecommended(ctx context.Context, field graphql.CollectedField, obj *model.UpgradeImpact) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UpgradeImpact_backupRecommended(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BackupRecommended, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UpgradeImpact_backupRecommended(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UpgradeImpact",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UpgradeImpact_breakingChanges(ctx context.Context, field graphql.CollectedField, obj *model.UpgradeImpact) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UpgradeImpact_breakingChanges(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BreakingChanges, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UpgradeImpact_breakingChanges(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UpgradeImpact",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UpgradeRecommendation_featureId(ctx context.Context, field graphql.CollectedField, obj *model.UpgradeRecommendation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UpgradeRecommendation_featureId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FeatureID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UpgradeRecommendation_featureId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UpgradeRecommendation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UpgradeRecommendation_featureName(ctx context.Context, field graphql.CollectedField, obj *model.UpgradeRecommendation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UpgradeRecommendation_featureName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FeatureName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UpgradeRecommendation_featureName(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UpgradeRecommendation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UpgradeRecommendation_currentVersion(ctx context.Context, field graphql.CollectedField, obj *model.UpgradeRecommendation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UpgradeRecommendation_currentVersion(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CurrentVersion, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UpgradeRecommendation_currentVersion(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UpgradeRecommendation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UpgradeRecommendation_requiredVersion(ctx context.Context, field graphql.CollectedField, obj *model.UpgradeRecommendation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UpgradeRecommendation_requiredVersion(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RequiredVersion, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UpgradeRecommendation_requiredVersion(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UpgradeRecommendation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UpgradeRecommendation_isMajorUpgrade(ctx context.Context, field graphql.CollectedField, obj *model.UpgradeRecommendation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UpgradeRecommendation_isMajorUpgrade(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsMajorUpgrade, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UpgradeRecommendation_isMajorUpgrade(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UpgradeRecommendation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UpgradeRecommendation_priority(ctx context.Context, field graphql.CollectedField, obj *model.UpgradeRecommendation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UpgradeRecommendation_priority(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Priority, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.UpgradePriority)
	fc.Result = res
	return ec.marshalNUpgradePriority2backendgraphmodelUpgradePriority(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UpgradeRecommendation_priority(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UpgradeRecommendation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type UpgradePriority does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UpgradeRecommendation_steps(ctx context.Context, field graphql.CollectedField, obj *model.UpgradeRecommendation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UpgradeRecommendation_steps(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Steps, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.UpgradeStep)
	fc.Result = res
	return ec.marshalNUpgradeStep2backendgraphmodelUpgradeStep(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UpgradeRecommendation_steps(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UpgradeRecommendation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "step":
				return ec.fieldContext_UpgradeStep_step(ctx, field)
			case "title":
				return ec.fieldContext_UpgradeStep_title(ctx, field)
			case "description":
				return ec.fieldContext_UpgradeStep_description(ctx, field)
			case "command":
				return ec.fieldContext_UpgradeStep_command(ctx, field)
			case "optional":
				return ec.fieldContext_UpgradeStep_optional(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UpgradeStep", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _UpgradeRecommendation_impact(ctx context.Context, field graphql.CollectedField, obj *model.UpgradeRecommendation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UpgradeRecommendation_impact(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Impact, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.UpgradeImpact)
	fc.Result = res
	return ec.marshalNUpgradeImpact2backendgraphmodelUpgradeImpact(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UpgradeRecommendation_impact(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UpgradeRecommendation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "requiresReboot":
				return ec.fieldContext_UpgradeImpact_requiresReboot(ctx, field)
			case "estimatedDowntime":
				return ec.fieldContext_UpgradeImpact_estimatedDowntime(ctx, field)
			case "backupRecommended":
				return ec.fieldContext_UpgradeImpact_backupRecommended(ctx, field)
			case "breakingChanges":
				return ec.fieldContext_UpgradeImpact_breakingChanges(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UpgradeImpact", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _UpgradeRecommendation_documentationUrl(ctx context.Context, field graphql.CollectedField, obj *model.UpgradeRecommendation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UpgradeRecommendation_documentationUrl(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DocumentationURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UpgradeRecommendation_documentationUrl(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UpgradeRecommendation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UpgradeRecommendation_warnings(ctx context.Context, field graphql.CollectedField, obj *model.UpgradeRecommendation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UpgradeRecommendation_warnings(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Warnings, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UpgradeRecommendation_warnings(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UpgradeRecommendation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UpgradeStep_step(ctx context.Context, field graphql.CollectedField, obj *model.UpgradeStep) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UpgradeStep_step(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Step, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UpgradeStep_step(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UpgradeStep",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UpgradeStep_title(ctx context.Context, field graphql.CollectedField, obj *model.UpgradeStep) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UpgradeStep_title(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Title, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UpgradeStep_title(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UpgradeStep",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UpgradeStep_description(ctx context.Context, field graphql.CollectedField, obj *model.UpgradeStep) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UpgradeStep_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UpgradeStep_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UpgradeStep",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UpgradeStep_command(ctx context.Context, field graphql.CollectedField, obj *model.UpgradeStep) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UpgradeStep_command(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Command, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UpgradeStep_command(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UpgradeStep",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UpgradeStep_optional(ctx context.Context, field graphql.CollectedField, obj *model.UpgradeStep) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UpgradeStep_optional(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Optional, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UpgradeStep_optional(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UpgradeStep",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_id(ctx context.Context, field graphql.CollectedField, obj *model.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_username(ctx context.Context, field graphql.CollectedField, obj *model.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_username(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Username, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_username(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_role(ctx context.Context, field graphql.CollectedField, obj *model.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_role(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Role, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.UserRole)
	fc.Result = res
	return ec.marshalNUserRole2backendgraphmodelUserRole(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_role(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type UserRole does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_email(ctx context.Context, field graphql.CollectedField, obj *model.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_email(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Email, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_email(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_displayName(ctx context.Context, field graphql.CollectedField, obj *model.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_displayName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DisplayName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_displayName(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_createdAt(ctx context.Context, field graphql.CollectedField, obj *model.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNDateTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_createdAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DateTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_lastLoginAt(ctx context.Context, field graphql.CollectedField, obj *model.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_lastLoginAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LastLoginAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalODateTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_lastLoginAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DateTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _VIFGuidanceStep_step(ctx context.Context, field graphql.CollectedField, obj *model.VIFGuidanceStep) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_VIFGuidanceStep_step(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Step, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_VIFGuidanceStep_step(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "VIFGuidanceStep",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _VIFGuidanceStep_title(ctx context.Context, field graphql.CollectedField, obj *model.VIFGuidanceStep) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_VIFGuidanceStep_title(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Title, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_VIFGuidanceStep_title(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "VIFGuidanceStep",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _VIFGuidanceStep_description(ctx context.Context, field graphql.CollectedField, obj *model.VIFGuidanceStep) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_VIFGuidanceStep_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_VIFGuidanceStep_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "VIFGuidanceStep",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _VIFGuidanceStep_completed(ctx context.Context, field graphql.CollectedField, obj *model.VIFGuidanceStep) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_VIFGuidanceStep_completed(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Completed, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_VIFGuidanceStep_completed(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "VIFGuidanceStep",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _VIFGuidanceStep_routerCommand(ctx context.Context, field graphql.CollectedField, obj *model.VIFGuidanceStep) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_VIFGuidanceStep_routerCommand(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RouterCommand, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_VIFGuidanceStep_routerCommand(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "VIFGuidanceStep",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _VIFRequirements_met(ctx context.Context, field graphql.CollectedField, obj *model.VIFRequirements) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_VIFRequirements_met(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Met, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_VIFRequirements_met(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "VIFRequirements",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _VIFRequirements_routerOSVersion(ctx context.Context, field graphql.CollectedField, obj *model.VIFRequirements) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_VIFRequirements_routerOSVersion(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RouterOSVersion, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_VIFRequirements_routerOSVersion(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "VIFRequirements",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _VIFRequirements_containerPackage(ctx context.Context, field graphql.CollectedField, obj *model.VIFRequirements) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_VIFRequirements_containerPackage(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ContainerPackage, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_VIFRequirements_containerPackage(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "VIFRequirements",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _VIFRequirements_containerEnabled(ctx context.Context, field graphql.CollectedField, obj *model.VIFRequirements) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_VIFRequirements_containerEnabled(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ContainerEnabled, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_VIFRequirements_containerEnabled(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "VIFRequirements",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _VIFRequirements_sufficientStorage(ctx context.Context, field graphql.CollectedField, obj *model.VIFRequirements) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_VIFRequirements_sufficientStorage(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SufficientStorage, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_VIFRequirements_sufficientStorage(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "VIFRequirements",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _VIFRequirements_networkNamespace(ctx context.Context, field graphql.CollectedField, obj *model.VIFRequirements) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_VIFRequirements_networkNamespace(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NetworkNamespace, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_VIFRequirements_networkNamespace(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "VIFRequirements",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _VIFRequirements_missingReasons(ctx context.Context, field graphql.CollectedField, obj *model.VIFRequirements) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_VIFRequirements_missingReasons(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MissingReasons, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_VIFRequirements_missingReasons(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "VIFRequirements",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _VIFRequirements_guidanceSteps(ctx context.Context, field graphql.CollectedField, obj *model.VIFRequirements) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_VIFRequirements_guidanceSteps(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.GuidanceSteps, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.VIFGuidanceStep)
	fc.Result = res
	return ec.marshalNVIFGuidanceStep2backendgraphmodelVIFGuidanceStep(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_VIFRequirements_guidanceSteps(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "VIFRequirements",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "step":
				return ec.fieldContext_VIFGuidanceStep_step(ctx, field)
			case "title":
				return ec.fieldContext_VIFGuidanceStep_title(ctx, field)
			case "description":
				return ec.fieldContext_VIFGuidanceStep_description(ctx, field)
			case "completed":
				return ec.fieldContext_VIFGuidanceStep_completed(ctx, field)
			case "routerCommand":
				return ec.fieldContext_VIFGuidanceStep_routerCommand(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type VIFGuidanceStep", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ValidationError_field(ctx context.Context, field graphql.CollectedField, obj *model.ValidationError) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ValidationError_field(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Field, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ValidationError_field(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ValidationError",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ValidationError_code(ctx context.Context, field graphql.CollectedField, obj *model.ValidationError) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ValidationError_code(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Code, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ValidationError_code(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ValidationError",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ValidationError_message(ctx context.Context, field graphql.CollectedField, obj *model.ValidationError) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ValidationError_message(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ValidationError_message(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ValidationError",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ValidationError_suggestion(ctx context.Context, field graphql.CollectedField, obj *model.ValidationError) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ValidationError_suggestion(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Suggestion, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ValidationError_suggestion(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ValidationError",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ValidationError_providedValue(ctx context.Context, field graphql.CollectedField, obj *model.ValidationError) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ValidationError_providedValue(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ProvidedValue, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ValidationError_providedValue(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ValidationError",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_locations(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_locations(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Locations, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalN__DirectiveLocation2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_locations(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type __DirectiveLocation does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_args(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_args(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_isRepeatable(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_isRepeatable(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsRepeatable, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_isRepeatable(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_isDeprecated(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_isDeprecated(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_deprecationReason(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_deprecationReason(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_args(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_args(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_type(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_isDeprecated(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_isDeprecated(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_deprecationReason(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_deprecationReason(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_type(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_defaultValue(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_defaultValue(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DefaultValue, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_defaultValue(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_types(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_types(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Types(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_types(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_queryType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_queryType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.QueryType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_queryType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_mutationType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_mutationType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MutationType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_mutationType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_subscriptionType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_subscriptionType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SubscriptionType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_subscriptionType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_directives(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_directives(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Directives(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Directive)
	fc.Result = res
	return ec.marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_directives(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___Directive_name(ctx, field)
			case "description":
				return ec.fieldContext___Directive_description(ctx, field)
			case "locations":
				return ec.fieldContext___Directive_locations(ctx, field)
			case "args":
				return ec.fieldContext___Directive_args(ctx, field)
			case "isRepeatable":
				return ec.fieldContext___Directive_isRepeatable(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Directive", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_kind(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_kind(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Kind(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalN__TypeKind2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_kind(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type __TypeKind does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_fields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_fields(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Fields(fc.Args["includeDeprecated"].(bool)), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Field)
	fc.Result = res
	return ec.marshalO__Field2githubcom99designsgqlgengraphqlintrospectionField(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_fields(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___Field_name(ctx, field)
			case "description":
				return ec.fieldContext___Field_description(ctx, field)
			case "args":
				return ec.fieldContext___Field_args(ctx, field)
			case "type":
				return ec.fieldContext___Field_type(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___Field_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___Field_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Field", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field___Type_fields_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) ___Type_interfaces(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_interfaces(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Interfaces(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_interfaces(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_possibleTypes(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_possibleTypes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PossibleTypes(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_possibleTypes(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_enumValues(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_enumValues(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EnumValues(fc.Args["includeDeprecated"].(bool)), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.EnumValue)
	fc.Result = res
	return ec.marshalO__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_enumValues(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___EnumValue_name(ctx, field)
			case "description":
				return ec.fieldContext___EnumValue_description(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___EnumValue_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___EnumValue_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __EnumValue", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field___Type_enumValues_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) ___Type_inputFields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_inputFields(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.InputFields(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalO__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_inputFields(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_ofType(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_ofType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OfType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_ofType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_specifiedByURL(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_specifiedByURL(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SpecifiedByURL(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_specifiedByURL(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

// endregion **************************** field.gotpl *****************************

// region    **************************** input.gotpl *****************************

func (ec *executionContext) unmarshalInputAddRouterInput(ctx context.Context, obj interface{}) (model.AddRouterInput, error) {
	var it model.AddRouterInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"host", "port", "username", "password", "protocolPreference", "name"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "host":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("host"))
			directive0 := func(ctx context.Context) (interface{}, error) { return ec.unmarshalNString2string(ctx, v) }
			directive1 := func(ctx context.Context) (interface{}, error) {
				minLength, err := ec.unmarshalOInt2int(ctx, 1)
				if err != nil {
					return nil, err
				}
				maxLength, err := ec.unmarshalOInt2int(ctx, 253)
				if err != nil {
					return nil, err
				}
				if ec.directives.Validate == nil {
					return nil, errors.New("directive validate is not implemented")
				}
				return ec.directives.Validate(ctx, obj, directive0, nil, nil, minLength, maxLength, nil, nil)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(string); ok {
				it.Host = data
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "port":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("port"))
			directive0 := func(ctx context.Context) (interface{}, error) { return ec.unmarshalOInt2int(ctx, v) }
			directive1 := func(ctx context.Context) (interface{}, error) {
				min, err := ec.unmarshalOInt2int(ctx, 1)
				if err != nil {
					return nil, err
				}
				max, err := ec.unmarshalOInt2int(ctx, 65535)
				if err != nil {
					return nil, err
				}
				if ec.directives.Validate == nil {
					return nil, errors.New("directive validate is not implemented")
				}
				return ec.directives.Validate(ctx, obj, directive0, min, max, nil, nil, nil, nil)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*int); ok {
				it.Port = graphql.OmittableOf(data)
			} else if tmp == nil {
				it.Port = graphql.OmittableOf[*int](nil)
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *int`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "username":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("username"))
			directive0 := func(ctx context.Context) (interface{}, error) { return ec.unmarshalNString2string(ctx, v) }
			directive1 := func(ctx context.Context) (interface{}, error) {
				minLength, err := ec.unmarshalOInt2int(ctx, 1)
				if err != nil {
					return nil, err
				}
				maxLength, err := ec.unmarshalOInt2int(ctx, 64)
				if err != nil {
					return nil, err
				}
				if ec.directives.Validate == nil {
					return nil, errors.New("directive validate is not implemented")
				}
				return ec.directives.Validate(ctx, obj, directive0, nil, nil, minLength, maxLength, nil, nil)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(string); ok {
				it.Username = data
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "password":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("password"))
			directive0 := func(ctx context.Context) (interface{}, error) { return ec.unmarshalNString2string(ctx, v) }
			directive1 := func(ctx context.Context) (interface{}, error) {
				if ec.directives.Sensitive == nil {
					return nil, errors.New("directive sensitive is not implemented")
				}
				return ec.directives.Sensitive(ctx, obj, directive0)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(string); ok {
				it.Password = data
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "protocolPreference":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("protocolPreference"))
			data, err := ec.unmarshalOProtocolPreference2backendgraphmodelProtocolPreference(ctx, v)
			if err != nil {
				return it, err
			}
			it.ProtocolPreference = graphql.OmittableOf(data)
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			directive0 := func(ctx context.Context) (interface{}, error) { return ec.unmarshalOString2string(ctx, v) }
			directive1 := func(ctx context.Context) (interface{}, error) {
				maxLength, err := ec.unmarshalOInt2int(ctx, 128)
				if err != nil {
					return nil, err
				}
				if ec.directives.Validate == nil {
					return nil, errors.New("directive validate is not implemented")
				}
				return ec.directives.Validate(ctx, obj, directive0, nil, nil, nil, maxLength, nil, nil)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*string); ok {
				it.Name = graphql.OmittableOf(data)
			} else if tmp == nil {
				it.Name = graphql.OmittableOf[*string](nil)
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCreateRouterInput(ctx context.Context, obj interface{}) (model.CreateRouterInput, error) {
	var it model.CreateRouterInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "host", "port", "username", "password", "platform"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			directive0 := func(ctx context.Context) (interface{}, error) { return ec.unmarshalNString2string(ctx, v) }
			directive1 := func(ctx context.Context) (interface{}, error) {
				minLength, err := ec.unmarshalOInt2int(ctx, 1)
				if err != nil {
					return nil, err
				}
				maxLength, err := ec.unmarshalOInt2int(ctx, 64)
				if err != nil {
					return nil, err
				}
				if ec.directives.Validate == nil {
					return nil, errors.New("directive validate is not implemented")
				}
				return ec.directives.Validate(ctx, obj, directive0, nil, nil, minLength, maxLength, nil, nil)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(string); ok {
				it.Name = data
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "host":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("host"))
			directive0 := func(ctx context.Context) (interface{}, error) { return ec.unmarshalNString2string(ctx, v) }
			directive1 := func(ctx context.Context) (interface{}, error) {
				minLength, err := ec.unmarshalOInt2int(ctx, 1)
				if err != nil {
					return nil, err
				}
				maxLength, err := ec.unmarshalOInt2int(ctx, 255)
				if err != nil {
					return nil, err
				}
				if ec.directives.Validate == nil {
					return nil, errors.New("directive validate is not implemented")
				}
				return ec.directives.Validate(ctx, obj, directive0, nil, nil, minLength, maxLength, nil, nil)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(string); ok {
				it.Host = data
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "port":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("port"))
			directive0 := func(ctx context.Context) (interface{}, error) { return ec.unmarshalOInt2int(ctx, v) }
			directive1 := func(ctx context.Context) (interface{}, error) {
				min, err := ec.unmarshalOInt2int(ctx, 1)
				if err != nil {
					return nil, err
				}
				max, err := ec.unmarshalOInt2int(ctx, 65535)
				if err != nil {
					return nil, err
				}
				if ec.directives.Validate == nil {
					return nil, errors.New("directive validate is not implemented")
				}
				return ec.directives.Validate(ctx, obj, directive0, min, max, nil, nil, nil, nil)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*int); ok {
				it.Port = graphql.OmittableOf(data)
			} else if tmp == nil {
				it.Port = graphql.OmittableOf[*int](nil)
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *int`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "username":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("username"))
			directive0 := func(ctx context.Context) (interface{}, error) { return ec.unmarshalNString2string(ctx, v) }
			directive1 := func(ctx context.Context) (interface{}, error) {
				minLength, err := ec.unmarshalOInt2int(ctx, 1)
				if err != nil {
					return nil, err
				}
				maxLength, err := ec.unmarshalOInt2int(ctx, 64)
				if err != nil {
					return nil, err
				}
				if ec.directives.Validate == nil {
					return nil, errors.New("directive validate is not implemented")
				}
				return ec.directives.Validate(ctx, obj, directive0, nil, nil, minLength, maxLength, nil, nil)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(string); ok {
				it.Username = data
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "password":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("password"))
			directive0 := func(ctx context.Context) (interface{}, error) { return ec.unmarshalNString2string(ctx, v) }
			directive1 := func(ctx context.Context) (interface{}, error) {
				minLength, err := ec.unmarshalOInt2int(ctx, 1)
				if err != nil {
					return nil, err
				}
				maxLength, err := ec.unmarshalOInt2int(ctx, 128)
				if err != nil {
					return nil, err
				}
				if ec.directives.Validate == nil {
					return nil, errors.New("directive validate is not implemented")
				}
				return ec.directives.Validate(ctx, obj, directive0, nil, nil, minLength, maxLength, nil, nil)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(string); ok {
				it.Password = data
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "platform":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("platform"))
			data, err := ec.unmarshalORouterPlatform2backendgraphmodelRouterPlatform(ctx, v)
			if err != nil {
				return it, err
			}
			it.Platform = graphql.OmittableOf(data)
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCredentialsInput(ctx context.Context, obj interface{}) (model.CredentialsInput, error) {
	var it model.CredentialsInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"username", "password"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "username":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("username"))
			directive0 := func(ctx context.Context) (interface{}, error) { return ec.unmarshalNString2string(ctx, v) }
			directive1 := func(ctx context.Context) (interface{}, error) {
				minLength, err := ec.unmarshalOInt2int(ctx, 1)
				if err != nil {
					return nil, err
				}
				maxLength, err := ec.unmarshalOInt2int(ctx, 64)
				if err != nil {
					return nil, err
				}
				if ec.directives.Validate == nil {
					return nil, errors.New("directive validate is not implemented")
				}
				return ec.directives.Validate(ctx, obj, directive0, nil, nil, minLength, maxLength, nil, nil)
			}
			directive2 := func(ctx context.Context) (interface{}, error) {
				if ec.directives.Sensitive == nil {
					return nil, errors.New("directive sensitive is not implemented")
				}
				return ec.directives.Sensitive(ctx, obj, directive1)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(string); ok {
				it.Username = data
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "password":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("password"))
			directive0 := func(ctx context.Context) (interface{}, error) { return ec.unmarshalNString2string(ctx, v) }
			directive1 := func(ctx context.Context) (interface{}, error) {
				minLength, err := ec.unmarshalOInt2int(ctx, 1)
				if err != nil {
					return nil, err
				}
				maxLength, err := ec.unmarshalOInt2int(ctx, 128)
				if err != nil {
					return nil, err
				}
				if ec.directives.Validate == nil {
					return nil, errors.New("directive validate is not implemented")
				}
				return ec.directives.Validate(ctx, obj, directive0, nil, nil, minLength, maxLength, nil, nil)
			}
			directive2 := func(ctx context.Context) (interface{}, error) {
				if ec.directives.Sensitive == nil {
					return nil, errors.New("directive sensitive is not implemented")
				}
				return ec.directives.Sensitive(ctx, obj, directive1)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(string); ok {
				it.Password = data
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputExportConfigInput(ctx context.Context, obj interface{}) (model.ExportConfigInput, error) {
	var it model.ExportConfigInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"routerId", "includeCredentials", "encryptionKey"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "routerId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("routerId"))
			data, err := ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.RouterID = data
		case "includeCredentials":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("includeCredentials"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.IncludeCredentials = graphql.OmittableOf(data)
		case "encryptionKey":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("encryptionKey"))
			directive0 := func(ctx context.Context) (interface{}, error) { return ec.unmarshalOString2string(ctx, v) }
			directive1 := func(ctx context.Context) (interface{}, error) {
				if ec.directives.Sensitive == nil {
					return nil, errors.New("directive sensitive is not implemented")
				}
				return ec.directives.Sensitive(ctx, obj, directive0)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*string); ok {
				it.EncryptionKey = graphql.OmittableOf(data)
			} else if tmp == nil {
				it.EncryptionKey = graphql.OmittableOf[*string](nil)
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputFeatureCompatibilityInput(ctx context.Context, obj interface{}) (model.FeatureCompatibilityInput, error) {
	var it model.FeatureCompatibilityInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"featureId", "isCHR"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "featureId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("featureId"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.FeatureID = data
		case "isCHR":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("isCHR"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.IsChr = graphql.OmittableOf(data)
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputPaginationInput(ctx context.Context, obj interface{}) (model.PaginationInput, error) {
	var it model.PaginationInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"first", "after", "last", "before"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "first":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.First = graphql.OmittableOf(data)
		case "after":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.After = graphql.OmittableOf(data)
		case "last":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("last"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Last = graphql.OmittableOf(data)
		case "before":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Before = graphql.OmittableOf(data)
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputScanNetworkInput(ctx context.Context, obj interface{}) (model.ScanNetworkInput, error) {
	var it model.ScanNetworkInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"subnet"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "subnet":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("subnet"))
			directive0 := func(ctx context.Context) (interface{}, error) { return ec.unmarshalNString2string(ctx, v) }
			directive1 := func(ctx context.Context) (interface{}, error) {
				minLength, err := ec.unmarshalOInt2int(ctx, 7)
				if err != nil {
					return nil, err
				}
				maxLength, err := ec.unmarshalOInt2int(ctx, 43)
				if err != nil {
					return nil, err
				}
				if ec.directives.Validate == nil {
					return nil, errors.New("directive validate is not implemented")
				}
				return ec.directives.Validate(ctx, obj, directive0, nil, nil, minLength, maxLength, nil, nil)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(string); ok {
				it.Subnet = data
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateRouterInput(ctx context.Context, obj interface{}) (model.UpdateRouterInput, error) {
	var it model.UpdateRouterInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "host", "port", "username", "password"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			directive0 := func(ctx context.Context) (interface{}, error) { return ec.unmarshalOString2string(ctx, v) }
			directive1 := func(ctx context.Context) (interface{}, error) {
				minLength, err := ec.unmarshalOInt2int(ctx, 1)
				if err != nil {
					return nil, err
				}
				maxLength, err := ec.unmarshalOInt2int(ctx, 64)
				if err != nil {
					return nil, err
				}
				if ec.directives.Validate == nil {
					return nil, errors.New("directive validate is not implemented")
				}
				return ec.directives.Validate(ctx, obj, directive0, nil, nil, minLength, maxLength, nil, nil)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*string); ok {
				it.Name = graphql.OmittableOf(data)
			} else if tmp == nil {
				it.Name = graphql.OmittableOf[*string](nil)
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "host":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("host"))
			directive0 := func(ctx context.Context) (interface{}, error) { return ec.unmarshalOString2string(ctx, v) }
			directive1 := func(ctx context.Context) (interface{}, error) {
				minLength, err := ec.unmarshalOInt2int(ctx, 1)
				if err != nil {
					return nil, err
				}
				maxLength, err := ec.unmarshalOInt2int(ctx, 255)
				if err != nil {
					return nil, err
				}
				if ec.directives.Validate == nil {
					return nil, errors.New("directive validate is not implemented")
				}
				return ec.directives.Validate(ctx, obj, directive0, nil, nil, minLength, maxLength, nil, nil)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*string); ok {
				it.Host = graphql.OmittableOf(data)
			} else if tmp == nil {
				it.Host = graphql.OmittableOf[*string](nil)
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "port":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("port"))
			directive0 := func(ctx context.Context) (interface{}, error) { return ec.unmarshalOInt2int(ctx, v) }
			directive1 := func(ctx context.Context) (interface{}, error) {
				min, err := ec.unmarshalOInt2int(ctx, 1)
				if err != nil {
					return nil, err
				}
				max, err := ec.unmarshalOInt2int(ctx, 65535)
				if err != nil {
					return nil, err
				}
				if ec.directives.Validate == nil {
					return nil, errors.New("directive validate is not implemented")
				}
				return ec.directives.Validate(ctx, obj, directive0, min, max, nil, nil, nil, nil)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*int); ok {
				it.Port = graphql.OmittableOf(data)
			} else if tmp == nil {
				it.Port = graphql.OmittableOf[*int](nil)
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *int`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "username":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("username"))
			directive0 := func(ctx context.Context) (interface{}, error) { return ec.unmarshalOString2string(ctx, v) }
			directive1 := func(ctx context.Context) (interface{}, error) {
				minLength, err := ec.unmarshalOInt2int(ctx, 1)
				if err != nil {
					return nil, err
				}
				maxLength, err := ec.unmarshalOInt2int(ctx, 64)
				if err != nil {
					return nil, err
				}
				if ec.directives.Validate == nil {
					return nil, errors.New("directive validate is not implemented")
				}
				return ec.directives.Validate(ctx, obj, directive0, nil, nil, minLength, maxLength, nil, nil)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*string); ok {
				it.Username = graphql.OmittableOf(data)
			} else if tmp == nil {
				it.Username = graphql.OmittableOf[*string](nil)
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "password":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("password"))
			directive0 := func(ctx context.Context) (interface{}, error) { return ec.unmarshalOString2string(ctx, v) }
			directive1 := func(ctx context.Context) (interface{}, error) {
				minLength, err := ec.unmarshalOInt2int(ctx, 1)
				if err != nil {
					return nil, err
				}
				maxLength, err := ec.unmarshalOInt2int(ctx, 128)
				if err != nil {
					return nil, err
				}
				if ec.directives.Validate == nil {
					return nil, errors.New("directive validate is not implemented")
				}
				return ec.directives.Validate(ctx, obj, directive0, nil, nil, minLength, maxLength, nil, nil)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*string); ok {
				it.Password = graphql.OmittableOf(data)
			} else if tmp == nil {
				it.Password = graphql.OmittableOf[*string](nil)
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		}
	}

	return it, nil
}

// endregion **************************** input.gotpl *****************************

// region    ************************** interface.gotpl ***************************

func (ec *executionContext) _Connection(ctx context.Context, sel ast.SelectionSet, obj model.Connection) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case model.RouterConnection:
		return ec._RouterConnection(ctx, sel, &obj)
	case *model.RouterConnection:
		if obj == nil {
			return graphql.Null
		}
		return ec._RouterConnection(ctx, sel, obj)
	case model.InterfaceConnection:
		return ec._InterfaceConnection(ctx, sel, &obj)
	case *model.InterfaceConnection:
		if obj == nil {
			return graphql.Null
		}
		return ec._InterfaceConnection(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _Edge(ctx context.Context, sel ast.SelectionSet, obj model.Edge) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case model.RouterEdge:
		return ec._RouterEdge(ctx, sel, &obj)
	case *model.RouterEdge:
		if obj == nil {
			return graphql.Null
		}
		return ec._RouterEdge(ctx, sel, obj)
	case model.InterfaceEdge:
		return ec._InterfaceEdge(ctx, sel, &obj)
	case *model.InterfaceEdge:
		if obj == nil {
			return graphql.Null
		}
		return ec._InterfaceEdge(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _Node(ctx context.Context, sel ast.SelectionSet, obj model.Node) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case model.User:
		return ec._User(ctx, sel, &obj)
	case *model.User:
		if obj == nil {
			return graphql.Null
		}
		return ec._User(ctx, sel, obj)
	case model.Router:
		return ec._Router(ctx, sel, &obj)
	case *model.Router:
		if obj == nil {
			return graphql.Null
		}
		return ec._Router(ctx, sel, obj)
	case model.Interface:
		return ec._Interface(ctx, sel, &obj)
	case *model.Interface:
		if obj == nil {
			return graphql.Null
		}
		return ec._Interface(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

// endregion ************************** interface.gotpl ***************************

// region    **************************** object.gotpl ****************************

var addRouterPayloadImplementors = []string{"AddRouterPayload"}

func (ec *executionContext) _AddRouterPayload(ctx context.Context, sel ast.SelectionSet, obj *model.AddRouterPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, addRouterPayloadImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AddRouterPayload")
		case "router":
			out.Values[i] = ec._AddRouterPayload_router(ctx, field, obj)
		case "connectionResult":
			out.Values[i] = ec._AddRouterPayload_connectionResult(ctx, field, obj)
		case "validationErrors":
			out.Values[i] = ec._AddRouterPayload_validationErrors(ctx, field, obj)
		case "errors":
			out.Values[i] = ec._AddRouterPayload_errors(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var authPayloadImplementors = []string{"AuthPayload"}

func (ec *executionContext) _AuthPayload(ctx context.Context, sel ast.SelectionSet, obj *model.AuthPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, authPayloadImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AuthPayload")
		case "token":
			out.Values[i] = ec._AuthPayload_token(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "user":
			out.Values[i] = ec._AuthPayload_user(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "expiresAt":
			out.Values[i] = ec._AuthPayload_expiresAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var authStatusImplementors = []string{"AuthStatus"}

func (ec *executionContext) _AuthStatus(ctx context.Context, sel ast.SelectionSet, obj *model.AuthStatus) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, authStatusImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AuthStatus")
		case "tested":
			out.Values[i] = ec._AuthStatus_tested(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "success":
			out.Values[i] = ec._AuthStatus_success(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "error":
			out.Values[i] = ec._AuthStatus_error(ctx, field, obj)
		case "errorCode":
			out.Values[i] = ec._AuthStatus_errorCode(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var cancelScanPayloadImplementors = []string{"CancelScanPayload"}

func (ec *executionContext) _CancelScanPayload(ctx context.Context, sel ast.SelectionSet, obj *model.CancelScanPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, cancelScanPayloadImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CancelScanPayload")
		case "task":
			out.Values[i] = ec._CancelScanPayload_task(ctx, field, obj)
		case "errors":
			out.Values[i] = ec._CancelScanPayload_errors(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var capabilityEntryImplementors = []string{"CapabilityEntry"}

func (ec *executionContext) _CapabilityEntry(ctx context.Context, sel ast.SelectionSet, obj *model.CapabilityEntry) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, capabilityEntryImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CapabilityEntry")
		case "capability":
			out.Values[i] = ec._CapabilityEntry_capability(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "level":
			out.Values[i] = ec._CapabilityEntry_level(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec._CapabilityEntry_description(ctx, field, obj)
		case "guidance":
			out.Values[i] = ec._CapabilityEntry_guidance(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var circuitBreakerEventImplementors = []string{"CircuitBreakerEvent"}

func (ec *executionContext) _CircuitBreakerEvent(ctx context.Context, sel ast.SelectionSet, obj *model.CircuitBreakerEvent) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, circuitBreakerEventImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CircuitBreakerEvent")
		case "routerId":
			out.Values[i] = ec._CircuitBreakerEvent_routerId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "previousState":
			out.Values[i] = ec._CircuitBreakerEvent_previousState(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "newState":
			out.Values[i] = ec._CircuitBreakerEvent_newState(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "consecutiveFailures":
			out.Values[i] = ec._CircuitBreakerEvent_consecutiveFailures(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "timestamp":
			out.Values[i] = ec._CircuitBreakerEvent_timestamp(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var circuitBreakerStatusImplementors = []string{"CircuitBreakerStatus"}

func (ec *executionContext) _CircuitBreakerStatus(ctx context.Context, sel ast.SelectionSet, obj *model.CircuitBreakerStatus) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, circuitBreakerStatusImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CircuitBreakerStatus")
		case "routerId":
			out.Values[i] = ec._CircuitBreakerStatus_routerId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "state":
			out.Values[i] = ec._CircuitBreakerStatus_state(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "failureCount":
			out.Values[i] = ec._CircuitBreakerStatus_failureCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "failureThreshold":
			out.Values[i] = ec._CircuitBreakerStatus_failureThreshold(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "cooldownRemainingSeconds":
			out.Values[i] = ec._CircuitBreakerStatus_cooldownRemainingSeconds(ctx, field, obj)
		case "lastFailureAt":
			out.Values[i] = ec._CircuitBreakerStatus_lastFailureAt(ctx, field, obj)
		case "lastSuccessAt":
			out.Values[i] = ec._CircuitBreakerStatus_lastSuccessAt(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var configProgressImplementors = []string{"ConfigProgress"}

func (ec *executionContext) _ConfigProgress(ctx context.Context, sel ast.SelectionSet, obj *model.ConfigProgress) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, configProgressImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ConfigProgress")
		case "operationId":
			out.Values[i] = ec._ConfigProgress_operationId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "status":
			out.Values[i] = ec._ConfigProgress_status(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "percentage":
			out.Values[i] = ec._ConfigProgress_percentage(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "message":
			out.Values[i] = ec._ConfigProgress_message(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "currentStep":
			out.Values[i] = ec._ConfigProgress_currentStep(ctx, field, obj)
		case "totalSteps":
			out.Values[i] = ec._ConfigProgress_totalSteps(ctx, field, obj)
		case "timestamp":
			out.Values[i] = ec._ConfigProgress_timestamp(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var connectRouterPayloadImplementors = []string{"ConnectRouterPayload"}

func (ec *executionContext) _ConnectRouterPayload(ctx context.Context, sel ast.SelectionSet, obj *model.ConnectRouterPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, connectRouterPayloadImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ConnectRouterPayload")
		case "router":
			out.Values[i] = ec._ConnectRouterPayload_router(ctx, field, obj)
		case "errors":
			out.Values[i] = ec._ConnectRouterPayload_errors(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var connectionAttemptImplementors = []string{"ConnectionAttempt"}

func (ec *executionContext) _ConnectionAttempt(ctx context.Context, sel ast.SelectionSet, obj *model.ConnectionAttempt) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, connectionAttemptImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ConnectionAttempt")
		case "protocol":
			out.Values[i] = ec._ConnectionAttempt_protocol(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "startedAt":
			out.Values[i] = ec._ConnectionAttempt_startedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "endedAt":
			out.Values[i] = ec._ConnectionAttempt_endedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "success":
			out.Values[i] = ec._ConnectionAttempt_success(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "errorCode":
			out.Values[i] = ec._ConnectionAttempt_errorCode(ctx, field, obj)
		case "errorMessage":
			out.Values[i] = ec._ConnectionAttempt_errorMessage(ctx, field, obj)
		case "errorCategory":
			out.Values[i] = ec._ConnectionAttempt_errorCategory(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var connectionDetailsImplementors = []string{"ConnectionDetails"}

func (ec *executionContext) _ConnectionDetails(ctx context.Context, sel ast.SelectionSet, obj *model.ConnectionDetails) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, connectionDetailsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ConnectionDetails")
		case "state":
			out.Values[i] = ec._ConnectionDetails_state(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "protocol":
			out.Values[i] = ec._ConnectionDetails_protocol(ctx, field, obj)
		case "preferredProtocol":
			out.Values[i] = ec._ConnectionDetails_preferredProtocol(ctx, field, obj)
		case "connectedAt":
			out.Values[i] = ec._ConnectionDetails_connectedAt(ctx, field, obj)
		case "uptime":
			out.Values[i] = ec._ConnectionDetails_uptime(ctx, field, obj)
		case "disconnectedAt":
			out.Values[i] = ec._ConnectionDetails_disconnectedAt(ctx, field, obj)
		case "lastError":
			out.Values[i] = ec._ConnectionDetails_lastError(ctx, field, obj)
		case "lastErrorTime":
			out.Values[i] = ec._ConnectionDetails_lastErrorTime(ctx, field, obj)
		case "disconnectReason":
			out.Values[i] = ec._ConnectionDetails_disconnectReason(ctx, field, obj)
		case "reconnectAttempts":
			out.Values[i] = ec._ConnectionDetails_reconnectAttempts(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "nextReconnectAt":
			out.Values[i] = ec._ConnectionDetails_nextReconnectAt(ctx, field, obj)
		case "circuitBreakerState":
			out.Values[i] = ec._ConnectionDetails_circuitBreakerState(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "version":
			out.Values[i] = ec._ConnectionDetails_version(ctx, field, obj)
		case "lastHealthCheck":
			out.Values[i] = ec._ConnectionDetails_lastHealthCheck(ctx, field, obj)
		case "healthChecksPassed":
			out.Values[i] = ec._ConnectionDetails_healthChecksPassed(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "healthChecksFailed":
			out.Values[i] = ec._ConnectionDetails_healthChecksFailed(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "securityWarning":
			out.Values[i] = ec._ConnectionDetails_securityWarning(ctx, field, obj)
		case "upgradeRecommendation":
			out.Values[i] = ec._ConnectionDetails_upgradeRecommendation(ctx, field, obj)
		case "isLegacyProtocol":
			out.Values[i] = ec._ConnectionDetails_isLegacyProtocol(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var connectionErrorImplementors = []string{"ConnectionError"}

func (ec *executionContext) _ConnectionError(ctx context.Context, sel ast.SelectionSet, obj *model.ConnectionError) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, connectionErrorImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ConnectionError")
		case "code":
			out.Values[i] = ec._ConnectionError_code(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "message":
			out.Values[i] = ec._ConnectionError_message(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "protocol":
			out.Values[i] = ec._ConnectionError_protocol(ctx, field, obj)
		case "retryable":
			out.Values[i] = ec._ConnectionError_retryable(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "suggestedAction":
			out.Values[i] = ec._ConnectionError_suggestedAction(ctx, field, obj)
		case "timeoutMs":
			out.Values[i] = ec._ConnectionError_timeoutMs(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var connectionStatsImplementors = []string{"ConnectionStats"}

func (ec *executionContext) _ConnectionStats(ctx context.Context, sel ast.SelectionSet, obj *model.ConnectionStats) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, connectionStatsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ConnectionStats")
		case "totalConnections":
			out.Values[i] = ec._ConnectionStats_totalConnections(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "connected":
			out.Values[i] = ec._ConnectionStats_connected(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "connecting":
			out.Values[i] = ec._ConnectionStats_connecting(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "disconnected":
			out.Values[i] = ec._ConnectionStats_disconnected(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "reconnecting":
			out.Values[i] = ec._ConnectionStats_reconnecting(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "error":
			out.Values[i] = ec._ConnectionStats_error(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var connectionTestResultImplementors = []string{"ConnectionTestResult"}

func (ec *executionContext) _ConnectionTestResult(ctx context.Context, sel ast.SelectionSet, obj *model.ConnectionTestResult) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, connectionTestResultImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ConnectionTestResult")
		case "success":
			out.Values[i] = ec._ConnectionTestResult_success(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "protocolUsed":
			out.Values[i] = ec._ConnectionTestResult_protocolUsed(ctx, field, obj)
		case "responseTimeMs":
			out.Values[i] = ec._ConnectionTestResult_responseTimeMs(ctx, field, obj)
		case "routerVersion":
			out.Values[i] = ec._ConnectionTestResult_routerVersion(ctx, field, obj)
		case "routerModel":
			out.Values[i] = ec._ConnectionTestResult_routerModel(ctx, field, obj)
		case "boardName":
			out.Values[i] = ec._ConnectionTestResult_boardName(ctx, field, obj)
		case "uptime":
			out.Values[i] = ec._ConnectionTestResult_uptime(ctx, field, obj)
		case "protocolsAttempted":
			out.Values[i] = ec._ConnectionTestResult_protocolsAttempted(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "supportsContainers":
			out.Values[i] = ec._ConnectionTestResult_supportsContainers(ctx, field, obj)
		case "architecture":
			out.Values[i] = ec._ConnectionTestResult_architecture(ctx, field, obj)
		case "error":
			out.Values[i] = ec._ConnectionTestResult_error(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var containerInfoImplementors = []string{"ContainerInfo"}

func (ec *executionContext) _ContainerInfo(ctx context.Context, sel ast.SelectionSet, obj *model.ContainerInfo) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, containerInfoImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ContainerInfo")
		case "packageInstalled":
			out.Values[i] = ec._ContainerInfo_packageInstalled(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "enabled":
			out.Values[i] = ec._ContainerInfo_enabled(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "registryConfigured":
			out.Values[i] = ec._ContainerInfo_registryConfigured(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "storageAvailable":
			out.Values[i] = ec._ContainerInfo_storageAvailable(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "supportsNetworkNamespace":
			out.Values[i] = ec._ContainerInfo_supportsNetworkNamespace(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "maxContainers":
			out.Values[i] = ec._ContainerInfo_maxContainers(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var createRouterPayloadImplementors = []string{"CreateRouterPayload"}

func (ec *executionContext) _CreateRouterPayload(ctx context.Context, sel ast.SelectionSet, obj *model.CreateRouterPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, createRouterPayloadImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CreateRouterPayload")
		case "router":
			out.Values[i] = ec._CreateRouterPayload_router(ctx, field, obj)
		case "errors":
			out.Values[i] = ec._CreateRouterPayload_errors(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var credentialTestResultImplementors = []string{"CredentialTestResult"}

func (ec *executionContext) _CredentialTestResult(ctx context.Context, sel ast.SelectionSet, obj *model.CredentialTestResult) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, credentialTestResultImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CredentialTestResult")
		case "routerId":
			out.Values[i] = ec._CredentialTestResult_routerId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "routerName":
			out.Values[i] = ec._CredentialTestResult_routerName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "success":
			out.Values[i] = ec._CredentialTestResult_success(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "status":
			out.Values[i] = ec._CredentialTestResult_status(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "responseTimeMs":
			out.Values[i] = ec._CredentialTestResult_responseTimeMs(ctx, field, obj)
		case "error":
			out.Values[i] = ec._CredentialTestResult_error(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var credentialUpdatePayloadImplementors = []string{"CredentialUpdatePayload"}

func (ec *executionContext) _CredentialUpdatePayload(ctx context.Context, sel ast.SelectionSet, obj *model.CredentialUpdatePayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, credentialUpdatePayloadImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CredentialUpdatePayload")
		case "success":
			out.Values[i] = ec._CredentialUpdatePayload_success(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "message":
			out.Values[i] = ec._CredentialUpdatePayload_message(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "credentials":
			out.Values[i] = ec._CredentialUpdatePayload_credentials(ctx, field, obj)
		case "errorCode":
			out.Values[i] = ec._CredentialUpdatePayload_errorCode(ctx, field, obj)
		case "errors":
			out.Values[i] = ec._CredentialUpdatePayload_errors(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var deleteRouterPayloadImplementors = []string{"DeleteRouterPayload"}

func (ec *executionContext) _DeleteRouterPayload(ctx context.Context, sel ast.SelectionSet, obj *model.DeleteRouterPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, deleteRouterPayloadImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DeleteRouterPayload")
		case "success":
			out.Values[i] = ec._DeleteRouterPayload_success(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deletedRouterId":
			out.Values[i] = ec._DeleteRouterPayload_deletedRouterId(ctx, field, obj)
		case "errors":
			out.Values[i] = ec._DeleteRouterPayload_errors(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var diagnosticReportImplementors = []string{"DiagnosticReport"}

func (ec *executionContext) _DiagnosticReport(ctx context.Context, sel ast.SelectionSet, obj *model.DiagnosticReport) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, diagnosticReportImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DiagnosticReport")
		case "routerId":
			out.Values[i] = ec._DiagnosticReport_routerId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "timestamp":
			out.Values[i] = ec._DiagnosticReport_timestamp(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "networkReachable":
			out.Values[i] = ec._DiagnosticReport_networkReachable(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "portStatus":
			out.Values[i] = ec._DiagnosticReport_portStatus(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "tlsStatus":
			out.Values[i] = ec._DiagnosticReport_tlsStatus(ctx, field, obj)
		case "authStatus":
			out.Values[i] = ec._DiagnosticReport_authStatus(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "suggestions":
			out.Values[i] = ec._DiagnosticReport_suggestions(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "rawReport":
			out.Values[i] = ec._DiagnosticReport_rawReport(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var diagnosticSuggestionImplementors = []string{"DiagnosticSuggestion"}

func (ec *executionContext) _DiagnosticSuggestion(ctx context.Context, sel ast.SelectionSet, obj *model.DiagnosticSuggestion) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, diagnosticSuggestionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DiagnosticSuggestion")
		case "severity":
			out.Values[i] = ec._DiagnosticSuggestion_severity(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "title":
			out.Values[i] = ec._DiagnosticSuggestion_title(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec._DiagnosticSuggestion_description(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "action":
			out.Values[i] = ec._DiagnosticSuggestion_action(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "docsUrl":
			out.Values[i] = ec._DiagnosticSuggestion_docsUrl(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var disconnectRouterPayloadImplementors = []string{"DisconnectRouterPayload"}

func (ec *executionContext) _DisconnectRouterPayload(ctx context.Context, sel ast.SelectionSet, obj *model.DisconnectRouterPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, disconnectRouterPayloadImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DisconnectRouterPayload")
		case "router":
			out.Values[i] = ec._DisconnectRouterPayload_router(ctx, field, obj)
		case "errors":
			out.Values[i] = ec._DisconnectRouterPayload_errors(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var discoveredDeviceImplementors = []string{"DiscoveredDevice"}

func (ec *executionContext) _DiscoveredDevice(ctx context.Context, sel ast.SelectionSet, obj *model.DiscoveredDevice) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, discoveredDeviceImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DiscoveredDevice")
		case "ip":
			out.Values[i] = ec._DiscoveredDevice_ip(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "hostname":
			out.Values[i] = ec._DiscoveredDevice_hostname(ctx, field, obj)
		case "ports":
			out.Values[i] = ec._DiscoveredDevice_ports(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deviceType":
			out.Values[i] = ec._DiscoveredDevice_deviceType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "vendor":
			out.Values[i] = ec._DiscoveredDevice_vendor(ctx, field, obj)
		case "routerOSInfo":
			out.Values[i] = ec._DiscoveredDevice_routerOSInfo(ctx, field, obj)
		case "confidence":
			out.Values[i] = ec._DiscoveredDevice_confidence(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "services":
			out.Values[i] = ec._DiscoveredDevice_services(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var errorExtensionsImplementors = []string{"ErrorExtensions"}

func (ec *executionContext) _ErrorExtensions(ctx context.Context, sel ast.SelectionSet, obj *model.ErrorExtensions) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, errorExtensionsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ErrorExtensions")
		case "code":
			out.Values[i] = ec._ErrorExtensions_code(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "category":
			out.Values[i] = ec._ErrorExtensions_category(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "field":
			out.Values[i] = ec._ErrorExtensions_field(ctx, field, obj)
		case "value":
			out.Values[i] = ec._ErrorExtensions_value(ctx, field, obj)
		case "suggestedFix":
			out.Values[i] = ec._ErrorExtensions_suggestedFix(ctx, field, obj)
		case "docsUrl":
			out.Values[i] = ec._ErrorExtensions_docsUrl(ctx, field, obj)
		case "requestId":
			out.Values[i] = ec._ErrorExtensions_requestId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "recoverable":
			out.Values[i] = ec._ErrorExtensions_recoverable(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "troubleshootingSteps":
			out.Values[i] = ec._ErrorExtensions_troubleshootingSteps(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var exportConfigPayloadImplementors = []string{"ExportConfigPayload"}

func (ec *executionContext) _ExportConfigPayload(ctx context.Context, sel ast.SelectionSet, obj *model.ExportConfigPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, exportConfigPayloadImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ExportConfigPayload")
		case "success":
			out.Values[i] = ec._ExportConfigPayload_success(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "config":
			out.Values[i] = ec._ExportConfigPayload_config(ctx, field, obj)
		case "securityWarning":
			out.Values[i] = ec._ExportConfigPayload_securityWarning(ctx, field, obj)
		case "errors":
			out.Values[i] = ec._ExportConfigPayload_errors(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var featureCompatibilityInfoImplementors = []string{"FeatureCompatibilityInfo"}

func (ec *executionContext) _FeatureCompatibilityInfo(ctx context.Context, sel ast.SelectionSet, obj *model.FeatureCompatibilityInfo) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, featureCompatibilityInfoImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("FeatureCompatibilityInfo")
		case "featureId":
			out.Values[i] = ec._FeatureCompatibilityInfo_featureId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec._FeatureCompatibilityInfo_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "minVersion":
			out.Values[i] = ec._FeatureCompatibilityInfo_minVersion(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "maxVersion":
			out.Values[i] = ec._FeatureCompatibilityInfo_maxVersion(ctx, field, obj)
		case "minVersionCHR":
			out.Values[i] = ec._FeatureCompatibilityInfo_minVersionCHR(ctx, field, obj)
		case "requiredPackages":
			out.Values[i] = ec._FeatureCompatibilityInfo_requiredPackages(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "dependsOn":
			out.Values[i] = ec._FeatureCompatibilityInfo_dependsOn(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "upgradeUrl":
			out.Values[i] = ec._FeatureCompatibilityInfo_upgradeUrl(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var featureSupportImplementors = []string{"FeatureSupport"}

func (ec *executionContext) _FeatureSupport(ctx context.Context, sel ast.SelectionSet, obj *model.FeatureSupport) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, featureSupportImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("FeatureSupport")
		case "featureId":
			out.Values[i] = ec._FeatureSupport_featureId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec._FeatureSupport_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "supported":
			out.Values[i] = ec._FeatureSupport_supported(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "level":
			out.Values[i] = ec._FeatureSupport_level(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "reason":
			out.Values[i] = ec._FeatureSupport_reason(ctx, field, obj)
		case "requiredVersion":
			out.Values[i] = ec._FeatureSupport_requiredVersion(ctx, field, obj)
		case "upgradeUrl":
			out.Values[i] = ec._FeatureSupport_upgradeUrl(ctx, field, obj)
		case "requiredPackages":
			out.Values[i] = ec._FeatureSupport_requiredPackages(ctx, field, obj)
		case "missingPackages":
			out.Values[i] = ec._FeatureSupport_missingPackages(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var hardwareInfoImplementors = []string{"HardwareInfo"}

func (ec *executionContext) _HardwareInfo(ctx context.Context, sel ast.SelectionSet, obj *model.HardwareInfo) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, hardwareInfoImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("HardwareInfo")
		case "architecture":
			out.Values[i] = ec._HardwareInfo_architecture(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "model":
			out.Values[i] = ec._HardwareInfo_model(ctx, field, obj)
		case "boardName":
			out.Values[i] = ec._HardwareInfo_boardName(ctx, field, obj)
		case "totalMemory":
			out.Values[i] = ec._HardwareInfo_totalMemory(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "availableStorage":
			out.Values[i] = ec._HardwareInfo_availableStorage(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "cpuCount":
			out.Values[i] = ec._HardwareInfo_cpuCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "hasWirelessChip":
			out.Values[i] = ec._HardwareInfo_hasWirelessChip(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "hasLTEModule":
			out.Values[i] = ec._HardwareInfo_hasLTEModule(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var healthCheckResultImplementors = []string{"HealthCheckResult"}

func (ec *executionContext) _HealthCheckResult(ctx context.Context, sel ast.SelectionSet, obj *model.HealthCheckResult) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, healthCheckResultImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("HealthCheckResult")
		case "routerId":
			out.Values[i] = ec._HealthCheckResult_routerId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "healthy":
			out.Values[i] = ec._HealthCheckResult_healthy(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "checkedAt":
			out.Values[i] = ec._HealthCheckResult_checkedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "responseTimeMs":
			out.Values[i] = ec._HealthCheckResult_responseTimeMs(ctx, field, obj)
		case "error":
			out.Values[i] = ec._HealthCheckResult_error(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var healthStatusImplementors = []string{"HealthStatus"}

func (ec *executionContext) _HealthStatus(ctx context.Context, sel ast.SelectionSet, obj *model.HealthStatus) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, healthStatusImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("HealthStatus")
		case "status":
			out.Values[i] = ec._HealthStatus_status(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "version":
			out.Values[i] = ec._HealthStatus_version(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "uptime":
			out.Values[i] = ec._HealthStatus_uptime(ctx, field, obj)
		case "connectedRouters":
			out.Values[i] = ec._HealthStatus_connectedRouters(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "checkedAt":
			out.Values[i] = ec._HealthStatus_checkedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var interfaceImplementors = []string{"Interface", "Node"}

func (ec *executionContext) _Interface(ctx context.Context, sel ast.SelectionSet, obj *model.Interface) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, interfaceImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Interface")
		case "id":
			out.Values[i] = ec._Interface_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec._Interface_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "type":
			out.Values[i] = ec._Interface_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "enabled":
			out.Values[i] = ec._Interface_enabled(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "running":
			out.Values[i] = ec._Interface_running(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "macAddress":
			out.Values[i] = ec._Interface_macAddress(ctx, field, obj)
		case "mtu":
			out.Values[i] = ec._Interface_mtu(ctx, field, obj)
		case "comment":
			out.Values[i] = ec._Interface_comment(ctx, field, obj)
		case "txBytes":
			out.Values[i] = ec._Interface_txBytes(ctx, field, obj)
		case "rxBytes":
			out.Values[i] = ec._Interface_rxBytes(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var interfaceConnectionImplementors = []string{"InterfaceConnection", "Connection"}

func (ec *executionContext) _InterfaceConnection(ctx context.Context, sel ast.SelectionSet, obj *model.InterfaceConnection) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, interfaceConnectionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("InterfaceConnection")
		case "edges":
			out.Values[i] = ec._InterfaceConnection_edges(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "pageInfo":
			out.Values[i] = ec._InterfaceConnection_pageInfo(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "totalCount":
			out.Values[i] = ec._InterfaceConnection_totalCount(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var interfaceEdgeImplementors = []string{"InterfaceEdge", "Edge"}

func (ec *executionContext) _InterfaceEdge(ctx context.Context, sel ast.SelectionSet, obj *model.InterfaceEdge) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, interfaceEdgeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("InterfaceEdge")
		case "node":
			out.Values[i] = ec._InterfaceEdge_node(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "cursor":
			out.Values[i] = ec._InterfaceEdge_cursor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var interfaceTrafficEventImplementors = []string{"InterfaceTrafficEvent"}

func (ec *executionContext) _InterfaceTrafficEvent(ctx context.Context, sel ast.SelectionSet, obj *model.InterfaceTrafficEvent) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, interfaceTrafficEventImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("InterfaceTrafficEvent")
		case "interfaceId":
			out.Values[i] = ec._InterfaceTrafficEvent_interfaceId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "interfaceName":
			out.Values[i] = ec._InterfaceTrafficEvent_interfaceName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "txRate":
			out.Values[i] = ec._InterfaceTrafficEvent_txRate(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "rxRate":
			out.Values[i] = ec._InterfaceTrafficEvent_rxRate(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "txTotal":
			out.Values[i] = ec._InterfaceTrafficEvent_txTotal(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "rxTotal":
			out.Values[i] = ec._InterfaceTrafficEvent_rxTotal(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "timestamp":
			out.Values[i] = ec._InterfaceTrafficEvent_timestamp(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var mutationImplementors = []string{"Mutation"}

func (ec *executionContext) _Mutation(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, mutationImplementors)
	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Mutation",
	})

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		innerCtx := graphql.WithRootFieldContext(ctx, &graphql.RootFieldContext{
			Object: field.Name,
			Field:  field,
		})

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Mutation")
		case "createRouter":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createRouter(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updateRouter":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateRouter(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deleteRouter":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_deleteRouter(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "testRouterConnection":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_testRouterConnection(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "connectRouter":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_connectRouter(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "disconnectRouter":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_disconnectRouter(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "refreshCapabilities":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_refreshCapabilities(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "login":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_login(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "logout":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_logout(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "changePassword":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_changePassword(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "revokeAllSessions":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_revokeAllSessions(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "revokeSession":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_revokeSession(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "setPreferredProtocol":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_setPreferredProtocol(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "reconnectRouter":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_reconnectRouter(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "checkRouterHealth":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_checkRouterHealth(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updateRouterCredentials":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateRouterCredentials(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "testAllCredentials":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_testAllCredentials(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "exportRouterConfig":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_exportRouterConfig(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "runDiagnostics":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_runDiagnostics(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "resetCircuitBreaker":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_resetCircuitBreaker(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "addRouter":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_addRouter(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "testRouterCredentials":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_testRouterCredentials(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "scanNetwork":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_scanNetwork(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "autoScanGateways":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_autoScanGateways(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "cancelScan":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_cancelScan(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var mutationErrorImplementors = []string{"MutationError"}

func (ec *executionContext) _MutationError(ctx context.Context, sel ast.SelectionSet, obj *model.MutationError) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, mutationErrorImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("MutationError")
		case "code":
			out.Values[i] = ec._MutationError_code(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "message":
			out.Values[i] = ec._MutationError_message(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "field":
			out.Values[i] = ec._MutationError_field(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var pageInfoImplementors = []string{"PageInfo"}

func (ec *executionContext) _PageInfo(ctx context.Context, sel ast.SelectionSet, obj *model.PageInfo) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, pageInfoImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PageInfo")
		case "hasNextPage":
			out.Values[i] = ec._PageInfo_hasNextPage(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "hasPreviousPage":
			out.Values[i] = ec._PageInfo_hasPreviousPage(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "startCursor":
			out.Values[i] = ec._PageInfo_startCursor(ctx, field, obj)
		case "endCursor":
			out.Values[i] = ec._PageInfo_endCursor(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var portStatusImplementors = []string{"PortStatus"}

func (ec *executionContext) _PortStatus(ctx context.Context, sel ast.SelectionSet, obj *model.PortStatus) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, portStatusImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PortStatus")
		case "port":
			out.Values[i] = ec._PortStatus_port(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "service":
			out.Values[i] = ec._PortStatus_service(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "open":
			out.Values[i] = ec._PortStatus_open(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "responseTimeMs":
			out.Values[i] = ec._PortStatus_responseTimeMs(ctx, field, obj)
		case "error":
			out.Values[i] = ec._PortStatus_error(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var queryImplementors = []string{"Query"}

func (ec *executionContext) _Query(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, queryImplementors)
	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Query",
	})

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		innerCtx := graphql.WithRootFieldContext(ctx, &graphql.RootFieldContext{
			Object: field.Name,
			Field:  field,
		})

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Query")
		case "node":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_node(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "health":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_health(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "version":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_version(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "router":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_router(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "routers":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_routers(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "interface":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_interface(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "interfaces":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_interfaces(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "routerCapabilities":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_routerCapabilities(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "isFeatureSupported":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_isFeatureSupported(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "supportedFeatures":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_supportedFeatures(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "unsupportedFeatures":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_unsupportedFeatures(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "compatibilityMatrix":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_compatibilityMatrix(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "upgradeRecommendation":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_upgradeRecommendation(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "upgradeRecommendations":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_upgradeRecommendations(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "me":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_me(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "mySessions":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_mySessions(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "connectionDetails":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_connectionDetails(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "routerHealth":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_routerHealth(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "connectionStats":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_connectionStats(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "routerCredentials":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_routerCredentials(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "connectionAttempts":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_connectionAttempts(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "circuitBreakerStatus":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_circuitBreakerStatus(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "scanStatus":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_scanStatus(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "scanHistory":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_scanHistory(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "__type":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Query___type(ctx, field)
			})
		case "__schema":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Query___schema(ctx, field)
			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var reconnectRouterPayloadImplementors = []string{"ReconnectRouterPayload"}

func (ec *executionContext) _ReconnectRouterPayload(ctx context.Context, sel ast.SelectionSet, obj *model.ReconnectRouterPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, reconnectRouterPayloadImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ReconnectRouterPayload")
		case "router":
			out.Values[i] = ec._ReconnectRouterPayload_router(ctx, field, obj)
		case "connectionDetails":
			out.Values[i] = ec._ReconnectRouterPayload_connectionDetails(ctx, field, obj)
		case "initiated":
			out.Values[i] = ec._ReconnectRouterPayload_initiated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "waitTimeMs":
			out.Values[i] = ec._ReconnectRouterPayload_waitTimeMs(ctx, field, obj)
		case "errors":
			out.Values[i] = ec._ReconnectRouterPayload_errors(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var refreshCapabilitiesPayloadImplementors = []string{"RefreshCapabilitiesPayload"}

func (ec *executionContext) _RefreshCapabilitiesPayload(ctx context.Context, sel ast.SelectionSet, obj *model.RefreshCapabilitiesPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, refreshCapabilitiesPayloadImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RefreshCapabilitiesPayload")
		case "capabilities":
			out.Values[i] = ec._RefreshCapabilitiesPayload_capabilities(ctx, field, obj)
		case "errors":
			out.Values[i] = ec._RefreshCapabilitiesPayload_errors(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var resourceUpdatedEventImplementors = []string{"ResourceUpdatedEvent"}

func (ec *executionContext) _ResourceUpdatedEvent(ctx context.Context, sel ast.SelectionSet, obj *model.ResourceUpdatedEvent) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, resourceUpdatedEventImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ResourceUpdatedEvent")
		case "resourceId":
			out.Values[i] = ec._ResourceUpdatedEvent_resourceId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "resourceType":
			out.Values[i] = ec._ResourceUpdatedEvent_resourceType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "routerId":
			out.Values[i] = ec._ResourceUpdatedEvent_routerId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "version":
			out.Values[i] = ec._ResourceUpdatedEvent_version(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "changedFields":
			out.Values[i] = ec._ResourceUpdatedEvent_changedFields(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "changeType":
			out.Values[i] = ec._ResourceUpdatedEvent_changeType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "timestamp":
			out.Values[i] = ec._ResourceUpdatedEvent_timestamp(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var routerImplementors = []string{"Router", "Node"}

func (ec *executionContext) _Router(ctx context.Context, sel ast.SelectionSet, obj *model.Router) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, routerImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Router")
		case "id":
			out.Values[i] = ec._Router_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec._Router_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "host":
			out.Values[i] = ec._Router_host(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "port":
			out.Values[i] = ec._Router_port(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "status":
			out.Values[i] = ec._Router_status(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "platform":
			out.Values[i] = ec._Router_platform(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "version":
			out.Values[i] = ec._Router_version(ctx, field, obj)
		case "model":
			out.Values[i] = ec._Router_model(ctx, field, obj)
		case "uptime":
			out.Values[i] = ec._Router_uptime(ctx, field, obj)
		case "lastConnected":
			out.Values[i] = ec._Router_lastConnected(ctx, field, obj)
		case "createdAt":
			out.Values[i] = ec._Router_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updatedAt":
			out.Values[i] = ec._Router_updatedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "capabilities":
			out.Values[i] = ec._Router_capabilities(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var routerAddedEventImplementors = []string{"RouterAddedEvent"}

func (ec *executionContext) _RouterAddedEvent(ctx context.Context, sel ast.SelectionSet, obj *model.RouterAddedEvent) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, routerAddedEventImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RouterAddedEvent")
		case "router":
			out.Values[i] = ec._RouterAddedEvent_router(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "protocolUsed":
			out.Values[i] = ec._RouterAddedEvent_protocolUsed(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "addedBy":
			out.Values[i] = ec._RouterAddedEvent_addedBy(ctx, field, obj)
		case "timestamp":
			out.Values[i] = ec._RouterAddedEvent_timestamp(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var routerCapabilitiesImplementors = []string{"RouterCapabilities"}

func (ec *executionContext) _RouterCapabilities(ctx context.Context, sel ast.SelectionSet, obj *model.RouterCapabilities) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, routerCapabilitiesImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RouterCapabilities")
		case "hardware":
			out.Values[i] = ec._RouterCapabilities_hardware(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "software":
			out.Values[i] = ec._RouterCapabilities_software(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "container":
			out.Values[i] = ec._RouterCapabilities_container(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "capabilities":
			out.Values[i] = ec._RouterCapabilities_capabilities(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "vifRequirements":
			out.Values[i] = ec._RouterCapabilities_vifRequirements(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "supportedFeatures":
			out.Values[i] = ec._RouterCapabilities_supportedFeatures(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "unsupportedFeatures":
			out.Values[i] = ec._RouterCapabilities_unsupportedFeatures(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "routerOSVersion":
			out.Values[i] = ec._RouterCapabilities_routerOSVersion(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "detectedAt":
			out.Values[i] = ec._RouterCapabilities_detectedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "expiresAt":
			out.Values[i] = ec._RouterCapabilities_expiresAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "isRefreshing":
			out.Values[i] = ec._RouterCapabilities_isRefreshing(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var routerConnectionImplementors = []string{"RouterConnection", "Connection"}

func (ec *executionContext) _RouterConnection(ctx context.Context, sel ast.SelectionSet, obj *model.RouterConnection) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, routerConnectionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RouterConnection")
		case "edges":
			out.Values[i] = ec._RouterConnection_edges(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "pageInfo":
			out.Values[i] = ec._RouterConnection_pageInfo(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "totalCount":
			out.Values[i] = ec._RouterConnection_totalCount(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var routerCredentialsImplementors = []string{"RouterCredentials"}

func (ec *executionContext) _RouterCredentials(ctx context.Context, sel ast.SelectionSet, obj *model.RouterCredentials) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, routerCredentialsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RouterCredentials")
		case "routerId":
			out.Values[i] = ec._RouterCredentials_routerId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "username":
			out.Values[i] = ec._RouterCredentials_username(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "hasPassword":
			out.Values[i] = ec._RouterCredentials_hasPassword(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "encryptionStatus":
			out.Values[i] = ec._RouterCredentials_encryptionStatus(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "keyVersion":
			out.Values[i] = ec._RouterCredentials_keyVersion(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "lastUpdated":
			out.Values[i] = ec._RouterCredentials_lastUpdated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createdAt":
			out.Values[i] = ec._RouterCredentials_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var routerEdgeImplementors = []string{"RouterEdge", "Edge"}

func (ec *executionContext) _RouterEdge(ctx context.Context, sel ast.SelectionSet, obj *model.RouterEdge) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, routerEdgeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RouterEdge")
		case "node":
			out.Values[i] = ec._RouterEdge_node(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "cursor":
			out.Values[i] = ec._RouterEdge_cursor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var routerOSInfoImplementors = []string{"RouterOSInfo"}

func (ec *executionContext) _RouterOSInfo(ctx context.Context, sel ast.SelectionSet, obj *model.RouterOSInfo) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, routerOSInfoImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RouterOSInfo")
		case "version":
			out.Values[i] = ec._RouterOSInfo_version(ctx, field, obj)
		case "boardName":
			out.Values[i] = ec._RouterOSInfo_boardName(ctx, field, obj)
		case "architecture":
			out.Values[i] = ec._RouterOSInfo_architecture(ctx, field, obj)
		case "platform":
			out.Values[i] = ec._RouterOSInfo_platform(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var routerOSVersionImplementors = []string{"RouterOSVersion"}

func (ec *executionContext) _RouterOSVersion(ctx context.Context, sel ast.SelectionSet, obj *model.RouterOSVersion) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, routerOSVersionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RouterOSVersion")
		case "raw":
			out.Values[i] = ec._RouterOSVersion_raw(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "major":
			out.Values[i] = ec._RouterOSVersion_major(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "minor":
			out.Values[i] = ec._RouterOSVersion_minor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "patch":
			out.Values[i] = ec._RouterOSVersion_patch(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "channel":
			out.Values[i] = ec._RouterOSVersion_channel(ctx, field, obj)
		case "isCHR":
			out.Values[i] = ec._RouterOSVersion_isCHR(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "supportsFeature":
			out.Values[i] = ec._RouterOSVersion_supportsFeature(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "isAtLeast":
			out.Values[i] = ec._RouterOSVersion_isAtLeast(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var routerStatusEventImplementors = []string{"RouterStatusEvent"}

func (ec *executionContext) _RouterStatusEvent(ctx context.Context, sel ast.SelectionSet, obj *model.RouterStatusEvent) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, routerStatusEventImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RouterStatusEvent")
		case "router":
			out.Values[i] = ec._RouterStatusEvent_router(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "previousStatus":
			out.Values[i] = ec._RouterStatusEvent_previousStatus(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "newStatus":
			out.Values[i] = ec._RouterStatusEvent_newStatus(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "timestamp":
			out.Values[i] = ec._RouterStatusEvent_timestamp(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var scanNetworkPayloadImplementors = []string{"ScanNetworkPayload"}

func (ec *executionContext) _ScanNetworkPayload(ctx context.Context, sel ast.SelectionSet, obj *model.ScanNetworkPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, scanNetworkPayloadImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ScanNetworkPayload")
		case "task":
			out.Values[i] = ec._ScanNetworkPayload_task(ctx, field, obj)
		case "errors":
			out.Values[i] = ec._ScanNetworkPayload_errors(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var scanProgressEventImplementors = []string{"ScanProgressEvent"}

func (ec *executionContext) _ScanProgressEvent(ctx context.Context, sel ast.SelectionSet, obj *model.ScanProgressEvent) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, scanProgressEventImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ScanProgressEvent")
		case "taskId":
			out.Values[i] = ec._ScanProgressEvent_taskId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "progress":
			out.Values[i] = ec._ScanProgressEvent_progress(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "devicesFound":
			out.Values[i] = ec._ScanProgressEvent_devicesFound(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "currentIP":
			out.Values[i] = ec._ScanProgressEvent_currentIP(ctx, field, obj)
		case "status":
			out.Values[i] = ec._ScanProgressEvent_status(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "timestamp":
			out.Values[i] = ec._ScanProgressEvent_timestamp(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var scanTaskImplementors = []string{"ScanTask"}

func (ec *executionContext) _ScanTask(ctx context.Context, sel ast.SelectionSet, obj *model.ScanTask) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, scanTaskImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ScanTask")
		case "id":
			out.Values[i] = ec._ScanTask_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "subnet":
			out.Values[i] = ec._ScanTask_subnet(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "status":
			out.Values[i] = ec._ScanTask_status(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "progress":
			out.Values[i] = ec._ScanTask_progress(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "results":
			out.Values[i] = ec._ScanTask_results(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "startTime":
			out.Values[i] = ec._ScanTask_startTime(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "endTime":
			out.Values[i] = ec._ScanTask_endTime(ctx, field, obj)
		case "error":
			out.Values[i] = ec._ScanTask_error(ctx, field, obj)
		case "totalIPs":
			out.Values[i] = ec._ScanTask_totalIPs(ctx, field, obj)
		case "scannedIPs":
			out.Values[i] = ec._ScanTask_scannedIPs(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var sessionImplementors = []string{"Session"}

func (ec *executionContext) _Session(ctx context.Context, sel ast.SelectionSet, obj *model.Session) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, sessionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Session")
		case "id":
			out.Values[i] = ec._Session_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "ipAddress":
			out.Values[i] = ec._Session_ipAddress(ctx, field, obj)
		case "userAgent":
			out.Values[i] = ec._Session_userAgent(ctx, field, obj)
		case "createdAt":
			out.Values[i] = ec._Session_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "lastActivity":
			out.Values[i] = ec._Session_lastActivity(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "isCurrent":
			out.Values[i] = ec._Session_isCurrent(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var setPreferredProtocolPayloadImplementors = []string{"SetPreferredProtocolPayload"}

func (ec *executionContext) _SetPreferredProtocolPayload(ctx context.Context, sel ast.SelectionSet, obj *model.SetPreferredProtocolPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, setPreferredProtocolPayloadImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SetPreferredProtocolPayload")
		case "router":
			out.Values[i] = ec._SetPreferredProtocolPayload_router(ctx, field, obj)
		case "connectionDetails":
			out.Values[i] = ec._SetPreferredProtocolPayload_connectionDetails(ctx, field, obj)
		case "errors":
			out.Values[i] = ec._SetPreferredProtocolPayload_errors(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var softwareInfoImplementors = []string{"SoftwareInfo"}

func (ec *executionContext) _SoftwareInfo(ctx context.Context, sel ast.SelectionSet, obj *model.SoftwareInfo) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, softwareInfoImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SoftwareInfo")
		case "version":
			out.Values[i] = ec._SoftwareInfo_version(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "versionMajor":
			out.Values[i] = ec._SoftwareInfo_versionMajor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "versionMinor":
			out.Values[i] = ec._SoftwareInfo_versionMinor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "versionPatch":
			out.Values[i] = ec._SoftwareInfo_versionPatch(ctx, field, obj)
		case "installedPackages":
			out.Values[i] = ec._SoftwareInfo_installedPackages(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "licenseLevel":
			out.Values[i] = ec._SoftwareInfo_licenseLevel(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updateChannel":
			out.Values[i] = ec._SoftwareInfo_updateChannel(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var subscriptionImplementors = []string{"Subscription"}

func (ec *executionContext) _Subscription(ctx context.Context, sel ast.SelectionSet) func(ctx context.Context) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, subscriptionImplementors)
	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Subscription",
	})
	if len(fields) != 1 {
		ec.Errorf(ctx, "must subscribe to exactly one stream")
		return nil
	}

	switch fields[0].Name {
	case "routerStatusChanged":
		return ec._Subscription_routerStatusChanged(ctx, fields[0])
	case "interfaceTraffic":
		return ec._Subscription_interfaceTraffic(ctx, fields[0])
	case "resourceUpdated":
		return ec._Subscription_resourceUpdated(ctx, fields[0])
	case "configApplyProgress":
		return ec._Subscription_configApplyProgress(ctx, fields[0])
	case "connectionHealth":
		return ec._Subscription_connectionHealth(ctx, fields[0])
	case "circuitBreakerChanged":
		return ec._Subscription_circuitBreakerChanged(ctx, fields[0])
	case "circuitBreakerStateChanged":
		return ec._Subscription_circuitBreakerStateChanged(ctx, fields[0])
	case "routerAdded":
		return ec._Subscription_routerAdded(ctx, fields[0])
	case "scanProgress":
		return ec._Subscription_scanProgress(ctx, fields[0])
	default:
		panic("unknown field " + strconv.Quote(fields[0].Name))
	}
}

var tLSStatusImplementors = []string{"TLSStatus"}

func (ec *executionContext) _TLSStatus(ctx context.Context, sel ast.SelectionSet, obj *model.TLSStatus) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, tLSStatusImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TLSStatus")
		case "valid":
			out.Values[i] = ec._TLSStatus_valid(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "issuer":
			out.Values[i] = ec._TLSStatus_issuer(ctx, field, obj)
		case "subject":
			out.Values[i] = ec._TLSStatus_subject(ctx, field, obj)
		case "expiresAt":
			out.Values[i] = ec._TLSStatus_expiresAt(ctx, field, obj)
		case "error":
			out.Values[i] = ec._TLSStatus_error(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var testAllCredentialsPayloadImplementors = []string{"TestAllCredentialsPayload"}

func (ec *executionContext) _TestAllCredentialsPayload(ctx context.Context, sel ast.SelectionSet, obj *model.TestAllCredentialsPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, testAllCredentialsPayloadImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TestAllCredentialsPayload")
		case "totalRouters":
			out.Values[i] = ec._TestAllCredentialsPayload_totalRouters(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "successCount":
			out.Values[i] = ec._TestAllCredentialsPayload_successCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "failureCount":
			out.Values[i] = ec._TestAllCredentialsPayload_failureCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "results":
			out.Values[i] = ec._TestAllCredentialsPayload_results(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var testConnectionPayloadImplementors = []string{"TestConnectionPayload"}

func (ec *executionContext) _TestConnectionPayload(ctx context.Context, sel ast.SelectionSet, obj *model.TestConnectionPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, testConnectionPayloadImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TestConnectionPayload")
		case "success":
			out.Values[i] = ec._TestConnectionPayload_success(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "responseTimeMs":
			out.Values[i] = ec._TestConnectionPayload_responseTimeMs(ctx, field, obj)
		case "version":
			out.Values[i] = ec._TestConnectionPayload_version(ctx, field, obj)
		case "error":
			out.Values[i] = ec._TestConnectionPayload_error(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var updateRouterPayloadImplementors = []string{"UpdateRouterPayload"}

func (ec *executionContext) _UpdateRouterPayload(ctx context.Context, sel ast.SelectionSet, obj *model.UpdateRouterPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, updateRouterPayloadImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UpdateRouterPayload")
		case "router":
			out.Values[i] = ec._UpdateRouterPayload_router(ctx, field, obj)
		case "errors":
			out.Values[i] = ec._UpdateRouterPayload_errors(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var upgradeImpactImplementors = []string{"UpgradeImpact"}

func (ec *executionContext) _UpgradeImpact(ctx context.Context, sel ast.SelectionSet, obj *model.UpgradeImpact) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, upgradeImpactImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UpgradeImpact")
		case "requiresReboot":
			out.Values[i] = ec._UpgradeImpact_requiresReboot(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "estimatedDowntime":
			out.Values[i] = ec._UpgradeImpact_estimatedDowntime(ctx, field, obj)
		case "backupRecommended":
			out.Values[i] = ec._UpgradeImpact_backupRecommended(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "breakingChanges":
			out.Values[i] = ec._UpgradeImpact_breakingChanges(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var upgradeRecommendationImplementors = []string{"UpgradeRecommendation"}

func (ec *executionContext) _UpgradeRecommendation(ctx context.Context, sel ast.SelectionSet, obj *model.UpgradeRecommendation) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, upgradeRecommendationImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UpgradeRecommendation")
		case "featureId":
			out.Values[i] = ec._UpgradeRecommendation_featureId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "featureName":
			out.Values[i] = ec._UpgradeRecommendation_featureName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "currentVersion":
			out.Values[i] = ec._UpgradeRecommendation_currentVersion(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "requiredVersion":
			out.Values[i] = ec._UpgradeRecommendation_requiredVersion(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "isMajorUpgrade":
			out.Values[i] = ec._UpgradeRecommendation_isMajorUpgrade(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "priority":
			out.Values[i] = ec._UpgradeRecommendation_priority(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "steps":
			out.Values[i] = ec._UpgradeRecommendation_steps(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "impact":
			out.Values[i] = ec._UpgradeRecommendation_impact(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "documentationUrl":
			out.Values[i] = ec._UpgradeRecommendation_documentationUrl(ctx, field, obj)
		case "warnings":
			out.Values[i] = ec._UpgradeRecommendation_warnings(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var upgradeStepImplementors = []string{"UpgradeStep"}

func (ec *executionContext) _UpgradeStep(ctx context.Context, sel ast.SelectionSet, obj *model.UpgradeStep) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, upgradeStepImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UpgradeStep")
		case "step":
			out.Values[i] = ec._UpgradeStep_step(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "title":
			out.Values[i] = ec._UpgradeStep_title(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec._UpgradeStep_description(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "command":
			out.Values[i] = ec._UpgradeStep_command(ctx, field, obj)
		case "optional":
			out.Values[i] = ec._UpgradeStep_optional(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var userImplementors = []string{"User", "Node"}

func (ec *executionContext) _User(ctx context.Context, sel ast.SelectionSet, obj *model.User) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, userImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("User")
		case "id":
			out.Values[i] = ec._User_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "username":
			out.Values[i] = ec._User_username(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "role":
			out.Values[i] = ec._User_role(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "email":
			out.Values[i] = ec._User_email(ctx, field, obj)
		case "displayName":
			out.Values[i] = ec._User_displayName(ctx, field, obj)
		case "createdAt":
			out.Values[i] = ec._User_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "lastLoginAt":
			out.Values[i] = ec._User_lastLoginAt(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var vIFGuidanceStepImplementors = []string{"VIFGuidanceStep"}

func (ec *executionContext) _VIFGuidanceStep(ctx context.Context, sel ast.SelectionSet, obj *model.VIFGuidanceStep) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, vIFGuidanceStepImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("VIFGuidanceStep")
		case "step":
			out.Values[i] = ec._VIFGuidanceStep_step(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "title":
			out.Values[i] = ec._VIFGuidanceStep_title(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec._VIFGuidanceStep_description(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "completed":
			out.Values[i] = ec._VIFGuidanceStep_completed(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "routerCommand":
			out.Values[i] = ec._VIFGuidanceStep_routerCommand(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var vIFRequirementsImplementors = []string{"VIFRequirements"}

func (ec *executionContext) _VIFRequirements(ctx context.Context, sel ast.SelectionSet, obj *model.VIFRequirements) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, vIFRequirementsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("VIFRequirements")
		case "met":
			out.Values[i] = ec._VIFRequirements_met(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "routerOSVersion":
			out.Values[i] = ec._VIFRequirements_routerOSVersion(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "containerPackage":
			out.Values[i] = ec._VIFRequirements_containerPackage(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "containerEnabled":
			out.Values[i] = ec._VIFRequirements_containerEnabled(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "sufficientStorage":
			out.Values[i] = ec._VIFRequirements_sufficientStorage(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "networkNamespace":
			out.Values[i] = ec._VIFRequirements_networkNamespace(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "missingReasons":
			out.Values[i] = ec._VIFRequirements_missingReasons(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "guidanceSteps":
			out.Values[i] = ec._VIFRequirements_guidanceSteps(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var validationErrorImplementors = []string{"ValidationError"}

func (ec *executionContext) _ValidationError(ctx context.Context, sel ast.SelectionSet, obj *model.ValidationError) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, validationErrorImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ValidationError")
		case "field":
			out.Values[i] = ec._ValidationError_field(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "code":
			out.Values[i] = ec._ValidationError_code(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "message":
			out.Values[i] = ec._ValidationError_message(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "suggestion":
			out.Values[i] = ec._ValidationError_suggestion(ctx, field, obj)
		case "providedValue":
			out.Values[i] = ec._ValidationError_providedValue(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __DirectiveImplementors = []string{"__Directive"}

func (ec *executionContext) ___Directive(ctx context.Context, sel ast.SelectionSet, obj *introspection.Directive) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __DirectiveImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Directive")
		case "name":
			out.Values[i] = ec.___Directive_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___Directive_description(ctx, field, obj)
		case "locations":
			out.Values[i] = ec.___Directive_locations(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "args":
			out.Values[i] = ec.___Directive_args(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "isRepeatable":
			out.Values[i] = ec.___Directive_isRepeatable(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __EnumValueImplementors = []string{"__EnumValue"}

func (ec *executionContext) ___EnumValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.EnumValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __EnumValueImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__EnumValue")
		case "name":
			out.Values[i] = ec.___EnumValue_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___EnumValue_description(ctx, field, obj)
		case "isDeprecated":
			out.Values[i] = ec.___EnumValue_isDeprecated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deprecationReason":
			out.Values[i] = ec.___EnumValue_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __FieldImplementors = []string{"__Field"}

func (ec *executionContext) ___Field(ctx context.Context, sel ast.SelectionSet, obj *introspection.Field) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __FieldImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Field")
		case "name":
			out.Values[i] = ec.___Field_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___Field_description(ctx, field, obj)
		case "args":
			out.Values[i] = ec.___Field_args(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "type":
			out.Values[i] = ec.___Field_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "isDeprecated":
			out.Values[i] = ec.___Field_isDeprecated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deprecationReason":
			out.Values[i] = ec.___Field_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __InputValueImplementors = []string{"__InputValue"}

func (ec *executionContext) ___InputValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.InputValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __InputValueImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__InputValue")
		case "name":
			out.Values[i] = ec.___InputValue_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___InputValue_description(ctx, field, obj)
		case "type":
			out.Values[i] = ec.___InputValue_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "defaultValue":
			out.Values[i] = ec.___InputValue_defaultValue(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __SchemaImplementors = []string{"__Schema"}

func (ec *executionContext) ___Schema(ctx context.Context, sel ast.SelectionSet, obj *introspection.Schema) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __SchemaImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Schema")
		case "description":
			out.Values[i] = ec.___Schema_description(ctx, field, obj)
		case "types":
			out.Values[i] = ec.___Schema_types(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "queryType":
			out.Values[i] = ec.___Schema_queryType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "mutationType":
			out.Values[i] = ec.___Schema_mutationType(ctx, field, obj)
		case "subscriptionType":
			out.Values[i] = ec.___Schema_subscriptionType(ctx, field, obj)
		case "directives":
			out.Values[i] = ec.___Schema_directives(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __TypeImplementors = []string{"__Type"}

func (ec *executionContext) ___Type(ctx context.Context, sel ast.SelectionSet, obj *introspection.Type) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __TypeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Type")
		case "kind":
			out.Values[i] = ec.___Type_kind(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec.___Type_name(ctx, field, obj)
		case "description":
			out.Values[i] = ec.___Type_description(ctx, field, obj)
		case "fields":
			out.Values[i] = ec.___Type_fields(ctx, field, obj)
		case "interfaces":
			out.Values[i] = ec.___Type_interfaces(ctx, field, obj)
		case "possibleTypes":
			out.Values[i] = ec.___Type_possibleTypes(ctx, field, obj)
		case "enumValues":
			out.Values[i] = ec.___Type_enumValues(ctx, field, obj)
		case "inputFields":
			out.Values[i] = ec.___Type_inputFields(ctx, field, obj)
		case "ofType":
			out.Values[i] = ec.___Type_ofType(ctx, field, obj)
		case "specifiedByURL":
			out.Values[i] = ec.___Type_specifiedByURL(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

// endregion **************************** object.gotpl ****************************

// region    ***************************** type.gotpl *****************************

func (ec *executionContext) unmarshalNAddRouterInput2backendgraphmodelAddRouterInput(ctx context.Context, v interface{}) (model.AddRouterInput, error) {
	res, err := ec.unmarshalInputAddRouterInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNAddRouterPayload2backendgraphmodelAddRouterPayload(ctx context.Context, sel ast.SelectionSet, v model.AddRouterPayload) graphql.Marshaler {
	return ec._AddRouterPayload(ctx, sel, &v)
}

func (ec *executionContext) marshalNAddRouterPayload2backendgraphmodelAddRouterPayload(ctx context.Context, sel ast.SelectionSet, v *model.AddRouterPayload) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._AddRouterPayload(ctx, sel, v)
}

func (ec *executionContext) marshalNAuthPayload2backendgraphmodelAuthPayload(ctx context.Context, sel ast.SelectionSet, v model.AuthPayload) graphql.Marshaler {
	return ec._AuthPayload(ctx, sel, &v)
}

func (ec *executionContext) marshalNAuthPayload2backendgraphmodelAuthPayload(ctx context.Context, sel ast.SelectionSet, v *model.AuthPayload) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._AuthPayload(ctx, sel, v)
}

func (ec *executionContext) marshalNAuthStatus2backendgraphmodelAuthStatus(ctx context.Context, sel ast.SelectionSet, v *model.AuthStatus) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._AuthStatus(ctx, sel, v)
}

func (ec *executionContext) unmarshalNBoolean2bool(ctx context.Context, v interface{}) (bool, error) {
	res, err := graphql.UnmarshalBoolean(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	res := graphql.MarshalBoolean(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNCancelScanPayload2backendgraphmodelCancelScanPayload(ctx context.Context, sel ast.SelectionSet, v model.CancelScanPayload) graphql.Marshaler {
	return ec._CancelScanPayload(ctx, sel, &v)
}

func (ec *executionContext) marshalNCancelScanPayload2backendgraphmodelCancelScanPayload(ctx context.Context, sel ast.SelectionSet, v *model.CancelScanPayload) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._CancelScanPayload(ctx, sel, v)
}

func (ec *executionContext) unmarshalNCapability2backendgraphmodelCapability(ctx context.Context, v interface{}) (model.Capability, error) {
	var res model.Capability
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNCapability2backendgraphmodelCapability(ctx context.Context, sel ast.SelectionSet, v model.Capability) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNCapabilityEntry2backendgraphmodelCapabilityEntry(ctx context.Context, sel ast.SelectionSet, v []*model.CapabilityEntry) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNCapabilityEntry2backendgraphmodelCapabilityEntry(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNCapabilityEntry2backendgraphmodelCapabilityEntry(ctx context.Context, sel ast.SelectionSet, v *model.CapabilityEntry) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._CapabilityEntry(ctx, sel, v)
}

func (ec *executionContext) unmarshalNCapabilityLevel2backendgraphmodelCapabilityLevel(ctx context.Context, v interface{}) (model.CapabilityLevel, error) {
	var res model.CapabilityLevel
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNCapabilityLevel2backendgraphmodelCapabilityLevel(ctx context.Context, sel ast.SelectionSet, v model.CapabilityLevel) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNChangeType2backendgraphmodelChangeType(ctx context.Context, v interface{}) (model.ChangeType, error) {
	var res model.ChangeType
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNChangeType2backendgraphmodelChangeType(ctx context.Context, sel ast.SelectionSet, v model.ChangeType) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNCircuitBreakerEvent2backendgraphmodelCircuitBreakerEvent(ctx context.Context, sel ast.SelectionSet, v model.CircuitBreakerEvent) graphql.Marshaler {
	return ec._CircuitBreakerEvent(ctx, sel, &v)
}

func (ec *executionContext) marshalNCircuitBreakerEvent2backendgraphmodelCircuitBreakerEvent(ctx context.Context, sel ast.SelectionSet, v *model.CircuitBreakerEvent) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._CircuitBreakerEvent(ctx, sel, v)
}

func (ec *executionContext) unmarshalNCircuitBreakerState2backendgraphmodelCircuitBreakerState(ctx context.Context, v interface{}) (model.CircuitBreakerState, error) {
	var res model.CircuitBreakerState
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNCircuitBreakerState2backendgraphmodelCircuitBreakerState(ctx context.Context, sel ast.SelectionSet, v model.CircuitBreakerState) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNCircuitBreakerStatus2backendgraphmodelCircuitBreakerStatus(ctx context.Context, sel ast.SelectionSet, v model.CircuitBreakerStatus) graphql.Marshaler {
	return ec._CircuitBreakerStatus(ctx, sel, &v)
}

func (ec *executionContext) marshalNCircuitBreakerStatus2backendgraphmodelCircuitBreakerStatus(ctx context.Context, sel ast.SelectionSet, v *model.CircuitBreakerStatus) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._CircuitBreakerStatus(ctx, sel, v)
}

func (ec *executionContext) unmarshalNConfigApplyStatus2backendgraphmodelConfigApplyStatus(ctx context.Context, v interface{}) (model.ConfigApplyStatus, error) {
	var res model.ConfigApplyStatus
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNConfigApplyStatus2backendgraphmodelConfigApplyStatus(ctx context.Context, sel ast.SelectionSet, v model.ConfigApplyStatus) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNConfigProgress2backendgraphmodelConfigProgress(ctx context.Context, sel ast.SelectionSet, v model.ConfigProgress) graphql.Marshaler {
	return ec._ConfigProgress(ctx, sel, &v)
}

func (ec *executionContext) marshalNConfigProgress2backendgraphmodelConfigProgress(ctx context.Context, sel ast.SelectionSet, v *model.ConfigProgress) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ConfigProgress(ctx, sel, v)
}

func (ec *executionContext) marshalNConnectRouterPayload2backendgraphmodelConnectRouterPayload(ctx context.Context, sel ast.SelectionSet, v model.ConnectRouterPayload) graphql.Marshaler {
	return ec._ConnectRouterPayload(ctx, sel, &v)
}

func (ec *executionContext) marshalNConnectRouterPayload2backendgraphmodelConnectRouterPayload(ctx context.Context, sel ast.SelectionSet, v *model.ConnectRouterPayload) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ConnectRouterPayload(ctx, sel, v)
}

func (ec *executionContext) marshalNConnectionAttempt2backendgraphmodelConnectionAttempt(ctx context.Context, sel ast.SelectionSet, v []*model.ConnectionAttempt) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNConnectionAttempt2backendgraphmodelConnectionAttempt(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNConnectionAttempt2backendgraphmodelConnectionAttempt(ctx context.Context, sel ast.SelectionSet, v *model.ConnectionAttempt) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ConnectionAttempt(ctx, sel, v)
}

func (ec *executionContext) unmarshalNConnectionErrorCode2backendgraphmodelConnectionErrorCode(ctx context.Context, v interface{}) (model.ConnectionErrorCode, error) {
	var res model.ConnectionErrorCode
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNConnectionErrorCode2backendgraphmodelConnectionErrorCode(ctx context.Context, sel ast.SelectionSet, v model.ConnectionErrorCode) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNConnectionStats2backendgraphmodelConnectionStats(ctx context.Context, sel ast.SelectionSet, v model.ConnectionStats) graphql.Marshaler {
	return ec._ConnectionStats(ctx, sel, &v)
}

func (ec *executionContext) marshalNConnectionStats2backendgraphmodelConnectionStats(ctx context.Context, sel ast.SelectionSet, v *model.ConnectionStats) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ConnectionStats(ctx, sel, v)
}

func (ec *executionContext) unmarshalNConnectionStatus2backendgraphmodelConnectionStatus(ctx context.Context, v interface{}) (model.ConnectionStatus, error) {
	var res model.ConnectionStatus
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNConnectionStatus2backendgraphmodelConnectionStatus(ctx context.Context, sel ast.SelectionSet, v model.ConnectionStatus) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNConnectionTestResult2backendgraphmodelConnectionTestResult(ctx context.Context, sel ast.SelectionSet, v model.ConnectionTestResult) graphql.Marshaler {
	return ec._ConnectionTestResult(ctx, sel, &v)
}

func (ec *executionContext) marshalNConnectionTestResult2backendgraphmodelConnectionTestResult(ctx context.Context, sel ast.SelectionSet, v *model.ConnectionTestResult) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ConnectionTestResult(ctx, sel, v)
}

func (ec *executionContext) marshalNContainerInfo2backendgraphmodelContainerInfo(ctx context.Context, sel ast.SelectionSet, v *model.ContainerInfo) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ContainerInfo(ctx, sel, v)
}

func (ec *executionContext) unmarshalNCreateRouterInput2backendgraphmodelCreateRouterInput(ctx context.Context, v interface{}) (model.CreateRouterInput, error) {
	res, err := ec.unmarshalInputCreateRouterInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNCreateRouterPayload2backendgraphmodelCreateRouterPayload(ctx context.Context, sel ast.SelectionSet, v model.CreateRouterPayload) graphql.Marshaler {
	return ec._CreateRouterPayload(ctx, sel, &v)
}

func (ec *executionContext) marshalNCreateRouterPayload2backendgraphmodelCreateRouterPayload(ctx context.Context, sel ast.SelectionSet, v *model.CreateRouterPayload) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._CreateRouterPayload(ctx, sel, v)
}

func (ec *executionContext) marshalNCredentialTestResult2backendgraphmodelCredentialTestResult(ctx context.Context, sel ast.SelectionSet, v []*model.CredentialTestResult) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNCredentialTestResult2backendgraphmodelCredentialTestResult(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNCredentialTestResult2backendgraphmodelCredentialTestResult(ctx context.Context, sel ast.SelectionSet, v *model.CredentialTestResult) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._CredentialTestResult(ctx, sel, v)
}

func (ec *executionContext) unmarshalNCredentialTestStatus2backendgraphmodelCredentialTestStatus(ctx context.Context, v interface{}) (model.CredentialTestStatus, error) {
	var res model.CredentialTestStatus
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNCredentialTestStatus2backendgraphmodelCredentialTestStatus(ctx context.Context, sel ast.SelectionSet, v model.CredentialTestStatus) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNCredentialUpdatePayload2backendgraphmodelCredentialUpdatePayload(ctx context.Context, sel ast.SelectionSet, v model.CredentialUpdatePayload) graphql.Marshaler {
	return ec._CredentialUpdatePayload(ctx, sel, &v)
}

func (ec *executionContext) marshalNCredentialUpdatePayload2backendgraphmodelCredentialUpdatePayload(ctx context.Context, sel ast.SelectionSet, v *model.CredentialUpdatePayload) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._CredentialUpdatePayload(ctx, sel, v)
}

func (ec *executionContext) unmarshalNCredentialsInput2backendgraphmodelCredentialsInput(ctx context.Context, v interface{}) (model.CredentialsInput, error) {
	res, err := ec.unmarshalInputCredentialsInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNDateTime2timeTime(ctx context.Context, v interface{}) (time.Time, error) {
	res, err := graphql.UnmarshalTime(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNDateTime2timeTime(ctx context.Context, sel ast.SelectionSet, v time.Time) graphql.Marshaler {
	res := graphql.MarshalTime(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNDeleteRouterPayload2backendgraphmodelDeleteRouterPayload(ctx context.Context, sel ast.SelectionSet, v model.DeleteRouterPayload) graphql.Marshaler {
	return ec._DeleteRouterPayload(ctx, sel, &v)
}

func (ec *executionContext) marshalNDeleteRouterPayload2backendgraphmodelDeleteRouterPayload(ctx context.Context, sel ast.SelectionSet, v *model.DeleteRouterPayload) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._DeleteRouterPayload(ctx, sel, v)
}

func (ec *executionContext) marshalNDiagnosticReport2backendgraphmodelDiagnosticReport(ctx context.Context, sel ast.SelectionSet, v model.DiagnosticReport) graphql.Marshaler {
	return ec._DiagnosticReport(ctx, sel, &v)
}

func (ec *executionContext) marshalNDiagnosticReport2backendgraphmodelDiagnosticReport(ctx context.Context, sel ast.SelectionSet, v *model.DiagnosticReport) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._DiagnosticReport(ctx, sel, v)
}

func (ec *executionContext) marshalNDiagnosticSuggestion2backendgraphmodelDiagnosticSuggestion(ctx context.Context, sel ast.SelectionSet, v []*model.DiagnosticSuggestion) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNDiagnosticSuggestion2backendgraphmodelDiagnosticSuggestion(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNDiagnosticSuggestion2backendgraphmodelDiagnosticSuggestion(ctx context.Context, sel ast.SelectionSet, v *model.DiagnosticSuggestion) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._DiagnosticSuggestion(ctx, sel, v)
}

func (ec *executionContext) marshalNDisconnectRouterPayload2backendgraphmodelDisconnectRouterPayload(ctx context.Context, sel ast.SelectionSet, v model.DisconnectRouterPayload) graphql.Marshaler {
	return ec._DisconnectRouterPayload(ctx, sel, &v)
}

func (ec *executionContext) marshalNDisconnectRouterPayload2backendgraphmodelDisconnectRouterPayload(ctx context.Context, sel ast.SelectionSet, v *model.DisconnectRouterPayload) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._DisconnectRouterPayload(ctx, sel, v)
}

func (ec *executionContext) marshalNDiscoveredDevice2backendgraphmodelDiscoveredDevice(ctx context.Context, sel ast.SelectionSet, v []*model.DiscoveredDevice) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNDiscoveredDevice2backendgraphmodelDiscoveredDevice(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNDiscoveredDevice2backendgraphmodelDiscoveredDevice(ctx context.Context, sel ast.SelectionSet, v *model.DiscoveredDevice) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._DiscoveredDevice(ctx, sel, v)
}

func (ec *executionContext) unmarshalNExportConfigInput2backendgraphmodelExportConfigInput(ctx context.Context, v interface{}) (model.ExportConfigInput, error) {
	res, err := ec.unmarshalInputExportConfigInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNExportConfigPayload2backendgraphmodelExportConfigPayload(ctx context.Context, sel ast.SelectionSet, v model.ExportConfigPayload) graphql.Marshaler {
	return ec._ExportConfigPayload(ctx, sel, &v)
}

func (ec *executionContext) marshalNExportConfigPayload2backendgraphmodelExportConfigPayload(ctx context.Context, sel ast.SelectionSet, v *model.ExportConfigPayload) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ExportConfigPayload(ctx, sel, v)
}

func (ec *executionContext) marshalNFeatureCompatibilityInfo2backendgraphmodelFeatureCompatibilityInfo(ctx context.Context, sel ast.SelectionSet, v []*model.FeatureCompatibilityInfo) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNFeatureCompatibilityInfo2backendgraphmodelFeatureCompatibilityInfo(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNFeatureCompatibilityInfo2backendgraphmodelFeatureCompatibilityInfo(ctx context.Context, sel ast.SelectionSet, v *model.FeatureCompatibilityInfo) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._FeatureCompatibilityInfo(ctx, sel, v)
}

func (ec *executionContext) marshalNFeatureSupport2backendgraphmodelFeatureSupport(ctx context.Context, sel ast.SelectionSet, v model.FeatureSupport) graphql.Marshaler {
	return ec._FeatureSupport(ctx, sel, &v)
}

func (ec *executionContext) marshalNFeatureSupport2backendgraphmodelFeatureSupport(ctx context.Context, sel ast.SelectionSet, v []*model.FeatureSupport) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNFeatureSupport2backendgraphmodelFeatureSupport(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNFeatureSupport2backendgraphmodelFeatureSupport(ctx context.Context, sel ast.SelectionSet, v *model.FeatureSupport) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._FeatureSupport(ctx, sel, v)
}

func (ec *executionContext) marshalNHardwareInfo2backendgraphmodelHardwareInfo(ctx context.Context, sel ast.SelectionSet, v *model.HardwareInfo) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._HardwareInfo(ctx, sel, v)
}

func (ec *executionContext) marshalNHealthCheckResult2backendgraphmodelHealthCheckResult(ctx context.Context, sel ast.SelectionSet, v model.HealthCheckResult) graphql.Marshaler {
	return ec._HealthCheckResult(ctx, sel, &v)
}

func (ec *executionContext) marshalNHealthCheckResult2backendgraphmodelHealthCheckResult(ctx context.Context, sel ast.SelectionSet, v *model.HealthCheckResult) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._HealthCheckResult(ctx, sel, v)
}

func (ec *executionContext) marshalNHealthStatus2backendgraphmodelHealthStatus(ctx context.Context, sel ast.SelectionSet, v model.HealthStatus) graphql.Marshaler {
	return ec._HealthStatus(ctx, sel, &v)
}

func (ec *executionContext) marshalNHealthStatus2backendgraphmodelHealthStatus(ctx context.Context, sel ast.SelectionSet, v *model.HealthStatus) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._HealthStatus(ctx, sel, v)
}

func (ec *executionContext) unmarshalNID2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalID(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNID2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalID(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNInt2int(ctx context.Context, v interface{}) (int, error) {
	res, err := graphql.UnmarshalInt(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNInt2int(ctx context.Context, sel ast.SelectionSet, v int) graphql.Marshaler {
	res := graphql.MarshalInt(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNInt2int(ctx context.Context, v interface{}) ([]int, error) {
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]int, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNInt2int(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNInt2int(ctx context.Context, sel ast.SelectionSet, v []int) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNInt2int(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNInterface2backendgraphmodelInterface(ctx context.Context, sel ast.SelectionSet, v *model.Interface) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Interface(ctx, sel, v)
}

func (ec *executionContext) marshalNInterfaceConnection2backendgraphmodelInterfaceConnection(ctx context.Context, sel ast.SelectionSet, v model.InterfaceConnection) graphql.Marshaler {
	return ec._InterfaceConnection(ctx, sel, &v)
}

func (ec *executionContext) marshalNInterfaceConnection2backendgraphmodelInterfaceConnection(ctx context.Context, sel ast.SelectionSet, v *model.InterfaceConnection) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._InterfaceConnection(ctx, sel, v)
}

func (ec *executionContext) marshalNInterfaceEdge2backendgraphmodelInterfaceEdge(ctx context.Context, sel ast.SelectionSet, v []*model.InterfaceEdge) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNInterfaceEdge2backendgraphmodelInterfaceEdge(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNInterfaceEdge2backendgraphmodelInterfaceEdge(ctx context.Context, sel ast.SelectionSet, v *model.InterfaceEdge) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._InterfaceEdge(ctx, sel, v)
}

func (ec *executionContext) marshalNInterfaceTrafficEvent2backendgraphmodelInterfaceTrafficEvent(ctx context.Context, sel ast.SelectionSet, v model.InterfaceTrafficEvent) graphql.Marshaler {
	return ec._InterfaceTrafficEvent(ctx, sel, &v)
}

func (ec *executionContext) marshalNInterfaceTrafficEvent2backendgraphmodelInterfaceTrafficEvent(ctx context.Context, sel ast.SelectionSet, v *model.InterfaceTrafficEvent) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._InterfaceTrafficEvent(ctx, sel, v)
}

func (ec *executionContext) unmarshalNInterfaceType2backendgraphmodelInterfaceType(ctx context.Context, v interface{}) (model.InterfaceType, error) {
	var res model.InterfaceType
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNInterfaceType2backendgraphmodelInterfaceType(ctx context.Context, sel ast.SelectionSet, v model.InterfaceType) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNMutationError2backendgraphmodelMutationError(ctx context.Context, sel ast.SelectionSet, v *model.MutationError) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._MutationError(ctx, sel, v)
}

func (ec *executionContext) marshalNPageInfo2backendgraphmodelPageInfo(ctx context.Context, sel ast.SelectionSet, v *model.PageInfo) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._PageInfo(ctx, sel, v)
}

func (ec *executionContext) marshalNPortStatus2backendgraphmodelPortStatus(ctx context.Context, sel ast.SelectionSet, v []*model.PortStatus) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNPortStatus2backendgraphmodelPortStatus(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNPortStatus2backendgraphmodelPortStatus(ctx context.Context, sel ast.SelectionSet, v *model.PortStatus) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._PortStatus(ctx, sel, v)
}

func (ec *executionContext) unmarshalNProtocol2backendgraphmodelProtocol(ctx context.Context, v interface{}) (model.Protocol, error) {
	var res model.Protocol
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNProtocol2backendgraphmodelProtocol(ctx context.Context, sel ast.SelectionSet, v model.Protocol) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNProtocol2backendgraphmodelProtocol(ctx context.Context, v interface{}) ([]model.Protocol, error) {
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]model.Protocol, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNProtocol2backendgraphmodelProtocol(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNProtocol2backendgraphmodelProtocol(ctx context.Context, sel ast.SelectionSet, v []model.Protocol) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNProtocol2backendgraphmodelProtocol(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNReconnectRouterPayload2backendgraphmodelReconnectRouterPayload(ctx context.Context, sel ast.SelectionSet, v model.ReconnectRouterPayload) graphql.Marshaler {
	return ec._ReconnectRouterPayload(ctx, sel, &v)
}

func (ec *executionContext) marshalNReconnectRouterPayload2backendgraphmodelReconnectRouterPayload(ctx context.Context, sel ast.SelectionSet, v *model.ReconnectRouterPayload) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ReconnectRouterPayload(ctx, sel, v)
}

func (ec *executionContext) marshalNRefreshCapabilitiesPayload2backendgraphmodelRefreshCapabilitiesPayload(ctx context.Context, sel ast.SelectionSet, v model.RefreshCapabilitiesPayload) graphql.Marshaler {
	return ec._RefreshCapabilitiesPayload(ctx, sel, &v)
}

func (ec *executionContext) marshalNRefreshCapabilitiesPayload2backendgraphmodelRefreshCapabilitiesPayload(ctx context.Context, sel ast.SelectionSet, v *model.RefreshCapabilitiesPayload) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._RefreshCapabilitiesPayload(ctx, sel, v)
}

func (ec *executionContext) marshalNResourceUpdatedEvent2backendgraphmodelResourceUpdatedEvent(ctx context.Context, sel ast.SelectionSet, v model.ResourceUpdatedEvent) graphql.Marshaler {
	return ec._ResourceUpdatedEvent(ctx, sel, &v)
}

func (ec *executionContext) marshalNResourceUpdatedEvent2backendgraphmodelResourceUpdatedEvent(ctx context.Context, sel ast.SelectionSet, v *model.ResourceUpdatedEvent) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ResourceUpdatedEvent(ctx, sel, v)
}

func (ec *executionContext) marshalNRouter2backendgraphmodelRouter(ctx context.Context, sel ast.SelectionSet, v *model.Router) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Router(ctx, sel, v)
}

func (ec *executionContext) marshalNRouterAddedEvent2backendgraphmodelRouterAddedEvent(ctx context.Context, sel ast.SelectionSet, v model.RouterAddedEvent) graphql.Marshaler {
	return ec._RouterAddedEvent(ctx, sel, &v)
}

func (ec *executionContext) marshalNRouterAddedEvent2backendgraphmodelRouterAddedEvent(ctx context.Context, sel ast.SelectionSet, v *model.RouterAddedEvent) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._RouterAddedEvent(ctx, sel, v)
}

func (ec *executionContext) marshalNRouterConnection2backendgraphmodelRouterConnection(ctx context.Context, sel ast.SelectionSet, v model.RouterConnection) graphql.Marshaler {
	return ec._RouterConnection(ctx, sel, &v)
}

func (ec *executionContext) marshalNRouterConnection2backendgraphmodelRouterConnection(ctx context.Context, sel ast.SelectionSet, v *model.RouterConnection) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._RouterConnection(ctx, sel, v)
}

func (ec *executionContext) marshalNRouterEdge2backendgraphmodelRouterEdge(ctx context.Context, sel ast.SelectionSet, v []*model.RouterEdge) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNRouterEdge2backendgraphmodelRouterEdge(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNRouterEdge2backendgraphmodelRouterEdge(ctx context.Context, sel ast.SelectionSet, v *model.RouterEdge) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._RouterEdge(ctx, sel, v)
}

func (ec *executionContext) marshalNRouterOSVersion2backendgraphmodelRouterOSVersion(ctx context.Context, sel ast.SelectionSet, v *model.RouterOSVersion) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._RouterOSVersion(ctx, sel, v)
}

func (ec *executionContext) unmarshalNRouterPlatform2backendgraphmodelRouterPlatform(ctx context.Context, v interface{}) (model.RouterPlatform, error) {
	var res model.RouterPlatform
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNRouterPlatform2backendgraphmodelRouterPlatform(ctx context.Context, sel ast.SelectionSet, v model.RouterPlatform) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNRouterStatusEvent2backendgraphmodelRouterStatusEvent(ctx context.Context, sel ast.SelectionSet, v model.RouterStatusEvent) graphql.Marshaler {
	return ec._RouterStatusEvent(ctx, sel, &v)
}

func (ec *executionContext) marshalNRouterStatusEvent2backendgraphmodelRouterStatusEvent(ctx context.Context, sel ast.SelectionSet, v *model.RouterStatusEvent) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._RouterStatusEvent(ctx, sel, v)
}

func (ec *executionContext) unmarshalNScanNetworkInput2backendgraphmodelScanNetworkInput(ctx context.Context, v interface{}) (model.ScanNetworkInput, error) {
	res, err := ec.unmarshalInputScanNetworkInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNScanNetworkPayload2backendgraphmodelScanNetworkPayload(ctx context.Context, sel ast.SelectionSet, v model.ScanNetworkPayload) graphql.Marshaler {
	return ec._ScanNetworkPayload(ctx, sel, &v)
}

func (ec *executionContext) marshalNScanNetworkPayload2backendgraphmodelScanNetworkPayload(ctx context.Context, sel ast.SelectionSet, v *model.ScanNetworkPayload) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ScanNetworkPayload(ctx, sel, v)
}

func (ec *executionContext) marshalNScanProgressEvent2backendgraphmodelScanProgressEvent(ctx context.Context, sel ast.SelectionSet, v model.ScanProgressEvent) graphql.Marshaler {
	return ec._ScanProgressEvent(ctx, sel, &v)
}

func (ec *executionContext) marshalNScanProgressEvent2backendgraphmodelScanProgressEvent(ctx context.Context, sel ast.SelectionSet, v *model.ScanProgressEvent) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ScanProgressEvent(ctx, sel, v)
}

func (ec *executionContext) unmarshalNScanStatus2backendgraphmodelScanStatus(ctx context.Context, v interface{}) (model.ScanStatus, error) {
	var res model.ScanStatus
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNScanStatus2backendgraphmodelScanStatus(ctx context.Context, sel ast.SelectionSet, v model.ScanStatus) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNScanTask2backendgraphmodelScanTask(ctx context.Context, sel ast.SelectionSet, v []*model.ScanTask) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNScanTask2backendgraphmodelScanTask(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNScanTask2backendgraphmodelScanTask(ctx context.Context, sel ast.SelectionSet, v *model.ScanTask) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ScanTask(ctx, sel, v)
}

func (ec *executionContext) unmarshalNServiceStatus2backendgraphmodelServiceStatus(ctx context.Context, v interface{}) (model.ServiceStatus, error) {
	var res model.ServiceStatus
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNServiceStatus2backendgraphmodelServiceStatus(ctx context.Context, sel ast.SelectionSet, v model.ServiceStatus) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNSession2backendgraphmodelSession(ctx context.Context, sel ast.SelectionSet, v []*model.Session) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNSession2backendgraphmodelSession(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNSession2backendgraphmodelSession(ctx context.Context, sel ast.SelectionSet, v *model.Session) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Session(ctx, sel, v)
}

func (ec *executionContext) marshalNSetPreferredProtocolPayload2backendgraphmodelSetPreferredProtocolPayload(ctx context.Context, sel ast.SelectionSet, v model.SetPreferredProtocolPayload) graphql.Marshaler {
	return ec._SetPreferredProtocolPayload(ctx, sel, &v)
}

func (ec *executionContext) marshalNSetPreferredProtocolPayload2backendgraphmodelSetPreferredProtocolPayload(ctx context.Context, sel ast.SelectionSet, v *model.SetPreferredProtocolPayload) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._SetPreferredProtocolPayload(ctx, sel, v)
}

func (ec *executionContext) unmarshalNSize2backendgraphmodelSize(ctx context.Context, v interface{}) (model.Size, error) {
	var res model.Size
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNSize2backendgraphmodelSize(ctx context.Context, sel ast.SelectionSet, v model.Size) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNSoftwareInfo2backendgraphmodelSoftwareInfo(ctx context.Context, sel ast.SelectionSet, v *model.SoftwareInfo) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._SoftwareInfo(ctx, sel, v)
}

func (ec *executionContext) unmarshalNString2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNString2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNString2string(ctx context.Context, v interface{}) ([]string, error) {
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNString2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNString2string(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNString2string(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNSuggestionSeverity2backendgraphmodelSuggestionSeverity(ctx context.Context, v interface{}) (model.SuggestionSeverity, error) {
	var res model.SuggestionSeverity
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNSuggestionSeverity2backendgraphmodelSuggestionSeverity(ctx context.Context, sel ast.SelectionSet, v model.SuggestionSeverity) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNTestAllCredentialsPayload2backendgraphmodelTestAllCredentialsPayload(ctx context.Context, sel ast.SelectionSet, v model.TestAllCredentialsPayload) graphql.Marshaler {
	return ec._TestAllCredentialsPayload(ctx, sel, &v)
}

func (ec *executionContext) marshalNTestAllCredentialsPayload2backendgraphmodelTestAllCredentialsPayload(ctx context.Context, sel ast.SelectionSet, v *model.TestAllCredentialsPayload) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._TestAllCredentialsPayload(ctx, sel, v)
}

func (ec *executionContext) marshalNTestConnectionPayload2backendgraphmodelTestConnectionPayload(ctx context.Context, sel ast.SelectionSet, v model.TestConnectionPayload) graphql.Marshaler {
	return ec._TestConnectionPayload(ctx, sel, &v)
}

func (ec *executionContext) marshalNTestConnectionPayload2backendgraphmodelTestConnectionPayload(ctx context.Context, sel ast.SelectionSet, v *model.TestConnectionPayload) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._TestConnectionPayload(ctx, sel, v)
}

func (ec *executionContext) unmarshalNUpdateRouterInput2backendgraphmodelUpdateRouterInput(ctx context.Context, v interface{}) (model.UpdateRouterInput, error) {
	res, err := ec.unmarshalInputUpdateRouterInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNUpdateRouterPayload2backendgraphmodelUpdateRouterPayload(ctx context.Context, sel ast.SelectionSet, v model.UpdateRouterPayload) graphql.Marshaler {
	return ec._UpdateRouterPayload(ctx, sel, &v)
}

func (ec *executionContext) marshalNUpdateRouterPayload2backendgraphmodelUpdateRouterPayload(ctx context.Context, sel ast.SelectionSet, v *model.UpdateRouterPayload) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._UpdateRouterPayload(ctx, sel, v)
}

func (ec *executionContext) marshalNUpgradeImpact2backendgraphmodelUpgradeImpact(ctx context.Context, sel ast.SelectionSet, v *model.UpgradeImpact) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._UpgradeImpact(ctx, sel, v)
}

func (ec *executionContext) unmarshalNUpgradePriority2backendgraphmodelUpgradePriority(ctx context.Context, v interface{}) (model.UpgradePriority, error) {
	var res model.UpgradePriority
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNUpgradePriority2backendgraphmodelUpgradePriority(ctx context.Context, sel ast.SelectionSet, v model.UpgradePriority) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNUpgradeRecommendation2backendgraphmodelUpgradeRecommendation(ctx context.Context, sel ast.SelectionSet, v []*model.UpgradeRecommendation) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNUpgradeRecommendation2backendgraphmodelUpgradeRecommendation(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNUpgradeRecommendation2backendgraphmodelUpgradeRecommendation(ctx context.Context, sel ast.SelectionSet, v *model.UpgradeRecommendation) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._UpgradeRecommendation(ctx, sel, v)
}

func (ec *executionContext) marshalNUpgradeStep2backendgraphmodelUpgradeStep(ctx context.Context, sel ast.SelectionSet, v []*model.UpgradeStep) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNUpgradeStep2backendgraphmodelUpgradeStep(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNUpgradeStep2backendgraphmodelUpgradeStep(ctx context.Context, sel ast.SelectionSet, v *model.UpgradeStep) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._UpgradeStep(ctx, sel, v)
}

func (ec *executionContext) marshalNUser2backendgraphmodelUser(ctx context.Context, sel ast.SelectionSet, v *model.User) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._User(ctx, sel, v)
}

func (ec *executionContext) unmarshalNUserRole2backendgraphmodelUserRole(ctx context.Context, v interface{}) (model.UserRole, error) {
	tmp, err := graphql.UnmarshalString(v)
	res := model.UserRole(tmp)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNUserRole2backendgraphmodelUserRole(ctx context.Context, sel ast.SelectionSet, v model.UserRole) graphql.Marshaler {
	res := graphql.MarshalString(string(v))
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNVIFGuidanceStep2backendgraphmodelVIFGuidanceStep(ctx context.Context, sel ast.SelectionSet, v []*model.VIFGuidanceStep) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNVIFGuidanceStep2backendgraphmodelVIFGuidanceStep(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNVIFGuidanceStep2backendgraphmodelVIFGuidanceStep(ctx context.Context, sel ast.SelectionSet, v *model.VIFGuidanceStep) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._VIFGuidanceStep(ctx, sel, v)
}

func (ec *executionContext) marshalNVIFRequirements2backendgraphmodelVIFRequirements(ctx context.Context, sel ast.SelectionSet, v *model.VIFRequirements) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._VIFRequirements(ctx, sel, v)
}

func (ec *executionContext) marshalNValidationError2backendgraphmodelValidationError(ctx context.Context, sel ast.SelectionSet, v *model.ValidationError) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ValidationError(ctx, sel, v)
}

func (ec *executionContext) marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective(ctx context.Context, sel ast.SelectionSet, v introspection.Directive) graphql.Marshaler {
	return ec.___Directive(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective(ctx context.Context, sel ast.SelectionSet, v []introspection.Directive) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalN__DirectiveLocation2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalN__DirectiveLocation2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalN__DirectiveLocation2string(ctx context.Context, v interface{}) ([]string, error) {
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalN__DirectiveLocation2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalN__DirectiveLocation2string(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__DirectiveLocation2string(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue(ctx context.Context, sel ast.SelectionSet, v introspection.EnumValue) graphql.Marshaler {
	return ec.___EnumValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Field2githubcom99designsgqlgengraphqlintrospectionField(ctx context.Context, sel ast.SelectionSet, v introspection.Field) graphql.Marshaler {
	return ec.___Field(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx context.Context, sel ast.SelectionSet, v introspection.InputValue) graphql.Marshaler {
	return ec.___InputValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v introspection.Type) graphql.Marshaler {
	return ec.___Type(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec.___Type(ctx, sel, v)
}

func (ec *executionContext) unmarshalN__TypeKind2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalN__TypeKind2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalOBoolean2bool(ctx context.Context, v interface{}) (bool, error) {
	res, err := graphql.UnmarshalBoolean(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	res := graphql.MarshalBoolean(v)
	return res
}

func (ec *executionContext) unmarshalOBoolean2bool(ctx context.Context, v interface{}) (*bool, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalBoolean(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOBoolean2bool(ctx context.Context, sel ast.SelectionSet, v *bool) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalBoolean(*v)
	return res
}

func (ec *executionContext) unmarshalOCacheScope2backendgraphmodelCacheScope(ctx context.Context, v interface{}) (*model.CacheScope, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(model.CacheScope)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOCacheScope2backendgraphmodelCacheScope(ctx context.Context, sel ast.SelectionSet, v *model.CacheScope) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) marshalOConnectionDetails2backendgraphmodelConnectionDetails(ctx context.Context, sel ast.SelectionSet, v *model.ConnectionDetails) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ConnectionDetails(ctx, sel, v)
}

func (ec *executionContext) marshalOConnectionError2backendgraphmodelConnectionError(ctx context.Context, sel ast.SelectionSet, v *model.ConnectionError) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ConnectionError(ctx, sel, v)
}

func (ec *executionContext) unmarshalOConnectionStatus2backendgraphmodelConnectionStatus(ctx context.Context, v interface{}) (*model.ConnectionStatus, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(model.ConnectionStatus)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOConnectionStatus2backendgraphmodelConnectionStatus(ctx context.Context, sel ast.SelectionSet, v *model.ConnectionStatus) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) marshalOConnectionTestResult2backendgraphmodelConnectionTestResult(ctx context.Context, sel ast.SelectionSet, v *model.ConnectionTestResult) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ConnectionTestResult(ctx, sel, v)
}

func (ec *executionContext) unmarshalOCredentialErrorCode2backendgraphmodelCredentialErrorCode(ctx context.Context, v interface{}) (*model.CredentialErrorCode, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(model.CredentialErrorCode)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOCredentialErrorCode2backendgraphmodelCredentialErrorCode(ctx context.Context, sel ast.SelectionSet, v *model.CredentialErrorCode) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalODateTime2timeTime(ctx context.Context, v interface{}) (*time.Time, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalTime(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalODateTime2timeTime(ctx context.Context, sel ast.SelectionSet, v *time.Time) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalTime(*v)
	return res
}

func (ec *executionContext) unmarshalODisconnectReason2backendgraphmodelDisconnectReason(ctx context.Context, v interface{}) (*model.DisconnectReason, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(model.DisconnectReason)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalODisconnectReason2backendgraphmodelDisconnectReason(ctx context.Context, sel ast.SelectionSet, v *model.DisconnectReason) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalODuration2backendgraphmodelDuration(ctx context.Context, v interface{}) (*model.Duration, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(model.Duration)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalODuration2backendgraphmodelDuration(ctx context.Context, sel ast.SelectionSet, v *model.Duration) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOErrorCategory2backendgraphmodelErrorCategory(ctx context.Context, v interface{}) (*model.ErrorCategory, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(model.ErrorCategory)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOErrorCategory2backendgraphmodelErrorCategory(ctx context.Context, sel ast.SelectionSet, v *model.ErrorCategory) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) marshalOHealthCheckResult2backendgraphmodelHealthCheckResult(ctx context.Context, sel ast.SelectionSet, v *model.HealthCheckResult) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._HealthCheckResult(ctx, sel, v)
}

func (ec *executionContext) unmarshalOID2string(ctx context.Context, v interface{}) (*string, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalID(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOID2string(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalID(*v)
	return res
}

func (ec *executionContext) unmarshalOInt2int(ctx context.Context, v interface{}) (*int, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalInt(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOInt2int(ctx context.Context, sel ast.SelectionSet, v *int) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalInt(*v)
	return res
}

func (ec *executionContext) marshalOInterface2backendgraphmodelInterface(ctx context.Context, sel ast.SelectionSet, v *model.Interface) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Interface(ctx, sel, v)
}

func (ec *executionContext) unmarshalOInterfaceType2backendgraphmodelInterfaceType(ctx context.Context, v interface{}) (*model.InterfaceType, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(model.InterfaceType)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOInterfaceType2backendgraphmodelInterfaceType(ctx context.Context, sel ast.SelectionSet, v *model.InterfaceType) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOJSON2map(ctx context.Context, v interface{}) (map[string]interface{}, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalMap(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOJSON2map(ctx context.Context, sel ast.SelectionSet, v map[string]interface{}) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalMap(v)
	return res
}

func (ec *executionContext) unmarshalOMAC2backendgraphmodelMAC(ctx context.Context, v interface{}) (*model.MAC, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(model.MAC)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOMAC2backendgraphmodelMAC(ctx context.Context, sel ast.SelectionSet, v *model.MAC) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) marshalOMutationError2backendgraphmodelMutationError(ctx context.Context, sel ast.SelectionSet, v []*model.MutationError) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNMutationError2backendgraphmodelMutationError(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalONode2backendgraphmodelNode(ctx context.Context, sel ast.SelectionSet, v model.Node) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Node(ctx, sel, v)
}

func (ec *executionContext) unmarshalOPaginationInput2backendgraphmodelPaginationInput(ctx context.Context, v interface{}) (*model.PaginationInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputPaginationInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOProtocol2backendgraphmodelProtocol(ctx context.Context, v interface{}) (*model.Protocol, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(model.Protocol)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOProtocol2backendgraphmodelProtocol(ctx context.Context, sel ast.SelectionSet, v *model.Protocol) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOProtocolPreference2backendgraphmodelProtocolPreference(ctx context.Context, v interface{}) (*model.ProtocolPreference, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(model.ProtocolPreference)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOProtocolPreference2backendgraphmodelProtocolPreference(ctx context.Context, sel ast.SelectionSet, v *model.ProtocolPreference) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) marshalORouter2backendgraphmodelRouter(ctx context.Context, sel ast.SelectionSet, v *model.Router) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Router(ctx, sel, v)
}

func (ec *executionContext) marshalORouterCapabilities2backendgraphmodelRouterCapabilities(ctx context.Context, sel ast.SelectionSet, v *model.RouterCapabilities) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._RouterCapabilities(ctx, sel, v)
}

func (ec *executionContext) marshalORouterCredentials2backendgraphmodelRouterCredentials(ctx context.Context, sel ast.SelectionSet, v *model.RouterCredentials) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._RouterCredentials(ctx, sel, v)
}

func (ec *executionContext) marshalORouterOSInfo2backendgraphmodelRouterOSInfo(ctx context.Context, sel ast.SelectionSet, v *model.RouterOSInfo) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._RouterOSInfo(ctx, sel, v)
}

func (ec *executionContext) unmarshalORouterPlatform2backendgraphmodelRouterPlatform(ctx context.Context, v interface{}) (*model.RouterPlatform, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(model.RouterPlatform)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalORouterPlatform2backendgraphmodelRouterPlatform(ctx context.Context, sel ast.SelectionSet, v *model.RouterPlatform) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) marshalOScanTask2backendgraphmodelScanTask(ctx context.Context, sel ast.SelectionSet, v *model.ScanTask) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ScanTask(ctx, sel, v)
}

func (ec *executionContext) unmarshalOSize2backendgraphmodelSize(ctx context.Context, v interface{}) (*model.Size, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(model.Size)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOSize2backendgraphmodelSize(ctx context.Context, sel ast.SelectionSet, v *model.Size) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOString2string(ctx context.Context, v interface{}) ([]string, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNString2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOString2string(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNString2string(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOString2string(ctx context.Context, v interface{}) (*string, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalString(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOString2string(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalString(*v)
	return res
}

func (ec *executionContext) marshalOTLSStatus2backendgraphmodelTLSStatus(ctx context.Context, sel ast.SelectionSet, v *model.TLSStatus) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._TLSStatus(ctx, sel, v)
}

func (ec *executionContext) marshalOUpgradeRecommendation2backendgraphmodelUpgradeRecommendation(ctx context.Context, sel ast.SelectionSet, v *model.UpgradeRecommendation) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._UpgradeRecommendation(ctx, sel, v)
}

func (ec *executionContext) marshalOUser2backendgraphmodelUser(ctx context.Context, sel ast.SelectionSet, v *model.User) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._User(ctx, sel, v)
}

func (ec *executionContext) unmarshalOValidateFormat2backendgraphmodelValidateFormat(ctx context.Context, v interface{}) (*model.ValidateFormat, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(model.ValidateFormat)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOValidateFormat2backendgraphmodelValidateFormat(ctx context.Context, sel ast.SelectionSet, v *model.ValidateFormat) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) marshalOValidationError2backendgraphmodelValidationError(ctx context.Context, sel ast.SelectionSet, v []*model.ValidationError) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNValidationError2backendgraphmodelValidationError(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue(ctx context.Context, sel ast.SelectionSet, v []introspection.EnumValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Field2githubcom99designsgqlgengraphqlintrospectionField(ctx context.Context, sel ast.SelectionSet, v []introspection.Field) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Field2githubcom99designsgqlgengraphqlintrospectionField(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Schema2githubcom99designsgqlgengraphqlintrospectionSchema(ctx context.Context, sel ast.SelectionSet, v *introspection.Schema) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.___Schema(ctx, sel, v)
}

func (ec *executionContext) marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.___Type(ctx, sel, v)
}

// endregion ***************************** type.gotpl *****************************
