// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package graph

import (
	"backend/graph/model"
	"bytes"
	"context"
	"errors"
	"fmt"
	"io"
	"strconv"
	"sync"
	"sync/atomic"
	"time"

	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"
	gqlparser "github.com/vektah/gqlparser/v2"
	"github.com/vektah/gqlparser/v2/ast"
)

// region    ************************** generated!.gotpl **************************

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		schema:     cfg.Schema,
		resolvers:  cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
	}
}

type Config struct {
	Schema     *ast.Schema
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
	Mutation() MutationResolver
	Query() QueryResolver
	Subscription() SubscriptionResolver
}

type DirectiveRoot struct {
	Auth       func(ctx context.Context, obj interface{}, next graphql.Resolver, requires *string) (res interface{}, err error)
	Capability func(ctx context.Context, obj interface{}, next graphql.Resolver, requires []string) (res interface{}, err error)
	Sensitive  func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error)
	Validate   func(ctx context.Context, obj interface{}, next graphql.Resolver, min *int, max *int, minLength *int, maxLength *int, pattern *string, format *model.ValidateFormat) (res interface{}, err error)
}

type ComplexityRoot struct {
	AddChangeSetItemPayload struct {
		ChangeSet func(childComplexity int) int
		Errors    func(childComplexity int) int
		ItemID    func(childComplexity int) int
	}

	AddRouterPayload struct {
		ConnectionResult func(childComplexity int) int
		Errors           func(childComplexity int) int
		Router           func(childComplexity int) int
		ValidationErrors func(childComplexity int) int
	}

	AffectedResource struct {
		ID     func(childComplexity int) int
		Impact func(childComplexity int) int
		Name   func(childComplexity int) int
		Type   func(childComplexity int) int
	}

	Alert struct {
		AcknowledgedAt func(childComplexity int) int
		AcknowledgedBy func(childComplexity int) int
		Data           func(childComplexity int) int
		DeliveryStatus func(childComplexity int) int
		DeviceID       func(childComplexity int) int
		EventType      func(childComplexity int) int
		ID             func(childComplexity int) int
		Message        func(childComplexity int) int
		Rule           func(childComplexity int) int
		Severity       func(childComplexity int) int
		Title          func(childComplexity int) int
		TriggeredAt    func(childComplexity int) int
		UpdatedAt      func(childComplexity int) int
	}

	AlertCondition struct {
		Field    func(childComplexity int) int
		Operator func(childComplexity int) int
		Value    func(childComplexity int) int
	}

	AlertConnection struct {
		Edges      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	AlertEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	AlertEvent struct {
		Action func(childComplexity int) int
		Alert  func(childComplexity int) int
	}

	AlertPayload struct {
		Alert  func(childComplexity int) int
		Errors func(childComplexity int) int
	}

	AlertRule struct {
		Alerts      func(childComplexity int, acknowledged *bool, limit *int) int
		Channels    func(childComplexity int) int
		Conditions  func(childComplexity int) int
		CreatedAt   func(childComplexity int) int
		Description func(childComplexity int) int
		DeviceID    func(childComplexity int) int
		Enabled     func(childComplexity int) int
		EventType   func(childComplexity int) int
		ID          func(childComplexity int) int
		Name        func(childComplexity int) int
		QuietHours  func(childComplexity int) int
		Severity    func(childComplexity int) int
		Throttle    func(childComplexity int) int
		UpdatedAt   func(childComplexity int) int
	}

	AlertRulePayload struct {
		AlertRule func(childComplexity int) int
		Errors    func(childComplexity int) int
	}

	ApplyChangeSetPayload struct {
		ChangeSetID func(childComplexity int) int
		Errors      func(childComplexity int) int
		Status      func(childComplexity int) int
	}

	ApplyFixPayload struct {
		Errors  func(childComplexity int) int
		Message func(childComplexity int) int
		Status  func(childComplexity int) int
		Success func(childComplexity int) int
	}

	ApplyResourcePayload struct {
		Errors      func(childComplexity int) int
		OperationID func(childComplexity int) int
		Resource    func(childComplexity int) int
	}

	ArchiveResourcePayload struct {
		Errors  func(childComplexity int) int
		Success func(childComplexity int) int
	}

	AuthPayload struct {
		ExpiresAt func(childComplexity int) int
		Token     func(childComplexity int) int
		User      func(childComplexity int) int
	}

	AuthStatus struct {
		Error     func(childComplexity int) int
		ErrorCode func(childComplexity int) int
		Success   func(childComplexity int) int
		Tested    func(childComplexity int) int
	}

	BandwidthDataPoint struct {
		BytesIn       func(childComplexity int) int
		BytesOut      func(childComplexity int) int
		PeriodSeconds func(childComplexity int) int
		Timestamp     func(childComplexity int) int
	}

	BatchInterfacePayload struct {
		Errors    func(childComplexity int) int
		Failed    func(childComplexity int) int
		Succeeded func(childComplexity int) int
	}

	Bridge struct {
		Comment              func(childComplexity int) int
		DependentDhcpServers func(childComplexity int) int
		DependentRoutes      func(childComplexity int) int
		Disabled             func(childComplexity int) int
		ID                   func(childComplexity int) int
		IPAddresses          func(childComplexity int) int
		MacAddress           func(childComplexity int) int
		Mtu                  func(childComplexity int) int
		Name                 func(childComplexity int) int
		Ports                func(childComplexity int) int
		Priority             func(childComplexity int) int
		Protocol             func(childComplexity int) int
		Pvid                 func(childComplexity int) int
		Running              func(childComplexity int) int
		StpStatus            func(childComplexity int) int
		VlanFiltering        func(childComplexity int) int
		Vlans                func(childComplexity int) int
	}

	BridgeMutationResult struct {
		Bridge        func(childComplexity int) int
		Errors        func(childComplexity int) int
		OperationID   func(childComplexity int) int
		PreviousState func(childComplexity int) int
		Success       func(childComplexity int) int
	}

	BridgePort struct {
		Bridge           func(childComplexity int) int
		Edge             func(childComplexity int) int
		FrameTypes       func(childComplexity int) int
		ID               func(childComplexity int) int
		IngressFiltering func(childComplexity int) int
		Interface        func(childComplexity int) int
		PathCost         func(childComplexity int) int
		Pvid             func(childComplexity int) int
		Role             func(childComplexity int) int
		State            func(childComplexity int) int
		TaggedVlans      func(childComplexity int) int
		UntaggedVlans    func(childComplexity int) int
	}

	BridgePortMutationResult struct {
		Errors        func(childComplexity int) int
		OperationID   func(childComplexity int) int
		Port          func(childComplexity int) int
		PreviousState func(childComplexity int) int
		Success       func(childComplexity int) int
	}

	BridgePortVlanConfig struct {
		FrameTypes    func(childComplexity int) int
		Mode          func(childComplexity int) int
		PortID        func(childComplexity int) int
		Pvid          func(childComplexity int) int
		TaggedVlans   func(childComplexity int) int
		UntaggedVlans func(childComplexity int) int
	}

	BridgeResource struct {
		Category      func(childComplexity int) int
		Configuration func(childComplexity int) int
		Deployment    func(childComplexity int) int
		ID            func(childComplexity int) int
		Metadata      func(childComplexity int) int
		Name          func(childComplexity int) int
		Platform      func(childComplexity int) int
		Ports         func(childComplexity int) int
		ProtocolMode  func(childComplexity int) int
		Relationships func(childComplexity int) int
		Runtime       func(childComplexity int) int
		ScopedID      func(childComplexity int) int
		Telemetry     func(childComplexity int) int
		Type          func(childComplexity int) int
		Validation    func(childComplexity int) int
	}

	BridgeStpStatus struct {
		LastTopologyChange  func(childComplexity int) int
		RootBridge          func(childComplexity int) int
		RootBridgeID        func(childComplexity int) int
		RootPathCost        func(childComplexity int) int
		RootPort            func(childComplexity int) int
		TopologyChangeCount func(childComplexity int) int
	}

	BridgeVlan struct {
		Bridge        func(childComplexity int) int
		TaggedPorts   func(childComplexity int) int
		UUID          func(childComplexity int) int
		UntaggedPorts func(childComplexity int) int
		VlanID        func(childComplexity int) int
	}

	BridgeVlanMutationResult struct {
		Errors  func(childComplexity int) int
		Success func(childComplexity int) int
		Vlan    func(childComplexity int) int
	}

	BulkAlertPayload struct {
		AcknowledgedCount func(childComplexity int) int
		Errors            func(childComplexity int) int
	}

	CPUMetrics struct {
		Cores     func(childComplexity int) int
		Frequency func(childComplexity int) int
		PerCore   func(childComplexity int) int
		Usage     func(childComplexity int) int
	}

	CancelChangeSetPayload struct {
		ChangeSet func(childComplexity int) int
		Errors    func(childComplexity int) int
		Success   func(childComplexity int) int
	}

	CancelScanPayload struct {
		Errors func(childComplexity int) int
		Task   func(childComplexity int) int
	}

	CapabilityEntry struct {
		Capability  func(childComplexity int) int
		Description func(childComplexity int) int
		Guidance    func(childComplexity int) int
		Level       func(childComplexity int) int
	}

	ChangeLogEntry struct {
		ChangeType    func(childComplexity int) int
		ChangedFields func(childComplexity int) int
		Summary       func(childComplexity int) int
		Timestamp     func(childComplexity int) int
		User          func(childComplexity int) int
	}

	ChangeSet struct {
		ApplyStartedAt func(childComplexity int) int
		CompletedAt    func(childComplexity int) int
		CreatedAt      func(childComplexity int) int
		CreatedBy      func(childComplexity int) int
		Description    func(childComplexity int) int
		Error          func(childComplexity int) int
		ID             func(childComplexity int) int
		Items          func(childComplexity int) int
		Name           func(childComplexity int) int
		RollbackPlan   func(childComplexity int) int
		RouterID       func(childComplexity int) int
		Source         func(childComplexity int) int
		Status         func(childComplexity int) int
		Validation     func(childComplexity int) int
		Version        func(childComplexity int) int
	}

	ChangeSetConflict struct {
		Description           func(childComplexity int) int
		IsExternalConflict    func(childComplexity int) int
		ItemID1               func(childComplexity int) int
		ItemID2OrResourceUUID func(childComplexity int) int
		Resolution            func(childComplexity int) int
	}

	ChangeSetError struct {
		Code                       func(childComplexity int) int
		FailedItemID               func(childComplexity int) int
		FailedRollbackItemIds      func(childComplexity int) int
		Message                    func(childComplexity int) int
		PartiallyAppliedItemIds    func(childComplexity int) int
		RequiresManualIntervention func(childComplexity int) int
	}

	ChangeSetItem struct {
		ApplyCompletedAt func(childComplexity int) int
		ApplyOrder       func(childComplexity int) int
		ApplyStartedAt   func(childComplexity int) int
		Configuration    func(childComplexity int) int
		Dependencies     func(childComplexity int) int
		Description      func(childComplexity int) int
		Error            func(childComplexity int) int
		ID               func(childComplexity int) int
		Name             func(childComplexity int) int
		Operation        func(childComplexity int) int
		PreviousState    func(childComplexity int) int
		ResourceCategory func(childComplexity int) int
		ResourceType     func(childComplexity int) int
		ResourceUUID     func(childComplexity int) int
		Status           func(childComplexity int) int
	}

	ChangeSetProgressEvent struct {
		AppliedCount         func(childComplexity int) int
		ChangeSetID          func(childComplexity int) int
		CurrentItem          func(childComplexity int) int
		Error                func(childComplexity int) int
		EstimatedRemainingMs func(childComplexity int) int
		ProgressPercent      func(childComplexity int) int
		Status               func(childComplexity int) int
		Timestamp            func(childComplexity int) int
		TotalCount           func(childComplexity int) int
	}

	ChangeSetStatusEvent struct {
		ChangeSetID    func(childComplexity int) int
		Error          func(childComplexity int) int
		NewStatus      func(childComplexity int) int
		PreviousStatus func(childComplexity int) int
		Timestamp      func(childComplexity int) int
	}

	ChangeSetSummary struct {
		CreatedAt       func(childComplexity int) int
		HasErrors       func(childComplexity int) int
		HasWarnings     func(childComplexity int) int
		ID              func(childComplexity int) int
		Name            func(childComplexity int) int
		OperationCounts func(childComplexity int) int
		Status          func(childComplexity int) int
		TotalItems      func(childComplexity int) int
	}

	ChangeSetValidationError struct {
		Code     func(childComplexity int) int
		Field    func(childComplexity int) int
		ItemID   func(childComplexity int) int
		Message  func(childComplexity int) int
		Severity func(childComplexity int) int
	}

	ChangeSetValidationResult struct {
		CanApply             func(childComplexity int) int
		CircularDependencies func(childComplexity int) int
		Conflicts            func(childComplexity int) int
		Errors               func(childComplexity int) int
		MissingDependencies  func(childComplexity int) int
		Warnings             func(childComplexity int) int
	}

	CircuitBreakerEvent struct {
		ConsecutiveFailures func(childComplexity int) int
		NewState            func(childComplexity int) int
		PreviousState       func(childComplexity int) int
		RouterID            func(childComplexity int) int
		Timestamp           func(childComplexity int) int
	}

	CircuitBreakerStatus struct {
		CooldownRemainingSeconds func(childComplexity int) int
		FailureCount             func(childComplexity int) int
		FailureThreshold         func(childComplexity int) int
		LastFailureAt            func(childComplexity int) int
		LastSuccessAt            func(childComplexity int) int
		RouterID                 func(childComplexity int) int
		State                    func(childComplexity int) int
	}

	CompositeResource struct {
		Children      func(childComplexity int) int
		Relationships func(childComplexity int) int
		Root          func(childComplexity int) int
	}

	ConfigPreview struct {
		AffectedResources func(childComplexity int) int
		Commands          func(childComplexity int) int
		Warnings          func(childComplexity int) int
	}

	ConfigProgress struct {
		CurrentStep func(childComplexity int) int
		Message     func(childComplexity int) int
		OperationID func(childComplexity int) int
		Percentage  func(childComplexity int) int
		Status      func(childComplexity int) int
		Timestamp   func(childComplexity int) int
		TotalSteps  func(childComplexity int) int
	}

	ConnectRouterPayload struct {
		Errors func(childComplexity int) int
		Router func(childComplexity int) int
	}

	ConnectionAttempt struct {
		EndedAt       func(childComplexity int) int
		ErrorCategory func(childComplexity int) int
		ErrorCode     func(childComplexity int) int
		ErrorMessage  func(childComplexity int) int
		Protocol      func(childComplexity int) int
		StartedAt     func(childComplexity int) int
		Success       func(childComplexity int) int
	}

	ConnectionDetails struct {
		CircuitBreakerState   func(childComplexity int) int
		ConnectedAt           func(childComplexity int) int
		DisconnectReason      func(childComplexity int) int
		DisconnectedAt        func(childComplexity int) int
		HealthChecksFailed    func(childComplexity int) int
		HealthChecksPassed    func(childComplexity int) int
		IsLegacyProtocol      func(childComplexity int) int
		LastError             func(childComplexity int) int
		LastErrorTime         func(childComplexity int) int
		LastHealthCheck       func(childComplexity int) int
		NextReconnectAt       func(childComplexity int) int
		PreferredProtocol     func(childComplexity int) int
		Protocol              func(childComplexity int) int
		ReconnectAttempts     func(childComplexity int) int
		SecurityWarning       func(childComplexity int) int
		State                 func(childComplexity int) int
		UpgradeRecommendation func(childComplexity int) int
		Uptime                func(childComplexity int) int
		Version               func(childComplexity int) int
	}

	ConnectionError struct {
		Code            func(childComplexity int) int
		Message         func(childComplexity int) int
		Protocol        func(childComplexity int) int
		Retryable       func(childComplexity int) int
		SuggestedAction func(childComplexity int) int
		TimeoutMs       func(childComplexity int) int
	}

	ConnectionStats struct {
		Connected        func(childComplexity int) int
		Connecting       func(childComplexity int) int
		Disconnected     func(childComplexity int) int
		Error            func(childComplexity int) int
		Reconnecting     func(childComplexity int) int
		TotalConnections func(childComplexity int) int
	}

	ConnectionTestResult struct {
		Architecture       func(childComplexity int) int
		BoardName          func(childComplexity int) int
		Error              func(childComplexity int) int
		ProtocolUsed       func(childComplexity int) int
		ProtocolsAttempted func(childComplexity int) int
		ResponseTimeMs     func(childComplexity int) int
		RouterModel        func(childComplexity int) int
		RouterVersion      func(childComplexity int) int
		Success            func(childComplexity int) int
		SupportsContainers func(childComplexity int) int
		Uptime             func(childComplexity int) int
	}

	ContainerInfo struct {
		Enabled                  func(childComplexity int) int
		MaxContainers            func(childComplexity int) int
		PackageInstalled         func(childComplexity int) int
		RegistryConfigured       func(childComplexity int) int
		StorageAvailable         func(childComplexity int) int
		SupportsNetworkNamespace func(childComplexity int) int
	}

	CreateChangeSetPayload struct {
		ChangeSet func(childComplexity int) int
		Errors    func(childComplexity int) int
	}

	CreateResourcePayload struct {
		Errors   func(childComplexity int) int
		Resource func(childComplexity int) int
	}

	CreateRouterPayload struct {
		Errors func(childComplexity int) int
		Router func(childComplexity int) int
	}

	CredentialTestResult struct {
		Error          func(childComplexity int) int
		ResponseTimeMs func(childComplexity int) int
		RouterID       func(childComplexity int) int
		RouterName     func(childComplexity int) int
		Status         func(childComplexity int) int
		Success        func(childComplexity int) int
	}

	CredentialUpdatePayload struct {
		Credentials func(childComplexity int) int
		ErrorCode   func(childComplexity int) int
		Errors      func(childComplexity int) int
		Message     func(childComplexity int) int
		Success     func(childComplexity int) int
	}

	CurrentItemInfo struct {
		ID        func(childComplexity int) int
		Name      func(childComplexity int) int
		Operation func(childComplexity int) int
		Status    func(childComplexity int) int
	}

	DHCPServerResource struct {
		ActiveLeases  func(childComplexity int) int
		AddressPool   func(childComplexity int) int
		Category      func(childComplexity int) int
		Configuration func(childComplexity int) int
		Deployment    func(childComplexity int) int
		ID            func(childComplexity int) int
		Interface     func(childComplexity int) int
		LeaseTime     func(childComplexity int) int
		Metadata      func(childComplexity int) int
		Name          func(childComplexity int) int
		Platform      func(childComplexity int) int
		Relationships func(childComplexity int) int
		Runtime       func(childComplexity int) int
		ScopedID      func(childComplexity int) int
		Telemetry     func(childComplexity int) int
		Type          func(childComplexity int) int
		Validation    func(childComplexity int) int
	}

	DailyStats struct {
		Date              func(childComplexity int) int
		ErrorCount        func(childComplexity int) int
		PeakThroughputIn  func(childComplexity int) int
		PeakThroughputOut func(childComplexity int) int
		TotalBytesIn      func(childComplexity int) int
		TotalBytesOut     func(childComplexity int) int
		UptimePercent     func(childComplexity int) int
	}

	DeleteChangeSetPayload struct {
		Errors  func(childComplexity int) int
		Success func(childComplexity int) int
	}

	DeletePayload struct {
		DeletedID func(childComplexity int) int
		Errors    func(childComplexity int) int
		Success   func(childComplexity int) int
	}

	DeleteResourcePayload struct {
		DeletedID func(childComplexity int) int
		Errors    func(childComplexity int) int
		Success   func(childComplexity int) int
	}

	DeleteResult struct {
		Errors  func(childComplexity int) int
		Message func(childComplexity int) int
		Success func(childComplexity int) int
	}

	DeleteRouterPayload struct {
		DeletedRouterID func(childComplexity int) int
		Errors          func(childComplexity int) int
		Success         func(childComplexity int) int
	}

	DependencyStatus struct {
		IsActive     func(childComplexity int) int
		Reason       func(childComplexity int) int
		ResourceType func(childComplexity int) int
		ResourceUUID func(childComplexity int) int
		State        func(childComplexity int) int
	}

	DeploymentState struct {
		AppliedAt        func(childComplexity int) int
		AppliedBy        func(childComplexity int) int
		ApplyOperationID func(childComplexity int) int
		Drift            func(childComplexity int) int
		GeneratedFields  func(childComplexity int) int
		IsInSync         func(childComplexity int) int
		RouterResourceID func(childComplexity int) int
		RouterVersion    func(childComplexity int) int
	}

	DeprecateResourcePayload struct {
		Errors   func(childComplexity int) int
		Resource func(childComplexity int) int
	}

	Device struct {
		ID              func(childComplexity int) int
		ResourceMetrics func(childComplexity int) int
	}

	DhcpClient struct {
		AddDefaultRoute func(childComplexity int) int
		Address         func(childComplexity int) int
		Comment         func(childComplexity int) int
		DhcpServer      func(childComplexity int) int
		Disabled        func(childComplexity int) int
		ExpiresAfter    func(childComplexity int) int
		Gateway         func(childComplexity int) int
		ID              func(childComplexity int) int
		Interface       func(childComplexity int) int
		Status          func(childComplexity int) int
		UsePeerDNS      func(childComplexity int) int
		UsePeerNtp      func(childComplexity int) int
	}

	DhcpServer struct {
		Disabled  func(childComplexity int) int
		ID        func(childComplexity int) int
		Interface func(childComplexity int) int
		Name      func(childComplexity int) int
	}

	DiagnosticReport struct {
		AuthStatus       func(childComplexity int) int
		NetworkReachable func(childComplexity int) int
		PortStatus       func(childComplexity int) int
		RawReport        func(childComplexity int) int
		RouterID         func(childComplexity int) int
		Suggestions      func(childComplexity int) int
		TLSStatus        func(childComplexity int) int
		Timestamp        func(childComplexity int) int
	}

	DiagnosticSuggestion struct {
		Action      func(childComplexity int) int
		Description func(childComplexity int) int
		DocsURL     func(childComplexity int) int
		Severity    func(childComplexity int) int
		Title       func(childComplexity int) int
	}

	DisconnectRouterPayload struct {
		Errors func(childComplexity int) int
		Router func(childComplexity int) int
	}

	DiscoveredDevice struct {
		Confidence   func(childComplexity int) int
		DeviceType   func(childComplexity int) int
		Hostname     func(childComplexity int) int
		IP           func(childComplexity int) int
		Ports        func(childComplexity int) int
		RouterOSInfo func(childComplexity int) int
		Services     func(childComplexity int) int
		Vendor       func(childComplexity int) int
	}

	DnsLookupResult struct {
		Authoritative func(childComplexity int) int
		Error         func(childComplexity int) int
		Hostname      func(childComplexity int) int
		QueryTime     func(childComplexity int) int
		RecordType    func(childComplexity int) int
		Records       func(childComplexity int) int
		Server        func(childComplexity int) int
		Status        func(childComplexity int) int
		Timestamp     func(childComplexity int) int
	}

	DnsRecord struct {
		Data     func(childComplexity int) int
		Name     func(childComplexity int) int
		Port     func(childComplexity int) int
		Priority func(childComplexity int) int
		TTL      func(childComplexity int) int
		Type     func(childComplexity int) int
		Weight   func(childComplexity int) int
	}

	DnsServer struct {
		Address     func(childComplexity int) int
		IsPrimary   func(childComplexity int) int
		IsSecondary func(childComplexity int) int
	}

	DnsServers struct {
		Primary   func(childComplexity int) int
		Secondary func(childComplexity int) int
		Servers   func(childComplexity int) int
	}

	DriftField struct {
		Actual   func(childComplexity int) int
		Expected func(childComplexity int) int
		Path     func(childComplexity int) int
	}

	DriftInfo struct {
		DetectedAt      func(childComplexity int) int
		DriftedFields   func(childComplexity int) int
		SuggestedAction func(childComplexity int) int
	}

	ErrorExtensions struct {
		Category             func(childComplexity int) int
		Code                 func(childComplexity int) int
		DocsURL              func(childComplexity int) int
		Field                func(childComplexity int) int
		Recoverable          func(childComplexity int) int
		RequestID            func(childComplexity int) int
		SuggestedFix         func(childComplexity int) int
		TroubleshootingSteps func(childComplexity int) int
		Value                func(childComplexity int) int
	}

	ExportConfigPayload struct {
		Config          func(childComplexity int) int
		Errors          func(childComplexity int) int
		SecurityWarning func(childComplexity int) int
		Success         func(childComplexity int) int
	}

	FeatureCompatibilityInfo struct {
		DependsOn        func(childComplexity int) int
		FeatureID        func(childComplexity int) int
		MaxVersion       func(childComplexity int) int
		MinVersion       func(childComplexity int) int
		MinVersionChr    func(childComplexity int) int
		Name             func(childComplexity int) int
		RequiredPackages func(childComplexity int) int
		UpgradeURL       func(childComplexity int) int
	}

	FeatureDeployment struct {
		AppliedAt        func(childComplexity int) int
		AppliedBy        func(childComplexity int) int
		AssignedIP       func(childComplexity int) int
		AssignedPorts    func(childComplexity int) int
		ContainerID      func(childComplexity int) int
		ContainerImage   func(childComplexity int) int
		Drift            func(childComplexity int) int
		IsInSync         func(childComplexity int) int
		RouterResourceID func(childComplexity int) int
		RouterVersion    func(childComplexity int) int
	}

	FeatureResource struct {
		Category          func(childComplexity int) int
		Configuration     func(childComplexity int) int
		Deployment        func(childComplexity int) int
		FeatureDeployment func(childComplexity int) int
		FeatureID         func(childComplexity int) int
		FeatureRuntime    func(childComplexity int) int
		ID                func(childComplexity int) int
		Metadata          func(childComplexity int) int
		Name              func(childComplexity int) int
		Platform          func(childComplexity int) int
		Relationships     func(childComplexity int) int
		Runtime           func(childComplexity int) int
		ScopedID          func(childComplexity int) int
		Telemetry         func(childComplexity int) int
		Type              func(childComplexity int) int
		Validation        func(childComplexity int) int
		Version           func(childComplexity int) int
		VirtualInterface  func(childComplexity int) int
	}

	FeatureRuntime struct {
		CPUUsagePercent func(childComplexity int) int
		ContainerStatus func(childComplexity int) int
		ErrorMessage    func(childComplexity int) int
		Health          func(childComplexity int) int
		IsRunning       func(childComplexity int) int
		LastUpdated     func(childComplexity int) int
		MemoryUsage     func(childComplexity int) int
		RoutedDevices   func(childComplexity int) int
	}

	FeatureSupport struct {
		FeatureID        func(childComplexity int) int
		Level            func(childComplexity int) int
		MissingPackages  func(childComplexity int) int
		Name             func(childComplexity int) int
		Reason           func(childComplexity int) int
		RequiredPackages func(childComplexity int) int
		RequiredVersion  func(childComplexity int) int
		Supported        func(childComplexity int) int
		UpgradeURL       func(childComplexity int) int
	}

	FirewallRule struct {
		Action       func(childComplexity int) int
		Chain        func(childComplexity int) int
		Disabled     func(childComplexity int) int
		ID           func(childComplexity int) int
		InInterface  func(childComplexity int) int
		OutInterface func(childComplexity int) int
	}

	FirewallRuleResource struct {
		Action        func(childComplexity int) int
		Category      func(childComplexity int) int
		Chain         func(childComplexity int) int
		Comment       func(childComplexity int) int
		Configuration func(childComplexity int) int
		Deployment    func(childComplexity int) int
		DstAddress    func(childComplexity int) int
		DstPort       func(childComplexity int) int
		Enabled       func(childComplexity int) int
		HitCount      func(childComplexity int) int
		ID            func(childComplexity int) int
		Metadata      func(childComplexity int) int
		Platform      func(childComplexity int) int
		Protocol      func(childComplexity int) int
		Relationships func(childComplexity int) int
		Runtime       func(childComplexity int) int
		ScopedID      func(childComplexity int) int
		SrcAddress    func(childComplexity int) int
		SrcPort       func(childComplexity int) int
		Telemetry     func(childComplexity int) int
		Type          func(childComplexity int) int
		Validation    func(childComplexity int) int
	}

	GatewayReachabilityResult struct {
		Interface func(childComplexity int) int
		Latency   func(childComplexity int) int
		Message   func(childComplexity int) int
		Reachable func(childComplexity int) int
	}

	HardwareInfo struct {
		Architecture     func(childComplexity int) int
		AvailableStorage func(childComplexity int) int
		BoardName        func(childComplexity int) int
		CPUCount         func(childComplexity int) int
		HasLTEModule     func(childComplexity int) int
		HasWirelessChip  func(childComplexity int) int
		Model            func(childComplexity int) int
		TotalMemory      func(childComplexity int) int
	}

	HealthCheckResult struct {
		CheckedAt      func(childComplexity int) int
		Error          func(childComplexity int) int
		Healthy        func(childComplexity int) int
		ResponseTimeMs func(childComplexity int) int
		RouterID       func(childComplexity int) int
	}

	HealthStatus struct {
		CheckedAt        func(childComplexity int) int
		ConnectedRouters func(childComplexity int) int
		Status           func(childComplexity int) int
		Uptime           func(childComplexity int) int
		Version          func(childComplexity int) int
	}

	HopProbe struct {
		ICMPCode    func(childComplexity int) int
		LatencyMs   func(childComplexity int) int
		ProbeNumber func(childComplexity int) int
		Success     func(childComplexity int) int
	}

	HourlyStats struct {
		ErrorCount    func(childComplexity int) int
		Hour          func(childComplexity int) int
		TotalBytesIn  func(childComplexity int) int
		TotalBytesOut func(childComplexity int) int
		UptimePercent func(childComplexity int) int
	}

	ISPInfo struct {
		Name  func(childComplexity int) int
		Phone func(childComplexity int) int
		URL   func(childComplexity int) int
	}

	Interface struct {
		Comment     func(childComplexity int) int
		Enabled     func(childComplexity int) int
		ID          func(childComplexity int) int
		IP          func(childComplexity int) int
		LastSeen    func(childComplexity int) int
		LinkPartner func(childComplexity int) int
		LinkSpeed   func(childComplexity int) int
		MacAddress  func(childComplexity int) int
		Mtu         func(childComplexity int) int
		Name        func(childComplexity int) int
		Running     func(childComplexity int) int
		RxBytes     func(childComplexity int) int
		RxRate      func(childComplexity int) int
		Status      func(childComplexity int) int
		TxBytes     func(childComplexity int) int
		TxRate      func(childComplexity int) int
		Type        func(childComplexity int) int
		UsedBy      func(childComplexity int) int
	}

	InterfaceConnection struct {
		Edges      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	InterfaceEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	InterfaceOperationError struct {
		Error         func(childComplexity int) int
		InterfaceID   func(childComplexity int) int
		InterfaceName func(childComplexity int) int
	}

	InterfaceStats struct {
		RxBytes   func(childComplexity int) int
		RxDrops   func(childComplexity int) int
		RxErrors  func(childComplexity int) int
		RxPackets func(childComplexity int) int
		TxBytes   func(childComplexity int) int
		TxDrops   func(childComplexity int) int
		TxErrors  func(childComplexity int) int
		TxPackets func(childComplexity int) int
	}

	InterfaceStatsHistory struct {
		DataPoints  func(childComplexity int) int
		EndTime     func(childComplexity int) int
		InterfaceID func(childComplexity int) int
		Interval    func(childComplexity int) int
		StartTime   func(childComplexity int) int
	}

	InterfaceStatusEvent struct {
		InterfaceID    func(childComplexity int) int
		InterfaceName  func(childComplexity int) int
		PreviousStatus func(childComplexity int) int
		Status         func(childComplexity int) int
		Timestamp      func(childComplexity int) int
	}

	InterfaceTrafficEvent struct {
		InterfaceID   func(childComplexity int) int
		InterfaceName func(childComplexity int) int
		RxRate        func(childComplexity int) int
		RxTotal       func(childComplexity int) int
		Timestamp     func(childComplexity int) int
		TxRate        func(childComplexity int) int
		TxTotal       func(childComplexity int) int
	}

	IpAddress struct {
		Address   func(childComplexity int) int
		Broadcast func(childComplexity int) int
		Comment   func(childComplexity int) int
		Disabled  func(childComplexity int) int
		Dynamic   func(childComplexity int) int
		ID        func(childComplexity int) int
		Interface func(childComplexity int) int
		Invalid   func(childComplexity int) int
		Network   func(childComplexity int) int
	}

	IpAddressChangeEvent struct {
		ChangeType  func(childComplexity int) int
		IPAddress   func(childComplexity int) int
		IPAddressID func(childComplexity int) int
		Timestamp   func(childComplexity int) int
	}

	IpAddressDeleteResult struct {
		Errors         func(childComplexity int) int
		ImpactAnalysis func(childComplexity int) int
		Message        func(childComplexity int) int
		Success        func(childComplexity int) int
	}

	IpAddressDependencies struct {
		DhcpServers     func(childComplexity int) int
		FirewallRules   func(childComplexity int) int
		HasDependencies func(childComplexity int) int
		IPAddressID     func(childComplexity int) int
		NatRules        func(childComplexity int) int
		Routes          func(childComplexity int) int
	}

	IpAddressImpactAnalysis struct {
		ActiveConnections   func(childComplexity int) int
		CanDelete           func(childComplexity int) int
		Consequences        func(childComplexity int) int
		Message             func(childComplexity int) int
		Severity            func(childComplexity int) int
		UsedByDhcpServers   func(childComplexity int) int
		UsedInFirewallRules func(childComplexity int) int
		UsedInNatRules      func(childComplexity int) int
	}

	IpAddressMutationResult struct {
		Errors    func(childComplexity int) int
		IPAddress func(childComplexity int) int
		Preview   func(childComplexity int) int
		Success   func(childComplexity int) int
	}

	IpConflict struct {
		Address      func(childComplexity int) int
		ConflictType func(childComplexity int) int
		Explanation  func(childComplexity int) int
		ID           func(childComplexity int) int
		Interface    func(childComplexity int) int
	}

	IpConflictResult struct {
		Conflicts   func(childComplexity int) int
		HasConflict func(childComplexity int) int
		Message     func(childComplexity int) int
	}

	LANNetwork struct {
		Bridge        func(childComplexity int) int
		Category      func(childComplexity int) int
		Config        func(childComplexity int) int
		Configuration func(childComplexity int) int
		Deployment    func(childComplexity int) int
		DhcpServer    func(childComplexity int) int
		FirewallRules func(childComplexity int) int
		ID            func(childComplexity int) int
		LanDeployment func(childComplexity int) int
		LanRuntime    func(childComplexity int) int
		Metadata      func(childComplexity int) int
		Platform      func(childComplexity int) int
		Relationships func(childComplexity int) int
		Routes        func(childComplexity int) int
		Runtime       func(childComplexity int) int
		ScopedID      func(childComplexity int) int
		Telemetry     func(childComplexity int) int
		Type          func(childComplexity int) int
		Validation    func(childComplexity int) int
	}

	LANNetworkConfig struct {
		DNSServers    func(childComplexity int) int
		DhcpEnabled   func(childComplexity int) int
		DhcpLeaseTime func(childComplexity int) int
		DhcpPoolEnd   func(childComplexity int) int
		DhcpPoolStart func(childComplexity int) int
		EnableNat     func(childComplexity int) int
		IPAddress     func(childComplexity int) int
		Interfaces    func(childComplexity int) int
		Name          func(childComplexity int) int
		SubnetMask    func(childComplexity int) int
		VlanID        func(childComplexity int) int
	}

	LANNetworkDeployment struct {
		AppliedAt        func(childComplexity int) int
		AppliedBy        func(childComplexity int) int
		BridgeID         func(childComplexity int) int
		DhcpServerID     func(childComplexity int) int
		Drift            func(childComplexity int) int
		IPAddressID      func(childComplexity int) int
		IsInSync         func(childComplexity int) int
		RouterResourceID func(childComplexity int) int
		RouterVersion    func(childComplexity int) int
	}

	LANNetworkRuntime struct {
		ActiveClients func(childComplexity int) int
		DhcpLeases    func(childComplexity int) int
		ErrorMessage  func(childComplexity int) int
		Health        func(childComplexity int) int
		IsRunning     func(childComplexity int) int
		LastUpdated   func(childComplexity int) int
		TotalBytesIn  func(childComplexity int) int
		TotalBytesOut func(childComplexity int) int
	}

	LteModem struct {
		Apn            func(childComplexity int) int
		Comment        func(childComplexity int) int
		ID             func(childComplexity int) int
		Name           func(childComplexity int) int
		NetworkType    func(childComplexity int) int
		Operator       func(childComplexity int) int
		PinConfigured  func(childComplexity int) int
		Running        func(childComplexity int) int
		SignalStrength func(childComplexity int) int
	}

	MemoryMetrics struct {
		Percentage func(childComplexity int) int
		Total      func(childComplexity int) int
		Used       func(childComplexity int) int
	}

	MissingDependency struct {
		ItemID              func(childComplexity int) int
		MissingResourceID   func(childComplexity int) int
		MissingResourceType func(childComplexity int) int
	}

	Mutation struct {
		AcknowledgeAlert        func(childComplexity int, alertID string) int
		AcknowledgeAlerts       func(childComplexity int, alertIds []string) int
		AddBridgePort           func(childComplexity int, bridgeID string, input model.AddBridgePortInput) int
		AddChangeSetItem        func(childComplexity int, changeSetID string, input model.ChangeSetItemInput) int
		AddRouter               func(childComplexity int, input model.AddRouterInput) int
		ApplyChangeSet          func(childComplexity int, changeSetID string) int
		ApplyResource           func(childComplexity int, id string, routerID string) int
		ApplyTroubleshootFix    func(childComplexity int, sessionID string, issueCode string) int
		ArchiveResource         func(childComplexity int, id string, routerID string) int
		AutoScanGateways        func(childComplexity int) int
		BatchInterfaceOperation func(childComplexity int, routerID string, input model.BatchInterfaceInput) int
		CancelChangeSet         func(childComplexity int, changeSetID string) int
		CancelScan              func(childComplexity int, taskID string) int
		CancelTraceroute        func(childComplexity int, jobID string) int
		CancelTroubleshoot      func(childComplexity int, sessionID string) int
		ChangePassword          func(childComplexity int, currentPassword string, newPassword string) int
		CheckRouterHealth       func(childComplexity int, routerID string) int
		ConfigureBridgePortVlan func(childComplexity int, routerID string, portID string, input model.BridgePortVlanInput) int
		ConfigureDhcpWan        func(childComplexity int, routerID string, input model.DhcpClientInput) int
		ConfigureLteWan         func(childComplexity int, routerID string, input model.LteModemInput) int
		ConfigurePppoeWan       func(childComplexity int, routerID string, input model.PppoeClientInput) int
		ConfigureStaticWan      func(childComplexity int, routerID string, input model.StaticIPInput) int
		ConfigureWANHealthCheck func(childComplexity int, routerID string, wanInterfaceID string, input model.WANHealthCheckInput) int
		ConnectRouter           func(childComplexity int, id string) int
		CreateAlertRule         func(childComplexity int, input model.CreateAlertRuleInput) int
		CreateBridge            func(childComplexity int, routerID string, input model.CreateBridgeInput) int
		CreateBridgeVlan        func(childComplexity int, bridgeID string, input model.CreateBridgeVlanInput) int
		CreateChangeSet         func(childComplexity int, input model.CreateChangeSetInput) int
		CreateIPAddress         func(childComplexity int, routerID string, input model.IPAddressInput) int
		CreateResource          func(childComplexity int, input model.CreateResourceInput) int
		CreateRoute             func(childComplexity int, routerID string, input model.RouteInput) int
		CreateRouter            func(childComplexity int, input model.CreateRouterInput) int
		CreateVlan              func(childComplexity int, routerID string, input model.VlanInput) int
		DeleteAlertRule         func(childComplexity int, id string) int
		DeleteBridge            func(childComplexity int, uuid string) int
		DeleteBridgeVlan        func(childComplexity int, uuid string) int
		DeleteChangeSet         func(childComplexity int, changeSetID string) int
		DeleteIPAddress         func(childComplexity int, routerID string, id string) int
		DeleteResource          func(childComplexity int, id string, routerID string) int
		DeleteRoute             func(childComplexity int, routerID string, id string) int
		DeleteRouter            func(childComplexity int, id string) int
		DeleteVlan              func(childComplexity int, id string) int
		DeleteWANConfiguration  func(childComplexity int, routerID string, wanInterfaceID string) int
		DeprecateResource       func(childComplexity int, id string, routerID string) int
		DisableInterface        func(childComplexity int, routerID string, interfaceID string) int
		DisconnectRouter        func(childComplexity int, id string) int
		EnableInterface         func(childComplexity int, routerID string, interfaceID string) int
		ExportRouterConfig      func(childComplexity int, input model.ExportConfigInput) int
		Login                   func(childComplexity int, username string, password string) int
		Logout                  func(childComplexity int) int
		ReconnectRouter         func(childComplexity int, routerID string) int
		RefreshCapabilities     func(childComplexity int, routerID string) int
		RemoveBridgePort        func(childComplexity int, portID string) int
		RemoveChangeSetItem     func(childComplexity int, changeSetID string, itemID string) int
		ResetCircuitBreaker     func(childComplexity int, routerID string) int
		RevokeAllSessions       func(childComplexity int, userID string) int
		RevokeSession           func(childComplexity int, sessionID string) int
		RollbackChangeSet       func(childComplexity int, changeSetID string) int
		RunDNSLookup            func(childComplexity int, input model.DNSLookupInput) int
		RunDiagnostics          func(childComplexity int, routerID string) int
		RunTraceroute           func(childComplexity int, deviceID string, input model.TracerouteInput) int
		RunTroubleshootStep     func(childComplexity int, sessionID string, stepType model.TroubleshootStepType) int
		ScanNetwork             func(childComplexity int, input model.ScanNetworkInput) int
		SetPreferredProtocol    func(childComplexity int, routerID string, protocol model.Protocol) int
		StartTroubleshoot       func(childComplexity int, routerID string) int
		TestAllCredentials      func(childComplexity int) int
		TestNotificationChannel func(childComplexity int, channel string, config map[string]interface{}) int
		TestRouterConnection    func(childComplexity int, id string) int
		TestRouterCredentials   func(childComplexity int, input model.AddRouterInput) int
		UndoBridgeOperation     func(childComplexity int, operationID string) int
		UpdateAlertRule         func(childComplexity int, id string, input model.UpdateAlertRuleInput) int
		UpdateBridge            func(childComplexity int, uuid string, input model.UpdateBridgeInput) int
		UpdateBridgePort        func(childComplexity int, portID string, input model.UpdateBridgePortInput) int
		UpdateChangeSetItem     func(childComplexity int, changeSetID string, itemID string, input model.UpdateChangeSetItemInput) int
		UpdateIPAddress         func(childComplexity int, routerID string, id string, input model.IPAddressInput) int
		UpdateInterface         func(childComplexity int, routerID string, interfaceID string, input model.UpdateInterfaceInput) int
		UpdateResource          func(childComplexity int, id string, routerID string, input model.UpdateResourceInput) int
		UpdateRoute             func(childComplexity int, routerID string, id string, input model.RouteInput) int
		UpdateRouter            func(childComplexity int, id string, input model.UpdateRouterInput) int
		UpdateRouterCredentials func(childComplexity int, routerID string, input model.CredentialsInput) int
		UpdateVlan              func(childComplexity int, id string, input model.VlanInput) int
		ValidateChangeSet       func(childComplexity int, changeSetID string) int
		ValidateResource        func(childComplexity int, id string, routerID string) int
		VerifyTroubleshootFix   func(childComplexity int, sessionID string, stepType model.TroubleshootStepType) int
	}

	MutationError struct {
		Code    func(childComplexity int) int
		Field   func(childComplexity int) int
		Message func(childComplexity int) int
	}

	NatRule struct {
		Action     func(childComplexity int) int
		Chain      func(childComplexity int) int
		Disabled   func(childComplexity int) int
		DstAddress func(childComplexity int) int
		ID         func(childComplexity int) int
		SrcAddress func(childComplexity int) int
		ToAddress  func(childComplexity int) int
	}

	NetworkConfigDetection struct {
		Gateway      func(childComplexity int) int
		IspInfo      func(childComplexity int) int
		WanInterface func(childComplexity int) int
	}

	OperationCounts struct {
		Create func(childComplexity int) int
		Delete func(childComplexity int) int
		Update func(childComplexity int) int
	}

	PageInfo struct {
		EndCursor       func(childComplexity int) int
		HasNextPage     func(childComplexity int) int
		HasPreviousPage func(childComplexity int) int
		StartCursor     func(childComplexity int) int
	}

	PlatformCapabilities struct {
		Details          func(childComplexity int) int
		IsSupported      func(childComplexity int) int
		Level            func(childComplexity int) int
		MinVersion       func(childComplexity int) int
		RequiredPackages func(childComplexity int) int
	}

	PlatformFeature struct {
		Description func(childComplexity int) int
		Enabled     func(childComplexity int) int
		ID          func(childComplexity int) int
		Name        func(childComplexity int) int
	}

	PlatformInfo struct {
		Capabilities  func(childComplexity int) int
		Current       func(childComplexity int) int
		Features      func(childComplexity int) int
		FieldMappings func(childComplexity int) int
		Limitations   func(childComplexity int) int
	}

	PlatformLimitation struct {
		AffectedFields func(childComplexity int) int
		Code           func(childComplexity int) int
		Description    func(childComplexity int) int
		Workaround     func(childComplexity int) int
	}

	PortStatus struct {
		Error          func(childComplexity int) int
		Open           func(childComplexity int) int
		Port           func(childComplexity int) int
		ResponseTimeMs func(childComplexity int) int
		Service        func(childComplexity int) int
	}

	PppoeClient struct {
		AddDefaultRoute func(childComplexity int) int
		Comment         func(childComplexity int) int
		Disabled        func(childComplexity int) int
		ID              func(childComplexity int) int
		Interface       func(childComplexity int) int
		Mru             func(childComplexity int) int
		Mtu             func(childComplexity int) int
		Name            func(childComplexity int) int
		Running         func(childComplexity int) int
		ServiceName     func(childComplexity int) int
		UsePeerDNS      func(childComplexity int) int
		Username        func(childComplexity int) int
	}

	Query struct {
		AlertRule                    func(childComplexity int, id string) int
		AlertRules                   func(childComplexity int, deviceID *string) int
		Alerts                       func(childComplexity int, deviceID *string, severity *model.AlertSeverity, acknowledged *bool, limit *int, offset *int) int
		AvailableInterfacesForBridge func(childComplexity int, routerID string) int
		Bridge                       func(childComplexity int, uuid string) int
		BridgePorts                  func(childComplexity int, bridgeID string) int
		BridgeVlans                  func(childComplexity int, bridgeID string) int
		Bridges                      func(childComplexity int, routerID string) int
		ChangeSet                    func(childComplexity int, id string, routerID string) int
		ChangeSets                   func(childComplexity int, routerID string, status *model.ChangeSetStatus, includeCompleted *bool) int
		CheckGatewayReachability     func(childComplexity int, routerID string, gateway model.IPv4) int
		CheckIPConflict              func(childComplexity int, routerID string, address string, interfaceID *string, excludeID *string) int
		CheckVlanIDAvailable         func(childComplexity int, routerID string, parentInterface string, vlanID int) int
		CircuitBreakerStatus         func(childComplexity int, routerID string) int
		CompatibilityMatrix          func(childComplexity int) int
		CompositeResource            func(childComplexity int, id string, routerID string) int
		ConnectionAttempts           func(childComplexity int, routerID string, limit *int) int
		ConnectionDetails            func(childComplexity int, routerID string) int
		ConnectionStats              func(childComplexity int) int
		DNSServers                   func(childComplexity int, deviceID string) int
		DetectGateway                func(childComplexity int, routerID string) int
		DetectIsp                    func(childComplexity int, routerID string) int
		DetectWanInterface           func(childComplexity int, routerID string) int
		Device                       func(childComplexity int, id string) int
		Health                       func(childComplexity int) int
		IPAddress                    func(childComplexity int, routerID string, id string) int
		IPAddressDependencies        func(childComplexity int, routerID string, id string) int
		IPAddresses                  func(childComplexity int, routerID string, interfaceID *string) int
		Interface                    func(childComplexity int, routerID string, id string) int
		InterfaceStatsHistory        func(childComplexity int, routerID string, interfaceID string, timeRange model.StatsTimeRangeInput, interval *model.Duration) int
		Interfaces                   func(childComplexity int, routerID string, typeArg *model.InterfaceType, pagination *model.PaginationInput) int
		IsFeatureSupported           func(childComplexity int, routerID string, featureID string) int
		Me                           func(childComplexity int) int
		MySessions                   func(childComplexity int) int
		Node                         func(childComplexity int, id string) int
		Resource                     func(childComplexity int, id string, routerID string, layers []model.ResourceLayer) int
		Resources                    func(childComplexity int, routerID string, category *model.ResourceCategory, typeArg *string, state *model.ResourceLifecycleState, pagination *model.PaginationInput) int
		Route                        func(childComplexity int, routerID string, id string) int
		Router                       func(childComplexity int, id string) int
		RouterCapabilities           func(childComplexity int, routerID string) int
		RouterCredentials            func(childComplexity int, routerID string) int
		RouterHealth                 func(childComplexity int, routerID string) int
		Routers                      func(childComplexity int, status *model.ConnectionStatus, pagination *model.PaginationInput) int
		Routes                       func(childComplexity int, routerID string, table *string, typeArg *model.RouteType) int
		ScanHistory                  func(childComplexity int, limit *int) int
		ScanStatus                   func(childComplexity int, taskID string) int
		SupportedFeatures            func(childComplexity int, routerID string) int
		TroubleshootSession          func(childComplexity int, id string) int
		UnsupportedFeatures          func(childComplexity int, routerID string) int
		UpgradeRecommendation        func(childComplexity int, routerID string, featureID string) int
		UpgradeRecommendations       func(childComplexity int, routerID string) int
		Version                      func(childComplexity int) int
		Vlan                         func(childComplexity int, id string) int
		VlanDependencies             func(childComplexity int, id string) int
		VlanTopology                 func(childComplexity int, routerID string, bridgeID string) int
		Vlans                        func(childComplexity int, routerID string, filter *model.VlanFilter) int
		WanConnectionHistory         func(childComplexity int, routerID string, wanInterfaceID string, pagination *model.PaginationInput) int
		WanInterface                 func(childComplexity int, routerID string, id string) int
		WanInterfaces                func(childComplexity int, routerID string) int
	}

	QuietHoursConfig struct {
		BypassCritical func(childComplexity int) int
		EndTime        func(childComplexity int) int
		StartTime      func(childComplexity int) int
		Timezone       func(childComplexity int) int
	}

	ReconnectRouterPayload struct {
		ConnectionDetails func(childComplexity int) int
		Errors            func(childComplexity int) int
		Initiated         func(childComplexity int) int
		Router            func(childComplexity int) int
		WaitTimeMs        func(childComplexity int) int
	}

	RefreshCapabilitiesPayload struct {
		Capabilities func(childComplexity int) int
		Errors       func(childComplexity int) int
	}

	RemoveChangeSetItemPayload struct {
		ChangeSet func(childComplexity int) int
		Errors    func(childComplexity int) int
	}

	ResourceConflict struct {
		ConflictingResource     func(childComplexity int) int
		ConflictingResourceUUID func(childComplexity int) int
		Description             func(childComplexity int) int
		Resolution              func(childComplexity int) int
		Type                    func(childComplexity int) int
	}

	ResourceConnection struct {
		Edges      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	ResourceEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	ResourceMetadata struct {
		CreatedAt     func(childComplexity int) int
		CreatedBy     func(childComplexity int) int
		Description   func(childComplexity int) int
		IsFavorite    func(childComplexity int) int
		IsPinned      func(childComplexity int) int
		Notes         func(childComplexity int) int
		RecentChanges func(childComplexity int) int
		State         func(childComplexity int) int
		Tags          func(childComplexity int) int
		UpdatedAt     func(childComplexity int) int
		UpdatedBy     func(childComplexity int) int
		Version       func(childComplexity int) int
	}

	ResourceMetrics struct {
		CPU         func(childComplexity int) int
		Memory      func(childComplexity int) int
		Storage     func(childComplexity int) int
		Temperature func(childComplexity int) int
		Timestamp   func(childComplexity int) int
	}

	ResourceReference struct {
		Category func(childComplexity int) int
		ID       func(childComplexity int) int
		State    func(childComplexity int) int
		Type     func(childComplexity int) int
		UUID     func(childComplexity int) int
	}

	ResourceRelationshipEdge struct {
		From func(childComplexity int) int
		To   func(childComplexity int) int
		Type func(childComplexity int) int
	}

	ResourceRelationships struct {
		Children   func(childComplexity int) int
		Custom     func(childComplexity int) int
		Dependents func(childComplexity int) int
		DependsOn  func(childComplexity int) int
		Parent     func(childComplexity int) int
		RoutedBy   func(childComplexity int) int
		RoutesVia  func(childComplexity int) int
	}

	ResourceRuntimeEvent struct {
		ID        func(childComplexity int) int
		Runtime   func(childComplexity int) int
		Timestamp func(childComplexity int) int
		Type      func(childComplexity int) int
	}

	ResourceStateEvent struct {
		ErrorMessage  func(childComplexity int) int
		ID            func(childComplexity int) int
		NewState      func(childComplexity int) int
		PreviousState func(childComplexity int) int
		Timestamp     func(childComplexity int) int
		Type          func(childComplexity int) int
	}

	ResourceUpdatedEvent struct {
		ChangeType    func(childComplexity int) int
		ChangedFields func(childComplexity int) int
		ResourceID    func(childComplexity int) int
		ResourceType  func(childComplexity int) int
		RouterID      func(childComplexity int) int
		Timestamp     func(childComplexity int) int
		Version       func(childComplexity int) int
	}

	RollbackChangeSetPayload struct {
		ChangeSet   func(childComplexity int) int
		Errors      func(childComplexity int) int
		FailedItems func(childComplexity int) int
		Success     func(childComplexity int) int
	}

	RollbackStep struct {
		Error         func(childComplexity int) int
		ItemID        func(childComplexity int) int
		Operation     func(childComplexity int) int
		ResourceUUID  func(childComplexity int) int
		RestoreState  func(childComplexity int) int
		RollbackOrder func(childComplexity int) int
		Success       func(childComplexity int) int
	}

	Route struct {
		Active       func(childComplexity int) int
		Comment      func(childComplexity int) int
		Destination  func(childComplexity int) int
		Disabled     func(childComplexity int) int
		Distance     func(childComplexity int) int
		Gateway      func(childComplexity int) int
		ID           func(childComplexity int) int
		Interface    func(childComplexity int) int
		RoutingMark  func(childComplexity int) int
		RoutingTable func(childComplexity int) int
		Scope        func(childComplexity int) int
		Type         func(childComplexity int) int
	}

	RouteDeleteResult struct {
		ImpactAnalysis func(childComplexity int) int
		Message        func(childComplexity int) int
		Success        func(childComplexity int) int
	}

	RouteImpactAnalysis struct {
		AffectedTraffic func(childComplexity int) int
		Consequences    func(childComplexity int) int
		IsDefaultRoute  func(childComplexity int) int
		Message         func(childComplexity int) int
		Severity        func(childComplexity int) int
	}

	RouteMutationResult struct {
		Message func(childComplexity int) int
		Route   func(childComplexity int) int
		Success func(childComplexity int) int
	}

	RouteResource struct {
		Active        func(childComplexity int) int
		Category      func(childComplexity int) int
		Configuration func(childComplexity int) int
		Deployment    func(childComplexity int) int
		Distance      func(childComplexity int) int
		DstAddress    func(childComplexity int) int
		Gateway       func(childComplexity int) int
		ID            func(childComplexity int) int
		Interface     func(childComplexity int) int
		Metadata      func(childComplexity int) int
		Platform      func(childComplexity int) int
		Relationships func(childComplexity int) int
		Runtime       func(childComplexity int) int
		ScopedID      func(childComplexity int) int
		Telemetry     func(childComplexity int) int
		Type          func(childComplexity int) int
		Validation    func(childComplexity int) int
	}

	Router struct {
		Capabilities  func(childComplexity int) int
		CreatedAt     func(childComplexity int) int
		Host          func(childComplexity int) int
		ID            func(childComplexity int) int
		LastConnected func(childComplexity int) int
		Model         func(childComplexity int) int
		Name          func(childComplexity int) int
		Platform      func(childComplexity int) int
		Port          func(childComplexity int) int
		Status        func(childComplexity int) int
		UpdatedAt     func(childComplexity int) int
		Uptime        func(childComplexity int) int
		Version       func(childComplexity int) int
	}

	RouterAddedEvent struct {
		AddedBy      func(childComplexity int) int
		ProtocolUsed func(childComplexity int) int
		Router       func(childComplexity int) int
		Timestamp    func(childComplexity int) int
	}

	RouterCapabilities struct {
		Capabilities        func(childComplexity int) int
		Container           func(childComplexity int) int
		DetectedAt          func(childComplexity int) int
		ExpiresAt           func(childComplexity int) int
		Hardware            func(childComplexity int) int
		IsRefreshing        func(childComplexity int) int
		RouterOSVersion     func(childComplexity int) int
		Software            func(childComplexity int) int
		SupportedFeatures   func(childComplexity int) int
		UnsupportedFeatures func(childComplexity int) int
		VifRequirements     func(childComplexity int) int
	}

	RouterConnection struct {
		Edges      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	RouterCredentials struct {
		CreatedAt        func(childComplexity int) int
		EncryptionStatus func(childComplexity int) int
		HasPassword      func(childComplexity int) int
		KeyVersion       func(childComplexity int) int
		LastUpdated      func(childComplexity int) int
		RouterID         func(childComplexity int) int
		Username         func(childComplexity int) int
	}

	RouterEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	RouterOSInfo struct {
		Architecture func(childComplexity int) int
		BoardName    func(childComplexity int) int
		Platform     func(childComplexity int) int
		Version      func(childComplexity int) int
	}

	RouterOSVersion struct {
		Channel         func(childComplexity int) int
		IsAtLeast       func(childComplexity int, version string) int
		IsChr           func(childComplexity int) int
		Major           func(childComplexity int) int
		Minor           func(childComplexity int) int
		Patch           func(childComplexity int) int
		Raw             func(childComplexity int) int
		SupportsFeature func(childComplexity int, featureID string) int
	}

	RouterStatusEvent struct {
		NewStatus      func(childComplexity int) int
		PreviousStatus func(childComplexity int) int
		Router         func(childComplexity int) int
		Timestamp      func(childComplexity int) int
	}

	RunTroubleshootStepPayload struct {
		Errors func(childComplexity int) int
		Step   func(childComplexity int) int
	}

	RuntimeMetrics struct {
		BytesIn       func(childComplexity int) int
		BytesOut      func(childComplexity int) int
		Custom        func(childComplexity int) int
		Drops         func(childComplexity int) int
		Errors        func(childComplexity int) int
		PacketsIn     func(childComplexity int) int
		PacketsOut    func(childComplexity int) int
		ThroughputIn  func(childComplexity int) int
		ThroughputOut func(childComplexity int) int
	}

	RuntimeState struct {
		ActiveConnections       func(childComplexity int) int
		ErrorMessage            func(childComplexity int) int
		Health                  func(childComplexity int) int
		IsRunning               func(childComplexity int) int
		LastSuccessfulOperation func(childComplexity int) int
		LastUpdated             func(childComplexity int) int
		Metrics                 func(childComplexity int) int
		Uptime                  func(childComplexity int) int
	}

	ScanNetworkPayload struct {
		Errors func(childComplexity int) int
		Task   func(childComplexity int) int
	}

	ScanProgressEvent struct {
		CurrentIP    func(childComplexity int) int
		DevicesFound func(childComplexity int) int
		Progress     func(childComplexity int) int
		Status       func(childComplexity int) int
		TaskID       func(childComplexity int) int
		Timestamp    func(childComplexity int) int
	}

	ScanTask struct {
		EndTime    func(childComplexity int) int
		Error      func(childComplexity int) int
		ID         func(childComplexity int) int
		Progress   func(childComplexity int) int
		Results    func(childComplexity int) int
		ScannedIPs func(childComplexity int) int
		StartTime  func(childComplexity int) int
		Status     func(childComplexity int) int
		Subnet     func(childComplexity int) int
		TotalIPs   func(childComplexity int) int
	}

	Session struct {
		CreatedAt    func(childComplexity int) int
		ID           func(childComplexity int) int
		IPAddress    func(childComplexity int) int
		IsCurrent    func(childComplexity int) int
		LastActivity func(childComplexity int) int
		UserAgent    func(childComplexity int) int
	}

	SetPreferredProtocolPayload struct {
		ConnectionDetails func(childComplexity int) int
		Errors            func(childComplexity int) int
		Router            func(childComplexity int) int
	}

	SoftwareInfo struct {
		InstalledPackages func(childComplexity int) int
		LicenseLevel      func(childComplexity int) int
		UpdateChannel     func(childComplexity int) int
		Version           func(childComplexity int) int
		VersionMajor      func(childComplexity int) int
		VersionMinor      func(childComplexity int) int
		VersionPatch      func(childComplexity int) int
	}

	StartTroubleshootPayload struct {
		Errors  func(childComplexity int) int
		Session func(childComplexity int) int
	}

	StaticIPConfig struct {
		Address      func(childComplexity int) int
		Comment      func(childComplexity int) int
		Gateway      func(childComplexity int) int
		ID           func(childComplexity int) int
		Interface    func(childComplexity int) int
		PrimaryDNS   func(childComplexity int) int
		SecondaryDNS func(childComplexity int) int
	}

	StatsDataPoint struct {
		RxBytesPerSec   func(childComplexity int) int
		RxErrors        func(childComplexity int) int
		RxPacketsPerSec func(childComplexity int) int
		Timestamp       func(childComplexity int) int
		TxBytesPerSec   func(childComplexity int) int
		TxErrors        func(childComplexity int) int
		TxPacketsPerSec func(childComplexity int) int
	}

	StorageMetrics struct {
		Percentage func(childComplexity int) int
		Total      func(childComplexity int) int
		Used       func(childComplexity int) int
	}

	Subscription struct {
		AlertEvents                func(childComplexity int, deviceID *string) int
		BridgePortsChanged         func(childComplexity int, bridgeID string) int
		BridgeStpStatusChanged     func(childComplexity int, bridgeID string) int
		ChangeSetProgress          func(childComplexity int, changeSetID string) int
		ChangeSetStatusChanged     func(childComplexity int, routerID string) int
		CircuitBreakerChanged      func(childComplexity int, routerID string) int
		CircuitBreakerStateChanged func(childComplexity int, routerID *string) int
		ConfigApplyProgress        func(childComplexity int, operationID string) int
		ConnectionHealth           func(childComplexity int, routerID *string) int
		IPAddressChanged           func(childComplexity int, routerID string) int
		InterfaceStatsUpdated      func(childComplexity int, routerID string, interfaceID string, interval *model.Duration) int
		InterfaceStatusChanged     func(childComplexity int, routerID string, interfaceID *string) int
		InterfaceTraffic           func(childComplexity int, routerID string, interfaceID *string) int
		ResourceMetrics            func(childComplexity int, deviceID string) int
		ResourceRuntime            func(childComplexity int, id string, routerID string) int
		ResourceStateChanged       func(childComplexity int, id *string, routerID string) int
		ResourceUpdated            func(childComplexity int, resourceID *string) int
		RouterAdded                func(childComplexity int) int
		RouterStatusChanged        func(childComplexity int, routerID *string) int
		ScanProgress               func(childComplexity int, taskID string) int
		TracerouteProgress         func(childComplexity int, jobID string) int
		TroubleshootProgress       func(childComplexity int, sessionID string) int
		VlanChanged                func(childComplexity int, routerID string) int
		WanHealthChanged           func(childComplexity int, routerID string, wanInterfaceID string) int
		WanStatusChanged           func(childComplexity int, routerID string, wanInterfaceID *string) int
	}

	TLSStatus struct {
		Error     func(childComplexity int) int
		ExpiresAt func(childComplexity int) int
		Issuer    func(childComplexity int) int
		Subject   func(childComplexity int) int
		Valid     func(childComplexity int) int
	}

	TelemetryData struct {
		BandwidthHistory func(childComplexity int) int
		DailyStats       func(childComplexity int) int
		DataStartedAt    func(childComplexity int) int
		HourlyStats      func(childComplexity int) int
		LastUpdatedAt    func(childComplexity int) int
		RetentionDays    func(childComplexity int) int
		UptimeHistory    func(childComplexity int) int
	}

	TestAllCredentialsPayload struct {
		FailureCount func(childComplexity int) int
		Results      func(childComplexity int) int
		SuccessCount func(childComplexity int) int
		TotalRouters func(childComplexity int) int
	}

	TestConnectionPayload struct {
		Error          func(childComplexity int) int
		ResponseTimeMs func(childComplexity int) int
		Success        func(childComplexity int) int
		Version        func(childComplexity int) int
	}

	TestNotificationPayload struct {
		Errors  func(childComplexity int) int
		Message func(childComplexity int) int
		Success func(childComplexity int) int
	}

	ThrottleConfig struct {
		GroupByField  func(childComplexity int) int
		MaxAlerts     func(childComplexity int) int
		PeriodSeconds func(childComplexity int) int
	}

	TopologyEdge struct {
		Data   func(childComplexity int) int
		ID     func(childComplexity int) int
		Label  func(childComplexity int) int
		Source func(childComplexity int) int
		Style  func(childComplexity int) int
		Target func(childComplexity int) int
	}

	TopologyEdgeStyle struct {
		Stroke          func(childComplexity int) int
		StrokeDasharray func(childComplexity int) int
		StrokeWidth     func(childComplexity int) int
	}

	TopologyNode struct {
		Data     func(childComplexity int) int
		ID       func(childComplexity int) int
		Label    func(childComplexity int) int
		Position func(childComplexity int) int
		Style    func(childComplexity int) int
		Sublabel func(childComplexity int) int
		Type     func(childComplexity int) int
	}

	TopologyNodeStyle struct {
		Fill        func(childComplexity int) int
		Stroke      func(childComplexity int) int
		StrokeWidth func(childComplexity int) int
	}

	TopologyPosition struct {
		X func(childComplexity int) int
		Y func(childComplexity int) int
	}

	TracerouteHop struct {
		Address      func(childComplexity int) int
		AvgLatencyMs func(childComplexity int) int
		HopNumber    func(childComplexity int) int
		Hostname     func(childComplexity int) int
		PacketLoss   func(childComplexity int) int
		Probes       func(childComplexity int) int
		Status       func(childComplexity int) int
	}

	TracerouteJob struct {
		JobID  func(childComplexity int) int
		Status func(childComplexity int) int
	}

	TracerouteProgressEvent struct {
		Error     func(childComplexity int) int
		EventType func(childComplexity int) int
		Hop       func(childComplexity int) int
		JobID     func(childComplexity int) int
		Result    func(childComplexity int) int
	}

	TracerouteResult struct {
		Completed          func(childComplexity int) int
		CompletedAt        func(childComplexity int) int
		Hops               func(childComplexity int) int
		MaxHops            func(childComplexity int) int
		Protocol           func(childComplexity int) int
		ReachedDestination func(childComplexity int) int
		StartedAt          func(childComplexity int) int
		Target             func(childComplexity int) int
		TargetIP           func(childComplexity int) int
		TotalTimeMs        func(childComplexity int) int
	}

	TroubleshootFixSuggestion struct {
		Command              func(childComplexity int) int
		Confidence           func(childComplexity int) int
		Explanation          func(childComplexity int) int
		IsManualFix          func(childComplexity int) int
		IssueCode            func(childComplexity int) int
		ManualSteps          func(childComplexity int) int
		RequiresConfirmation func(childComplexity int) int
		RollbackCommand      func(childComplexity int) int
		Title                func(childComplexity int) int
	}

	TroubleshootSession struct {
		AppliedFixes     func(childComplexity int) int
		CompletedAt      func(childComplexity int) int
		CurrentStepIndex func(childComplexity int) int
		Gateway          func(childComplexity int) int
		ID               func(childComplexity int) int
		IspInfo          func(childComplexity int) int
		RouterID         func(childComplexity int) int
		StartedAt        func(childComplexity int) int
		Status           func(childComplexity int) int
		Steps            func(childComplexity int) int
		WanInterface     func(childComplexity int) int
	}

	TroubleshootStep struct {
		CompletedAt func(childComplexity int) int
		Description func(childComplexity int) int
		Fix         func(childComplexity int) int
		ID          func(childComplexity int) int
		Name        func(childComplexity int) int
		Result      func(childComplexity int) int
		StartedAt   func(childComplexity int) int
		Status      func(childComplexity int) int
	}

	TroubleshootStepResult struct {
		Details         func(childComplexity int) int
		ExecutionTimeMs func(childComplexity int) int
		IssueCode       func(childComplexity int) int
		Message         func(childComplexity int) int
		Success         func(childComplexity int) int
		Target          func(childComplexity int) int
	}

	UpdateChangeSetItemPayload struct {
		ChangeSet func(childComplexity int) int
		Errors    func(childComplexity int) int
	}

	UpdateInterfacePayload struct {
		Errors    func(childComplexity int) int
		Interface func(childComplexity int) int
	}

	UpdateResourcePayload struct {
		Errors   func(childComplexity int) int
		Resource func(childComplexity int) int
	}

	UpdateRouterPayload struct {
		Errors func(childComplexity int) int
		Router func(childComplexity int) int
	}

	UpgradeImpact struct {
		BackupRecommended func(childComplexity int) int
		BreakingChanges   func(childComplexity int) int
		EstimatedDowntime func(childComplexity int) int
		RequiresReboot    func(childComplexity int) int
	}

	UpgradeRecommendation struct {
		CurrentVersion   func(childComplexity int) int
		DocumentationURL func(childComplexity int) int
		FeatureID        func(childComplexity int) int
		FeatureName      func(childComplexity int) int
		Impact           func(childComplexity int) int
		IsMajorUpgrade   func(childComplexity int) int
		Priority         func(childComplexity int) int
		RequiredVersion  func(childComplexity int) int
		Steps            func(childComplexity int) int
		Warnings         func(childComplexity int) int
	}

	UpgradeStep struct {
		Command     func(childComplexity int) int
		Description func(childComplexity int) int
		Optional    func(childComplexity int) int
		Step        func(childComplexity int) int
		Title       func(childComplexity int) int
	}

	UptimeDataPoint struct {
		IsUp          func(childComplexity int) int
		PeriodSeconds func(childComplexity int) int
		Timestamp     func(childComplexity int) int
	}

	User struct {
		CreatedAt   func(childComplexity int) int
		DisplayName func(childComplexity int) int
		Email       func(childComplexity int) int
		ID          func(childComplexity int) int
		LastLoginAt func(childComplexity int) int
		Role        func(childComplexity int) int
		Username    func(childComplexity int) int
	}

	VIFGuidanceStep struct {
		Completed     func(childComplexity int) int
		Description   func(childComplexity int) int
		RouterCommand func(childComplexity int) int
		Step          func(childComplexity int) int
		Title         func(childComplexity int) int
	}

	VIFRequirements struct {
		ContainerEnabled  func(childComplexity int) int
		ContainerPackage  func(childComplexity int) int
		GuidanceSteps     func(childComplexity int) int
		Met               func(childComplexity int) int
		MissingReasons    func(childComplexity int) int
		NetworkNamespace  func(childComplexity int) int
		RouterOSVersion   func(childComplexity int) int
		SufficientStorage func(childComplexity int) int
	}

	ValidateChangeSetPayload struct {
		ChangeSet  func(childComplexity int) int
		Errors     func(childComplexity int) int
		Validation func(childComplexity int) int
	}

	ValidateResourcePayload struct {
		Errors     func(childComplexity int) int
		Resource   func(childComplexity int) int
		Validation func(childComplexity int) int
	}

	ValidationError struct {
		Code          func(childComplexity int) int
		Field         func(childComplexity int) int
		Message       func(childComplexity int) int
		ProvidedValue func(childComplexity int) int
		Suggestion    func(childComplexity int) int
	}

	ValidationIssue struct {
		Code         func(childComplexity int) int
		DocsURL      func(childComplexity int) int
		Field        func(childComplexity int) int
		Message      func(childComplexity int) int
		Severity     func(childComplexity int) int
		SuggestedFix func(childComplexity int) int
	}

	ValidationResult struct {
		CanApply             func(childComplexity int) int
		Conflicts            func(childComplexity int) int
		Errors               func(childComplexity int) int
		RequiredDependencies func(childComplexity int) int
		Stage                func(childComplexity int) int
		ValidatedAt          func(childComplexity int) int
		ValidationDurationMs func(childComplexity int) int
		Warnings             func(childComplexity int) int
	}

	Vlan struct {
		Comment     func(childComplexity int) int
		Disabled    func(childComplexity int) int
		ID          func(childComplexity int) int
		IPAddresses func(childComplexity int) int
		Interface   func(childComplexity int) int
		MacAddress  func(childComplexity int) int
		Mtu         func(childComplexity int) int
		Name        func(childComplexity int) int
		Running     func(childComplexity int) int
		Statistics  func(childComplexity int) int
		VlanID      func(childComplexity int) int
	}

	VlanDependencies struct {
		ActiveConnections func(childComplexity int) int
		DhcpServers       func(childComplexity int) int
		FirewallRules     func(childComplexity int) int
		HasDependencies   func(childComplexity int) int
		IPAddresses       func(childComplexity int) int
		Routes            func(childComplexity int) int
		VlanID            func(childComplexity int) int
	}

	VlanMutationResult struct {
		Errors  func(childComplexity int) int
		Preview func(childComplexity int) int
		Success func(childComplexity int) int
		Vlan    func(childComplexity int) int
	}

	VlanTopology struct {
		Edges func(childComplexity int) int
		Nodes func(childComplexity int) int
	}

	WANConnectionEvent struct {
		Duration       func(childComplexity int) int
		EventType      func(childComplexity int) int
		Gateway        func(childComplexity int) int
		ID             func(childComplexity int) int
		PublicIP       func(childComplexity int) int
		Reason         func(childComplexity int) int
		Timestamp      func(childComplexity int) int
		WanInterfaceID func(childComplexity int) int
	}

	WANConnectionEventConnection struct {
		Edges      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	WANConnectionEventEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	WANHealthStatus struct {
		Enabled      func(childComplexity int) int
		FailureCount func(childComplexity int) int
		Interval     func(childComplexity int) int
		LastCheck    func(childComplexity int) int
		Latency      func(childComplexity int) int
		PacketLoss   func(childComplexity int) int
		Status       func(childComplexity int) int
		SuccessCount func(childComplexity int) int
		Target       func(childComplexity int) int
	}

	WANInterface struct {
		DhcpClient     func(childComplexity int) int
		Gateway        func(childComplexity int) int
		Health         func(childComplexity int) int
		ID             func(childComplexity int) int
		Interface      func(childComplexity int) int
		IsDefaultRoute func(childComplexity int) int
		LastConnected  func(childComplexity int) int
		LteModem       func(childComplexity int) int
		PppoeClient    func(childComplexity int) int
		PrimaryDNS     func(childComplexity int) int
		PublicIP       func(childComplexity int) int
		SecondaryDNS   func(childComplexity int) int
		StaticConfig   func(childComplexity int) int
		Statistics     func(childComplexity int) int
		Status         func(childComplexity int) int
		Type           func(childComplexity int) int
		Uptime         func(childComplexity int) int
	}

	WANLink struct {
		Category         func(childComplexity int) int
		Configuration    func(childComplexity int) int
		ConnectionType   func(childComplexity int) int
		Deployment       func(childComplexity int) int
		FailoverPriority func(childComplexity int) int
		ID               func(childComplexity int) int
		Interface        func(childComplexity int) int
		IsPrimary        func(childComplexity int) int
		Metadata         func(childComplexity int) int
		Platform         func(childComplexity int) int
		Relationships    func(childComplexity int) int
		Runtime          func(childComplexity int) int
		ScopedID         func(childComplexity int) int
		Telemetry        func(childComplexity int) int
		Type             func(childComplexity int) int
		Validation       func(childComplexity int) int
		WanRuntime       func(childComplexity int) int
	}

	WANLinkRuntime struct {
		CurrentIP       func(childComplexity int) int
		DNSServers      func(childComplexity int) int
		DownlinkSpeed   func(childComplexity int) int
		ErrorMessage    func(childComplexity int) int
		Gateway         func(childComplexity int) int
		Health          func(childComplexity int) int
		IsRunning       func(childComplexity int) int
		LastStateChange func(childComplexity int) int
		LastUpdated     func(childComplexity int) int
		PublicIP        func(childComplexity int) int
		UplinkSpeed     func(childComplexity int) int
		Uptime          func(childComplexity int) int
	}

	WANMutationResult struct {
		Errors       func(childComplexity int) int
		Preview      func(childComplexity int) int
		Success      func(childComplexity int) int
		WanInterface func(childComplexity int) int
	}

	WireGuardClient struct {
		Category            func(childComplexity int) int
		Config              func(childComplexity int) int
		Configuration       func(childComplexity int) int
		Deployment          func(childComplexity int) int
		ID                  func(childComplexity int) int
		Metadata            func(childComplexity int) int
		Platform            func(childComplexity int) int
		Relationships       func(childComplexity int) int
		Runtime             func(childComplexity int) int
		ScopedID            func(childComplexity int) int
		Telemetry           func(childComplexity int) int
		Type                func(childComplexity int) int
		Validation          func(childComplexity int) int
		WireguardDeployment func(childComplexity int) int
		WireguardRuntime    func(childComplexity int) int
	}

	WireGuardClientConfig struct {
		AllowedIPs          func(childComplexity int) int
		DNSServers          func(childComplexity int) int
		KillSwitch          func(childComplexity int) int
		ListenPort          func(childComplexity int) int
		Name                func(childComplexity int) int
		PeerEndpoint        func(childComplexity int) int
		PeerPublicKey       func(childComplexity int) int
		PersistentKeepalive func(childComplexity int) int
		PrivateKey          func(childComplexity int) int
		WanInterface        func(childComplexity int) int
	}

	WireGuardDeployment struct {
		AppliedAt        func(childComplexity int) int
		AppliedBy        func(childComplexity int) int
		Drift            func(childComplexity int) int
		InterfaceName    func(childComplexity int) int
		IsInSync         func(childComplexity int) int
		PublicKey        func(childComplexity int) int
		RouterResourceID func(childComplexity int) int
		RouterVersion    func(childComplexity int) int
	}

	WireGuardRuntime struct {
		ActivePeers     func(childComplexity int) int
		BytesIn         func(childComplexity int) int
		BytesOut        func(childComplexity int) int
		CurrentEndpoint func(childComplexity int) int
		ErrorMessage    func(childComplexity int) int
		Health          func(childComplexity int) int
		IsConnected     func(childComplexity int) int
		IsRunning       func(childComplexity int) int
		LastHandshake   func(childComplexity int) int
		LastUpdated     func(childComplexity int) int
	}
}

type MutationResolver interface {
	CreateRouter(ctx context.Context, input model.CreateRouterInput) (*model.CreateRouterPayload, error)
	UpdateRouter(ctx context.Context, id string, input model.UpdateRouterInput) (*model.UpdateRouterPayload, error)
	DeleteRouter(ctx context.Context, id string) (*model.DeleteRouterPayload, error)
	TestRouterConnection(ctx context.Context, id string) (*model.TestConnectionPayload, error)
	ConnectRouter(ctx context.Context, id string) (*model.ConnectRouterPayload, error)
	DisconnectRouter(ctx context.Context, id string) (*model.DisconnectRouterPayload, error)
	RefreshCapabilities(ctx context.Context, routerID string) (*model.RefreshCapabilitiesPayload, error)
	UpdateInterface(ctx context.Context, routerID string, interfaceID string, input model.UpdateInterfaceInput) (*model.UpdateInterfacePayload, error)
	EnableInterface(ctx context.Context, routerID string, interfaceID string) (*model.UpdateInterfacePayload, error)
	DisableInterface(ctx context.Context, routerID string, interfaceID string) (*model.UpdateInterfacePayload, error)
	BatchInterfaceOperation(ctx context.Context, routerID string, input model.BatchInterfaceInput) (*model.BatchInterfacePayload, error)
	Login(ctx context.Context, username string, password string) (*model.AuthPayload, error)
	Logout(ctx context.Context) (bool, error)
	ChangePassword(ctx context.Context, currentPassword string, newPassword string) (bool, error)
	RevokeAllSessions(ctx context.Context, userID string) (bool, error)
	RevokeSession(ctx context.Context, sessionID string) (bool, error)
	SetPreferredProtocol(ctx context.Context, routerID string, protocol model.Protocol) (*model.SetPreferredProtocolPayload, error)
	ReconnectRouter(ctx context.Context, routerID string) (*model.ReconnectRouterPayload, error)
	CheckRouterHealth(ctx context.Context, routerID string) (*model.HealthCheckResult, error)
	UpdateRouterCredentials(ctx context.Context, routerID string, input model.CredentialsInput) (*model.CredentialUpdatePayload, error)
	TestAllCredentials(ctx context.Context) (*model.TestAllCredentialsPayload, error)
	ExportRouterConfig(ctx context.Context, input model.ExportConfigInput) (*model.ExportConfigPayload, error)
	ScanNetwork(ctx context.Context, input model.ScanNetworkInput) (*model.ScanNetworkPayload, error)
	AutoScanGateways(ctx context.Context) (*model.ScanNetworkPayload, error)
	CancelScan(ctx context.Context, taskID string) (*model.CancelScanPayload, error)
	CreateChangeSet(ctx context.Context, input model.CreateChangeSetInput) (*model.CreateChangeSetPayload, error)
	AddChangeSetItem(ctx context.Context, changeSetID string, input model.ChangeSetItemInput) (*model.AddChangeSetItemPayload, error)
	UpdateChangeSetItem(ctx context.Context, changeSetID string, itemID string, input model.UpdateChangeSetItemInput) (*model.UpdateChangeSetItemPayload, error)
	RemoveChangeSetItem(ctx context.Context, changeSetID string, itemID string) (*model.RemoveChangeSetItemPayload, error)
	ValidateChangeSet(ctx context.Context, changeSetID string) (*model.ValidateChangeSetPayload, error)
	ApplyChangeSet(ctx context.Context, changeSetID string) (*model.ApplyChangeSetPayload, error)
	CancelChangeSet(ctx context.Context, changeSetID string) (*model.CancelChangeSetPayload, error)
	RollbackChangeSet(ctx context.Context, changeSetID string) (*model.RollbackChangeSetPayload, error)
	DeleteChangeSet(ctx context.Context, changeSetID string) (*model.DeleteChangeSetPayload, error)
	RunDiagnostics(ctx context.Context, routerID string) (*model.DiagnosticReport, error)
	ResetCircuitBreaker(ctx context.Context, routerID string) (*model.CircuitBreakerStatus, error)
	StartTroubleshoot(ctx context.Context, routerID string) (*model.StartTroubleshootPayload, error)
	RunTroubleshootStep(ctx context.Context, sessionID string, stepType model.TroubleshootStepType) (*model.RunTroubleshootStepPayload, error)
	ApplyTroubleshootFix(ctx context.Context, sessionID string, issueCode string) (*model.ApplyFixPayload, error)
	VerifyTroubleshootFix(ctx context.Context, sessionID string, stepType model.TroubleshootStepType) (*model.RunTroubleshootStepPayload, error)
	CancelTroubleshoot(ctx context.Context, sessionID string) (*model.TroubleshootSession, error)
	RunTraceroute(ctx context.Context, deviceID string, input model.TracerouteInput) (*model.TracerouteJob, error)
	CancelTraceroute(ctx context.Context, jobID string) (bool, error)
	RunDNSLookup(ctx context.Context, input model.DNSLookupInput) (*model.DNSLookupResult, error)
	CreateAlertRule(ctx context.Context, input model.CreateAlertRuleInput) (*model.AlertRulePayload, error)
	UpdateAlertRule(ctx context.Context, id string, input model.UpdateAlertRuleInput) (*model.AlertRulePayload, error)
	DeleteAlertRule(ctx context.Context, id string) (*model.DeletePayload, error)
	AcknowledgeAlert(ctx context.Context, alertID string) (*model.AlertPayload, error)
	AcknowledgeAlerts(ctx context.Context, alertIds []string) (*model.BulkAlertPayload, error)
	TestNotificationChannel(ctx context.Context, channel string, config map[string]interface{}) (*model.TestNotificationPayload, error)
	AddRouter(ctx context.Context, input model.AddRouterInput) (*model.AddRouterPayload, error)
	TestRouterCredentials(ctx context.Context, input model.AddRouterInput) (*model.ConnectionTestResult, error)
	CreateResource(ctx context.Context, input model.CreateResourceInput) (*model.CreateResourcePayload, error)
	UpdateResource(ctx context.Context, id string, routerID string, input model.UpdateResourceInput) (*model.UpdateResourcePayload, error)
	ValidateResource(ctx context.Context, id string, routerID string) (*model.ValidateResourcePayload, error)
	ApplyResource(ctx context.Context, id string, routerID string) (*model.ApplyResourcePayload, error)
	DeprecateResource(ctx context.Context, id string, routerID string) (*model.DeprecateResourcePayload, error)
	ArchiveResource(ctx context.Context, id string, routerID string) (*model.ArchiveResourcePayload, error)
	DeleteResource(ctx context.Context, id string, routerID string) (*model.DeleteResourcePayload, error)
	CreateIPAddress(ctx context.Context, routerID string, input model.IPAddressInput) (*model.IPAddressMutationResult, error)
	UpdateIPAddress(ctx context.Context, routerID string, id string, input model.IPAddressInput) (*model.IPAddressMutationResult, error)
	DeleteIPAddress(ctx context.Context, routerID string, id string) (*model.IPAddressDeleteResult, error)
	CreateVlan(ctx context.Context, routerID string, input model.VlanInput) (*model.VlanMutationResult, error)
	UpdateVlan(ctx context.Context, id string, input model.VlanInput) (*model.VlanMutationResult, error)
	DeleteVlan(ctx context.Context, id string) (*model.DeleteResult, error)
	ConfigureBridgePortVlan(ctx context.Context, routerID string, portID string, input model.BridgePortVlanInput) (*model.VlanMutationResult, error)
	CreateRoute(ctx context.Context, routerID string, input model.RouteInput) (*model.RouteMutationResult, error)
	UpdateRoute(ctx context.Context, routerID string, id string, input model.RouteInput) (*model.RouteMutationResult, error)
	DeleteRoute(ctx context.Context, routerID string, id string) (*model.RouteDeleteResult, error)
	CreateBridge(ctx context.Context, routerID string, input model.CreateBridgeInput) (*model.BridgeMutationResult, error)
	UpdateBridge(ctx context.Context, uuid string, input model.UpdateBridgeInput) (*model.BridgeMutationResult, error)
	DeleteBridge(ctx context.Context, uuid string) (*model.DeleteResult, error)
	UndoBridgeOperation(ctx context.Context, operationID string) (*model.BridgeMutationResult, error)
	AddBridgePort(ctx context.Context, bridgeID string, input model.AddBridgePortInput) (*model.BridgePortMutationResult, error)
	UpdateBridgePort(ctx context.Context, portID string, input model.UpdateBridgePortInput) (*model.BridgePortMutationResult, error)
	RemoveBridgePort(ctx context.Context, portID string) (*model.DeleteResult, error)
	CreateBridgeVlan(ctx context.Context, bridgeID string, input model.CreateBridgeVlanInput) (*model.BridgeVlanMutationResult, error)
	DeleteBridgeVlan(ctx context.Context, uuid string) (*model.DeleteResult, error)
	ConfigureDhcpWan(ctx context.Context, routerID string, input model.DhcpClientInput) (*model.WANMutationResult, error)
	ConfigurePppoeWan(ctx context.Context, routerID string, input model.PppoeClientInput) (*model.WANMutationResult, error)
	ConfigureStaticWan(ctx context.Context, routerID string, input model.StaticIPInput) (*model.WANMutationResult, error)
	ConfigureLteWan(ctx context.Context, routerID string, input model.LteModemInput) (*model.WANMutationResult, error)
	ConfigureWANHealthCheck(ctx context.Context, routerID string, wanInterfaceID string, input model.WANHealthCheckInput) (*model.WANMutationResult, error)
	DeleteWANConfiguration(ctx context.Context, routerID string, wanInterfaceID string) (*model.DeleteResult, error)
}
type QueryResolver interface {
	Node(ctx context.Context, id string) (model.Node, error)
	Health(ctx context.Context) (*model.HealthStatus, error)
	Version(ctx context.Context) (string, error)
	Device(ctx context.Context, id string) (*model.Device, error)
	Router(ctx context.Context, id string) (*model.Router, error)
	Routers(ctx context.Context, status *model.ConnectionStatus, pagination *model.PaginationInput) (*model.RouterConnection, error)
	Interface(ctx context.Context, routerID string, id string) (*model.Interface, error)
	Interfaces(ctx context.Context, routerID string, typeArg *model.InterfaceType, pagination *model.PaginationInput) (*model.InterfaceConnection, error)
	RouterCapabilities(ctx context.Context, routerID string) (*model.RouterCapabilities, error)
	IsFeatureSupported(ctx context.Context, routerID string, featureID string) (*model.FeatureSupport, error)
	SupportedFeatures(ctx context.Context, routerID string) ([]*model.FeatureSupport, error)
	UnsupportedFeatures(ctx context.Context, routerID string) ([]*model.FeatureSupport, error)
	CompatibilityMatrix(ctx context.Context) ([]*model.FeatureCompatibilityInfo, error)
	UpgradeRecommendation(ctx context.Context, routerID string, featureID string) (*model.UpgradeRecommendation, error)
	UpgradeRecommendations(ctx context.Context, routerID string) ([]*model.UpgradeRecommendation, error)
	Me(ctx context.Context) (*model.User, error)
	MySessions(ctx context.Context) ([]*model.Session, error)
	ConnectionDetails(ctx context.Context, routerID string) (*model.ConnectionDetails, error)
	RouterHealth(ctx context.Context, routerID string) (*model.HealthCheckResult, error)
	ConnectionStats(ctx context.Context) (*model.ConnectionStats, error)
	RouterCredentials(ctx context.Context, routerID string) (*model.RouterCredentials, error)
	ScanStatus(ctx context.Context, taskID string) (*model.ScanTask, error)
	ScanHistory(ctx context.Context, limit *int) ([]*model.ScanTask, error)
	ChangeSet(ctx context.Context, id string, routerID string) (*model.ChangeSet, error)
	ChangeSets(ctx context.Context, routerID string, status *model.ChangeSetStatus, includeCompleted *bool) ([]*model.ChangeSetSummary, error)
	ConnectionAttempts(ctx context.Context, routerID string, limit *int) ([]*model.ConnectionAttempt, error)
	CircuitBreakerStatus(ctx context.Context, routerID string) (*model.CircuitBreakerStatus, error)
	TroubleshootSession(ctx context.Context, id string) (*model.TroubleshootSession, error)
	DetectWanInterface(ctx context.Context, routerID string) (string, error)
	DetectGateway(ctx context.Context, routerID string) (*string, error)
	DetectIsp(ctx context.Context, routerID string) (*model.ISPInfo, error)
	DNSServers(ctx context.Context, deviceID string) (*model.DNSServers, error)
	AlertRules(ctx context.Context, deviceID *string) ([]*model.AlertRule, error)
	AlertRule(ctx context.Context, id string) (*model.AlertRule, error)
	Alerts(ctx context.Context, deviceID *string, severity *model.AlertSeverity, acknowledged *bool, limit *int, offset *int) (*model.AlertConnection, error)
	Resource(ctx context.Context, id string, routerID string, layers []model.ResourceLayer) (model.Resource, error)
	Resources(ctx context.Context, routerID string, category *model.ResourceCategory, typeArg *string, state *model.ResourceLifecycleState, pagination *model.PaginationInput) (*model.ResourceConnection, error)
	CompositeResource(ctx context.Context, id string, routerID string) (*model.CompositeResource, error)
	IPAddresses(ctx context.Context, routerID string, interfaceID *string) ([]*model.IPAddress, error)
	IPAddress(ctx context.Context, routerID string, id string) (*model.IPAddress, error)
	CheckIPConflict(ctx context.Context, routerID string, address string, interfaceID *string, excludeID *string) (*model.IPConflictResult, error)
	IPAddressDependencies(ctx context.Context, routerID string, id string) (*model.IPAddressDependencies, error)
	Vlans(ctx context.Context, routerID string, filter *model.VlanFilter) ([]*model.Vlan, error)
	Vlan(ctx context.Context, id string) (*model.Vlan, error)
	CheckVlanIDAvailable(ctx context.Context, routerID string, parentInterface string, vlanID int) (bool, error)
	VlanDependencies(ctx context.Context, id string) (*model.VlanDependencies, error)
	VlanTopology(ctx context.Context, routerID string, bridgeID string) (*model.VlanTopology, error)
	Routes(ctx context.Context, routerID string, table *string, typeArg *model.RouteType) ([]*model.Route, error)
	Route(ctx context.Context, routerID string, id string) (*model.Route, error)
	CheckGatewayReachability(ctx context.Context, routerID string, gateway model.IPv4) (*model.GatewayReachabilityResult, error)
	InterfaceStatsHistory(ctx context.Context, routerID string, interfaceID string, timeRange model.StatsTimeRangeInput, interval *model.Duration) (*model.InterfaceStatsHistory, error)
	Bridges(ctx context.Context, routerID string) ([]*model.Bridge, error)
	Bridge(ctx context.Context, uuid string) (*model.Bridge, error)
	BridgePorts(ctx context.Context, bridgeID string) ([]*model.BridgePort, error)
	BridgeVlans(ctx context.Context, bridgeID string) ([]*model.BridgeVlan, error)
	AvailableInterfacesForBridge(ctx context.Context, routerID string) ([]*model.Interface, error)
	WanInterfaces(ctx context.Context, routerID string) ([]*model.WANInterface, error)
	WanInterface(ctx context.Context, routerID string, id string) (*model.WANInterface, error)
	WanConnectionHistory(ctx context.Context, routerID string, wanInterfaceID string, pagination *model.PaginationInput) (*model.WANConnectionEventConnection, error)
}
type SubscriptionResolver interface {
	RouterStatusChanged(ctx context.Context, routerID *string) (<-chan *model.RouterStatusEvent, error)
	ResourceMetrics(ctx context.Context, deviceID string) (<-chan *model.ResourceMetrics, error)
	InterfaceTraffic(ctx context.Context, routerID string, interfaceID *string) (<-chan *model.InterfaceTrafficEvent, error)
	ResourceUpdated(ctx context.Context, resourceID *string) (<-chan *model.ResourceUpdatedEvent, error)
	ConfigApplyProgress(ctx context.Context, operationID string) (<-chan *model.ConfigProgress, error)
	InterfaceStatusChanged(ctx context.Context, routerID string, interfaceID *string) (<-chan *model.InterfaceStatusEvent, error)
	ConnectionHealth(ctx context.Context, routerID *string) (<-chan *model.HealthCheckResult, error)
	CircuitBreakerChanged(ctx context.Context, routerID string) (<-chan *model.CircuitBreakerEvent, error)
	ScanProgress(ctx context.Context, taskID string) (<-chan *model.ScanProgressEvent, error)
	ChangeSetProgress(ctx context.Context, changeSetID string) (<-chan *model.ChangeSetProgressEvent, error)
	ChangeSetStatusChanged(ctx context.Context, routerID string) (<-chan *model.ChangeSetStatusEvent, error)
	CircuitBreakerStateChanged(ctx context.Context, routerID *string) (<-chan *model.CircuitBreakerStatus, error)
	TroubleshootProgress(ctx context.Context, sessionID string) (<-chan *model.TroubleshootSession, error)
	TracerouteProgress(ctx context.Context, jobID string) (<-chan *model.TracerouteProgressEvent, error)
	AlertEvents(ctx context.Context, deviceID *string) (<-chan *model.AlertEvent, error)
	RouterAdded(ctx context.Context) (<-chan *model.RouterAddedEvent, error)
	ResourceRuntime(ctx context.Context, id string, routerID string) (<-chan *model.ResourceRuntimeEvent, error)
	ResourceStateChanged(ctx context.Context, id *string, routerID string) (<-chan *model.ResourceStateEvent, error)
	IPAddressChanged(ctx context.Context, routerID string) (<-chan *model.IPAddressChangeEvent, error)
	VlanChanged(ctx context.Context, routerID string) (<-chan *model.Vlan, error)
	InterfaceStatsUpdated(ctx context.Context, routerID string, interfaceID string, interval *model.Duration) (<-chan *model.InterfaceStats, error)
	BridgeStpStatusChanged(ctx context.Context, bridgeID string) (<-chan *model.BridgeStpStatus, error)
	BridgePortsChanged(ctx context.Context, bridgeID string) (<-chan []*model.BridgePort, error)
	WanStatusChanged(ctx context.Context, routerID string, wanInterfaceID *string) (<-chan *model.WANInterface, error)
	WanHealthChanged(ctx context.Context, routerID string, wanInterfaceID string) (<-chan *model.WANHealthStatus, error)
}

type executableSchema struct {
	schema     *ast.Schema
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	if e.schema != nil {
		return e.schema
	}
	return parsedSchema
}

func (e *executableSchema) Complexity(typeName, field string, childComplexity int, rawArgs map[string]interface{}) (int, bool) {
	ec := executionContext{nil, e, 0, 0, nil}
	_ = ec
	switch typeName + "." + field {

	case "AddChangeSetItemPayload.changeSet":
		if e.complexity.AddChangeSetItemPayload.ChangeSet == nil {
			break
		}

		return e.complexity.AddChangeSetItemPayload.ChangeSet(childComplexity), true

	case "AddChangeSetItemPayload.errors":
		if e.complexity.AddChangeSetItemPayload.Errors == nil {
			break
		}

		return e.complexity.AddChangeSetItemPayload.Errors(childComplexity), true

	case "AddChangeSetItemPayload.itemId":
		if e.complexity.AddChangeSetItemPayload.ItemID == nil {
			break
		}

		return e.complexity.AddChangeSetItemPayload.ItemID(childComplexity), true

	case "AddRouterPayload.connectionResult":
		if e.complexity.AddRouterPayload.ConnectionResult == nil {
			break
		}

		return e.complexity.AddRouterPayload.ConnectionResult(childComplexity), true

	case "AddRouterPayload.errors":
		if e.complexity.AddRouterPayload.Errors == nil {
			break
		}

		return e.complexity.AddRouterPayload.Errors(childComplexity), true

	case "AddRouterPayload.router":
		if e.complexity.AddRouterPayload.Router == nil {
			break
		}

		return e.complexity.AddRouterPayload.Router(childComplexity), true

	case "AddRouterPayload.validationErrors":
		if e.complexity.AddRouterPayload.ValidationErrors == nil {
			break
		}

		return e.complexity.AddRouterPayload.ValidationErrors(childComplexity), true

	case "AffectedResource.id":
		if e.complexity.AffectedResource.ID == nil {
			break
		}

		return e.complexity.AffectedResource.ID(childComplexity), true

	case "AffectedResource.impact":
		if e.complexity.AffectedResource.Impact == nil {
			break
		}

		return e.complexity.AffectedResource.Impact(childComplexity), true

	case "AffectedResource.name":
		if e.complexity.AffectedResource.Name == nil {
			break
		}

		return e.complexity.AffectedResource.Name(childComplexity), true

	case "AffectedResource.type":
		if e.complexity.AffectedResource.Type == nil {
			break
		}

		return e.complexity.AffectedResource.Type(childComplexity), true

	case "Alert.acknowledgedAt":
		if e.complexity.Alert.AcknowledgedAt == nil {
			break
		}

		return e.complexity.Alert.AcknowledgedAt(childComplexity), true

	case "Alert.acknowledgedBy":
		if e.complexity.Alert.AcknowledgedBy == nil {
			break
		}

		return e.complexity.Alert.AcknowledgedBy(childComplexity), true

	case "Alert.data":
		if e.complexity.Alert.Data == nil {
			break
		}

		return e.complexity.Alert.Data(childComplexity), true

	case "Alert.deliveryStatus":
		if e.complexity.Alert.DeliveryStatus == nil {
			break
		}

		return e.complexity.Alert.DeliveryStatus(childComplexity), true

	case "Alert.deviceId":
		if e.complexity.Alert.DeviceID == nil {
			break
		}

		return e.complexity.Alert.DeviceID(childComplexity), true

	case "Alert.eventType":
		if e.complexity.Alert.EventType == nil {
			break
		}

		return e.complexity.Alert.EventType(childComplexity), true

	case "Alert.id":
		if e.complexity.Alert.ID == nil {
			break
		}

		return e.complexity.Alert.ID(childComplexity), true

	case "Alert.message":
		if e.complexity.Alert.Message == nil {
			break
		}

		return e.complexity.Alert.Message(childComplexity), true

	case "Alert.rule":
		if e.complexity.Alert.Rule == nil {
			break
		}

		return e.complexity.Alert.Rule(childComplexity), true

	case "Alert.severity":
		if e.complexity.Alert.Severity == nil {
			break
		}

		return e.complexity.Alert.Severity(childComplexity), true

	case "Alert.title":
		if e.complexity.Alert.Title == nil {
			break
		}

		return e.complexity.Alert.Title(childComplexity), true

	case "Alert.triggeredAt":
		if e.complexity.Alert.TriggeredAt == nil {
			break
		}

		return e.complexity.Alert.TriggeredAt(childComplexity), true

	case "Alert.updatedAt":
		if e.complexity.Alert.UpdatedAt == nil {
			break
		}

		return e.complexity.Alert.UpdatedAt(childComplexity), true

	case "AlertCondition.field":
		if e.complexity.AlertCondition.Field == nil {
			break
		}

		return e.complexity.AlertCondition.Field(childComplexity), true

	case "AlertCondition.operator":
		if e.complexity.AlertCondition.Operator == nil {
			break
		}

		return e.complexity.AlertCondition.Operator(childComplexity), true

	case "AlertCondition.value":
		if e.complexity.AlertCondition.Value == nil {
			break
		}

		return e.complexity.AlertCondition.Value(childComplexity), true

	case "AlertConnection.edges":
		if e.complexity.AlertConnection.Edges == nil {
			break
		}

		return e.complexity.AlertConnection.Edges(childComplexity), true

	case "AlertConnection.pageInfo":
		if e.complexity.AlertConnection.PageInfo == nil {
			break
		}

		return e.complexity.AlertConnection.PageInfo(childComplexity), true

	case "AlertConnection.totalCount":
		if e.complexity.AlertConnection.TotalCount == nil {
			break
		}

		return e.complexity.AlertConnection.TotalCount(childComplexity), true

	case "AlertEdge.cursor":
		if e.complexity.AlertEdge.Cursor == nil {
			break
		}

		return e.complexity.AlertEdge.Cursor(childComplexity), true

	case "AlertEdge.node":
		if e.complexity.AlertEdge.Node == nil {
			break
		}

		return e.complexity.AlertEdge.Node(childComplexity), true

	case "AlertEvent.action":
		if e.complexity.AlertEvent.Action == nil {
			break
		}

		return e.complexity.AlertEvent.Action(childComplexity), true

	case "AlertEvent.alert":
		if e.complexity.AlertEvent.Alert == nil {
			break
		}

		return e.complexity.AlertEvent.Alert(childComplexity), true

	case "AlertPayload.alert":
		if e.complexity.AlertPayload.Alert == nil {
			break
		}

		return e.complexity.AlertPayload.Alert(childComplexity), true

	case "AlertPayload.errors":
		if e.complexity.AlertPayload.Errors == nil {
			break
		}

		return e.complexity.AlertPayload.Errors(childComplexity), true

	case "AlertRule.alerts":
		if e.complexity.AlertRule.Alerts == nil {
			break
		}

		args, err := ec.field_AlertRule_alerts_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.AlertRule.Alerts(childComplexity, args["acknowledged"].(*bool), args["limit"].(*int)), true

	case "AlertRule.channels":
		if e.complexity.AlertRule.Channels == nil {
			break
		}

		return e.complexity.AlertRule.Channels(childComplexity), true

	case "AlertRule.conditions":
		if e.complexity.AlertRule.Conditions == nil {
			break
		}

		return e.complexity.AlertRule.Conditions(childComplexity), true

	case "AlertRule.createdAt":
		if e.complexity.AlertRule.CreatedAt == nil {
			break
		}

		return e.complexity.AlertRule.CreatedAt(childComplexity), true

	case "AlertRule.description":
		if e.complexity.AlertRule.Description == nil {
			break
		}

		return e.complexity.AlertRule.Description(childComplexity), true

	case "AlertRule.deviceId":
		if e.complexity.AlertRule.DeviceID == nil {
			break
		}

		return e.complexity.AlertRule.DeviceID(childComplexity), true

	case "AlertRule.enabled":
		if e.complexity.AlertRule.Enabled == nil {
			break
		}

		return e.complexity.AlertRule.Enabled(childComplexity), true

	case "AlertRule.eventType":
		if e.complexity.AlertRule.EventType == nil {
			break
		}

		return e.complexity.AlertRule.EventType(childComplexity), true

	case "AlertRule.id":
		if e.complexity.AlertRule.ID == nil {
			break
		}

		return e.complexity.AlertRule.ID(childComplexity), true

	case "AlertRule.name":
		if e.complexity.AlertRule.Name == nil {
			break
		}

		return e.complexity.AlertRule.Name(childComplexity), true

	case "AlertRule.quietHours":
		if e.complexity.AlertRule.QuietHours == nil {
			break
		}

		return e.complexity.AlertRule.QuietHours(childComplexity), true

	case "AlertRule.severity":
		if e.complexity.AlertRule.Severity == nil {
			break
		}

		return e.complexity.AlertRule.Severity(childComplexity), true

	case "AlertRule.throttle":
		if e.complexity.AlertRule.Throttle == nil {
			break
		}

		return e.complexity.AlertRule.Throttle(childComplexity), true

	case "AlertRule.updatedAt":
		if e.complexity.AlertRule.UpdatedAt == nil {
			break
		}

		return e.complexity.AlertRule.UpdatedAt(childComplexity), true

	case "AlertRulePayload.alertRule":
		if e.complexity.AlertRulePayload.AlertRule == nil {
			break
		}

		return e.complexity.AlertRulePayload.AlertRule(childComplexity), true

	case "AlertRulePayload.errors":
		if e.complexity.AlertRulePayload.Errors == nil {
			break
		}

		return e.complexity.AlertRulePayload.Errors(childComplexity), true

	case "ApplyChangeSetPayload.changeSetId":
		if e.complexity.ApplyChangeSetPayload.ChangeSetID == nil {
			break
		}

		return e.complexity.ApplyChangeSetPayload.ChangeSetID(childComplexity), true

	case "ApplyChangeSetPayload.errors":
		if e.complexity.ApplyChangeSetPayload.Errors == nil {
			break
		}

		return e.complexity.ApplyChangeSetPayload.Errors(childComplexity), true

	case "ApplyChangeSetPayload.status":
		if e.complexity.ApplyChangeSetPayload.Status == nil {
			break
		}

		return e.complexity.ApplyChangeSetPayload.Status(childComplexity), true

	case "ApplyFixPayload.errors":
		if e.complexity.ApplyFixPayload.Errors == nil {
			break
		}

		return e.complexity.ApplyFixPayload.Errors(childComplexity), true

	case "ApplyFixPayload.message":
		if e.complexity.ApplyFixPayload.Message == nil {
			break
		}

		return e.complexity.ApplyFixPayload.Message(childComplexity), true

	case "ApplyFixPayload.status":
		if e.complexity.ApplyFixPayload.Status == nil {
			break
		}

		return e.complexity.ApplyFixPayload.Status(childComplexity), true

	case "ApplyFixPayload.success":
		if e.complexity.ApplyFixPayload.Success == nil {
			break
		}

		return e.complexity.ApplyFixPayload.Success(childComplexity), true

	case "ApplyResourcePayload.errors":
		if e.complexity.ApplyResourcePayload.Errors == nil {
			break
		}

		return e.complexity.ApplyResourcePayload.Errors(childComplexity), true

	case "ApplyResourcePayload.operationId":
		if e.complexity.ApplyResourcePayload.OperationID == nil {
			break
		}

		return e.complexity.ApplyResourcePayload.OperationID(childComplexity), true

	case "ApplyResourcePayload.resource":
		if e.complexity.ApplyResourcePayload.Resource == nil {
			break
		}

		return e.complexity.ApplyResourcePayload.Resource(childComplexity), true

	case "ArchiveResourcePayload.errors":
		if e.complexity.ArchiveResourcePayload.Errors == nil {
			break
		}

		return e.complexity.ArchiveResourcePayload.Errors(childComplexity), true

	case "ArchiveResourcePayload.success":
		if e.complexity.ArchiveResourcePayload.Success == nil {
			break
		}

		return e.complexity.ArchiveResourcePayload.Success(childComplexity), true

	case "AuthPayload.expiresAt":
		if e.complexity.AuthPayload.ExpiresAt == nil {
			break
		}

		return e.complexity.AuthPayload.ExpiresAt(childComplexity), true

	case "AuthPayload.token":
		if e.complexity.AuthPayload.Token == nil {
			break
		}

		return e.complexity.AuthPayload.Token(childComplexity), true

	case "AuthPayload.user":
		if e.complexity.AuthPayload.User == nil {
			break
		}

		return e.complexity.AuthPayload.User(childComplexity), true

	case "AuthStatus.error":
		if e.complexity.AuthStatus.Error == nil {
			break
		}

		return e.complexity.AuthStatus.Error(childComplexity), true

	case "AuthStatus.errorCode":
		if e.complexity.AuthStatus.ErrorCode == nil {
			break
		}

		return e.complexity.AuthStatus.ErrorCode(childComplexity), true

	case "AuthStatus.success":
		if e.complexity.AuthStatus.Success == nil {
			break
		}

		return e.complexity.AuthStatus.Success(childComplexity), true

	case "AuthStatus.tested":
		if e.complexity.AuthStatus.Tested == nil {
			break
		}

		return e.complexity.AuthStatus.Tested(childComplexity), true

	case "BandwidthDataPoint.bytesIn":
		if e.complexity.BandwidthDataPoint.BytesIn == nil {
			break
		}

		return e.complexity.BandwidthDataPoint.BytesIn(childComplexity), true

	case "BandwidthDataPoint.bytesOut":
		if e.complexity.BandwidthDataPoint.BytesOut == nil {
			break
		}

		return e.complexity.BandwidthDataPoint.BytesOut(childComplexity), true

	case "BandwidthDataPoint.periodSeconds":
		if e.complexity.BandwidthDataPoint.PeriodSeconds == nil {
			break
		}

		return e.complexity.BandwidthDataPoint.PeriodSeconds(childComplexity), true

	case "BandwidthDataPoint.timestamp":
		if e.complexity.BandwidthDataPoint.Timestamp == nil {
			break
		}

		return e.complexity.BandwidthDataPoint.Timestamp(childComplexity), true

	case "BatchInterfacePayload.errors":
		if e.complexity.BatchInterfacePayload.Errors == nil {
			break
		}

		return e.complexity.BatchInterfacePayload.Errors(childComplexity), true

	case "BatchInterfacePayload.failed":
		if e.complexity.BatchInterfacePayload.Failed == nil {
			break
		}

		return e.complexity.BatchInterfacePayload.Failed(childComplexity), true

	case "BatchInterfacePayload.succeeded":
		if e.complexity.BatchInterfacePayload.Succeeded == nil {
			break
		}

		return e.complexity.BatchInterfacePayload.Succeeded(childComplexity), true

	case "Bridge.comment":
		if e.complexity.Bridge.Comment == nil {
			break
		}

		return e.complexity.Bridge.Comment(childComplexity), true

	case "Bridge.dependentDhcpServers":
		if e.complexity.Bridge.DependentDhcpServers == nil {
			break
		}

		return e.complexity.Bridge.DependentDhcpServers(childComplexity), true

	case "Bridge.dependentRoutes":
		if e.complexity.Bridge.DependentRoutes == nil {
			break
		}

		return e.complexity.Bridge.DependentRoutes(childComplexity), true

	case "Bridge.disabled":
		if e.complexity.Bridge.Disabled == nil {
			break
		}

		return e.complexity.Bridge.Disabled(childComplexity), true

	case "Bridge.id":
		if e.complexity.Bridge.ID == nil {
			break
		}

		return e.complexity.Bridge.ID(childComplexity), true

	case "Bridge.ipAddresses":
		if e.complexity.Bridge.IPAddresses == nil {
			break
		}

		return e.complexity.Bridge.IPAddresses(childComplexity), true

	case "Bridge.macAddress":
		if e.complexity.Bridge.MacAddress == nil {
			break
		}

		return e.complexity.Bridge.MacAddress(childComplexity), true

	case "Bridge.mtu":
		if e.complexity.Bridge.Mtu == nil {
			break
		}

		return e.complexity.Bridge.Mtu(childComplexity), true

	case "Bridge.name":
		if e.complexity.Bridge.Name == nil {
			break
		}

		return e.complexity.Bridge.Name(childComplexity), true

	case "Bridge.ports":
		if e.complexity.Bridge.Ports == nil {
			break
		}

		return e.complexity.Bridge.Ports(childComplexity), true

	case "Bridge.priority":
		if e.complexity.Bridge.Priority == nil {
			break
		}

		return e.complexity.Bridge.Priority(childComplexity), true

	case "Bridge.protocol":
		if e.complexity.Bridge.Protocol == nil {
			break
		}

		return e.complexity.Bridge.Protocol(childComplexity), true

	case "Bridge.pvid":
		if e.complexity.Bridge.Pvid == nil {
			break
		}

		return e.complexity.Bridge.Pvid(childComplexity), true

	case "Bridge.running":
		if e.complexity.Bridge.Running == nil {
			break
		}

		return e.complexity.Bridge.Running(childComplexity), true

	case "Bridge.stpStatus":
		if e.complexity.Bridge.StpStatus == nil {
			break
		}

		return e.complexity.Bridge.StpStatus(childComplexity), true

	case "Bridge.vlanFiltering":
		if e.complexity.Bridge.VlanFiltering == nil {
			break
		}

		return e.complexity.Bridge.VlanFiltering(childComplexity), true

	case "Bridge.vlans":
		if e.complexity.Bridge.Vlans == nil {
			break
		}

		return e.complexity.Bridge.Vlans(childComplexity), true

	case "BridgeMutationResult.bridge":
		if e.complexity.BridgeMutationResult.Bridge == nil {
			break
		}

		return e.complexity.BridgeMutationResult.Bridge(childComplexity), true

	case "BridgeMutationResult.errors":
		if e.complexity.BridgeMutationResult.Errors == nil {
			break
		}

		return e.complexity.BridgeMutationResult.Errors(childComplexity), true

	case "BridgeMutationResult.operationId":
		if e.complexity.BridgeMutationResult.OperationID == nil {
			break
		}

		return e.complexity.BridgeMutationResult.OperationID(childComplexity), true

	case "BridgeMutationResult.previousState":
		if e.complexity.BridgeMutationResult.PreviousState == nil {
			break
		}

		return e.complexity.BridgeMutationResult.PreviousState(childComplexity), true

	case "BridgeMutationResult.success":
		if e.complexity.BridgeMutationResult.Success == nil {
			break
		}

		return e.complexity.BridgeMutationResult.Success(childComplexity), true

	case "BridgePort.bridge":
		if e.complexity.BridgePort.Bridge == nil {
			break
		}

		return e.complexity.BridgePort.Bridge(childComplexity), true

	case "BridgePort.edge":
		if e.complexity.BridgePort.Edge == nil {
			break
		}

		return e.complexity.BridgePort.Edge(childComplexity), true

	case "BridgePort.frameTypes":
		if e.complexity.BridgePort.FrameTypes == nil {
			break
		}

		return e.complexity.BridgePort.FrameTypes(childComplexity), true

	case "BridgePort.id":
		if e.complexity.BridgePort.ID == nil {
			break
		}

		return e.complexity.BridgePort.ID(childComplexity), true

	case "BridgePort.ingressFiltering":
		if e.complexity.BridgePort.IngressFiltering == nil {
			break
		}

		return e.complexity.BridgePort.IngressFiltering(childComplexity), true

	case "BridgePort.interface":
		if e.complexity.BridgePort.Interface == nil {
			break
		}

		return e.complexity.BridgePort.Interface(childComplexity), true

	case "BridgePort.pathCost":
		if e.complexity.BridgePort.PathCost == nil {
			break
		}

		return e.complexity.BridgePort.PathCost(childComplexity), true

	case "BridgePort.pvid":
		if e.complexity.BridgePort.Pvid == nil {
			break
		}

		return e.complexity.BridgePort.Pvid(childComplexity), true

	case "BridgePort.role":
		if e.complexity.BridgePort.Role == nil {
			break
		}

		return e.complexity.BridgePort.Role(childComplexity), true

	case "BridgePort.state":
		if e.complexity.BridgePort.State == nil {
			break
		}

		return e.complexity.BridgePort.State(childComplexity), true

	case "BridgePort.taggedVlans":
		if e.complexity.BridgePort.TaggedVlans == nil {
			break
		}

		return e.complexity.BridgePort.TaggedVlans(childComplexity), true

	case "BridgePort.untaggedVlans":
		if e.complexity.BridgePort.UntaggedVlans == nil {
			break
		}

		return e.complexity.BridgePort.UntaggedVlans(childComplexity), true

	case "BridgePortMutationResult.errors":
		if e.complexity.BridgePortMutationResult.Errors == nil {
			break
		}

		return e.complexity.BridgePortMutationResult.Errors(childComplexity), true

	case "BridgePortMutationResult.operationId":
		if e.complexity.BridgePortMutationResult.OperationID == nil {
			break
		}

		return e.complexity.BridgePortMutationResult.OperationID(childComplexity), true

	case "BridgePortMutationResult.port":
		if e.complexity.BridgePortMutationResult.Port == nil {
			break
		}

		return e.complexity.BridgePortMutationResult.Port(childComplexity), true

	case "BridgePortMutationResult.previousState":
		if e.complexity.BridgePortMutationResult.PreviousState == nil {
			break
		}

		return e.complexity.BridgePortMutationResult.PreviousState(childComplexity), true

	case "BridgePortMutationResult.success":
		if e.complexity.BridgePortMutationResult.Success == nil {
			break
		}

		return e.complexity.BridgePortMutationResult.Success(childComplexity), true

	case "BridgePortVlanConfig.frameTypes":
		if e.complexity.BridgePortVlanConfig.FrameTypes == nil {
			break
		}

		return e.complexity.BridgePortVlanConfig.FrameTypes(childComplexity), true

	case "BridgePortVlanConfig.mode":
		if e.complexity.BridgePortVlanConfig.Mode == nil {
			break
		}

		return e.complexity.BridgePortVlanConfig.Mode(childComplexity), true

	case "BridgePortVlanConfig.portId":
		if e.complexity.BridgePortVlanConfig.PortID == nil {
			break
		}

		return e.complexity.BridgePortVlanConfig.PortID(childComplexity), true

	case "BridgePortVlanConfig.pvid":
		if e.complexity.BridgePortVlanConfig.Pvid == nil {
			break
		}

		return e.complexity.BridgePortVlanConfig.Pvid(childComplexity), true

	case "BridgePortVlanConfig.taggedVlans":
		if e.complexity.BridgePortVlanConfig.TaggedVlans == nil {
			break
		}

		return e.complexity.BridgePortVlanConfig.TaggedVlans(childComplexity), true

	case "BridgePortVlanConfig.untaggedVlans":
		if e.complexity.BridgePortVlanConfig.UntaggedVlans == nil {
			break
		}

		return e.complexity.BridgePortVlanConfig.UntaggedVlans(childComplexity), true

	case "BridgeResource.category":
		if e.complexity.BridgeResource.Category == nil {
			break
		}

		return e.complexity.BridgeResource.Category(childComplexity), true

	case "BridgeResource.configuration":
		if e.complexity.BridgeResource.Configuration == nil {
			break
		}

		return e.complexity.BridgeResource.Configuration(childComplexity), true

	case "BridgeResource.deployment":
		if e.complexity.BridgeResource.Deployment == nil {
			break
		}

		return e.complexity.BridgeResource.Deployment(childComplexity), true

	case "BridgeResource.id":
		if e.complexity.BridgeResource.ID == nil {
			break
		}

		return e.complexity.BridgeResource.ID(childComplexity), true

	case "BridgeResource.metadata":
		if e.complexity.BridgeResource.Metadata == nil {
			break
		}

		return e.complexity.BridgeResource.Metadata(childComplexity), true

	case "BridgeResource.name":
		if e.complexity.BridgeResource.Name == nil {
			break
		}

		return e.complexity.BridgeResource.Name(childComplexity), true

	case "BridgeResource.platform":
		if e.complexity.BridgeResource.Platform == nil {
			break
		}

		return e.complexity.BridgeResource.Platform(childComplexity), true

	case "BridgeResource.ports":
		if e.complexity.BridgeResource.Ports == nil {
			break
		}

		return e.complexity.BridgeResource.Ports(childComplexity), true

	case "BridgeResource.protocolMode":
		if e.complexity.BridgeResource.ProtocolMode == nil {
			break
		}

		return e.complexity.BridgeResource.ProtocolMode(childComplexity), true

	case "BridgeResource.relationships":
		if e.complexity.BridgeResource.Relationships == nil {
			break
		}

		return e.complexity.BridgeResource.Relationships(childComplexity), true

	case "BridgeResource.runtime":
		if e.complexity.BridgeResource.Runtime == nil {
			break
		}

		return e.complexity.BridgeResource.Runtime(childComplexity), true

	case "BridgeResource.scopedId":
		if e.complexity.BridgeResource.ScopedID == nil {
			break
		}

		return e.complexity.BridgeResource.ScopedID(childComplexity), true

	case "BridgeResource.telemetry":
		if e.complexity.BridgeResource.Telemetry == nil {
			break
		}

		return e.complexity.BridgeResource.Telemetry(childComplexity), true

	case "BridgeResource.type":
		if e.complexity.BridgeResource.Type == nil {
			break
		}

		return e.complexity.BridgeResource.Type(childComplexity), true

	case "BridgeResource.validation":
		if e.complexity.BridgeResource.Validation == nil {
			break
		}

		return e.complexity.BridgeResource.Validation(childComplexity), true

	case "BridgeStpStatus.lastTopologyChange":
		if e.complexity.BridgeStpStatus.LastTopologyChange == nil {
			break
		}

		return e.complexity.BridgeStpStatus.LastTopologyChange(childComplexity), true

	case "BridgeStpStatus.rootBridge":
		if e.complexity.BridgeStpStatus.RootBridge == nil {
			break
		}

		return e.complexity.BridgeStpStatus.RootBridge(childComplexity), true

	case "BridgeStpStatus.rootBridgeId":
		if e.complexity.BridgeStpStatus.RootBridgeID == nil {
			break
		}

		return e.complexity.BridgeStpStatus.RootBridgeID(childComplexity), true

	case "BridgeStpStatus.rootPathCost":
		if e.complexity.BridgeStpStatus.RootPathCost == nil {
			break
		}

		return e.complexity.BridgeStpStatus.RootPathCost(childComplexity), true

	case "BridgeStpStatus.rootPort":
		if e.complexity.BridgeStpStatus.RootPort == nil {
			break
		}

		return e.complexity.BridgeStpStatus.RootPort(childComplexity), true

	case "BridgeStpStatus.topologyChangeCount":
		if e.complexity.BridgeStpStatus.TopologyChangeCount == nil {
			break
		}

		return e.complexity.BridgeStpStatus.TopologyChangeCount(childComplexity), true

	case "BridgeVlan.bridge":
		if e.complexity.BridgeVlan.Bridge == nil {
			break
		}

		return e.complexity.BridgeVlan.Bridge(childComplexity), true

	case "BridgeVlan.taggedPorts":
		if e.complexity.BridgeVlan.TaggedPorts == nil {
			break
		}

		return e.complexity.BridgeVlan.TaggedPorts(childComplexity), true

	case "BridgeVlan.uuid":
		if e.complexity.BridgeVlan.UUID == nil {
			break
		}

		return e.complexity.BridgeVlan.UUID(childComplexity), true

	case "BridgeVlan.untaggedPorts":
		if e.complexity.BridgeVlan.UntaggedPorts == nil {
			break
		}

		return e.complexity.BridgeVlan.UntaggedPorts(childComplexity), true

	case "BridgeVlan.vlanId":
		if e.complexity.BridgeVlan.VlanID == nil {
			break
		}

		return e.complexity.BridgeVlan.VlanID(childComplexity), true

	case "BridgeVlanMutationResult.errors":
		if e.complexity.BridgeVlanMutationResult.Errors == nil {
			break
		}

		return e.complexity.BridgeVlanMutationResult.Errors(childComplexity), true

	case "BridgeVlanMutationResult.success":
		if e.complexity.BridgeVlanMutationResult.Success == nil {
			break
		}

		return e.complexity.BridgeVlanMutationResult.Success(childComplexity), true

	case "BridgeVlanMutationResult.vlan":
		if e.complexity.BridgeVlanMutationResult.Vlan == nil {
			break
		}

		return e.complexity.BridgeVlanMutationResult.Vlan(childComplexity), true

	case "BulkAlertPayload.acknowledgedCount":
		if e.complexity.BulkAlertPayload.AcknowledgedCount == nil {
			break
		}

		return e.complexity.BulkAlertPayload.AcknowledgedCount(childComplexity), true

	case "BulkAlertPayload.errors":
		if e.complexity.BulkAlertPayload.Errors == nil {
			break
		}

		return e.complexity.BulkAlertPayload.Errors(childComplexity), true

	case "CPUMetrics.cores":
		if e.complexity.CPUMetrics.Cores == nil {
			break
		}

		return e.complexity.CPUMetrics.Cores(childComplexity), true

	case "CPUMetrics.frequency":
		if e.complexity.CPUMetrics.Frequency == nil {
			break
		}

		return e.complexity.CPUMetrics.Frequency(childComplexity), true

	case "CPUMetrics.perCore":
		if e.complexity.CPUMetrics.PerCore == nil {
			break
		}

		return e.complexity.CPUMetrics.PerCore(childComplexity), true

	case "CPUMetrics.usage":
		if e.complexity.CPUMetrics.Usage == nil {
			break
		}

		return e.complexity.CPUMetrics.Usage(childComplexity), true

	case "CancelChangeSetPayload.changeSet":
		if e.complexity.CancelChangeSetPayload.ChangeSet == nil {
			break
		}

		return e.complexity.CancelChangeSetPayload.ChangeSet(childComplexity), true

	case "CancelChangeSetPayload.errors":
		if e.complexity.CancelChangeSetPayload.Errors == nil {
			break
		}

		return e.complexity.CancelChangeSetPayload.Errors(childComplexity), true

	case "CancelChangeSetPayload.success":
		if e.complexity.CancelChangeSetPayload.Success == nil {
			break
		}

		return e.complexity.CancelChangeSetPayload.Success(childComplexity), true

	case "CancelScanPayload.errors":
		if e.complexity.CancelScanPayload.Errors == nil {
			break
		}

		return e.complexity.CancelScanPayload.Errors(childComplexity), true

	case "CancelScanPayload.task":
		if e.complexity.CancelScanPayload.Task == nil {
			break
		}

		return e.complexity.CancelScanPayload.Task(childComplexity), true

	case "CapabilityEntry.capability":
		if e.complexity.CapabilityEntry.Capability == nil {
			break
		}

		return e.complexity.CapabilityEntry.Capability(childComplexity), true

	case "CapabilityEntry.description":
		if e.complexity.CapabilityEntry.Description == nil {
			break
		}

		return e.complexity.CapabilityEntry.Description(childComplexity), true

	case "CapabilityEntry.guidance":
		if e.complexity.CapabilityEntry.Guidance == nil {
			break
		}

		return e.complexity.CapabilityEntry.Guidance(childComplexity), true

	case "CapabilityEntry.level":
		if e.complexity.CapabilityEntry.Level == nil {
			break
		}

		return e.complexity.CapabilityEntry.Level(childComplexity), true

	case "ChangeLogEntry.changeType":
		if e.complexity.ChangeLogEntry.ChangeType == nil {
			break
		}

		return e.complexity.ChangeLogEntry.ChangeType(childComplexity), true

	case "ChangeLogEntry.changedFields":
		if e.complexity.ChangeLogEntry.ChangedFields == nil {
			break
		}

		return e.complexity.ChangeLogEntry.ChangedFields(childComplexity), true

	case "ChangeLogEntry.summary":
		if e.complexity.ChangeLogEntry.Summary == nil {
			break
		}

		return e.complexity.ChangeLogEntry.Summary(childComplexity), true

	case "ChangeLogEntry.timestamp":
		if e.complexity.ChangeLogEntry.Timestamp == nil {
			break
		}

		return e.complexity.ChangeLogEntry.Timestamp(childComplexity), true

	case "ChangeLogEntry.user":
		if e.complexity.ChangeLogEntry.User == nil {
			break
		}

		return e.complexity.ChangeLogEntry.User(childComplexity), true

	case "ChangeSet.applyStartedAt":
		if e.complexity.ChangeSet.ApplyStartedAt == nil {
			break
		}

		return e.complexity.ChangeSet.ApplyStartedAt(childComplexity), true

	case "ChangeSet.completedAt":
		if e.complexity.ChangeSet.CompletedAt == nil {
			break
		}

		return e.complexity.ChangeSet.CompletedAt(childComplexity), true

	case "ChangeSet.createdAt":
		if e.complexity.ChangeSet.CreatedAt == nil {
			break
		}

		return e.complexity.ChangeSet.CreatedAt(childComplexity), true

	case "ChangeSet.createdBy":
		if e.complexity.ChangeSet.CreatedBy == nil {
			break
		}

		return e.complexity.ChangeSet.CreatedBy(childComplexity), true

	case "ChangeSet.description":
		if e.complexity.ChangeSet.Description == nil {
			break
		}

		return e.complexity.ChangeSet.Description(childComplexity), true

	case "ChangeSet.error":
		if e.complexity.ChangeSet.Error == nil {
			break
		}

		return e.complexity.ChangeSet.Error(childComplexity), true

	case "ChangeSet.id":
		if e.complexity.ChangeSet.ID == nil {
			break
		}

		return e.complexity.ChangeSet.ID(childComplexity), true

	case "ChangeSet.items":
		if e.complexity.ChangeSet.Items == nil {
			break
		}

		return e.complexity.ChangeSet.Items(childComplexity), true

	case "ChangeSet.name":
		if e.complexity.ChangeSet.Name == nil {
			break
		}

		return e.complexity.ChangeSet.Name(childComplexity), true

	case "ChangeSet.rollbackPlan":
		if e.complexity.ChangeSet.RollbackPlan == nil {
			break
		}

		return e.complexity.ChangeSet.RollbackPlan(childComplexity), true

	case "ChangeSet.routerId":
		if e.complexity.ChangeSet.RouterID == nil {
			break
		}

		return e.complexity.ChangeSet.RouterID(childComplexity), true

	case "ChangeSet.source":
		if e.complexity.ChangeSet.Source == nil {
			break
		}

		return e.complexity.ChangeSet.Source(childComplexity), true

	case "ChangeSet.status":
		if e.complexity.ChangeSet.Status == nil {
			break
		}

		return e.complexity.ChangeSet.Status(childComplexity), true

	case "ChangeSet.validation":
		if e.complexity.ChangeSet.Validation == nil {
			break
		}

		return e.complexity.ChangeSet.Validation(childComplexity), true

	case "ChangeSet.version":
		if e.complexity.ChangeSet.Version == nil {
			break
		}

		return e.complexity.ChangeSet.Version(childComplexity), true

	case "ChangeSetConflict.description":
		if e.complexity.ChangeSetConflict.Description == nil {
			break
		}

		return e.complexity.ChangeSetConflict.Description(childComplexity), true

	case "ChangeSetConflict.isExternalConflict":
		if e.complexity.ChangeSetConflict.IsExternalConflict == nil {
			break
		}

		return e.complexity.ChangeSetConflict.IsExternalConflict(childComplexity), true

	case "ChangeSetConflict.itemId1":
		if e.complexity.ChangeSetConflict.ItemID1 == nil {
			break
		}

		return e.complexity.ChangeSetConflict.ItemID1(childComplexity), true

	case "ChangeSetConflict.itemId2OrResourceUuid":
		if e.complexity.ChangeSetConflict.ItemID2OrResourceUUID == nil {
			break
		}

		return e.complexity.ChangeSetConflict.ItemID2OrResourceUUID(childComplexity), true

	case "ChangeSetConflict.resolution":
		if e.complexity.ChangeSetConflict.Resolution == nil {
			break
		}

		return e.complexity.ChangeSetConflict.Resolution(childComplexity), true

	case "ChangeSetError.code":
		if e.complexity.ChangeSetError.Code == nil {
			break
		}

		return e.complexity.ChangeSetError.Code(childComplexity), true

	case "ChangeSetError.failedItemId":
		if e.complexity.ChangeSetError.FailedItemID == nil {
			break
		}

		return e.complexity.ChangeSetError.FailedItemID(childComplexity), true

	case "ChangeSetError.failedRollbackItemIds":
		if e.complexity.ChangeSetError.FailedRollbackItemIds == nil {
			break
		}

		return e.complexity.ChangeSetError.FailedRollbackItemIds(childComplexity), true

	case "ChangeSetError.message":
		if e.complexity.ChangeSetError.Message == nil {
			break
		}

		return e.complexity.ChangeSetError.Message(childComplexity), true

	case "ChangeSetError.partiallyAppliedItemIds":
		if e.complexity.ChangeSetError.PartiallyAppliedItemIds == nil {
			break
		}

		return e.complexity.ChangeSetError.PartiallyAppliedItemIds(childComplexity), true

	case "ChangeSetError.requiresManualIntervention":
		if e.complexity.ChangeSetError.RequiresManualIntervention == nil {
			break
		}

		return e.complexity.ChangeSetError.RequiresManualIntervention(childComplexity), true

	case "ChangeSetItem.applyCompletedAt":
		if e.complexity.ChangeSetItem.ApplyCompletedAt == nil {
			break
		}

		return e.complexity.ChangeSetItem.ApplyCompletedAt(childComplexity), true

	case "ChangeSetItem.applyOrder":
		if e.complexity.ChangeSetItem.ApplyOrder == nil {
			break
		}

		return e.complexity.ChangeSetItem.ApplyOrder(childComplexity), true

	case "ChangeSetItem.applyStartedAt":
		if e.complexity.ChangeSetItem.ApplyStartedAt == nil {
			break
		}

		return e.complexity.ChangeSetItem.ApplyStartedAt(childComplexity), true

	case "ChangeSetItem.configuration":
		if e.complexity.ChangeSetItem.Configuration == nil {
			break
		}

		return e.complexity.ChangeSetItem.Configuration(childComplexity), true

	case "ChangeSetItem.dependencies":
		if e.complexity.ChangeSetItem.Dependencies == nil {
			break
		}

		return e.complexity.ChangeSetItem.Dependencies(childComplexity), true

	case "ChangeSetItem.description":
		if e.complexity.ChangeSetItem.Description == nil {
			break
		}

		return e.complexity.ChangeSetItem.Description(childComplexity), true

	case "ChangeSetItem.error":
		if e.complexity.ChangeSetItem.Error == nil {
			break
		}

		return e.complexity.ChangeSetItem.Error(childComplexity), true

	case "ChangeSetItem.id":
		if e.complexity.ChangeSetItem.ID == nil {
			break
		}

		return e.complexity.ChangeSetItem.ID(childComplexity), true

	case "ChangeSetItem.name":
		if e.complexity.ChangeSetItem.Name == nil {
			break
		}

		return e.complexity.ChangeSetItem.Name(childComplexity), true

	case "ChangeSetItem.operation":
		if e.complexity.ChangeSetItem.Operation == nil {
			break
		}

		return e.complexity.ChangeSetItem.Operation(childComplexity), true

	case "ChangeSetItem.previousState":
		if e.complexity.ChangeSetItem.PreviousState == nil {
			break
		}

		return e.complexity.ChangeSetItem.PreviousState(childComplexity), true

	case "ChangeSetItem.resourceCategory":
		if e.complexity.ChangeSetItem.ResourceCategory == nil {
			break
		}

		return e.complexity.ChangeSetItem.ResourceCategory(childComplexity), true

	case "ChangeSetItem.resourceType":
		if e.complexity.ChangeSetItem.ResourceType == nil {
			break
		}

		return e.complexity.ChangeSetItem.ResourceType(childComplexity), true

	case "ChangeSetItem.resourceUuid":
		if e.complexity.ChangeSetItem.ResourceUUID == nil {
			break
		}

		return e.complexity.ChangeSetItem.ResourceUUID(childComplexity), true

	case "ChangeSetItem.status":
		if e.complexity.ChangeSetItem.Status == nil {
			break
		}

		return e.complexity.ChangeSetItem.Status(childComplexity), true

	case "ChangeSetProgressEvent.appliedCount":
		if e.complexity.ChangeSetProgressEvent.AppliedCount == nil {
			break
		}

		return e.complexity.ChangeSetProgressEvent.AppliedCount(childComplexity), true

	case "ChangeSetProgressEvent.changeSetId":
		if e.complexity.ChangeSetProgressEvent.ChangeSetID == nil {
			break
		}

		return e.complexity.ChangeSetProgressEvent.ChangeSetID(childComplexity), true

	case "ChangeSetProgressEvent.currentItem":
		if e.complexity.ChangeSetProgressEvent.CurrentItem == nil {
			break
		}

		return e.complexity.ChangeSetProgressEvent.CurrentItem(childComplexity), true

	case "ChangeSetProgressEvent.error":
		if e.complexity.ChangeSetProgressEvent.Error == nil {
			break
		}

		return e.complexity.ChangeSetProgressEvent.Error(childComplexity), true

	case "ChangeSetProgressEvent.estimatedRemainingMs":
		if e.complexity.ChangeSetProgressEvent.EstimatedRemainingMs == nil {
			break
		}

		return e.complexity.ChangeSetProgressEvent.EstimatedRemainingMs(childComplexity), true

	case "ChangeSetProgressEvent.progressPercent":
		if e.complexity.ChangeSetProgressEvent.ProgressPercent == nil {
			break
		}

		return e.complexity.ChangeSetProgressEvent.ProgressPercent(childComplexity), true

	case "ChangeSetProgressEvent.status":
		if e.complexity.ChangeSetProgressEvent.Status == nil {
			break
		}

		return e.complexity.ChangeSetProgressEvent.Status(childComplexity), true

	case "ChangeSetProgressEvent.timestamp":
		if e.complexity.ChangeSetProgressEvent.Timestamp == nil {
			break
		}

		return e.complexity.ChangeSetProgressEvent.Timestamp(childComplexity), true

	case "ChangeSetProgressEvent.totalCount":
		if e.complexity.ChangeSetProgressEvent.TotalCount == nil {
			break
		}

		return e.complexity.ChangeSetProgressEvent.TotalCount(childComplexity), true

	case "ChangeSetStatusEvent.changeSetId":
		if e.complexity.ChangeSetStatusEvent.ChangeSetID == nil {
			break
		}

		return e.complexity.ChangeSetStatusEvent.ChangeSetID(childComplexity), true

	case "ChangeSetStatusEvent.error":
		if e.complexity.ChangeSetStatusEvent.Error == nil {
			break
		}

		return e.complexity.ChangeSetStatusEvent.Error(childComplexity), true

	case "ChangeSetStatusEvent.newStatus":
		if e.complexity.ChangeSetStatusEvent.NewStatus == nil {
			break
		}

		return e.complexity.ChangeSetStatusEvent.NewStatus(childComplexity), true

	case "ChangeSetStatusEvent.previousStatus":
		if e.complexity.ChangeSetStatusEvent.PreviousStatus == nil {
			break
		}

		return e.complexity.ChangeSetStatusEvent.PreviousStatus(childComplexity), true

	case "ChangeSetStatusEvent.timestamp":
		if e.complexity.ChangeSetStatusEvent.Timestamp == nil {
			break
		}

		return e.complexity.ChangeSetStatusEvent.Timestamp(childComplexity), true

	case "ChangeSetSummary.createdAt":
		if e.complexity.ChangeSetSummary.CreatedAt == nil {
			break
		}

		return e.complexity.ChangeSetSummary.CreatedAt(childComplexity), true

	case "ChangeSetSummary.hasErrors":
		if e.complexity.ChangeSetSummary.HasErrors == nil {
			break
		}

		return e.complexity.ChangeSetSummary.HasErrors(childComplexity), true

	case "ChangeSetSummary.hasWarnings":
		if e.complexity.ChangeSetSummary.HasWarnings == nil {
			break
		}

		return e.complexity.ChangeSetSummary.HasWarnings(childComplexity), true

	case "ChangeSetSummary.id":
		if e.complexity.ChangeSetSummary.ID == nil {
			break
		}

		return e.complexity.ChangeSetSummary.ID(childComplexity), true

	case "ChangeSetSummary.name":
		if e.complexity.ChangeSetSummary.Name == nil {
			break
		}

		return e.complexity.ChangeSetSummary.Name(childComplexity), true

	case "ChangeSetSummary.operationCounts":
		if e.complexity.ChangeSetSummary.OperationCounts == nil {
			break
		}

		return e.complexity.ChangeSetSummary.OperationCounts(childComplexity), true

	case "ChangeSetSummary.status":
		if e.complexity.ChangeSetSummary.Status == nil {
			break
		}

		return e.complexity.ChangeSetSummary.Status(childComplexity), true

	case "ChangeSetSummary.totalItems":
		if e.complexity.ChangeSetSummary.TotalItems == nil {
			break
		}

		return e.complexity.ChangeSetSummary.TotalItems(childComplexity), true

	case "ChangeSetValidationError.code":
		if e.complexity.ChangeSetValidationError.Code == nil {
			break
		}

		return e.complexity.ChangeSetValidationError.Code(childComplexity), true

	case "ChangeSetValidationError.field":
		if e.complexity.ChangeSetValidationError.Field == nil {
			break
		}

		return e.complexity.ChangeSetValidationError.Field(childComplexity), true

	case "ChangeSetValidationError.itemId":
		if e.complexity.ChangeSetValidationError.ItemID == nil {
			break
		}

		return e.complexity.ChangeSetValidationError.ItemID(childComplexity), true

	case "ChangeSetValidationError.message":
		if e.complexity.ChangeSetValidationError.Message == nil {
			break
		}

		return e.complexity.ChangeSetValidationError.Message(childComplexity), true

	case "ChangeSetValidationError.severity":
		if e.complexity.ChangeSetValidationError.Severity == nil {
			break
		}

		return e.complexity.ChangeSetValidationError.Severity(childComplexity), true

	case "ChangeSetValidationResult.canApply":
		if e.complexity.ChangeSetValidationResult.CanApply == nil {
			break
		}

		return e.complexity.ChangeSetValidationResult.CanApply(childComplexity), true

	case "ChangeSetValidationResult.circularDependencies":
		if e.complexity.ChangeSetValidationResult.CircularDependencies == nil {
			break
		}

		return e.complexity.ChangeSetValidationResult.CircularDependencies(childComplexity), true

	case "ChangeSetValidationResult.conflicts":
		if e.complexity.ChangeSetValidationResult.Conflicts == nil {
			break
		}

		return e.complexity.ChangeSetValidationResult.Conflicts(childComplexity), true

	case "ChangeSetValidationResult.errors":
		if e.complexity.ChangeSetValidationResult.Errors == nil {
			break
		}

		return e.complexity.ChangeSetValidationResult.Errors(childComplexity), true

	case "ChangeSetValidationResult.missingDependencies":
		if e.complexity.ChangeSetValidationResult.MissingDependencies == nil {
			break
		}

		return e.complexity.ChangeSetValidationResult.MissingDependencies(childComplexity), true

	case "ChangeSetValidationResult.warnings":
		if e.complexity.ChangeSetValidationResult.Warnings == nil {
			break
		}

		return e.complexity.ChangeSetValidationResult.Warnings(childComplexity), true

	case "CircuitBreakerEvent.consecutiveFailures":
		if e.complexity.CircuitBreakerEvent.ConsecutiveFailures == nil {
			break
		}

		return e.complexity.CircuitBreakerEvent.ConsecutiveFailures(childComplexity), true

	case "CircuitBreakerEvent.newState":
		if e.complexity.CircuitBreakerEvent.NewState == nil {
			break
		}

		return e.complexity.CircuitBreakerEvent.NewState(childComplexity), true

	case "CircuitBreakerEvent.previousState":
		if e.complexity.CircuitBreakerEvent.PreviousState == nil {
			break
		}

		return e.complexity.CircuitBreakerEvent.PreviousState(childComplexity), true

	case "CircuitBreakerEvent.routerId":
		if e.complexity.CircuitBreakerEvent.RouterID == nil {
			break
		}

		return e.complexity.CircuitBreakerEvent.RouterID(childComplexity), true

	case "CircuitBreakerEvent.timestamp":
		if e.complexity.CircuitBreakerEvent.Timestamp == nil {
			break
		}

		return e.complexity.CircuitBreakerEvent.Timestamp(childComplexity), true

	case "CircuitBreakerStatus.cooldownRemainingSeconds":
		if e.complexity.CircuitBreakerStatus.CooldownRemainingSeconds == nil {
			break
		}

		return e.complexity.CircuitBreakerStatus.CooldownRemainingSeconds(childComplexity), true

	case "CircuitBreakerStatus.failureCount":
		if e.complexity.CircuitBreakerStatus.FailureCount == nil {
			break
		}

		return e.complexity.CircuitBreakerStatus.FailureCount(childComplexity), true

	case "CircuitBreakerStatus.failureThreshold":
		if e.complexity.CircuitBreakerStatus.FailureThreshold == nil {
			break
		}

		return e.complexity.CircuitBreakerStatus.FailureThreshold(childComplexity), true

	case "CircuitBreakerStatus.lastFailureAt":
		if e.complexity.CircuitBreakerStatus.LastFailureAt == nil {
			break
		}

		return e.complexity.CircuitBreakerStatus.LastFailureAt(childComplexity), true

	case "CircuitBreakerStatus.lastSuccessAt":
		if e.complexity.CircuitBreakerStatus.LastSuccessAt == nil {
			break
		}

		return e.complexity.CircuitBreakerStatus.LastSuccessAt(childComplexity), true

	case "CircuitBreakerStatus.routerId":
		if e.complexity.CircuitBreakerStatus.RouterID == nil {
			break
		}

		return e.complexity.CircuitBreakerStatus.RouterID(childComplexity), true

	case "CircuitBreakerStatus.state":
		if e.complexity.CircuitBreakerStatus.State == nil {
			break
		}

		return e.complexity.CircuitBreakerStatus.State(childComplexity), true

	case "CompositeResource.children":
		if e.complexity.CompositeResource.Children == nil {
			break
		}

		return e.complexity.CompositeResource.Children(childComplexity), true

	case "CompositeResource.relationships":
		if e.complexity.CompositeResource.Relationships == nil {
			break
		}

		return e.complexity.CompositeResource.Relationships(childComplexity), true

	case "CompositeResource.root":
		if e.complexity.CompositeResource.Root == nil {
			break
		}

		return e.complexity.CompositeResource.Root(childComplexity), true

	case "ConfigPreview.affectedResources":
		if e.complexity.ConfigPreview.AffectedResources == nil {
			break
		}

		return e.complexity.ConfigPreview.AffectedResources(childComplexity), true

	case "ConfigPreview.commands":
		if e.complexity.ConfigPreview.Commands == nil {
			break
		}

		return e.complexity.ConfigPreview.Commands(childComplexity), true

	case "ConfigPreview.warnings":
		if e.complexity.ConfigPreview.Warnings == nil {
			break
		}

		return e.complexity.ConfigPreview.Warnings(childComplexity), true

	case "ConfigProgress.currentStep":
		if e.complexity.ConfigProgress.CurrentStep == nil {
			break
		}

		return e.complexity.ConfigProgress.CurrentStep(childComplexity), true

	case "ConfigProgress.message":
		if e.complexity.ConfigProgress.Message == nil {
			break
		}

		return e.complexity.ConfigProgress.Message(childComplexity), true

	case "ConfigProgress.operationId":
		if e.complexity.ConfigProgress.OperationID == nil {
			break
		}

		return e.complexity.ConfigProgress.OperationID(childComplexity), true

	case "ConfigProgress.percentage":
		if e.complexity.ConfigProgress.Percentage == nil {
			break
		}

		return e.complexity.ConfigProgress.Percentage(childComplexity), true

	case "ConfigProgress.status":
		if e.complexity.ConfigProgress.Status == nil {
			break
		}

		return e.complexity.ConfigProgress.Status(childComplexity), true

	case "ConfigProgress.timestamp":
		if e.complexity.ConfigProgress.Timestamp == nil {
			break
		}

		return e.complexity.ConfigProgress.Timestamp(childComplexity), true

	case "ConfigProgress.totalSteps":
		if e.complexity.ConfigProgress.TotalSteps == nil {
			break
		}

		return e.complexity.ConfigProgress.TotalSteps(childComplexity), true

	case "ConnectRouterPayload.errors":
		if e.complexity.ConnectRouterPayload.Errors == nil {
			break
		}

		return e.complexity.ConnectRouterPayload.Errors(childComplexity), true

	case "ConnectRouterPayload.router":
		if e.complexity.ConnectRouterPayload.Router == nil {
			break
		}

		return e.complexity.ConnectRouterPayload.Router(childComplexity), true

	case "ConnectionAttempt.endedAt":
		if e.complexity.ConnectionAttempt.EndedAt == nil {
			break
		}

		return e.complexity.ConnectionAttempt.EndedAt(childComplexity), true

	case "ConnectionAttempt.errorCategory":
		if e.complexity.ConnectionAttempt.ErrorCategory == nil {
			break
		}

		return e.complexity.ConnectionAttempt.ErrorCategory(childComplexity), true

	case "ConnectionAttempt.errorCode":
		if e.complexity.ConnectionAttempt.ErrorCode == nil {
			break
		}

		return e.complexity.ConnectionAttempt.ErrorCode(childComplexity), true

	case "ConnectionAttempt.errorMessage":
		if e.complexity.ConnectionAttempt.ErrorMessage == nil {
			break
		}

		return e.complexity.ConnectionAttempt.ErrorMessage(childComplexity), true

	case "ConnectionAttempt.protocol":
		if e.complexity.ConnectionAttempt.Protocol == nil {
			break
		}

		return e.complexity.ConnectionAttempt.Protocol(childComplexity), true

	case "ConnectionAttempt.startedAt":
		if e.complexity.ConnectionAttempt.StartedAt == nil {
			break
		}

		return e.complexity.ConnectionAttempt.StartedAt(childComplexity), true

	case "ConnectionAttempt.success":
		if e.complexity.ConnectionAttempt.Success == nil {
			break
		}

		return e.complexity.ConnectionAttempt.Success(childComplexity), true

	case "ConnectionDetails.circuitBreakerState":
		if e.complexity.ConnectionDetails.CircuitBreakerState == nil {
			break
		}

		return e.complexity.ConnectionDetails.CircuitBreakerState(childComplexity), true

	case "ConnectionDetails.connectedAt":
		if e.complexity.ConnectionDetails.ConnectedAt == nil {
			break
		}

		return e.complexity.ConnectionDetails.ConnectedAt(childComplexity), true

	case "ConnectionDetails.disconnectReason":
		if e.complexity.ConnectionDetails.DisconnectReason == nil {
			break
		}

		return e.complexity.ConnectionDetails.DisconnectReason(childComplexity), true

	case "ConnectionDetails.disconnectedAt":
		if e.complexity.ConnectionDetails.DisconnectedAt == nil {
			break
		}

		return e.complexity.ConnectionDetails.DisconnectedAt(childComplexity), true

	case "ConnectionDetails.healthChecksFailed":
		if e.complexity.ConnectionDetails.HealthChecksFailed == nil {
			break
		}

		return e.complexity.ConnectionDetails.HealthChecksFailed(childComplexity), true

	case "ConnectionDetails.healthChecksPassed":
		if e.complexity.ConnectionDetails.HealthChecksPassed == nil {
			break
		}

		return e.complexity.ConnectionDetails.HealthChecksPassed(childComplexity), true

	case "ConnectionDetails.isLegacyProtocol":
		if e.complexity.ConnectionDetails.IsLegacyProtocol == nil {
			break
		}

		return e.complexity.ConnectionDetails.IsLegacyProtocol(childComplexity), true

	case "ConnectionDetails.lastError":
		if e.complexity.ConnectionDetails.LastError == nil {
			break
		}

		return e.complexity.ConnectionDetails.LastError(childComplexity), true

	case "ConnectionDetails.lastErrorTime":
		if e.complexity.ConnectionDetails.LastErrorTime == nil {
			break
		}

		return e.complexity.ConnectionDetails.LastErrorTime(childComplexity), true

	case "ConnectionDetails.lastHealthCheck":
		if e.complexity.ConnectionDetails.LastHealthCheck == nil {
			break
		}

		return e.complexity.ConnectionDetails.LastHealthCheck(childComplexity), true

	case "ConnectionDetails.nextReconnectAt":
		if e.complexity.ConnectionDetails.NextReconnectAt == nil {
			break
		}

		return e.complexity.ConnectionDetails.NextReconnectAt(childComplexity), true

	case "ConnectionDetails.preferredProtocol":
		if e.complexity.ConnectionDetails.PreferredProtocol == nil {
			break
		}

		return e.complexity.ConnectionDetails.PreferredProtocol(childComplexity), true

	case "ConnectionDetails.protocol":
		if e.complexity.ConnectionDetails.Protocol == nil {
			break
		}

		return e.complexity.ConnectionDetails.Protocol(childComplexity), true

	case "ConnectionDetails.reconnectAttempts":
		if e.complexity.ConnectionDetails.ReconnectAttempts == nil {
			break
		}

		return e.complexity.ConnectionDetails.ReconnectAttempts(childComplexity), true

	case "ConnectionDetails.securityWarning":
		if e.complexity.ConnectionDetails.SecurityWarning == nil {
			break
		}

		return e.complexity.ConnectionDetails.SecurityWarning(childComplexity), true

	case "ConnectionDetails.state":
		if e.complexity.ConnectionDetails.State == nil {
			break
		}

		return e.complexity.ConnectionDetails.State(childComplexity), true

	case "ConnectionDetails.upgradeRecommendation":
		if e.complexity.ConnectionDetails.UpgradeRecommendation == nil {
			break
		}

		return e.complexity.ConnectionDetails.UpgradeRecommendation(childComplexity), true

	case "ConnectionDetails.uptime":
		if e.complexity.ConnectionDetails.Uptime == nil {
			break
		}

		return e.complexity.ConnectionDetails.Uptime(childComplexity), true

	case "ConnectionDetails.version":
		if e.complexity.ConnectionDetails.Version == nil {
			break
		}

		return e.complexity.ConnectionDetails.Version(childComplexity), true

	case "ConnectionError.code":
		if e.complexity.ConnectionError.Code == nil {
			break
		}

		return e.complexity.ConnectionError.Code(childComplexity), true

	case "ConnectionError.message":
		if e.complexity.ConnectionError.Message == nil {
			break
		}

		return e.complexity.ConnectionError.Message(childComplexity), true

	case "ConnectionError.protocol":
		if e.complexity.ConnectionError.Protocol == nil {
			break
		}

		return e.complexity.ConnectionError.Protocol(childComplexity), true

	case "ConnectionError.retryable":
		if e.complexity.ConnectionError.Retryable == nil {
			break
		}

		return e.complexity.ConnectionError.Retryable(childComplexity), true

	case "ConnectionError.suggestedAction":
		if e.complexity.ConnectionError.SuggestedAction == nil {
			break
		}

		return e.complexity.ConnectionError.SuggestedAction(childComplexity), true

	case "ConnectionError.timeoutMs":
		if e.complexity.ConnectionError.TimeoutMs == nil {
			break
		}

		return e.complexity.ConnectionError.TimeoutMs(childComplexity), true

	case "ConnectionStats.connected":
		if e.complexity.ConnectionStats.Connected == nil {
			break
		}

		return e.complexity.ConnectionStats.Connected(childComplexity), true

	case "ConnectionStats.connecting":
		if e.complexity.ConnectionStats.Connecting == nil {
			break
		}

		return e.complexity.ConnectionStats.Connecting(childComplexity), true

	case "ConnectionStats.disconnected":
		if e.complexity.ConnectionStats.Disconnected == nil {
			break
		}

		return e.complexity.ConnectionStats.Disconnected(childComplexity), true

	case "ConnectionStats.error":
		if e.complexity.ConnectionStats.Error == nil {
			break
		}

		return e.complexity.ConnectionStats.Error(childComplexity), true

	case "ConnectionStats.reconnecting":
		if e.complexity.ConnectionStats.Reconnecting == nil {
			break
		}

		return e.complexity.ConnectionStats.Reconnecting(childComplexity), true

	case "ConnectionStats.totalConnections":
		if e.complexity.ConnectionStats.TotalConnections == nil {
			break
		}

		return e.complexity.ConnectionStats.TotalConnections(childComplexity), true

	case "ConnectionTestResult.architecture":
		if e.complexity.ConnectionTestResult.Architecture == nil {
			break
		}

		return e.complexity.ConnectionTestResult.Architecture(childComplexity), true

	case "ConnectionTestResult.boardName":
		if e.complexity.ConnectionTestResult.BoardName == nil {
			break
		}

		return e.complexity.ConnectionTestResult.BoardName(childComplexity), true

	case "ConnectionTestResult.error":
		if e.complexity.ConnectionTestResult.Error == nil {
			break
		}

		return e.complexity.ConnectionTestResult.Error(childComplexity), true

	case "ConnectionTestResult.protocolUsed":
		if e.complexity.ConnectionTestResult.ProtocolUsed == nil {
			break
		}

		return e.complexity.ConnectionTestResult.ProtocolUsed(childComplexity), true

	case "ConnectionTestResult.protocolsAttempted":
		if e.complexity.ConnectionTestResult.ProtocolsAttempted == nil {
			break
		}

		return e.complexity.ConnectionTestResult.ProtocolsAttempted(childComplexity), true

	case "ConnectionTestResult.responseTimeMs":
		if e.complexity.ConnectionTestResult.ResponseTimeMs == nil {
			break
		}

		return e.complexity.ConnectionTestResult.ResponseTimeMs(childComplexity), true

	case "ConnectionTestResult.routerModel":
		if e.complexity.ConnectionTestResult.RouterModel == nil {
			break
		}

		return e.complexity.ConnectionTestResult.RouterModel(childComplexity), true

	case "ConnectionTestResult.routerVersion":
		if e.complexity.ConnectionTestResult.RouterVersion == nil {
			break
		}

		return e.complexity.ConnectionTestResult.RouterVersion(childComplexity), true

	case "ConnectionTestResult.success":
		if e.complexity.ConnectionTestResult.Success == nil {
			break
		}

		return e.complexity.ConnectionTestResult.Success(childComplexity), true

	case "ConnectionTestResult.supportsContainers":
		if e.complexity.ConnectionTestResult.SupportsContainers == nil {
			break
		}

		return e.complexity.ConnectionTestResult.SupportsContainers(childComplexity), true

	case "ConnectionTestResult.uptime":
		if e.complexity.ConnectionTestResult.Uptime == nil {
			break
		}

		return e.complexity.ConnectionTestResult.Uptime(childComplexity), true

	case "ContainerInfo.enabled":
		if e.complexity.ContainerInfo.Enabled == nil {
			break
		}

		return e.complexity.ContainerInfo.Enabled(childComplexity), true

	case "ContainerInfo.maxContainers":
		if e.complexity.ContainerInfo.MaxContainers == nil {
			break
		}

		return e.complexity.ContainerInfo.MaxContainers(childComplexity), true

	case "ContainerInfo.packageInstalled":
		if e.complexity.ContainerInfo.PackageInstalled == nil {
			break
		}

		return e.complexity.ContainerInfo.PackageInstalled(childComplexity), true

	case "ContainerInfo.registryConfigured":
		if e.complexity.ContainerInfo.RegistryConfigured == nil {
			break
		}

		return e.complexity.ContainerInfo.RegistryConfigured(childComplexity), true

	case "ContainerInfo.storageAvailable":
		if e.complexity.ContainerInfo.StorageAvailable == nil {
			break
		}

		return e.complexity.ContainerInfo.StorageAvailable(childComplexity), true

	case "ContainerInfo.supportsNetworkNamespace":
		if e.complexity.ContainerInfo.SupportsNetworkNamespace == nil {
			break
		}

		return e.complexity.ContainerInfo.SupportsNetworkNamespace(childComplexity), true

	case "CreateChangeSetPayload.changeSet":
		if e.complexity.CreateChangeSetPayload.ChangeSet == nil {
			break
		}

		return e.complexity.CreateChangeSetPayload.ChangeSet(childComplexity), true

	case "CreateChangeSetPayload.errors":
		if e.complexity.CreateChangeSetPayload.Errors == nil {
			break
		}

		return e.complexity.CreateChangeSetPayload.Errors(childComplexity), true

	case "CreateResourcePayload.errors":
		if e.complexity.CreateResourcePayload.Errors == nil {
			break
		}

		return e.complexity.CreateResourcePayload.Errors(childComplexity), true

	case "CreateResourcePayload.resource":
		if e.complexity.CreateResourcePayload.Resource == nil {
			break
		}

		return e.complexity.CreateResourcePayload.Resource(childComplexity), true

	case "CreateRouterPayload.errors":
		if e.complexity.CreateRouterPayload.Errors == nil {
			break
		}

		return e.complexity.CreateRouterPayload.Errors(childComplexity), true

	case "CreateRouterPayload.router":
		if e.complexity.CreateRouterPayload.Router == nil {
			break
		}

		return e.complexity.CreateRouterPayload.Router(childComplexity), true

	case "CredentialTestResult.error":
		if e.complexity.CredentialTestResult.Error == nil {
			break
		}

		return e.complexity.CredentialTestResult.Error(childComplexity), true

	case "CredentialTestResult.responseTimeMs":
		if e.complexity.CredentialTestResult.ResponseTimeMs == nil {
			break
		}

		return e.complexity.CredentialTestResult.ResponseTimeMs(childComplexity), true

	case "CredentialTestResult.routerId":
		if e.complexity.CredentialTestResult.RouterID == nil {
			break
		}

		return e.complexity.CredentialTestResult.RouterID(childComplexity), true

	case "CredentialTestResult.routerName":
		if e.complexity.CredentialTestResult.RouterName == nil {
			break
		}

		return e.complexity.CredentialTestResult.RouterName(childComplexity), true

	case "CredentialTestResult.status":
		if e.complexity.CredentialTestResult.Status == nil {
			break
		}

		return e.complexity.CredentialTestResult.Status(childComplexity), true

	case "CredentialTestResult.success":
		if e.complexity.CredentialTestResult.Success == nil {
			break
		}

		return e.complexity.CredentialTestResult.Success(childComplexity), true

	case "CredentialUpdatePayload.credentials":
		if e.complexity.CredentialUpdatePayload.Credentials == nil {
			break
		}

		return e.complexity.CredentialUpdatePayload.Credentials(childComplexity), true

	case "CredentialUpdatePayload.errorCode":
		if e.complexity.CredentialUpdatePayload.ErrorCode == nil {
			break
		}

		return e.complexity.CredentialUpdatePayload.ErrorCode(childComplexity), true

	case "CredentialUpdatePayload.errors":
		if e.complexity.CredentialUpdatePayload.Errors == nil {
			break
		}

		return e.complexity.CredentialUpdatePayload.Errors(childComplexity), true

	case "CredentialUpdatePayload.message":
		if e.complexity.CredentialUpdatePayload.Message == nil {
			break
		}

		return e.complexity.CredentialUpdatePayload.Message(childComplexity), true

	case "CredentialUpdatePayload.success":
		if e.complexity.CredentialUpdatePayload.Success == nil {
			break
		}

		return e.complexity.CredentialUpdatePayload.Success(childComplexity), true

	case "CurrentItemInfo.id":
		if e.complexity.CurrentItemInfo.ID == nil {
			break
		}

		return e.complexity.CurrentItemInfo.ID(childComplexity), true

	case "CurrentItemInfo.name":
		if e.complexity.CurrentItemInfo.Name == nil {
			break
		}

		return e.complexity.CurrentItemInfo.Name(childComplexity), true

	case "CurrentItemInfo.operation":
		if e.complexity.CurrentItemInfo.Operation == nil {
			break
		}

		return e.complexity.CurrentItemInfo.Operation(childComplexity), true

	case "CurrentItemInfo.status":
		if e.complexity.CurrentItemInfo.Status == nil {
			break
		}

		return e.complexity.CurrentItemInfo.Status(childComplexity), true

	case "DHCPServerResource.activeLeases":
		if e.complexity.DHCPServerResource.ActiveLeases == nil {
			break
		}

		return e.complexity.DHCPServerResource.ActiveLeases(childComplexity), true

	case "DHCPServerResource.addressPool":
		if e.complexity.DHCPServerResource.AddressPool == nil {
			break
		}

		return e.complexity.DHCPServerResource.AddressPool(childComplexity), true

	case "DHCPServerResource.category":
		if e.complexity.DHCPServerResource.Category == nil {
			break
		}

		return e.complexity.DHCPServerResource.Category(childComplexity), true

	case "DHCPServerResource.configuration":
		if e.complexity.DHCPServerResource.Configuration == nil {
			break
		}

		return e.complexity.DHCPServerResource.Configuration(childComplexity), true

	case "DHCPServerResource.deployment":
		if e.complexity.DHCPServerResource.Deployment == nil {
			break
		}

		return e.complexity.DHCPServerResource.Deployment(childComplexity), true

	case "DHCPServerResource.id":
		if e.complexity.DHCPServerResource.ID == nil {
			break
		}

		return e.complexity.DHCPServerResource.ID(childComplexity), true

	case "DHCPServerResource.interface":
		if e.complexity.DHCPServerResource.Interface == nil {
			break
		}

		return e.complexity.DHCPServerResource.Interface(childComplexity), true

	case "DHCPServerResource.leaseTime":
		if e.complexity.DHCPServerResource.LeaseTime == nil {
			break
		}

		return e.complexity.DHCPServerResource.LeaseTime(childComplexity), true

	case "DHCPServerResource.metadata":
		if e.complexity.DHCPServerResource.Metadata == nil {
			break
		}

		return e.complexity.DHCPServerResource.Metadata(childComplexity), true

	case "DHCPServerResource.name":
		if e.complexity.DHCPServerResource.Name == nil {
			break
		}

		return e.complexity.DHCPServerResource.Name(childComplexity), true

	case "DHCPServerResource.platform":
		if e.complexity.DHCPServerResource.Platform == nil {
			break
		}

		return e.complexity.DHCPServerResource.Platform(childComplexity), true

	case "DHCPServerResource.relationships":
		if e.complexity.DHCPServerResource.Relationships == nil {
			break
		}

		return e.complexity.DHCPServerResource.Relationships(childComplexity), true

	case "DHCPServerResource.runtime":
		if e.complexity.DHCPServerResource.Runtime == nil {
			break
		}

		return e.complexity.DHCPServerResource.Runtime(childComplexity), true

	case "DHCPServerResource.scopedId":
		if e.complexity.DHCPServerResource.ScopedID == nil {
			break
		}

		return e.complexity.DHCPServerResource.ScopedID(childComplexity), true

	case "DHCPServerResource.telemetry":
		if e.complexity.DHCPServerResource.Telemetry == nil {
			break
		}

		return e.complexity.DHCPServerResource.Telemetry(childComplexity), true

	case "DHCPServerResource.type":
		if e.complexity.DHCPServerResource.Type == nil {
			break
		}

		return e.complexity.DHCPServerResource.Type(childComplexity), true

	case "DHCPServerResource.validation":
		if e.complexity.DHCPServerResource.Validation == nil {
			break
		}

		return e.complexity.DHCPServerResource.Validation(childComplexity), true

	case "DailyStats.date":
		if e.complexity.DailyStats.Date == nil {
			break
		}

		return e.complexity.DailyStats.Date(childComplexity), true

	case "DailyStats.errorCount":
		if e.complexity.DailyStats.ErrorCount == nil {
			break
		}

		return e.complexity.DailyStats.ErrorCount(childComplexity), true

	case "DailyStats.peakThroughputIn":
		if e.complexity.DailyStats.PeakThroughputIn == nil {
			break
		}

		return e.complexity.DailyStats.PeakThroughputIn(childComplexity), true

	case "DailyStats.peakThroughputOut":
		if e.complexity.DailyStats.PeakThroughputOut == nil {
			break
		}

		return e.complexity.DailyStats.PeakThroughputOut(childComplexity), true

	case "DailyStats.totalBytesIn":
		if e.complexity.DailyStats.TotalBytesIn == nil {
			break
		}

		return e.complexity.DailyStats.TotalBytesIn(childComplexity), true

	case "DailyStats.totalBytesOut":
		if e.complexity.DailyStats.TotalBytesOut == nil {
			break
		}

		return e.complexity.DailyStats.TotalBytesOut(childComplexity), true

	case "DailyStats.uptimePercent":
		if e.complexity.DailyStats.UptimePercent == nil {
			break
		}

		return e.complexity.DailyStats.UptimePercent(childComplexity), true

	case "DeleteChangeSetPayload.errors":
		if e.complexity.DeleteChangeSetPayload.Errors == nil {
			break
		}

		return e.complexity.DeleteChangeSetPayload.Errors(childComplexity), true

	case "DeleteChangeSetPayload.success":
		if e.complexity.DeleteChangeSetPayload.Success == nil {
			break
		}

		return e.complexity.DeleteChangeSetPayload.Success(childComplexity), true

	case "DeletePayload.deletedId":
		if e.complexity.DeletePayload.DeletedID == nil {
			break
		}

		return e.complexity.DeletePayload.DeletedID(childComplexity), true

	case "DeletePayload.errors":
		if e.complexity.DeletePayload.Errors == nil {
			break
		}

		return e.complexity.DeletePayload.Errors(childComplexity), true

	case "DeletePayload.success":
		if e.complexity.DeletePayload.Success == nil {
			break
		}

		return e.complexity.DeletePayload.Success(childComplexity), true

	case "DeleteResourcePayload.deletedId":
		if e.complexity.DeleteResourcePayload.DeletedID == nil {
			break
		}

		return e.complexity.DeleteResourcePayload.DeletedID(childComplexity), true

	case "DeleteResourcePayload.errors":
		if e.complexity.DeleteResourcePayload.Errors == nil {
			break
		}

		return e.complexity.DeleteResourcePayload.Errors(childComplexity), true

	case "DeleteResourcePayload.success":
		if e.complexity.DeleteResourcePayload.Success == nil {
			break
		}

		return e.complexity.DeleteResourcePayload.Success(childComplexity), true

	case "DeleteResult.errors":
		if e.complexity.DeleteResult.Errors == nil {
			break
		}

		return e.complexity.DeleteResult.Errors(childComplexity), true

	case "DeleteResult.message":
		if e.complexity.DeleteResult.Message == nil {
			break
		}

		return e.complexity.DeleteResult.Message(childComplexity), true

	case "DeleteResult.success":
		if e.complexity.DeleteResult.Success == nil {
			break
		}

		return e.complexity.DeleteResult.Success(childComplexity), true

	case "DeleteRouterPayload.deletedRouterId":
		if e.complexity.DeleteRouterPayload.DeletedRouterID == nil {
			break
		}

		return e.complexity.DeleteRouterPayload.DeletedRouterID(childComplexity), true

	case "DeleteRouterPayload.errors":
		if e.complexity.DeleteRouterPayload.Errors == nil {
			break
		}

		return e.complexity.DeleteRouterPayload.Errors(childComplexity), true

	case "DeleteRouterPayload.success":
		if e.complexity.DeleteRouterPayload.Success == nil {
			break
		}

		return e.complexity.DeleteRouterPayload.Success(childComplexity), true

	case "DependencyStatus.isActive":
		if e.complexity.DependencyStatus.IsActive == nil {
			break
		}

		return e.complexity.DependencyStatus.IsActive(childComplexity), true

	case "DependencyStatus.reason":
		if e.complexity.DependencyStatus.Reason == nil {
			break
		}

		return e.complexity.DependencyStatus.Reason(childComplexity), true

	case "DependencyStatus.resourceType":
		if e.complexity.DependencyStatus.ResourceType == nil {
			break
		}

		return e.complexity.DependencyStatus.ResourceType(childComplexity), true

	case "DependencyStatus.resourceUuid":
		if e.complexity.DependencyStatus.ResourceUUID == nil {
			break
		}

		return e.complexity.DependencyStatus.ResourceUUID(childComplexity), true

	case "DependencyStatus.state":
		if e.complexity.DependencyStatus.State == nil {
			break
		}

		return e.complexity.DependencyStatus.State(childComplexity), true

	case "DeploymentState.appliedAt":
		if e.complexity.DeploymentState.AppliedAt == nil {
			break
		}

		return e.complexity.DeploymentState.AppliedAt(childComplexity), true

	case "DeploymentState.appliedBy":
		if e.complexity.DeploymentState.AppliedBy == nil {
			break
		}

		return e.complexity.DeploymentState.AppliedBy(childComplexity), true

	case "DeploymentState.applyOperationId":
		if e.complexity.DeploymentState.ApplyOperationID == nil {
			break
		}

		return e.complexity.DeploymentState.ApplyOperationID(childComplexity), true

	case "DeploymentState.drift":
		if e.complexity.DeploymentState.Drift == nil {
			break
		}

		return e.complexity.DeploymentState.Drift(childComplexity), true

	case "DeploymentState.generatedFields":
		if e.complexity.DeploymentState.GeneratedFields == nil {
			break
		}

		return e.complexity.DeploymentState.GeneratedFields(childComplexity), true

	case "DeploymentState.isInSync":
		if e.complexity.DeploymentState.IsInSync == nil {
			break
		}

		return e.complexity.DeploymentState.IsInSync(childComplexity), true

	case "DeploymentState.routerResourceId":
		if e.complexity.DeploymentState.RouterResourceID == nil {
			break
		}

		return e.complexity.DeploymentState.RouterResourceID(childComplexity), true

	case "DeploymentState.routerVersion":
		if e.complexity.DeploymentState.RouterVersion == nil {
			break
		}

		return e.complexity.DeploymentState.RouterVersion(childComplexity), true

	case "DeprecateResourcePayload.errors":
		if e.complexity.DeprecateResourcePayload.Errors == nil {
			break
		}

		return e.complexity.DeprecateResourcePayload.Errors(childComplexity), true

	case "DeprecateResourcePayload.resource":
		if e.complexity.DeprecateResourcePayload.Resource == nil {
			break
		}

		return e.complexity.DeprecateResourcePayload.Resource(childComplexity), true

	case "Device.id":
		if e.complexity.Device.ID == nil {
			break
		}

		return e.complexity.Device.ID(childComplexity), true

	case "Device.resourceMetrics":
		if e.complexity.Device.ResourceMetrics == nil {
			break
		}

		return e.complexity.Device.ResourceMetrics(childComplexity), true

	case "DhcpClient.addDefaultRoute":
		if e.complexity.DhcpClient.AddDefaultRoute == nil {
			break
		}

		return e.complexity.DhcpClient.AddDefaultRoute(childComplexity), true

	case "DhcpClient.address":
		if e.complexity.DhcpClient.Address == nil {
			break
		}

		return e.complexity.DhcpClient.Address(childComplexity), true

	case "DhcpClient.comment":
		if e.complexity.DhcpClient.Comment == nil {
			break
		}

		return e.complexity.DhcpClient.Comment(childComplexity), true

	case "DhcpClient.dhcpServer":
		if e.complexity.DhcpClient.DhcpServer == nil {
			break
		}

		return e.complexity.DhcpClient.DhcpServer(childComplexity), true

	case "DhcpClient.disabled":
		if e.complexity.DhcpClient.Disabled == nil {
			break
		}

		return e.complexity.DhcpClient.Disabled(childComplexity), true

	case "DhcpClient.expiresAfter":
		if e.complexity.DhcpClient.ExpiresAfter == nil {
			break
		}

		return e.complexity.DhcpClient.ExpiresAfter(childComplexity), true

	case "DhcpClient.gateway":
		if e.complexity.DhcpClient.Gateway == nil {
			break
		}

		return e.complexity.DhcpClient.Gateway(childComplexity), true

	case "DhcpClient.id":
		if e.complexity.DhcpClient.ID == nil {
			break
		}

		return e.complexity.DhcpClient.ID(childComplexity), true

	case "DhcpClient.interface":
		if e.complexity.DhcpClient.Interface == nil {
			break
		}

		return e.complexity.DhcpClient.Interface(childComplexity), true

	case "DhcpClient.status":
		if e.complexity.DhcpClient.Status == nil {
			break
		}

		return e.complexity.DhcpClient.Status(childComplexity), true

	case "DhcpClient.usePeerDNS":
		if e.complexity.DhcpClient.UsePeerDNS == nil {
			break
		}

		return e.complexity.DhcpClient.UsePeerDNS(childComplexity), true

	case "DhcpClient.usePeerNTP":
		if e.complexity.DhcpClient.UsePeerNtp == nil {
			break
		}

		return e.complexity.DhcpClient.UsePeerNtp(childComplexity), true

	case "DhcpServer.disabled":
		if e.complexity.DhcpServer.Disabled == nil {
			break
		}

		return e.complexity.DhcpServer.Disabled(childComplexity), true

	case "DhcpServer.id":
		if e.complexity.DhcpServer.ID == nil {
			break
		}

		return e.complexity.DhcpServer.ID(childComplexity), true

	case "DhcpServer.interface":
		if e.complexity.DhcpServer.Interface == nil {
			break
		}

		return e.complexity.DhcpServer.Interface(childComplexity), true

	case "DhcpServer.name":
		if e.complexity.DhcpServer.Name == nil {
			break
		}

		return e.complexity.DhcpServer.Name(childComplexity), true

	case "DiagnosticReport.authStatus":
		if e.complexity.DiagnosticReport.AuthStatus == nil {
			break
		}

		return e.complexity.DiagnosticReport.AuthStatus(childComplexity), true

	case "DiagnosticReport.networkReachable":
		if e.complexity.DiagnosticReport.NetworkReachable == nil {
			break
		}

		return e.complexity.DiagnosticReport.NetworkReachable(childComplexity), true

	case "DiagnosticReport.portStatus":
		if e.complexity.DiagnosticReport.PortStatus == nil {
			break
		}

		return e.complexity.DiagnosticReport.PortStatus(childComplexity), true

	case "DiagnosticReport.rawReport":
		if e.complexity.DiagnosticReport.RawReport == nil {
			break
		}

		return e.complexity.DiagnosticReport.RawReport(childComplexity), true

	case "DiagnosticReport.routerId":
		if e.complexity.DiagnosticReport.RouterID == nil {
			break
		}

		return e.complexity.DiagnosticReport.RouterID(childComplexity), true

	case "DiagnosticReport.suggestions":
		if e.complexity.DiagnosticReport.Suggestions == nil {
			break
		}

		return e.complexity.DiagnosticReport.Suggestions(childComplexity), true

	case "DiagnosticReport.tlsStatus":
		if e.complexity.DiagnosticReport.TLSStatus == nil {
			break
		}

		return e.complexity.DiagnosticReport.TLSStatus(childComplexity), true

	case "DiagnosticReport.timestamp":
		if e.complexity.DiagnosticReport.Timestamp == nil {
			break
		}

		return e.complexity.DiagnosticReport.Timestamp(childComplexity), true

	case "DiagnosticSuggestion.action":
		if e.complexity.DiagnosticSuggestion.Action == nil {
			break
		}

		return e.complexity.DiagnosticSuggestion.Action(childComplexity), true

	case "DiagnosticSuggestion.description":
		if e.complexity.DiagnosticSuggestion.Description == nil {
			break
		}

		return e.complexity.DiagnosticSuggestion.Description(childComplexity), true

	case "DiagnosticSuggestion.docsUrl":
		if e.complexity.DiagnosticSuggestion.DocsURL == nil {
			break
		}

		return e.complexity.DiagnosticSuggestion.DocsURL(childComplexity), true

	case "DiagnosticSuggestion.severity":
		if e.complexity.DiagnosticSuggestion.Severity == nil {
			break
		}

		return e.complexity.DiagnosticSuggestion.Severity(childComplexity), true

	case "DiagnosticSuggestion.title":
		if e.complexity.DiagnosticSuggestion.Title == nil {
			break
		}

		return e.complexity.DiagnosticSuggestion.Title(childComplexity), true

	case "DisconnectRouterPayload.errors":
		if e.complexity.DisconnectRouterPayload.Errors == nil {
			break
		}

		return e.complexity.DisconnectRouterPayload.Errors(childComplexity), true

	case "DisconnectRouterPayload.router":
		if e.complexity.DisconnectRouterPayload.Router == nil {
			break
		}

		return e.complexity.DisconnectRouterPayload.Router(childComplexity), true

	case "DiscoveredDevice.confidence":
		if e.complexity.DiscoveredDevice.Confidence == nil {
			break
		}

		return e.complexity.DiscoveredDevice.Confidence(childComplexity), true

	case "DiscoveredDevice.deviceType":
		if e.complexity.DiscoveredDevice.DeviceType == nil {
			break
		}

		return e.complexity.DiscoveredDevice.DeviceType(childComplexity), true

	case "DiscoveredDevice.hostname":
		if e.complexity.DiscoveredDevice.Hostname == nil {
			break
		}

		return e.complexity.DiscoveredDevice.Hostname(childComplexity), true

	case "DiscoveredDevice.ip":
		if e.complexity.DiscoveredDevice.IP == nil {
			break
		}

		return e.complexity.DiscoveredDevice.IP(childComplexity), true

	case "DiscoveredDevice.ports":
		if e.complexity.DiscoveredDevice.Ports == nil {
			break
		}

		return e.complexity.DiscoveredDevice.Ports(childComplexity), true

	case "DiscoveredDevice.routerOSInfo":
		if e.complexity.DiscoveredDevice.RouterOSInfo == nil {
			break
		}

		return e.complexity.DiscoveredDevice.RouterOSInfo(childComplexity), true

	case "DiscoveredDevice.services":
		if e.complexity.DiscoveredDevice.Services == nil {
			break
		}

		return e.complexity.DiscoveredDevice.Services(childComplexity), true

	case "DiscoveredDevice.vendor":
		if e.complexity.DiscoveredDevice.Vendor == nil {
			break
		}

		return e.complexity.DiscoveredDevice.Vendor(childComplexity), true

	case "DnsLookupResult.authoritative":
		if e.complexity.DnsLookupResult.Authoritative == nil {
			break
		}

		return e.complexity.DnsLookupResult.Authoritative(childComplexity), true

	case "DnsLookupResult.error":
		if e.complexity.DnsLookupResult.Error == nil {
			break
		}

		return e.complexity.DnsLookupResult.Error(childComplexity), true

	case "DnsLookupResult.hostname":
		if e.complexity.DnsLookupResult.Hostname == nil {
			break
		}

		return e.complexity.DnsLookupResult.Hostname(childComplexity), true

	case "DnsLookupResult.queryTime":
		if e.complexity.DnsLookupResult.QueryTime == nil {
			break
		}

		return e.complexity.DnsLookupResult.QueryTime(childComplexity), true

	case "DnsLookupResult.recordType":
		if e.complexity.DnsLookupResult.RecordType == nil {
			break
		}

		return e.complexity.DnsLookupResult.RecordType(childComplexity), true

	case "DnsLookupResult.records":
		if e.complexity.DnsLookupResult.Records == nil {
			break
		}

		return e.complexity.DnsLookupResult.Records(childComplexity), true

	case "DnsLookupResult.server":
		if e.complexity.DnsLookupResult.Server == nil {
			break
		}

		return e.complexity.DnsLookupResult.Server(childComplexity), true

	case "DnsLookupResult.status":
		if e.complexity.DnsLookupResult.Status == nil {
			break
		}

		return e.complexity.DnsLookupResult.Status(childComplexity), true

	case "DnsLookupResult.timestamp":
		if e.complexity.DnsLookupResult.Timestamp == nil {
			break
		}

		return e.complexity.DnsLookupResult.Timestamp(childComplexity), true

	case "DnsRecord.data":
		if e.complexity.DnsRecord.Data == nil {
			break
		}

		return e.complexity.DnsRecord.Data(childComplexity), true

	case "DnsRecord.name":
		if e.complexity.DnsRecord.Name == nil {
			break
		}

		return e.complexity.DnsRecord.Name(childComplexity), true

	case "DnsRecord.port":
		if e.complexity.DnsRecord.Port == nil {
			break
		}

		return e.complexity.DnsRecord.Port(childComplexity), true

	case "DnsRecord.priority":
		if e.complexity.DnsRecord.Priority == nil {
			break
		}

		return e.complexity.DnsRecord.Priority(childComplexity), true

	case "DnsRecord.ttl":
		if e.complexity.DnsRecord.TTL == nil {
			break
		}

		return e.complexity.DnsRecord.TTL(childComplexity), true

	case "DnsRecord.type":
		if e.complexity.DnsRecord.Type == nil {
			break
		}

		return e.complexity.DnsRecord.Type(childComplexity), true

	case "DnsRecord.weight":
		if e.complexity.DnsRecord.Weight == nil {
			break
		}

		return e.complexity.DnsRecord.Weight(childComplexity), true

	case "DnsServer.address":
		if e.complexity.DnsServer.Address == nil {
			break
		}

		return e.complexity.DnsServer.Address(childComplexity), true

	case "DnsServer.isPrimary":
		if e.complexity.DnsServer.IsPrimary == nil {
			break
		}

		return e.complexity.DnsServer.IsPrimary(childComplexity), true

	case "DnsServer.isSecondary":
		if e.complexity.DnsServer.IsSecondary == nil {
			break
		}

		return e.complexity.DnsServer.IsSecondary(childComplexity), true

	case "DnsServers.primary":
		if e.complexity.DnsServers.Primary == nil {
			break
		}

		return e.complexity.DnsServers.Primary(childComplexity), true

	case "DnsServers.secondary":
		if e.complexity.DnsServers.Secondary == nil {
			break
		}

		return e.complexity.DnsServers.Secondary(childComplexity), true

	case "DnsServers.servers":
		if e.complexity.DnsServers.Servers == nil {
			break
		}

		return e.complexity.DnsServers.Servers(childComplexity), true

	case "DriftField.actual":
		if e.complexity.DriftField.Actual == nil {
			break
		}

		return e.complexity.DriftField.Actual(childComplexity), true

	case "DriftField.expected":
		if e.complexity.DriftField.Expected == nil {
			break
		}

		return e.complexity.DriftField.Expected(childComplexity), true

	case "DriftField.path":
		if e.complexity.DriftField.Path == nil {
			break
		}

		return e.complexity.DriftField.Path(childComplexity), true

	case "DriftInfo.detectedAt":
		if e.complexity.DriftInfo.DetectedAt == nil {
			break
		}

		return e.complexity.DriftInfo.DetectedAt(childComplexity), true

	case "DriftInfo.driftedFields":
		if e.complexity.DriftInfo.DriftedFields == nil {
			break
		}

		return e.complexity.DriftInfo.DriftedFields(childComplexity), true

	case "DriftInfo.suggestedAction":
		if e.complexity.DriftInfo.SuggestedAction == nil {
			break
		}

		return e.complexity.DriftInfo.SuggestedAction(childComplexity), true

	case "ErrorExtensions.category":
		if e.complexity.ErrorExtensions.Category == nil {
			break
		}

		return e.complexity.ErrorExtensions.Category(childComplexity), true

	case "ErrorExtensions.code":
		if e.complexity.ErrorExtensions.Code == nil {
			break
		}

		return e.complexity.ErrorExtensions.Code(childComplexity), true

	case "ErrorExtensions.docsUrl":
		if e.complexity.ErrorExtensions.DocsURL == nil {
			break
		}

		return e.complexity.ErrorExtensions.DocsURL(childComplexity), true

	case "ErrorExtensions.field":
		if e.complexity.ErrorExtensions.Field == nil {
			break
		}

		return e.complexity.ErrorExtensions.Field(childComplexity), true

	case "ErrorExtensions.recoverable":
		if e.complexity.ErrorExtensions.Recoverable == nil {
			break
		}

		return e.complexity.ErrorExtensions.Recoverable(childComplexity), true

	case "ErrorExtensions.requestId":
		if e.complexity.ErrorExtensions.RequestID == nil {
			break
		}

		return e.complexity.ErrorExtensions.RequestID(childComplexity), true

	case "ErrorExtensions.suggestedFix":
		if e.complexity.ErrorExtensions.SuggestedFix == nil {
			break
		}

		return e.complexity.ErrorExtensions.SuggestedFix(childComplexity), true

	case "ErrorExtensions.troubleshootingSteps":
		if e.complexity.ErrorExtensions.TroubleshootingSteps == nil {
			break
		}

		return e.complexity.ErrorExtensions.TroubleshootingSteps(childComplexity), true

	case "ErrorExtensions.value":
		if e.complexity.ErrorExtensions.Value == nil {
			break
		}

		return e.complexity.ErrorExtensions.Value(childComplexity), true

	case "ExportConfigPayload.config":
		if e.complexity.ExportConfigPayload.Config == nil {
			break
		}

		return e.complexity.ExportConfigPayload.Config(childComplexity), true

	case "ExportConfigPayload.errors":
		if e.complexity.ExportConfigPayload.Errors == nil {
			break
		}

		return e.complexity.ExportConfigPayload.Errors(childComplexity), true

	case "ExportConfigPayload.securityWarning":
		if e.complexity.ExportConfigPayload.SecurityWarning == nil {
			break
		}

		return e.complexity.ExportConfigPayload.SecurityWarning(childComplexity), true

	case "ExportConfigPayload.success":
		if e.complexity.ExportConfigPayload.Success == nil {
			break
		}

		return e.complexity.ExportConfigPayload.Success(childComplexity), true

	case "FeatureCompatibilityInfo.dependsOn":
		if e.complexity.FeatureCompatibilityInfo.DependsOn == nil {
			break
		}

		return e.complexity.FeatureCompatibilityInfo.DependsOn(childComplexity), true

	case "FeatureCompatibilityInfo.featureId":
		if e.complexity.FeatureCompatibilityInfo.FeatureID == nil {
			break
		}

		return e.complexity.FeatureCompatibilityInfo.FeatureID(childComplexity), true

	case "FeatureCompatibilityInfo.maxVersion":
		if e.complexity.FeatureCompatibilityInfo.MaxVersion == nil {
			break
		}

		return e.complexity.FeatureCompatibilityInfo.MaxVersion(childComplexity), true

	case "FeatureCompatibilityInfo.minVersion":
		if e.complexity.FeatureCompatibilityInfo.MinVersion == nil {
			break
		}

		return e.complexity.FeatureCompatibilityInfo.MinVersion(childComplexity), true

	case "FeatureCompatibilityInfo.minVersionCHR":
		if e.complexity.FeatureCompatibilityInfo.MinVersionChr == nil {
			break
		}

		return e.complexity.FeatureCompatibilityInfo.MinVersionChr(childComplexity), true

	case "FeatureCompatibilityInfo.name":
		if e.complexity.FeatureCompatibilityInfo.Name == nil {
			break
		}

		return e.complexity.FeatureCompatibilityInfo.Name(childComplexity), true

	case "FeatureCompatibilityInfo.requiredPackages":
		if e.complexity.FeatureCompatibilityInfo.RequiredPackages == nil {
			break
		}

		return e.complexity.FeatureCompatibilityInfo.RequiredPackages(childComplexity), true

	case "FeatureCompatibilityInfo.upgradeUrl":
		if e.complexity.FeatureCompatibilityInfo.UpgradeURL == nil {
			break
		}

		return e.complexity.FeatureCompatibilityInfo.UpgradeURL(childComplexity), true

	case "FeatureDeployment.appliedAt":
		if e.complexity.FeatureDeployment.AppliedAt == nil {
			break
		}

		return e.complexity.FeatureDeployment.AppliedAt(childComplexity), true

	case "FeatureDeployment.appliedBy":
		if e.complexity.FeatureDeployment.AppliedBy == nil {
			break
		}

		return e.complexity.FeatureDeployment.AppliedBy(childComplexity), true

	case "FeatureDeployment.assignedIP":
		if e.complexity.FeatureDeployment.AssignedIP == nil {
			break
		}

		return e.complexity.FeatureDeployment.AssignedIP(childComplexity), true

	case "FeatureDeployment.assignedPorts":
		if e.complexity.FeatureDeployment.AssignedPorts == nil {
			break
		}

		return e.complexity.FeatureDeployment.AssignedPorts(childComplexity), true

	case "FeatureDeployment.containerId":
		if e.complexity.FeatureDeployment.ContainerID == nil {
			break
		}

		return e.complexity.FeatureDeployment.ContainerID(childComplexity), true

	case "FeatureDeployment.containerImage":
		if e.complexity.FeatureDeployment.ContainerImage == nil {
			break
		}

		return e.complexity.FeatureDeployment.ContainerImage(childComplexity), true

	case "FeatureDeployment.drift":
		if e.complexity.FeatureDeployment.Drift == nil {
			break
		}

		return e.complexity.FeatureDeployment.Drift(childComplexity), true

	case "FeatureDeployment.isInSync":
		if e.complexity.FeatureDeployment.IsInSync == nil {
			break
		}

		return e.complexity.FeatureDeployment.IsInSync(childComplexity), true

	case "FeatureDeployment.routerResourceId":
		if e.complexity.FeatureDeployment.RouterResourceID == nil {
			break
		}

		return e.complexity.FeatureDeployment.RouterResourceID(childComplexity), true

	case "FeatureDeployment.routerVersion":
		if e.complexity.FeatureDeployment.RouterVersion == nil {
			break
		}

		return e.complexity.FeatureDeployment.RouterVersion(childComplexity), true

	case "FeatureResource.category":
		if e.complexity.FeatureResource.Category == nil {
			break
		}

		return e.complexity.FeatureResource.Category(childComplexity), true

	case "FeatureResource.configuration":
		if e.complexity.FeatureResource.Configuration == nil {
			break
		}

		return e.complexity.FeatureResource.Configuration(childComplexity), true

	case "FeatureResource.deployment":
		if e.complexity.FeatureResource.Deployment == nil {
			break
		}

		return e.complexity.FeatureResource.Deployment(childComplexity), true

	case "FeatureResource.featureDeployment":
		if e.complexity.FeatureResource.FeatureDeployment == nil {
			break
		}

		return e.complexity.FeatureResource.FeatureDeployment(childComplexity), true

	case "FeatureResource.featureId":
		if e.complexity.FeatureResource.FeatureID == nil {
			break
		}

		return e.complexity.FeatureResource.FeatureID(childComplexity), true

	case "FeatureResource.featureRuntime":
		if e.complexity.FeatureResource.FeatureRuntime == nil {
			break
		}

		return e.complexity.FeatureResource.FeatureRuntime(childComplexity), true

	case "FeatureResource.id":
		if e.complexity.FeatureResource.ID == nil {
			break
		}

		return e.complexity.FeatureResource.ID(childComplexity), true

	case "FeatureResource.metadata":
		if e.complexity.FeatureResource.Metadata == nil {
			break
		}

		return e.complexity.FeatureResource.Metadata(childComplexity), true

	case "FeatureResource.name":
		if e.complexity.FeatureResource.Name == nil {
			break
		}

		return e.complexity.FeatureResource.Name(childComplexity), true

	case "FeatureResource.platform":
		if e.complexity.FeatureResource.Platform == nil {
			break
		}

		return e.complexity.FeatureResource.Platform(childComplexity), true

	case "FeatureResource.relationships":
		if e.complexity.FeatureResource.Relationships == nil {
			break
		}

		return e.complexity.FeatureResource.Relationships(childComplexity), true

	case "FeatureResource.runtime":
		if e.complexity.FeatureResource.Runtime == nil {
			break
		}

		return e.complexity.FeatureResource.Runtime(childComplexity), true

	case "FeatureResource.scopedId":
		if e.complexity.FeatureResource.ScopedID == nil {
			break
		}

		return e.complexity.FeatureResource.ScopedID(childComplexity), true

	case "FeatureResource.telemetry":
		if e.complexity.FeatureResource.Telemetry == nil {
			break
		}

		return e.complexity.FeatureResource.Telemetry(childComplexity), true

	case "FeatureResource.type":
		if e.complexity.FeatureResource.Type == nil {
			break
		}

		return e.complexity.FeatureResource.Type(childComplexity), true

	case "FeatureResource.validation":
		if e.complexity.FeatureResource.Validation == nil {
			break
		}

		return e.complexity.FeatureResource.Validation(childComplexity), true

	case "FeatureResource.version":
		if e.complexity.FeatureResource.Version == nil {
			break
		}

		return e.complexity.FeatureResource.Version(childComplexity), true

	case "FeatureResource.virtualInterface":
		if e.complexity.FeatureResource.VirtualInterface == nil {
			break
		}

		return e.complexity.FeatureResource.VirtualInterface(childComplexity), true

	case "FeatureRuntime.cpuUsagePercent":
		if e.complexity.FeatureRuntime.CPUUsagePercent == nil {
			break
		}

		return e.complexity.FeatureRuntime.CPUUsagePercent(childComplexity), true

	case "FeatureRuntime.containerStatus":
		if e.complexity.FeatureRuntime.ContainerStatus == nil {
			break
		}

		return e.complexity.FeatureRuntime.ContainerStatus(childComplexity), true

	case "FeatureRuntime.errorMessage":
		if e.complexity.FeatureRuntime.ErrorMessage == nil {
			break
		}

		return e.complexity.FeatureRuntime.ErrorMessage(childComplexity), true

	case "FeatureRuntime.health":
		if e.complexity.FeatureRuntime.Health == nil {
			break
		}

		return e.complexity.FeatureRuntime.Health(childComplexity), true

	case "FeatureRuntime.isRunning":
		if e.complexity.FeatureRuntime.IsRunning == nil {
			break
		}

		return e.complexity.FeatureRuntime.IsRunning(childComplexity), true

	case "FeatureRuntime.lastUpdated":
		if e.complexity.FeatureRuntime.LastUpdated == nil {
			break
		}

		return e.complexity.FeatureRuntime.LastUpdated(childComplexity), true

	case "FeatureRuntime.memoryUsage":
		if e.complexity.FeatureRuntime.MemoryUsage == nil {
			break
		}

		return e.complexity.FeatureRuntime.MemoryUsage(childComplexity), true

	case "FeatureRuntime.routedDevices":
		if e.complexity.FeatureRuntime.RoutedDevices == nil {
			break
		}

		return e.complexity.FeatureRuntime.RoutedDevices(childComplexity), true

	case "FeatureSupport.featureId":
		if e.complexity.FeatureSupport.FeatureID == nil {
			break
		}

		return e.complexity.FeatureSupport.FeatureID(childComplexity), true

	case "FeatureSupport.level":
		if e.complexity.FeatureSupport.Level == nil {
			break
		}

		return e.complexity.FeatureSupport.Level(childComplexity), true

	case "FeatureSupport.missingPackages":
		if e.complexity.FeatureSupport.MissingPackages == nil {
			break
		}

		return e.complexity.FeatureSupport.MissingPackages(childComplexity), true

	case "FeatureSupport.name":
		if e.complexity.FeatureSupport.Name == nil {
			break
		}

		return e.complexity.FeatureSupport.Name(childComplexity), true

	case "FeatureSupport.reason":
		if e.complexity.FeatureSupport.Reason == nil {
			break
		}

		return e.complexity.FeatureSupport.Reason(childComplexity), true

	case "FeatureSupport.requiredPackages":
		if e.complexity.FeatureSupport.RequiredPackages == nil {
			break
		}

		return e.complexity.FeatureSupport.RequiredPackages(childComplexity), true

	case "FeatureSupport.requiredVersion":
		if e.complexity.FeatureSupport.RequiredVersion == nil {
			break
		}

		return e.complexity.FeatureSupport.RequiredVersion(childComplexity), true

	case "FeatureSupport.supported":
		if e.complexity.FeatureSupport.Supported == nil {
			break
		}

		return e.complexity.FeatureSupport.Supported(childComplexity), true

	case "FeatureSupport.upgradeUrl":
		if e.complexity.FeatureSupport.UpgradeURL == nil {
			break
		}

		return e.complexity.FeatureSupport.UpgradeURL(childComplexity), true

	case "FirewallRule.action":
		if e.complexity.FirewallRule.Action == nil {
			break
		}

		return e.complexity.FirewallRule.Action(childComplexity), true

	case "FirewallRule.chain":
		if e.complexity.FirewallRule.Chain == nil {
			break
		}

		return e.complexity.FirewallRule.Chain(childComplexity), true

	case "FirewallRule.disabled":
		if e.complexity.FirewallRule.Disabled == nil {
			break
		}

		return e.complexity.FirewallRule.Disabled(childComplexity), true

	case "FirewallRule.id":
		if e.complexity.FirewallRule.ID == nil {
			break
		}

		return e.complexity.FirewallRule.ID(childComplexity), true

	case "FirewallRule.inInterface":
		if e.complexity.FirewallRule.InInterface == nil {
			break
		}

		return e.complexity.FirewallRule.InInterface(childComplexity), true

	case "FirewallRule.outInterface":
		if e.complexity.FirewallRule.OutInterface == nil {
			break
		}

		return e.complexity.FirewallRule.OutInterface(childComplexity), true

	case "FirewallRuleResource.action":
		if e.complexity.FirewallRuleResource.Action == nil {
			break
		}

		return e.complexity.FirewallRuleResource.Action(childComplexity), true

	case "FirewallRuleResource.category":
		if e.complexity.FirewallRuleResource.Category == nil {
			break
		}

		return e.complexity.FirewallRuleResource.Category(childComplexity), true

	case "FirewallRuleResource.chain":
		if e.complexity.FirewallRuleResource.Chain == nil {
			break
		}

		return e.complexity.FirewallRuleResource.Chain(childComplexity), true

	case "FirewallRuleResource.comment":
		if e.complexity.FirewallRuleResource.Comment == nil {
			break
		}

		return e.complexity.FirewallRuleResource.Comment(childComplexity), true

	case "FirewallRuleResource.configuration":
		if e.complexity.FirewallRuleResource.Configuration == nil {
			break
		}

		return e.complexity.FirewallRuleResource.Configuration(childComplexity), true

	case "FirewallRuleResource.deployment":
		if e.complexity.FirewallRuleResource.Deployment == nil {
			break
		}

		return e.complexity.FirewallRuleResource.Deployment(childComplexity), true

	case "FirewallRuleResource.dstAddress":
		if e.complexity.FirewallRuleResource.DstAddress == nil {
			break
		}

		return e.complexity.FirewallRuleResource.DstAddress(childComplexity), true

	case "FirewallRuleResource.dstPort":
		if e.complexity.FirewallRuleResource.DstPort == nil {
			break
		}

		return e.complexity.FirewallRuleResource.DstPort(childComplexity), true

	case "FirewallRuleResource.enabled":
		if e.complexity.FirewallRuleResource.Enabled == nil {
			break
		}

		return e.complexity.FirewallRuleResource.Enabled(childComplexity), true

	case "FirewallRuleResource.hitCount":
		if e.complexity.FirewallRuleResource.HitCount == nil {
			break
		}

		return e.complexity.FirewallRuleResource.HitCount(childComplexity), true

	case "FirewallRuleResource.id":
		if e.complexity.FirewallRuleResource.ID == nil {
			break
		}

		return e.complexity.FirewallRuleResource.ID(childComplexity), true

	case "FirewallRuleResource.metadata":
		if e.complexity.FirewallRuleResource.Metadata == nil {
			break
		}

		return e.complexity.FirewallRuleResource.Metadata(childComplexity), true

	case "FirewallRuleResource.platform":
		if e.complexity.FirewallRuleResource.Platform == nil {
			break
		}

		return e.complexity.FirewallRuleResource.Platform(childComplexity), true

	case "FirewallRuleResource.protocol":
		if e.complexity.FirewallRuleResource.Protocol == nil {
			break
		}

		return e.complexity.FirewallRuleResource.Protocol(childComplexity), true

	case "FirewallRuleResource.relationships":
		if e.complexity.FirewallRuleResource.Relationships == nil {
			break
		}

		return e.complexity.FirewallRuleResource.Relationships(childComplexity), true

	case "FirewallRuleResource.runtime":
		if e.complexity.FirewallRuleResource.Runtime == nil {
			break
		}

		return e.complexity.FirewallRuleResource.Runtime(childComplexity), true

	case "FirewallRuleResource.scopedId":
		if e.complexity.FirewallRuleResource.ScopedID == nil {
			break
		}

		return e.complexity.FirewallRuleResource.ScopedID(childComplexity), true

	case "FirewallRuleResource.srcAddress":
		if e.complexity.FirewallRuleResource.SrcAddress == nil {
			break
		}

		return e.complexity.FirewallRuleResource.SrcAddress(childComplexity), true

	case "FirewallRuleResource.srcPort":
		if e.complexity.FirewallRuleResource.SrcPort == nil {
			break
		}

		return e.complexity.FirewallRuleResource.SrcPort(childComplexity), true

	case "FirewallRuleResource.telemetry":
		if e.complexity.FirewallRuleResource.Telemetry == nil {
			break
		}

		return e.complexity.FirewallRuleResource.Telemetry(childComplexity), true

	case "FirewallRuleResource.type":
		if e.complexity.FirewallRuleResource.Type == nil {
			break
		}

		return e.complexity.FirewallRuleResource.Type(childComplexity), true

	case "FirewallRuleResource.validation":
		if e.complexity.FirewallRuleResource.Validation == nil {
			break
		}

		return e.complexity.FirewallRuleResource.Validation(childComplexity), true

	case "GatewayReachabilityResult.interface":
		if e.complexity.GatewayReachabilityResult.Interface == nil {
			break
		}

		return e.complexity.GatewayReachabilityResult.Interface(childComplexity), true

	case "GatewayReachabilityResult.latency":
		if e.complexity.GatewayReachabilityResult.Latency == nil {
			break
		}

		return e.complexity.GatewayReachabilityResult.Latency(childComplexity), true

	case "GatewayReachabilityResult.message":
		if e.complexity.GatewayReachabilityResult.Message == nil {
			break
		}

		return e.complexity.GatewayReachabilityResult.Message(childComplexity), true

	case "GatewayReachabilityResult.reachable":
		if e.complexity.GatewayReachabilityResult.Reachable == nil {
			break
		}

		return e.complexity.GatewayReachabilityResult.Reachable(childComplexity), true

	case "HardwareInfo.architecture":
		if e.complexity.HardwareInfo.Architecture == nil {
			break
		}

		return e.complexity.HardwareInfo.Architecture(childComplexity), true

	case "HardwareInfo.availableStorage":
		if e.complexity.HardwareInfo.AvailableStorage == nil {
			break
		}

		return e.complexity.HardwareInfo.AvailableStorage(childComplexity), true

	case "HardwareInfo.boardName":
		if e.complexity.HardwareInfo.BoardName == nil {
			break
		}

		return e.complexity.HardwareInfo.BoardName(childComplexity), true

	case "HardwareInfo.cpuCount":
		if e.complexity.HardwareInfo.CPUCount == nil {
			break
		}

		return e.complexity.HardwareInfo.CPUCount(childComplexity), true

	case "HardwareInfo.hasLTEModule":
		if e.complexity.HardwareInfo.HasLTEModule == nil {
			break
		}

		return e.complexity.HardwareInfo.HasLTEModule(childComplexity), true

	case "HardwareInfo.hasWirelessChip":
		if e.complexity.HardwareInfo.HasWirelessChip == nil {
			break
		}

		return e.complexity.HardwareInfo.HasWirelessChip(childComplexity), true

	case "HardwareInfo.model":
		if e.complexity.HardwareInfo.Model == nil {
			break
		}

		return e.complexity.HardwareInfo.Model(childComplexity), true

	case "HardwareInfo.totalMemory":
		if e.complexity.HardwareInfo.TotalMemory == nil {
			break
		}

		return e.complexity.HardwareInfo.TotalMemory(childComplexity), true

	case "HealthCheckResult.checkedAt":
		if e.complexity.HealthCheckResult.CheckedAt == nil {
			break
		}

		return e.complexity.HealthCheckResult.CheckedAt(childComplexity), true

	case "HealthCheckResult.error":
		if e.complexity.HealthCheckResult.Error == nil {
			break
		}

		return e.complexity.HealthCheckResult.Error(childComplexity), true

	case "HealthCheckResult.healthy":
		if e.complexity.HealthCheckResult.Healthy == nil {
			break
		}

		return e.complexity.HealthCheckResult.Healthy(childComplexity), true

	case "HealthCheckResult.responseTimeMs":
		if e.complexity.HealthCheckResult.ResponseTimeMs == nil {
			break
		}

		return e.complexity.HealthCheckResult.ResponseTimeMs(childComplexity), true

	case "HealthCheckResult.routerId":
		if e.complexity.HealthCheckResult.RouterID == nil {
			break
		}

		return e.complexity.HealthCheckResult.RouterID(childComplexity), true

	case "HealthStatus.checkedAt":
		if e.complexity.HealthStatus.CheckedAt == nil {
			break
		}

		return e.complexity.HealthStatus.CheckedAt(childComplexity), true

	case "HealthStatus.connectedRouters":
		if e.complexity.HealthStatus.ConnectedRouters == nil {
			break
		}

		return e.complexity.HealthStatus.ConnectedRouters(childComplexity), true

	case "HealthStatus.status":
		if e.complexity.HealthStatus.Status == nil {
			break
		}

		return e.complexity.HealthStatus.Status(childComplexity), true

	case "HealthStatus.uptime":
		if e.complexity.HealthStatus.Uptime == nil {
			break
		}

		return e.complexity.HealthStatus.Uptime(childComplexity), true

	case "HealthStatus.version":
		if e.complexity.HealthStatus.Version == nil {
			break
		}

		return e.complexity.HealthStatus.Version(childComplexity), true

	case "HopProbe.icmpCode":
		if e.complexity.HopProbe.ICMPCode == nil {
			break
		}

		return e.complexity.HopProbe.ICMPCode(childComplexity), true

	case "HopProbe.latencyMs":
		if e.complexity.HopProbe.LatencyMs == nil {
			break
		}

		return e.complexity.HopProbe.LatencyMs(childComplexity), true

	case "HopProbe.probeNumber":
		if e.complexity.HopProbe.ProbeNumber == nil {
			break
		}

		return e.complexity.HopProbe.ProbeNumber(childComplexity), true

	case "HopProbe.success":
		if e.complexity.HopProbe.Success == nil {
			break
		}

		return e.complexity.HopProbe.Success(childComplexity), true

	case "HourlyStats.errorCount":
		if e.complexity.HourlyStats.ErrorCount == nil {
			break
		}

		return e.complexity.HourlyStats.ErrorCount(childComplexity), true

	case "HourlyStats.hour":
		if e.complexity.HourlyStats.Hour == nil {
			break
		}

		return e.complexity.HourlyStats.Hour(childComplexity), true

	case "HourlyStats.totalBytesIn":
		if e.complexity.HourlyStats.TotalBytesIn == nil {
			break
		}

		return e.complexity.HourlyStats.TotalBytesIn(childComplexity), true

	case "HourlyStats.totalBytesOut":
		if e.complexity.HourlyStats.TotalBytesOut == nil {
			break
		}

		return e.complexity.HourlyStats.TotalBytesOut(childComplexity), true

	case "HourlyStats.uptimePercent":
		if e.complexity.HourlyStats.UptimePercent == nil {
			break
		}

		return e.complexity.HourlyStats.UptimePercent(childComplexity), true

	case "ISPInfo.name":
		if e.complexity.ISPInfo.Name == nil {
			break
		}

		return e.complexity.ISPInfo.Name(childComplexity), true

	case "ISPInfo.phone":
		if e.complexity.ISPInfo.Phone == nil {
			break
		}

		return e.complexity.ISPInfo.Phone(childComplexity), true

	case "ISPInfo.url":
		if e.complexity.ISPInfo.URL == nil {
			break
		}

		return e.complexity.ISPInfo.URL(childComplexity), true

	case "Interface.comment":
		if e.complexity.Interface.Comment == nil {
			break
		}

		return e.complexity.Interface.Comment(childComplexity), true

	case "Interface.enabled":
		if e.complexity.Interface.Enabled == nil {
			break
		}

		return e.complexity.Interface.Enabled(childComplexity), true

	case "Interface.id":
		if e.complexity.Interface.ID == nil {
			break
		}

		return e.complexity.Interface.ID(childComplexity), true

	case "Interface.ip":
		if e.complexity.Interface.IP == nil {
			break
		}

		return e.complexity.Interface.IP(childComplexity), true

	case "Interface.lastSeen":
		if e.complexity.Interface.LastSeen == nil {
			break
		}

		return e.complexity.Interface.LastSeen(childComplexity), true

	case "Interface.linkPartner":
		if e.complexity.Interface.LinkPartner == nil {
			break
		}

		return e.complexity.Interface.LinkPartner(childComplexity), true

	case "Interface.linkSpeed":
		if e.complexity.Interface.LinkSpeed == nil {
			break
		}

		return e.complexity.Interface.LinkSpeed(childComplexity), true

	case "Interface.macAddress":
		if e.complexity.Interface.MacAddress == nil {
			break
		}

		return e.complexity.Interface.MacAddress(childComplexity), true

	case "Interface.mtu":
		if e.complexity.Interface.Mtu == nil {
			break
		}

		return e.complexity.Interface.Mtu(childComplexity), true

	case "Interface.name":
		if e.complexity.Interface.Name == nil {
			break
		}

		return e.complexity.Interface.Name(childComplexity), true

	case "Interface.running":
		if e.complexity.Interface.Running == nil {
			break
		}

		return e.complexity.Interface.Running(childComplexity), true

	case "Interface.rxBytes":
		if e.complexity.Interface.RxBytes == nil {
			break
		}

		return e.complexity.Interface.RxBytes(childComplexity), true

	case "Interface.rxRate":
		if e.complexity.Interface.RxRate == nil {
			break
		}

		return e.complexity.Interface.RxRate(childComplexity), true

	case "Interface.status":
		if e.complexity.Interface.Status == nil {
			break
		}

		return e.complexity.Interface.Status(childComplexity), true

	case "Interface.txBytes":
		if e.complexity.Interface.TxBytes == nil {
			break
		}

		return e.complexity.Interface.TxBytes(childComplexity), true

	case "Interface.txRate":
		if e.complexity.Interface.TxRate == nil {
			break
		}

		return e.complexity.Interface.TxRate(childComplexity), true

	case "Interface.type":
		if e.complexity.Interface.Type == nil {
			break
		}

		return e.complexity.Interface.Type(childComplexity), true

	case "Interface.usedBy":
		if e.complexity.Interface.UsedBy == nil {
			break
		}

		return e.complexity.Interface.UsedBy(childComplexity), true

	case "InterfaceConnection.edges":
		if e.complexity.InterfaceConnection.Edges == nil {
			break
		}

		return e.complexity.InterfaceConnection.Edges(childComplexity), true

	case "InterfaceConnection.pageInfo":
		if e.complexity.InterfaceConnection.PageInfo == nil {
			break
		}

		return e.complexity.InterfaceConnection.PageInfo(childComplexity), true

	case "InterfaceConnection.totalCount":
		if e.complexity.InterfaceConnection.TotalCount == nil {
			break
		}

		return e.complexity.InterfaceConnection.TotalCount(childComplexity), true

	case "InterfaceEdge.cursor":
		if e.complexity.InterfaceEdge.Cursor == nil {
			break
		}

		return e.complexity.InterfaceEdge.Cursor(childComplexity), true

	case "InterfaceEdge.node":
		if e.complexity.InterfaceEdge.Node == nil {
			break
		}

		return e.complexity.InterfaceEdge.Node(childComplexity), true

	case "InterfaceOperationError.error":
		if e.complexity.InterfaceOperationError.Error == nil {
			break
		}

		return e.complexity.InterfaceOperationError.Error(childComplexity), true

	case "InterfaceOperationError.interfaceId":
		if e.complexity.InterfaceOperationError.InterfaceID == nil {
			break
		}

		return e.complexity.InterfaceOperationError.InterfaceID(childComplexity), true

	case "InterfaceOperationError.interfaceName":
		if e.complexity.InterfaceOperationError.InterfaceName == nil {
			break
		}

		return e.complexity.InterfaceOperationError.InterfaceName(childComplexity), true

	case "InterfaceStats.rxBytes":
		if e.complexity.InterfaceStats.RxBytes == nil {
			break
		}

		return e.complexity.InterfaceStats.RxBytes(childComplexity), true

	case "InterfaceStats.rxDrops":
		if e.complexity.InterfaceStats.RxDrops == nil {
			break
		}

		return e.complexity.InterfaceStats.RxDrops(childComplexity), true

	case "InterfaceStats.rxErrors":
		if e.complexity.InterfaceStats.RxErrors == nil {
			break
		}

		return e.complexity.InterfaceStats.RxErrors(childComplexity), true

	case "InterfaceStats.rxPackets":
		if e.complexity.InterfaceStats.RxPackets == nil {
			break
		}

		return e.complexity.InterfaceStats.RxPackets(childComplexity), true

	case "InterfaceStats.txBytes":
		if e.complexity.InterfaceStats.TxBytes == nil {
			break
		}

		return e.complexity.InterfaceStats.TxBytes(childComplexity), true

	case "InterfaceStats.txDrops":
		if e.complexity.InterfaceStats.TxDrops == nil {
			break
		}

		return e.complexity.InterfaceStats.TxDrops(childComplexity), true

	case "InterfaceStats.txErrors":
		if e.complexity.InterfaceStats.TxErrors == nil {
			break
		}

		return e.complexity.InterfaceStats.TxErrors(childComplexity), true

	case "InterfaceStats.txPackets":
		if e.complexity.InterfaceStats.TxPackets == nil {
			break
		}

		return e.complexity.InterfaceStats.TxPackets(childComplexity), true

	case "InterfaceStatsHistory.dataPoints":
		if e.complexity.InterfaceStatsHistory.DataPoints == nil {
			break
		}

		return e.complexity.InterfaceStatsHistory.DataPoints(childComplexity), true

	case "InterfaceStatsHistory.endTime":
		if e.complexity.InterfaceStatsHistory.EndTime == nil {
			break
		}

		return e.complexity.InterfaceStatsHistory.EndTime(childComplexity), true

	case "InterfaceStatsHistory.interfaceId":
		if e.complexity.InterfaceStatsHistory.InterfaceID == nil {
			break
		}

		return e.complexity.InterfaceStatsHistory.InterfaceID(childComplexity), true

	case "InterfaceStatsHistory.interval":
		if e.complexity.InterfaceStatsHistory.Interval == nil {
			break
		}

		return e.complexity.InterfaceStatsHistory.Interval(childComplexity), true

	case "InterfaceStatsHistory.startTime":
		if e.complexity.InterfaceStatsHistory.StartTime == nil {
			break
		}

		return e.complexity.InterfaceStatsHistory.StartTime(childComplexity), true

	case "InterfaceStatusEvent.interfaceId":
		if e.complexity.InterfaceStatusEvent.InterfaceID == nil {
			break
		}

		return e.complexity.InterfaceStatusEvent.InterfaceID(childComplexity), true

	case "InterfaceStatusEvent.interfaceName":
		if e.complexity.InterfaceStatusEvent.InterfaceName == nil {
			break
		}

		return e.complexity.InterfaceStatusEvent.InterfaceName(childComplexity), true

	case "InterfaceStatusEvent.previousStatus":
		if e.complexity.InterfaceStatusEvent.PreviousStatus == nil {
			break
		}

		return e.complexity.InterfaceStatusEvent.PreviousStatus(childComplexity), true

	case "InterfaceStatusEvent.status":
		if e.complexity.InterfaceStatusEvent.Status == nil {
			break
		}

		return e.complexity.InterfaceStatusEvent.Status(childComplexity), true

	case "InterfaceStatusEvent.timestamp":
		if e.complexity.InterfaceStatusEvent.Timestamp == nil {
			break
		}

		return e.complexity.InterfaceStatusEvent.Timestamp(childComplexity), true

	case "InterfaceTrafficEvent.interfaceId":
		if e.complexity.InterfaceTrafficEvent.InterfaceID == nil {
			break
		}

		return e.complexity.InterfaceTrafficEvent.InterfaceID(childComplexity), true

	case "InterfaceTrafficEvent.interfaceName":
		if e.complexity.InterfaceTrafficEvent.InterfaceName == nil {
			break
		}

		return e.complexity.InterfaceTrafficEvent.InterfaceName(childComplexity), true

	case "InterfaceTrafficEvent.rxRate":
		if e.complexity.InterfaceTrafficEvent.RxRate == nil {
			break
		}

		return e.complexity.InterfaceTrafficEvent.RxRate(childComplexity), true

	case "InterfaceTrafficEvent.rxTotal":
		if e.complexity.InterfaceTrafficEvent.RxTotal == nil {
			break
		}

		return e.complexity.InterfaceTrafficEvent.RxTotal(childComplexity), true

	case "InterfaceTrafficEvent.timestamp":
		if e.complexity.InterfaceTrafficEvent.Timestamp == nil {
			break
		}

		return e.complexity.InterfaceTrafficEvent.Timestamp(childComplexity), true

	case "InterfaceTrafficEvent.txRate":
		if e.complexity.InterfaceTrafficEvent.TxRate == nil {
			break
		}

		return e.complexity.InterfaceTrafficEvent.TxRate(childComplexity), true

	case "InterfaceTrafficEvent.txTotal":
		if e.complexity.InterfaceTrafficEvent.TxTotal == nil {
			break
		}

		return e.complexity.InterfaceTrafficEvent.TxTotal(childComplexity), true

	case "IpAddress.address":
		if e.complexity.IpAddress.Address == nil {
			break
		}

		return e.complexity.IpAddress.Address(childComplexity), true

	case "IpAddress.broadcast":
		if e.complexity.IpAddress.Broadcast == nil {
			break
		}

		return e.complexity.IpAddress.Broadcast(childComplexity), true

	case "IpAddress.comment":
		if e.complexity.IpAddress.Comment == nil {
			break
		}

		return e.complexity.IpAddress.Comment(childComplexity), true

	case "IpAddress.disabled":
		if e.complexity.IpAddress.Disabled == nil {
			break
		}

		return e.complexity.IpAddress.Disabled(childComplexity), true

	case "IpAddress.dynamic":
		if e.complexity.IpAddress.Dynamic == nil {
			break
		}

		return e.complexity.IpAddress.Dynamic(childComplexity), true

	case "IpAddress.id":
		if e.complexity.IpAddress.ID == nil {
			break
		}

		return e.complexity.IpAddress.ID(childComplexity), true

	case "IpAddress.interface":
		if e.complexity.IpAddress.Interface == nil {
			break
		}

		return e.complexity.IpAddress.Interface(childComplexity), true

	case "IpAddress.invalid":
		if e.complexity.IpAddress.Invalid == nil {
			break
		}

		return e.complexity.IpAddress.Invalid(childComplexity), true

	case "IpAddress.network":
		if e.complexity.IpAddress.Network == nil {
			break
		}

		return e.complexity.IpAddress.Network(childComplexity), true

	case "IpAddressChangeEvent.changeType":
		if e.complexity.IpAddressChangeEvent.ChangeType == nil {
			break
		}

		return e.complexity.IpAddressChangeEvent.ChangeType(childComplexity), true

	case "IpAddressChangeEvent.ipAddress":
		if e.complexity.IpAddressChangeEvent.IPAddress == nil {
			break
		}

		return e.complexity.IpAddressChangeEvent.IPAddress(childComplexity), true

	case "IpAddressChangeEvent.ipAddressId":
		if e.complexity.IpAddressChangeEvent.IPAddressID == nil {
			break
		}

		return e.complexity.IpAddressChangeEvent.IPAddressID(childComplexity), true

	case "IpAddressChangeEvent.timestamp":
		if e.complexity.IpAddressChangeEvent.Timestamp == nil {
			break
		}

		return e.complexity.IpAddressChangeEvent.Timestamp(childComplexity), true

	case "IpAddressDeleteResult.errors":
		if e.complexity.IpAddressDeleteResult.Errors == nil {
			break
		}

		return e.complexity.IpAddressDeleteResult.Errors(childComplexity), true

	case "IpAddressDeleteResult.impactAnalysis":
		if e.complexity.IpAddressDeleteResult.ImpactAnalysis == nil {
			break
		}

		return e.complexity.IpAddressDeleteResult.ImpactAnalysis(childComplexity), true

	case "IpAddressDeleteResult.message":
		if e.complexity.IpAddressDeleteResult.Message == nil {
			break
		}

		return e.complexity.IpAddressDeleteResult.Message(childComplexity), true

	case "IpAddressDeleteResult.success":
		if e.complexity.IpAddressDeleteResult.Success == nil {
			break
		}

		return e.complexity.IpAddressDeleteResult.Success(childComplexity), true

	case "IpAddressDependencies.dhcpServers":
		if e.complexity.IpAddressDependencies.DhcpServers == nil {
			break
		}

		return e.complexity.IpAddressDependencies.DhcpServers(childComplexity), true

	case "IpAddressDependencies.firewallRules":
		if e.complexity.IpAddressDependencies.FirewallRules == nil {
			break
		}

		return e.complexity.IpAddressDependencies.FirewallRules(childComplexity), true

	case "IpAddressDependencies.hasDependencies":
		if e.complexity.IpAddressDependencies.HasDependencies == nil {
			break
		}

		return e.complexity.IpAddressDependencies.HasDependencies(childComplexity), true

	case "IpAddressDependencies.ipAddressId":
		if e.complexity.IpAddressDependencies.IPAddressID == nil {
			break
		}

		return e.complexity.IpAddressDependencies.IPAddressID(childComplexity), true

	case "IpAddressDependencies.natRules":
		if e.complexity.IpAddressDependencies.NatRules == nil {
			break
		}

		return e.complexity.IpAddressDependencies.NatRules(childComplexity), true

	case "IpAddressDependencies.routes":
		if e.complexity.IpAddressDependencies.Routes == nil {
			break
		}

		return e.complexity.IpAddressDependencies.Routes(childComplexity), true

	case "IpAddressImpactAnalysis.activeConnections":
		if e.complexity.IpAddressImpactAnalysis.ActiveConnections == nil {
			break
		}

		return e.complexity.IpAddressImpactAnalysis.ActiveConnections(childComplexity), true

	case "IpAddressImpactAnalysis.canDelete":
		if e.complexity.IpAddressImpactAnalysis.CanDelete == nil {
			break
		}

		return e.complexity.IpAddressImpactAnalysis.CanDelete(childComplexity), true

	case "IpAddressImpactAnalysis.consequences":
		if e.complexity.IpAddressImpactAnalysis.Consequences == nil {
			break
		}

		return e.complexity.IpAddressImpactAnalysis.Consequences(childComplexity), true

	case "IpAddressImpactAnalysis.message":
		if e.complexity.IpAddressImpactAnalysis.Message == nil {
			break
		}

		return e.complexity.IpAddressImpactAnalysis.Message(childComplexity), true

	case "IpAddressImpactAnalysis.severity":
		if e.complexity.IpAddressImpactAnalysis.Severity == nil {
			break
		}

		return e.complexity.IpAddressImpactAnalysis.Severity(childComplexity), true

	case "IpAddressImpactAnalysis.usedByDhcpServers":
		if e.complexity.IpAddressImpactAnalysis.UsedByDhcpServers == nil {
			break
		}

		return e.complexity.IpAddressImpactAnalysis.UsedByDhcpServers(childComplexity), true

	case "IpAddressImpactAnalysis.usedInFirewallRules":
		if e.complexity.IpAddressImpactAnalysis.UsedInFirewallRules == nil {
			break
		}

		return e.complexity.IpAddressImpactAnalysis.UsedInFirewallRules(childComplexity), true

	case "IpAddressImpactAnalysis.usedInNatRules":
		if e.complexity.IpAddressImpactAnalysis.UsedInNatRules == nil {
			break
		}

		return e.complexity.IpAddressImpactAnalysis.UsedInNatRules(childComplexity), true

	case "IpAddressMutationResult.errors":
		if e.complexity.IpAddressMutationResult.Errors == nil {
			break
		}

		return e.complexity.IpAddressMutationResult.Errors(childComplexity), true

	case "IpAddressMutationResult.ipAddress":
		if e.complexity.IpAddressMutationResult.IPAddress == nil {
			break
		}

		return e.complexity.IpAddressMutationResult.IPAddress(childComplexity), true

	case "IpAddressMutationResult.preview":
		if e.complexity.IpAddressMutationResult.Preview == nil {
			break
		}

		return e.complexity.IpAddressMutationResult.Preview(childComplexity), true

	case "IpAddressMutationResult.success":
		if e.complexity.IpAddressMutationResult.Success == nil {
			break
		}

		return e.complexity.IpAddressMutationResult.Success(childComplexity), true

	case "IpConflict.address":
		if e.complexity.IpConflict.Address == nil {
			break
		}

		return e.complexity.IpConflict.Address(childComplexity), true

	case "IpConflict.conflictType":
		if e.complexity.IpConflict.ConflictType == nil {
			break
		}

		return e.complexity.IpConflict.ConflictType(childComplexity), true

	case "IpConflict.explanation":
		if e.complexity.IpConflict.Explanation == nil {
			break
		}

		return e.complexity.IpConflict.Explanation(childComplexity), true

	case "IpConflict.id":
		if e.complexity.IpConflict.ID == nil {
			break
		}

		return e.complexity.IpConflict.ID(childComplexity), true

	case "IpConflict.interface":
		if e.complexity.IpConflict.Interface == nil {
			break
		}

		return e.complexity.IpConflict.Interface(childComplexity), true

	case "IpConflictResult.conflicts":
		if e.complexity.IpConflictResult.Conflicts == nil {
			break
		}

		return e.complexity.IpConflictResult.Conflicts(childComplexity), true

	case "IpConflictResult.hasConflict":
		if e.complexity.IpConflictResult.HasConflict == nil {
			break
		}

		return e.complexity.IpConflictResult.HasConflict(childComplexity), true

	case "IpConflictResult.message":
		if e.complexity.IpConflictResult.Message == nil {
			break
		}

		return e.complexity.IpConflictResult.Message(childComplexity), true

	case "LANNetwork.bridge":
		if e.complexity.LANNetwork.Bridge == nil {
			break
		}

		return e.complexity.LANNetwork.Bridge(childComplexity), true

	case "LANNetwork.category":
		if e.complexity.LANNetwork.Category == nil {
			break
		}

		return e.complexity.LANNetwork.Category(childComplexity), true

	case "LANNetwork.config":
		if e.complexity.LANNetwork.Config == nil {
			break
		}

		return e.complexity.LANNetwork.Config(childComplexity), true

	case "LANNetwork.configuration":
		if e.complexity.LANNetwork.Configuration == nil {
			break
		}

		return e.complexity.LANNetwork.Configuration(childComplexity), true

	case "LANNetwork.deployment":
		if e.complexity.LANNetwork.Deployment == nil {
			break
		}

		return e.complexity.LANNetwork.Deployment(childComplexity), true

	case "LANNetwork.dhcpServer":
		if e.complexity.LANNetwork.DhcpServer == nil {
			break
		}

		return e.complexity.LANNetwork.DhcpServer(childComplexity), true

	case "LANNetwork.firewallRules":
		if e.complexity.LANNetwork.FirewallRules == nil {
			break
		}

		return e.complexity.LANNetwork.FirewallRules(childComplexity), true

	case "LANNetwork.id":
		if e.complexity.LANNetwork.ID == nil {
			break
		}

		return e.complexity.LANNetwork.ID(childComplexity), true

	case "LANNetwork.lanDeployment":
		if e.complexity.LANNetwork.LanDeployment == nil {
			break
		}

		return e.complexity.LANNetwork.LanDeployment(childComplexity), true

	case "LANNetwork.lanRuntime":
		if e.complexity.LANNetwork.LanRuntime == nil {
			break
		}

		return e.complexity.LANNetwork.LanRuntime(childComplexity), true

	case "LANNetwork.metadata":
		if e.complexity.LANNetwork.Metadata == nil {
			break
		}

		return e.complexity.LANNetwork.Metadata(childComplexity), true

	case "LANNetwork.platform":
		if e.complexity.LANNetwork.Platform == nil {
			break
		}

		return e.complexity.LANNetwork.Platform(childComplexity), true

	case "LANNetwork.relationships":
		if e.complexity.LANNetwork.Relationships == nil {
			break
		}

		return e.complexity.LANNetwork.Relationships(childComplexity), true

	case "LANNetwork.routes":
		if e.complexity.LANNetwork.Routes == nil {
			break
		}

		return e.complexity.LANNetwork.Routes(childComplexity), true

	case "LANNetwork.runtime":
		if e.complexity.LANNetwork.Runtime == nil {
			break
		}

		return e.complexity.LANNetwork.Runtime(childComplexity), true

	case "LANNetwork.scopedId":
		if e.complexity.LANNetwork.ScopedID == nil {
			break
		}

		return e.complexity.LANNetwork.ScopedID(childComplexity), true

	case "LANNetwork.telemetry":
		if e.complexity.LANNetwork.Telemetry == nil {
			break
		}

		return e.complexity.LANNetwork.Telemetry(childComplexity), true

	case "LANNetwork.type":
		if e.complexity.LANNetwork.Type == nil {
			break
		}

		return e.complexity.LANNetwork.Type(childComplexity), true

	case "LANNetwork.validation":
		if e.complexity.LANNetwork.Validation == nil {
			break
		}

		return e.complexity.LANNetwork.Validation(childComplexity), true

	case "LANNetworkConfig.dnsServers":
		if e.complexity.LANNetworkConfig.DNSServers == nil {
			break
		}

		return e.complexity.LANNetworkConfig.DNSServers(childComplexity), true

	case "LANNetworkConfig.dhcpEnabled":
		if e.complexity.LANNetworkConfig.DhcpEnabled == nil {
			break
		}

		return e.complexity.LANNetworkConfig.DhcpEnabled(childComplexity), true

	case "LANNetworkConfig.dhcpLeaseTime":
		if e.complexity.LANNetworkConfig.DhcpLeaseTime == nil {
			break
		}

		return e.complexity.LANNetworkConfig.DhcpLeaseTime(childComplexity), true

	case "LANNetworkConfig.dhcpPoolEnd":
		if e.complexity.LANNetworkConfig.DhcpPoolEnd == nil {
			break
		}

		return e.complexity.LANNetworkConfig.DhcpPoolEnd(childComplexity), true

	case "LANNetworkConfig.dhcpPoolStart":
		if e.complexity.LANNetworkConfig.DhcpPoolStart == nil {
			break
		}

		return e.complexity.LANNetworkConfig.DhcpPoolStart(childComplexity), true

	case "LANNetworkConfig.enableNat":
		if e.complexity.LANNetworkConfig.EnableNat == nil {
			break
		}

		return e.complexity.LANNetworkConfig.EnableNat(childComplexity), true

	case "LANNetworkConfig.ipAddress":
		if e.complexity.LANNetworkConfig.IPAddress == nil {
			break
		}

		return e.complexity.LANNetworkConfig.IPAddress(childComplexity), true

	case "LANNetworkConfig.interfaces":
		if e.complexity.LANNetworkConfig.Interfaces == nil {
			break
		}

		return e.complexity.LANNetworkConfig.Interfaces(childComplexity), true

	case "LANNetworkConfig.name":
		if e.complexity.LANNetworkConfig.Name == nil {
			break
		}

		return e.complexity.LANNetworkConfig.Name(childComplexity), true

	case "LANNetworkConfig.subnetMask":
		if e.complexity.LANNetworkConfig.SubnetMask == nil {
			break
		}

		return e.complexity.LANNetworkConfig.SubnetMask(childComplexity), true

	case "LANNetworkConfig.vlanId":
		if e.complexity.LANNetworkConfig.VlanID == nil {
			break
		}

		return e.complexity.LANNetworkConfig.VlanID(childComplexity), true

	case "LANNetworkDeployment.appliedAt":
		if e.complexity.LANNetworkDeployment.AppliedAt == nil {
			break
		}

		return e.complexity.LANNetworkDeployment.AppliedAt(childComplexity), true

	case "LANNetworkDeployment.appliedBy":
		if e.complexity.LANNetworkDeployment.AppliedBy == nil {
			break
		}

		return e.complexity.LANNetworkDeployment.AppliedBy(childComplexity), true

	case "LANNetworkDeployment.bridgeId":
		if e.complexity.LANNetworkDeployment.BridgeID == nil {
			break
		}

		return e.complexity.LANNetworkDeployment.BridgeID(childComplexity), true

	case "LANNetworkDeployment.dhcpServerId":
		if e.complexity.LANNetworkDeployment.DhcpServerID == nil {
			break
		}

		return e.complexity.LANNetworkDeployment.DhcpServerID(childComplexity), true

	case "LANNetworkDeployment.drift":
		if e.complexity.LANNetworkDeployment.Drift == nil {
			break
		}

		return e.complexity.LANNetworkDeployment.Drift(childComplexity), true

	case "LANNetworkDeployment.ipAddressId":
		if e.complexity.LANNetworkDeployment.IPAddressID == nil {
			break
		}

		return e.complexity.LANNetworkDeployment.IPAddressID(childComplexity), true

	case "LANNetworkDeployment.isInSync":
		if e.complexity.LANNetworkDeployment.IsInSync == nil {
			break
		}

		return e.complexity.LANNetworkDeployment.IsInSync(childComplexity), true

	case "LANNetworkDeployment.routerResourceId":
		if e.complexity.LANNetworkDeployment.RouterResourceID == nil {
			break
		}

		return e.complexity.LANNetworkDeployment.RouterResourceID(childComplexity), true

	case "LANNetworkDeployment.routerVersion":
		if e.complexity.LANNetworkDeployment.RouterVersion == nil {
			break
		}

		return e.complexity.LANNetworkDeployment.RouterVersion(childComplexity), true

	case "LANNetworkRuntime.activeClients":
		if e.complexity.LANNetworkRuntime.ActiveClients == nil {
			break
		}

		return e.complexity.LANNetworkRuntime.ActiveClients(childComplexity), true

	case "LANNetworkRuntime.dhcpLeases":
		if e.complexity.LANNetworkRuntime.DhcpLeases == nil {
			break
		}

		return e.complexity.LANNetworkRuntime.DhcpLeases(childComplexity), true

	case "LANNetworkRuntime.errorMessage":
		if e.complexity.LANNetworkRuntime.ErrorMessage == nil {
			break
		}

		return e.complexity.LANNetworkRuntime.ErrorMessage(childComplexity), true

	case "LANNetworkRuntime.health":
		if e.complexity.LANNetworkRuntime.Health == nil {
			break
		}

		return e.complexity.LANNetworkRuntime.Health(childComplexity), true

	case "LANNetworkRuntime.isRunning":
		if e.complexity.LANNetworkRuntime.IsRunning == nil {
			break
		}

		return e.complexity.LANNetworkRuntime.IsRunning(childComplexity), true

	case "LANNetworkRuntime.lastUpdated":
		if e.complexity.LANNetworkRuntime.LastUpdated == nil {
			break
		}

		return e.complexity.LANNetworkRuntime.LastUpdated(childComplexity), true

	case "LANNetworkRuntime.totalBytesIn":
		if e.complexity.LANNetworkRuntime.TotalBytesIn == nil {
			break
		}

		return e.complexity.LANNetworkRuntime.TotalBytesIn(childComplexity), true

	case "LANNetworkRuntime.totalBytesOut":
		if e.complexity.LANNetworkRuntime.TotalBytesOut == nil {
			break
		}

		return e.complexity.LANNetworkRuntime.TotalBytesOut(childComplexity), true

	case "LteModem.apn":
		if e.complexity.LteModem.Apn == nil {
			break
		}

		return e.complexity.LteModem.Apn(childComplexity), true

	case "LteModem.comment":
		if e.complexity.LteModem.Comment == nil {
			break
		}

		return e.complexity.LteModem.Comment(childComplexity), true

	case "LteModem.id":
		if e.complexity.LteModem.ID == nil {
			break
		}

		return e.complexity.LteModem.ID(childComplexity), true

	case "LteModem.name":
		if e.complexity.LteModem.Name == nil {
			break
		}

		return e.complexity.LteModem.Name(childComplexity), true

	case "LteModem.networkType":
		if e.complexity.LteModem.NetworkType == nil {
			break
		}

		return e.complexity.LteModem.NetworkType(childComplexity), true

	case "LteModem.operator":
		if e.complexity.LteModem.Operator == nil {
			break
		}

		return e.complexity.LteModem.Operator(childComplexity), true

	case "LteModem.pinConfigured":
		if e.complexity.LteModem.PinConfigured == nil {
			break
		}

		return e.complexity.LteModem.PinConfigured(childComplexity), true

	case "LteModem.running":
		if e.complexity.LteModem.Running == nil {
			break
		}

		return e.complexity.LteModem.Running(childComplexity), true

	case "LteModem.signalStrength":
		if e.complexity.LteModem.SignalStrength == nil {
			break
		}

		return e.complexity.LteModem.SignalStrength(childComplexity), true

	case "MemoryMetrics.percentage":
		if e.complexity.MemoryMetrics.Percentage == nil {
			break
		}

		return e.complexity.MemoryMetrics.Percentage(childComplexity), true

	case "MemoryMetrics.total":
		if e.complexity.MemoryMetrics.Total == nil {
			break
		}

		return e.complexity.MemoryMetrics.Total(childComplexity), true

	case "MemoryMetrics.used":
		if e.complexity.MemoryMetrics.Used == nil {
			break
		}

		return e.complexity.MemoryMetrics.Used(childComplexity), true

	case "MissingDependency.itemId":
		if e.complexity.MissingDependency.ItemID == nil {
			break
		}

		return e.complexity.MissingDependency.ItemID(childComplexity), true

	case "MissingDependency.missingResourceId":
		if e.complexity.MissingDependency.MissingResourceID == nil {
			break
		}

		return e.complexity.MissingDependency.MissingResourceID(childComplexity), true

	case "MissingDependency.missingResourceType":
		if e.complexity.MissingDependency.MissingResourceType == nil {
			break
		}

		return e.complexity.MissingDependency.MissingResourceType(childComplexity), true

	case "Mutation.acknowledgeAlert":
		if e.complexity.Mutation.AcknowledgeAlert == nil {
			break
		}

		args, err := ec.field_Mutation_acknowledgeAlert_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.AcknowledgeAlert(childComplexity, args["alertId"].(string)), true

	case "Mutation.acknowledgeAlerts":
		if e.complexity.Mutation.AcknowledgeAlerts == nil {
			break
		}

		args, err := ec.field_Mutation_acknowledgeAlerts_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.AcknowledgeAlerts(childComplexity, args["alertIds"].([]string)), true

	case "Mutation.addBridgePort":
		if e.complexity.Mutation.AddBridgePort == nil {
			break
		}

		args, err := ec.field_Mutation_addBridgePort_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.AddBridgePort(childComplexity, args["bridgeId"].(string), args["input"].(model.AddBridgePortInput)), true

	case "Mutation.addChangeSetItem":
		if e.complexity.Mutation.AddChangeSetItem == nil {
			break
		}

		args, err := ec.field_Mutation_addChangeSetItem_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.AddChangeSetItem(childComplexity, args["changeSetId"].(string), args["input"].(model.ChangeSetItemInput)), true

	case "Mutation.addRouter":
		if e.complexity.Mutation.AddRouter == nil {
			break
		}

		args, err := ec.field_Mutation_addRouter_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.AddRouter(childComplexity, args["input"].(model.AddRouterInput)), true

	case "Mutation.applyChangeSet":
		if e.complexity.Mutation.ApplyChangeSet == nil {
			break
		}

		args, err := ec.field_Mutation_applyChangeSet_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.ApplyChangeSet(childComplexity, args["changeSetId"].(string)), true

	case "Mutation.applyResource":
		if e.complexity.Mutation.ApplyResource == nil {
			break
		}

		args, err := ec.field_Mutation_applyResource_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.ApplyResource(childComplexity, args["id"].(string), args["routerId"].(string)), true

	case "Mutation.applyTroubleshootFix":
		if e.complexity.Mutation.ApplyTroubleshootFix == nil {
			break
		}

		args, err := ec.field_Mutation_applyTroubleshootFix_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.ApplyTroubleshootFix(childComplexity, args["sessionId"].(string), args["issueCode"].(string)), true

	case "Mutation.archiveResource":
		if e.complexity.Mutation.ArchiveResource == nil {
			break
		}

		args, err := ec.field_Mutation_archiveResource_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.ArchiveResource(childComplexity, args["id"].(string), args["routerId"].(string)), true

	case "Mutation.autoScanGateways":
		if e.complexity.Mutation.AutoScanGateways == nil {
			break
		}

		return e.complexity.Mutation.AutoScanGateways(childComplexity), true

	case "Mutation.batchInterfaceOperation":
		if e.complexity.Mutation.BatchInterfaceOperation == nil {
			break
		}

		args, err := ec.field_Mutation_batchInterfaceOperation_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.BatchInterfaceOperation(childComplexity, args["routerId"].(string), args["input"].(model.BatchInterfaceInput)), true

	case "Mutation.cancelChangeSet":
		if e.complexity.Mutation.CancelChangeSet == nil {
			break
		}

		args, err := ec.field_Mutation_cancelChangeSet_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CancelChangeSet(childComplexity, args["changeSetId"].(string)), true

	case "Mutation.cancelScan":
		if e.complexity.Mutation.CancelScan == nil {
			break
		}

		args, err := ec.field_Mutation_cancelScan_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CancelScan(childComplexity, args["taskId"].(string)), true

	case "Mutation.cancelTraceroute":
		if e.complexity.Mutation.CancelTraceroute == nil {
			break
		}

		args, err := ec.field_Mutation_cancelTraceroute_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CancelTraceroute(childComplexity, args["jobId"].(string)), true

	case "Mutation.cancelTroubleshoot":
		if e.complexity.Mutation.CancelTroubleshoot == nil {
			break
		}

		args, err := ec.field_Mutation_cancelTroubleshoot_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CancelTroubleshoot(childComplexity, args["sessionId"].(string)), true

	case "Mutation.changePassword":
		if e.complexity.Mutation.ChangePassword == nil {
			break
		}

		args, err := ec.field_Mutation_changePassword_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.ChangePassword(childComplexity, args["currentPassword"].(string), args["newPassword"].(string)), true

	case "Mutation.checkRouterHealth":
		if e.complexity.Mutation.CheckRouterHealth == nil {
			break
		}

		args, err := ec.field_Mutation_checkRouterHealth_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CheckRouterHealth(childComplexity, args["routerId"].(string)), true

	case "Mutation.configureBridgePortVlan":
		if e.complexity.Mutation.ConfigureBridgePortVlan == nil {
			break
		}

		args, err := ec.field_Mutation_configureBridgePortVlan_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.ConfigureBridgePortVlan(childComplexity, args["routerId"].(string), args["portId"].(string), args["input"].(model.BridgePortVlanInput)), true

	case "Mutation.configureDhcpWAN":
		if e.complexity.Mutation.ConfigureDhcpWan == nil {
			break
		}

		args, err := ec.field_Mutation_configureDhcpWAN_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.ConfigureDhcpWan(childComplexity, args["routerId"].(string), args["input"].(model.DhcpClientInput)), true

	case "Mutation.configureLteWAN":
		if e.complexity.Mutation.ConfigureLteWan == nil {
			break
		}

		args, err := ec.field_Mutation_configureLteWAN_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.ConfigureLteWan(childComplexity, args["routerId"].(string), args["input"].(model.LteModemInput)), true

	case "Mutation.configurePppoeWAN":
		if e.complexity.Mutation.ConfigurePppoeWan == nil {
			break
		}

		args, err := ec.field_Mutation_configurePppoeWAN_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.ConfigurePppoeWan(childComplexity, args["routerId"].(string), args["input"].(model.PppoeClientInput)), true

	case "Mutation.configureStaticWAN":
		if e.complexity.Mutation.ConfigureStaticWan == nil {
			break
		}

		args, err := ec.field_Mutation_configureStaticWAN_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.ConfigureStaticWan(childComplexity, args["routerId"].(string), args["input"].(model.StaticIPInput)), true

	case "Mutation.configureWANHealthCheck":
		if e.complexity.Mutation.ConfigureWANHealthCheck == nil {
			break
		}

		args, err := ec.field_Mutation_configureWANHealthCheck_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.ConfigureWANHealthCheck(childComplexity, args["routerId"].(string), args["wanInterfaceId"].(string), args["input"].(model.WANHealthCheckInput)), true

	case "Mutation.connectRouter":
		if e.complexity.Mutation.ConnectRouter == nil {
			break
		}

		args, err := ec.field_Mutation_connectRouter_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.ConnectRouter(childComplexity, args["id"].(string)), true

	case "Mutation.createAlertRule":
		if e.complexity.Mutation.CreateAlertRule == nil {
			break
		}

		args, err := ec.field_Mutation_createAlertRule_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateAlertRule(childComplexity, args["input"].(model.CreateAlertRuleInput)), true

	case "Mutation.createBridge":
		if e.complexity.Mutation.CreateBridge == nil {
			break
		}

		args, err := ec.field_Mutation_createBridge_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateBridge(childComplexity, args["routerId"].(string), args["input"].(model.CreateBridgeInput)), true

	case "Mutation.createBridgeVlan":
		if e.complexity.Mutation.CreateBridgeVlan == nil {
			break
		}

		args, err := ec.field_Mutation_createBridgeVlan_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateBridgeVlan(childComplexity, args["bridgeId"].(string), args["input"].(model.CreateBridgeVlanInput)), true

	case "Mutation.createChangeSet":
		if e.complexity.Mutation.CreateChangeSet == nil {
			break
		}

		args, err := ec.field_Mutation_createChangeSet_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateChangeSet(childComplexity, args["input"].(model.CreateChangeSetInput)), true

	case "Mutation.createIpAddress":
		if e.complexity.Mutation.CreateIPAddress == nil {
			break
		}

		args, err := ec.field_Mutation_createIpAddress_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateIPAddress(childComplexity, args["routerId"].(string), args["input"].(model.IPAddressInput)), true

	case "Mutation.createResource":
		if e.complexity.Mutation.CreateResource == nil {
			break
		}

		args, err := ec.field_Mutation_createResource_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateResource(childComplexity, args["input"].(model.CreateResourceInput)), true

	case "Mutation.createRoute":
		if e.complexity.Mutation.CreateRoute == nil {
			break
		}

		args, err := ec.field_Mutation_createRoute_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateRoute(childComplexity, args["routerId"].(string), args["input"].(model.RouteInput)), true

	case "Mutation.createRouter":
		if e.complexity.Mutation.CreateRouter == nil {
			break
		}

		args, err := ec.field_Mutation_createRouter_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateRouter(childComplexity, args["input"].(model.CreateRouterInput)), true

	case "Mutation.createVlan":
		if e.complexity.Mutation.CreateVlan == nil {
			break
		}

		args, err := ec.field_Mutation_createVlan_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateVlan(childComplexity, args["routerId"].(string), args["input"].(model.VlanInput)), true

	case "Mutation.deleteAlertRule":
		if e.complexity.Mutation.DeleteAlertRule == nil {
			break
		}

		args, err := ec.field_Mutation_deleteAlertRule_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteAlertRule(childComplexity, args["id"].(string)), true

	case "Mutation.deleteBridge":
		if e.complexity.Mutation.DeleteBridge == nil {
			break
		}

		args, err := ec.field_Mutation_deleteBridge_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteBridge(childComplexity, args["uuid"].(string)), true

	case "Mutation.deleteBridgeVlan":
		if e.complexity.Mutation.DeleteBridgeVlan == nil {
			break
		}

		args, err := ec.field_Mutation_deleteBridgeVlan_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteBridgeVlan(childComplexity, args["uuid"].(string)), true

	case "Mutation.deleteChangeSet":
		if e.complexity.Mutation.DeleteChangeSet == nil {
			break
		}

		args, err := ec.field_Mutation_deleteChangeSet_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteChangeSet(childComplexity, args["changeSetId"].(string)), true

	case "Mutation.deleteIpAddress":
		if e.complexity.Mutation.DeleteIPAddress == nil {
			break
		}

		args, err := ec.field_Mutation_deleteIpAddress_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteIPAddress(childComplexity, args["routerId"].(string), args["id"].(string)), true

	case "Mutation.deleteResource":
		if e.complexity.Mutation.DeleteResource == nil {
			break
		}

		args, err := ec.field_Mutation_deleteResource_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteResource(childComplexity, args["id"].(string), args["routerId"].(string)), true

	case "Mutation.deleteRoute":
		if e.complexity.Mutation.DeleteRoute == nil {
			break
		}

		args, err := ec.field_Mutation_deleteRoute_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteRoute(childComplexity, args["routerId"].(string), args["id"].(string)), true

	case "Mutation.deleteRouter":
		if e.complexity.Mutation.DeleteRouter == nil {
			break
		}

		args, err := ec.field_Mutation_deleteRouter_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteRouter(childComplexity, args["id"].(string)), true

	case "Mutation.deleteVlan":
		if e.complexity.Mutation.DeleteVlan == nil {
			break
		}

		args, err := ec.field_Mutation_deleteVlan_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteVlan(childComplexity, args["id"].(string)), true

	case "Mutation.deleteWANConfiguration":
		if e.complexity.Mutation.DeleteWANConfiguration == nil {
			break
		}

		args, err := ec.field_Mutation_deleteWANConfiguration_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteWANConfiguration(childComplexity, args["routerId"].(string), args["wanInterfaceId"].(string)), true

	case "Mutation.deprecateResource":
		if e.complexity.Mutation.DeprecateResource == nil {
			break
		}

		args, err := ec.field_Mutation_deprecateResource_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeprecateResource(childComplexity, args["id"].(string), args["routerId"].(string)), true

	case "Mutation.disableInterface":
		if e.complexity.Mutation.DisableInterface == nil {
			break
		}

		args, err := ec.field_Mutation_disableInterface_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DisableInterface(childComplexity, args["routerId"].(string), args["interfaceId"].(string)), true

	case "Mutation.disconnectRouter":
		if e.complexity.Mutation.DisconnectRouter == nil {
			break
		}

		args, err := ec.field_Mutation_disconnectRouter_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DisconnectRouter(childComplexity, args["id"].(string)), true

	case "Mutation.enableInterface":
		if e.complexity.Mutation.EnableInterface == nil {
			break
		}

		args, err := ec.field_Mutation_enableInterface_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.EnableInterface(childComplexity, args["routerId"].(string), args["interfaceId"].(string)), true

	case "Mutation.exportRouterConfig":
		if e.complexity.Mutation.ExportRouterConfig == nil {
			break
		}

		args, err := ec.field_Mutation_exportRouterConfig_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.ExportRouterConfig(childComplexity, args["input"].(model.ExportConfigInput)), true

	case "Mutation.login":
		if e.complexity.Mutation.Login == nil {
			break
		}

		args, err := ec.field_Mutation_login_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.Login(childComplexity, args["username"].(string), args["password"].(string)), true

	case "Mutation.logout":
		if e.complexity.Mutation.Logout == nil {
			break
		}

		return e.complexity.Mutation.Logout(childComplexity), true

	case "Mutation.reconnectRouter":
		if e.complexity.Mutation.ReconnectRouter == nil {
			break
		}

		args, err := ec.field_Mutation_reconnectRouter_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.ReconnectRouter(childComplexity, args["routerId"].(string)), true

	case "Mutation.refreshCapabilities":
		if e.complexity.Mutation.RefreshCapabilities == nil {
			break
		}

		args, err := ec.field_Mutation_refreshCapabilities_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.RefreshCapabilities(childComplexity, args["routerId"].(string)), true

	case "Mutation.removeBridgePort":
		if e.complexity.Mutation.RemoveBridgePort == nil {
			break
		}

		args, err := ec.field_Mutation_removeBridgePort_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.RemoveBridgePort(childComplexity, args["portId"].(string)), true

	case "Mutation.removeChangeSetItem":
		if e.complexity.Mutation.RemoveChangeSetItem == nil {
			break
		}

		args, err := ec.field_Mutation_removeChangeSetItem_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.RemoveChangeSetItem(childComplexity, args["changeSetId"].(string), args["itemId"].(string)), true

	case "Mutation.resetCircuitBreaker":
		if e.complexity.Mutation.ResetCircuitBreaker == nil {
			break
		}

		args, err := ec.field_Mutation_resetCircuitBreaker_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.ResetCircuitBreaker(childComplexity, args["routerId"].(string)), true

	case "Mutation.revokeAllSessions":
		if e.complexity.Mutation.RevokeAllSessions == nil {
			break
		}

		args, err := ec.field_Mutation_revokeAllSessions_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.RevokeAllSessions(childComplexity, args["userId"].(string)), true

	case "Mutation.revokeSession":
		if e.complexity.Mutation.RevokeSession == nil {
			break
		}

		args, err := ec.field_Mutation_revokeSession_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.RevokeSession(childComplexity, args["sessionId"].(string)), true

	case "Mutation.rollbackChangeSet":
		if e.complexity.Mutation.RollbackChangeSet == nil {
			break
		}

		args, err := ec.field_Mutation_rollbackChangeSet_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.RollbackChangeSet(childComplexity, args["changeSetId"].(string)), true

	case "Mutation.runDnsLookup":
		if e.complexity.Mutation.RunDNSLookup == nil {
			break
		}

		args, err := ec.field_Mutation_runDnsLookup_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.RunDNSLookup(childComplexity, args["input"].(model.DNSLookupInput)), true

	case "Mutation.runDiagnostics":
		if e.complexity.Mutation.RunDiagnostics == nil {
			break
		}

		args, err := ec.field_Mutation_runDiagnostics_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.RunDiagnostics(childComplexity, args["routerId"].(string)), true

	case "Mutation.runTraceroute":
		if e.complexity.Mutation.RunTraceroute == nil {
			break
		}

		args, err := ec.field_Mutation_runTraceroute_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.RunTraceroute(childComplexity, args["deviceId"].(string), args["input"].(model.TracerouteInput)), true

	case "Mutation.runTroubleshootStep":
		if e.complexity.Mutation.RunTroubleshootStep == nil {
			break
		}

		args, err := ec.field_Mutation_runTroubleshootStep_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.RunTroubleshootStep(childComplexity, args["sessionId"].(string), args["stepType"].(model.TroubleshootStepType)), true

	case "Mutation.scanNetwork":
		if e.complexity.Mutation.ScanNetwork == nil {
			break
		}

		args, err := ec.field_Mutation_scanNetwork_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.ScanNetwork(childComplexity, args["input"].(model.ScanNetworkInput)), true

	case "Mutation.setPreferredProtocol":
		if e.complexity.Mutation.SetPreferredProtocol == nil {
			break
		}

		args, err := ec.field_Mutation_setPreferredProtocol_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.SetPreferredProtocol(childComplexity, args["routerId"].(string), args["protocol"].(model.Protocol)), true

	case "Mutation.startTroubleshoot":
		if e.complexity.Mutation.StartTroubleshoot == nil {
			break
		}

		args, err := ec.field_Mutation_startTroubleshoot_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.StartTroubleshoot(childComplexity, args["routerId"].(string)), true

	case "Mutation.testAllCredentials":
		if e.complexity.Mutation.TestAllCredentials == nil {
			break
		}

		return e.complexity.Mutation.TestAllCredentials(childComplexity), true

	case "Mutation.testNotificationChannel":
		if e.complexity.Mutation.TestNotificationChannel == nil {
			break
		}

		args, err := ec.field_Mutation_testNotificationChannel_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.TestNotificationChannel(childComplexity, args["channel"].(string), args["config"].(map[string]interface{})), true

	case "Mutation.testRouterConnection":
		if e.complexity.Mutation.TestRouterConnection == nil {
			break
		}

		args, err := ec.field_Mutation_testRouterConnection_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.TestRouterConnection(childComplexity, args["id"].(string)), true

	case "Mutation.testRouterCredentials":
		if e.complexity.Mutation.TestRouterCredentials == nil {
			break
		}

		args, err := ec.field_Mutation_testRouterCredentials_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.TestRouterCredentials(childComplexity, args["input"].(model.AddRouterInput)), true

	case "Mutation.undoBridgeOperation":
		if e.complexity.Mutation.UndoBridgeOperation == nil {
			break
		}

		args, err := ec.field_Mutation_undoBridgeOperation_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UndoBridgeOperation(childComplexity, args["operationId"].(string)), true

	case "Mutation.updateAlertRule":
		if e.complexity.Mutation.UpdateAlertRule == nil {
			break
		}

		args, err := ec.field_Mutation_updateAlertRule_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateAlertRule(childComplexity, args["id"].(string), args["input"].(model.UpdateAlertRuleInput)), true

	case "Mutation.updateBridge":
		if e.complexity.Mutation.UpdateBridge == nil {
			break
		}

		args, err := ec.field_Mutation_updateBridge_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateBridge(childComplexity, args["uuid"].(string), args["input"].(model.UpdateBridgeInput)), true

	case "Mutation.updateBridgePort":
		if e.complexity.Mutation.UpdateBridgePort == nil {
			break
		}

		args, err := ec.field_Mutation_updateBridgePort_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateBridgePort(childComplexity, args["portId"].(string), args["input"].(model.UpdateBridgePortInput)), true

	case "Mutation.updateChangeSetItem":
		if e.complexity.Mutation.UpdateChangeSetItem == nil {
			break
		}

		args, err := ec.field_Mutation_updateChangeSetItem_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateChangeSetItem(childComplexity, args["changeSetId"].(string), args["itemId"].(string), args["input"].(model.UpdateChangeSetItemInput)), true

	case "Mutation.updateIpAddress":
		if e.complexity.Mutation.UpdateIPAddress == nil {
			break
		}

		args, err := ec.field_Mutation_updateIpAddress_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateIPAddress(childComplexity, args["routerId"].(string), args["id"].(string), args["input"].(model.IPAddressInput)), true

	case "Mutation.updateInterface":
		if e.complexity.Mutation.UpdateInterface == nil {
			break
		}

		args, err := ec.field_Mutation_updateInterface_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateInterface(childComplexity, args["routerId"].(string), args["interfaceId"].(string), args["input"].(model.UpdateInterfaceInput)), true

	case "Mutation.updateResource":
		if e.complexity.Mutation.UpdateResource == nil {
			break
		}

		args, err := ec.field_Mutation_updateResource_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateResource(childComplexity, args["id"].(string), args["routerId"].(string), args["input"].(model.UpdateResourceInput)), true

	case "Mutation.updateRoute":
		if e.complexity.Mutation.UpdateRoute == nil {
			break
		}

		args, err := ec.field_Mutation_updateRoute_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateRoute(childComplexity, args["routerId"].(string), args["id"].(string), args["input"].(model.RouteInput)), true

	case "Mutation.updateRouter":
		if e.complexity.Mutation.UpdateRouter == nil {
			break
		}

		args, err := ec.field_Mutation_updateRouter_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateRouter(childComplexity, args["id"].(string), args["input"].(model.UpdateRouterInput)), true

	case "Mutation.updateRouterCredentials":
		if e.complexity.Mutation.UpdateRouterCredentials == nil {
			break
		}

		args, err := ec.field_Mutation_updateRouterCredentials_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateRouterCredentials(childComplexity, args["routerId"].(string), args["input"].(model.CredentialsInput)), true

	case "Mutation.updateVlan":
		if e.complexity.Mutation.UpdateVlan == nil {
			break
		}

		args, err := ec.field_Mutation_updateVlan_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateVlan(childComplexity, args["id"].(string), args["input"].(model.VlanInput)), true

	case "Mutation.validateChangeSet":
		if e.complexity.Mutation.ValidateChangeSet == nil {
			break
		}

		args, err := ec.field_Mutation_validateChangeSet_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.ValidateChangeSet(childComplexity, args["changeSetId"].(string)), true

	case "Mutation.validateResource":
		if e.complexity.Mutation.ValidateResource == nil {
			break
		}

		args, err := ec.field_Mutation_validateResource_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.ValidateResource(childComplexity, args["id"].(string), args["routerId"].(string)), true

	case "Mutation.verifyTroubleshootFix":
		if e.complexity.Mutation.VerifyTroubleshootFix == nil {
			break
		}

		args, err := ec.field_Mutation_verifyTroubleshootFix_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.VerifyTroubleshootFix(childComplexity, args["sessionId"].(string), args["stepType"].(model.TroubleshootStepType)), true

	case "MutationError.code":
		if e.complexity.MutationError.Code == nil {
			break
		}

		return e.complexity.MutationError.Code(childComplexity), true

	case "MutationError.field":
		if e.complexity.MutationError.Field == nil {
			break
		}

		return e.complexity.MutationError.Field(childComplexity), true

	case "MutationError.message":
		if e.complexity.MutationError.Message == nil {
			break
		}

		return e.complexity.MutationError.Message(childComplexity), true

	case "NatRule.action":
		if e.complexity.NatRule.Action == nil {
			break
		}

		return e.complexity.NatRule.Action(childComplexity), true

	case "NatRule.chain":
		if e.complexity.NatRule.Chain == nil {
			break
		}

		return e.complexity.NatRule.Chain(childComplexity), true

	case "NatRule.disabled":
		if e.complexity.NatRule.Disabled == nil {
			break
		}

		return e.complexity.NatRule.Disabled(childComplexity), true

	case "NatRule.dstAddress":
		if e.complexity.NatRule.DstAddress == nil {
			break
		}

		return e.complexity.NatRule.DstAddress(childComplexity), true

	case "NatRule.id":
		if e.complexity.NatRule.ID == nil {
			break
		}

		return e.complexity.NatRule.ID(childComplexity), true

	case "NatRule.srcAddress":
		if e.complexity.NatRule.SrcAddress == nil {
			break
		}

		return e.complexity.NatRule.SrcAddress(childComplexity), true

	case "NatRule.toAddress":
		if e.complexity.NatRule.ToAddress == nil {
			break
		}

		return e.complexity.NatRule.ToAddress(childComplexity), true

	case "NetworkConfigDetection.gateway":
		if e.complexity.NetworkConfigDetection.Gateway == nil {
			break
		}

		return e.complexity.NetworkConfigDetection.Gateway(childComplexity), true

	case "NetworkConfigDetection.ispInfo":
		if e.complexity.NetworkConfigDetection.IspInfo == nil {
			break
		}

		return e.complexity.NetworkConfigDetection.IspInfo(childComplexity), true

	case "NetworkConfigDetection.wanInterface":
		if e.complexity.NetworkConfigDetection.WanInterface == nil {
			break
		}

		return e.complexity.NetworkConfigDetection.WanInterface(childComplexity), true

	case "OperationCounts.create":
		if e.complexity.OperationCounts.Create == nil {
			break
		}

		return e.complexity.OperationCounts.Create(childComplexity), true

	case "OperationCounts.delete":
		if e.complexity.OperationCounts.Delete == nil {
			break
		}

		return e.complexity.OperationCounts.Delete(childComplexity), true

	case "OperationCounts.update":
		if e.complexity.OperationCounts.Update == nil {
			break
		}

		return e.complexity.OperationCounts.Update(childComplexity), true

	case "PageInfo.endCursor":
		if e.complexity.PageInfo.EndCursor == nil {
			break
		}

		return e.complexity.PageInfo.EndCursor(childComplexity), true

	case "PageInfo.hasNextPage":
		if e.complexity.PageInfo.HasNextPage == nil {
			break
		}

		return e.complexity.PageInfo.HasNextPage(childComplexity), true

	case "PageInfo.hasPreviousPage":
		if e.complexity.PageInfo.HasPreviousPage == nil {
			break
		}

		return e.complexity.PageInfo.HasPreviousPage(childComplexity), true

	case "PageInfo.startCursor":
		if e.complexity.PageInfo.StartCursor == nil {
			break
		}

		return e.complexity.PageInfo.StartCursor(childComplexity), true

	case "PlatformCapabilities.details":
		if e.complexity.PlatformCapabilities.Details == nil {
			break
		}

		return e.complexity.PlatformCapabilities.Details(childComplexity), true

	case "PlatformCapabilities.isSupported":
		if e.complexity.PlatformCapabilities.IsSupported == nil {
			break
		}

		return e.complexity.PlatformCapabilities.IsSupported(childComplexity), true

	case "PlatformCapabilities.level":
		if e.complexity.PlatformCapabilities.Level == nil {
			break
		}

		return e.complexity.PlatformCapabilities.Level(childComplexity), true

	case "PlatformCapabilities.minVersion":
		if e.complexity.PlatformCapabilities.MinVersion == nil {
			break
		}

		return e.complexity.PlatformCapabilities.MinVersion(childComplexity), true

	case "PlatformCapabilities.requiredPackages":
		if e.complexity.PlatformCapabilities.RequiredPackages == nil {
			break
		}

		return e.complexity.PlatformCapabilities.RequiredPackages(childComplexity), true

	case "PlatformFeature.description":
		if e.complexity.PlatformFeature.Description == nil {
			break
		}

		return e.complexity.PlatformFeature.Description(childComplexity), true

	case "PlatformFeature.enabled":
		if e.complexity.PlatformFeature.Enabled == nil {
			break
		}

		return e.complexity.PlatformFeature.Enabled(childComplexity), true

	case "PlatformFeature.id":
		if e.complexity.PlatformFeature.ID == nil {
			break
		}

		return e.complexity.PlatformFeature.ID(childComplexity), true

	case "PlatformFeature.name":
		if e.complexity.PlatformFeature.Name == nil {
			break
		}

		return e.complexity.PlatformFeature.Name(childComplexity), true

	case "PlatformInfo.capabilities":
		if e.complexity.PlatformInfo.Capabilities == nil {
			break
		}

		return e.complexity.PlatformInfo.Capabilities(childComplexity), true

	case "PlatformInfo.current":
		if e.complexity.PlatformInfo.Current == nil {
			break
		}

		return e.complexity.PlatformInfo.Current(childComplexity), true

	case "PlatformInfo.features":
		if e.complexity.PlatformInfo.Features == nil {
			break
		}

		return e.complexity.PlatformInfo.Features(childComplexity), true

	case "PlatformInfo.fieldMappings":
		if e.complexity.PlatformInfo.FieldMappings == nil {
			break
		}

		return e.complexity.PlatformInfo.FieldMappings(childComplexity), true

	case "PlatformInfo.limitations":
		if e.complexity.PlatformInfo.Limitations == nil {
			break
		}

		return e.complexity.PlatformInfo.Limitations(childComplexity), true

	case "PlatformLimitation.affectedFields":
		if e.complexity.PlatformLimitation.AffectedFields == nil {
			break
		}

		return e.complexity.PlatformLimitation.AffectedFields(childComplexity), true

	case "PlatformLimitation.code":
		if e.complexity.PlatformLimitation.Code == nil {
			break
		}

		return e.complexity.PlatformLimitation.Code(childComplexity), true

	case "PlatformLimitation.description":
		if e.complexity.PlatformLimitation.Description == nil {
			break
		}

		return e.complexity.PlatformLimitation.Description(childComplexity), true

	case "PlatformLimitation.workaround":
		if e.complexity.PlatformLimitation.Workaround == nil {
			break
		}

		return e.complexity.PlatformLimitation.Workaround(childComplexity), true

	case "PortStatus.error":
		if e.complexity.PortStatus.Error == nil {
			break
		}

		return e.complexity.PortStatus.Error(childComplexity), true

	case "PortStatus.open":
		if e.complexity.PortStatus.Open == nil {
			break
		}

		return e.complexity.PortStatus.Open(childComplexity), true

	case "PortStatus.port":
		if e.complexity.PortStatus.Port == nil {
			break
		}

		return e.complexity.PortStatus.Port(childComplexity), true

	case "PortStatus.responseTimeMs":
		if e.complexity.PortStatus.ResponseTimeMs == nil {
			break
		}

		return e.complexity.PortStatus.ResponseTimeMs(childComplexity), true

	case "PortStatus.service":
		if e.complexity.PortStatus.Service == nil {
			break
		}

		return e.complexity.PortStatus.Service(childComplexity), true

	case "PppoeClient.addDefaultRoute":
		if e.complexity.PppoeClient.AddDefaultRoute == nil {
			break
		}

		return e.complexity.PppoeClient.AddDefaultRoute(childComplexity), true

	case "PppoeClient.comment":
		if e.complexity.PppoeClient.Comment == nil {
			break
		}

		return e.complexity.PppoeClient.Comment(childComplexity), true

	case "PppoeClient.disabled":
		if e.complexity.PppoeClient.Disabled == nil {
			break
		}

		return e.complexity.PppoeClient.Disabled(childComplexity), true

	case "PppoeClient.id":
		if e.complexity.PppoeClient.ID == nil {
			break
		}

		return e.complexity.PppoeClient.ID(childComplexity), true

	case "PppoeClient.interface":
		if e.complexity.PppoeClient.Interface == nil {
			break
		}

		return e.complexity.PppoeClient.Interface(childComplexity), true

	case "PppoeClient.mru":
		if e.complexity.PppoeClient.Mru == nil {
			break
		}

		return e.complexity.PppoeClient.Mru(childComplexity), true

	case "PppoeClient.mtu":
		if e.complexity.PppoeClient.Mtu == nil {
			break
		}

		return e.complexity.PppoeClient.Mtu(childComplexity), true

	case "PppoeClient.name":
		if e.complexity.PppoeClient.Name == nil {
			break
		}

		return e.complexity.PppoeClient.Name(childComplexity), true

	case "PppoeClient.running":
		if e.complexity.PppoeClient.Running == nil {
			break
		}

		return e.complexity.PppoeClient.Running(childComplexity), true

	case "PppoeClient.serviceName":
		if e.complexity.PppoeClient.ServiceName == nil {
			break
		}

		return e.complexity.PppoeClient.ServiceName(childComplexity), true

	case "PppoeClient.usePeerDNS":
		if e.complexity.PppoeClient.UsePeerDNS == nil {
			break
		}

		return e.complexity.PppoeClient.UsePeerDNS(childComplexity), true

	case "PppoeClient.username":
		if e.complexity.PppoeClient.Username == nil {
			break
		}

		return e.complexity.PppoeClient.Username(childComplexity), true

	case "Query.alertRule":
		if e.complexity.Query.AlertRule == nil {
			break
		}

		args, err := ec.field_Query_alertRule_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.AlertRule(childComplexity, args["id"].(string)), true

	case "Query.alertRules":
		if e.complexity.Query.AlertRules == nil {
			break
		}

		args, err := ec.field_Query_alertRules_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.AlertRules(childComplexity, args["deviceId"].(*string)), true

	case "Query.alerts":
		if e.complexity.Query.Alerts == nil {
			break
		}

		args, err := ec.field_Query_alerts_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Alerts(childComplexity, args["deviceId"].(*string), args["severity"].(*model.AlertSeverity), args["acknowledged"].(*bool), args["limit"].(*int), args["offset"].(*int)), true

	case "Query.availableInterfacesForBridge":
		if e.complexity.Query.AvailableInterfacesForBridge == nil {
			break
		}

		args, err := ec.field_Query_availableInterfacesForBridge_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.AvailableInterfacesForBridge(childComplexity, args["routerId"].(string)), true

	case "Query.bridge":
		if e.complexity.Query.Bridge == nil {
			break
		}

		args, err := ec.field_Query_bridge_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Bridge(childComplexity, args["uuid"].(string)), true

	case "Query.bridgePorts":
		if e.complexity.Query.BridgePorts == nil {
			break
		}

		args, err := ec.field_Query_bridgePorts_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.BridgePorts(childComplexity, args["bridgeId"].(string)), true

	case "Query.bridgeVlans":
		if e.complexity.Query.BridgeVlans == nil {
			break
		}

		args, err := ec.field_Query_bridgeVlans_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.BridgeVlans(childComplexity, args["bridgeId"].(string)), true

	case "Query.bridges":
		if e.complexity.Query.Bridges == nil {
			break
		}

		args, err := ec.field_Query_bridges_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Bridges(childComplexity, args["routerId"].(string)), true

	case "Query.changeSet":
		if e.complexity.Query.ChangeSet == nil {
			break
		}

		args, err := ec.field_Query_changeSet_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.ChangeSet(childComplexity, args["id"].(string), args["routerId"].(string)), true

	case "Query.changeSets":
		if e.complexity.Query.ChangeSets == nil {
			break
		}

		args, err := ec.field_Query_changeSets_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.ChangeSets(childComplexity, args["routerId"].(string), args["status"].(*model.ChangeSetStatus), args["includeCompleted"].(*bool)), true

	case "Query.checkGatewayReachability":
		if e.complexity.Query.CheckGatewayReachability == nil {
			break
		}

		args, err := ec.field_Query_checkGatewayReachability_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.CheckGatewayReachability(childComplexity, args["routerId"].(string), args["gateway"].(model.IPv4)), true

	case "Query.checkIpConflict":
		if e.complexity.Query.CheckIPConflict == nil {
			break
		}

		args, err := ec.field_Query_checkIpConflict_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.CheckIPConflict(childComplexity, args["routerId"].(string), args["address"].(string), args["interfaceId"].(*string), args["excludeId"].(*string)), true

	case "Query.checkVlanIdAvailable":
		if e.complexity.Query.CheckVlanIDAvailable == nil {
			break
		}

		args, err := ec.field_Query_checkVlanIdAvailable_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.CheckVlanIDAvailable(childComplexity, args["routerId"].(string), args["parentInterface"].(string), args["vlanId"].(int)), true

	case "Query.circuitBreakerStatus":
		if e.complexity.Query.CircuitBreakerStatus == nil {
			break
		}

		args, err := ec.field_Query_circuitBreakerStatus_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.CircuitBreakerStatus(childComplexity, args["routerId"].(string)), true

	case "Query.compatibilityMatrix":
		if e.complexity.Query.CompatibilityMatrix == nil {
			break
		}

		return e.complexity.Query.CompatibilityMatrix(childComplexity), true

	case "Query.compositeResource":
		if e.complexity.Query.CompositeResource == nil {
			break
		}

		args, err := ec.field_Query_compositeResource_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.CompositeResource(childComplexity, args["id"].(string), args["routerId"].(string)), true

	case "Query.connectionAttempts":
		if e.complexity.Query.ConnectionAttempts == nil {
			break
		}

		args, err := ec.field_Query_connectionAttempts_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.ConnectionAttempts(childComplexity, args["routerId"].(string), args["limit"].(*int)), true

	case "Query.connectionDetails":
		if e.complexity.Query.ConnectionDetails == nil {
			break
		}

		args, err := ec.field_Query_connectionDetails_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.ConnectionDetails(childComplexity, args["routerId"].(string)), true

	case "Query.connectionStats":
		if e.complexity.Query.ConnectionStats == nil {
			break
		}

		return e.complexity.Query.ConnectionStats(childComplexity), true

	case "Query.dnsServers":
		if e.complexity.Query.DNSServers == nil {
			break
		}

		args, err := ec.field_Query_dnsServers_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.DNSServers(childComplexity, args["deviceId"].(string)), true

	case "Query.detectGateway":
		if e.complexity.Query.DetectGateway == nil {
			break
		}

		args, err := ec.field_Query_detectGateway_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.DetectGateway(childComplexity, args["routerId"].(string)), true

	case "Query.detectISP":
		if e.complexity.Query.DetectIsp == nil {
			break
		}

		args, err := ec.field_Query_detectISP_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.DetectIsp(childComplexity, args["routerId"].(string)), true

	case "Query.detectWanInterface":
		if e.complexity.Query.DetectWanInterface == nil {
			break
		}

		args, err := ec.field_Query_detectWanInterface_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.DetectWanInterface(childComplexity, args["routerId"].(string)), true

	case "Query.device":
		if e.complexity.Query.Device == nil {
			break
		}

		args, err := ec.field_Query_device_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Device(childComplexity, args["id"].(string)), true

	case "Query.health":
		if e.complexity.Query.Health == nil {
			break
		}

		return e.complexity.Query.Health(childComplexity), true

	case "Query.ipAddress":
		if e.complexity.Query.IPAddress == nil {
			break
		}

		args, err := ec.field_Query_ipAddress_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.IPAddress(childComplexity, args["routerId"].(string), args["id"].(string)), true

	case "Query.ipAddressDependencies":
		if e.complexity.Query.IPAddressDependencies == nil {
			break
		}

		args, err := ec.field_Query_ipAddressDependencies_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.IPAddressDependencies(childComplexity, args["routerId"].(string), args["id"].(string)), true

	case "Query.ipAddresses":
		if e.complexity.Query.IPAddresses == nil {
			break
		}

		args, err := ec.field_Query_ipAddresses_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.IPAddresses(childComplexity, args["routerId"].(string), args["interfaceId"].(*string)), true

	case "Query.interface":
		if e.complexity.Query.Interface == nil {
			break
		}

		args, err := ec.field_Query_interface_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Interface(childComplexity, args["routerId"].(string), args["id"].(string)), true

	case "Query.interfaceStatsHistory":
		if e.complexity.Query.InterfaceStatsHistory == nil {
			break
		}

		args, err := ec.field_Query_interfaceStatsHistory_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.InterfaceStatsHistory(childComplexity, args["routerId"].(string), args["interfaceId"].(string), args["timeRange"].(model.StatsTimeRangeInput), args["interval"].(*model.Duration)), true

	case "Query.interfaces":
		if e.complexity.Query.Interfaces == nil {
			break
		}

		args, err := ec.field_Query_interfaces_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Interfaces(childComplexity, args["routerId"].(string), args["type"].(*model.InterfaceType), args["pagination"].(*model.PaginationInput)), true

	case "Query.isFeatureSupported":
		if e.complexity.Query.IsFeatureSupported == nil {
			break
		}

		args, err := ec.field_Query_isFeatureSupported_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.IsFeatureSupported(childComplexity, args["routerId"].(string), args["featureId"].(string)), true

	case "Query.me":
		if e.complexity.Query.Me == nil {
			break
		}

		return e.complexity.Query.Me(childComplexity), true

	case "Query.mySessions":
		if e.complexity.Query.MySessions == nil {
			break
		}

		return e.complexity.Query.MySessions(childComplexity), true

	case "Query.node":
		if e.complexity.Query.Node == nil {
			break
		}

		args, err := ec.field_Query_node_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Node(childComplexity, args["id"].(string)), true

	case "Query.resource":
		if e.complexity.Query.Resource == nil {
			break
		}

		args, err := ec.field_Query_resource_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Resource(childComplexity, args["id"].(string), args["routerId"].(string), args["layers"].([]model.ResourceLayer)), true

	case "Query.resources":
		if e.complexity.Query.Resources == nil {
			break
		}

		args, err := ec.field_Query_resources_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Resources(childComplexity, args["routerId"].(string), args["category"].(*model.ResourceCategory), args["type"].(*string), args["state"].(*model.ResourceLifecycleState), args["pagination"].(*model.PaginationInput)), true

	case "Query.route":
		if e.complexity.Query.Route == nil {
			break
		}

		args, err := ec.field_Query_route_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Route(childComplexity, args["routerId"].(string), args["id"].(string)), true

	case "Query.router":
		if e.complexity.Query.Router == nil {
			break
		}

		args, err := ec.field_Query_router_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Router(childComplexity, args["id"].(string)), true

	case "Query.routerCapabilities":
		if e.complexity.Query.RouterCapabilities == nil {
			break
		}

		args, err := ec.field_Query_routerCapabilities_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.RouterCapabilities(childComplexity, args["routerId"].(string)), true

	case "Query.routerCredentials":
		if e.complexity.Query.RouterCredentials == nil {
			break
		}

		args, err := ec.field_Query_routerCredentials_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.RouterCredentials(childComplexity, args["routerId"].(string)), true

	case "Query.routerHealth":
		if e.complexity.Query.RouterHealth == nil {
			break
		}

		args, err := ec.field_Query_routerHealth_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.RouterHealth(childComplexity, args["routerId"].(string)), true

	case "Query.routers":
		if e.complexity.Query.Routers == nil {
			break
		}

		args, err := ec.field_Query_routers_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Routers(childComplexity, args["status"].(*model.ConnectionStatus), args["pagination"].(*model.PaginationInput)), true

	case "Query.routes":
		if e.complexity.Query.Routes == nil {
			break
		}

		args, err := ec.field_Query_routes_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Routes(childComplexity, args["routerId"].(string), args["table"].(*string), args["type"].(*model.RouteType)), true

	case "Query.scanHistory":
		if e.complexity.Query.ScanHistory == nil {
			break
		}

		args, err := ec.field_Query_scanHistory_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.ScanHistory(childComplexity, args["limit"].(*int)), true

	case "Query.scanStatus":
		if e.complexity.Query.ScanStatus == nil {
			break
		}

		args, err := ec.field_Query_scanStatus_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.ScanStatus(childComplexity, args["taskId"].(string)), true

	case "Query.supportedFeatures":
		if e.complexity.Query.SupportedFeatures == nil {
			break
		}

		args, err := ec.field_Query_supportedFeatures_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.SupportedFeatures(childComplexity, args["routerId"].(string)), true

	case "Query.troubleshootSession":
		if e.complexity.Query.TroubleshootSession == nil {
			break
		}

		args, err := ec.field_Query_troubleshootSession_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.TroubleshootSession(childComplexity, args["id"].(string)), true

	case "Query.unsupportedFeatures":
		if e.complexity.Query.UnsupportedFeatures == nil {
			break
		}

		args, err := ec.field_Query_unsupportedFeatures_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.UnsupportedFeatures(childComplexity, args["routerId"].(string)), true

	case "Query.upgradeRecommendation":
		if e.complexity.Query.UpgradeRecommendation == nil {
			break
		}

		args, err := ec.field_Query_upgradeRecommendation_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.UpgradeRecommendation(childComplexity, args["routerId"].(string), args["featureId"].(string)), true

	case "Query.upgradeRecommendations":
		if e.complexity.Query.UpgradeRecommendations == nil {
			break
		}

		args, err := ec.field_Query_upgradeRecommendations_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.UpgradeRecommendations(childComplexity, args["routerId"].(string)), true

	case "Query.version":
		if e.complexity.Query.Version == nil {
			break
		}

		return e.complexity.Query.Version(childComplexity), true

	case "Query.vlan":
		if e.complexity.Query.Vlan == nil {
			break
		}

		args, err := ec.field_Query_vlan_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Vlan(childComplexity, args["id"].(string)), true

	case "Query.vlanDependencies":
		if e.complexity.Query.VlanDependencies == nil {
			break
		}

		args, err := ec.field_Query_vlanDependencies_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.VlanDependencies(childComplexity, args["id"].(string)), true

	case "Query.vlanTopology":
		if e.complexity.Query.VlanTopology == nil {
			break
		}

		args, err := ec.field_Query_vlanTopology_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.VlanTopology(childComplexity, args["routerId"].(string), args["bridgeId"].(string)), true

	case "Query.vlans":
		if e.complexity.Query.Vlans == nil {
			break
		}

		args, err := ec.field_Query_vlans_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Vlans(childComplexity, args["routerId"].(string), args["filter"].(*model.VlanFilter)), true

	case "Query.wanConnectionHistory":
		if e.complexity.Query.WanConnectionHistory == nil {
			break
		}

		args, err := ec.field_Query_wanConnectionHistory_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.WanConnectionHistory(childComplexity, args["routerId"].(string), args["wanInterfaceId"].(string), args["pagination"].(*model.PaginationInput)), true

	case "Query.wanInterface":
		if e.complexity.Query.WanInterface == nil {
			break
		}

		args, err := ec.field_Query_wanInterface_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.WanInterface(childComplexity, args["routerId"].(string), args["id"].(string)), true

	case "Query.wanInterfaces":
		if e.complexity.Query.WanInterfaces == nil {
			break
		}

		args, err := ec.field_Query_wanInterfaces_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.WanInterfaces(childComplexity, args["routerId"].(string)), true

	case "QuietHoursConfig.bypassCritical":
		if e.complexity.QuietHoursConfig.BypassCritical == nil {
			break
		}

		return e.complexity.QuietHoursConfig.BypassCritical(childComplexity), true

	case "QuietHoursConfig.endTime":
		if e.complexity.QuietHoursConfig.EndTime == nil {
			break
		}

		return e.complexity.QuietHoursConfig.EndTime(childComplexity), true

	case "QuietHoursConfig.startTime":
		if e.complexity.QuietHoursConfig.StartTime == nil {
			break
		}

		return e.complexity.QuietHoursConfig.StartTime(childComplexity), true

	case "QuietHoursConfig.timezone":
		if e.complexity.QuietHoursConfig.Timezone == nil {
			break
		}

		return e.complexity.QuietHoursConfig.Timezone(childComplexity), true

	case "ReconnectRouterPayload.connectionDetails":
		if e.complexity.ReconnectRouterPayload.ConnectionDetails == nil {
			break
		}

		return e.complexity.ReconnectRouterPayload.ConnectionDetails(childComplexity), true

	case "ReconnectRouterPayload.errors":
		if e.complexity.ReconnectRouterPayload.Errors == nil {
			break
		}

		return e.complexity.ReconnectRouterPayload.Errors(childComplexity), true

	case "ReconnectRouterPayload.initiated":
		if e.complexity.ReconnectRouterPayload.Initiated == nil {
			break
		}

		return e.complexity.ReconnectRouterPayload.Initiated(childComplexity), true

	case "ReconnectRouterPayload.router":
		if e.complexity.ReconnectRouterPayload.Router == nil {
			break
		}

		return e.complexity.ReconnectRouterPayload.Router(childComplexity), true

	case "ReconnectRouterPayload.waitTimeMs":
		if e.complexity.ReconnectRouterPayload.WaitTimeMs == nil {
			break
		}

		return e.complexity.ReconnectRouterPayload.WaitTimeMs(childComplexity), true

	case "RefreshCapabilitiesPayload.capabilities":
		if e.complexity.RefreshCapabilitiesPayload.Capabilities == nil {
			break
		}

		return e.complexity.RefreshCapabilitiesPayload.Capabilities(childComplexity), true

	case "RefreshCapabilitiesPayload.errors":
		if e.complexity.RefreshCapabilitiesPayload.Errors == nil {
			break
		}

		return e.complexity.RefreshCapabilitiesPayload.Errors(childComplexity), true

	case "RemoveChangeSetItemPayload.changeSet":
		if e.complexity.RemoveChangeSetItemPayload.ChangeSet == nil {
			break
		}

		return e.complexity.RemoveChangeSetItemPayload.ChangeSet(childComplexity), true

	case "RemoveChangeSetItemPayload.errors":
		if e.complexity.RemoveChangeSetItemPayload.Errors == nil {
			break
		}

		return e.complexity.RemoveChangeSetItemPayload.Errors(childComplexity), true

	case "ResourceConflict.conflictingResource":
		if e.complexity.ResourceConflict.ConflictingResource == nil {
			break
		}

		return e.complexity.ResourceConflict.ConflictingResource(childComplexity), true

	case "ResourceConflict.conflictingResourceUuid":
		if e.complexity.ResourceConflict.ConflictingResourceUUID == nil {
			break
		}

		return e.complexity.ResourceConflict.ConflictingResourceUUID(childComplexity), true

	case "ResourceConflict.description":
		if e.complexity.ResourceConflict.Description == nil {
			break
		}

		return e.complexity.ResourceConflict.Description(childComplexity), true

	case "ResourceConflict.resolution":
		if e.complexity.ResourceConflict.Resolution == nil {
			break
		}

		return e.complexity.ResourceConflict.Resolution(childComplexity), true

	case "ResourceConflict.type":
		if e.complexity.ResourceConflict.Type == nil {
			break
		}

		return e.complexity.ResourceConflict.Type(childComplexity), true

	case "ResourceConnection.edges":
		if e.complexity.ResourceConnection.Edges == nil {
			break
		}

		return e.complexity.ResourceConnection.Edges(childComplexity), true

	case "ResourceConnection.pageInfo":
		if e.complexity.ResourceConnection.PageInfo == nil {
			break
		}

		return e.complexity.ResourceConnection.PageInfo(childComplexity), true

	case "ResourceConnection.totalCount":
		if e.complexity.ResourceConnection.TotalCount == nil {
			break
		}

		return e.complexity.ResourceConnection.TotalCount(childComplexity), true

	case "ResourceEdge.cursor":
		if e.complexity.ResourceEdge.Cursor == nil {
			break
		}

		return e.complexity.ResourceEdge.Cursor(childComplexity), true

	case "ResourceEdge.node":
		if e.complexity.ResourceEdge.Node == nil {
			break
		}

		return e.complexity.ResourceEdge.Node(childComplexity), true

	case "ResourceMetadata.createdAt":
		if e.complexity.ResourceMetadata.CreatedAt == nil {
			break
		}

		return e.complexity.ResourceMetadata.CreatedAt(childComplexity), true

	case "ResourceMetadata.createdBy":
		if e.complexity.ResourceMetadata.CreatedBy == nil {
			break
		}

		return e.complexity.ResourceMetadata.CreatedBy(childComplexity), true

	case "ResourceMetadata.description":
		if e.complexity.ResourceMetadata.Description == nil {
			break
		}

		return e.complexity.ResourceMetadata.Description(childComplexity), true

	case "ResourceMetadata.isFavorite":
		if e.complexity.ResourceMetadata.IsFavorite == nil {
			break
		}

		return e.complexity.ResourceMetadata.IsFavorite(childComplexity), true

	case "ResourceMetadata.isPinned":
		if e.complexity.ResourceMetadata.IsPinned == nil {
			break
		}

		return e.complexity.ResourceMetadata.IsPinned(childComplexity), true

	case "ResourceMetadata.notes":
		if e.complexity.ResourceMetadata.Notes == nil {
			break
		}

		return e.complexity.ResourceMetadata.Notes(childComplexity), true

	case "ResourceMetadata.recentChanges":
		if e.complexity.ResourceMetadata.RecentChanges == nil {
			break
		}

		return e.complexity.ResourceMetadata.RecentChanges(childComplexity), true

	case "ResourceMetadata.state":
		if e.complexity.ResourceMetadata.State == nil {
			break
		}

		return e.complexity.ResourceMetadata.State(childComplexity), true

	case "ResourceMetadata.tags":
		if e.complexity.ResourceMetadata.Tags == nil {
			break
		}

		return e.complexity.ResourceMetadata.Tags(childComplexity), true

	case "ResourceMetadata.updatedAt":
		if e.complexity.ResourceMetadata.UpdatedAt == nil {
			break
		}

		return e.complexity.ResourceMetadata.UpdatedAt(childComplexity), true

	case "ResourceMetadata.updatedBy":
		if e.complexity.ResourceMetadata.UpdatedBy == nil {
			break
		}

		return e.complexity.ResourceMetadata.UpdatedBy(childComplexity), true

	case "ResourceMetadata.version":
		if e.complexity.ResourceMetadata.Version == nil {
			break
		}

		return e.complexity.ResourceMetadata.Version(childComplexity), true

	case "ResourceMetrics.cpu":
		if e.complexity.ResourceMetrics.CPU == nil {
			break
		}

		return e.complexity.ResourceMetrics.CPU(childComplexity), true

	case "ResourceMetrics.memory":
		if e.complexity.ResourceMetrics.Memory == nil {
			break
		}

		return e.complexity.ResourceMetrics.Memory(childComplexity), true

	case "ResourceMetrics.storage":
		if e.complexity.ResourceMetrics.Storage == nil {
			break
		}

		return e.complexity.ResourceMetrics.Storage(childComplexity), true

	case "ResourceMetrics.temperature":
		if e.complexity.ResourceMetrics.Temperature == nil {
			break
		}

		return e.complexity.ResourceMetrics.Temperature(childComplexity), true

	case "ResourceMetrics.timestamp":
		if e.complexity.ResourceMetrics.Timestamp == nil {
			break
		}

		return e.complexity.ResourceMetrics.Timestamp(childComplexity), true

	case "ResourceReference.category":
		if e.complexity.ResourceReference.Category == nil {
			break
		}

		return e.complexity.ResourceReference.Category(childComplexity), true

	case "ResourceReference.id":
		if e.complexity.ResourceReference.ID == nil {
			break
		}

		return e.complexity.ResourceReference.ID(childComplexity), true

	case "ResourceReference.state":
		if e.complexity.ResourceReference.State == nil {
			break
		}

		return e.complexity.ResourceReference.State(childComplexity), true

	case "ResourceReference.type":
		if e.complexity.ResourceReference.Type == nil {
			break
		}

		return e.complexity.ResourceReference.Type(childComplexity), true

	case "ResourceReference.uuid":
		if e.complexity.ResourceReference.UUID == nil {
			break
		}

		return e.complexity.ResourceReference.UUID(childComplexity), true

	case "ResourceRelationshipEdge.from":
		if e.complexity.ResourceRelationshipEdge.From == nil {
			break
		}

		return e.complexity.ResourceRelationshipEdge.From(childComplexity), true

	case "ResourceRelationshipEdge.to":
		if e.complexity.ResourceRelationshipEdge.To == nil {
			break
		}

		return e.complexity.ResourceRelationshipEdge.To(childComplexity), true

	case "ResourceRelationshipEdge.type":
		if e.complexity.ResourceRelationshipEdge.Type == nil {
			break
		}

		return e.complexity.ResourceRelationshipEdge.Type(childComplexity), true

	case "ResourceRelationships.children":
		if e.complexity.ResourceRelationships.Children == nil {
			break
		}

		return e.complexity.ResourceRelationships.Children(childComplexity), true

	case "ResourceRelationships.custom":
		if e.complexity.ResourceRelationships.Custom == nil {
			break
		}

		return e.complexity.ResourceRelationships.Custom(childComplexity), true

	case "ResourceRelationships.dependents":
		if e.complexity.ResourceRelationships.Dependents == nil {
			break
		}

		return e.complexity.ResourceRelationships.Dependents(childComplexity), true

	case "ResourceRelationships.dependsOn":
		if e.complexity.ResourceRelationships.DependsOn == nil {
			break
		}

		return e.complexity.ResourceRelationships.DependsOn(childComplexity), true

	case "ResourceRelationships.parent":
		if e.complexity.ResourceRelationships.Parent == nil {
			break
		}

		return e.complexity.ResourceRelationships.Parent(childComplexity), true

	case "ResourceRelationships.routedBy":
		if e.complexity.ResourceRelationships.RoutedBy == nil {
			break
		}

		return e.complexity.ResourceRelationships.RoutedBy(childComplexity), true

	case "ResourceRelationships.routesVia":
		if e.complexity.ResourceRelationships.RoutesVia == nil {
			break
		}

		return e.complexity.ResourceRelationships.RoutesVia(childComplexity), true

	case "ResourceRuntimeEvent.id":
		if e.complexity.ResourceRuntimeEvent.ID == nil {
			break
		}

		return e.complexity.ResourceRuntimeEvent.ID(childComplexity), true

	case "ResourceRuntimeEvent.runtime":
		if e.complexity.ResourceRuntimeEvent.Runtime == nil {
			break
		}

		return e.complexity.ResourceRuntimeEvent.Runtime(childComplexity), true

	case "ResourceRuntimeEvent.timestamp":
		if e.complexity.ResourceRuntimeEvent.Timestamp == nil {
			break
		}

		return e.complexity.ResourceRuntimeEvent.Timestamp(childComplexity), true

	case "ResourceRuntimeEvent.type":
		if e.complexity.ResourceRuntimeEvent.Type == nil {
			break
		}

		return e.complexity.ResourceRuntimeEvent.Type(childComplexity), true

	case "ResourceStateEvent.errorMessage":
		if e.complexity.ResourceStateEvent.ErrorMessage == nil {
			break
		}

		return e.complexity.ResourceStateEvent.ErrorMessage(childComplexity), true

	case "ResourceStateEvent.id":
		if e.complexity.ResourceStateEvent.ID == nil {
			break
		}

		return e.complexity.ResourceStateEvent.ID(childComplexity), true

	case "ResourceStateEvent.newState":
		if e.complexity.ResourceStateEvent.NewState == nil {
			break
		}

		return e.complexity.ResourceStateEvent.NewState(childComplexity), true

	case "ResourceStateEvent.previousState":
		if e.complexity.ResourceStateEvent.PreviousState == nil {
			break
		}

		return e.complexity.ResourceStateEvent.PreviousState(childComplexity), true

	case "ResourceStateEvent.timestamp":
		if e.complexity.ResourceStateEvent.Timestamp == nil {
			break
		}

		return e.complexity.ResourceStateEvent.Timestamp(childComplexity), true

	case "ResourceStateEvent.type":
		if e.complexity.ResourceStateEvent.Type == nil {
			break
		}

		return e.complexity.ResourceStateEvent.Type(childComplexity), true

	case "ResourceUpdatedEvent.changeType":
		if e.complexity.ResourceUpdatedEvent.ChangeType == nil {
			break
		}

		return e.complexity.ResourceUpdatedEvent.ChangeType(childComplexity), true

	case "ResourceUpdatedEvent.changedFields":
		if e.complexity.ResourceUpdatedEvent.ChangedFields == nil {
			break
		}

		return e.complexity.ResourceUpdatedEvent.ChangedFields(childComplexity), true

	case "ResourceUpdatedEvent.resourceId":
		if e.complexity.ResourceUpdatedEvent.ResourceID == nil {
			break
		}

		return e.complexity.ResourceUpdatedEvent.ResourceID(childComplexity), true

	case "ResourceUpdatedEvent.resourceType":
		if e.complexity.ResourceUpdatedEvent.ResourceType == nil {
			break
		}

		return e.complexity.ResourceUpdatedEvent.ResourceType(childComplexity), true

	case "ResourceUpdatedEvent.routerId":
		if e.complexity.ResourceUpdatedEvent.RouterID == nil {
			break
		}

		return e.complexity.ResourceUpdatedEvent.RouterID(childComplexity), true

	case "ResourceUpdatedEvent.timestamp":
		if e.complexity.ResourceUpdatedEvent.Timestamp == nil {
			break
		}

		return e.complexity.ResourceUpdatedEvent.Timestamp(childComplexity), true

	case "ResourceUpdatedEvent.version":
		if e.complexity.ResourceUpdatedEvent.Version == nil {
			break
		}

		return e.complexity.ResourceUpdatedEvent.Version(childComplexity), true

	case "RollbackChangeSetPayload.changeSet":
		if e.complexity.RollbackChangeSetPayload.ChangeSet == nil {
			break
		}

		return e.complexity.RollbackChangeSetPayload.ChangeSet(childComplexity), true

	case "RollbackChangeSetPayload.errors":
		if e.complexity.RollbackChangeSetPayload.Errors == nil {
			break
		}

		return e.complexity.RollbackChangeSetPayload.Errors(childComplexity), true

	case "RollbackChangeSetPayload.failedItems":
		if e.complexity.RollbackChangeSetPayload.FailedItems == nil {
			break
		}

		return e.complexity.RollbackChangeSetPayload.FailedItems(childComplexity), true

	case "RollbackChangeSetPayload.success":
		if e.complexity.RollbackChangeSetPayload.Success == nil {
			break
		}

		return e.complexity.RollbackChangeSetPayload.Success(childComplexity), true

	case "RollbackStep.error":
		if e.complexity.RollbackStep.Error == nil {
			break
		}

		return e.complexity.RollbackStep.Error(childComplexity), true

	case "RollbackStep.itemId":
		if e.complexity.RollbackStep.ItemID == nil {
			break
		}

		return e.complexity.RollbackStep.ItemID(childComplexity), true

	case "RollbackStep.operation":
		if e.complexity.RollbackStep.Operation == nil {
			break
		}

		return e.complexity.RollbackStep.Operation(childComplexity), true

	case "RollbackStep.resourceUuid":
		if e.complexity.RollbackStep.ResourceUUID == nil {
			break
		}

		return e.complexity.RollbackStep.ResourceUUID(childComplexity), true

	case "RollbackStep.restoreState":
		if e.complexity.RollbackStep.RestoreState == nil {
			break
		}

		return e.complexity.RollbackStep.RestoreState(childComplexity), true

	case "RollbackStep.rollbackOrder":
		if e.complexity.RollbackStep.RollbackOrder == nil {
			break
		}

		return e.complexity.RollbackStep.RollbackOrder(childComplexity), true

	case "RollbackStep.success":
		if e.complexity.RollbackStep.Success == nil {
			break
		}

		return e.complexity.RollbackStep.Success(childComplexity), true

	case "Route.active":
		if e.complexity.Route.Active == nil {
			break
		}

		return e.complexity.Route.Active(childComplexity), true

	case "Route.comment":
		if e.complexity.Route.Comment == nil {
			break
		}

		return e.complexity.Route.Comment(childComplexity), true

	case "Route.destination":
		if e.complexity.Route.Destination == nil {
			break
		}

		return e.complexity.Route.Destination(childComplexity), true

	case "Route.disabled":
		if e.complexity.Route.Disabled == nil {
			break
		}

		return e.complexity.Route.Disabled(childComplexity), true

	case "Route.distance":
		if e.complexity.Route.Distance == nil {
			break
		}

		return e.complexity.Route.Distance(childComplexity), true

	case "Route.gateway":
		if e.complexity.Route.Gateway == nil {
			break
		}

		return e.complexity.Route.Gateway(childComplexity), true

	case "Route.id":
		if e.complexity.Route.ID == nil {
			break
		}

		return e.complexity.Route.ID(childComplexity), true

	case "Route.interface":
		if e.complexity.Route.Interface == nil {
			break
		}

		return e.complexity.Route.Interface(childComplexity), true

	case "Route.routingMark":
		if e.complexity.Route.RoutingMark == nil {
			break
		}

		return e.complexity.Route.RoutingMark(childComplexity), true

	case "Route.routingTable":
		if e.complexity.Route.RoutingTable == nil {
			break
		}

		return e.complexity.Route.RoutingTable(childComplexity), true

	case "Route.scope":
		if e.complexity.Route.Scope == nil {
			break
		}

		return e.complexity.Route.Scope(childComplexity), true

	case "Route.type":
		if e.complexity.Route.Type == nil {
			break
		}

		return e.complexity.Route.Type(childComplexity), true

	case "RouteDeleteResult.impactAnalysis":
		if e.complexity.RouteDeleteResult.ImpactAnalysis == nil {
			break
		}

		return e.complexity.RouteDeleteResult.ImpactAnalysis(childComplexity), true

	case "RouteDeleteResult.message":
		if e.complexity.RouteDeleteResult.Message == nil {
			break
		}

		return e.complexity.RouteDeleteResult.Message(childComplexity), true

	case "RouteDeleteResult.success":
		if e.complexity.RouteDeleteResult.Success == nil {
			break
		}

		return e.complexity.RouteDeleteResult.Success(childComplexity), true

	case "RouteImpactAnalysis.affectedTraffic":
		if e.complexity.RouteImpactAnalysis.AffectedTraffic == nil {
			break
		}

		return e.complexity.RouteImpactAnalysis.AffectedTraffic(childComplexity), true

	case "RouteImpactAnalysis.consequences":
		if e.complexity.RouteImpactAnalysis.Consequences == nil {
			break
		}

		return e.complexity.RouteImpactAnalysis.Consequences(childComplexity), true

	case "RouteImpactAnalysis.isDefaultRoute":
		if e.complexity.RouteImpactAnalysis.IsDefaultRoute == nil {
			break
		}

		return e.complexity.RouteImpactAnalysis.IsDefaultRoute(childComplexity), true

	case "RouteImpactAnalysis.message":
		if e.complexity.RouteImpactAnalysis.Message == nil {
			break
		}

		return e.complexity.RouteImpactAnalysis.Message(childComplexity), true

	case "RouteImpactAnalysis.severity":
		if e.complexity.RouteImpactAnalysis.Severity == nil {
			break
		}

		return e.complexity.RouteImpactAnalysis.Severity(childComplexity), true

	case "RouteMutationResult.message":
		if e.complexity.RouteMutationResult.Message == nil {
			break
		}

		return e.complexity.RouteMutationResult.Message(childComplexity), true

	case "RouteMutationResult.route":
		if e.complexity.RouteMutationResult.Route == nil {
			break
		}

		return e.complexity.RouteMutationResult.Route(childComplexity), true

	case "RouteMutationResult.success":
		if e.complexity.RouteMutationResult.Success == nil {
			break
		}

		return e.complexity.RouteMutationResult.Success(childComplexity), true

	case "RouteResource.active":
		if e.complexity.RouteResource.Active == nil {
			break
		}

		return e.complexity.RouteResource.Active(childComplexity), true

	case "RouteResource.category":
		if e.complexity.RouteResource.Category == nil {
			break
		}

		return e.complexity.RouteResource.Category(childComplexity), true

	case "RouteResource.configuration":
		if e.complexity.RouteResource.Configuration == nil {
			break
		}

		return e.complexity.RouteResource.Configuration(childComplexity), true

	case "RouteResource.deployment":
		if e.complexity.RouteResource.Deployment == nil {
			break
		}

		return e.complexity.RouteResource.Deployment(childComplexity), true

	case "RouteResource.distance":
		if e.complexity.RouteResource.Distance == nil {
			break
		}

		return e.complexity.RouteResource.Distance(childComplexity), true

	case "RouteResource.dstAddress":
		if e.complexity.RouteResource.DstAddress == nil {
			break
		}

		return e.complexity.RouteResource.DstAddress(childComplexity), true

	case "RouteResource.gateway":
		if e.complexity.RouteResource.Gateway == nil {
			break
		}

		return e.complexity.RouteResource.Gateway(childComplexity), true

	case "RouteResource.id":
		if e.complexity.RouteResource.ID == nil {
			break
		}

		return e.complexity.RouteResource.ID(childComplexity), true

	case "RouteResource.interface":
		if e.complexity.RouteResource.Interface == nil {
			break
		}

		return e.complexity.RouteResource.Interface(childComplexity), true

	case "RouteResource.metadata":
		if e.complexity.RouteResource.Metadata == nil {
			break
		}

		return e.complexity.RouteResource.Metadata(childComplexity), true

	case "RouteResource.platform":
		if e.complexity.RouteResource.Platform == nil {
			break
		}

		return e.complexity.RouteResource.Platform(childComplexity), true

	case "RouteResource.relationships":
		if e.complexity.RouteResource.Relationships == nil {
			break
		}

		return e.complexity.RouteResource.Relationships(childComplexity), true

	case "RouteResource.runtime":
		if e.complexity.RouteResource.Runtime == nil {
			break
		}

		return e.complexity.RouteResource.Runtime(childComplexity), true

	case "RouteResource.scopedId":
		if e.complexity.RouteResource.ScopedID == nil {
			break
		}

		return e.complexity.RouteResource.ScopedID(childComplexity), true

	case "RouteResource.telemetry":
		if e.complexity.RouteResource.Telemetry == nil {
			break
		}

		return e.complexity.RouteResource.Telemetry(childComplexity), true

	case "RouteResource.type":
		if e.complexity.RouteResource.Type == nil {
			break
		}

		return e.complexity.RouteResource.Type(childComplexity), true

	case "RouteResource.validation":
		if e.complexity.RouteResource.Validation == nil {
			break
		}

		return e.complexity.RouteResource.Validation(childComplexity), true

	case "Router.capabilities":
		if e.complexity.Router.Capabilities == nil {
			break
		}

		return e.complexity.Router.Capabilities(childComplexity), true

	case "Router.createdAt":
		if e.complexity.Router.CreatedAt == nil {
			break
		}

		return e.complexity.Router.CreatedAt(childComplexity), true

	case "Router.host":
		if e.complexity.Router.Host == nil {
			break
		}

		return e.complexity.Router.Host(childComplexity), true

	case "Router.id":
		if e.complexity.Router.ID == nil {
			break
		}

		return e.complexity.Router.ID(childComplexity), true

	case "Router.lastConnected":
		if e.complexity.Router.LastConnected == nil {
			break
		}

		return e.complexity.Router.LastConnected(childComplexity), true

	case "Router.model":
		if e.complexity.Router.Model == nil {
			break
		}

		return e.complexity.Router.Model(childComplexity), true

	case "Router.name":
		if e.complexity.Router.Name == nil {
			break
		}

		return e.complexity.Router.Name(childComplexity), true

	case "Router.platform":
		if e.complexity.Router.Platform == nil {
			break
		}

		return e.complexity.Router.Platform(childComplexity), true

	case "Router.port":
		if e.complexity.Router.Port == nil {
			break
		}

		return e.complexity.Router.Port(childComplexity), true

	case "Router.status":
		if e.complexity.Router.Status == nil {
			break
		}

		return e.complexity.Router.Status(childComplexity), true

	case "Router.updatedAt":
		if e.complexity.Router.UpdatedAt == nil {
			break
		}

		return e.complexity.Router.UpdatedAt(childComplexity), true

	case "Router.uptime":
		if e.complexity.Router.Uptime == nil {
			break
		}

		return e.complexity.Router.Uptime(childComplexity), true

	case "Router.version":
		if e.complexity.Router.Version == nil {
			break
		}

		return e.complexity.Router.Version(childComplexity), true

	case "RouterAddedEvent.addedBy":
		if e.complexity.RouterAddedEvent.AddedBy == nil {
			break
		}

		return e.complexity.RouterAddedEvent.AddedBy(childComplexity), true

	case "RouterAddedEvent.protocolUsed":
		if e.complexity.RouterAddedEvent.ProtocolUsed == nil {
			break
		}

		return e.complexity.RouterAddedEvent.ProtocolUsed(childComplexity), true

	case "RouterAddedEvent.router":
		if e.complexity.RouterAddedEvent.Router == nil {
			break
		}

		return e.complexity.RouterAddedEvent.Router(childComplexity), true

	case "RouterAddedEvent.timestamp":
		if e.complexity.RouterAddedEvent.Timestamp == nil {
			break
		}

		return e.complexity.RouterAddedEvent.Timestamp(childComplexity), true

	case "RouterCapabilities.capabilities":
		if e.complexity.RouterCapabilities.Capabilities == nil {
			break
		}

		return e.complexity.RouterCapabilities.Capabilities(childComplexity), true

	case "RouterCapabilities.container":
		if e.complexity.RouterCapabilities.Container == nil {
			break
		}

		return e.complexity.RouterCapabilities.Container(childComplexity), true

	case "RouterCapabilities.detectedAt":
		if e.complexity.RouterCapabilities.DetectedAt == nil {
			break
		}

		return e.complexity.RouterCapabilities.DetectedAt(childComplexity), true

	case "RouterCapabilities.expiresAt":
		if e.complexity.RouterCapabilities.ExpiresAt == nil {
			break
		}

		return e.complexity.RouterCapabilities.ExpiresAt(childComplexity), true

	case "RouterCapabilities.hardware":
		if e.complexity.RouterCapabilities.Hardware == nil {
			break
		}

		return e.complexity.RouterCapabilities.Hardware(childComplexity), true

	case "RouterCapabilities.isRefreshing":
		if e.complexity.RouterCapabilities.IsRefreshing == nil {
			break
		}

		return e.complexity.RouterCapabilities.IsRefreshing(childComplexity), true

	case "RouterCapabilities.routerOSVersion":
		if e.complexity.RouterCapabilities.RouterOSVersion == nil {
			break
		}

		return e.complexity.RouterCapabilities.RouterOSVersion(childComplexity), true

	case "RouterCapabilities.software":
		if e.complexity.RouterCapabilities.Software == nil {
			break
		}

		return e.complexity.RouterCapabilities.Software(childComplexity), true

	case "RouterCapabilities.supportedFeatures":
		if e.complexity.RouterCapabilities.SupportedFeatures == nil {
			break
		}

		return e.complexity.RouterCapabilities.SupportedFeatures(childComplexity), true

	case "RouterCapabilities.unsupportedFeatures":
		if e.complexity.RouterCapabilities.UnsupportedFeatures == nil {
			break
		}

		return e.complexity.RouterCapabilities.UnsupportedFeatures(childComplexity), true

	case "RouterCapabilities.vifRequirements":
		if e.complexity.RouterCapabilities.VifRequirements == nil {
			break
		}

		return e.complexity.RouterCapabilities.VifRequirements(childComplexity), true

	case "RouterConnection.edges":
		if e.complexity.RouterConnection.Edges == nil {
			break
		}

		return e.complexity.RouterConnection.Edges(childComplexity), true

	case "RouterConnection.pageInfo":
		if e.complexity.RouterConnection.PageInfo == nil {
			break
		}

		return e.complexity.RouterConnection.PageInfo(childComplexity), true

	case "RouterConnection.totalCount":
		if e.complexity.RouterConnection.TotalCount == nil {
			break
		}

		return e.complexity.RouterConnection.TotalCount(childComplexity), true

	case "RouterCredentials.createdAt":
		if e.complexity.RouterCredentials.CreatedAt == nil {
			break
		}

		return e.complexity.RouterCredentials.CreatedAt(childComplexity), true

	case "RouterCredentials.encryptionStatus":
		if e.complexity.RouterCredentials.EncryptionStatus == nil {
			break
		}

		return e.complexity.RouterCredentials.EncryptionStatus(childComplexity), true

	case "RouterCredentials.hasPassword":
		if e.complexity.RouterCredentials.HasPassword == nil {
			break
		}

		return e.complexity.RouterCredentials.HasPassword(childComplexity), true

	case "RouterCredentials.keyVersion":
		if e.complexity.RouterCredentials.KeyVersion == nil {
			break
		}

		return e.complexity.RouterCredentials.KeyVersion(childComplexity), true

	case "RouterCredentials.lastUpdated":
		if e.complexity.RouterCredentials.LastUpdated == nil {
			break
		}

		return e.complexity.RouterCredentials.LastUpdated(childComplexity), true

	case "RouterCredentials.routerId":
		if e.complexity.RouterCredentials.RouterID == nil {
			break
		}

		return e.complexity.RouterCredentials.RouterID(childComplexity), true

	case "RouterCredentials.username":
		if e.complexity.RouterCredentials.Username == nil {
			break
		}

		return e.complexity.RouterCredentials.Username(childComplexity), true

	case "RouterEdge.cursor":
		if e.complexity.RouterEdge.Cursor == nil {
			break
		}

		return e.complexity.RouterEdge.Cursor(childComplexity), true

	case "RouterEdge.node":
		if e.complexity.RouterEdge.Node == nil {
			break
		}

		return e.complexity.RouterEdge.Node(childComplexity), true

	case "RouterOSInfo.architecture":
		if e.complexity.RouterOSInfo.Architecture == nil {
			break
		}

		return e.complexity.RouterOSInfo.Architecture(childComplexity), true

	case "RouterOSInfo.boardName":
		if e.complexity.RouterOSInfo.BoardName == nil {
			break
		}

		return e.complexity.RouterOSInfo.BoardName(childComplexity), true

	case "RouterOSInfo.platform":
		if e.complexity.RouterOSInfo.Platform == nil {
			break
		}

		return e.complexity.RouterOSInfo.Platform(childComplexity), true

	case "RouterOSInfo.version":
		if e.complexity.RouterOSInfo.Version == nil {
			break
		}

		return e.complexity.RouterOSInfo.Version(childComplexity), true

	case "RouterOSVersion.channel":
		if e.complexity.RouterOSVersion.Channel == nil {
			break
		}

		return e.complexity.RouterOSVersion.Channel(childComplexity), true

	case "RouterOSVersion.isAtLeast":
		if e.complexity.RouterOSVersion.IsAtLeast == nil {
			break
		}

		args, err := ec.field_RouterOSVersion_isAtLeast_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.RouterOSVersion.IsAtLeast(childComplexity, args["version"].(string)), true

	case "RouterOSVersion.isCHR":
		if e.complexity.RouterOSVersion.IsChr == nil {
			break
		}

		return e.complexity.RouterOSVersion.IsChr(childComplexity), true

	case "RouterOSVersion.major":
		if e.complexity.RouterOSVersion.Major == nil {
			break
		}

		return e.complexity.RouterOSVersion.Major(childComplexity), true

	case "RouterOSVersion.minor":
		if e.complexity.RouterOSVersion.Minor == nil {
			break
		}

		return e.complexity.RouterOSVersion.Minor(childComplexity), true

	case "RouterOSVersion.patch":
		if e.complexity.RouterOSVersion.Patch == nil {
			break
		}

		return e.complexity.RouterOSVersion.Patch(childComplexity), true

	case "RouterOSVersion.raw":
		if e.complexity.RouterOSVersion.Raw == nil {
			break
		}

		return e.complexity.RouterOSVersion.Raw(childComplexity), true

	case "RouterOSVersion.supportsFeature":
		if e.complexity.RouterOSVersion.SupportsFeature == nil {
			break
		}

		args, err := ec.field_RouterOSVersion_supportsFeature_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.RouterOSVersion.SupportsFeature(childComplexity, args["featureId"].(string)), true

	case "RouterStatusEvent.newStatus":
		if e.complexity.RouterStatusEvent.NewStatus == nil {
			break
		}

		return e.complexity.RouterStatusEvent.NewStatus(childComplexity), true

	case "RouterStatusEvent.previousStatus":
		if e.complexity.RouterStatusEvent.PreviousStatus == nil {
			break
		}

		return e.complexity.RouterStatusEvent.PreviousStatus(childComplexity), true

	case "RouterStatusEvent.router":
		if e.complexity.RouterStatusEvent.Router == nil {
			break
		}

		return e.complexity.RouterStatusEvent.Router(childComplexity), true

	case "RouterStatusEvent.timestamp":
		if e.complexity.RouterStatusEvent.Timestamp == nil {
			break
		}

		return e.complexity.RouterStatusEvent.Timestamp(childComplexity), true

	case "RunTroubleshootStepPayload.errors":
		if e.complexity.RunTroubleshootStepPayload.Errors == nil {
			break
		}

		return e.complexity.RunTroubleshootStepPayload.Errors(childComplexity), true

	case "RunTroubleshootStepPayload.step":
		if e.complexity.RunTroubleshootStepPayload.Step == nil {
			break
		}

		return e.complexity.RunTroubleshootStepPayload.Step(childComplexity), true

	case "RuntimeMetrics.bytesIn":
		if e.complexity.RuntimeMetrics.BytesIn == nil {
			break
		}

		return e.complexity.RuntimeMetrics.BytesIn(childComplexity), true

	case "RuntimeMetrics.bytesOut":
		if e.complexity.RuntimeMetrics.BytesOut == nil {
			break
		}

		return e.complexity.RuntimeMetrics.BytesOut(childComplexity), true

	case "RuntimeMetrics.custom":
		if e.complexity.RuntimeMetrics.Custom == nil {
			break
		}

		return e.complexity.RuntimeMetrics.Custom(childComplexity), true

	case "RuntimeMetrics.drops":
		if e.complexity.RuntimeMetrics.Drops == nil {
			break
		}

		return e.complexity.RuntimeMetrics.Drops(childComplexity), true

	case "RuntimeMetrics.errors":
		if e.complexity.RuntimeMetrics.Errors == nil {
			break
		}

		return e.complexity.RuntimeMetrics.Errors(childComplexity), true

	case "RuntimeMetrics.packetsIn":
		if e.complexity.RuntimeMetrics.PacketsIn == nil {
			break
		}

		return e.complexity.RuntimeMetrics.PacketsIn(childComplexity), true

	case "RuntimeMetrics.packetsOut":
		if e.complexity.RuntimeMetrics.PacketsOut == nil {
			break
		}

		return e.complexity.RuntimeMetrics.PacketsOut(childComplexity), true

	case "RuntimeMetrics.throughputIn":
		if e.complexity.RuntimeMetrics.ThroughputIn == nil {
			break
		}

		return e.complexity.RuntimeMetrics.ThroughputIn(childComplexity), true

	case "RuntimeMetrics.throughputOut":
		if e.complexity.RuntimeMetrics.ThroughputOut == nil {
			break
		}

		return e.complexity.RuntimeMetrics.ThroughputOut(childComplexity), true

	case "RuntimeState.activeConnections":
		if e.complexity.RuntimeState.ActiveConnections == nil {
			break
		}

		return e.complexity.RuntimeState.ActiveConnections(childComplexity), true

	case "RuntimeState.errorMessage":
		if e.complexity.RuntimeState.ErrorMessage == nil {
			break
		}

		return e.complexity.RuntimeState.ErrorMessage(childComplexity), true

	case "RuntimeState.health":
		if e.complexity.RuntimeState.Health == nil {
			break
		}

		return e.complexity.RuntimeState.Health(childComplexity), true

	case "RuntimeState.isRunning":
		if e.complexity.RuntimeState.IsRunning == nil {
			break
		}

		return e.complexity.RuntimeState.IsRunning(childComplexity), true

	case "RuntimeState.lastSuccessfulOperation":
		if e.complexity.RuntimeState.LastSuccessfulOperation == nil {
			break
		}

		return e.complexity.RuntimeState.LastSuccessfulOperation(childComplexity), true

	case "RuntimeState.lastUpdated":
		if e.complexity.RuntimeState.LastUpdated == nil {
			break
		}

		return e.complexity.RuntimeState.LastUpdated(childComplexity), true

	case "RuntimeState.metrics":
		if e.complexity.RuntimeState.Metrics == nil {
			break
		}

		return e.complexity.RuntimeState.Metrics(childComplexity), true

	case "RuntimeState.uptime":
		if e.complexity.RuntimeState.Uptime == nil {
			break
		}

		return e.complexity.RuntimeState.Uptime(childComplexity), true

	case "ScanNetworkPayload.errors":
		if e.complexity.ScanNetworkPayload.Errors == nil {
			break
		}

		return e.complexity.ScanNetworkPayload.Errors(childComplexity), true

	case "ScanNetworkPayload.task":
		if e.complexity.ScanNetworkPayload.Task == nil {
			break
		}

		return e.complexity.ScanNetworkPayload.Task(childComplexity), true

	case "ScanProgressEvent.currentIP":
		if e.complexity.ScanProgressEvent.CurrentIP == nil {
			break
		}

		return e.complexity.ScanProgressEvent.CurrentIP(childComplexity), true

	case "ScanProgressEvent.devicesFound":
		if e.complexity.ScanProgressEvent.DevicesFound == nil {
			break
		}

		return e.complexity.ScanProgressEvent.DevicesFound(childComplexity), true

	case "ScanProgressEvent.progress":
		if e.complexity.ScanProgressEvent.Progress == nil {
			break
		}

		return e.complexity.ScanProgressEvent.Progress(childComplexity), true

	case "ScanProgressEvent.status":
		if e.complexity.ScanProgressEvent.Status == nil {
			break
		}

		return e.complexity.ScanProgressEvent.Status(childComplexity), true

	case "ScanProgressEvent.taskId":
		if e.complexity.ScanProgressEvent.TaskID == nil {
			break
		}

		return e.complexity.ScanProgressEvent.TaskID(childComplexity), true

	case "ScanProgressEvent.timestamp":
		if e.complexity.ScanProgressEvent.Timestamp == nil {
			break
		}

		return e.complexity.ScanProgressEvent.Timestamp(childComplexity), true

	case "ScanTask.endTime":
		if e.complexity.ScanTask.EndTime == nil {
			break
		}

		return e.complexity.ScanTask.EndTime(childComplexity), true

	case "ScanTask.error":
		if e.complexity.ScanTask.Error == nil {
			break
		}

		return e.complexity.ScanTask.Error(childComplexity), true

	case "ScanTask.id":
		if e.complexity.ScanTask.ID == nil {
			break
		}

		return e.complexity.ScanTask.ID(childComplexity), true

	case "ScanTask.progress":
		if e.complexity.ScanTask.Progress == nil {
			break
		}

		return e.complexity.ScanTask.Progress(childComplexity), true

	case "ScanTask.results":
		if e.complexity.ScanTask.Results == nil {
			break
		}

		return e.complexity.ScanTask.Results(childComplexity), true

	case "ScanTask.scannedIPs":
		if e.complexity.ScanTask.ScannedIPs == nil {
			break
		}

		return e.complexity.ScanTask.ScannedIPs(childComplexity), true

	case "ScanTask.startTime":
		if e.complexity.ScanTask.StartTime == nil {
			break
		}

		return e.complexity.ScanTask.StartTime(childComplexity), true

	case "ScanTask.status":
		if e.complexity.ScanTask.Status == nil {
			break
		}

		return e.complexity.ScanTask.Status(childComplexity), true

	case "ScanTask.subnet":
		if e.complexity.ScanTask.Subnet == nil {
			break
		}

		return e.complexity.ScanTask.Subnet(childComplexity), true

	case "ScanTask.totalIPs":
		if e.complexity.ScanTask.TotalIPs == nil {
			break
		}

		return e.complexity.ScanTask.TotalIPs(childComplexity), true

	case "Session.createdAt":
		if e.complexity.Session.CreatedAt == nil {
			break
		}

		return e.complexity.Session.CreatedAt(childComplexity), true

	case "Session.id":
		if e.complexity.Session.ID == nil {
			break
		}

		return e.complexity.Session.ID(childComplexity), true

	case "Session.ipAddress":
		if e.complexity.Session.IPAddress == nil {
			break
		}

		return e.complexity.Session.IPAddress(childComplexity), true

	case "Session.isCurrent":
		if e.complexity.Session.IsCurrent == nil {
			break
		}

		return e.complexity.Session.IsCurrent(childComplexity), true

	case "Session.lastActivity":
		if e.complexity.Session.LastActivity == nil {
			break
		}

		return e.complexity.Session.LastActivity(childComplexity), true

	case "Session.userAgent":
		if e.complexity.Session.UserAgent == nil {
			break
		}

		return e.complexity.Session.UserAgent(childComplexity), true

	case "SetPreferredProtocolPayload.connectionDetails":
		if e.complexity.SetPreferredProtocolPayload.ConnectionDetails == nil {
			break
		}

		return e.complexity.SetPreferredProtocolPayload.ConnectionDetails(childComplexity), true

	case "SetPreferredProtocolPayload.errors":
		if e.complexity.SetPreferredProtocolPayload.Errors == nil {
			break
		}

		return e.complexity.SetPreferredProtocolPayload.Errors(childComplexity), true

	case "SetPreferredProtocolPayload.router":
		if e.complexity.SetPreferredProtocolPayload.Router == nil {
			break
		}

		return e.complexity.SetPreferredProtocolPayload.Router(childComplexity), true

	case "SoftwareInfo.installedPackages":
		if e.complexity.SoftwareInfo.InstalledPackages == nil {
			break
		}

		return e.complexity.SoftwareInfo.InstalledPackages(childComplexity), true

	case "SoftwareInfo.licenseLevel":
		if e.complexity.SoftwareInfo.LicenseLevel == nil {
			break
		}

		return e.complexity.SoftwareInfo.LicenseLevel(childComplexity), true

	case "SoftwareInfo.updateChannel":
		if e.complexity.SoftwareInfo.UpdateChannel == nil {
			break
		}

		return e.complexity.SoftwareInfo.UpdateChannel(childComplexity), true

	case "SoftwareInfo.version":
		if e.complexity.SoftwareInfo.Version == nil {
			break
		}

		return e.complexity.SoftwareInfo.Version(childComplexity), true

	case "SoftwareInfo.versionMajor":
		if e.complexity.SoftwareInfo.VersionMajor == nil {
			break
		}

		return e.complexity.SoftwareInfo.VersionMajor(childComplexity), true

	case "SoftwareInfo.versionMinor":
		if e.complexity.SoftwareInfo.VersionMinor == nil {
			break
		}

		return e.complexity.SoftwareInfo.VersionMinor(childComplexity), true

	case "SoftwareInfo.versionPatch":
		if e.complexity.SoftwareInfo.VersionPatch == nil {
			break
		}

		return e.complexity.SoftwareInfo.VersionPatch(childComplexity), true

	case "StartTroubleshootPayload.errors":
		if e.complexity.StartTroubleshootPayload.Errors == nil {
			break
		}

		return e.complexity.StartTroubleshootPayload.Errors(childComplexity), true

	case "StartTroubleshootPayload.session":
		if e.complexity.StartTroubleshootPayload.Session == nil {
			break
		}

		return e.complexity.StartTroubleshootPayload.Session(childComplexity), true

	case "StaticIPConfig.address":
		if e.complexity.StaticIPConfig.Address == nil {
			break
		}

		return e.complexity.StaticIPConfig.Address(childComplexity), true

	case "StaticIPConfig.comment":
		if e.complexity.StaticIPConfig.Comment == nil {
			break
		}

		return e.complexity.StaticIPConfig.Comment(childComplexity), true

	case "StaticIPConfig.gateway":
		if e.complexity.StaticIPConfig.Gateway == nil {
			break
		}

		return e.complexity.StaticIPConfig.Gateway(childComplexity), true

	case "StaticIPConfig.id":
		if e.complexity.StaticIPConfig.ID == nil {
			break
		}

		return e.complexity.StaticIPConfig.ID(childComplexity), true

	case "StaticIPConfig.interface":
		if e.complexity.StaticIPConfig.Interface == nil {
			break
		}

		return e.complexity.StaticIPConfig.Interface(childComplexity), true

	case "StaticIPConfig.primaryDNS":
		if e.complexity.StaticIPConfig.PrimaryDNS == nil {
			break
		}

		return e.complexity.StaticIPConfig.PrimaryDNS(childComplexity), true

	case "StaticIPConfig.secondaryDNS":
		if e.complexity.StaticIPConfig.SecondaryDNS == nil {
			break
		}

		return e.complexity.StaticIPConfig.SecondaryDNS(childComplexity), true

	case "StatsDataPoint.rxBytesPerSec":
		if e.complexity.StatsDataPoint.RxBytesPerSec == nil {
			break
		}

		return e.complexity.StatsDataPoint.RxBytesPerSec(childComplexity), true

	case "StatsDataPoint.rxErrors":
		if e.complexity.StatsDataPoint.RxErrors == nil {
			break
		}

		return e.complexity.StatsDataPoint.RxErrors(childComplexity), true

	case "StatsDataPoint.rxPacketsPerSec":
		if e.complexity.StatsDataPoint.RxPacketsPerSec == nil {
			break
		}

		return e.complexity.StatsDataPoint.RxPacketsPerSec(childComplexity), true

	case "StatsDataPoint.timestamp":
		if e.complexity.StatsDataPoint.Timestamp == nil {
			break
		}

		return e.complexity.StatsDataPoint.Timestamp(childComplexity), true

	case "StatsDataPoint.txBytesPerSec":
		if e.complexity.StatsDataPoint.TxBytesPerSec == nil {
			break
		}

		return e.complexity.StatsDataPoint.TxBytesPerSec(childComplexity), true

	case "StatsDataPoint.txErrors":
		if e.complexity.StatsDataPoint.TxErrors == nil {
			break
		}

		return e.complexity.StatsDataPoint.TxErrors(childComplexity), true

	case "StatsDataPoint.txPacketsPerSec":
		if e.complexity.StatsDataPoint.TxPacketsPerSec == nil {
			break
		}

		return e.complexity.StatsDataPoint.TxPacketsPerSec(childComplexity), true

	case "StorageMetrics.percentage":
		if e.complexity.StorageMetrics.Percentage == nil {
			break
		}

		return e.complexity.StorageMetrics.Percentage(childComplexity), true

	case "StorageMetrics.total":
		if e.complexity.StorageMetrics.Total == nil {
			break
		}

		return e.complexity.StorageMetrics.Total(childComplexity), true

	case "StorageMetrics.used":
		if e.complexity.StorageMetrics.Used == nil {
			break
		}

		return e.complexity.StorageMetrics.Used(childComplexity), true

	case "Subscription.alertEvents":
		if e.complexity.Subscription.AlertEvents == nil {
			break
		}

		args, err := ec.field_Subscription_alertEvents_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Subscription.AlertEvents(childComplexity, args["deviceId"].(*string)), true

	case "Subscription.bridgePortsChanged":
		if e.complexity.Subscription.BridgePortsChanged == nil {
			break
		}

		args, err := ec.field_Subscription_bridgePortsChanged_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Subscription.BridgePortsChanged(childComplexity, args["bridgeId"].(string)), true

	case "Subscription.bridgeStpStatusChanged":
		if e.complexity.Subscription.BridgeStpStatusChanged == nil {
			break
		}

		args, err := ec.field_Subscription_bridgeStpStatusChanged_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Subscription.BridgeStpStatusChanged(childComplexity, args["bridgeId"].(string)), true

	case "Subscription.changeSetProgress":
		if e.complexity.Subscription.ChangeSetProgress == nil {
			break
		}

		args, err := ec.field_Subscription_changeSetProgress_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Subscription.ChangeSetProgress(childComplexity, args["changeSetId"].(string)), true

	case "Subscription.changeSetStatusChanged":
		if e.complexity.Subscription.ChangeSetStatusChanged == nil {
			break
		}

		args, err := ec.field_Subscription_changeSetStatusChanged_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Subscription.ChangeSetStatusChanged(childComplexity, args["routerId"].(string)), true

	case "Subscription.circuitBreakerChanged":
		if e.complexity.Subscription.CircuitBreakerChanged == nil {
			break
		}

		args, err := ec.field_Subscription_circuitBreakerChanged_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Subscription.CircuitBreakerChanged(childComplexity, args["routerId"].(string)), true

	case "Subscription.circuitBreakerStateChanged":
		if e.complexity.Subscription.CircuitBreakerStateChanged == nil {
			break
		}

		args, err := ec.field_Subscription_circuitBreakerStateChanged_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Subscription.CircuitBreakerStateChanged(childComplexity, args["routerId"].(*string)), true

	case "Subscription.configApplyProgress":
		if e.complexity.Subscription.ConfigApplyProgress == nil {
			break
		}

		args, err := ec.field_Subscription_configApplyProgress_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Subscription.ConfigApplyProgress(childComplexity, args["operationId"].(string)), true

	case "Subscription.connectionHealth":
		if e.complexity.Subscription.ConnectionHealth == nil {
			break
		}

		args, err := ec.field_Subscription_connectionHealth_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Subscription.ConnectionHealth(childComplexity, args["routerId"].(*string)), true

	case "Subscription.ipAddressChanged":
		if e.complexity.Subscription.IPAddressChanged == nil {
			break
		}

		args, err := ec.field_Subscription_ipAddressChanged_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Subscription.IPAddressChanged(childComplexity, args["routerId"].(string)), true

	case "Subscription.interfaceStatsUpdated":
		if e.complexity.Subscription.InterfaceStatsUpdated == nil {
			break
		}

		args, err := ec.field_Subscription_interfaceStatsUpdated_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Subscription.InterfaceStatsUpdated(childComplexity, args["routerId"].(string), args["interfaceId"].(string), args["interval"].(*model.Duration)), true

	case "Subscription.interfaceStatusChanged":
		if e.complexity.Subscription.InterfaceStatusChanged == nil {
			break
		}

		args, err := ec.field_Subscription_interfaceStatusChanged_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Subscription.InterfaceStatusChanged(childComplexity, args["routerId"].(string), args["interfaceId"].(*string)), true

	case "Subscription.interfaceTraffic":
		if e.complexity.Subscription.InterfaceTraffic == nil {
			break
		}

		args, err := ec.field_Subscription_interfaceTraffic_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Subscription.InterfaceTraffic(childComplexity, args["routerId"].(string), args["interfaceId"].(*string)), true

	case "Subscription.resourceMetrics":
		if e.complexity.Subscription.ResourceMetrics == nil {
			break
		}

		args, err := ec.field_Subscription_resourceMetrics_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Subscription.ResourceMetrics(childComplexity, args["deviceId"].(string)), true

	case "Subscription.resourceRuntime":
		if e.complexity.Subscription.ResourceRuntime == nil {
			break
		}

		args, err := ec.field_Subscription_resourceRuntime_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Subscription.ResourceRuntime(childComplexity, args["id"].(string), args["routerId"].(string)), true

	case "Subscription.resourceStateChanged":
		if e.complexity.Subscription.ResourceStateChanged == nil {
			break
		}

		args, err := ec.field_Subscription_resourceStateChanged_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Subscription.ResourceStateChanged(childComplexity, args["id"].(*string), args["routerId"].(string)), true

	case "Subscription.resourceUpdated":
		if e.complexity.Subscription.ResourceUpdated == nil {
			break
		}

		args, err := ec.field_Subscription_resourceUpdated_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Subscription.ResourceUpdated(childComplexity, args["resourceId"].(*string)), true

	case "Subscription.routerAdded":
		if e.complexity.Subscription.RouterAdded == nil {
			break
		}

		return e.complexity.Subscription.RouterAdded(childComplexity), true

	case "Subscription.routerStatusChanged":
		if e.complexity.Subscription.RouterStatusChanged == nil {
			break
		}

		args, err := ec.field_Subscription_routerStatusChanged_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Subscription.RouterStatusChanged(childComplexity, args["routerId"].(*string)), true

	case "Subscription.scanProgress":
		if e.complexity.Subscription.ScanProgress == nil {
			break
		}

		args, err := ec.field_Subscription_scanProgress_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Subscription.ScanProgress(childComplexity, args["taskId"].(string)), true

	case "Subscription.tracerouteProgress":
		if e.complexity.Subscription.TracerouteProgress == nil {
			break
		}

		args, err := ec.field_Subscription_tracerouteProgress_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Subscription.TracerouteProgress(childComplexity, args["jobId"].(string)), true

	case "Subscription.troubleshootProgress":
		if e.complexity.Subscription.TroubleshootProgress == nil {
			break
		}

		args, err := ec.field_Subscription_troubleshootProgress_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Subscription.TroubleshootProgress(childComplexity, args["sessionId"].(string)), true

	case "Subscription.vlanChanged":
		if e.complexity.Subscription.VlanChanged == nil {
			break
		}

		args, err := ec.field_Subscription_vlanChanged_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Subscription.VlanChanged(childComplexity, args["routerId"].(string)), true

	case "Subscription.wanHealthChanged":
		if e.complexity.Subscription.WanHealthChanged == nil {
			break
		}

		args, err := ec.field_Subscription_wanHealthChanged_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Subscription.WanHealthChanged(childComplexity, args["routerId"].(string), args["wanInterfaceId"].(string)), true

	case "Subscription.wanStatusChanged":
		if e.complexity.Subscription.WanStatusChanged == nil {
			break
		}

		args, err := ec.field_Subscription_wanStatusChanged_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Subscription.WanStatusChanged(childComplexity, args["routerId"].(string), args["wanInterfaceId"].(*string)), true

	case "TLSStatus.error":
		if e.complexity.TLSStatus.Error == nil {
			break
		}

		return e.complexity.TLSStatus.Error(childComplexity), true

	case "TLSStatus.expiresAt":
		if e.complexity.TLSStatus.ExpiresAt == nil {
			break
		}

		return e.complexity.TLSStatus.ExpiresAt(childComplexity), true

	case "TLSStatus.issuer":
		if e.complexity.TLSStatus.Issuer == nil {
			break
		}

		return e.complexity.TLSStatus.Issuer(childComplexity), true

	case "TLSStatus.subject":
		if e.complexity.TLSStatus.Subject == nil {
			break
		}

		return e.complexity.TLSStatus.Subject(childComplexity), true

	case "TLSStatus.valid":
		if e.complexity.TLSStatus.Valid == nil {
			break
		}

		return e.complexity.TLSStatus.Valid(childComplexity), true

	case "TelemetryData.bandwidthHistory":
		if e.complexity.TelemetryData.BandwidthHistory == nil {
			break
		}

		return e.complexity.TelemetryData.BandwidthHistory(childComplexity), true

	case "TelemetryData.dailyStats":
		if e.complexity.TelemetryData.DailyStats == nil {
			break
		}

		return e.complexity.TelemetryData.DailyStats(childComplexity), true

	case "TelemetryData.dataStartedAt":
		if e.complexity.TelemetryData.DataStartedAt == nil {
			break
		}

		return e.complexity.TelemetryData.DataStartedAt(childComplexity), true

	case "TelemetryData.hourlyStats":
		if e.complexity.TelemetryData.HourlyStats == nil {
			break
		}

		return e.complexity.TelemetryData.HourlyStats(childComplexity), true

	case "TelemetryData.lastUpdatedAt":
		if e.complexity.TelemetryData.LastUpdatedAt == nil {
			break
		}

		return e.complexity.TelemetryData.LastUpdatedAt(childComplexity), true

	case "TelemetryData.retentionDays":
		if e.complexity.TelemetryData.RetentionDays == nil {
			break
		}

		return e.complexity.TelemetryData.RetentionDays(childComplexity), true

	case "TelemetryData.uptimeHistory":
		if e.complexity.TelemetryData.UptimeHistory == nil {
			break
		}

		return e.complexity.TelemetryData.UptimeHistory(childComplexity), true

	case "TestAllCredentialsPayload.failureCount":
		if e.complexity.TestAllCredentialsPayload.FailureCount == nil {
			break
		}

		return e.complexity.TestAllCredentialsPayload.FailureCount(childComplexity), true

	case "TestAllCredentialsPayload.results":
		if e.complexity.TestAllCredentialsPayload.Results == nil {
			break
		}

		return e.complexity.TestAllCredentialsPayload.Results(childComplexity), true

	case "TestAllCredentialsPayload.successCount":
		if e.complexity.TestAllCredentialsPayload.SuccessCount == nil {
			break
		}

		return e.complexity.TestAllCredentialsPayload.SuccessCount(childComplexity), true

	case "TestAllCredentialsPayload.totalRouters":
		if e.complexity.TestAllCredentialsPayload.TotalRouters == nil {
			break
		}

		return e.complexity.TestAllCredentialsPayload.TotalRouters(childComplexity), true

	case "TestConnectionPayload.error":
		if e.complexity.TestConnectionPayload.Error == nil {
			break
		}

		return e.complexity.TestConnectionPayload.Error(childComplexity), true

	case "TestConnectionPayload.responseTimeMs":
		if e.complexity.TestConnectionPayload.ResponseTimeMs == nil {
			break
		}

		return e.complexity.TestConnectionPayload.ResponseTimeMs(childComplexity), true

	case "TestConnectionPayload.success":
		if e.complexity.TestConnectionPayload.Success == nil {
			break
		}

		return e.complexity.TestConnectionPayload.Success(childComplexity), true

	case "TestConnectionPayload.version":
		if e.complexity.TestConnectionPayload.Version == nil {
			break
		}

		return e.complexity.TestConnectionPayload.Version(childComplexity), true

	case "TestNotificationPayload.errors":
		if e.complexity.TestNotificationPayload.Errors == nil {
			break
		}

		return e.complexity.TestNotificationPayload.Errors(childComplexity), true

	case "TestNotificationPayload.message":
		if e.complexity.TestNotificationPayload.Message == nil {
			break
		}

		return e.complexity.TestNotificationPayload.Message(childComplexity), true

	case "TestNotificationPayload.success":
		if e.complexity.TestNotificationPayload.Success == nil {
			break
		}

		return e.complexity.TestNotificationPayload.Success(childComplexity), true

	case "ThrottleConfig.groupByField":
		if e.complexity.ThrottleConfig.GroupByField == nil {
			break
		}

		return e.complexity.ThrottleConfig.GroupByField(childComplexity), true

	case "ThrottleConfig.maxAlerts":
		if e.complexity.ThrottleConfig.MaxAlerts == nil {
			break
		}

		return e.complexity.ThrottleConfig.MaxAlerts(childComplexity), true

	case "ThrottleConfig.periodSeconds":
		if e.complexity.ThrottleConfig.PeriodSeconds == nil {
			break
		}

		return e.complexity.ThrottleConfig.PeriodSeconds(childComplexity), true

	case "TopologyEdge.data":
		if e.complexity.TopologyEdge.Data == nil {
			break
		}

		return e.complexity.TopologyEdge.Data(childComplexity), true

	case "TopologyEdge.id":
		if e.complexity.TopologyEdge.ID == nil {
			break
		}

		return e.complexity.TopologyEdge.ID(childComplexity), true

	case "TopologyEdge.label":
		if e.complexity.TopologyEdge.Label == nil {
			break
		}

		return e.complexity.TopologyEdge.Label(childComplexity), true

	case "TopologyEdge.source":
		if e.complexity.TopologyEdge.Source == nil {
			break
		}

		return e.complexity.TopologyEdge.Source(childComplexity), true

	case "TopologyEdge.style":
		if e.complexity.TopologyEdge.Style == nil {
			break
		}

		return e.complexity.TopologyEdge.Style(childComplexity), true

	case "TopologyEdge.target":
		if e.complexity.TopologyEdge.Target == nil {
			break
		}

		return e.complexity.TopologyEdge.Target(childComplexity), true

	case "TopologyEdgeStyle.stroke":
		if e.complexity.TopologyEdgeStyle.Stroke == nil {
			break
		}

		return e.complexity.TopologyEdgeStyle.Stroke(childComplexity), true

	case "TopologyEdgeStyle.strokeDasharray":
		if e.complexity.TopologyEdgeStyle.StrokeDasharray == nil {
			break
		}

		return e.complexity.TopologyEdgeStyle.StrokeDasharray(childComplexity), true

	case "TopologyEdgeStyle.strokeWidth":
		if e.complexity.TopologyEdgeStyle.StrokeWidth == nil {
			break
		}

		return e.complexity.TopologyEdgeStyle.StrokeWidth(childComplexity), true

	case "TopologyNode.data":
		if e.complexity.TopologyNode.Data == nil {
			break
		}

		return e.complexity.TopologyNode.Data(childComplexity), true

	case "TopologyNode.id":
		if e.complexity.TopologyNode.ID == nil {
			break
		}

		return e.complexity.TopologyNode.ID(childComplexity), true

	case "TopologyNode.label":
		if e.complexity.TopologyNode.Label == nil {
			break
		}

		return e.complexity.TopologyNode.Label(childComplexity), true

	case "TopologyNode.position":
		if e.complexity.TopologyNode.Position == nil {
			break
		}

		return e.complexity.TopologyNode.Position(childComplexity), true

	case "TopologyNode.style":
		if e.complexity.TopologyNode.Style == nil {
			break
		}

		return e.complexity.TopologyNode.Style(childComplexity), true

	case "TopologyNode.sublabel":
		if e.complexity.TopologyNode.Sublabel == nil {
			break
		}

		return e.complexity.TopologyNode.Sublabel(childComplexity), true

	case "TopologyNode.type":
		if e.complexity.TopologyNode.Type == nil {
			break
		}

		return e.complexity.TopologyNode.Type(childComplexity), true

	case "TopologyNodeStyle.fill":
		if e.complexity.TopologyNodeStyle.Fill == nil {
			break
		}

		return e.complexity.TopologyNodeStyle.Fill(childComplexity), true

	case "TopologyNodeStyle.stroke":
		if e.complexity.TopologyNodeStyle.Stroke == nil {
			break
		}

		return e.complexity.TopologyNodeStyle.Stroke(childComplexity), true

	case "TopologyNodeStyle.strokeWidth":
		if e.complexity.TopologyNodeStyle.StrokeWidth == nil {
			break
		}

		return e.complexity.TopologyNodeStyle.StrokeWidth(childComplexity), true

	case "TopologyPosition.x":
		if e.complexity.TopologyPosition.X == nil {
			break
		}

		return e.complexity.TopologyPosition.X(childComplexity), true

	case "TopologyPosition.y":
		if e.complexity.TopologyPosition.Y == nil {
			break
		}

		return e.complexity.TopologyPosition.Y(childComplexity), true

	case "TracerouteHop.address":
		if e.complexity.TracerouteHop.Address == nil {
			break
		}

		return e.complexity.TracerouteHop.Address(childComplexity), true

	case "TracerouteHop.avgLatencyMs":
		if e.complexity.TracerouteHop.AvgLatencyMs == nil {
			break
		}

		return e.complexity.TracerouteHop.AvgLatencyMs(childComplexity), true

	case "TracerouteHop.hopNumber":
		if e.complexity.TracerouteHop.HopNumber == nil {
			break
		}

		return e.complexity.TracerouteHop.HopNumber(childComplexity), true

	case "TracerouteHop.hostname":
		if e.complexity.TracerouteHop.Hostname == nil {
			break
		}

		return e.complexity.TracerouteHop.Hostname(childComplexity), true

	case "TracerouteHop.packetLoss":
		if e.complexity.TracerouteHop.PacketLoss == nil {
			break
		}

		return e.complexity.TracerouteHop.PacketLoss(childComplexity), true

	case "TracerouteHop.probes":
		if e.complexity.TracerouteHop.Probes == nil {
			break
		}

		return e.complexity.TracerouteHop.Probes(childComplexity), true

	case "TracerouteHop.status":
		if e.complexity.TracerouteHop.Status == nil {
			break
		}

		return e.complexity.TracerouteHop.Status(childComplexity), true

	case "TracerouteJob.jobId":
		if e.complexity.TracerouteJob.JobID == nil {
			break
		}

		return e.complexity.TracerouteJob.JobID(childComplexity), true

	case "TracerouteJob.status":
		if e.complexity.TracerouteJob.Status == nil {
			break
		}

		return e.complexity.TracerouteJob.Status(childComplexity), true

	case "TracerouteProgressEvent.error":
		if e.complexity.TracerouteProgressEvent.Error == nil {
			break
		}

		return e.complexity.TracerouteProgressEvent.Error(childComplexity), true

	case "TracerouteProgressEvent.eventType":
		if e.complexity.TracerouteProgressEvent.EventType == nil {
			break
		}

		return e.complexity.TracerouteProgressEvent.EventType(childComplexity), true

	case "TracerouteProgressEvent.hop":
		if e.complexity.TracerouteProgressEvent.Hop == nil {
			break
		}

		return e.complexity.TracerouteProgressEvent.Hop(childComplexity), true

	case "TracerouteProgressEvent.jobId":
		if e.complexity.TracerouteProgressEvent.JobID == nil {
			break
		}

		return e.complexity.TracerouteProgressEvent.JobID(childComplexity), true

	case "TracerouteProgressEvent.result":
		if e.complexity.TracerouteProgressEvent.Result == nil {
			break
		}

		return e.complexity.TracerouteProgressEvent.Result(childComplexity), true

	case "TracerouteResult.completed":
		if e.complexity.TracerouteResult.Completed == nil {
			break
		}

		return e.complexity.TracerouteResult.Completed(childComplexity), true

	case "TracerouteResult.completedAt":
		if e.complexity.TracerouteResult.CompletedAt == nil {
			break
		}

		return e.complexity.TracerouteResult.CompletedAt(childComplexity), true

	case "TracerouteResult.hops":
		if e.complexity.TracerouteResult.Hops == nil {
			break
		}

		return e.complexity.TracerouteResult.Hops(childComplexity), true

	case "TracerouteResult.maxHops":
		if e.complexity.TracerouteResult.MaxHops == nil {
			break
		}

		return e.complexity.TracerouteResult.MaxHops(childComplexity), true

	case "TracerouteResult.protocol":
		if e.complexity.TracerouteResult.Protocol == nil {
			break
		}

		return e.complexity.TracerouteResult.Protocol(childComplexity), true

	case "TracerouteResult.reachedDestination":
		if e.complexity.TracerouteResult.ReachedDestination == nil {
			break
		}

		return e.complexity.TracerouteResult.ReachedDestination(childComplexity), true

	case "TracerouteResult.startedAt":
		if e.complexity.TracerouteResult.StartedAt == nil {
			break
		}

		return e.complexity.TracerouteResult.StartedAt(childComplexity), true

	case "TracerouteResult.target":
		if e.complexity.TracerouteResult.Target == nil {
			break
		}

		return e.complexity.TracerouteResult.Target(childComplexity), true

	case "TracerouteResult.targetIp":
		if e.complexity.TracerouteResult.TargetIP == nil {
			break
		}

		return e.complexity.TracerouteResult.TargetIP(childComplexity), true

	case "TracerouteResult.totalTimeMs":
		if e.complexity.TracerouteResult.TotalTimeMs == nil {
			break
		}

		return e.complexity.TracerouteResult.TotalTimeMs(childComplexity), true

	case "TroubleshootFixSuggestion.command":
		if e.complexity.TroubleshootFixSuggestion.Command == nil {
			break
		}

		return e.complexity.TroubleshootFixSuggestion.Command(childComplexity), true

	case "TroubleshootFixSuggestion.confidence":
		if e.complexity.TroubleshootFixSuggestion.Confidence == nil {
			break
		}

		return e.complexity.TroubleshootFixSuggestion.Confidence(childComplexity), true

	case "TroubleshootFixSuggestion.explanation":
		if e.complexity.TroubleshootFixSuggestion.Explanation == nil {
			break
		}

		return e.complexity.TroubleshootFixSuggestion.Explanation(childComplexity), true

	case "TroubleshootFixSuggestion.isManualFix":
		if e.complexity.TroubleshootFixSuggestion.IsManualFix == nil {
			break
		}

		return e.complexity.TroubleshootFixSuggestion.IsManualFix(childComplexity), true

	case "TroubleshootFixSuggestion.issueCode":
		if e.complexity.TroubleshootFixSuggestion.IssueCode == nil {
			break
		}

		return e.complexity.TroubleshootFixSuggestion.IssueCode(childComplexity), true

	case "TroubleshootFixSuggestion.manualSteps":
		if e.complexity.TroubleshootFixSuggestion.ManualSteps == nil {
			break
		}

		return e.complexity.TroubleshootFixSuggestion.ManualSteps(childComplexity), true

	case "TroubleshootFixSuggestion.requiresConfirmation":
		if e.complexity.TroubleshootFixSuggestion.RequiresConfirmation == nil {
			break
		}

		return e.complexity.TroubleshootFixSuggestion.RequiresConfirmation(childComplexity), true

	case "TroubleshootFixSuggestion.rollbackCommand":
		if e.complexity.TroubleshootFixSuggestion.RollbackCommand == nil {
			break
		}

		return e.complexity.TroubleshootFixSuggestion.RollbackCommand(childComplexity), true

	case "TroubleshootFixSuggestion.title":
		if e.complexity.TroubleshootFixSuggestion.Title == nil {
			break
		}

		return e.complexity.TroubleshootFixSuggestion.Title(childComplexity), true

	case "TroubleshootSession.appliedFixes":
		if e.complexity.TroubleshootSession.AppliedFixes == nil {
			break
		}

		return e.complexity.TroubleshootSession.AppliedFixes(childComplexity), true

	case "TroubleshootSession.completedAt":
		if e.complexity.TroubleshootSession.CompletedAt == nil {
			break
		}

		return e.complexity.TroubleshootSession.CompletedAt(childComplexity), true

	case "TroubleshootSession.currentStepIndex":
		if e.complexity.TroubleshootSession.CurrentStepIndex == nil {
			break
		}

		return e.complexity.TroubleshootSession.CurrentStepIndex(childComplexity), true

	case "TroubleshootSession.gateway":
		if e.complexity.TroubleshootSession.Gateway == nil {
			break
		}

		return e.complexity.TroubleshootSession.Gateway(childComplexity), true

	case "TroubleshootSession.id":
		if e.complexity.TroubleshootSession.ID == nil {
			break
		}

		return e.complexity.TroubleshootSession.ID(childComplexity), true

	case "TroubleshootSession.ispInfo":
		if e.complexity.TroubleshootSession.IspInfo == nil {
			break
		}

		return e.complexity.TroubleshootSession.IspInfo(childComplexity), true

	case "TroubleshootSession.routerId":
		if e.complexity.TroubleshootSession.RouterID == nil {
			break
		}

		return e.complexity.TroubleshootSession.RouterID(childComplexity), true

	case "TroubleshootSession.startedAt":
		if e.complexity.TroubleshootSession.StartedAt == nil {
			break
		}

		return e.complexity.TroubleshootSession.StartedAt(childComplexity), true

	case "TroubleshootSession.status":
		if e.complexity.TroubleshootSession.Status == nil {
			break
		}

		return e.complexity.TroubleshootSession.Status(childComplexity), true

	case "TroubleshootSession.steps":
		if e.complexity.TroubleshootSession.Steps == nil {
			break
		}

		return e.complexity.TroubleshootSession.Steps(childComplexity), true

	case "TroubleshootSession.wanInterface":
		if e.complexity.TroubleshootSession.WanInterface == nil {
			break
		}

		return e.complexity.TroubleshootSession.WanInterface(childComplexity), true

	case "TroubleshootStep.completedAt":
		if e.complexity.TroubleshootStep.CompletedAt == nil {
			break
		}

		return e.complexity.TroubleshootStep.CompletedAt(childComplexity), true

	case "TroubleshootStep.description":
		if e.complexity.TroubleshootStep.Description == nil {
			break
		}

		return e.complexity.TroubleshootStep.Description(childComplexity), true

	case "TroubleshootStep.fix":
		if e.complexity.TroubleshootStep.Fix == nil {
			break
		}

		return e.complexity.TroubleshootStep.Fix(childComplexity), true

	case "TroubleshootStep.id":
		if e.complexity.TroubleshootStep.ID == nil {
			break
		}

		return e.complexity.TroubleshootStep.ID(childComplexity), true

	case "TroubleshootStep.name":
		if e.complexity.TroubleshootStep.Name == nil {
			break
		}

		return e.complexity.TroubleshootStep.Name(childComplexity), true

	case "TroubleshootStep.result":
		if e.complexity.TroubleshootStep.Result == nil {
			break
		}

		return e.complexity.TroubleshootStep.Result(childComplexity), true

	case "TroubleshootStep.startedAt":
		if e.complexity.TroubleshootStep.StartedAt == nil {
			break
		}

		return e.complexity.TroubleshootStep.StartedAt(childComplexity), true

	case "TroubleshootStep.status":
		if e.complexity.TroubleshootStep.Status == nil {
			break
		}

		return e.complexity.TroubleshootStep.Status(childComplexity), true

	case "TroubleshootStepResult.details":
		if e.complexity.TroubleshootStepResult.Details == nil {
			break
		}

		return e.complexity.TroubleshootStepResult.Details(childComplexity), true

	case "TroubleshootStepResult.executionTimeMs":
		if e.complexity.TroubleshootStepResult.ExecutionTimeMs == nil {
			break
		}

		return e.complexity.TroubleshootStepResult.ExecutionTimeMs(childComplexity), true

	case "TroubleshootStepResult.issueCode":
		if e.complexity.TroubleshootStepResult.IssueCode == nil {
			break
		}

		return e.complexity.TroubleshootStepResult.IssueCode(childComplexity), true

	case "TroubleshootStepResult.message":
		if e.complexity.TroubleshootStepResult.Message == nil {
			break
		}

		return e.complexity.TroubleshootStepResult.Message(childComplexity), true

	case "TroubleshootStepResult.success":
		if e.complexity.TroubleshootStepResult.Success == nil {
			break
		}

		return e.complexity.TroubleshootStepResult.Success(childComplexity), true

	case "TroubleshootStepResult.target":
		if e.complexity.TroubleshootStepResult.Target == nil {
			break
		}

		return e.complexity.TroubleshootStepResult.Target(childComplexity), true

	case "UpdateChangeSetItemPayload.changeSet":
		if e.complexity.UpdateChangeSetItemPayload.ChangeSet == nil {
			break
		}

		return e.complexity.UpdateChangeSetItemPayload.ChangeSet(childComplexity), true

	case "UpdateChangeSetItemPayload.errors":
		if e.complexity.UpdateChangeSetItemPayload.Errors == nil {
			break
		}

		return e.complexity.UpdateChangeSetItemPayload.Errors(childComplexity), true

	case "UpdateInterfacePayload.errors":
		if e.complexity.UpdateInterfacePayload.Errors == nil {
			break
		}

		return e.complexity.UpdateInterfacePayload.Errors(childComplexity), true

	case "UpdateInterfacePayload.interface":
		if e.complexity.UpdateInterfacePayload.Interface == nil {
			break
		}

		return e.complexity.UpdateInterfacePayload.Interface(childComplexity), true

	case "UpdateResourcePayload.errors":
		if e.complexity.UpdateResourcePayload.Errors == nil {
			break
		}

		return e.complexity.UpdateResourcePayload.Errors(childComplexity), true

	case "UpdateResourcePayload.resource":
		if e.complexity.UpdateResourcePayload.Resource == nil {
			break
		}

		return e.complexity.UpdateResourcePayload.Resource(childComplexity), true

	case "UpdateRouterPayload.errors":
		if e.complexity.UpdateRouterPayload.Errors == nil {
			break
		}

		return e.complexity.UpdateRouterPayload.Errors(childComplexity), true

	case "UpdateRouterPayload.router":
		if e.complexity.UpdateRouterPayload.Router == nil {
			break
		}

		return e.complexity.UpdateRouterPayload.Router(childComplexity), true

	case "UpgradeImpact.backupRecommended":
		if e.complexity.UpgradeImpact.BackupRecommended == nil {
			break
		}

		return e.complexity.UpgradeImpact.BackupRecommended(childComplexity), true

	case "UpgradeImpact.breakingChanges":
		if e.complexity.UpgradeImpact.BreakingChanges == nil {
			break
		}

		return e.complexity.UpgradeImpact.BreakingChanges(childComplexity), true

	case "UpgradeImpact.estimatedDowntime":
		if e.complexity.UpgradeImpact.EstimatedDowntime == nil {
			break
		}

		return e.complexity.UpgradeImpact.EstimatedDowntime(childComplexity), true

	case "UpgradeImpact.requiresReboot":
		if e.complexity.UpgradeImpact.RequiresReboot == nil {
			break
		}

		return e.complexity.UpgradeImpact.RequiresReboot(childComplexity), true

	case "UpgradeRecommendation.currentVersion":
		if e.complexity.UpgradeRecommendation.CurrentVersion == nil {
			break
		}

		return e.complexity.UpgradeRecommendation.CurrentVersion(childComplexity), true

	case "UpgradeRecommendation.documentationUrl":
		if e.complexity.UpgradeRecommendation.DocumentationURL == nil {
			break
		}

		return e.complexity.UpgradeRecommendation.DocumentationURL(childComplexity), true

	case "UpgradeRecommendation.featureId":
		if e.complexity.UpgradeRecommendation.FeatureID == nil {
			break
		}

		return e.complexity.UpgradeRecommendation.FeatureID(childComplexity), true

	case "UpgradeRecommendation.featureName":
		if e.complexity.UpgradeRecommendation.FeatureName == nil {
			break
		}

		return e.complexity.UpgradeRecommendation.FeatureName(childComplexity), true

	case "UpgradeRecommendation.impact":
		if e.complexity.UpgradeRecommendation.Impact == nil {
			break
		}

		return e.complexity.UpgradeRecommendation.Impact(childComplexity), true

	case "UpgradeRecommendation.isMajorUpgrade":
		if e.complexity.UpgradeRecommendation.IsMajorUpgrade == nil {
			break
		}

		return e.complexity.UpgradeRecommendation.IsMajorUpgrade(childComplexity), true

	case "UpgradeRecommendation.priority":
		if e.complexity.UpgradeRecommendation.Priority == nil {
			break
		}

		return e.complexity.UpgradeRecommendation.Priority(childComplexity), true

	case "UpgradeRecommendation.requiredVersion":
		if e.complexity.UpgradeRecommendation.RequiredVersion == nil {
			break
		}

		return e.complexity.UpgradeRecommendation.RequiredVersion(childComplexity), true

	case "UpgradeRecommendation.steps":
		if e.complexity.UpgradeRecommendation.Steps == nil {
			break
		}

		return e.complexity.UpgradeRecommendation.Steps(childComplexity), true

	case "UpgradeRecommendation.warnings":
		if e.complexity.UpgradeRecommendation.Warnings == nil {
			break
		}

		return e.complexity.UpgradeRecommendation.Warnings(childComplexity), true

	case "UpgradeStep.command":
		if e.complexity.UpgradeStep.Command == nil {
			break
		}

		return e.complexity.UpgradeStep.Command(childComplexity), true

	case "UpgradeStep.description":
		if e.complexity.UpgradeStep.Description == nil {
			break
		}

		return e.complexity.UpgradeStep.Description(childComplexity), true

	case "UpgradeStep.optional":
		if e.complexity.UpgradeStep.Optional == nil {
			break
		}

		return e.complexity.UpgradeStep.Optional(childComplexity), true

	case "UpgradeStep.step":
		if e.complexity.UpgradeStep.Step == nil {
			break
		}

		return e.complexity.UpgradeStep.Step(childComplexity), true

	case "UpgradeStep.title":
		if e.complexity.UpgradeStep.Title == nil {
			break
		}

		return e.complexity.UpgradeStep.Title(childComplexity), true

	case "UptimeDataPoint.isUp":
		if e.complexity.UptimeDataPoint.IsUp == nil {
			break
		}

		return e.complexity.UptimeDataPoint.IsUp(childComplexity), true

	case "UptimeDataPoint.periodSeconds":
		if e.complexity.UptimeDataPoint.PeriodSeconds == nil {
			break
		}

		return e.complexity.UptimeDataPoint.PeriodSeconds(childComplexity), true

	case "UptimeDataPoint.timestamp":
		if e.complexity.UptimeDataPoint.Timestamp == nil {
			break
		}

		return e.complexity.UptimeDataPoint.Timestamp(childComplexity), true

	case "User.createdAt":
		if e.complexity.User.CreatedAt == nil {
			break
		}

		return e.complexity.User.CreatedAt(childComplexity), true

	case "User.displayName":
		if e.complexity.User.DisplayName == nil {
			break
		}

		return e.complexity.User.DisplayName(childComplexity), true

	case "User.email":
		if e.complexity.User.Email == nil {
			break
		}

		return e.complexity.User.Email(childComplexity), true

	case "User.id":
		if e.complexity.User.ID == nil {
			break
		}

		return e.complexity.User.ID(childComplexity), true

	case "User.lastLoginAt":
		if e.complexity.User.LastLoginAt == nil {
			break
		}

		return e.complexity.User.LastLoginAt(childComplexity), true

	case "User.role":
		if e.complexity.User.Role == nil {
			break
		}

		return e.complexity.User.Role(childComplexity), true

	case "User.username":
		if e.complexity.User.Username == nil {
			break
		}

		return e.complexity.User.Username(childComplexity), true

	case "VIFGuidanceStep.completed":
		if e.complexity.VIFGuidanceStep.Completed == nil {
			break
		}

		return e.complexity.VIFGuidanceStep.Completed(childComplexity), true

	case "VIFGuidanceStep.description":
		if e.complexity.VIFGuidanceStep.Description == nil {
			break
		}

		return e.complexity.VIFGuidanceStep.Description(childComplexity), true

	case "VIFGuidanceStep.routerCommand":
		if e.complexity.VIFGuidanceStep.RouterCommand == nil {
			break
		}

		return e.complexity.VIFGuidanceStep.RouterCommand(childComplexity), true

	case "VIFGuidanceStep.step":
		if e.complexity.VIFGuidanceStep.Step == nil {
			break
		}

		return e.complexity.VIFGuidanceStep.Step(childComplexity), true

	case "VIFGuidanceStep.title":
		if e.complexity.VIFGuidanceStep.Title == nil {
			break
		}

		return e.complexity.VIFGuidanceStep.Title(childComplexity), true

	case "VIFRequirements.containerEnabled":
		if e.complexity.VIFRequirements.ContainerEnabled == nil {
			break
		}

		return e.complexity.VIFRequirements.ContainerEnabled(childComplexity), true

	case "VIFRequirements.containerPackage":
		if e.complexity.VIFRequirements.ContainerPackage == nil {
			break
		}

		return e.complexity.VIFRequirements.ContainerPackage(childComplexity), true

	case "VIFRequirements.guidanceSteps":
		if e.complexity.VIFRequirements.GuidanceSteps == nil {
			break
		}

		return e.complexity.VIFRequirements.GuidanceSteps(childComplexity), true

	case "VIFRequirements.met":
		if e.complexity.VIFRequirements.Met == nil {
			break
		}

		return e.complexity.VIFRequirements.Met(childComplexity), true

	case "VIFRequirements.missingReasons":
		if e.complexity.VIFRequirements.MissingReasons == nil {
			break
		}

		return e.complexity.VIFRequirements.MissingReasons(childComplexity), true

	case "VIFRequirements.networkNamespace":
		if e.complexity.VIFRequirements.NetworkNamespace == nil {
			break
		}

		return e.complexity.VIFRequirements.NetworkNamespace(childComplexity), true

	case "VIFRequirements.routerOSVersion":
		if e.complexity.VIFRequirements.RouterOSVersion == nil {
			break
		}

		return e.complexity.VIFRequirements.RouterOSVersion(childComplexity), true

	case "VIFRequirements.sufficientStorage":
		if e.complexity.VIFRequirements.SufficientStorage == nil {
			break
		}

		return e.complexity.VIFRequirements.SufficientStorage(childComplexity), true

	case "ValidateChangeSetPayload.changeSet":
		if e.complexity.ValidateChangeSetPayload.ChangeSet == nil {
			break
		}

		return e.complexity.ValidateChangeSetPayload.ChangeSet(childComplexity), true

	case "ValidateChangeSetPayload.errors":
		if e.complexity.ValidateChangeSetPayload.Errors == nil {
			break
		}

		return e.complexity.ValidateChangeSetPayload.Errors(childComplexity), true

	case "ValidateChangeSetPayload.validation":
		if e.complexity.ValidateChangeSetPayload.Validation == nil {
			break
		}

		return e.complexity.ValidateChangeSetPayload.Validation(childComplexity), true

	case "ValidateResourcePayload.errors":
		if e.complexity.ValidateResourcePayload.Errors == nil {
			break
		}

		return e.complexity.ValidateResourcePayload.Errors(childComplexity), true

	case "ValidateResourcePayload.resource":
		if e.complexity.ValidateResourcePayload.Resource == nil {
			break
		}

		return e.complexity.ValidateResourcePayload.Resource(childComplexity), true

	case "ValidateResourcePayload.validation":
		if e.complexity.ValidateResourcePayload.Validation == nil {
			break
		}

		return e.complexity.ValidateResourcePayload.Validation(childComplexity), true

	case "ValidationError.code":
		if e.complexity.ValidationError.Code == nil {
			break
		}

		return e.complexity.ValidationError.Code(childComplexity), true

	case "ValidationError.field":
		if e.complexity.ValidationError.Field == nil {
			break
		}

		return e.complexity.ValidationError.Field(childComplexity), true

	case "ValidationError.message":
		if e.complexity.ValidationError.Message == nil {
			break
		}

		return e.complexity.ValidationError.Message(childComplexity), true

	case "ValidationError.providedValue":
		if e.complexity.ValidationError.ProvidedValue == nil {
			break
		}

		return e.complexity.ValidationError.ProvidedValue(childComplexity), true

	case "ValidationError.suggestion":
		if e.complexity.ValidationError.Suggestion == nil {
			break
		}

		return e.complexity.ValidationError.Suggestion(childComplexity), true

	case "ValidationIssue.code":
		if e.complexity.ValidationIssue.Code == nil {
			break
		}

		return e.complexity.ValidationIssue.Code(childComplexity), true

	case "ValidationIssue.docsUrl":
		if e.complexity.ValidationIssue.DocsURL == nil {
			break
		}

		return e.complexity.ValidationIssue.DocsURL(childComplexity), true

	case "ValidationIssue.field":
		if e.complexity.ValidationIssue.Field == nil {
			break
		}

		return e.complexity.ValidationIssue.Field(childComplexity), true

	case "ValidationIssue.message":
		if e.complexity.ValidationIssue.Message == nil {
			break
		}

		return e.complexity.ValidationIssue.Message(childComplexity), true

	case "ValidationIssue.severity":
		if e.complexity.ValidationIssue.Severity == nil {
			break
		}

		return e.complexity.ValidationIssue.Severity(childComplexity), true

	case "ValidationIssue.suggestedFix":
		if e.complexity.ValidationIssue.SuggestedFix == nil {
			break
		}

		return e.complexity.ValidationIssue.SuggestedFix(childComplexity), true

	case "ValidationResult.canApply":
		if e.complexity.ValidationResult.CanApply == nil {
			break
		}

		return e.complexity.ValidationResult.CanApply(childComplexity), true

	case "ValidationResult.conflicts":
		if e.complexity.ValidationResult.Conflicts == nil {
			break
		}

		return e.complexity.ValidationResult.Conflicts(childComplexity), true

	case "ValidationResult.errors":
		if e.complexity.ValidationResult.Errors == nil {
			break
		}

		return e.complexity.ValidationResult.Errors(childComplexity), true

	case "ValidationResult.requiredDependencies":
		if e.complexity.ValidationResult.RequiredDependencies == nil {
			break
		}

		return e.complexity.ValidationResult.RequiredDependencies(childComplexity), true

	case "ValidationResult.stage":
		if e.complexity.ValidationResult.Stage == nil {
			break
		}

		return e.complexity.ValidationResult.Stage(childComplexity), true

	case "ValidationResult.validatedAt":
		if e.complexity.ValidationResult.ValidatedAt == nil {
			break
		}

		return e.complexity.ValidationResult.ValidatedAt(childComplexity), true

	case "ValidationResult.validationDurationMs":
		if e.complexity.ValidationResult.ValidationDurationMs == nil {
			break
		}

		return e.complexity.ValidationResult.ValidationDurationMs(childComplexity), true

	case "ValidationResult.warnings":
		if e.complexity.ValidationResult.Warnings == nil {
			break
		}

		return e.complexity.ValidationResult.Warnings(childComplexity), true

	case "Vlan.comment":
		if e.complexity.Vlan.Comment == nil {
			break
		}

		return e.complexity.Vlan.Comment(childComplexity), true

	case "Vlan.disabled":
		if e.complexity.Vlan.Disabled == nil {
			break
		}

		return e.complexity.Vlan.Disabled(childComplexity), true

	case "Vlan.id":
		if e.complexity.Vlan.ID == nil {
			break
		}

		return e.complexity.Vlan.ID(childComplexity), true

	case "Vlan.ipAddresses":
		if e.complexity.Vlan.IPAddresses == nil {
			break
		}

		return e.complexity.Vlan.IPAddresses(childComplexity), true

	case "Vlan.interface":
		if e.complexity.Vlan.Interface == nil {
			break
		}

		return e.complexity.Vlan.Interface(childComplexity), true

	case "Vlan.macAddress":
		if e.complexity.Vlan.MacAddress == nil {
			break
		}

		return e.complexity.Vlan.MacAddress(childComplexity), true

	case "Vlan.mtu":
		if e.complexity.Vlan.Mtu == nil {
			break
		}

		return e.complexity.Vlan.Mtu(childComplexity), true

	case "Vlan.name":
		if e.complexity.Vlan.Name == nil {
			break
		}

		return e.complexity.Vlan.Name(childComplexity), true

	case "Vlan.running":
		if e.complexity.Vlan.Running == nil {
			break
		}

		return e.complexity.Vlan.Running(childComplexity), true

	case "Vlan.statistics":
		if e.complexity.Vlan.Statistics == nil {
			break
		}

		return e.complexity.Vlan.Statistics(childComplexity), true

	case "Vlan.vlanId":
		if e.complexity.Vlan.VlanID == nil {
			break
		}

		return e.complexity.Vlan.VlanID(childComplexity), true

	case "VlanDependencies.activeConnections":
		if e.complexity.VlanDependencies.ActiveConnections == nil {
			break
		}

		return e.complexity.VlanDependencies.ActiveConnections(childComplexity), true

	case "VlanDependencies.dhcpServers":
		if e.complexity.VlanDependencies.DhcpServers == nil {
			break
		}

		return e.complexity.VlanDependencies.DhcpServers(childComplexity), true

	case "VlanDependencies.firewallRules":
		if e.complexity.VlanDependencies.FirewallRules == nil {
			break
		}

		return e.complexity.VlanDependencies.FirewallRules(childComplexity), true

	case "VlanDependencies.hasDependencies":
		if e.complexity.VlanDependencies.HasDependencies == nil {
			break
		}

		return e.complexity.VlanDependencies.HasDependencies(childComplexity), true

	case "VlanDependencies.ipAddresses":
		if e.complexity.VlanDependencies.IPAddresses == nil {
			break
		}

		return e.complexity.VlanDependencies.IPAddresses(childComplexity), true

	case "VlanDependencies.routes":
		if e.complexity.VlanDependencies.Routes == nil {
			break
		}

		return e.complexity.VlanDependencies.Routes(childComplexity), true

	case "VlanDependencies.vlanId":
		if e.complexity.VlanDependencies.VlanID == nil {
			break
		}

		return e.complexity.VlanDependencies.VlanID(childComplexity), true

	case "VlanMutationResult.errors":
		if e.complexity.VlanMutationResult.Errors == nil {
			break
		}

		return e.complexity.VlanMutationResult.Errors(childComplexity), true

	case "VlanMutationResult.preview":
		if e.complexity.VlanMutationResult.Preview == nil {
			break
		}

		return e.complexity.VlanMutationResult.Preview(childComplexity), true

	case "VlanMutationResult.success":
		if e.complexity.VlanMutationResult.Success == nil {
			break
		}

		return e.complexity.VlanMutationResult.Success(childComplexity), true

	case "VlanMutationResult.vlan":
		if e.complexity.VlanMutationResult.Vlan == nil {
			break
		}

		return e.complexity.VlanMutationResult.Vlan(childComplexity), true

	case "VlanTopology.edges":
		if e.complexity.VlanTopology.Edges == nil {
			break
		}

		return e.complexity.VlanTopology.Edges(childComplexity), true

	case "VlanTopology.nodes":
		if e.complexity.VlanTopology.Nodes == nil {
			break
		}

		return e.complexity.VlanTopology.Nodes(childComplexity), true

	case "WANConnectionEvent.duration":
		if e.complexity.WANConnectionEvent.Duration == nil {
			break
		}

		return e.complexity.WANConnectionEvent.Duration(childComplexity), true

	case "WANConnectionEvent.eventType":
		if e.complexity.WANConnectionEvent.EventType == nil {
			break
		}

		return e.complexity.WANConnectionEvent.EventType(childComplexity), true

	case "WANConnectionEvent.gateway":
		if e.complexity.WANConnectionEvent.Gateway == nil {
			break
		}

		return e.complexity.WANConnectionEvent.Gateway(childComplexity), true

	case "WANConnectionEvent.id":
		if e.complexity.WANConnectionEvent.ID == nil {
			break
		}

		return e.complexity.WANConnectionEvent.ID(childComplexity), true

	case "WANConnectionEvent.publicIP":
		if e.complexity.WANConnectionEvent.PublicIP == nil {
			break
		}

		return e.complexity.WANConnectionEvent.PublicIP(childComplexity), true

	case "WANConnectionEvent.reason":
		if e.complexity.WANConnectionEvent.Reason == nil {
			break
		}

		return e.complexity.WANConnectionEvent.Reason(childComplexity), true

	case "WANConnectionEvent.timestamp":
		if e.complexity.WANConnectionEvent.Timestamp == nil {
			break
		}

		return e.complexity.WANConnectionEvent.Timestamp(childComplexity), true

	case "WANConnectionEvent.wanInterfaceId":
		if e.complexity.WANConnectionEvent.WanInterfaceID == nil {
			break
		}

		return e.complexity.WANConnectionEvent.WanInterfaceID(childComplexity), true

	case "WANConnectionEventConnection.edges":
		if e.complexity.WANConnectionEventConnection.Edges == nil {
			break
		}

		return e.complexity.WANConnectionEventConnection.Edges(childComplexity), true

	case "WANConnectionEventConnection.pageInfo":
		if e.complexity.WANConnectionEventConnection.PageInfo == nil {
			break
		}

		return e.complexity.WANConnectionEventConnection.PageInfo(childComplexity), true

	case "WANConnectionEventConnection.totalCount":
		if e.complexity.WANConnectionEventConnection.TotalCount == nil {
			break
		}

		return e.complexity.WANConnectionEventConnection.TotalCount(childComplexity), true

	case "WANConnectionEventEdge.cursor":
		if e.complexity.WANConnectionEventEdge.Cursor == nil {
			break
		}

		return e.complexity.WANConnectionEventEdge.Cursor(childComplexity), true

	case "WANConnectionEventEdge.node":
		if e.complexity.WANConnectionEventEdge.Node == nil {
			break
		}

		return e.complexity.WANConnectionEventEdge.Node(childComplexity), true

	case "WANHealthStatus.enabled":
		if e.complexity.WANHealthStatus.Enabled == nil {
			break
		}

		return e.complexity.WANHealthStatus.Enabled(childComplexity), true

	case "WANHealthStatus.failureCount":
		if e.complexity.WANHealthStatus.FailureCount == nil {
			break
		}

		return e.complexity.WANHealthStatus.FailureCount(childComplexity), true

	case "WANHealthStatus.interval":
		if e.complexity.WANHealthStatus.Interval == nil {
			break
		}

		return e.complexity.WANHealthStatus.Interval(childComplexity), true

	case "WANHealthStatus.lastCheck":
		if e.complexity.WANHealthStatus.LastCheck == nil {
			break
		}

		return e.complexity.WANHealthStatus.LastCheck(childComplexity), true

	case "WANHealthStatus.latency":
		if e.complexity.WANHealthStatus.Latency == nil {
			break
		}

		return e.complexity.WANHealthStatus.Latency(childComplexity), true

	case "WANHealthStatus.packetLoss":
		if e.complexity.WANHealthStatus.PacketLoss == nil {
			break
		}

		return e.complexity.WANHealthStatus.PacketLoss(childComplexity), true

	case "WANHealthStatus.status":
		if e.complexity.WANHealthStatus.Status == nil {
			break
		}

		return e.complexity.WANHealthStatus.Status(childComplexity), true

	case "WANHealthStatus.successCount":
		if e.complexity.WANHealthStatus.SuccessCount == nil {
			break
		}

		return e.complexity.WANHealthStatus.SuccessCount(childComplexity), true

	case "WANHealthStatus.target":
		if e.complexity.WANHealthStatus.Target == nil {
			break
		}

		return e.complexity.WANHealthStatus.Target(childComplexity), true

	case "WANInterface.dhcpClient":
		if e.complexity.WANInterface.DhcpClient == nil {
			break
		}

		return e.complexity.WANInterface.DhcpClient(childComplexity), true

	case "WANInterface.gateway":
		if e.complexity.WANInterface.Gateway == nil {
			break
		}

		return e.complexity.WANInterface.Gateway(childComplexity), true

	case "WANInterface.health":
		if e.complexity.WANInterface.Health == nil {
			break
		}

		return e.complexity.WANInterface.Health(childComplexity), true

	case "WANInterface.id":
		if e.complexity.WANInterface.ID == nil {
			break
		}

		return e.complexity.WANInterface.ID(childComplexity), true

	case "WANInterface.interface":
		if e.complexity.WANInterface.Interface == nil {
			break
		}

		return e.complexity.WANInterface.Interface(childComplexity), true

	case "WANInterface.isDefaultRoute":
		if e.complexity.WANInterface.IsDefaultRoute == nil {
			break
		}

		return e.complexity.WANInterface.IsDefaultRoute(childComplexity), true

	case "WANInterface.lastConnected":
		if e.complexity.WANInterface.LastConnected == nil {
			break
		}

		return e.complexity.WANInterface.LastConnected(childComplexity), true

	case "WANInterface.lteModem":
		if e.complexity.WANInterface.LteModem == nil {
			break
		}

		return e.complexity.WANInterface.LteModem(childComplexity), true

	case "WANInterface.pppoeClient":
		if e.complexity.WANInterface.PppoeClient == nil {
			break
		}

		return e.complexity.WANInterface.PppoeClient(childComplexity), true

	case "WANInterface.primaryDNS":
		if e.complexity.WANInterface.PrimaryDNS == nil {
			break
		}

		return e.complexity.WANInterface.PrimaryDNS(childComplexity), true

	case "WANInterface.publicIP":
		if e.complexity.WANInterface.PublicIP == nil {
			break
		}

		return e.complexity.WANInterface.PublicIP(childComplexity), true

	case "WANInterface.secondaryDNS":
		if e.complexity.WANInterface.SecondaryDNS == nil {
			break
		}

		return e.complexity.WANInterface.SecondaryDNS(childComplexity), true

	case "WANInterface.staticConfig":
		if e.complexity.WANInterface.StaticConfig == nil {
			break
		}

		return e.complexity.WANInterface.StaticConfig(childComplexity), true

	case "WANInterface.statistics":
		if e.complexity.WANInterface.Statistics == nil {
			break
		}

		return e.complexity.WANInterface.Statistics(childComplexity), true

	case "WANInterface.status":
		if e.complexity.WANInterface.Status == nil {
			break
		}

		return e.complexity.WANInterface.Status(childComplexity), true

	case "WANInterface.type":
		if e.complexity.WANInterface.Type == nil {
			break
		}

		return e.complexity.WANInterface.Type(childComplexity), true

	case "WANInterface.uptime":
		if e.complexity.WANInterface.Uptime == nil {
			break
		}

		return e.complexity.WANInterface.Uptime(childComplexity), true

	case "WANLink.category":
		if e.complexity.WANLink.Category == nil {
			break
		}

		return e.complexity.WANLink.Category(childComplexity), true

	case "WANLink.configuration":
		if e.complexity.WANLink.Configuration == nil {
			break
		}

		return e.complexity.WANLink.Configuration(childComplexity), true

	case "WANLink.connectionType":
		if e.complexity.WANLink.ConnectionType == nil {
			break
		}

		return e.complexity.WANLink.ConnectionType(childComplexity), true

	case "WANLink.deployment":
		if e.complexity.WANLink.Deployment == nil {
			break
		}

		return e.complexity.WANLink.Deployment(childComplexity), true

	case "WANLink.failoverPriority":
		if e.complexity.WANLink.FailoverPriority == nil {
			break
		}

		return e.complexity.WANLink.FailoverPriority(childComplexity), true

	case "WANLink.id":
		if e.complexity.WANLink.ID == nil {
			break
		}

		return e.complexity.WANLink.ID(childComplexity), true

	case "WANLink.interface":
		if e.complexity.WANLink.Interface == nil {
			break
		}

		return e.complexity.WANLink.Interface(childComplexity), true

	case "WANLink.isPrimary":
		if e.complexity.WANLink.IsPrimary == nil {
			break
		}

		return e.complexity.WANLink.IsPrimary(childComplexity), true

	case "WANLink.metadata":
		if e.complexity.WANLink.Metadata == nil {
			break
		}

		return e.complexity.WANLink.Metadata(childComplexity), true

	case "WANLink.platform":
		if e.complexity.WANLink.Platform == nil {
			break
		}

		return e.complexity.WANLink.Platform(childComplexity), true

	case "WANLink.relationships":
		if e.complexity.WANLink.Relationships == nil {
			break
		}

		return e.complexity.WANLink.Relationships(childComplexity), true

	case "WANLink.runtime":
		if e.complexity.WANLink.Runtime == nil {
			break
		}

		return e.complexity.WANLink.Runtime(childComplexity), true

	case "WANLink.scopedId":
		if e.complexity.WANLink.ScopedID == nil {
			break
		}

		return e.complexity.WANLink.ScopedID(childComplexity), true

	case "WANLink.telemetry":
		if e.complexity.WANLink.Telemetry == nil {
			break
		}

		return e.complexity.WANLink.Telemetry(childComplexity), true

	case "WANLink.type":
		if e.complexity.WANLink.Type == nil {
			break
		}

		return e.complexity.WANLink.Type(childComplexity), true

	case "WANLink.validation":
		if e.complexity.WANLink.Validation == nil {
			break
		}

		return e.complexity.WANLink.Validation(childComplexity), true

	case "WANLink.wanRuntime":
		if e.complexity.WANLink.WanRuntime == nil {
			break
		}

		return e.complexity.WANLink.WanRuntime(childComplexity), true

	case "WANLinkRuntime.currentIP":
		if e.complexity.WANLinkRuntime.CurrentIP == nil {
			break
		}

		return e.complexity.WANLinkRuntime.CurrentIP(childComplexity), true

	case "WANLinkRuntime.dnsServers":
		if e.complexity.WANLinkRuntime.DNSServers == nil {
			break
		}

		return e.complexity.WANLinkRuntime.DNSServers(childComplexity), true

	case "WANLinkRuntime.downlinkSpeed":
		if e.complexity.WANLinkRuntime.DownlinkSpeed == nil {
			break
		}

		return e.complexity.WANLinkRuntime.DownlinkSpeed(childComplexity), true

	case "WANLinkRuntime.errorMessage":
		if e.complexity.WANLinkRuntime.ErrorMessage == nil {
			break
		}

		return e.complexity.WANLinkRuntime.ErrorMessage(childComplexity), true

	case "WANLinkRuntime.gateway":
		if e.complexity.WANLinkRuntime.Gateway == nil {
			break
		}

		return e.complexity.WANLinkRuntime.Gateway(childComplexity), true

	case "WANLinkRuntime.health":
		if e.complexity.WANLinkRuntime.Health == nil {
			break
		}

		return e.complexity.WANLinkRuntime.Health(childComplexity), true

	case "WANLinkRuntime.isRunning":
		if e.complexity.WANLinkRuntime.IsRunning == nil {
			break
		}

		return e.complexity.WANLinkRuntime.IsRunning(childComplexity), true

	case "WANLinkRuntime.lastStateChange":
		if e.complexity.WANLinkRuntime.LastStateChange == nil {
			break
		}

		return e.complexity.WANLinkRuntime.LastStateChange(childComplexity), true

	case "WANLinkRuntime.lastUpdated":
		if e.complexity.WANLinkRuntime.LastUpdated == nil {
			break
		}

		return e.complexity.WANLinkRuntime.LastUpdated(childComplexity), true

	case "WANLinkRuntime.publicIP":
		if e.complexity.WANLinkRuntime.PublicIP == nil {
			break
		}

		return e.complexity.WANLinkRuntime.PublicIP(childComplexity), true

	case "WANLinkRuntime.uplinkSpeed":
		if e.complexity.WANLinkRuntime.UplinkSpeed == nil {
			break
		}

		return e.complexity.WANLinkRuntime.UplinkSpeed(childComplexity), true

	case "WANLinkRuntime.uptime":
		if e.complexity.WANLinkRuntime.Uptime == nil {
			break
		}

		return e.complexity.WANLinkRuntime.Uptime(childComplexity), true

	case "WANMutationResult.errors":
		if e.complexity.WANMutationResult.Errors == nil {
			break
		}

		return e.complexity.WANMutationResult.Errors(childComplexity), true

	case "WANMutationResult.preview":
		if e.complexity.WANMutationResult.Preview == nil {
			break
		}

		return e.complexity.WANMutationResult.Preview(childComplexity), true

	case "WANMutationResult.success":
		if e.complexity.WANMutationResult.Success == nil {
			break
		}

		return e.complexity.WANMutationResult.Success(childComplexity), true

	case "WANMutationResult.wanInterface":
		if e.complexity.WANMutationResult.WanInterface == nil {
			break
		}

		return e.complexity.WANMutationResult.WanInterface(childComplexity), true

	case "WireGuardClient.category":
		if e.complexity.WireGuardClient.Category == nil {
			break
		}

		return e.complexity.WireGuardClient.Category(childComplexity), true

	case "WireGuardClient.config":
		if e.complexity.WireGuardClient.Config == nil {
			break
		}

		return e.complexity.WireGuardClient.Config(childComplexity), true

	case "WireGuardClient.configuration":
		if e.complexity.WireGuardClient.Configuration == nil {
			break
		}

		return e.complexity.WireGuardClient.Configuration(childComplexity), true

	case "WireGuardClient.deployment":
		if e.complexity.WireGuardClient.Deployment == nil {
			break
		}

		return e.complexity.WireGuardClient.Deployment(childComplexity), true

	case "WireGuardClient.id":
		if e.complexity.WireGuardClient.ID == nil {
			break
		}

		return e.complexity.WireGuardClient.ID(childComplexity), true

	case "WireGuardClient.metadata":
		if e.complexity.WireGuardClient.Metadata == nil {
			break
		}

		return e.complexity.WireGuardClient.Metadata(childComplexity), true

	case "WireGuardClient.platform":
		if e.complexity.WireGuardClient.Platform == nil {
			break
		}

		return e.complexity.WireGuardClient.Platform(childComplexity), true

	case "WireGuardClient.relationships":
		if e.complexity.WireGuardClient.Relationships == nil {
			break
		}

		return e.complexity.WireGuardClient.Relationships(childComplexity), true

	case "WireGuardClient.runtime":
		if e.complexity.WireGuardClient.Runtime == nil {
			break
		}

		return e.complexity.WireGuardClient.Runtime(childComplexity), true

	case "WireGuardClient.scopedId":
		if e.complexity.WireGuardClient.ScopedID == nil {
			break
		}

		return e.complexity.WireGuardClient.ScopedID(childComplexity), true

	case "WireGuardClient.telemetry":
		if e.complexity.WireGuardClient.Telemetry == nil {
			break
		}

		return e.complexity.WireGuardClient.Telemetry(childComplexity), true

	case "WireGuardClient.type":
		if e.complexity.WireGuardClient.Type == nil {
			break
		}

		return e.complexity.WireGuardClient.Type(childComplexity), true

	case "WireGuardClient.validation":
		if e.complexity.WireGuardClient.Validation == nil {
			break
		}

		return e.complexity.WireGuardClient.Validation(childComplexity), true

	case "WireGuardClient.wireguardDeployment":
		if e.complexity.WireGuardClient.WireguardDeployment == nil {
			break
		}

		return e.complexity.WireGuardClient.WireguardDeployment(childComplexity), true

	case "WireGuardClient.wireguardRuntime":
		if e.complexity.WireGuardClient.WireguardRuntime == nil {
			break
		}

		return e.complexity.WireGuardClient.WireguardRuntime(childComplexity), true

	case "WireGuardClientConfig.allowedIPs":
		if e.complexity.WireGuardClientConfig.AllowedIPs == nil {
			break
		}

		return e.complexity.WireGuardClientConfig.AllowedIPs(childComplexity), true

	case "WireGuardClientConfig.dnsServers":
		if e.complexity.WireGuardClientConfig.DNSServers == nil {
			break
		}

		return e.complexity.WireGuardClientConfig.DNSServers(childComplexity), true

	case "WireGuardClientConfig.killSwitch":
		if e.complexity.WireGuardClientConfig.KillSwitch == nil {
			break
		}

		return e.complexity.WireGuardClientConfig.KillSwitch(childComplexity), true

	case "WireGuardClientConfig.listenPort":
		if e.complexity.WireGuardClientConfig.ListenPort == nil {
			break
		}

		return e.complexity.WireGuardClientConfig.ListenPort(childComplexity), true

	case "WireGuardClientConfig.name":
		if e.complexity.WireGuardClientConfig.Name == nil {
			break
		}

		return e.complexity.WireGuardClientConfig.Name(childComplexity), true

	case "WireGuardClientConfig.peerEndpoint":
		if e.complexity.WireGuardClientConfig.PeerEndpoint == nil {
			break
		}

		return e.complexity.WireGuardClientConfig.PeerEndpoint(childComplexity), true

	case "WireGuardClientConfig.peerPublicKey":
		if e.complexity.WireGuardClientConfig.PeerPublicKey == nil {
			break
		}

		return e.complexity.WireGuardClientConfig.PeerPublicKey(childComplexity), true

	case "WireGuardClientConfig.persistentKeepalive":
		if e.complexity.WireGuardClientConfig.PersistentKeepalive == nil {
			break
		}

		return e.complexity.WireGuardClientConfig.PersistentKeepalive(childComplexity), true

	case "WireGuardClientConfig.privateKey":
		if e.complexity.WireGuardClientConfig.PrivateKey == nil {
			break
		}

		return e.complexity.WireGuardClientConfig.PrivateKey(childComplexity), true

	case "WireGuardClientConfig.wanInterface":
		if e.complexity.WireGuardClientConfig.WanInterface == nil {
			break
		}

		return e.complexity.WireGuardClientConfig.WanInterface(childComplexity), true

	case "WireGuardDeployment.appliedAt":
		if e.complexity.WireGuardDeployment.AppliedAt == nil {
			break
		}

		return e.complexity.WireGuardDeployment.AppliedAt(childComplexity), true

	case "WireGuardDeployment.appliedBy":
		if e.complexity.WireGuardDeployment.AppliedBy == nil {
			break
		}

		return e.complexity.WireGuardDeployment.AppliedBy(childComplexity), true

	case "WireGuardDeployment.drift":
		if e.complexity.WireGuardDeployment.Drift == nil {
			break
		}

		return e.complexity.WireGuardDeployment.Drift(childComplexity), true

	case "WireGuardDeployment.interfaceName":
		if e.complexity.WireGuardDeployment.InterfaceName == nil {
			break
		}

		return e.complexity.WireGuardDeployment.InterfaceName(childComplexity), true

	case "WireGuardDeployment.isInSync":
		if e.complexity.WireGuardDeployment.IsInSync == nil {
			break
		}

		return e.complexity.WireGuardDeployment.IsInSync(childComplexity), true

	case "WireGuardDeployment.publicKey":
		if e.complexity.WireGuardDeployment.PublicKey == nil {
			break
		}

		return e.complexity.WireGuardDeployment.PublicKey(childComplexity), true

	case "WireGuardDeployment.routerResourceId":
		if e.complexity.WireGuardDeployment.RouterResourceID == nil {
			break
		}

		return e.complexity.WireGuardDeployment.RouterResourceID(childComplexity), true

	case "WireGuardDeployment.routerVersion":
		if e.complexity.WireGuardDeployment.RouterVersion == nil {
			break
		}

		return e.complexity.WireGuardDeployment.RouterVersion(childComplexity), true

	case "WireGuardRuntime.activePeers":
		if e.complexity.WireGuardRuntime.ActivePeers == nil {
			break
		}

		return e.complexity.WireGuardRuntime.ActivePeers(childComplexity), true

	case "WireGuardRuntime.bytesIn":
		if e.complexity.WireGuardRuntime.BytesIn == nil {
			break
		}

		return e.complexity.WireGuardRuntime.BytesIn(childComplexity), true

	case "WireGuardRuntime.bytesOut":
		if e.complexity.WireGuardRuntime.BytesOut == nil {
			break
		}

		return e.complexity.WireGuardRuntime.BytesOut(childComplexity), true

	case "WireGuardRuntime.currentEndpoint":
		if e.complexity.WireGuardRuntime.CurrentEndpoint == nil {
			break
		}

		return e.complexity.WireGuardRuntime.CurrentEndpoint(childComplexity), true

	case "WireGuardRuntime.errorMessage":
		if e.complexity.WireGuardRuntime.ErrorMessage == nil {
			break
		}

		return e.complexity.WireGuardRuntime.ErrorMessage(childComplexity), true

	case "WireGuardRuntime.health":
		if e.complexity.WireGuardRuntime.Health == nil {
			break
		}

		return e.complexity.WireGuardRuntime.Health(childComplexity), true

	case "WireGuardRuntime.isConnected":
		if e.complexity.WireGuardRuntime.IsConnected == nil {
			break
		}

		return e.complexity.WireGuardRuntime.IsConnected(childComplexity), true

	case "WireGuardRuntime.isRunning":
		if e.complexity.WireGuardRuntime.IsRunning == nil {
			break
		}

		return e.complexity.WireGuardRuntime.IsRunning(childComplexity), true

	case "WireGuardRuntime.lastHandshake":
		if e.complexity.WireGuardRuntime.LastHandshake == nil {
			break
		}

		return e.complexity.WireGuardRuntime.LastHandshake(childComplexity), true

	case "WireGuardRuntime.lastUpdated":
		if e.complexity.WireGuardRuntime.LastUpdated == nil {
			break
		}

		return e.complexity.WireGuardRuntime.LastUpdated(childComplexity), true

	}
	return 0, false
}

func (e *executableSchema) Exec(ctx context.Context) graphql.ResponseHandler {
	rc := graphql.GetOperationContext(ctx)
	ec := executionContext{rc, e, 0, 0, make(chan graphql.DeferredResult)}
	inputUnmarshalMap := graphql.BuildUnmarshalerMap(
		ec.unmarshalInputAddBridgePortInput,
		ec.unmarshalInputAddRouterInput,
		ec.unmarshalInputAlertConditionInput,
		ec.unmarshalInputBatchInterfaceInput,
		ec.unmarshalInputBridgePortVlanInput,
		ec.unmarshalInputChangeSetItemInput,
		ec.unmarshalInputCreateAlertRuleInput,
		ec.unmarshalInputCreateBridgeInput,
		ec.unmarshalInputCreateBridgeVlanInput,
		ec.unmarshalInputCreateChangeSetInput,
		ec.unmarshalInputCreateResourceInput,
		ec.unmarshalInputCreateRouterInput,
		ec.unmarshalInputCredentialsInput,
		ec.unmarshalInputDhcpClientInput,
		ec.unmarshalInputDnsLookupInput,
		ec.unmarshalInputExportConfigInput,
		ec.unmarshalInputFeatureCompatibilityInput,
		ec.unmarshalInputIntRange,
		ec.unmarshalInputIpAddressInput,
		ec.unmarshalInputLteModemInput,
		ec.unmarshalInputPaginationInput,
		ec.unmarshalInputPppoeClientInput,
		ec.unmarshalInputQuietHoursConfigInput,
		ec.unmarshalInputResourceRelationshipsInput,
		ec.unmarshalInputRouteInput,
		ec.unmarshalInputScanNetworkInput,
		ec.unmarshalInputStaticIPInput,
		ec.unmarshalInputStatsTimeRangeInput,
		ec.unmarshalInputThrottleConfigInput,
		ec.unmarshalInputTracerouteInput,
		ec.unmarshalInputUpdateAlertRuleInput,
		ec.unmarshalInputUpdateBridgeInput,
		ec.unmarshalInputUpdateBridgePortInput,
		ec.unmarshalInputUpdateChangeSetItemInput,
		ec.unmarshalInputUpdateInterfaceInput,
		ec.unmarshalInputUpdateResourceInput,
		ec.unmarshalInputUpdateRouterInput,
		ec.unmarshalInputVlanFilter,
		ec.unmarshalInputVlanInput,
		ec.unmarshalInputWANHealthCheckInput,
	)
	first := true

	switch rc.Operation.Operation {
	case ast.Query:
		return func(ctx context.Context) *graphql.Response {
			var response graphql.Response
			var data graphql.Marshaler
			if first {
				first = false
				ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
				data = ec._Query(ctx, rc.Operation.SelectionSet)
			} else {
				if atomic.LoadInt32(&ec.pendingDeferred) > 0 {
					result := <-ec.deferredResults
					atomic.AddInt32(&ec.pendingDeferred, -1)
					data = result.Result
					response.Path = result.Path
					response.Label = result.Label
					response.Errors = result.Errors
				} else {
					return nil
				}
			}
			var buf bytes.Buffer
			data.MarshalGQL(&buf)
			response.Data = buf.Bytes()
			if atomic.LoadInt32(&ec.deferred) > 0 {
				hasNext := atomic.LoadInt32(&ec.pendingDeferred) > 0
				response.HasNext = &hasNext
			}

			return &response
		}
	case ast.Mutation:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
			data := ec._Mutation(ctx, rc.Operation.SelectionSet)
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}
	case ast.Subscription:
		next := ec._Subscription(ctx, rc.Operation.SelectionSet)

		var buf bytes.Buffer
		return func(ctx context.Context) *graphql.Response {
			buf.Reset()
			data := next(ctx)

			if data == nil {
				return nil
			}
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}

	default:
		return graphql.OneShot(graphql.ErrorResponse(ctx, "unsupported GraphQL operation"))
	}
}

type executionContext struct {
	*graphql.OperationContext
	*executableSchema
	deferred        int32
	pendingDeferred int32
	deferredResults chan graphql.DeferredResult
}

func (ec *executionContext) processDeferredGroup(dg graphql.DeferredGroup) {
	atomic.AddInt32(&ec.pendingDeferred, 1)
	go func() {
		ctx := graphql.WithFreshResponseContext(dg.Context)
		dg.FieldSet.Dispatch(ctx)
		ds := graphql.DeferredResult{
			Path:   dg.Path,
			Label:  dg.Label,
			Result: dg.FieldSet,
			Errors: graphql.GetErrors(ctx),
		}
		// null fields should bubble up
		if dg.FieldSet.Invalids > 0 {
			ds.Result = graphql.Null
		}
		ec.deferredResults <- ds
	}()
}

func (ec *executionContext) introspectSchema() (*introspection.Schema, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapSchema(ec.Schema()), nil
}

func (ec *executionContext) introspectType(name string) (*introspection.Type, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapTypeFromDef(ec.Schema(), ec.Schema().Types[name]), nil
}

var sources = []*ast.Source{
	{Name: "../../../schema/scalars.graphql", Input: `# =============================================================================
# Custom Scalar Definitions for NasNetConnect
# =============================================================================
# These scalars provide type safety for network-specific data types.
# Generated code will map these to appropriate language types.
# =============================================================================

"""
ISO 8601 datetime string (e.g., "2024-01-15T10:30:00Z")
"""
scalar DateTime

"""
Arbitrary JSON data for flexible configuration
"""
scalar JSON

"""
IPv4 address string (e.g., "192.168.1.1")
Validated format: XXX.XXX.XXX.XXX where XXX is 0-255
"""
scalar IPv4

"""
IPv6 address string (e.g., "2001:0db8:85a3:0000:0000:8a2e:0370:7334")
"""
scalar IPv6

"""
MAC address string (e.g., "00:1A:2B:3C:4D:5E" or "00-1A-2B-3C-4D-5E")
"""
scalar MAC

"""
CIDR notation for network address (e.g., "192.168.1.0/24")
"""
scalar CIDR

"""
TCP/UDP port number (1-65535)
"""
scalar Port

"""
Port range string (e.g., "80", "80-443", "80,443,8080")
"""
scalar PortRange

"""
Duration string in RouterOS format (e.g., "1d2h3m4s", "30s", "5m")
"""
scalar Duration

"""
Bandwidth string with unit (e.g., "10M", "1G", "100k")
"""
scalar Bandwidth

"""
Size in bytes with optional unit (e.g., "1024", "1k", "1M", "1G")
"""
scalar Size

"""
ULID (Universally Unique Lexicographically Sortable Identifier)
A 26-character string that is time-sortable and globally unique.
Example: "01ARZ3NDEKTSV4RRFFQ69G5FAV"
"""
scalar ULID
`, BuiltIn: false},
	{Name: "../../../schema/directives.graphql", Input: `# =============================================================================
# Custom Directive Definitions for NasNetConnect
# =============================================================================
# These directives enable:
# 1. Input validation (@validate) - Generates Zod schemas
# 2. Platform mapping (@mikrotik, @openwrt, @vyos) - Multi-platform support
# 3. Capability gating (@capability) - Feature-based access control
# =============================================================================

# -----------------------------------------------------------------------------
# Validation Directive
# -----------------------------------------------------------------------------
# Used to define validation constraints on input fields and field definitions.
# These constraints are:
# - Processed by graphql-codegen to generate Zod validation schemas
# - Used by gqlgen for server-side validation
#
# Example usage:
#   input CreateUserInput {
#     username: String! @validate(minLength: 3, maxLength: 32, pattern: "^[a-z0-9_]+$")
#     email: String! @validate(format: EMAIL)
#     age: Int @validate(min: 0, max: 150)
#   }
# -----------------------------------------------------------------------------
directive @validate(
  "Minimum value for numeric types"
  min: Int
  "Maximum value for numeric types"
  max: Int
  "Minimum length for string types"
  minLength: Int
  "Maximum length for string types"
  maxLength: Int
  "Regular expression pattern for string validation"
  pattern: String
  "Predefined format validation (EMAIL, URL, UUID, IPV4, IPV6, MAC, CIDR)"
  format: ValidateFormat
) on INPUT_FIELD_DEFINITION | FIELD_DEFINITION | ARGUMENT_DEFINITION

"""
Predefined validation formats for common data types
"""
enum ValidateFormat {
  EMAIL
  URL
  UUID
  IPV4
  IPV6
  MAC
  CIDR
  HOSTNAME
  FQDN
}

# -----------------------------------------------------------------------------
# Platform Mapping Directives
# -----------------------------------------------------------------------------
# These directives map GraphQL fields to platform-specific API paths.
# The resolver layer uses these to translate operations to router commands.
#
# Example usage:
#   type Interface {
#     name: String! @mikrotik(path: "/interface", field: "name") @openwrt(ubus: "network.interface", field: "interface")
#   }
# -----------------------------------------------------------------------------

"""
Maps field to MikroTik RouterOS API path and command
"""
directive @mikrotik(
  "RouterOS API path (e.g., '/ip/address', '/interface/ethernet')"
  path: String!
  "Field name in RouterOS response if different from GraphQL field"
  field: String
  "RouterOS command (print, add, set, remove) - defaults to contextual"
  cmd: String
) on FIELD_DEFINITION | OBJECT

"""
Maps field to OpenWrt ubus call
"""
directive @openwrt(
  "Ubus namespace and method (e.g., 'network.interface', 'system.board')"
  ubus: String!
  "Method to call (list, call, etc.)"
  method: String
  "Field name in ubus response if different from GraphQL field"
  field: String
) on FIELD_DEFINITION | OBJECT

"""
Maps field to VyOS configuration path
"""
directive @vyos(
  "VyOS configuration path (e.g., 'interfaces ethernet eth0')"
  path: String!
  "Field name in VyOS response if different from GraphQL field"
  field: String
) on FIELD_DEFINITION | OBJECT

# -----------------------------------------------------------------------------
# Capability Directive
# -----------------------------------------------------------------------------
# Gates field access based on router capabilities.
# Resolver checks if connected router has required capabilities before
# attempting to fetch/mutate the field.
#
# Example usage:
#   type WirelessInterface {
#     channel: Int! @capability(requires: ["wireless"])
#     wifiWave2: Boolean @capability(requires: ["wireless", "wifi-wave2"])
#   }
# -----------------------------------------------------------------------------
directive @capability(
  "List of required capability identifiers"
  requires: [String!]!
) on FIELD_DEFINITION | OBJECT

# -----------------------------------------------------------------------------
# Subscription Directive
# -----------------------------------------------------------------------------
# Marks a field as subscribable for real-time updates.
#
# Example usage:
#   type Subscription {
#     interfaceTraffic(interfaceId: ID!): TrafficUpdate! @realtime(interval: 1000)
#   }
# -----------------------------------------------------------------------------
directive @realtime(
  "Update interval in milliseconds"
  interval: Int
  "Topic/channel name for pub/sub"
  topic: String
) on FIELD_DEFINITION

# -----------------------------------------------------------------------------
# Caching Directive
# -----------------------------------------------------------------------------
# Hints for client-side and server-side caching behavior.
#
# Example usage:
#   type SystemInfo {
#     version: String! @cache(maxAge: 3600)
#     uptime: Duration! @cache(maxAge: 5)
#   }
# -----------------------------------------------------------------------------
directive @cache(
  "Maximum age in seconds"
  maxAge: Int!
  "Cache scope (PRIVATE for user-specific, PUBLIC for shared)"
  scope: CacheScope
) on FIELD_DEFINITION

enum CacheScope {
  PRIVATE
  PUBLIC
}

# -----------------------------------------------------------------------------
# Deprecated with migration hint
# -----------------------------------------------------------------------------
# Extended deprecation with migration guidance.
#
# Example usage:
#   type Query {
#     oldEndpoint: Data @deprecated(reason: "Use newEndpoint", replacement: "newEndpoint")
#   }
# -----------------------------------------------------------------------------
directive @migrateFrom(
  "The old field/type name this replaces"
  field: String!
  "Version when migration should be complete"
  removeInVersion: String
) on FIELD_DEFINITION | OBJECT | INPUT_FIELD_DEFINITION

# -----------------------------------------------------------------------------
# Sensitive Data Directive
# -----------------------------------------------------------------------------
# Marks fields containing sensitive data that should be redacted in logs
# and stripped from error responses in production mode.
#
# Example usage:
#   input CredentialsInput {
#     username: String!
#     password: String! @sensitive
#     apiKey: String @sensitive
#   }
#
#   type RouterSecret {
#     encryptedPassword: String! @sensitive
#     sshKey: String @sensitive
#   }
# -----------------------------------------------------------------------------
"""
Marks field as containing sensitive data (passwords, tokens, keys).
Values are redacted in logs and error responses.
"""
directive @sensitive on FIELD_DEFINITION | INPUT_FIELD_DEFINITION | ARGUMENT_DEFINITION

# -----------------------------------------------------------------------------
# Auth Directive
# -----------------------------------------------------------------------------
# Requires authentication and optional role/permission checks.
# Must be authenticated to access fields with this directive.
#
# Example usage:
#   type Mutation {
#     deleteRouter(id: ID!): Boolean! @auth(requires: "admin")
#     updateSettings: Settings! @auth  # Just requires authentication
#   }
# -----------------------------------------------------------------------------
"""
Requires authentication to access this field.
Optionally requires a specific role or permission.
"""
directive @auth(
  "Required role or permission level (e.g., 'admin', 'operator', 'viewer')"
  requires: String
) on FIELD_DEFINITION | OBJECT
`, BuiltIn: false},
	{Name: "../../../schema/schema.graphql", Input: `# =============================================================================
# NasNetConnect GraphQL Schema
# =============================================================================
# This is the main schema file defining queries, mutations, and subscriptions.
# It serves as the single source of truth for the API contract.
#
# Schema Structure:
# - scalars.graphql - Custom scalar type definitions
# - directives.graphql - Custom directive definitions
# - schema.graphql - This file (types, queries, mutations, subscriptions)
#
# Code Generation:
# - TypeScript: graphql-codegen generates types, hooks, and Zod schemas
# - Go: gqlgen generates structs, resolvers, and validators
# =============================================================================

# -----------------------------------------------------------------------------
# Core Interfaces
# -----------------------------------------------------------------------------

"""
Relay Node interface for global object identification
"""
interface Node {
  "Globally unique identifier"
  id: ID!
}

"""
Connection interface for paginated results (Relay pagination)
"""
interface Connection {
  "Pagination information"
  pageInfo: PageInfo!
  "Total count of items (if available)"
  totalCount: Int
}

"""
Edge interface for connection edges
"""
interface Edge {
  "Cursor for pagination"
  cursor: String!
}

# -----------------------------------------------------------------------------
# Pagination Types
# -----------------------------------------------------------------------------

"""
Information about pagination in a connection
"""
type PageInfo {
  "When paginating forwards, are there more items?"
  hasNextPage: Boolean!
  "When paginating backwards, are there more items?"
  hasPreviousPage: Boolean!
  "Cursor for the first edge"
  startCursor: String
  "Cursor for the last edge"
  endCursor: String
}

"""
Standard pagination input arguments
"""
input PaginationInput {
  "Number of items to fetch"
  first: Int
  "Cursor to fetch items after"
  after: String
  "Number of items to fetch from the end"
  last: Int
  "Cursor to fetch items before"
  before: String
}

# -----------------------------------------------------------------------------
# Health & System Types
# -----------------------------------------------------------------------------

"""
Overall system health status
"""
type HealthStatus {
  "Service status"
  status: ServiceStatus!
  "Service version"
  version: String!
  "Server uptime"
  uptime: Duration
  "Connected router count"
  connectedRouters: Int!
  "Last health check timestamp"
  checkedAt: DateTime!
}

"""
Service operational status
"""
enum ServiceStatus {
  "Service is fully operational"
  HEALTHY
  "Service is operational with degraded performance"
  DEGRADED
  "Service is not operational"
  UNHEALTHY
}

"""
Router connection status
"""
enum ConnectionStatus {
  "Actively connected and responsive"
  CONNECTED
  "Connection attempt in progress"
  CONNECTING
  "Not connected"
  DISCONNECTED
  "Connection failed with error"
  ERROR
}

# -----------------------------------------------------------------------------
# Router Types
# -----------------------------------------------------------------------------

"""
A managed router device
"""
type Router implements Node {
  "Unique router identifier"
  id: ID!
  "User-friendly display name"
  name: String!
  "Router hostname or IP address"
  host: String!
  "Connection port"
  port: Int!
  "Current connection status"
  status: ConnectionStatus!
  "Router platform type"
  platform: RouterPlatform!
  "RouterOS version (if connected)"
  version: String @mikrotik(path: "/system/resource", field: "version")
  "Router model"
  model: String @mikrotik(path: "/system/routerboard", field: "model")
  "System uptime"
  uptime: Duration @mikrotik(path: "/system/resource", field: "uptime")
  "Last successful connection time"
  lastConnected: DateTime
  "When the router was added to NasNet"
  createdAt: DateTime!
  "Last update timestamp"
  updatedAt: DateTime!
  "Detected router capabilities (requires connection)"
  capabilities: RouterCapabilities
}

"""
Supported router platforms
"""
enum RouterPlatform {
  "MikroTik RouterOS"
  MIKROTIK
  "OpenWrt"
  OPENWRT
  "VyOS"
  VYOS
  "Generic/Unknown"
  GENERIC
}

"""
Input for creating a new router connection
"""
input CreateRouterInput {
  "User-friendly display name"
  name: String! @validate(minLength: 1, maxLength: 64)
  "Router hostname or IP address"
  host: String! @validate(minLength: 1, maxLength: 255)
  "Connection port (default: 8728 for MikroTik API)"
  port: Int @validate(min: 1, max: 65535)
  "Username for authentication"
  username: String! @validate(minLength: 1, maxLength: 64)
  "Password for authentication"
  password: String! @validate(minLength: 1, maxLength: 128)
  "Router platform type"
  platform: RouterPlatform
}

"""
Input for updating router settings
"""
input UpdateRouterInput {
  "Updated display name"
  name: String @validate(minLength: 1, maxLength: 64)
  "Updated hostname or IP address"
  host: String @validate(minLength: 1, maxLength: 255)
  "Updated connection port"
  port: Int @validate(min: 1, max: 65535)
  "Updated username"
  username: String @validate(minLength: 1, maxLength: 64)
  "Updated password"
  password: String @validate(minLength: 1, maxLength: 128)
}

# -----------------------------------------------------------------------------
# Interface Types (Network Interfaces)
# -----------------------------------------------------------------------------

"""
A network interface on a router
"""
type Interface implements Node {
  "Unique interface identifier"
  id: ID!
  "Interface name (e.g., ether1, wlan1)"
  name: String! @mikrotik(path: "/interface", field: "name")
  "Interface type"
  type: InterfaceType! @mikrotik(path: "/interface", field: "type")
  "Whether the interface is enabled"
  enabled: Boolean! @mikrotik(path: "/interface", field: "disabled")
  "Whether the interface is running (link up)"
  running: Boolean! @mikrotik(path: "/interface", field: "running")
  "MAC address"
  macAddress: MAC @mikrotik(path: "/interface", field: "mac-address")
  "MTU setting"
  mtu: Int @mikrotik(path: "/interface", field: "mtu")
  "User comment"
  comment: String @mikrotik(path: "/interface", field: "comment")
  "TX bytes"
  txBytes: Size @mikrotik(path: "/interface", field: "tx-byte")
  "RX bytes"
  rxBytes: Size @mikrotik(path: "/interface", field: "rx-byte")

  # Dashboard-specific fields
  "IP address assigned to this interface"
  ip: IPv4 @mikrotik(path: "/ip/address", field: "address")
  "Operational status of the interface"
  status: InterfaceStatus!
  "Current transmit rate in bytes per second"
  txRate: Size @mikrotik(path: "/interface", field: "tx-bits-per-second")
  "Current receive rate in bytes per second"
  rxRate: Size @mikrotik(path: "/interface", field: "rx-bits-per-second")
  "Link speed (e.g., 1Gbps, 100Mbps)"
  linkSpeed: String @mikrotik(path: "/interface/ethernet", field: "rate")
  "Last time this interface was seen/queried"
  lastSeen: DateTime
  "Connected device information from LLDP"
  linkPartner: String
  "Services using this interface (bridge, VPN, etc.)"
  usedBy: [String!]
}

"""
Types of network interfaces
"""
enum InterfaceType {
  ETHERNET
  VLAN
  BRIDGE
  WIRELESS
  TUNNEL
  PPP
  BONDING
  LOOPBACK
  VIRTUAL
  OTHER
}

"""
Operational status of a network interface
"""
enum InterfaceStatus {
  "Interface is up and running"
  UP
  "Interface is down"
  DOWN
  "Interface is disabled"
  DISABLED
  "Status unknown or error"
  UNKNOWN
}

"""
Event emitted when an interface status changes
"""
type InterfaceStatusEvent {
  "Interface ID"
  interfaceId: ID!
  "Interface name"
  interfaceName: String!
  "New status"
  status: InterfaceStatus!
  "Previous status"
  previousStatus: InterfaceStatus!
  "Event timestamp"
  timestamp: DateTime!
}

# -----------------------------------------------------------------------------
# Interface Subscription Extensions
# -----------------------------------------------------------------------------

extend type Subscription {
  """
  Subscribe to interface status changes for real-time updates
  """
  interfaceStatusChanged(
    "Router ID to monitor"
    routerId: ID!
    "Optional interface ID to filter events (if not provided, all interfaces)"
    interfaceId: ID
  ): InterfaceStatusEvent!
}

# -----------------------------------------------------------------------------
# Resource Metrics Types (System Resources)
# -----------------------------------------------------------------------------

"""
Device (router) for querying resource metrics
"""
type Device {
  "Device identifier"
  id: ID!
  "Current resource utilization metrics"
  resourceMetrics: ResourceMetrics!
}

"""
Real-time resource utilization metrics for a device
"""
type ResourceMetrics {
  "CPU utilization metrics"
  cpu: CPUMetrics!
  "Memory utilization metrics"
  memory: MemoryMetrics!
  "Storage utilization metrics"
  storage: StorageMetrics!
  "Temperature in Celsius (null if not supported)"
  temperature: Float
  "Timestamp when metrics were collected"
  timestamp: DateTime!
}

"""
CPU utilization metrics
"""
type CPUMetrics {
  "Overall CPU usage percentage (0-100)"
  usage: Float!
  "Number of CPU cores"
  cores: Int!
  "Per-core usage percentages (one per core)"
  perCore: [Float!]!
  "CPU frequency in MHz (optional)"
  frequency: Float
}

"""
Memory utilization metrics
"""
type MemoryMetrics {
  "Used memory in bytes"
  used: Float!
  "Total memory in bytes"
  total: Float!
  "Memory usage percentage (0-100)"
  percentage: Float!
}

"""
Storage utilization metrics
"""
type StorageMetrics {
  "Used storage in bytes"
  used: Float!
  "Total storage in bytes"
  total: Float!
  "Storage usage percentage (0-100)"
  percentage: Float!
}

# -----------------------------------------------------------------------------
# Query Root
# -----------------------------------------------------------------------------

type Query {
  "Fetch any node by its global ID"
  node(id: ID!): Node

  "Get system health status"
  health: HealthStatus!

  "Get current API version"
  version: String!

  # Device Queries (Resource Metrics)
  "Get a device by ID for resource metrics"
  device(id: ID!): Device

  # Router Queries
  "Get a router by ID"
  router(id: ID!): Router
  "List all managed routers"
  routers(
    "Filter by connection status"
    status: ConnectionStatus
    "Pagination parameters"
    pagination: PaginationInput
  ): RouterConnection!

  # Interface Queries (require active router connection)
  "Get a network interface by ID"
  interface(
    "Router to query"
    routerId: ID!
    "Interface ID"
    id: ID!
  ): Interface @capability(requires: ["interface"])

  "List interfaces on a router"
  interfaces(
    "Router to query"
    routerId: ID!
    "Filter by interface type"
    type: InterfaceType
    "Pagination parameters"
    pagination: PaginationInput
  ): InterfaceConnection! @capability(requires: ["interface"])

  # Capability Queries
  "Get router capabilities by router ID"
  routerCapabilities(routerId: ID!): RouterCapabilities

  # Version Compatibility Queries
  "Check if a feature is supported on a specific router"
  isFeatureSupported(
    "Router to check"
    routerId: ID!
    "Feature identifier"
    featureId: String!
  ): FeatureSupport!

  "Get all features supported by a router"
  supportedFeatures(routerId: ID!): [FeatureSupport!]!

  "Get features not supported by a router with upgrade guidance"
  unsupportedFeatures(routerId: ID!): [FeatureSupport!]!

  "Get the compatibility matrix for all known features"
  compatibilityMatrix: [FeatureCompatibilityInfo!]!

  # Upgrade Recommendation Queries
  "Get upgrade recommendation for a specific feature on a router"
  upgradeRecommendation(
    "Router to check"
    routerId: ID!
    "Feature to enable"
    featureId: String!
  ): UpgradeRecommendation

  "Get all upgrade recommendations for a router"
  upgradeRecommendations(routerId: ID!): [UpgradeRecommendation!]!
}

"""
Information about a feature in the compatibility matrix
"""
type FeatureCompatibilityInfo {
  "Feature identifier"
  featureId: String!
  "Human-readable feature name"
  name: String!
  "Minimum RouterOS version required"
  minVersion: String!
  "Maximum RouterOS version supported (if any)"
  maxVersion: String
  "Minimum version for CHR (if different)"
  minVersionCHR: String
  "Required packages"
  requiredPackages: [String!]!
  "Feature dependencies"
  dependsOn: [String!]!
  "URL to MikroTik documentation"
  upgradeUrl: String
}

# -----------------------------------------------------------------------------
# Mutation Root
# -----------------------------------------------------------------------------

type Mutation {
  # Router Management
  "Add a new router to manage"
  createRouter(input: CreateRouterInput!): CreateRouterPayload!
  "Update router settings"
  updateRouter(id: ID!, input: UpdateRouterInput!): UpdateRouterPayload!
  "Remove a router"
  deleteRouter(id: ID!): DeleteRouterPayload!
  "Test connection to a router"
  testRouterConnection(id: ID!): TestConnectionPayload!
  "Connect to a router"
  connectRouter(id: ID!): ConnectRouterPayload!
  "Disconnect from a router"
  disconnectRouter(id: ID!): DisconnectRouterPayload!

  # Capability Management
  "Force refresh router capabilities (invalidates cache)"
  refreshCapabilities(routerId: ID!): RefreshCapabilitiesPayload!

  # Interface Management
  "Update interface settings (MTU, comment, ARP mode)"
  updateInterface(
    routerId: ID!
    interfaceId: ID!
    input: UpdateInterfaceInput!
  ): UpdateInterfacePayload!

  "Enable an interface"
  enableInterface(
    routerId: ID!
    interfaceId: ID!
  ): UpdateInterfacePayload!

  "Disable an interface"
  disableInterface(
    routerId: ID!
    interfaceId: ID!
  ): UpdateInterfacePayload!

  "Batch operation on multiple interfaces"
  batchInterfaceOperation(
    routerId: ID!
    input: BatchInterfaceInput!
  ): BatchInterfacePayload!

  # Device Scanning mutations are defined in scanner.graphql
}

# -----------------------------------------------------------------------------
# Subscription Root
# -----------------------------------------------------------------------------

type Subscription {
  "Subscribe to router status changes"
  routerStatusChanged(routerId: ID): RouterStatusEvent!

  "Subscribe to real-time resource metrics updates"
  resourceMetrics(
    "Device ID to monitor"
    deviceId: ID!
  ): ResourceMetrics! @realtime(interval: 2000)

  "Subscribe to interface traffic updates"
  interfaceTraffic(
    routerId: ID!
    interfaceId: ID
  ): InterfaceTrafficEvent! @realtime(interval: 1000)

  "Subscribe to resource updates (create, update, delete)"
  resourceUpdated(resourceId: ID): ResourceUpdatedEvent!

  "Subscribe to configuration apply progress"
  configApplyProgress(operationId: ID!): ConfigProgress!

  # Device scan subscriptions are defined in scanner.graphql
}

# -----------------------------------------------------------------------------
# Connection Types (Relay Pagination)
# -----------------------------------------------------------------------------

type RouterConnection implements Connection {
  edges: [RouterEdge!]!
  pageInfo: PageInfo!
  totalCount: Int
}

type RouterEdge implements Edge {
  node: Router!
  cursor: String!
}

type InterfaceConnection implements Connection {
  edges: [InterfaceEdge!]!
  pageInfo: PageInfo!
  totalCount: Int
}

type InterfaceEdge implements Edge {
  node: Interface!
  cursor: String!
}

# -----------------------------------------------------------------------------
# Interface Management Inputs
# -----------------------------------------------------------------------------

"""
Input for updating interface settings
"""
input UpdateInterfaceInput {
  "Enable or disable the interface"
  enabled: Boolean
  "MTU size (68-9000 bytes)"
  mtu: Int @validate(min: 68, max: 9000)
  "Interface comment"
  comment: String @validate(maxLength: 255)
}

"""
Input for batch interface operations
"""
input BatchInterfaceInput {
  "Interface IDs to operate on"
  interfaceIds: [ID!]!
  "Action to perform"
  action: BatchInterfaceAction!
  "Optional input for UPDATE action"
  input: UpdateInterfaceInput
}

"""
Actions available for batch interface operations
"""
enum BatchInterfaceAction {
  ENABLE
  DISABLE
  UPDATE
}

"""
Payload returned by updateInterface, enableInterface, and disableInterface mutations
"""
type UpdateInterfacePayload {
  "Updated interface"
  interface: Interface
  "Errors that occurred during the operation"
  errors: [MutationError!]
}

"""
Payload returned by batchInterfaceOperation mutation
"""
type BatchInterfacePayload {
  "Interfaces that were successfully updated"
  succeeded: [Interface!]!
  "Interfaces that failed with reasons"
  failed: [InterfaceOperationError!]!
  "General errors that occurred"
  errors: [MutationError!]
}

"""
Error information for a single interface operation in a batch
"""
type InterfaceOperationError {
  "Interface ID that failed"
  interfaceId: ID!
  "Interface name"
  interfaceName: String!
  "Error message describing why the operation failed"
  error: String!
}

# -----------------------------------------------------------------------------
# Mutation Payloads
# -----------------------------------------------------------------------------

"""
Standard error type for mutations
"""
type MutationError {
  "Error code for programmatic handling"
  code: String!
  "Human-readable error message"
  message: String!
  "Field that caused the error (if applicable)"
  field: String
}

"""
Rich error extensions for detailed error diagnostics.
Included in GraphQL error responses under the 'extensions' key.
"""
type ErrorExtensions {
  "Error code for programmatic handling (e.g., 'V400', 'R200')"
  code: String!
  "Error category (validation, protocol, network, auth, resource, internal)"
  category: String!
  "Field path that caused the error (e.g., 'input.listenPort')"
  field: String
  "The invalid value (redacted in production for sensitive fields)"
  value: JSON
  "User-friendly suggestion for fixing the error"
  suggestedFix: String
  "Link to relevant documentation"
  docsUrl: String
  "Request correlation ID for support and debugging"
  requestId: String!
  "Whether the error is recoverable (can be retried)"
  recoverable: Boolean!
  "Additional troubleshooting steps for complex errors"
  troubleshootingSteps: [String!]
}

type CreateRouterPayload {
  "The created router"
  router: Router
  "Errors that occurred during creation"
  errors: [MutationError!]
}

type UpdateRouterPayload {
  "The updated router"
  router: Router
  "Errors that occurred during update"
  errors: [MutationError!]
}

type DeleteRouterPayload {
  "Whether deletion was successful"
  success: Boolean!
  "ID of the deleted router"
  deletedRouterId: ID
  "Errors that occurred during deletion"
  errors: [MutationError!]
}

type TestConnectionPayload {
  "Whether the connection test succeeded"
  success: Boolean!
  "Response time in milliseconds"
  responseTimeMs: Int
  "Router version if connection succeeded"
  version: String
  "Error message if connection failed"
  error: String
}

type ConnectRouterPayload {
  "The router that was connected"
  router: Router
  "Errors that occurred during connection"
  errors: [MutationError!]
}

type DisconnectRouterPayload {
  "The router that was disconnected"
  router: Router
  "Errors that occurred during disconnection"
  errors: [MutationError!]
}

# -----------------------------------------------------------------------------
# Subscription Events
# -----------------------------------------------------------------------------

type RouterStatusEvent {
  "The router whose status changed"
  router: Router!
  "Previous status"
  previousStatus: ConnectionStatus!
  "New status"
  newStatus: ConnectionStatus!
  "Timestamp of the change"
  timestamp: DateTime!
}

type InterfaceTrafficEvent {
  "Interface ID"
  interfaceId: ID!
  "Interface name"
  interfaceName: String!
  "TX rate in bytes per second"
  txRate: Size!
  "RX rate in bytes per second"
  rxRate: Size!
  "Total TX bytes"
  txTotal: Size!
  "Total RX bytes"
  rxTotal: Size!
  "Timestamp"
  timestamp: DateTime!
}

"""
Event emitted when a router resource is updated
"""
type ResourceUpdatedEvent {
  "Unique resource identifier"
  resourceId: ID!
  "Type of resource (interface, firewall-rule, dhcp-lease, etc.)"
  resourceType: String!
  "Router this resource belongs to"
  routerId: ID!
  "New version number after update"
  version: Int!
  "Fields that were changed"
  changedFields: [String!]!
  "Type of change (create, update, delete)"
  changeType: ChangeType!
  "Timestamp of the update"
  timestamp: DateTime!
}

"""
Type of change for resource events
"""
enum ChangeType {
  CREATE
  UPDATE
  DELETE
}

"""
Progress information for configuration apply operations
"""
type ConfigProgress {
  "Unique operation identifier"
  operationId: ID!
  "Current status of the operation"
  status: ConfigApplyStatus!
  "Completion percentage (0-100)"
  percentage: Int!
  "Human-readable progress message"
  message: String!
  "Current step number"
  currentStep: Int
  "Total number of steps"
  totalSteps: Int
  "Timestamp of this progress update"
  timestamp: DateTime!
}

"""
Status of a configuration apply operation
"""
enum ConfigApplyStatus {
  PENDING
  VALIDATING
  APPLYING
  VERIFYING
  COMPLETED
  FAILED
  ROLLED_BACK
}

# -----------------------------------------------------------------------------
# Capability Types
# -----------------------------------------------------------------------------

"""
Feature capability categories detected on routers.
Used to determine what features are available on a specific router.
"""
enum Capability {
  "Container/Docker support"
  CONTAINER
  "Virtual Interface Factory support"
  VIF
  "Wireless/WiFi support"
  WIRELESS
  "Advanced routing features"
  ROUTING
  "Firewall features"
  FIREWALL
  "MPLS support"
  MPLS
  "IPv6 support"
  IPV6
  "Hotspot features"
  HOTSPOT
  "User Manager features"
  USER_MANAGER
  "Dude monitoring support"
  DUDE
  "WireGuard VPN support"
  WIREGUARD
  "ZeroTier support"
  ZEROTIER
}

"""
Capability support level for a feature.
Determines how the feature appears in the UI.
"""
enum CapabilityLevel {
  "Feature not supported (hide in UI)"
  NONE
  "Limited support (show with warnings)"
  BASIC
  "Full RouterOS native support"
  ADVANCED
  "Complete support including container-based features"
  FULL
}

"""
Single capability with its support level and guidance
"""
type CapabilityEntry {
  "Capability category"
  capability: Capability!
  "Support level"
  level: CapabilityLevel!
  "Human-readable description of support"
  description: String
  "Actionable message if feature unavailable"
  guidance: String
}

"""
Hardware information detected from router
"""
type HardwareInfo {
  "CPU architecture (arm, arm64, x86_64, etc.)"
  architecture: String!
  "Router model name"
  model: String
  "Board name"
  boardName: String
  "Total RAM in bytes"
  totalMemory: Size!
  "Available storage in bytes"
  availableStorage: Size!
  "Number of CPU cores"
  cpuCount: Int!
  "Whether wireless hardware is present"
  hasWirelessChip: Boolean!
  "Whether LTE/cellular hardware is present"
  hasLTEModule: Boolean!
}

"""
Software information detected from router
"""
type SoftwareInfo {
  "RouterOS version string"
  version: String!
  "Parsed major version number"
  versionMajor: Int!
  "Parsed minor version number"
  versionMinor: Int!
  "Parsed patch version number"
  versionPatch: Int
  "List of installed packages"
  installedPackages: [String!]!
  "License level (0-6)"
  licenseLevel: Int!
  "Update channel (stable, testing, development)"
  updateChannel: String
}

"""
Container-specific capability information
"""
type ContainerInfo {
  "Whether container package is installed"
  packageInstalled: Boolean!
  "Whether container feature is enabled in system settings"
  enabled: Boolean!
  "Whether a container registry is configured"
  registryConfigured: Boolean!
  "Available storage for container images in bytes"
  storageAvailable: Size!
  "Whether network namespace is supported"
  supportsNetworkNamespace: Boolean!
  "Maximum number of containers supported"
  maxContainers: Int
}

"""
VIF (Virtual Interface Factory) requirements check result
"""
type VIFRequirements {
  "Whether all VIF requirements are satisfied"
  met: Boolean!
  "Whether RouterOS version is sufficient (7.13+)"
  routerOSVersion: Boolean!
  "Whether container package is installed"
  containerPackage: Boolean!
  "Whether container feature is enabled"
  containerEnabled: Boolean!
  "Whether there's sufficient storage (>100MB)"
  sufficientStorage: Boolean!
  "Whether network namespace is supported"
  networkNamespace: Boolean!
  "Human-readable reasons why VIF is not available"
  missingReasons: [String!]!
  "Step-by-step guidance for enabling VIF"
  guidanceSteps: [VIFGuidanceStep!]!
}

"""
Single step in VIF enablement guidance
"""
type VIFGuidanceStep {
  "Step number (1-based)"
  step: Int!
  "Short title for the step"
  title: String!
  "Detailed instruction"
  description: String!
  "Whether this requirement is already met"
  completed: Boolean!
  "RouterOS command to execute (if applicable)"
  routerCommand: String
}

"""
Complete router capabilities detected from system inspection
"""
type RouterCapabilities {
  "Hardware information"
  hardware: HardwareInfo!
  "Software information"
  software: SoftwareInfo!
  "Container-specific capabilities"
  container: ContainerInfo!
  "Capability entries with support levels"
  capabilities: [CapabilityEntry!]!
  "VIF requirements check"
  vifRequirements: VIFRequirements!
  "Features supported by this router's version and configuration"
  supportedFeatures: [FeatureSupport!]!
  "Features not supported by this router (with upgrade guidance)"
  unsupportedFeatures: [FeatureSupport!]!
  "Parsed RouterOS version with comparison helpers"
  routerOSVersion: RouterOSVersion!
  "When capabilities were detected"
  detectedAt: DateTime!
  "When cache expires (24h TTL)"
  expiresAt: DateTime!
  "Whether cache is stale and refresh is in progress"
  isRefreshing: Boolean!
}

"""
Parsed RouterOS version with semantic versioning
"""
type RouterOSVersion {
  "Full version string (e.g., '7.13.2')"
  raw: String!
  "Major version number"
  major: Int!
  "Minor version number"
  minor: Int!
  "Patch version number"
  patch: Int!
  "Version channel (stable, beta, rc, long-term)"
  channel: String
  "Whether this is a Cloud Hosted Router (CHR)"
  isCHR: Boolean!
  "Check if this version supports a specific feature"
  supportsFeature(featureId: String!): Boolean!
  "Check if version is at least the given version (e.g., '7.1')"
  isAtLeast(version: String!): Boolean!
}

"""
Feature support information based on RouterOS version
"""
type FeatureSupport {
  "Feature identifier (e.g., 'rest_api', 'container', 'wireguard')"
  featureId: String!
  "Human-readable feature name"
  name: String!
  "Whether the feature is supported on this router"
  supported: Boolean!
  "Capability level (none, basic, advanced, full)"
  level: CapabilityLevel!
  "Reason why the feature is not supported (if applicable)"
  reason: String
  "Minimum RouterOS version required for this feature"
  requiredVersion: String
  "URL to MikroTik documentation for upgrade guidance"
  upgradeUrl: String
  "Required packages that need to be installed"
  requiredPackages: [String!]
  "Missing packages (if any)"
  missingPackages: [String!]
}

"""
Input for checking feature compatibility
"""
input FeatureCompatibilityInput {
  "Feature identifier to check"
  featureId: String!
  "Whether to check for CHR-specific requirements"
  isCHR: Boolean
}

"""
Upgrade recommendation for enabling a feature
"""
type UpgradeRecommendation {
  "Feature that requires upgrade"
  featureId: String!
  "Human-readable feature name"
  featureName: String!
  "Current RouterOS version"
  currentVersion: String!
  "Minimum required version for this feature"
  requiredVersion: String!
  "Whether this is a major version upgrade (e.g., 6.x to 7.x)"
  isMajorUpgrade: Boolean!
  "Priority level (critical, high, medium, low)"
  priority: UpgradePriority!
  "Steps to complete the upgrade"
  steps: [UpgradeStep!]!
  "Estimated impact on router operation"
  impact: UpgradeImpact!
  "URL to MikroTik upgrade documentation"
  documentationUrl: String
  "Warnings or important notes about this upgrade"
  warnings: [String!]!
}

"""
Priority level for upgrade recommendations
"""
enum UpgradePriority {
  "Security-related, should upgrade immediately"
  CRITICAL
  "Highly recommended for stability/features"
  HIGH
  "Recommended but not urgent"
  MEDIUM
  "Nice to have, optional"
  LOW
}

"""
Impact assessment for an upgrade
"""
type UpgradeImpact {
  "Whether reboot is required"
  requiresReboot: Boolean!
  "Estimated downtime description"
  estimatedDowntime: String
  "Whether configuration backup is recommended before upgrade"
  backupRecommended: Boolean!
  "Potential breaking changes to be aware of"
  breakingChanges: [String!]!
}

"""
Single step in an upgrade process
"""
type UpgradeStep {
  "Step number (1-based)"
  step: Int!
  "Step title"
  title: String!
  "Detailed instructions"
  description: String!
  "RouterOS command to execute (if applicable)"
  command: String
  "Whether this step is optional"
  optional: Boolean!
}

"""
Payload for refreshCapabilities mutation
"""
type RefreshCapabilitiesPayload {
  "Updated capabilities after refresh"
  capabilities: RouterCapabilities
  "Errors during refresh"
  errors: [MutationError!]
}

# -----------------------------------------------------------------------------
# Device Scan Types
# -----------------------------------------------------------------------------
# All device scan types are defined in scanner.graphql
`, BuiltIn: false},
	{Name: "../../../schema/auth.graphql", Input: `# =============================================================================
# Authentication Schema for NasNetConnect
# =============================================================================
# Defines authentication types, queries, and mutations.
# Implements JWT-based authentication with sliding sessions.
# =============================================================================

# -----------------------------------------------------------------------------
# Auth Types
# -----------------------------------------------------------------------------

"""
Authentication payload returned on successful login
"""
type AuthPayload {
  "JWT access token"
  token: String!
  "Authenticated user"
  user: User!
  "Token expiration timestamp"
  expiresAt: DateTime!
}

"""
User account in NasNetConnect
"""
type User implements Node {
  "User ULID"
  id: ID!
  "Unique username"
  username: String!
  "User role for authorization"
  role: UserRole!
  "Email address (if provided)"
  email: String
  "Display name"
  displayName: String
  "Account creation timestamp"
  createdAt: DateTime!
  "Last successful login"
  lastLoginAt: DateTime
}

"""
User roles for authorization
"""
enum UserRole {
  "Full administrative access"
  ADMIN
  "Can view and modify but not delete or manage users"
  OPERATOR
  "Read-only access"
  VIEWER
}

"""
Active user session
"""
type Session {
  "Session ULID"
  id: ID!
  "Client IP address"
  ipAddress: String
  "Client user agent"
  userAgent: String
  "Session creation time"
  createdAt: DateTime!
  "Last activity time"
  lastActivity: DateTime!
  "Whether this is the current session"
  isCurrent: Boolean!
}

# -----------------------------------------------------------------------------
# Auth Queries
# -----------------------------------------------------------------------------

extend type Query {
  "Get current authenticated user"
  me: User @auth

  "Get all active sessions for the current user"
  mySessions: [Session!]! @auth
}

# -----------------------------------------------------------------------------
# Auth Mutations
# -----------------------------------------------------------------------------

extend type Mutation {
  "Authenticate and receive a JWT token"
  login(
    "Username"
    username: String!
    "Password"
    password: String! @sensitive
  ): AuthPayload!

  "Invalidate current session and clear tokens"
  logout: Boolean! @auth

  "Change the current user's password"
  changePassword(
    "Current password for verification"
    currentPassword: String! @sensitive
    "New password (must meet policy requirements)"
    newPassword: String! @sensitive
  ): Boolean! @auth

  "Revoke all sessions for a user (admin only)"
  revokeAllSessions(
    "User ID to revoke sessions for"
    userId: ID!
  ): Boolean! @auth(requires: "admin")

  "Revoke a specific session"
  revokeSession(
    "Session ID to revoke"
    sessionId: ID!
  ): Boolean! @auth
}

# -----------------------------------------------------------------------------
# Auth Errors
# -----------------------------------------------------------------------------

"""
Authentication error codes
"""
enum AuthErrorCode {
  "Invalid username or password"
  INVALID_CREDENTIALS
  "Session has expired"
  SESSION_EXPIRED
  "Token is invalid or malformed"
  TOKEN_INVALID
  "Token has expired"
  TOKEN_EXPIRED
  "Insufficient permissions"
  INSUFFICIENT_ROLE
  "Too many login attempts"
  RATE_LIMITED
  "Password does not meet requirements"
  PASSWORD_POLICY_VIOLATION
}
`, BuiltIn: false},
	{Name: "../../../schema/connection.graphql", Input: `# =============================================================================
# Connection Management GraphQL Schema Extension
# =============================================================================
# This schema provides types and operations for managing persistent router
# connections with automatic reconnection, circuit breaker, and health monitoring.
# Story: NAS-3.5 - Implement Connection Management
# =============================================================================

# -----------------------------------------------------------------------------
# Connection Types
# -----------------------------------------------------------------------------

"""
Protocol used for router communication
"""
enum Protocol {
  "REST API protocol (RouterOS 7.1+)"
  REST
  "Binary API protocol (port 8728)"
  API
  "TLS-encrypted binary API (port 8729)"
  API_SSL
  "SSH protocol (port 22)"
  SSH
  "Telnet protocol (port 23)"
  TELNET
}

"""
Reason for router disconnection
"""
enum DisconnectReason {
  "Unknown reason"
  UNKNOWN
  "User manually disconnected"
  MANUAL
  "Network failure"
  NETWORK_FAILURE
  "Authentication failed"
  AUTH_FAILURE
  "Connection timed out"
  TIMEOUT
  "Circuit breaker is open"
  CIRCUIT_OPEN
  "Application shutting down"
  SHUTDOWN
}

"""
Circuit breaker state
"""
enum CircuitBreakerState {
  "Circuit is closed (normal operation)"
  CLOSED
  "Circuit is open (blocking requests)"
  OPEN
  "Circuit is half-open (testing recovery)"
  HALF_OPEN
}

"""
Detailed connection status for a router
"""
type ConnectionDetails {
  "Current connection state"
  state: ConnectionStatus!

  "Protocol currently in use"
  protocol: Protocol

  "User's preferred protocol (if set)"
  preferredProtocol: Protocol

  "When the connection was established"
  connectedAt: DateTime

  "Connection uptime duration"
  uptime: Duration

  "When the last disconnection occurred"
  disconnectedAt: DateTime

  "Most recent error message"
  lastError: String

  "When the last error occurred"
  lastErrorTime: DateTime

  "Reason for disconnection"
  disconnectReason: DisconnectReason

  "Number of reconnection attempts made"
  reconnectAttempts: Int!

  "When the next reconnection attempt will be made"
  nextReconnectAt: DateTime

  "Current circuit breaker state"
  circuitBreakerState: CircuitBreakerState!

  "Router version (if connected)"
  version: String

  "When the last health check was performed"
  lastHealthCheck: DateTime

  "Consecutive passed health checks"
  healthChecksPassed: Int!

  "Consecutive failed health checks"
  healthChecksFailed: Int!

  "Security warning if using insecure protocol (e.g., Telnet)"
  securityWarning: String

  "Recommendation for upgrading to a more secure protocol"
  upgradeRecommendation: String

  "Whether the current protocol is considered legacy/insecure"
  isLegacyProtocol: Boolean!
}

"""
Health check result for a router
"""
type HealthCheckResult {
  "Router ID"
  routerId: ID!

  "Whether the router is healthy"
  healthy: Boolean!

  "When the check was performed"
  checkedAt: DateTime!

  "Response time in milliseconds"
  responseTimeMs: Int

  "Error message if unhealthy"
  error: String
}

"""
Connection manager statistics
"""
type ConnectionStats {
  "Total number of connections"
  totalConnections: Int!

  "Number of connected routers"
  connected: Int!

  "Number of connecting routers"
  connecting: Int!

  "Number of disconnected routers"
  disconnected: Int!

  "Number of reconnecting routers"
  reconnecting: Int!

  "Number of routers in error state"
  error: Int!
}

# -----------------------------------------------------------------------------
# Query Extensions
# -----------------------------------------------------------------------------

extend type Query {
  "Get detailed connection status for a router"
  connectionDetails(routerId: ID!): ConnectionDetails

  "Get health check result for a router"
  routerHealth(routerId: ID!): HealthCheckResult

  "Get connection manager statistics"
  connectionStats: ConnectionStats!
}

# -----------------------------------------------------------------------------
# Mutation Extensions
# -----------------------------------------------------------------------------

extend type Mutation {
  "Set preferred protocol for a router"
  setPreferredProtocol(
    "Router ID"
    routerId: ID!
    "Preferred protocol"
    protocol: Protocol!
  ): SetPreferredProtocolPayload!

  "Manually trigger reconnection to a router"
  reconnectRouter(
    "Router ID"
    routerId: ID!
  ): ReconnectRouterPayload!

  "Perform immediate health check on a router"
  checkRouterHealth(
    "Router ID"
    routerId: ID!
  ): HealthCheckResult!
}

# -----------------------------------------------------------------------------
# Mutation Payloads
# -----------------------------------------------------------------------------

type SetPreferredProtocolPayload {
  "The updated router"
  router: Router
  "Updated connection details"
  connectionDetails: ConnectionDetails
  "Errors that occurred"
  errors: [MutationError!]
}

type ReconnectRouterPayload {
  "The router being reconnected"
  router: Router
  "Updated connection details"
  connectionDetails: ConnectionDetails
  "Whether reconnection was initiated"
  initiated: Boolean!
  "Rate limit wait time if rate limited"
  waitTimeMs: Int
  "Errors that occurred"
  errors: [MutationError!]
}

# -----------------------------------------------------------------------------
# Subscription Extensions
# -----------------------------------------------------------------------------

extend type Subscription {
  "Subscribe to connection health updates"
  connectionHealth(
    "Router ID to monitor (optional, all routers if not specified)"
    routerId: ID
  ): HealthCheckResult!

  "Subscribe to circuit breaker state changes"
  circuitBreakerChanged(
    "Router ID to monitor"
    routerId: ID!
  ): CircuitBreakerEvent!
}

"""
Event emitted when circuit breaker state changes
"""
type CircuitBreakerEvent {
  "Router ID"
  routerId: ID!
  "Previous state"
  previousState: CircuitBreakerState!
  "New state"
  newState: CircuitBreakerState!
  "Consecutive failures that triggered the change"
  consecutiveFailures: Int!
  "When the state changed"
  timestamp: DateTime!
}
`, BuiltIn: false},
	{Name: "../../../schema/credentials.graphql", Input: `# =============================================================================
# Credential Management GraphQL Schema
# =============================================================================
# This schema defines types and operations for managing router credentials.
#
# Security Notes:
# - Passwords are NEVER returned in any query or mutation response
# - All credential fields use AES-256-GCM encryption at rest
# - Credential changes are logged to the audit trail (without values)
# - The @sensitive directive marks fields that should be redacted in logs
# =============================================================================

# -----------------------------------------------------------------------------
# Credential Types
# -----------------------------------------------------------------------------

"""
Router credential information (non-sensitive).
Password is never included - only metadata about credentials.
"""
type RouterCredentials {
  "Router ID these credentials belong to"
  routerId: ID!
  "Username for router authentication"
  username: String!
  "Whether a password is stored"
  hasPassword: Boolean!
  "Encryption algorithm used (always 'AES-256-GCM')"
  encryptionStatus: String!
  "Encryption key version (for rotation tracking)"
  keyVersion: Int!
  "When credentials were last updated"
  lastUpdated: DateTime!
  "When credentials were first created"
  createdAt: DateTime!
}

"""
Input for updating router credentials.
Both username and password must be provided.
"""
input CredentialsInput {
  "Username for router authentication"
  username: String! @validate(minLength: 1, maxLength: 64) @sensitive
  "Password for router authentication"
  password: String! @validate(minLength: 1, maxLength: 128) @sensitive
}

"""
Result of updating router credentials.
"""
type CredentialUpdatePayload {
  "Whether the update was successful"
  success: Boolean!
  "Human-readable message about the operation"
  message: String!
  "Updated credential info (without password)"
  credentials: RouterCredentials
  "Error code if update failed"
  errorCode: CredentialErrorCode
  "Errors that occurred during update"
  errors: [MutationError!]
}

"""
Error codes specific to credential operations.
"""
enum CredentialErrorCode {
  "Authentication failed with new credentials"
  AUTH_FAILED
  "Connection timed out when testing credentials"
  TIMEOUT
  "Connection was refused"
  CONNECTION_REFUSED
  "Router not found"
  ROUTER_NOT_FOUND
  "Credentials not found for router"
  CREDENTIALS_NOT_FOUND
  "Encryption failed"
  ENCRYPTION_FAILED
  "Decryption failed (key may have rotated)"
  DECRYPTION_FAILED
  "Invalid input provided"
  INVALID_INPUT
}

# -----------------------------------------------------------------------------
# Bulk Testing Types
# -----------------------------------------------------------------------------

"""
Result of testing all router credentials.
"""
type TestAllCredentialsPayload {
  "Total number of routers tested"
  totalRouters: Int!
  "Number of successful credential tests"
  successCount: Int!
  "Number of failed credential tests"
  failureCount: Int!
  "Per-router test results"
  results: [CredentialTestResult!]!
}

"""
Result of testing a single router's credentials.
"""
type CredentialTestResult {
  "Router ID that was tested"
  routerId: ID!
  "Router name for display"
  routerName: String!
  "Whether the test was successful"
  success: Boolean!
  "Connection status"
  status: CredentialTestStatus!
  "Response time in milliseconds (if successful)"
  responseTimeMs: Int
  "Error message if test failed"
  error: String
}

"""
Status of a credential test.
"""
enum CredentialTestStatus {
  "Credentials are valid and connection succeeded"
  SUCCESS
  "Authentication failed"
  AUTH_FAILED
  "Connection timed out"
  TIMEOUT
  "Connection was refused"
  CONNECTION_REFUSED
  "Network unreachable"
  NETWORK_ERROR
  "No credentials stored for this router"
  NO_CREDENTIALS
  "Unknown error occurred"
  ERROR
}

# -----------------------------------------------------------------------------
# Export Security Types
# -----------------------------------------------------------------------------

"""
Options for exporting router configuration.
"""
input ExportConfigInput {
  "Router ID to export configuration from"
  routerId: ID!
  "Whether to include credentials (requires encryptionKey if true)"
  includeCredentials: Boolean
  "User-provided encryption key for credential export (required if includeCredentials is true)"
  encryptionKey: String @sensitive
}

"""
Result of exporting router configuration.
"""
type ExportConfigPayload {
  "Whether the export was successful"
  success: Boolean!
  "Exported configuration data (JSON format)"
  config: JSON
  "Security warning message about credential handling"
  securityWarning: String
  "Errors that occurred during export"
  errors: [MutationError!]
}

# -----------------------------------------------------------------------------
# Query Extensions
# -----------------------------------------------------------------------------

extend type Query {
  "Get credential information for a router (password is never returned)"
  routerCredentials(routerId: ID!): RouterCredentials @auth
}

# -----------------------------------------------------------------------------
# Mutation Extensions
# -----------------------------------------------------------------------------

extend type Mutation {
  """
  Update router credentials.
  Tests the new credentials before saving.
  Old credentials are preserved if the test fails.
  """
  updateRouterCredentials(
    routerId: ID!
    input: CredentialsInput!
  ): CredentialUpdatePayload! @auth

  """
  Test all router credentials in parallel.
  Returns aggregate results with per-router status.
  """
  testAllCredentials: TestAllCredentialsPayload! @auth

  """
  Export router configuration with optional credential handling.
  Credentials are excluded by default for security.
  If includeCredentials is true, an encryptionKey must be provided.
  """
  exportRouterConfig(input: ExportConfigInput!): ExportConfigPayload! @auth
}
`, BuiltIn: false},
	{Name: "../../../schema/scanner.graphql", Input: `# =============================================================================
# Network Scanner GraphQL Schema
# =============================================================================
# Types for router auto-discovery and network scanning functionality.
# Enables users to discover MikroTik routers on their network without knowing
# their IP addresses.
#
# Story: NAS-3.4 - Implement Router Auto Scanner
# =============================================================================

# -----------------------------------------------------------------------------
# Scan Status Enum
# -----------------------------------------------------------------------------

"""
Status of a network scan operation
"""
enum ScanStatus {
  "Scan is queued and waiting to start"
  PENDING
  "Scan is actively running"
  RUNNING
  "Scan completed successfully"
  COMPLETED
  "Scan was cancelled by user"
  CANCELLED
  "Scan failed with an error"
  FAILED
}

# -----------------------------------------------------------------------------
# Core Types
# -----------------------------------------------------------------------------

"""
Information about a discovered RouterOS device
"""
type RouterOSInfo {
  "RouterOS version string (e.g., '7.12', '6.49.8')"
  version: String
  "Router board name (e.g., 'hAP ac', 'CCR2004-1G-12S+2XS')"
  boardName: String
  "CPU architecture (e.g., 'arm', 'x86', 'mips')"
  architecture: String
  "Platform identifier"
  platform: String
}

"""
A device discovered during a network scan.
Only confirmed MikroTik devices are returned (confidence >= 40).
"""
type DiscoveredDevice {
  "IP address of the discovered device"
  ip: String!
  "Hostname (if reverse DNS resolves)"
  hostname: String
  "Open ports found on the device"
  ports: [Int!]!
  "Device type classification"
  deviceType: String!
  "Device vendor (always 'MikroTik' for returned results)"
  vendor: String
  "RouterOS-specific information (version, board, architecture)"
  routerOSInfo: RouterOSInfo
  "Confidence score for RouterOS detection (40-100)"
  confidence: Int!
  "Detected services (mikrotik-api, mikrotik-winbox, mikrotik-rest, etc.)"
  services: [String!]!
}

"""
A network scan task that tracks scan progress and results.
Scans are asynchronous - start with mutation, poll/subscribe for progress.
"""
type ScanTask {
  "Unique task identifier"
  id: ID!
  "Target subnet (CIDR notation, IP range, or gateway scan indicator)"
  subnet: String!
  "Current scan status"
  status: ScanStatus!
  "Scan progress percentage (0-100)"
  progress: Int!
  "Discovered devices (populated as scan progresses)"
  results: [DiscoveredDevice!]!
  "When the scan was started"
  startTime: DateTime!
  "When the scan completed (null if still running)"
  endTime: DateTime
  "Error message if scan failed"
  error: String
  "Total IPs to scan (for progress calculation)"
  totalIPs: Int
  "Number of IPs scanned so far"
  scannedIPs: Int
}

"""
Real-time progress event for scan subscriptions
"""
type ScanProgressEvent {
  "Task ID this event belongs to"
  taskId: ID!
  "Current progress percentage (0-100)"
  progress: Int!
  "Number of MikroTik devices found so far"
  devicesFound: Int!
  "IP address currently being scanned"
  currentIP: String
  "Current scan status"
  status: ScanStatus!
  "Timestamp of this progress update"
  timestamp: DateTime!
}

# -----------------------------------------------------------------------------
# Input Types
# -----------------------------------------------------------------------------

"""
Input for starting a network scan
"""
input ScanNetworkInput {
  "Target subnet in CIDR notation (e.g., '192.168.88.0/24') or IP range (e.g., '192.168.1.1-192.168.1.100')"
  subnet: String! @validate(minLength: 7, maxLength: 43)
}

# -----------------------------------------------------------------------------
# Mutation Payloads
# -----------------------------------------------------------------------------

type ScanNetworkPayload {
  "The created scan task"
  task: ScanTask
  "Errors that occurred"
  errors: [MutationError!]
}

type CancelScanPayload {
  "The cancelled scan task"
  task: ScanTask
  "Errors that occurred"
  errors: [MutationError!]
}

# -----------------------------------------------------------------------------
# Query Extensions
# -----------------------------------------------------------------------------

extend type Query {
  "Get the status of a scan task by ID"
  scanStatus(taskId: ID!): ScanTask

  "Get scan history (recent scans)"
  scanHistory(
    "Maximum number of results to return"
    limit: Int = 10
  ): [ScanTask!]!
}

# -----------------------------------------------------------------------------
# Mutation Extensions
# -----------------------------------------------------------------------------

extend type Mutation {
  """
  Start a network scan for MikroTik routers.
  Returns a task ID that can be used to track progress via subscription or polling.

  Supported subnet formats:
  - CIDR: "192.168.88.0/24" (scans 254 usable IPs)
  - Range: "192.168.1.1-192.168.1.100" (scans specified range)
  - Single IP: "192.168.88.1" (scans one IP)

  Performance: /24 scan completes in 1-2 seconds with 20 concurrent workers.
  """
  scanNetwork(input: ScanNetworkInput!): ScanNetworkPayload!

  """
  Start an automatic gateway scan.
  Scans common gateway IPs (192.168.0-255.1) to find MikroTik routers.
  This is useful when the user doesn't know which subnet to scan.

  Only returns verified MikroTik RouterOS devices (confidence >= 40).
  """
  autoScanGateways: ScanNetworkPayload!

  """
  Cancel a running scan.
  The scan will stop within 1 second and partial results are preserved.
  """
  cancelScan(taskId: ID!): CancelScanPayload!
}

# -----------------------------------------------------------------------------
# Subscription Extensions
# -----------------------------------------------------------------------------

extend type Subscription {
  """
  Subscribe to real-time scan progress updates.
  Emits events every 5% progress or every 2 seconds, whichever is sooner.
  """
  scanProgress(taskId: ID!): ScanProgressEvent!
}
`, BuiltIn: false},
	{Name: "../../../schema/resource-layers.graphql", Input: `# =============================================================================
# Universal State v2 - Resource Layers Schema
# =============================================================================
# This schema defines the layer-specific types for the 8-layer Resource Model.
#
# Reference: ADR-012 - Universal State v2
# Reference: Docs/architecture/data-architecture.md
# =============================================================================

# -----------------------------------------------------------------------------
# Layer 2: Validation Result
# -----------------------------------------------------------------------------

"""
Layer 2: Validation result from 7-stage backend validation pipeline.
Computed on every configuration change.
"""
type ValidationResult {
  "Whether the resource can be applied"
  canApply: Boolean!

  "Current validation stage"
  stage: ValidationStage!

  "Validation errors (blocking)"
  errors: [ValidationIssue!]!

  "Validation warnings (non-blocking)"
  warnings: [ValidationIssue!]!

  "Resource conflicts detected"
  conflicts: [ResourceConflict!]!

  "Required dependencies that must be active"
  requiredDependencies: [DependencyStatus!]!

  "When validation was performed"
  validatedAt: DateTime!

  "Duration of validation in milliseconds"
  validationDurationMs: Int!
}

"""
Validation pipeline stages
"""
enum ValidationStage {
  "Schema validation (Zod/GraphQL)"
  SCHEMA

  "Semantic validation (business rules)"
  SEMANTIC

  "Dependency validation (required resources exist)"
  DEPENDENCY

  "Conflict detection (port/IP/route conflicts)"
  CONFLICT

  "Platform validation (capability checks)"
  PLATFORM

  "Quota validation (resource limits)"
  QUOTA

  "Pre-flight simulation"
  SIMULATION

  "All stages complete"
  COMPLETE
}

"""
A validation issue (error or warning)
"""
type ValidationIssue {
  "Error code for programmatic handling"
  code: String!

  "Human-readable message"
  message: String!

  "Field path that caused the issue (e.g., 'configuration.listenPort')"
  field: String

  "Severity level"
  severity: ValidationSeverity!

  "Suggested fix"
  suggestedFix: String

  "Link to documentation"
  docsUrl: String
}

"""
Validation issue severity
"""
enum ValidationSeverity {
  "Blocks apply, must be fixed"
  ERROR

  "Does not block, but recommended to address"
  WARNING

  "Informational notice"
  INFO
}

"""
Conflict with another resource
"""
type ResourceConflict {
  "Type of conflict"
  type: ConflictType!

  "The conflicting resource"
  conflictingResource: Resource

  "Conflicting resource UUID (if resource is not loaded)"
  conflictingResourceUuid: ID!

  "Description of the conflict"
  description: String!

  "Suggested resolution"
  resolution: String
}

"""
Types of resource conflicts
"""
enum ConflictType {
  "Port number conflict"
  PORT

  "IP address conflict"
  IP_ADDRESS

  "Route overlap"
  ROUTE

  "Interface conflict"
  INTERFACE

  "Name collision"
  NAME

  "Configuration incompatibility"
  CONFIGURATION
}

"""
Status of a required dependency
"""
type DependencyStatus {
  "Dependency resource UUID"
  resourceUuid: ID!

  "Dependency resource type"
  resourceType: String!

  "Whether the dependency is active"
  isActive: Boolean!

  "Current state of the dependency"
  state: ResourceLifecycleState!

  "Why this dependency is required"
  reason: String!
}

# -----------------------------------------------------------------------------
# Layer 3: Deployment State
# -----------------------------------------------------------------------------

"""
Layer 3: What's actually on router after Apply-Confirm.
Includes router-generated fields like IDs and computed values.
"""
type DeploymentState {
  "Router-generated resource ID (e.g., '*1A' in MikroTik)"
  routerResourceId: String

  "When the resource was applied"
  appliedAt: DateTime!

  "User who applied the resource"
  appliedBy: String

  "Version number on router"
  routerVersion: Int

  "Router-generated fields (public key, computed values, etc.)"
  generatedFields: JSON

  "Whether deployment matches configuration (no drift)"
  isInSync: Boolean!

  "Detected drift from configuration"
  drift: DriftInfo

  "Apply operation ID for audit trail"
  applyOperationId: ID
}

"""
Information about configuration drift
"""
type DriftInfo {
  "When drift was detected"
  detectedAt: DateTime!

  "Fields that have drifted"
  driftedFields: [DriftField!]!

  "Suggested action to resolve drift"
  suggestedAction: DriftAction!
}

"""
A field that has drifted from configuration
"""
type DriftField {
  "Field path"
  path: String!

  "Expected value (from configuration)"
  expected: JSON

  "Actual value (from router)"
  actual: JSON
}

"""
Actions to resolve drift
"""
enum DriftAction {
  "Re-apply configuration to router"
  REAPPLY

  "Update configuration to match router"
  ACCEPT

  "Manual review required"
  REVIEW
}

# -----------------------------------------------------------------------------
# Layer 4: Runtime State
# -----------------------------------------------------------------------------

"""
Layer 4: Live operational state polled/streamed from router.
Updated via polling (5-60s interval) or WebSocket push.
"""
type RuntimeState {
  "Whether the resource is currently running/active"
  isRunning: Boolean!

  "Health status of the resource"
  health: RuntimeHealth!

  "Error message if resource is unhealthy"
  errorMessage: String

  "Resource-specific runtime metrics"
  metrics: RuntimeMetrics

  "Last time runtime was updated"
  lastUpdated: DateTime!

  "Time since last successful operation"
  lastSuccessfulOperation: DateTime

  "Current peers/connections (for VPN, etc.)"
  activeConnections: Int

  "Resource uptime"
  uptime: Duration
}

"""
Runtime health status
"""
enum RuntimeHealth {
  "Resource is healthy and operating normally"
  HEALTHY

  "Resource is running but with warnings"
  WARNING

  "Resource is running but degraded"
  DEGRADED

  "Resource has failed"
  FAILED

  "Health status unknown"
  UNKNOWN
}

"""
Resource-specific runtime metrics
"""
type RuntimeMetrics {
  "Bytes received"
  bytesIn: Size

  "Bytes transmitted"
  bytesOut: Size

  "Packets received"
  packetsIn: Int

  "Packets transmitted"
  packetsOut: Int

  "Error count"
  errors: Int

  "Drops count"
  drops: Int

  "Current throughput in (bytes/sec)"
  throughputIn: Size

  "Current throughput out (bytes/sec)"
  throughputOut: Size

  "Resource-specific custom metrics"
  custom: JSON
}

# -----------------------------------------------------------------------------
# Layer 5: Telemetry Data
# -----------------------------------------------------------------------------

"""
Layer 5: Time-series metrics and historical data.
Collected over time for analytics and trending.
"""
type TelemetryData {
  "Bandwidth history (last 24h)"
  bandwidthHistory: [BandwidthDataPoint!]

  "Uptime history (availability)"
  uptimeHistory: [UptimeDataPoint!]

  "Hourly statistics"
  hourlyStats: [HourlyStats!]

  "Daily statistics"
  dailyStats: [DailyStats!]

  "First data point timestamp"
  dataStartedAt: DateTime

  "Last data point timestamp"
  lastUpdatedAt: DateTime

  "Data retention period"
  retentionDays: Int!
}

"""
A bandwidth data point
"""
type BandwidthDataPoint {
  "Timestamp"
  timestamp: DateTime!

  "Bytes in during this period"
  bytesIn: Size!

  "Bytes out during this period"
  bytesOut: Size!

  "Period duration in seconds"
  periodSeconds: Int!
}

"""
An uptime data point
"""
type UptimeDataPoint {
  "Timestamp"
  timestamp: DateTime!

  "Whether resource was up during this period"
  isUp: Boolean!

  "Period duration in seconds"
  periodSeconds: Int!
}

"""
Hourly statistics
"""
type HourlyStats {
  "Hour start timestamp"
  hour: DateTime!

  "Total bytes in"
  totalBytesIn: Size!

  "Total bytes out"
  totalBytesOut: Size!

  "Uptime percentage (0-100)"
  uptimePercent: Float!

  "Error count"
  errorCount: Int!
}

"""
Daily statistics
"""
type DailyStats {
  "Date (UTC)"
  date: DateTime!

  "Total bytes in"
  totalBytesIn: Size!

  "Total bytes out"
  totalBytesOut: Size!

  "Uptime percentage (0-100)"
  uptimePercent: Float!

  "Error count"
  errorCount: Int!

  "Peak throughput in (bytes/sec)"
  peakThroughputIn: Size!

  "Peak throughput out (bytes/sec)"
  peakThroughputOut: Size!
}

# -----------------------------------------------------------------------------
# Layer 6: Resource Metadata
# -----------------------------------------------------------------------------

"""
Layer 6: Resource lifecycle info, tags, ownership.
System-managed with some user-editable fields.
"""
type ResourceMetadata {
  "Resource creation timestamp"
  createdAt: DateTime!

  "User who created the resource"
  createdBy: String!

  "Last update timestamp"
  updatedAt: DateTime!

  "User who last updated the resource"
  updatedBy: String

  "Current lifecycle state"
  state: ResourceLifecycleState!

  "Optimistic locking version"
  version: Int!

  "User-defined tags for organization"
  tags: [String!]!

  "Resource description"
  description: String

  "Whether resource is marked as favorite"
  isFavorite: Boolean!

  "Whether resource is pinned"
  isPinned: Boolean!

  "Custom user notes"
  notes: String

  "Audit trail of recent changes"
  recentChanges: [ChangeLogEntry!]
}

"""
An entry in the change log
"""
type ChangeLogEntry {
  "Change timestamp"
  timestamp: DateTime!

  "User who made the change"
  user: String!

  "Type of change"
  changeType: ChangeType!

  "Changed fields"
  changedFields: [String!]!

  "Brief description of the change"
  summary: String
}

# -----------------------------------------------------------------------------
# Layer 7: Resource Relationships
# -----------------------------------------------------------------------------

"""
Layer 7: Dependencies and relationships between resources.
Combines user-defined relationships and system-discovered dependencies.
"""
type ResourceRelationships {
  "Resources this resource depends on"
  dependsOn: [ResourceReference!]!

  "Resources that depend on this resource"
  dependents: [ResourceReference!]!

  "Resource this routes traffic via"
  routesVia: ResourceReference

  "Resources that route traffic via this resource"
  routedBy: [ResourceReference!]!

  "Parent resource (for hierarchical resources)"
  parent: ResourceReference

  "Child resources (for hierarchical resources)"
  children: [ResourceReference!]!

  "Custom relationships"
  custom: JSON
}

"""
Reference to another resource
"""
type ResourceReference {
  "Resource UUID"
  uuid: ID!

  "Resource scoped ID"
  id: String!

  "Resource type"
  type: String!

  "Resource category"
  category: ResourceCategory!

  "Current lifecycle state"
  state: ResourceLifecycleState!
}

# -----------------------------------------------------------------------------
# Layer 8: Platform Info
# -----------------------------------------------------------------------------

"""
Layer 8: Platform-specific capabilities and field mappings.
From platform adapter (MikroTik, OpenWrt, VyOS).
"""
type PlatformInfo {
  "Current platform"
  current: RouterPlatform!

  "Platform-specific capabilities for this resource type"
  capabilities: PlatformCapabilities!

  "Field mappings between GraphQL and platform-native names"
  fieldMappings: JSON

  "Platform-specific limitations or constraints"
  limitations: [PlatformLimitation!]

  "Platform-specific features available"
  features: [PlatformFeature!]
}

"""
Platform capabilities for a resource type
"""
type PlatformCapabilities {
  "Whether this resource type is supported"
  isSupported: Boolean!

  "Capability level"
  level: CapabilityLevel!

  "Minimum platform version required"
  minVersion: String

  "Required packages"
  requiredPackages: [String!]

  "Capability-specific details"
  details: JSON
}

"""
A platform-specific limitation
"""
type PlatformLimitation {
  "Limitation identifier"
  code: String!

  "Human-readable description"
  description: String!

  "Affected fields"
  affectedFields: [String!]

  "Workaround if available"
  workaround: String
}

"""
A platform-specific feature
"""
type PlatformFeature {
  "Feature identifier"
  id: String!

  "Feature name"
  name: String!

  "Whether feature is enabled"
  enabled: Boolean!

  "Feature description"
  description: String
}
`, BuiltIn: false},
	{Name: "../../../schema/change-set.graphql", Input: `# =============================================================================
# Change Set Schema - Atomic Multi-Resource Operations
# =============================================================================
# This schema defines types and operations for atomic multi-resource changes.
# Change sets group related configuration changes and apply them atomically,
# with automatic rollback on failure.
#
# Reference: NAS-4.14 - Implement Change Sets (Atomic Multi-Resource Operations)
# Reference: ADR-012 - Universal State v2
# Reference: FR-STM-013 - Atomic multi-resource operations
# =============================================================================

# -----------------------------------------------------------------------------
# Change Set Status Enum
# -----------------------------------------------------------------------------

"""
Change set lifecycle status
"""
enum ChangeSetStatus {
  "Initial state - adding items, not yet validated"
  DRAFT

  "Running validation on all items"
  VALIDATING

  "All items validated, ready to apply"
  READY

  "Applying resources in dependency order"
  APPLYING

  "All resources applied successfully"
  COMPLETED

  "Apply failed, may have partial application"
  FAILED

  "Rolling back applied changes"
  ROLLING_BACK

  "Rollback completed successfully"
  ROLLED_BACK

  "Rollback partially failed - manual intervention needed"
  PARTIAL_FAILURE

  "User cancelled the operation"
  CANCELLED
}

# -----------------------------------------------------------------------------
# Change Operation Enum
# -----------------------------------------------------------------------------

"""
Type of operation to perform on a resource
"""
enum ChangeOperation {
  "Create a new resource"
  CREATE

  "Update an existing resource"
  UPDATE

  "Delete an existing resource"
  DELETE
}

# -----------------------------------------------------------------------------
# Change Set Item Status Enum
# -----------------------------------------------------------------------------

"""
Status of individual items within a change set
"""
enum ChangeSetItemStatus {
  "Waiting to be applied"
  PENDING

  "Currently being applied"
  APPLYING

  "Successfully applied"
  APPLIED

  "Application failed"
  FAILED

  "Successfully rolled back"
  ROLLED_BACK

  "Rollback failed - manual intervention needed"
  ROLLBACK_FAILED

  "Skipped due to dependency failure"
  SKIPPED
}

# -----------------------------------------------------------------------------
# Change Set Types
# -----------------------------------------------------------------------------

"""
Individual item within a change set
"""
type ChangeSetItem {
  "Unique identifier for this item"
  id: ID!

  "Resource type identifier"
  resourceType: String!

  "Resource category"
  resourceCategory: ResourceCategory!

  "Existing resource UUID (null for create operations)"
  resourceUuid: ID

  "User-friendly name"
  name: String!

  "Optional description"
  description: String

  "Operation to perform"
  operation: ChangeOperation!

  "New/updated configuration"
  configuration: JSON!

  "Previous state (for rollback)"
  previousState: JSON

  "Item IDs this depends on"
  dependencies: [ID!]!

  "Current status"
  status: ChangeSetItemStatus!

  "Error message if failed"
  error: String

  "Apply started timestamp"
  applyStartedAt: DateTime

  "Apply completed timestamp"
  applyCompletedAt: DateTime

  "Order in which this item will be applied"
  applyOrder: Int!
}

"""
Validation error for a change set item
"""
type ChangeSetValidationError {
  "Item ID with validation error"
  itemId: ID!

  "Field path within the item configuration"
  field: String!

  "Error message"
  message: String!

  "Severity level"
  severity: ValidationSeverity!

  "Error code"
  code: String
}

"""
Conflict between change set items
"""
type ChangeSetConflict {
  "First conflicting item ID"
  itemId1: ID!

  "Second conflicting item ID or resource UUID"
  itemId2OrResourceUuid: ID!

  "Whether conflict is with existing resource"
  isExternalConflict: Boolean!

  "Description of the conflict"
  description: String!

  "Suggested resolution"
  resolution: String
}

"""
Validation result for a change set
"""
type ChangeSetValidationResult {
  "Whether the change set can be applied"
  canApply: Boolean!

  "Validation errors (blocking)"
  errors: [ChangeSetValidationError!]!

  "Validation warnings (non-blocking)"
  warnings: [ChangeSetValidationError!]!

  "Detected conflicts"
  conflicts: [ChangeSetConflict!]!

  "Missing dependencies"
  missingDependencies: [MissingDependency!]!

  "Circular dependencies (if any)"
  circularDependencies: [[ID!]!]
}

"""
Missing dependency information
"""
type MissingDependency {
  "Item ID with missing dependency"
  itemId: ID!

  "Missing resource type"
  missingResourceType: String!

  "Missing resource ID"
  missingResourceId: ID!
}

"""
Detailed error for failed change sets
"""
type ChangeSetError {
  "Error message"
  message: String!

  "Item ID that caused the failure"
  failedItemId: ID!

  "Error code"
  code: String

  "Items applied before failure"
  partiallyAppliedItemIds: [ID!]!

  "Items that failed rollback"
  failedRollbackItemIds: [ID!]!

  "Whether manual intervention is required"
  requiresManualIntervention: Boolean!
}

"""
Rollback step for recovery
"""
type RollbackStep {
  "Item ID being rolled back"
  itemId: ID!

  "Rollback operation"
  operation: RollbackOperation!

  "State to restore"
  restoreState: JSON

  "Resource UUID on router"
  resourceUuid: ID

  "Whether rollback succeeded"
  success: Boolean!

  "Error message if failed"
  error: String

  "Order in rollback sequence"
  rollbackOrder: Int!
}

"""
Rollback operation type
"""
enum RollbackOperation {
  "Delete a created resource"
  DELETE

  "Restore a deleted resource"
  RESTORE

  "Revert an updated resource"
  REVERT
}

"""
A change set representing an atomic multi-resource operation
"""
type ChangeSet {
  "Unique identifier (ULID)"
  id: ID!

  "Human-readable name"
  name: String!

  "Optional description"
  description: String

  "Router ID this change set applies to"
  routerId: ID!

  "Items in this change set"
  items: [ChangeSetItem!]!

  "Current status"
  status: ChangeSetStatus!

  "Validation result"
  validation: ChangeSetValidationResult

  "Rollback plan"
  rollbackPlan: [RollbackStep!]!

  "Error information (if failed)"
  error: ChangeSetError

  "Created timestamp"
  createdAt: DateTime!

  "Apply started timestamp"
  applyStartedAt: DateTime

  "Completed timestamp"
  completedAt: DateTime

  "User who created the change set"
  createdBy: String

  "Source wizard/feature"
  source: String

  "Version for optimistic concurrency"
  version: Int!
}

"""
Summary of a change set for list displays
"""
type ChangeSetSummary {
  "Change set ID"
  id: ID!

  "Name"
  name: String!

  "Current status"
  status: ChangeSetStatus!

  "Operation counts"
  operationCounts: OperationCounts!

  "Total items"
  totalItems: Int!

  "Created timestamp"
  createdAt: DateTime!

  "Has validation errors"
  hasErrors: Boolean!

  "Has validation warnings"
  hasWarnings: Boolean!
}

"""
Operation counts by type
"""
type OperationCounts {
  create: Int!
  update: Int!
  delete: Int!
}

# -----------------------------------------------------------------------------
# Progress Event for Subscriptions
# -----------------------------------------------------------------------------

"""
Progress event for real-time updates during apply
"""
type ChangeSetProgressEvent {
  "Change set ID"
  changeSetId: ID!

  "Current status"
  status: ChangeSetStatus!

  "Currently processing item"
  currentItem: CurrentItemInfo

  "Number of items applied"
  appliedCount: Int!

  "Total number of items"
  totalCount: Int!

  "Progress percentage (0-100)"
  progressPercent: Float!

  "Estimated time remaining in milliseconds"
  estimatedRemainingMs: Int

  "Error if failed"
  error: ChangeSetError

  "Timestamp of this event"
  timestamp: DateTime!
}

"""
Current item information in progress event
"""
type CurrentItemInfo {
  id: ID!
  name: String!
  operation: ChangeOperation!
  status: ChangeSetItemStatus!
}

# -----------------------------------------------------------------------------
# Queries
# -----------------------------------------------------------------------------

extend type Query {
  """
  Get a change set by ID
  """
  changeSet(
    "Change set ID"
    id: ID!
    "Router the change set belongs to"
    routerId: ID!
  ): ChangeSet

  """
  List change sets for a router
  """
  changeSets(
    "Router to query"
    routerId: ID!
    "Filter by status"
    status: ChangeSetStatus
    "Include completed/failed (default: false)"
    includeCompleted: Boolean = false
  ): [ChangeSetSummary!]!
}

# -----------------------------------------------------------------------------
# Mutations
# -----------------------------------------------------------------------------

extend type Mutation {
  """
  Create a new change set
  """
  createChangeSet(input: CreateChangeSetInput!): CreateChangeSetPayload!

  """
  Add an item to a change set
  """
  addChangeSetItem(
    changeSetId: ID!
    input: ChangeSetItemInput!
  ): AddChangeSetItemPayload!

  """
  Update an item in a change set
  """
  updateChangeSetItem(
    changeSetId: ID!
    itemId: ID!
    input: UpdateChangeSetItemInput!
  ): UpdateChangeSetItemPayload!

  """
  Remove an item from a change set
  """
  removeChangeSetItem(
    changeSetId: ID!
    itemId: ID!
  ): RemoveChangeSetItemPayload!

  """
  Validate a change set (all items)
  """
  validateChangeSet(changeSetId: ID!): ValidateChangeSetPayload!

  """
  Apply a change set atomically to the router
  """
  applyChangeSet(changeSetId: ID!): ApplyChangeSetPayload!

  """
  Cancel an in-progress change set application
  """
  cancelChangeSet(changeSetId: ID!): CancelChangeSetPayload!

  """
  Force rollback of a failed change set
  """
  rollbackChangeSet(changeSetId: ID!): RollbackChangeSetPayload!

  """
  Delete a change set (only if not applying)
  """
  deleteChangeSet(changeSetId: ID!): DeleteChangeSetPayload!
}

# -----------------------------------------------------------------------------
# Mutation Inputs
# -----------------------------------------------------------------------------

"""
Input for creating a new change set
"""
input CreateChangeSetInput {
  "Router to apply changes to"
  routerId: ID!

  "Human-readable name"
  name: String!

  "Optional description"
  description: String

  "Source wizard/feature"
  source: String
}

"""
Input for adding an item to a change set
"""
input ChangeSetItemInput {
  "Resource type identifier"
  resourceType: String!

  "Resource category"
  resourceCategory: ResourceCategory!

  "Existing resource UUID (for update/delete)"
  resourceUuid: ID

  "User-friendly name"
  name: String!

  "Optional description"
  description: String

  "Operation to perform"
  operation: ChangeOperation!

  "Configuration"
  configuration: JSON!

  "Previous state (for rollback on update/delete)"
  previousState: JSON

  "Item IDs this depends on"
  dependencies: [ID!]
}

"""
Input for updating an item in a change set
"""
input UpdateChangeSetItemInput {
  "Updated name"
  name: String

  "Updated description"
  description: String

  "Updated configuration"
  configuration: JSON

  "Updated dependencies"
  dependencies: [ID!]
}

# -----------------------------------------------------------------------------
# Mutation Payloads
# -----------------------------------------------------------------------------

type CreateChangeSetPayload {
  "The created change set"
  changeSet: ChangeSet
  "Errors that occurred"
  errors: [MutationError!]
}

type AddChangeSetItemPayload {
  "The updated change set"
  changeSet: ChangeSet
  "The added item ID"
  itemId: ID
  "Errors that occurred"
  errors: [MutationError!]
}

type UpdateChangeSetItemPayload {
  "The updated change set"
  changeSet: ChangeSet
  "Errors that occurred"
  errors: [MutationError!]
}

type RemoveChangeSetItemPayload {
  "The updated change set"
  changeSet: ChangeSet
  "Errors that occurred"
  errors: [MutationError!]
}

type ValidateChangeSetPayload {
  "The validated change set"
  changeSet: ChangeSet
  "Validation result"
  validation: ChangeSetValidationResult
  "Errors that occurred"
  errors: [MutationError!]
}

type ApplyChangeSetPayload {
  "Change set ID"
  changeSetId: ID!
  "Current status"
  status: ChangeSetStatus!
  "Errors that occurred"
  errors: [MutationError!]
}

type CancelChangeSetPayload {
  "The cancelled change set"
  changeSet: ChangeSet
  "Whether cancel was successful"
  success: Boolean!
  "Errors that occurred"
  errors: [MutationError!]
}

type RollbackChangeSetPayload {
  "The rolled back change set"
  changeSet: ChangeSet
  "Whether rollback was successful"
  success: Boolean!
  "Items that failed to rollback"
  failedItems: [ID!]
  "Errors that occurred"
  errors: [MutationError!]
}

type DeleteChangeSetPayload {
  "Whether deletion was successful"
  success: Boolean!
  "Errors that occurred"
  errors: [MutationError!]
}

# -----------------------------------------------------------------------------
# Subscriptions
# -----------------------------------------------------------------------------

extend type Subscription {
  """
  Subscribe to change set application progress
  """
  changeSetProgress(
    "Change set ID"
    changeSetId: ID!
  ): ChangeSetProgressEvent!

  """
  Subscribe to change set status changes
  """
  changeSetStatusChanged(
    "Router to subscribe to"
    routerId: ID!
  ): ChangeSetStatusEvent!
}

"""
Change set status change event
"""
type ChangeSetStatusEvent {
  "Change set ID"
  changeSetId: ID!

  "Previous status"
  previousStatus: ChangeSetStatus!

  "New status"
  newStatus: ChangeSetStatus!

  "Error if failed"
  error: ChangeSetError

  "Timestamp"
  timestamp: DateTime!
}
`, BuiltIn: false},
	{Name: "../../../schema/diagnostics.graphql", Input: `# =============================================================================
# Connection Diagnostics GraphQL Schema Extension
# =============================================================================
# This schema provides types and operations for diagnosing router connection
# issues, providing actionable troubleshooting suggestions, and exposing
# circuit breaker state.
# Story: NAS-3.10 - Implement Connection Diagnostics
# =============================================================================

# -----------------------------------------------------------------------------
# Diagnostic Types
# -----------------------------------------------------------------------------

"""
Severity level for diagnostic suggestions
"""
enum SuggestionSeverity {
  "Informational message, no action required"
  INFO
  "Warning that may affect functionality"
  WARNING
  "Error that needs to be addressed"
  ERROR
  "Critical issue blocking connectivity"
  CRITICAL
}

"""
Category of connection error for classification
"""
enum ErrorCategory {
  "Connection or response timeout"
  TIMEOUT
  "Connection actively refused"
  REFUSED
  "Authentication failed"
  AUTH_FAILED
  "Protocol-level error"
  PROTOCOL_ERROR
  "Network unreachable or DNS failure"
  NETWORK_ERROR
  "TLS/SSL certificate or handshake error"
  TLS_ERROR
}

"""
Status of a single port check
"""
type PortStatus {
  "Port number checked"
  port: Int!
  "Service name (API, API-SSL, SSH, Telnet, HTTP, HTTPS)"
  service: String!
  "Whether the port is open and accepting connections"
  open: Boolean!
  "Response time in milliseconds (if port is open)"
  responseTimeMs: Int
  "Error message (if port is closed)"
  error: String
}

"""
TLS certificate status for secure connections
"""
type TLSStatus {
  "Whether the certificate is valid"
  valid: Boolean!
  "Certificate issuer"
  issuer: String
  "Certificate subject"
  subject: String
  "Certificate expiration date"
  expiresAt: DateTime
  "Error message (if certificate is invalid)"
  error: String
}

"""
Authentication test status
"""
type AuthStatus {
  "Whether authentication was tested"
  tested: Boolean!
  "Whether authentication succeeded"
  success: Boolean!
  "Error message (if authentication failed)"
  error: String
  "Error code mapped to ErrorCodes (A5xx)"
  errorCode: String
}

"""
Actionable diagnostic suggestion
"""
type DiagnosticSuggestion {
  "Severity level of the issue"
  severity: SuggestionSeverity!
  "Short title describing the issue"
  title: String!
  "Detailed description of the issue"
  description: String!
  "Recommended action to resolve the issue"
  action: String!
  "Link to relevant documentation"
  docsUrl: String
}

"""
Comprehensive diagnostic report for a router
"""
type DiagnosticReport {
  "Router ID being diagnosed"
  routerId: ID!
  "When the diagnostic was run"
  timestamp: DateTime!
  "Whether the router is reachable on the network"
  networkReachable: Boolean!
  "Status of each checked port"
  portStatus: [PortStatus!]!
  "TLS certificate status (if TLS ports were checked)"
  tlsStatus: TLSStatus
  "Authentication test status"
  authStatus: AuthStatus!
  "Actionable suggestions based on diagnostic results"
  suggestions: [DiagnosticSuggestion!]!
  "Raw text report for clipboard/export"
  rawReport: String!
}

"""
Record of a single protocol connection attempt
"""
type ConnectionAttempt {
  "Protocol that was attempted"
  protocol: Protocol!
  "When the attempt started"
  startedAt: DateTime!
  "When the attempt ended"
  endedAt: DateTime!
  "Whether the attempt succeeded"
  success: Boolean!
  "Error code if failed"
  errorCode: String
  "Error message if failed"
  errorMessage: String
  "Error category for classification"
  errorCategory: ErrorCategory
}

"""
Circuit breaker status for a router
"""
type CircuitBreakerStatus {
  "Router ID"
  routerId: ID!
  "Current circuit breaker state"
  state: CircuitBreakerState!
  "Number of consecutive failures"
  failureCount: Int!
  "Failure threshold before circuit opens"
  failureThreshold: Int!
  "Seconds until auto-retry (when circuit is open)"
  cooldownRemainingSeconds: Int
  "When the last failure occurred"
  lastFailureAt: DateTime
  "When the last success occurred"
  lastSuccessAt: DateTime
}

# -----------------------------------------------------------------------------
# Query Extensions
# -----------------------------------------------------------------------------

extend type Query {
  """
  Get recent connection attempts for a router.
  Returns the most recent attempts, ordered newest first.
  """
  connectionAttempts(
    "Router ID to get attempts for"
    routerId: ID!
    "Maximum number of attempts to return (default: 10)"
    limit: Int = 10
  ): [ConnectionAttempt!]!

  """
  Get circuit breaker status for a router.
  Shows current state, failure counts, and cooldown timing.
  """
  circuitBreakerStatus(routerId: ID!): CircuitBreakerStatus!
}

# -----------------------------------------------------------------------------
# Mutation Extensions
# -----------------------------------------------------------------------------

extend type Mutation {
  """
  Run comprehensive diagnostics on a router connection.
  Performs network reachability check, port scanning, TLS validation,
  and authentication testing. Rate limited to 1 request per 10 seconds per router.
  """
  runDiagnostics(routerId: ID!): DiagnosticReport!

  """
  Manually reset the circuit breaker for a router.
  This allows immediate reconnection attempts even if the circuit is open.
  Use with caution as it bypasses the backoff protection.
  """
  resetCircuitBreaker(routerId: ID!): CircuitBreakerStatus!
}

# -----------------------------------------------------------------------------
# Subscription Extensions
# -----------------------------------------------------------------------------

extend type Subscription {
  """
  Subscribe to circuit breaker state changes for a router.
  Emits an event whenever the circuit breaker transitions between states.
  """
  circuitBreakerStateChanged(
    "Router ID to monitor (optional, all routers if not specified)"
    routerId: ID
  ): CircuitBreakerStatus!
}

# =============================================================================
# Internet Troubleshooting (No Internet Wizard)
# =============================================================================
# This schema provides types and operations for diagnosing internet connectivity
# issues on routers, running automated diagnostics, and applying fixes.
# Story: NAS-5.11 - Implement No Internet Troubleshooting Wizard
# =============================================================================

# -----------------------------------------------------------------------------
# Internet Troubleshooting Types
# -----------------------------------------------------------------------------

"""
Diagnostic step identifier for internet troubleshooting
"""
enum TroubleshootStepType {
  "Check WAN interface status"
  WAN
  "Ping default gateway"
  GATEWAY
  "Ping external internet server"
  INTERNET
  "Test DNS resolution"
  DNS
  "Verify NAT/masquerade rules"
  NAT
}

"""
Status of a diagnostic step
"""
enum TroubleshootStepStatus {
  "Step not yet started"
  PENDING
  "Step currently executing"
  RUNNING
  "Step completed successfully"
  PASSED
  "Step failed"
  FAILED
  "Step skipped"
  SKIPPED
}

"""
Confidence level for a fix suggestion
"""
enum FixConfidence {
  "High confidence this fix will resolve the issue"
  HIGH
  "Medium confidence, may resolve the issue"
  MEDIUM
  "Low confidence, worth trying as last resort"
  LOW
}

"""
Status of a fix application
"""
enum FixApplicationStatus {
  "Fix is available but not yet applied"
  AVAILABLE
  "Fix is being applied"
  APPLYING
  "Fix was applied successfully"
  APPLIED
  "Fix application failed"
  FAILED
  "Fix was applied but issue persists"
  ISSUE_PERSISTS
}

"""
Result of a single diagnostic step
"""
type TroubleshootStepResult {
  "Whether the check passed"
  success: Boolean!
  "User-friendly message about the result"
  message: String!
  "Technical details for debugging"
  details: String
  "Execution time in milliseconds"
  executionTimeMs: Int!
  "Detected error code"
  issueCode: String
  "Target that was checked (IP, interface name, etc.)"
  target: String
}

"""
Suggested fix for a failed diagnostic step
"""
type TroubleshootFixSuggestion {
  "Unique issue code (e.g., WAN_DISABLED, NO_DEFAULT_ROUTE)"
  issueCode: String!
  "User-friendly fix title"
  title: String!
  "Detailed explanation of what will be fixed"
  explanation: String!
  "Confidence level for this fix"
  confidence: FixConfidence!
  "Whether user confirmation is required before applying"
  requiresConfirmation: Boolean!
  "Whether this is a manual fix (requires user action)"
  isManualFix: Boolean!
  "Manual steps if this cannot be automated"
  manualSteps: [String!]
  "RouterOS command that will be executed"
  command: String
  "Rollback command if fix needs to be reverted"
  rollbackCommand: String
}

"""
ISP contact information
"""
type ISPInfo {
  "ISP name"
  name: String!
  "ISP support phone number"
  phone: String
  "ISP support website URL"
  url: String
}

"""
A single step in the troubleshooting wizard
"""
type TroubleshootStep {
  "Step type/ID"
  id: TroubleshootStepType!
  "Step display name"
  name: String!
  "Step description"
  description: String!
  "Current status of this step"
  status: TroubleshootStepStatus!
  "Result of executing this step"
  result: TroubleshootStepResult
  "Suggested fix if step failed"
  fix: TroubleshootFixSuggestion
  "When the step started"
  startedAt: DateTime
  "When the step completed"
  completedAt: DateTime
}

"""
Complete troubleshooting session
"""
type TroubleshootSession {
  "Unique session identifier"
  id: ID!
  "Router being diagnosed"
  routerId: ID!
  "All diagnostic steps"
  steps: [TroubleshootStep!]!
  "Current step index (0-based)"
  currentStepIndex: Int!
  "Overall session status"
  status: TroubleshootSessionStatus!
  "Detected WAN interface name"
  wanInterface: String
  "Detected default gateway IP"
  gateway: String
  "Detected ISP information"
  ispInfo: ISPInfo
  "Fixes that have been applied"
  appliedFixes: [String!]!
  "When the session started"
  startedAt: DateTime!
  "When the session completed"
  completedAt: DateTime
}

"""
Overall status of a troubleshooting session
"""
enum TroubleshootSessionStatus {
  "Session created but not started"
  IDLE
  "Detecting network configuration"
  INITIALIZING
  "Running diagnostic steps"
  RUNNING
  "Waiting for user decision on fix"
  AWAITING_FIX_DECISION
  "Applying a fix"
  APPLYING_FIX
  "Verifying fix worked"
  VERIFYING_FIX
  "Session completed"
  COMPLETED
  "Session was cancelled"
  CANCELLED
}

"""
Result of starting a troubleshooting session
"""
type StartTroubleshootPayload {
  "The created session"
  session: TroubleshootSession
  "Errors that occurred"
  errors: [MutationError!]
}

"""
Result of running a diagnostic step
"""
type RunTroubleshootStepPayload {
  "Updated step with result"
  step: TroubleshootStep!
  "Errors that occurred"
  errors: [MutationError!]
}

"""
Result of applying a fix
"""
type ApplyFixPayload {
  "Whether fix was applied successfully"
  success: Boolean!
  "User-friendly message"
  message: String!
  "Fix application status"
  status: FixApplicationStatus!
  "Errors that occurred"
  errors: [MutationError!]
}

"""
Network configuration detection result
"""
type NetworkConfigDetection {
  "Detected WAN interface name"
  wanInterface: String!
  "Detected default gateway IP"
  gateway: String
  "Detected ISP information"
  ispInfo: ISPInfo
}

# -----------------------------------------------------------------------------
# Query Extensions (Internet Troubleshooting)
# -----------------------------------------------------------------------------

extend type Query {
  """
  Get a troubleshooting session by ID
  """
  troubleshootSession(id: ID!): TroubleshootSession

  """
  Detect WAN interface from default route
  """
  detectWanInterface(routerId: ID!): String!

  """
  Detect default gateway from DHCP client or static route
  """
  detectGateway(routerId: ID!): String

  """
  Detect ISP information from WAN IP
  """
  detectISP(routerId: ID!): ISPInfo
}

# -----------------------------------------------------------------------------
# Mutation Extensions (Internet Troubleshooting)
# -----------------------------------------------------------------------------

extend type Mutation {
  """
  Start a new troubleshooting session for a router.
  Automatically detects network configuration and begins diagnostics.
  """
  startTroubleshoot(routerId: ID!): StartTroubleshootPayload!

  """
  Run a specific diagnostic step in a session
  """
  runTroubleshootStep(
    "Session ID"
    sessionId: ID!
    "Step to run"
    stepType: TroubleshootStepType!
  ): RunTroubleshootStepPayload!

  """
  Apply a suggested fix for a failed diagnostic step
  """
  applyTroubleshootFix(
    "Session ID"
    sessionId: ID!
    "Issue code to fix"
    issueCode: String!
  ): ApplyFixPayload!

  """
  Verify a fix by re-running the diagnostic step
  """
  verifyTroubleshootFix(
    "Session ID"
    sessionId: ID!
    "Step to verify"
    stepType: TroubleshootStepType!
  ): RunTroubleshootStepPayload!

  """
  Cancel a troubleshooting session
  """
  cancelTroubleshoot(sessionId: ID!): TroubleshootSession!
}

# -----------------------------------------------------------------------------
# Subscription Extensions (Internet Troubleshooting)
# -----------------------------------------------------------------------------

extend type Subscription {
  """
  Subscribe to troubleshooting session progress.
  Emits events as steps are executed, fixes are applied, and results are updated.
  """
  troubleshootProgress(sessionId: ID!): TroubleshootSession!
}

# =============================================================================
# Traceroute Diagnostic Tool
# =============================================================================
# This schema provides types and operations for running traceroute diagnostics
# from the router to discover network paths and identify latency issues.
# Story: NAS-5.8 - Implement Traceroute Diagnostic Tool
# =============================================================================

# -----------------------------------------------------------------------------
# Traceroute Types
# -----------------------------------------------------------------------------

"""
Status of a single hop in a traceroute
"""
enum HopStatus {
  "Hop responded successfully"
  SUCCESS
  "Hop did not respond (timeout)"
  TIMEOUT
  "Destination unreachable at this hop"
  UNREACHABLE
  "Access prohibited (firewall/ACL)"
  PROHIBITED
}

"""
Protocol to use for traceroute probes
"""
enum TracerouteProtocol {
  "ICMP echo request (default)"
  ICMP
  "UDP probes"
  UDP
  "TCP SYN probes"
  TCP
}

"""
A single probe result within a hop
"""
type HopProbe {
  "Probe number (1-3 typically)"
  probeNumber: Int!
  "Latency in milliseconds (null for timeout)"
  latencyMs: Float
  "Whether the probe succeeded"
  success: Boolean!
  "ICMP error code if probe failed"
  icmpCode: String
}

"""
A single hop in the traceroute path
"""
type TracerouteHop {
  "Hop number (1-based)"
  hopNumber: Int!
  "IP address of the hop (null for timeout)"
  address: String
  "Reverse DNS hostname (if available)"
  hostname: String
  "Individual probe results for this hop"
  probes: [HopProbe!]!
  "Status of this hop"
  status: HopStatus!
  "Average latency across successful probes"
  avgLatencyMs: Float
  "Packet loss percentage for this hop (0-100)"
  packetLoss: Float!
}

"""
Complete traceroute result
"""
type TracerouteResult {
  "Target hostname or IP address"
  target: String!
  "Resolved target IP address"
  targetIp: String!
  "Protocol used for probes"
  protocol: TracerouteProtocol!
  "Maximum hops configured"
  maxHops: Int!
  "Discovered hops in order"
  hops: [TracerouteHop!]!
  "Whether traceroute completed"
  completed: Boolean!
  "Whether destination was reached"
  reachedDestination: Boolean!
  "Total time from start to completion (ms)"
  totalTimeMs: Float!
  "When the traceroute started"
  startedAt: DateTime!
  "When the traceroute completed (if finished)"
  completedAt: DateTime
}

"""
Input parameters for starting a traceroute
"""
input TracerouteInput {
  "Target hostname or IP address"
  target: String!
  "Maximum number of hops (default: 30, max: 64)"
  maxHops: Int = 30
  "Timeout per hop in milliseconds (default: 3000)"
  timeout: Int = 3000
  "Number of probes per hop (default: 3)"
  probeCount: Int = 3
  "Protocol to use for probes (default: ICMP)"
  protocol: TracerouteProtocol = ICMP
}

"""
Job status for async traceroute execution
"""
enum JobStatus {
  "Job has been created"
  STARTED
  "Job is currently running"
  RUNNING
  "Job completed successfully"
  COMPLETE
  "Job was cancelled by user"
  CANCELLED
  "Job encountered an error"
  ERROR
}

"""
Traceroute job reference for subscription tracking
"""
type TracerouteJob {
  "Unique job identifier"
  jobId: ID!
  "Current job status"
  status: JobStatus!
}

"""
Event type for traceroute progress updates
"""
enum TracerouteEventType {
  "A new hop was discovered"
  HOP_DISCOVERED
  "Traceroute completed"
  COMPLETE
  "Traceroute encountered an error"
  ERROR
  "Traceroute was cancelled"
  CANCELLED
}

"""
Progress event emitted during traceroute execution
"""
type TracerouteProgressEvent {
  "Job identifier"
  jobId: ID!
  "Type of event"
  eventType: TracerouteEventType!
  "Newly discovered hop (for HOP_DISCOVERED events)"
  hop: TracerouteHop
  "Final result (for COMPLETE events)"
  result: TracerouteResult
  "Error message (for ERROR events)"
  error: String
}

# -----------------------------------------------------------------------------
# Mutation Extensions (Traceroute)
# -----------------------------------------------------------------------------

extend type Mutation {
  """
  Start a traceroute from the router to the target.
  Returns a job ID for subscription tracking.
  """
  runTraceroute(
    "Device/router ID to run traceroute from"
    deviceId: ID!
    "Traceroute parameters"
    input: TracerouteInput!
  ): TracerouteJob!

  """
  Cancel a running traceroute job.
  """
  cancelTraceroute(
    "Job ID to cancel"
    jobId: ID!
  ): Boolean!
}

# -----------------------------------------------------------------------------
# Subscription Extensions (Traceroute)
# -----------------------------------------------------------------------------

extend type Subscription {
  """
  Subscribe to traceroute progress updates.
  Emits an event for each hop discovered and when traceroute completes.
  """
  tracerouteProgress(
    "Job ID to monitor"
    jobId: ID!
  ): TracerouteProgressEvent!
}

# =============================================================================
# DNS Lookup Tool
# =============================================================================
# This schema provides types and operations for DNS lookups, supporting
# multiple record types and server comparisons for troubleshooting.
# Story: NAS-5.9 - Implement DNS Lookup Tool
# =============================================================================

# -----------------------------------------------------------------------------
# DNS Lookup Types
# -----------------------------------------------------------------------------

"""
DNS lookup status codes
"""
enum DnsLookupStatus {
  "Query completed successfully"
  SUCCESS
  "Domain does not exist (NXDOMAIN)"
  NXDOMAIN
  "DNS server failure (SERVFAIL)"
  SERVFAIL
  "Query timed out"
  TIMEOUT
  "Query refused by server"
  REFUSED
  "Network error occurred"
  NETWORK_ERROR
}

"""
DNS record types supported
"""
enum DnsRecordType {
  "IPv4 address record"
  A
  "IPv6 address record"
  AAAA
  "Mail exchange record"
  MX
  "Text record"
  TXT
  "Canonical name record"
  CNAME
  "Name server record"
  NS
  "Pointer record (reverse DNS)"
  PTR
  "Start of authority record"
  SOA
  "Service record"
  SRV
}

"""
Single DNS record
"""
type DnsRecord {
  "Record name (query hostname)"
  name: String!
  "Record type"
  type: DnsRecordType!
  "Time to live in seconds"
  ttl: Int!
  "Record data (IP, hostname, text, etc.)"
  data: String!
  "Priority (for MX/SRV records)"
  priority: Int
  "Weight (for SRV records)"
  weight: Int
  "Port (for SRV records)"
  port: Int
}

"""
Result of a DNS lookup operation
"""
type DnsLookupResult {
  "Hostname that was queried"
  hostname: String!
  "Record type that was queried"
  recordType: DnsRecordType!
  "Query status"
  status: DnsLookupStatus!
  "Resolved records"
  records: [DnsRecord!]!
  "DNS server used"
  server: String!
  "Query time in milliseconds"
  queryTime: Int!
  "Whether response was authoritative"
  authoritative: Boolean!
  "Error message (if query failed)"
  error: String
  "When the query was executed"
  timestamp: DateTime!
}

"""
DNS server configuration
"""
type DnsServer {
  "Server IP address"
  address: String!
  "Whether this is the primary DNS server"
  isPrimary: Boolean!
  "Whether this is the secondary DNS server"
  isSecondary: Boolean!
}

"""
Collection of DNS servers
"""
type DnsServers {
  "All configured DNS servers"
  servers: [DnsServer!]!
  "Primary DNS server address"
  primary: String!
  "Secondary DNS server address (if configured)"
  secondary: String
}

"""
Input for DNS lookup operation
"""
input DnsLookupInput {
  "Device/router ID to run lookup from"
  deviceId: String!
  "Hostname or IP address to look up"
  hostname: String!
  "DNS record type to query"
  recordType: DnsRecordType!
  "DNS server to use (defaults to router's configured DNS)"
  server: String
  "Query timeout in seconds (default: 5)"
  timeout: Int
}

# -----------------------------------------------------------------------------
# Query Extensions (DNS Lookup)
# -----------------------------------------------------------------------------

extend type Query {
  """
  Get configured DNS servers for a device.
  Returns primary and secondary DNS servers configured on the router.
  """
  dnsServers(
    "Device/router ID"
    deviceId: String!
  ): DnsServers!
}

# -----------------------------------------------------------------------------
# Mutation Extensions (DNS Lookup)
# -----------------------------------------------------------------------------

extend type Mutation {
  """
  Perform DNS lookup (synchronous request-response).
  Queries the specified DNS server for the hostname and record type.
  Uses RouterOS native DNS lookup for A/AAAA records when possible,
  falls back to Go resolver for other record types.
  """
  runDnsLookup(
    "DNS lookup parameters"
    input: DnsLookupInput!
  ): DnsLookupResult!
}
`, BuiltIn: false},
	{Name: "../../../schema/alerts.graphql", Input: `# =============================================================================
# Alert Rules and Notifications Schema
# =============================================================================
# Defines alert rules, alerts, notification channels, and real-time subscriptions
# for the NasNetConnect monitoring and alerting system.
# =============================================================================

# -----------------------------------------------------------------------------
# Alert Types
# -----------------------------------------------------------------------------

"""
Alert rule defines conditions that trigger notifications when met
"""
type AlertRule implements Node {
  """Globally unique identifier"""
  id: ID!

  """Human-readable alert rule name"""
  name: String!

  """Optional description of what this rule monitors"""
  description: String

  """Event type to match (e.g., 'router.offline', 'interface.down', 'cpu.high')"""
  eventType: String!

  """Array of conditions for event matching"""
  conditions: [AlertCondition!]!

  """Alert severity level"""
  severity: AlertSeverity!

  """Notification channels to use"""
  channels: [String!]!

  """Throttle configuration to prevent alert spam"""
  throttle: ThrottleConfig

  """Quiet hours configuration for non-critical alerts"""
  quietHours: QuietHoursConfig

  """Optional device ID filter - rule only applies to this device"""
  deviceId: ID

  """Whether this alert rule is enabled"""
  enabled: Boolean!

  """Record creation timestamp"""
  createdAt: DateTime!

  """Last update timestamp"""
  updatedAt: DateTime!

  """Alerts triggered by this rule"""
  alerts(
    """Filter by acknowledged status"""
    acknowledged: Boolean
    """Limit number of results"""
    limit: Int = 50
  ): [Alert!]!
}

"""
Individual alert instance triggered when rule conditions are met
"""
type Alert implements Node {
  """Globally unique identifier"""
  id: ID!

  """Alert rule that triggered this alert"""
  rule: AlertRule!

  """Event type that triggered this alert"""
  eventType: String!

  """Alert severity level"""
  severity: AlertSeverity!

  """Alert title/summary"""
  title: String!

  """Detailed alert message"""
  message: String!

  """Event data and context information"""
  data: JSON

  """Device ID that triggered this alert"""
  deviceId: ID

  """When alert was triggered"""
  triggeredAt: DateTime!

  """When alert was acknowledged"""
  acknowledgedAt: DateTime

  """User who acknowledged the alert"""
  acknowledgedBy: String

  """Delivery status per channel"""
  deliveryStatus: JSON

  """Last update timestamp"""
  updatedAt: DateTime!
}

"""
Condition for event matching in alert rules
"""
type AlertCondition {
  """Field name to evaluate"""
  field: String!

  """Comparison operator"""
  operator: ConditionOperator!

  """Value to compare against"""
  value: String!
}

"""
Throttle configuration to prevent alert spam
"""
type ThrottleConfig {
  """Maximum number of alerts allowed"""
  maxAlerts: Int!

  """Time period in seconds"""
  periodSeconds: Int!

  """Optional field to group alerts by"""
  groupByField: String
}

"""
Quiet hours configuration
"""
type QuietHoursConfig {
  """Start time in HH:MM format"""
  startTime: String!

  """End time in HH:MM format"""
  endTime: String!

  """Timezone (IANA timezone database name)"""
  timezone: String!

  """Whether critical alerts bypass quiet hours"""
  bypassCritical: Boolean!
}

# -----------------------------------------------------------------------------
# Enums
# -----------------------------------------------------------------------------

"""
Alert severity levels
"""
enum AlertSeverity {
  """Critical - requires immediate attention"""
  CRITICAL

  """Warning - attention needed soon"""
  WARNING

  """Info - informational only"""
  INFO
}

"""
Condition comparison operators
"""
enum ConditionOperator {
  """Exact match"""
  EQUALS

  """Not equal"""
  NOT_EQUALS

  """Numeric greater than"""
  GREATER_THAN

  """Numeric less than"""
  LESS_THAN

  """String contains"""
  CONTAINS

  """Regular expression match"""
  REGEX
}

"""
Alert action types for subscriptions
"""
enum AlertAction {
  """Alert was created/triggered"""
  CREATED

  """Alert was acknowledged"""
  ACKNOWLEDGED

  """Alert was resolved"""
  RESOLVED
}

# -----------------------------------------------------------------------------
# Input Types
# -----------------------------------------------------------------------------

"""
Input for creating an alert rule
"""
input CreateAlertRuleInput {
  """Human-readable alert rule name"""
  name: String!

  """Optional description"""
  description: String

  """Event type to match"""
  eventType: String!

  """Array of conditions"""
  conditions: [AlertConditionInput!]

  """Alert severity level"""
  severity: AlertSeverity!

  """Notification channels"""
  channels: [String!]!

  """Throttle configuration"""
  throttle: ThrottleConfigInput

  """Quiet hours configuration"""
  quietHours: QuietHoursConfigInput

  """Optional device ID filter"""
  deviceId: ID

  """Whether rule is enabled (default: true)"""
  enabled: Boolean = true
}

"""
Input for updating an alert rule
"""
input UpdateAlertRuleInput {
  """Human-readable alert rule name"""
  name: String

  """Optional description"""
  description: String

  """Event type to match"""
  eventType: String

  """Array of conditions"""
  conditions: [AlertConditionInput!]

  """Alert severity level"""
  severity: AlertSeverity

  """Notification channels"""
  channels: [String!]

  """Throttle configuration"""
  throttle: ThrottleConfigInput

  """Quiet hours configuration"""
  quietHours: QuietHoursConfigInput

  """Optional device ID filter"""
  deviceId: ID

  """Whether rule is enabled"""
  enabled: Boolean
}

"""
Alert condition input
"""
input AlertConditionInput {
  """Field name to evaluate"""
  field: String!

  """Comparison operator"""
  operator: ConditionOperator!

  """Value to compare against"""
  value: String!
}

"""
Throttle configuration input
"""
input ThrottleConfigInput {
  """Maximum number of alerts allowed"""
  maxAlerts: Int!

  """Time period in seconds"""
  periodSeconds: Int!

  """Optional field to group alerts by"""
  groupByField: String
}

"""
Quiet hours configuration input
"""
input QuietHoursConfigInput {
  """Start time in HH:MM format"""
  startTime: String!

  """End time in HH:MM format"""
  endTime: String!

  """Timezone (default: UTC)"""
  timezone: String = "UTC"

  """Whether critical alerts bypass quiet hours (default: true)"""
  bypassCritical: Boolean = true
}

# -----------------------------------------------------------------------------
# Connection Types (Relay Pagination)
# -----------------------------------------------------------------------------

"""
Paginated alert connection
"""
type AlertConnection implements Connection {
  """Alert edges"""
  edges: [AlertEdge!]!

  """Pagination information"""
  pageInfo: PageInfo!

  """Total count of alerts"""
  totalCount: Int!
}

"""
Alert edge for pagination
"""
type AlertEdge implements Edge {
  """Alert node"""
  node: Alert!

  """Pagination cursor"""
  cursor: String!
}

# -----------------------------------------------------------------------------
# Payload Types
# -----------------------------------------------------------------------------

"""
Alert rule mutation payload
"""
type AlertRulePayload {
  """Created/updated alert rule"""
  alertRule: AlertRule

  """Errors encountered during mutation"""
  errors: [MutationError!]
}

"""
Alert mutation payload
"""
type AlertPayload {
  """Modified alert"""
  alert: Alert

  """Errors encountered during mutation"""
  errors: [MutationError!]
}

"""
Bulk alert mutation payload
"""
type BulkAlertPayload {
  """Number of alerts acknowledged"""
  acknowledgedCount: Int!

  """Errors encountered during mutation"""
  errors: [MutationError!]
}

"""
Test notification payload
"""
type TestNotificationPayload {
  """Whether test was successful"""
  success: Boolean!

  """Test result message"""
  message: String

  """Errors encountered during test"""
  errors: [MutationError!]
}

"""
Delete operation payload
"""
type DeletePayload {
  """Whether deletion was successful"""
  success: Boolean!

  """ID of deleted item"""
  deletedId: ID

  """Errors encountered during deletion"""
  errors: [MutationError!]
}

# -----------------------------------------------------------------------------
# Subscription Event Types
# -----------------------------------------------------------------------------

"""
Alert event for real-time subscriptions
"""
type AlertEvent {
  """The alert that changed"""
  alert: Alert!

  """Type of action that occurred"""
  action: AlertAction!
}

# -----------------------------------------------------------------------------
# Queries
# -----------------------------------------------------------------------------

extend type Query {
  """
  Get all alert rules, optionally filtered by device
  """
  alertRules(
    """Filter by device ID"""
    deviceId: ID
  ): [AlertRule!]!

  """
  Get a single alert rule by ID
  """
  alertRule(
    """Alert rule ID"""
    id: ID!
  ): AlertRule

  """
  Get alerts with filtering and pagination
  """
  alerts(
    """Filter by device ID"""
    deviceId: ID
    """Filter by severity"""
    severity: AlertSeverity
    """Filter by acknowledged status"""
    acknowledged: Boolean
    """Pagination limit"""
    limit: Int = 50
    """Pagination offset"""
    offset: Int = 0
  ): AlertConnection!
}

# -----------------------------------------------------------------------------
# Mutations
# -----------------------------------------------------------------------------

extend type Mutation {
  """
  Create a new alert rule
  """
  createAlertRule(
    """Alert rule input"""
    input: CreateAlertRuleInput!
  ): AlertRulePayload!

  """
  Update an existing alert rule
  """
  updateAlertRule(
    """Alert rule ID"""
    id: ID!
    """Update input"""
    input: UpdateAlertRuleInput!
  ): AlertRulePayload!

  """
  Delete an alert rule
  """
  deleteAlertRule(
    """Alert rule ID"""
    id: ID!
  ): DeletePayload!

  """
  Acknowledge a single alert
  """
  acknowledgeAlert(
    """Alert ID"""
    alertId: ID!
  ): AlertPayload!

  """
  Acknowledge multiple alerts
  """
  acknowledgeAlerts(
    """Array of alert IDs"""
    alertIds: [ID!]!
  ): BulkAlertPayload!

  """
  Test a notification channel
  """
  testNotificationChannel(
    """Channel type (email, telegram, pushover, webhook)"""
    channel: String!
    """Channel configuration"""
    config: JSON!
  ): TestNotificationPayload!
}

# -----------------------------------------------------------------------------
# Subscriptions
# -----------------------------------------------------------------------------

extend type Subscription {
  """
  Subscribe to alert events for real-time updates
  """
  alertEvents(
    """Filter by device ID"""
    deviceId: ID
  ): AlertEvent!
}
`, BuiltIn: false},
	{Name: "../../../schema/router-add.graphql", Input: `# =============================================================================
# Router Addition GraphQL Schema Extension
# =============================================================================
# This schema provides types and operations for manually adding routers with
# credential validation, protocol preference, and connection testing.
# Story: NAS-3.8 - Implement Manual Router Addition Flow
# =============================================================================

# -----------------------------------------------------------------------------
# Protocol Preference Enum
# -----------------------------------------------------------------------------

"""
User preference for which protocol to use when connecting to a router.
AUTO will try protocols in the recommended fallback order.
"""
enum ProtocolPreference {
  "Automatically detect best protocol (REST -> API -> API_SSL -> SSH -> Telnet)"
  AUTO
  "Force REST API protocol (RouterOS 7.1+)"
  REST
  "Force Binary API protocol (port 8728)"
  API
  "Force TLS-encrypted binary API (port 8729)"
  API_SSL
  "Force SSH protocol (port 22)"
  SSH
  "Force Telnet protocol (port 23, insecure - use only as last resort)"
  TELNET
}

# -----------------------------------------------------------------------------
# Input Types
# -----------------------------------------------------------------------------

"""
Input for manually adding a new router with full credentials and protocol preference.
This is the primary input type for the addRouter mutation.
"""
input AddRouterInput {
  """
  Router hostname or IP address.
  Can be an IPv4 address (e.g., '192.168.88.1'), IPv6 address, or hostname (e.g., 'router.local').
  Hostnames will trigger DNS resolution with caching.
  """
  host: String! @validate(minLength: 1, maxLength: 253)

  """
  Connection port. If not specified, defaults to protocol-specific port:
  - REST: 443 (or 80 for HTTP)
  - API: 8728
  - API_SSL: 8729
  - SSH: 22
  - Telnet: 23
  """
  port: Int @validate(min: 1, max: 65535)

  """
  Username for authentication.
  For MikroTik routers, this is typically 'admin' or a custom user.
  """
  username: String! @validate(minLength: 1, maxLength: 64)

  """
  Password for authentication.
  This value is encrypted before storage and never logged.
  """
  password: String! @sensitive

  """
  Protocol preference for connection.
  Defaults to AUTO which tries protocols in recommended order.
  """
  protocolPreference: ProtocolPreference

  """
  User-friendly display name for the router.
  If not provided, a name will be generated from the host.
  """
  name: String @validate(maxLength: 128)
}

# -----------------------------------------------------------------------------
# Connection Test Result
# -----------------------------------------------------------------------------

"""
Result of a connection test attempt, including protocol detection results.
"""
type ConnectionTestResult {
  "Whether the connection was successful"
  success: Boolean!

  "Protocol that was successfully used"
  protocolUsed: Protocol

  "Response time in milliseconds"
  responseTimeMs: Int

  "RouterOS version detected (if connection succeeded)"
  routerVersion: String

  "Router model detected (if connection succeeded)"
  routerModel: String

  "Router board name (if connection succeeded)"
  boardName: String

  "Uptime of the router (if connection succeeded)"
  uptime: Duration

  "List of protocols that were attempted"
  protocolsAttempted: [Protocol!]!

  "Whether the router supports containers"
  supportsContainers: Boolean

  "Architecture of the router (arm, arm64, x86, etc.)"
  architecture: String

  "Error details if connection failed"
  error: ConnectionError
}

"""
Detailed error information for connection failures.
Used to provide actionable feedback to the user.
"""
type ConnectionError {
  "Error code for programmatic handling"
  code: ConnectionErrorCode!

  "Human-readable error message"
  message: String!

  "Protocol that failed (if specific to a protocol)"
  protocol: Protocol

  "Whether the error is likely transient and retryable"
  retryable: Boolean!

  "Suggested user action to resolve the error"
  suggestedAction: String

  "Timeout in milliseconds (if timeout error)"
  timeoutMs: Int
}

"""
Error codes for connection failures.
Each code has specific meaning and recovery suggestions.
"""
enum ConnectionErrorCode {
  "Authentication failed - invalid username or password"
  AUTH_FAILED
  "Network unreachable - cannot reach the host"
  NETWORK_UNREACHABLE
  "Connection refused - port is closed or blocked"
  CONNECTION_REFUSED
  "No compatible protocol found after trying all options"
  PROTOCOL_MISMATCH
  "Connection or response timed out"
  TIMEOUT
  "DNS resolution failed for hostname"
  DNS_FAILED
  "Router with same host/port already exists"
  DUPLICATE_ROUTER
  "TLS/SSL handshake failed"
  TLS_ERROR
  "Router responded but is not a MikroTik device"
  NOT_MIKROTIK
  "Unknown or unexpected error"
  UNKNOWN
}

# -----------------------------------------------------------------------------
# Mutation Payload
# -----------------------------------------------------------------------------

"""
Field-level validation error with suggestions for fixing.
"""
type ValidationError {
  "Field path that failed validation (e.g., 'input.host', 'input.port')"
  field: String!

  "Error code for the validation failure"
  code: String!

  "Human-readable error message"
  message: String!

  "Suggestion for fixing the validation error"
  suggestion: String

  "The invalid value (redacted for sensitive fields)"
  providedValue: String
}

"""
Payload returned from the addRouter mutation.
Contains either the created router or validation/connection errors.
"""
type AddRouterPayload {
  "The newly created router (null if errors occurred)"
  router: Router

  "Connection test result from initial connection attempt"
  connectionResult: ConnectionTestResult

  "Field-level validation errors for retry"
  validationErrors: [ValidationError!]

  "General errors that occurred during creation"
  errors: [MutationError!]
}

# -----------------------------------------------------------------------------
# Mutation Extension
# -----------------------------------------------------------------------------

extend type Mutation {
  """
  Add a new router by entering its IP address and credentials.

  This mutation will:
  1. Validate input fields (host format, port range, etc.)
  2. Check for duplicate routers (same host/port)
  3. Resolve hostname to IP if necessary (with DNS caching)
  4. Test connection using protocol preference (or auto-detect)
  5. Store router with encrypted credentials on success
  6. Emit RouterAddedEvent for real-time updates

  Returns validation errors if input is invalid, or connection errors
  if the router cannot be reached or authenticated.
  """
  addRouter(input: AddRouterInput!): AddRouterPayload!

  """
  Test connection to a router without adding it.
  Useful for validating credentials before committing.
  """
  testRouterCredentials(input: AddRouterInput!): ConnectionTestResult!
}

# -----------------------------------------------------------------------------
# Subscription Extension
# -----------------------------------------------------------------------------

extend type Subscription {
  """
  Subscribe to router addition events.
  Emits when a new router is successfully added to the system.
  """
  routerAdded: RouterAddedEvent!
}

"""
Event emitted when a new router is added.
"""
type RouterAddedEvent {
  "The newly added router"
  router: Router!

  "Protocol used for initial connection"
  protocolUsed: Protocol!

  "User who added the router (if authenticated)"
  addedBy: String

  "Timestamp of addition"
  timestamp: DateTime!
}
`, BuiltIn: false},
	{Name: "../../../schema/resource.graphql", Input: `# =============================================================================
# Universal State v2 - Resource Schema
# =============================================================================
# This schema defines the 8-layer Resource Model for NasNetConnect.
# Every managed resource (VPN, Network, Firewall Rule, Feature) implements
# this interface to provide consistent state management.
#
# Reference: ADR-012 - Universal State v2
# Reference: Docs/architecture/data-architecture.md
# =============================================================================

# -----------------------------------------------------------------------------
# Resource Interface
# -----------------------------------------------------------------------------

"""
Universal State v2 Resource Interface.
Every managed resource implements this interface with 8 layers:
1. configuration - User's desired config (mutable by user)
2. validation - Pre-flight check results (computed by backend)
3. deployment - What's on router (after Apply-Confirm)
4. runtime - Live operational state (polled/streamed)
5. telemetry - Time-series metrics (historical)
6. metadata - Lifecycle info, tags, ownership
7. relationships - Dependencies (embedded + explicit)
8. platform - Capabilities and field mappings
"""
interface Resource {
  "Globally unique identifier (ULID) - also serves as Node.id for Relay compatibility"
  id: ID!

  "Scoped identifier for readability (e.g., 'vpn.wg.client:usa-vpn:a1b2')"
  scopedId: String!

  "Resource type identifier (e.g., 'vpn.wireguard.client')"
  type: String!

  "Resource category"
  category: ResourceCategory!

  # =========================================================================
  # 8-LAYER MODEL
  # =========================================================================

  """
  Layer 1: CONFIGURATION - User's desired config
  Mutable by user. Validated by Zod on client, GraphQL on server.
  Implementations can provide strongly-typed configs.
  """
  configuration: JSON

  """
  Layer 2: VALIDATION - Pre-flight check results
  Computed by backend. Updated on every configuration change.
  """
  validation: ValidationResult

  """
  Layer 3: DEPLOYMENT - What's actually on router
  Written after Apply-Confirm. Includes router-generated fields.
  Implementations can provide strongly-typed deployment states.
  """
  deployment: DeploymentState

  """
  Layer 4: RUNTIME - Live operational state
  Polled/streamed from router. Read-only.
  Implementations can provide strongly-typed runtime states.
  """
  runtime: RuntimeState

  """
  Layer 5: TELEMETRY - Time-series metrics
  Historical data collected over time. Read-only.
  """
  telemetry: TelemetryData

  """
  Layer 6: METADATA - Resource lifecycle info
  System-managed. Includes tags, version, ownership.
  """
  metadata: ResourceMetadata!

  """
  Layer 7: RELATIONSHIPS - Dependencies
  Embedded in config (user-defined) + explicit table (system-discovered).
  """
  relationships: ResourceRelationships

  """
  Layer 8: PLATFORM - Capabilities and field mappings
  From platform adapter. Router-specific behavior.
  """
  platform: PlatformInfo
}

# -----------------------------------------------------------------------------
# Resource Category Enum
# -----------------------------------------------------------------------------

"""
Categories of managed resources
"""
enum ResourceCategory {
  "Network topology: WAN Links, LAN Networks, VLANs"
  NETWORK

  "VPN connectivity: WireGuard, OpenVPN, IPsec"
  VPN

  "System infrastructure: Certificates, NTP, DDNS"
  INFRASTRUCTURE

  "Application-level: Port Forwarding, Game Rules"
  APPLICATION

  "Marketplace features: Tor, AdGuard, sing-box"
  FEATURE

  "Community extensions: Third-party plugins"
  PLUGIN
}

# -----------------------------------------------------------------------------
# Resource Lifecycle States
# -----------------------------------------------------------------------------

"""
Resource lifecycle states for state machine
"""
enum ResourceLifecycleState {
  "Initial creation, not yet validated"
  DRAFT

  "Backend validation in progress"
  VALIDATING

  "Passed validation, ready to apply"
  VALID

  "Being applied to router"
  APPLYING

  "Successfully applied and running"
  ACTIVE

  "Running but with issues"
  DEGRADED

  "Failed state (validation or apply)"
  ERROR

  "Marked for removal"
  DEPRECATED

  "Final state, no longer active"
  ARCHIVED
}

# -----------------------------------------------------------------------------
# Resource Connection (Relay Pagination)
# -----------------------------------------------------------------------------

type ResourceConnection implements Connection {
  edges: [ResourceEdge!]!
  pageInfo: PageInfo!
  totalCount: Int
}

type ResourceEdge implements Edge {
  cursor: String!
  node: Resource!
}

# -----------------------------------------------------------------------------
# Resource Queries
# -----------------------------------------------------------------------------

extend type Query {
  """
  Get a resource by ID
  """
  resource(
    "Resource ID (ULID)"
    id: ID!
    "Router the resource belongs to"
    routerId: ID!
    "Specific layers to fetch (default: all)"
    layers: [ResourceLayer!]
  ): Resource

  """
  List resources for a router
  """
  resources(
    "Router to query"
    routerId: ID!
    "Filter by category"
    category: ResourceCategory
    "Filter by type"
    type: String
    "Filter by lifecycle state"
    state: ResourceLifecycleState
    "Pagination parameters"
    pagination: PaginationInput
  ): ResourceConnection!

  """
  Get composite resource with all related sub-resources
  """
  compositeResource(
    "Resource ID (ULID)"
    id: ID!
    "Router the resource belongs to"
    routerId: ID!
  ): CompositeResource
}

# -----------------------------------------------------------------------------
# Resource Mutations
# -----------------------------------------------------------------------------

extend type Mutation {
  """
  Create a new resource (starts in DRAFT state)
  """
  createResource(input: CreateResourceInput!): CreateResourcePayload!

  """
  Update resource configuration (transitions to DRAFT  VALIDATING)
  """
  updateResource(
    id: ID!
    routerId: ID!
    input: UpdateResourceInput!
  ): UpdateResourcePayload!

  """
  Validate resource configuration (transitions DRAFT  VALIDATING  VALID/ERROR)
  """
  validateResource(id: ID!, routerId: ID!): ValidateResourcePayload!

  """
  Apply resource to router (transitions VALID  APPLYING  ACTIVE/ERROR)
  Follows Apply-Confirm-Merge pattern.
  """
  applyResource(id: ID!, routerId: ID!): ApplyResourcePayload!

  """
  Deprecate a resource (transitions  DEPRECATED)
  """
  deprecateResource(id: ID!, routerId: ID!): DeprecateResourcePayload!

  """
  Archive a resource (transitions DEPRECATED  ARCHIVED)
  """
  archiveResource(id: ID!, routerId: ID!): ArchiveResourcePayload!

  """
  Delete a resource permanently
  """
  deleteResource(id: ID!, routerId: ID!): DeleteResourcePayload!
}

# -----------------------------------------------------------------------------
# Resource Subscriptions
# -----------------------------------------------------------------------------

extend type Subscription {
  """
  Subscribe to resource runtime updates
  """
  resourceRuntime(
    "Resource ID (ULID)"
    id: ID!
    "Router the resource belongs to"
    routerId: ID!
  ): ResourceRuntimeEvent! @realtime(interval: 5000)

  """
  Subscribe to resource lifecycle state changes
  """
  resourceStateChanged(
    "Resource ID (optional - subscribe to all if not provided)"
    id: ID
    "Router to subscribe to"
    routerId: ID!
  ): ResourceStateEvent!
}

# -----------------------------------------------------------------------------
# Resource Layer Enum (for selective fetching)
# -----------------------------------------------------------------------------

"""
Selectable resource layers for optimized fetching
"""
enum ResourceLayer {
  CONFIGURATION
  VALIDATION
  DEPLOYMENT
  RUNTIME
  TELEMETRY
  METADATA
  RELATIONSHIPS
  PLATFORM
}

# -----------------------------------------------------------------------------
# Mutation Inputs
# -----------------------------------------------------------------------------

"""
Input for creating a new resource
"""
input CreateResourceInput {
  "Router to create resource on"
  routerId: ID!

  "Resource type (e.g., 'vpn.wireguard.client')"
  type: String!

  "Resource category"
  category: ResourceCategory!

  "Initial configuration"
  configuration: JSON!

  "User-defined relationships"
  relationships: ResourceRelationshipsInput

  "Initial tags"
  tags: [String!]

  "Resource description"
  description: String
}

"""
Input for updating resource configuration
"""
input UpdateResourceInput {
  "Updated configuration (partial or full)"
  configuration: JSON

  "Updated relationships"
  relationships: ResourceRelationshipsInput

  "Updated tags"
  tags: [String!]

  "Updated description"
  description: String
}

"""
Input for resource relationships
"""
input ResourceRelationshipsInput {
  "Resources this resource depends on (IDs)"
  dependsOn: [ID!]

  "Resources that route traffic via this resource (ID)"
  routesVia: ID

  "Parent resource ID (for hierarchical resources)"
  parent: ID

  "Custom relationship data"
  custom: JSON
}

# -----------------------------------------------------------------------------
# Mutation Payloads
# -----------------------------------------------------------------------------

type CreateResourcePayload {
  "The created resource"
  resource: Resource
  "Errors that occurred"
  errors: [MutationError!]
}

type UpdateResourcePayload {
  "The updated resource"
  resource: Resource
  "Errors that occurred"
  errors: [MutationError!]
}

type ValidateResourcePayload {
  "The validated resource"
  resource: Resource
  "Validation result"
  validation: ValidationResult
  "Errors that occurred"
  errors: [MutationError!]
}

type ApplyResourcePayload {
  "The applied resource"
  resource: Resource
  "Operation ID for progress tracking"
  operationId: ID!
  "Errors that occurred"
  errors: [MutationError!]
}

type DeprecateResourcePayload {
  "The deprecated resource"
  resource: Resource
  "Errors that occurred"
  errors: [MutationError!]
}

type ArchiveResourcePayload {
  "Whether archive was successful"
  success: Boolean!
  "Errors that occurred"
  errors: [MutationError!]
}

type DeleteResourcePayload {
  "Whether deletion was successful"
  success: Boolean!
  "ID of deleted resource"
  deletedId: ID
  "Errors that occurred"
  errors: [MutationError!]
}

# -----------------------------------------------------------------------------
# Subscription Events
# -----------------------------------------------------------------------------

"""
Runtime update event for a resource
"""
type ResourceRuntimeEvent {
  "Resource ID (ULID)"
  id: ID!
  "Resource type"
  type: String!
  "Updated runtime state"
  runtime: RuntimeState!
  "Timestamp of update"
  timestamp: DateTime!
}

"""
Lifecycle state change event
"""
type ResourceStateEvent {
  "Resource ID (ULID)"
  id: ID!
  "Resource type"
  type: String!
  "Previous state"
  previousState: ResourceLifecycleState!
  "New state"
  newState: ResourceLifecycleState!
  "Error message if state is ERROR"
  errorMessage: String
  "Timestamp of change"
  timestamp: DateTime!
}

# -----------------------------------------------------------------------------
# Composite Resource Type
# -----------------------------------------------------------------------------

"""
A composite resource with all related sub-resources
"""
type CompositeResource {
  "The root resource"
  root: Resource!
  "All child/related resources"
  children: [Resource!]!
  "Flattened relationship graph"
  relationships: [ResourceRelationshipEdge!]!
}

"""
Edge in the resource relationship graph
"""
type ResourceRelationshipEdge {
  "Source resource ID"
  from: ID!
  "Target resource ID"
  to: ID!
  "Relationship type"
  type: ResourceRelationshipType!
}

"""
Types of relationships between resources
"""
enum ResourceRelationshipType {
  "Child depends on parent"
  DEPENDS_ON
  "Traffic routes via this resource"
  ROUTES_VIA
  "Parent-child hierarchy"
  PARENT_CHILD
  "Resources are in the same group"
  GROUP
  "Custom relationship"
  CUSTOM
}
`, BuiltIn: false},
	{Name: "../../../schema/composite-resources.graphql", Input: `# =============================================================================
# Universal State v2 - Composite Resources Schema
# =============================================================================
# This schema defines composite resources that group related sub-resources.
# Examples: LANNetwork (bridge + DHCP + firewall), VPNClient (interface + routes)
#
# Reference: ADR-012 - Universal State v2
# Reference: Docs/architecture/data-architecture.md
# =============================================================================

# -----------------------------------------------------------------------------
# Concrete Resource Types
# -----------------------------------------------------------------------------

"""
WireGuard VPN Client resource implementing 8-layer model
"""
type WireGuardClient implements Resource & Node {
  id: ID!
  scopedId: String!
  type: String!
  category: ResourceCategory!

  # Generic configuration (interface requirement)
  configuration: JSON

  # Other layers
  validation: ValidationResult
  deployment: DeploymentState
  runtime: RuntimeState
  telemetry: TelemetryData
  metadata: ResourceMetadata!
  relationships: ResourceRelationships
  platform: PlatformInfo

  # Typed fields (additional to interface)
  config: WireGuardClientConfig!
  wireguardDeployment: WireGuardDeployment
  wireguardRuntime: WireGuardRuntime
}

"""
WireGuard client configuration
"""
type WireGuardClientConfig {
  "User-friendly name"
  name: String!

  "WireGuard private key"
  privateKey: String! @sensitive

  "Peer public key"
  peerPublicKey: String!

  "Peer endpoint (IP:port)"
  peerEndpoint: String!

  "Allowed IPs (CIDR notation)"
  allowedIPs: [CIDR!]!

  "Persistent keepalive interval"
  persistentKeepalive: Duration

  "Listen port (0 for auto)"
  listenPort: Port

  "WAN interface to use"
  wanInterface: ID

  "Enable kill switch"
  killSwitch: Boolean

  "DNS servers to use"
  dnsServers: [IPv4!]
}

"""
WireGuard deployment state (router-generated)
"""
type WireGuardDeployment {
  routerResourceId: String
  appliedAt: DateTime!
  appliedBy: String
  routerVersion: Int
  isInSync: Boolean!
  drift: DriftInfo

  # WireGuard-specific generated fields
  "Generated public key"
  publicKey: String
  "Assigned interface name"
  interfaceName: String
}

"""
WireGuard runtime state
"""
type WireGuardRuntime {
  isRunning: Boolean!
  health: RuntimeHealth!
  errorMessage: String
  lastUpdated: DateTime!

  # WireGuard-specific runtime
  "Whether connected to peer"
  isConnected: Boolean!
  "Last handshake time"
  lastHandshake: DateTime
  "Current endpoint (may differ from configured)"
  currentEndpoint: String
  "Bytes transferred in"
  bytesIn: Size!
  "Bytes transferred out"
  bytesOut: Size!
  "Current active peers count"
  activePeers: Int!
}

# -----------------------------------------------------------------------------
# LAN Network (Composite)
# -----------------------------------------------------------------------------

"""
LAN Network composite resource - groups bridge, DHCP, firewall, routing
"""
type LANNetwork implements Resource & Node {
  id: ID!
  scopedId: String!
  type: String!
  category: ResourceCategory!

  # Generic fields (interface requirement)
  configuration: JSON
  validation: ValidationResult
  deployment: DeploymentState
  runtime: RuntimeState
  telemetry: TelemetryData
  metadata: ResourceMetadata!
  relationships: ResourceRelationships
  platform: PlatformInfo

  # Typed fields (additional to interface)
  config: LANNetworkConfig!
  lanDeployment: LANNetworkDeployment
  lanRuntime: LANNetworkRuntime

  # Composite sub-resources
  "Bridge interface"
  bridge: BridgeResource
  "DHCP server configuration"
  dhcpServer: DHCPServerResource
  "Firewall rules for this LAN"
  firewallRules: [FirewallRuleResource!]!
  "Static routes"
  routes: [RouteResource!]!
}

"""
LAN Network configuration
"""
type LANNetworkConfig {
  "Network name"
  name: String!

  "IP address for the LAN"
  ipAddress: IPv4!

  "Subnet mask in CIDR notation"
  subnetMask: Int! @validate(min: 1, max: 32)

  "Interfaces to include in bridge"
  interfaces: [String!]!

  "Enable DHCP server"
  dhcpEnabled: Boolean!

  "DHCP pool start"
  dhcpPoolStart: IPv4

  "DHCP pool end"
  dhcpPoolEnd: IPv4

  "DHCP lease time"
  dhcpLeaseTime: Duration

  "DNS servers for DHCP"
  dnsServers: [IPv4!]

  "Enable NAT masquerading"
  enableNat: Boolean!

  "VLAN ID (optional)"
  vlanId: Int @validate(min: 1, max: 4094)
}

"""
LAN Network deployment state
"""
type LANNetworkDeployment {
  routerResourceId: String
  appliedAt: DateTime!
  appliedBy: String
  routerVersion: Int
  isInSync: Boolean!
  drift: DriftInfo

  # Composite deployment
  "Bridge interface ID on router"
  bridgeId: String
  "DHCP server ID on router"
  dhcpServerId: String
  "IP address ID on router"
  ipAddressId: String
}

"""
LAN Network runtime state
"""
type LANNetworkRuntime {
  isRunning: Boolean!
  health: RuntimeHealth!
  errorMessage: String
  lastUpdated: DateTime!

  # LAN-specific runtime
  "Number of active clients"
  activeClients: Int!
  "Active DHCP leases"
  dhcpLeases: Int!
  "Total traffic in"
  totalBytesIn: Size!
  "Total traffic out"
  totalBytesOut: Size!
}

# -----------------------------------------------------------------------------
# Sub-Resource Types
# -----------------------------------------------------------------------------

"""
Bridge resource (part of LANNetwork)
"""
type BridgeResource implements Resource & Node {
  id: ID!
  scopedId: String!
  type: String!
  category: ResourceCategory!
  configuration: JSON!
  validation: ValidationResult
  deployment: DeploymentState
  runtime: RuntimeState
  telemetry: TelemetryData
  metadata: ResourceMetadata!
  relationships: ResourceRelationships
  platform: PlatformInfo

  "Bridge name"
  name: String!
  "Ports in this bridge"
  ports: [String!]!
  "Protocol mode (rstp, stp, none)"
  protocolMode: String
}

"""
DHCP Server resource
"""
type DHCPServerResource implements Resource & Node {
  id: ID!
  scopedId: String!
  type: String!
  category: ResourceCategory!
  configuration: JSON!
  validation: ValidationResult
  deployment: DeploymentState
  runtime: RuntimeState
  telemetry: TelemetryData
  metadata: ResourceMetadata!
  relationships: ResourceRelationships
  platform: PlatformInfo

  "Server name"
  name: String!
  "Interface serving DHCP"
  interface: String!
  "Address pool name"
  addressPool: String!
  "Lease time"
  leaseTime: Duration!
  "Number of active leases"
  activeLeases: Int
}

"""
Firewall Rule resource
"""
type FirewallRuleResource implements Resource & Node {
  id: ID!
  scopedId: String!
  type: String!
  category: ResourceCategory!
  configuration: JSON!
  validation: ValidationResult
  deployment: DeploymentState
  runtime: RuntimeState
  telemetry: TelemetryData
  metadata: ResourceMetadata!
  relationships: ResourceRelationships
  platform: PlatformInfo

  "Rule chain (input, forward, output)"
  chain: String!
  "Rule action (accept, drop, reject)"
  action: String!
  "Source address/network"
  srcAddress: String
  "Destination address/network"
  dstAddress: String
  "Source port(s)"
  srcPort: String
  "Destination port(s)"
  dstPort: String
  "Protocol (tcp, udp, icmp, etc.)"
  protocol: String
  "Rule comment"
  comment: String
  "Whether rule is enabled"
  enabled: Boolean!
  "Hit counter"
  hitCount: Int
}

"""
Route resource
"""
type RouteResource implements Resource & Node {
  id: ID!
  scopedId: String!
  type: String!
  category: ResourceCategory!
  configuration: JSON!
  validation: ValidationResult
  deployment: DeploymentState
  runtime: RuntimeState
  telemetry: TelemetryData
  metadata: ResourceMetadata!
  relationships: ResourceRelationships
  platform: PlatformInfo

  "Destination network"
  dstAddress: CIDR!
  "Gateway address"
  gateway: IPv4
  "Outgoing interface"
  interface: String
  "Route distance/metric"
  distance: Int
  "Whether route is active"
  active: Boolean!
}

# -----------------------------------------------------------------------------
# WAN Link Resource
# -----------------------------------------------------------------------------

"""
WAN Link resource for internet connectivity
"""
type WANLink implements Resource & Node {
  id: ID!
  scopedId: String!
  type: String!
  category: ResourceCategory!
  configuration: JSON
  validation: ValidationResult
  deployment: DeploymentState
  runtime: RuntimeState
  telemetry: TelemetryData
  metadata: ResourceMetadata!
  relationships: ResourceRelationships
  platform: PlatformInfo

  # Typed runtime (additional to interface)
  wanRuntime: WANLinkRuntime

  "Interface name"
  interface: String!
  "Connection type (static, dhcp, pppoe)"
  connectionType: WANConnectionType!
  "Whether this is the primary WAN"
  isPrimary: Boolean!
  "Failover priority (lower = higher priority)"
  failoverPriority: Int
}

# Note: WANConnectionType enum is defined in wan.graphql

"""
WAN Link runtime state
"""
type WANLinkRuntime {
  isRunning: Boolean!
  health: RuntimeHealth!
  errorMessage: String
  lastUpdated: DateTime!

  # WAN-specific
  "Current IP address"
  currentIP: IPv4
  "Gateway address"
  gateway: IPv4
  "Public IP (may differ due to NAT)"
  publicIP: IPv4
  "DNS servers received"
  dnsServers: [IPv4!]
  "Current uplink speed (bytes/sec)"
  uplinkSpeed: Size
  "Current downlink speed (bytes/sec)"
  downlinkSpeed: Size
  "Total uptime"
  uptime: Duration
  "Last connection change"
  lastStateChange: DateTime
}

# -----------------------------------------------------------------------------
# Feature Resource (Marketplace)
# -----------------------------------------------------------------------------

"""
Marketplace Feature resource (Tor, AdGuard, sing-box, etc.)
"""
type FeatureResource implements Resource & Node {
  id: ID!
  scopedId: String!
  type: String!
  category: ResourceCategory!
  configuration: JSON
  validation: ValidationResult
  deployment: DeploymentState
  runtime: RuntimeState
  telemetry: TelemetryData
  metadata: ResourceMetadata!
  relationships: ResourceRelationships
  platform: PlatformInfo

  # Typed fields (additional to interface)
  featureDeployment: FeatureDeployment
  featureRuntime: FeatureRuntime

  "Feature identifier"
  featureId: String!
  "Feature name"
  name: String!
  "Feature version"
  version: String!
  "Virtual interface assigned"
  virtualInterface: String
}

"""
Feature deployment state
"""
type FeatureDeployment {
  routerResourceId: String
  appliedAt: DateTime!
  appliedBy: String
  routerVersion: Int
  isInSync: Boolean!
  drift: DriftInfo

  # Feature-specific
  "Container ID (if containerized)"
  containerId: String
  "Container image used"
  containerImage: String
  "Assigned ports"
  assignedPorts: [Port!]
  "Assigned IP address"
  assignedIP: IPv4
}

"""
Feature runtime state
"""
type FeatureRuntime {
  isRunning: Boolean!
  health: RuntimeHealth!
  errorMessage: String
  lastUpdated: DateTime!

  # Feature-specific
  "Container status"
  containerStatus: String
  "Memory usage"
  memoryUsage: Size
  "CPU usage percentage"
  cpuUsagePercent: Float
  "Devices routed through this feature"
  routedDevices: Int
}
`, BuiltIn: false},
	{Name: "../../../schema/network.graphql", Input: `# =============================================================================
# Network Management GraphQL Schema
# =============================================================================
# This schema defines types for advanced network management including:
# - VLAN interfaces (802.1Q)
# - Bridge port VLAN configuration
# - Network topology
#
# These types extend the base Interface type defined in schema.graphql
# =============================================================================

# -----------------------------------------------------------------------------
# VLAN Types
# -----------------------------------------------------------------------------

"""
A VLAN (Virtual LAN) interface for network segmentation using 802.1Q tagging
"""
type Vlan implements Node {
  "Unique VLAN identifier"
  id: ID!
  "VLAN interface name (e.g., vlan10, vlan-guest)"
  name: String! @validate(minLength: 1, maxLength: 100) @mikrotik(path: "/interface/vlan", field: "name")
  "802.1Q VLAN ID (1-4094)"
  vlanId: Int! @validate(min: 1, max: 4094) @mikrotik(path: "/interface/vlan", field: "vlan-id")
  "Parent interface (bridge or physical interface)"
  interface: Interface! @mikrotik(path: "/interface/vlan", field: "interface")
  "MTU setting (optional, inherits from parent if not set)"
  mtu: Int @validate(min: 68, max: 65535) @mikrotik(path: "/interface/vlan", field: "mtu")
  "MAC address of the VLAN interface"
  macAddress: MAC @mikrotik(path: "/interface/vlan", field: "mac-address")
  "Whether the VLAN interface is disabled"
  disabled: Boolean! @mikrotik(path: "/interface/vlan", field: "disabled")
  "Whether the VLAN interface is running (link up)"
  running: Boolean! @mikrotik(path: "/interface/vlan", field: "running")
  "User comment"
  comment: String @mikrotik(path: "/interface/vlan", field: "comment")
  "IP addresses assigned to this VLAN"
  ipAddresses: [IpAddress!]!
  "Traffic statistics for this VLAN"
  statistics: InterfaceStats
}

"""
Input for creating a new VLAN interface
"""
input VlanInput {
  "VLAN interface name (alphanumeric, hyphens, underscores)"
  name: String! @validate(minLength: 1, maxLength: 100, pattern: "^[a-zA-Z0-9_-]+$")
  "802.1Q VLAN ID (1-4094)"
  vlanId: Int! @validate(min: 1, max: 4094)
  "Parent interface ID (bridge or physical interface)"
  interface: ID!
  "MTU setting (optional, inherits from parent if not set)"
  mtu: Int @validate(min: 68, max: 65535)
  "User comment"
  comment: String @validate(maxLength: 255)
}

"""
Filter options for querying VLANs
"""
input VlanFilter {
  "Filter by parent interface ID"
  parentInterface: ID
  "Filter by VLAN ID range"
  vlanIdRange: IntRange
  "Filter by name containing this string"
  nameContains: String
}

"""
Integer range for filtering
"""
input IntRange {
  "Minimum value (inclusive)"
  min: Int
  "Maximum value (inclusive)"
  max: Int
}

"""
Result of a VLAN mutation (create, update)
"""
type VlanMutationResult {
  "Whether the operation succeeded"
  success: Boolean!
  "The created or updated VLAN (if successful)"
  vlan: Vlan
  "Configuration preview (RouterOS commands that will be executed)"
  preview: ConfigPreview
  "Errors that occurred during the operation"
  errors: [MutationError!]
}

"""
Result of a delete operation
"""
type DeleteResult {
  "Whether the deletion succeeded"
  success: Boolean!
  "Success or error message"
  message: String
  "Errors that occurred during deletion"
  errors: [MutationError!]
}

"""
Preview of RouterOS configuration commands
"""
type ConfigPreview {
  "RouterOS commands to be executed"
  commands: [String!]!
  "Warnings about the configuration changes"
  warnings: [String!]
  "Resources that will be affected"
  affectedResources: [AffectedResource!]
}

"""
Resource affected by a configuration change
"""
type AffectedResource {
  "Resource type (ip-address, dhcp-server, firewall-rule, etc.)"
  type: String!
  "Resource ID"
  id: ID!
  "Resource name or description"
  name: String!
  "How the resource will be affected (modified, disabled, removed)"
  impact: ResourceImpact!
}

"""
Impact level for affected resources
"""
enum ResourceImpact {
  "Resource will be modified"
  MODIFIED
  "Resource will be disabled"
  DISABLED
  "Resource will be removed"
  REMOVED
  "Connections will be dropped"
  CONNECTION_DROP
}

# -----------------------------------------------------------------------------
# IP Address Types
# -----------------------------------------------------------------------------

"""
An IP address assigned to an interface
"""
type IpAddress implements Node {
  "Unique IP address identifier"
  id: ID!
  "IP address with CIDR notation (e.g., 192.168.10.1/24)"
  address: String! @validate(format: CIDR) @mikrotik(path: "/ip/address", field: "address")
  "Network address (calculated from address and netmask)"
  network: String
  "Broadcast address (calculated from address and netmask)"
  broadcast: String
  "Interface this IP is assigned to"
  interface: Interface! @mikrotik(path: "/ip/address", field: "interface")
  "Whether this IP is disabled"
  disabled: Boolean! @mikrotik(path: "/ip/address", field: "disabled")
  "Whether this IP was dynamically assigned (via DHCP client)"
  dynamic: Boolean! @mikrotik(path: "/ip/address", field: "dynamic")
  "Whether this IP is invalid (conflicting or error state)"
  invalid: Boolean! @mikrotik(path: "/ip/address", field: "invalid")
  "User comment"
  comment: String @validate(maxLength: 255) @mikrotik(path: "/ip/address", field: "comment")
}

"""
Input for creating or updating an IP address
"""
input IpAddressInput {
  "IP address with CIDR notation (e.g., 192.168.10.1/24)"
  address: String! @validate(format: CIDR)
  "Interface ID to assign this IP to"
  interfaceId: ID!
  "User comment"
  comment: String @validate(maxLength: 255)
  "Whether this IP is disabled"
  disabled: Boolean
}

"""
Result of an IP address mutation (create, update)
"""
type IpAddressMutationResult {
  "Whether the operation succeeded"
  success: Boolean!
  "The created or updated IP address (if successful)"
  ipAddress: IpAddress
  "Configuration preview (RouterOS commands)"
  preview: ConfigPreview
  "Errors that occurred during the operation"
  errors: [MutationError!]
}

"""
Result of an IP address deletion with dependency checking
"""
type IpAddressDeleteResult {
  "Whether the deletion succeeded"
  success: Boolean!
  "Success or error message"
  message: String
  "Impact analysis for this IP address deletion"
  impactAnalysis: IpAddressImpactAnalysis
  "Errors that occurred during deletion"
  errors: [MutationError!]
}

"""
Analysis of the impact of deleting an IP address
"""
type IpAddressImpactAnalysis {
  "Whether this IP is used as a gateway by DHCP servers"
  usedByDhcpServers: [DhcpServer!]!
  "Whether this IP is referenced in firewall rules"
  usedInFirewallRules: [FirewallRule!]!
  "Whether this IP is used in NAT rules"
  usedInNatRules: [NatRule!]!
  "Number of active connections using this IP"
  activeConnections: Int!
  "Severity of the deletion"
  severity: ConfirmationSeverity!
  "Human-readable impact message"
  message: String!
  "List of consequences of deleting this IP"
  consequences: [String!]!
  "Whether the IP can be safely deleted"
  canDelete: Boolean!
}

"""
NAT rule reference type
"""
type NatRule {
  "NAT rule ID"
  id: ID!
  "Rule chain (srcnat, dstnat)"
  chain: String!
  "Action (masquerade, dst-nat, src-nat)"
  action: String!
  "Source address"
  srcAddress: String
  "Destination address"
  dstAddress: String
  "To address (for dst-nat)"
  toAddress: String
  "Whether the rule is disabled"
  disabled: Boolean!
}

"""
Result of checking IP address conflicts
"""
type IpConflictResult {
  "Whether the IP conflicts with existing assignments"
  hasConflict: Boolean!
  "List of conflicting IP addresses"
  conflicts: [IpConflict!]!
  "Human-readable message"
  message: String!
}

"""
Details about an IP address conflict
"""
type IpConflict {
  "Conflicting IP address ID"
  id: ID!
  "Conflicting IP address"
  address: String!
  "Interface where conflict exists"
  interface: Interface!
  "Type of conflict"
  conflictType: IpConflictType!
  "Explanation of the conflict"
  explanation: String!
}

"""
Type of IP address conflict
"""
enum IpConflictType {
  "Exact IP address match on different interface"
  EXACT
  "IP addresses are in overlapping subnets"
  SUBNET_OVERLAP
  "IP is the broadcast address of another subnet"
  BROADCAST
  "IP is the network address of another subnet"
  NETWORK
}

"""
Dependencies for an IP address
"""
type IpAddressDependencies {
  "IP address ID"
  ipAddressId: ID!
  "DHCP servers using this IP as gateway"
  dhcpServers: [DhcpServer!]!
  "Static routes using this IP"
  routes: [Route!]!
  "NAT rules referencing this IP"
  natRules: [NatRule!]!
  "Firewall rules referencing this IP"
  firewallRules: [FirewallRule!]!
  "Whether the IP has any dependencies"
  hasDependencies: Boolean!
}

"""
Interface traffic statistics
"""
type InterfaceStats {
  "Total bytes transmitted"
  txBytes: Size!
  "Total bytes received"
  rxBytes: Size!
  "Total packets transmitted"
  txPackets: Size!
  "Total packets received"
  rxPackets: Size!
  "Transmission errors"
  txErrors: Int!
  "Receive errors"
  rxErrors: Int!
  "Transmission drops"
  txDrops: Int!
  "Receive drops"
  rxDrops: Int!
}

"""
Historical interface statistics with time-series data
"""
type InterfaceStatsHistory {
  "Interface ID"
  interfaceId: ID!
  "Time-series data points"
  dataPoints: [StatsDataPoint!]!
  "Aggregation interval (e.g., 5m, 1h)"
  interval: Duration!
  "Start of the time range"
  startTime: DateTime!
  "End of the time range"
  endTime: DateTime!
}

"""
A single data point in interface statistics history
"""
type StatsDataPoint {
  "Timestamp of the data point"
  timestamp: DateTime!
  "Transmit rate in bytes per second"
  txBytesPerSec: Float!
  "Receive rate in bytes per second"
  rxBytesPerSec: Float!
  "Transmit rate in packets per second"
  txPacketsPerSec: Float!
  "Receive rate in packets per second"
  rxPacketsPerSec: Float!
  "Transmission errors in this interval"
  txErrors: Int!
  "Receive errors in this interval"
  rxErrors: Int!
}

"""
Input for specifying a time range
"""
input StatsTimeRangeInput {
  "Start of the time range"
  start: DateTime!
  "End of the time range"
  end: DateTime!
}

# -----------------------------------------------------------------------------
# Bridge Port VLAN Configuration
# -----------------------------------------------------------------------------

"""
VLAN configuration for a bridge port (trunk/access port setup)
"""
type BridgePortVlanConfig {
  "Bridge port ID"
  portId: ID!
  "Port VLAN ID (PVID) for untagged traffic"
  pvid: Int! @validate(min: 1, max: 4094)
  "Frame types allowed on this port"
  frameTypes: BridgePortFrameTypes!
  "Tagged VLANs allowed on this port (trunk mode)"
  taggedVlans: [Int!]! @validate(min: 1, max: 4094)
  "Untagged VLANs on this port (typically just PVID)"
  untaggedVlans: [Int!]! @validate(min: 1, max: 4094)
  "Port mode (trunk or access)"
  mode: PortMode!
}

"""
Frame types that can be admitted on a bridge port
"""
enum BridgePortFrameTypes {
  "Accept all frames (tagged and untagged)"
  ADMIT_ALL
  "Accept only untagged and priority-tagged frames"
  ADMIT_ONLY_UNTAGGED_AND_PRIORITY_TAGGED
  "Accept only VLAN-tagged frames"
  ADMIT_ONLY_VLAN_TAGGED
}

"""
Port mode for VLAN configuration
"""
enum PortMode {
  "Trunk port (carries multiple VLANs with tagging)"
  TRUNK
  "Access port (single VLAN, untagged)"
  ACCESS
}

"""
Input for configuring bridge port VLAN settings
"""
input BridgePortVlanInput {
  "Port VLAN ID (PVID) for untagged traffic"
  pvid: Int! @validate(min: 1, max: 4094)
  "Frame types allowed on this port"
  frameTypes: BridgePortFrameTypes!
  "Tagged VLANs (for trunk ports)"
  taggedVlans: [Int!] @validate(min: 1, max: 4094)
  "Port mode (trunk or access)"
  mode: PortMode!
}

# -----------------------------------------------------------------------------
# VLAN Dependencies
# -----------------------------------------------------------------------------

"""
Resources that depend on a VLAN interface
"""
type VlanDependencies {
  "VLAN interface ID"
  vlanId: ID!
  "IP addresses assigned to this VLAN"
  ipAddresses: [IpAddress!]!
  "DHCP servers using this VLAN"
  dhcpServers: [DhcpServer!]!
  "Firewall rules referencing this VLAN"
  firewallRules: [FirewallRule!]!
  "Routes using this VLAN interface"
  routes: [Route!]!
  "Number of active connections on this VLAN"
  activeConnections: Int!
  "Whether the VLAN has any dependencies"
  hasDependencies: Boolean!
}

"""
DHCP server (minimal type for dependencies)
"""
type DhcpServer {
  "DHCP server ID"
  id: ID!
  "DHCP server name"
  name: String!
  "Interface the DHCP server is bound to"
  interface: Interface!
  "Whether the DHCP server is disabled"
  disabled: Boolean!
}

"""
Firewall rule (minimal type for dependencies)
"""
type FirewallRule {
  "Firewall rule ID"
  id: ID!
  "Rule chain"
  chain: String!
  "Rule action"
  action: String!
  "Input interface filter"
  inInterface: String
  "Output interface filter"
  outInterface: String
  "Whether the rule is disabled"
  disabled: Boolean!
}

"""
Route type for static and dynamic routing
"""
type Route implements Node {
  "Route ID"
  id: ID!
  "Destination network in CIDR notation"
  destination: CIDR! @mikrotik(path: "/ip/route", field: "dst-address")
  "Gateway address"
  gateway: IPv4 @mikrotik(path: "/ip/route", field: "gateway")
  "Interface used for this route"
  interface: String @mikrotik(path: "/ip/route", field: "interface")
  "Route distance/metric (1-255)"
  distance: Int! @validate(min: 1, max: 255) @mikrotik(path: "/ip/route", field: "distance")
  "Routing mark for policy routing"
  routingMark: String @mikrotik(path: "/ip/route", field: "routing-mark")
  "Routing table name (main, vpn, etc.)"
  routingTable: String @mikrotik(path: "/ip/route", field: "routing-table")
  "Route type (static, connected, dynamic, BGP, OSPF)"
  type: RouteType!
  "Route scope"
  scope: RouteScope!
  "User comment"
  comment: String @validate(maxLength: 255) @mikrotik(path: "/ip/route", field: "comment")
  "Whether the route is active"
  active: Boolean!
  "Whether the route is disabled"
  disabled: Boolean @mikrotik(path: "/ip/route", field: "disabled")
}

"""
Route type classification
"""
enum RouteType {
  "Static route (manually configured)"
  STATIC
  "Connected route (directly connected network)"
  CONNECTED
  "Dynamic route (learned via routing protocol)"
  DYNAMIC
  "BGP route"
  BGP
  "OSPF route"
  OSPF
}

"""
Route scope
"""
enum RouteScope {
  "Global route (forwarded between interfaces)"
  GLOBAL
  "Link-local route (not forwarded)"
  LINK
  "Host-local route"
  HOST
}

"""
Input for creating or updating a route
"""
input RouteInput {
  "Destination network in CIDR notation"
  destination: CIDR!
  "Gateway address (optional if interface is provided)"
  gateway: IPv4
  "Interface used for this route (optional if gateway is provided)"
  interface: String
  "Route distance/metric (1-255, default: 1)"
  distance: Int @validate(min: 1, max: 255)
  "Routing mark for policy routing"
  routingMark: String
  "Routing table name (default: main)"
  routingTable: String
  "User comment"
  comment: String @validate(maxLength: 255)
}

"""
Result of a route mutation (create, update)
"""
type RouteMutationResult {
  "Whether the operation succeeded"
  success: Boolean!
  "Success or error message"
  message: String
  "The created or updated route (if successful)"
  route: Route
}

"""
Result of a route deletion with impact analysis
"""
type RouteDeleteResult {
  "Whether the deletion succeeded"
  success: Boolean!
  "Success or error message"
  message: String
  "Impact analysis for this route deletion"
  impactAnalysis: RouteImpactAnalysis!
}

"""
Analysis of the impact of deleting a route
"""
type RouteImpactAnalysis {
  "Whether this is the default route (0.0.0.0/0)"
  isDefaultRoute: Boolean!
  "Description of affected traffic"
  affectedTraffic: String!
  "Severity of the deletion (CRITICAL for default route, STANDARD for others)"
  severity: ConfirmationSeverity!
  "Human-readable message about the impact"
  message: String!
  "List of consequences of deleting this route"
  consequences: [String!]!
}

"""
Severity level for confirmation dialogs
"""
enum ConfirmationSeverity {
  "Critical operation requiring explicit confirmation"
  CRITICAL
  "Standard operation with brief confirmation"
  STANDARD
}

"""
Result of checking gateway reachability
"""
type GatewayReachabilityResult {
  "Whether the gateway is reachable"
  reachable: Boolean!
  "Ping latency in milliseconds (null if unreachable)"
  latency: Int
  "Interface through which gateway is reachable (null if unreachable)"
  interface: String
  "Human-readable message about reachability"
  message: String!
}

# -----------------------------------------------------------------------------
# VLAN Topology Types
# -----------------------------------------------------------------------------

"""
Node in a VLAN network topology diagram
"""
type TopologyNode {
  "Node ID"
  id: ID!
  "Node type (bridge, vlan, port)"
  type: TopologyNodeType!
  "Display label"
  label: String!
  "Sub-label (optional)"
  sublabel: String
  "Node position in the diagram"
  position: TopologyPosition!
  "Additional node data"
  data: JSON
  "Node styling"
  style: TopologyNodeStyle
}

"""
Type of topology node
"""
enum TopologyNodeType {
  "Bridge interface"
  BRIDGE
  "VLAN interface"
  VLAN
  "Physical port"
  PORT
}

"""
Position of a node in the topology
"""
type TopologyPosition {
  "X coordinate"
  x: Float!
  "Y coordinate"
  y: Float!
}

"""
Styling for topology nodes
"""
type TopologyNodeStyle {
  "Fill color (CSS color)"
  fill: String
  "Stroke color (CSS color)"
  stroke: String
  "Stroke width in pixels"
  strokeWidth: Float
}

"""
Edge connecting nodes in a topology
"""
type TopologyEdge {
  "Edge ID"
  id: ID!
  "Source node ID"
  source: ID!
  "Target node ID"
  target: ID!
  "Edge label (optional)"
  label: String
  "Additional edge data"
  data: JSON
  "Edge styling"
  style: TopologyEdgeStyle
}

"""
Styling for topology edges
"""
type TopologyEdgeStyle {
  "Stroke color (CSS color)"
  stroke: String
  "Stroke width in pixels"
  strokeWidth: Float
  "Stroke dash array (for dashed lines)"
  strokeDasharray: String
}

"""
VLAN topology data (nodes and edges)
"""
type VlanTopology {
  "Topology nodes (bridges, VLANs, ports)"
  nodes: [TopologyNode!]!
  "Topology edges (connections)"
  edges: [TopologyEdge!]!
}

# -----------------------------------------------------------------------------
# Query Extensions
# -----------------------------------------------------------------------------

extend type Query {
  """
  Get all IP addresses on a router with optional filtering
  """
  ipAddresses(
    "Router ID to query"
    routerId: ID!
    "Optional: filter by interface ID"
    interfaceId: ID
  ): [IpAddress!]! @capability(requires: ["interface"])

  """
  Get a specific IP address by ID
  """
  ipAddress(
    "Router ID"
    routerId: ID!
    "IP address ID"
    id: ID!
  ): IpAddress @capability(requires: ["interface"])

  """
  Check if an IP address conflicts with existing assignments
  """
  checkIpConflict(
    "Router ID"
    routerId: ID!
    "IP address to check (CIDR notation)"
    address: String!
    "Interface ID (optional, for scoped check)"
    interfaceId: ID
    "Exclude this IP ID from conflict check (for updates)"
    excludeId: ID
  ): IpConflictResult! @capability(requires: ["interface"])

  """
  Get dependencies for an IP address (DHCP servers, routes, etc.)
  """
  ipAddressDependencies(
    "Router ID"
    routerId: ID!
    "IP address ID"
    id: ID!
  ): IpAddressDependencies! @capability(requires: ["interface"])

  """
  Get all VLANs on a router with optional filtering
  """
  vlans(
    "Router ID to query"
    routerId: ID!
    "Optional filters"
    filter: VlanFilter
  ): [Vlan!]! @capability(requires: ["interface"])

  """
  Get a specific VLAN by ID
  """
  vlan(
    "VLAN ID"
    id: ID!
  ): Vlan @capability(requires: ["interface"])

  """
  Check if a VLAN ID is available on a parent interface
  """
  checkVlanIdAvailable(
    "Router ID"
    routerId: ID!
    "Parent interface ID"
    parentInterface: ID!
    "VLAN ID to check"
    vlanId: Int!
  ): Boolean! @capability(requires: ["interface"])

  """
  Get dependencies for a VLAN (IP addresses, DHCP, routes, etc.)
  """
  vlanDependencies(
    "VLAN ID"
    id: ID!
  ): VlanDependencies @capability(requires: ["interface"])

  """
  Get VLAN topology for a bridge
  """
  vlanTopology(
    "Router ID"
    routerId: ID!
    "Bridge ID"
    bridgeId: ID!
  ): VlanTopology @capability(requires: ["interface"])

  """
  Get all routes on a router with optional filtering
  """
  routes(
    "Router ID to query"
    routerId: ID!
    "Filter by routing table name (main, vpn, etc.)"
    table: String
    "Filter by route type (STATIC, CONNECTED, DYNAMIC, etc.)"
    type: RouteType
  ): [Route!]! @capability(requires: ["routing"])

  """
  Get a specific route by ID
  """
  route(
    "Router ID"
    routerId: ID!
    "Route ID"
    id: ID!
  ): Route @capability(requires: ["routing"])

  """
  Check if a gateway address is reachable from the router
  """
  checkGatewayReachability(
    "Router ID"
    routerId: ID!
    "Gateway IP address to check"
    gateway: IPv4!
  ): GatewayReachabilityResult! @capability(requires: ["routing"])

  """
  Get historical interface statistics for bandwidth analysis
  """
  interfaceStatsHistory(
    "Router ID"
    routerId: ID!
    "Interface ID"
    interfaceId: ID!
    "Time range for the query"
    timeRange: StatsTimeRangeInput!
    "Aggregation interval (default: 5m)"
    interval: Duration = "5m"
  ): InterfaceStatsHistory! @capability(requires: ["interface"])
}

# -----------------------------------------------------------------------------
# Mutation Extensions
# -----------------------------------------------------------------------------

extend type Mutation {
  """
  Assign a new IP address to an interface
  """
  createIpAddress(
    "Router ID"
    routerId: ID!
    "IP address input"
    input: IpAddressInput!
  ): IpAddressMutationResult! @capability(requires: ["interface"])

  """
  Update an existing IP address
  """
  updateIpAddress(
    "Router ID"
    routerId: ID!
    "IP address ID"
    id: ID!
    "Updated IP address data"
    input: IpAddressInput!
  ): IpAddressMutationResult! @capability(requires: ["interface"])

  """
  Remove an IP address from an interface
  """
  deleteIpAddress(
    "Router ID"
    routerId: ID!
    "IP address ID to delete"
    id: ID!
  ): IpAddressDeleteResult! @capability(requires: ["interface"])

  """
  Create a new VLAN interface
  """
  createVlan(
    "Router ID"
    routerId: ID!
    "VLAN input data"
    input: VlanInput!
  ): VlanMutationResult! @capability(requires: ["interface"])

  """
  Update an existing VLAN interface
  """
  updateVlan(
    "VLAN ID"
    id: ID!
    "Updated VLAN data"
    input: VlanInput!
  ): VlanMutationResult! @capability(requires: ["interface"])

  """
  Delete a VLAN interface
  """
  deleteVlan(
    "VLAN ID to delete"
    id: ID!
  ): DeleteResult! @capability(requires: ["interface"])

  """
  Configure VLAN settings on a bridge port (trunk/access)
  """
  configureBridgePortVlan(
    "Router ID"
    routerId: ID!
    "Bridge port ID"
    portId: ID!
    "VLAN configuration"
    input: BridgePortVlanInput!
  ): VlanMutationResult! @capability(requires: ["interface"])

  """
  Create a new static route
  """
  createRoute(
    "Router ID"
    routerId: ID!
    "Route input data"
    input: RouteInput!
  ): RouteMutationResult! @capability(requires: ["routing"])

  """
  Update an existing route
  """
  updateRoute(
    "Router ID"
    routerId: ID!
    "Route ID"
    id: ID!
    "Updated route data"
    input: RouteInput!
  ): RouteMutationResult! @capability(requires: ["routing"])

  """
  Delete a route with impact analysis
  """
  deleteRoute(
    "Router ID"
    routerId: ID!
    "Route ID to delete"
    id: ID!
  ): RouteDeleteResult! @capability(requires: ["routing"])
}

# -----------------------------------------------------------------------------
# Subscription Extensions
# -----------------------------------------------------------------------------

extend type Subscription {
  """
  Subscribe to IP address changes (create, update, delete)
  """
  ipAddressChanged(
    "Router ID to monitor"
    routerId: ID!
  ): IpAddressChangeEvent! @capability(requires: ["interface"])

  """
  Subscribe to VLAN interface changes (create, update, delete)
  """
  vlanChanged(
    "Router ID to monitor"
    routerId: ID!
  ): Vlan! @capability(requires: ["interface"])

  """
  Subscribe to real-time interface statistics updates
  """
  interfaceStatsUpdated(
    "Router ID to monitor"
    routerId: ID!
    "Interface ID to monitor"
    interfaceId: ID!
    "Polling interval (default: 5s, minimum: 1s)"
    interval: Duration = "5s"
  ): InterfaceStats! @capability(requires: ["interface"])
}

"""
Event emitted when an IP address changes
"""
type IpAddressChangeEvent {
  "Type of change (CREATED, UPDATED, DELETED)"
  changeType: ChangeType!
  "The IP address that changed"
  ipAddress: IpAddress
  "IP address ID (for deletions)"
  ipAddressId: ID!
  "Timestamp of the change"
  timestamp: DateTime!
}

# Note: ChangeType enum is defined in schema.graphql
`, BuiltIn: false},
	{Name: "../../../schema/bridge.graphql", Input: `# =============================================================================
# Bridge Configuration Schema
# =============================================================================
# Reference: Epic 6 - Network Management
# RouterOS Commands: /interface/bridge/*
# Story: NAS-6.6 - Implement Bridge Configuration
# =============================================================================

# -----------------------------------------------------------------------------
# Enums
# -----------------------------------------------------------------------------

enum StpProtocol {
  NONE
  STP
  RSTP
  MSTP
}

enum FrameTypes {
  ADMIT_ALL
  ADMIT_ONLY_UNTAGGED_AND_PRIORITY
  ADMIT_ONLY_VLAN_TAGGED
}

enum StpPortRole {
  ROOT
  DESIGNATED
  ALTERNATE
  BACKUP
  DISABLED
}

enum StpPortState {
  DISABLED
  BLOCKING
  LISTENING
  LEARNING
  FORWARDING
}

# -----------------------------------------------------------------------------
# Types
# -----------------------------------------------------------------------------

type Bridge implements Node {
  id: ID!
  name: String!
  comment: String @mikrotik(path: "/interface/bridge", field: "comment")
  disabled: Boolean! @mikrotik(path: "/interface/bridge", field: "disabled")
  running: Boolean!
  macAddress: MAC @mikrotik(path: "/interface/bridge", field: "mac-address")
  mtu: Int @validate(min: 68, max: 65535) @mikrotik(path: "/interface/bridge", field: "mtu")

  # STP Configuration
  protocol: StpProtocol! @mikrotik(path: "/interface/bridge", field: "protocol")
  priority: Int @validate(min: 0, max: 61440) @mikrotik(path: "/interface/bridge", field: "priority")

  # VLAN Configuration
  vlanFiltering: Boolean! @mikrotik(path: "/interface/bridge", field: "vlan-filtering")
  pvid: Int @validate(min: 1, max: 4094) @mikrotik(path: "/interface/bridge", field: "pvid")

  # Relationships
  ports: [BridgePort!]!
  vlans: [BridgeVlan!]!
  ipAddresses: [IpAddress!]!

  # STP Status (real-time)
  stpStatus: BridgeStpStatus

  # Impact analysis for deletion
  dependentDhcpServers: [DhcpServer!]!
  dependentRoutes: [Route!]!
}

type BridgePort implements Node {
  id: ID!
  bridge: Bridge!
  interface: Interface!

  # VLAN Configuration
  pvid: Int! @validate(min: 1, max: 4094) @mikrotik(path: "/interface/bridge/port", field: "pvid")
  frameTypes: FrameTypes! @mikrotik(path: "/interface/bridge/port", field: "frame-types")
  ingressFiltering: Boolean! @mikrotik(path: "/interface/bridge/port", field: "ingress-filtering")
  taggedVlans: [Int!]!
  untaggedVlans: [Int!]!

  # STP Per-Port Status
  role: StpPortRole!
  state: StpPortState!
  pathCost: Int!
  edge: Boolean! @mikrotik(path: "/interface/bridge/port", field: "edge")
}

type BridgeStpStatus {
  rootBridge: Boolean!
  rootBridgeId: String
  rootPort: String
  rootPathCost: Int!
  topologyChangeCount: Int!
  lastTopologyChange: DateTime
}

type BridgeVlan {
  uuid: ID!
  bridge: Bridge!
  vlanId: Int! @validate(min: 1, max: 4094)
  taggedPorts: [BridgePort!]!
  untaggedPorts: [BridgePort!]!
}

# -----------------------------------------------------------------------------
# Input Types
# -----------------------------------------------------------------------------

input CreateBridgeInput {
  name: String! @validate(minLength: 1, maxLength: 100, pattern: "^[a-zA-Z][a-zA-Z0-9_-]*$")
  comment: String
  protocol: StpProtocol
  priority: Int @validate(min: 0, max: 61440)
  vlanFiltering: Boolean
  pvid: Int @validate(min: 1, max: 4094)
  mtu: Int @validate(min: 68, max: 65535)
}

input UpdateBridgeInput {
  comment: String
  protocol: StpProtocol
  priority: Int @validate(min: 0, max: 61440)
  vlanFiltering: Boolean
  pvid: Int @validate(min: 1, max: 4094)
  mtu: Int @validate(min: 68, max: 65535)
  disabled: Boolean
}

input AddBridgePortInput {
  interfaceId: ID!
  pvid: Int @validate(min: 1, max: 4094)
  frameTypes: FrameTypes
  ingressFiltering: Boolean
}

input UpdateBridgePortInput {
  pvid: Int @validate(min: 1, max: 4094)
  frameTypes: FrameTypes
  ingressFiltering: Boolean
  taggedVlans: [Int!]
  untaggedVlans: [Int!]
  edge: Boolean
  pathCost: Int @validate(min: 1, max: 65535)
}

input CreateBridgeVlanInput {
  vlanId: Int! @validate(min: 1, max: 4094)
  taggedPortIds: [ID!]
  untaggedPortIds: [ID!]
}

# -----------------------------------------------------------------------------
# Mutation Results
# -----------------------------------------------------------------------------

type BridgeMutationResult {
  success: Boolean!
  bridge: Bridge
  errors: [MutationError!]
  "Previous state for undo functionality"
  previousState: JSON
  "Unique operation ID for undo within 10-second window"
  operationId: ID
}

type BridgePortMutationResult {
  success: Boolean!
  port: BridgePort
  errors: [MutationError!]
  previousState: JSON
  operationId: ID
}

type BridgeVlanMutationResult {
  success: Boolean!
  vlan: BridgeVlan
  errors: [MutationError!]
}

# -----------------------------------------------------------------------------
# Queries
# -----------------------------------------------------------------------------

extend type Query {
  "List all bridges on a router"
  bridges(routerId: ID!): [Bridge!]!

  "Get a single bridge by UUID"
  bridge(uuid: ID!): Bridge

  "Get bridge ports"
  bridgePorts(bridgeId: ID!): [BridgePort!]!

  "Get bridge VLANs"
  bridgeVlans(bridgeId: ID!): [BridgeVlan!]!

  "Get interfaces available to add to a bridge (not already in any bridge)"
  availableInterfacesForBridge(routerId: ID!): [Interface!]!
}

# -----------------------------------------------------------------------------
# Mutations
# -----------------------------------------------------------------------------

extend type Mutation {
  "Create a new bridge"
  createBridge(routerId: ID!, input: CreateBridgeInput!): BridgeMutationResult!

  "Update an existing bridge"
  updateBridge(uuid: ID!, input: UpdateBridgeInput!): BridgeMutationResult!

  "Delete a bridge"
  deleteBridge(uuid: ID!): DeleteResult!

  "Undo a bridge operation (within 10-second window)"
  undoBridgeOperation(operationId: ID!): BridgeMutationResult!

  "Add a port to a bridge"
  addBridgePort(bridgeId: ID!, input: AddBridgePortInput!): BridgePortMutationResult!

  "Update bridge port settings"
  updateBridgePort(portId: ID!, input: UpdateBridgePortInput!): BridgePortMutationResult!

  "Remove a port from a bridge"
  removeBridgePort(portId: ID!): DeleteResult!

  "Create a bridge VLAN entry"
  createBridgeVlan(bridgeId: ID!, input: CreateBridgeVlanInput!): BridgeVlanMutationResult!

  "Delete a bridge VLAN entry"
  deleteBridgeVlan(uuid: ID!): DeleteResult!
}

# -----------------------------------------------------------------------------
# Subscriptions
# -----------------------------------------------------------------------------

extend type Subscription {
  "Subscribe to STP status changes for a bridge"
  bridgeStpStatusChanged(bridgeId: ID!): BridgeStpStatus!

  "Subscribe to bridge port changes"
  bridgePortsChanged(bridgeId: ID!): [BridgePort!]!
}
`, BuiltIn: false},
	{Name: "../../../schema/wan.graphql", Input: `# =============================================================================
# WAN Link Configuration GraphQL Schema
# =============================================================================
# WAN interface types, health monitoring, and connection management
# Extends base Interface type from schema.graphql
# =============================================================================

# -----------------------------------------------------------------------------
# WAN Interface Types
# -----------------------------------------------------------------------------

"""
WAN interface status with connection details
"""
type WANInterface implements Node {
  "Unique identifier"
  id: ID!

  "Underlying network interface"
  interface: Interface! @mikrotik(path: "/interface", field: "name")

  "WAN connection type"
  type: WANConnectionType!

  "Current connection status"
  status: WANStatus!

  "Public IP address (if connected)"
  publicIP: IPv4 @mikrotik(path: "/ip/address", field: "address")

  "Gateway IP address"
  gateway: IPv4

  "Primary DNS server"
  primaryDNS: IPv4

  "Secondary DNS server"
  secondaryDNS: IPv4

  "Connection uptime"
  uptime: Duration

  "Last connection time"
  lastConnected: DateTime

  "Health check status"
  health: WANHealthStatus

  "DHCP client configuration (if type is DHCP)"
  dhcpClient: DhcpClient

  "PPPoE client configuration (if type is PPPOE)"
  pppoeClient: PppoeClient

  "Static IP configuration (if type is STATIC)"
  staticConfig: StaticIPConfig

  "LTE modem configuration (if type is LTE)"
  lteModem: LteModem

  "Whether this is the default route"
  isDefaultRoute: Boolean!

  "Traffic statistics"
  statistics: InterfaceStats
}

"""
WAN connection type classification
"""
enum WANConnectionType {
  "DHCP client (dynamic IP)"
  DHCP
  "PPPoE dial-up connection"
  PPPOE
  "Static IP configuration"
  STATIC
  "LTE/cellular connection"
  LTE
  "Not configured"
  NONE
}

"""
WAN connection status
"""
enum WANStatus {
  "Connected and online"
  CONNECTED
  "Connecting/authenticating"
  CONNECTING
  "Disconnected"
  DISCONNECTED
  "Connection failed"
  ERROR
  "Disabled"
  DISABLED
}

# -----------------------------------------------------------------------------
# DHCP Client Types
# -----------------------------------------------------------------------------

"""
DHCP client configuration for dynamic WAN IP
"""
type DhcpClient implements Node {
  "Unique identifier"
  id: ID!

  "Interface name"
  interface: String! @mikrotik(path: "/ip/dhcp-client", field: "interface")

  "Whether DHCP client is disabled"
  disabled: Boolean! @mikrotik(path: "/ip/dhcp-client", field: "disabled")

  "Add default route from DHCP"
  addDefaultRoute: Boolean! @mikrotik(path: "/ip/dhcp-client", field: "add-default-route")

  "Use DNS servers from DHCP"
  usePeerDNS: Boolean! @mikrotik(path: "/ip/dhcp-client", field: "use-peer-dns")

  "Use NTP servers from DHCP"
  usePeerNTP: Boolean! @mikrotik(path: "/ip/dhcp-client", field: "use-peer-ntp")

  "Current DHCP status"
  status: String! @mikrotik(path: "/ip/dhcp-client", field: "status")

  "Assigned IP address"
  address: IPv4 @mikrotik(path: "/ip/dhcp-client", field: "address")

  "DHCP server address"
  dhcpServer: IPv4 @mikrotik(path: "/ip/dhcp-client", field: "dhcp-server")

  "Gateway from DHCP"
  gateway: IPv4 @mikrotik(path: "/ip/dhcp-client", field: "gateway")

  "Lease expiry time"
  expiresAfter: Duration @mikrotik(path: "/ip/dhcp-client", field: "expires-after")

  "User comment"
  comment: String @mikrotik(path: "/ip/dhcp-client", field: "comment")
}

"""
Input for creating/updating DHCP client
"""
input DhcpClientInput {
  "Interface to enable DHCP client on"
  interface: String! @validate(minLength: 1, maxLength: 100)

  "Add default route (default: true)"
  addDefaultRoute: Boolean

  "Use peer DNS (default: true)"
  usePeerDNS: Boolean

  "Use peer NTP (default: true)"
  usePeerNTP: Boolean

  "User comment"
  comment: String @validate(maxLength: 255)
}

# -----------------------------------------------------------------------------
# PPPoE Client Types
# -----------------------------------------------------------------------------

"""
PPPoE client configuration for dial-up WAN
"""
type PppoeClient implements Node {
  "Unique identifier"
  id: ID!

  "PPPoE interface name"
  name: String! @mikrotik(path: "/interface/pppoe-client", field: "name")

  "Underlying interface (ethernet/bridge)"
  interface: String! @mikrotik(path: "/interface/pppoe-client", field: "interface")

  "Whether PPPoE is disabled"
  disabled: Boolean! @mikrotik(path: "/interface/pppoe-client", field: "disabled")

  "Username for authentication"
  username: String! @mikrotik(path: "/interface/pppoe-client", field: "user")

  "Service name (optional)"
  serviceName: String @mikrotik(path: "/interface/pppoe-client", field: "service-name")

  "Add default route"
  addDefaultRoute: Boolean! @mikrotik(path: "/interface/pppoe-client", field: "add-default-route")

  "Use peer DNS"
  usePeerDNS: Boolean! @mikrotik(path: "/interface/pppoe-client", field: "use-peer-dns")

  "Current connection status"
  running: Boolean! @mikrotik(path: "/interface/pppoe-client", field: "running")

  "MTU setting"
  mtu: Int @mikrotik(path: "/interface/pppoe-client", field: "mtu")

  "MRU setting"
  mru: Int @mikrotik(path: "/interface/pppoe-client", field: "mru")

  "User comment"
  comment: String @mikrotik(path: "/interface/pppoe-client", field: "comment")
}

"""
Input for creating/updating PPPoE client
"""
input PppoeClientInput {
  "PPPoE interface name"
  name: String! @validate(minLength: 1, maxLength: 100, pattern: "^[a-zA-Z0-9_-]+$")

  "Physical interface (ether1, bridge, etc.)"
  interface: String! @validate(minLength: 1, maxLength: 100)

  "Username for ISP authentication"
  username: String! @validate(minLength: 1, maxLength: 128)

  "Password for ISP authentication"
  password: String! @validate(minLength: 1, maxLength: 128)

  "Service name (optional, ISP-specific)"
  serviceName: String @validate(maxLength: 100)

  "Add default route (default: true)"
  addDefaultRoute: Boolean

  "Use peer DNS (default: true)"
  usePeerDNS: Boolean

  "MTU (default: auto)"
  mtu: Int @validate(min: 576, max: 1500)

  "MRU (default: auto)"
  mru: Int @validate(min: 576, max: 1500)

  "User comment"
  comment: String @validate(maxLength: 255)
}

# -----------------------------------------------------------------------------
# Static IP Types
# -----------------------------------------------------------------------------

"""
Static IP WAN configuration
"""
type StaticIPConfig implements Node {
  "Unique identifier"
  id: ID!

  "Interface name"
  interface: String!

  "Static IP address with CIDR"
  address: CIDR! @mikrotik(path: "/ip/address", field: "address")

  "Gateway IP address"
  gateway: IPv4! @mikrotik(path: "/ip/route", field: "gateway")

  "Primary DNS server"
  primaryDNS: IPv4

  "Secondary DNS server"
  secondaryDNS: IPv4

  "User comment"
  comment: String
}

"""
Input for configuring static IP WAN
"""
input StaticIPInput {
  "Interface to configure"
  interface: String! @validate(minLength: 1, maxLength: 100)

  "Static IP address with CIDR (e.g., 203.0.113.5/30)"
  address: CIDR!

  "Gateway IP address"
  gateway: IPv4!

  "Primary DNS server"
  primaryDNS: IPv4

  "Secondary DNS server"
  secondaryDNS: IPv4

  "User comment"
  comment: String @validate(maxLength: 255)
}

# -----------------------------------------------------------------------------
# LTE Modem Types
# -----------------------------------------------------------------------------

"""
LTE/cellular modem configuration
"""
type LteModem implements Node {
  "Unique identifier"
  id: ID!

  "LTE interface name"
  name: String! @mikrotik(path: "/interface/lte", field: "name")

  "APN (Access Point Name)"
  apn: String! @mikrotik(path: "/interface/lte", field: "apn")

  "Signal strength (RSSI in dBm)"
  signalStrength: Int @mikrotik(path: "/interface/lte", field: "rssi")

  "Connection status"
  running: Boolean! @mikrotik(path: "/interface/lte", field: "running")

  "Operator name"
  operator: String @mikrotik(path: "/interface/lte", field: "current-operator")

  "Network type (LTE, 3G, etc.)"
  networkType: String @mikrotik(path: "/interface/lte", field: "current-cellid")

  "PIN code configured"
  pinConfigured: Boolean!

  "User comment"
  comment: String @mikrotik(path: "/interface/lte", field: "comment")
}

"""
Input for configuring LTE modem
"""
input LteModemInput {
  "LTE interface name"
  name: String! @validate(minLength: 1, maxLength: 100)

  "APN (Access Point Name)"
  apn: String! @validate(minLength: 1, maxLength: 100)

  "PIN code (optional, for SIM card)"
  pin: String @validate(minLength: 4, maxLength: 8, pattern: "^[0-9]+$")

  "User comment"
  comment: String @validate(maxLength: 255)
}

# -----------------------------------------------------------------------------
# Health Monitoring Types
# -----------------------------------------------------------------------------

"""
WAN health check status
"""
type WANHealthStatus {
  "Overall health status"
  status: HealthCheckStatus!

  "Target host being monitored"
  target: String!

  "Check interval"
  interval: Duration!

  "Current latency (if reachable)"
  latency: Int

  "Packet loss percentage (0-100)"
  packetLoss: Int!

  "Consecutive successful checks"
  successCount: Int!

  "Consecutive failed checks"
  failureCount: Int!

  "Last check timestamp"
  lastCheck: DateTime!

  "Whether health check is enabled"
  enabled: Boolean!
}

"""
Health check status
"""
enum HealthCheckStatus {
  "Target is reachable (healthy)"
  HEALTHY
  "Target is unreachable (unhealthy)"
  UNHEALTHY
  "Health check is disabled"
  DISABLED
  "Health check is starting"
  UNKNOWN
}

"""
Input for configuring WAN health check
"""
input WANHealthCheckInput {
  "Target host to ping (IP or hostname)"
  target: String! @validate(minLength: 1, maxLength: 255)

  "Check interval in seconds"
  interval: Int! @validate(min: 5, max: 300)

  "Enable health check"
  enabled: Boolean!
}

# -----------------------------------------------------------------------------
# Connection History Types
# -----------------------------------------------------------------------------

"""
WAN connection history entry
"""
type WANConnectionEvent {
  "Event ID"
  id: ID!

  "WAN interface ID"
  wanInterfaceId: ID!

  "Event type"
  eventType: WANEventType!

  "Event timestamp"
  timestamp: DateTime!

  "Public IP at the time (if applicable)"
  publicIP: IPv4

  "Gateway IP"
  gateway: IPv4

  "Reason/error message (if applicable)"
  reason: String

  "Connection duration (for disconnect events)"
  duration: Duration
}

"""
WAN event types for history tracking
"""
enum WANEventType {
  "Connection established"
  CONNECTED
  "Connection lost"
  DISCONNECTED
  "Authentication failed"
  AUTH_FAILED
  "IP address changed"
  IP_CHANGED
  "Gateway changed"
  GATEWAY_CHANGED
  "Health check failed"
  HEALTH_FAILED
  "Health check recovered"
  HEALTH_RECOVERED
}

"""
Connection history pagination
"""
type WANConnectionEventConnection implements Connection {
  edges: [WANConnectionEventEdge!]!
  pageInfo: PageInfo!
  totalCount: Int
}

type WANConnectionEventEdge implements Edge {
  node: WANConnectionEvent!
  cursor: String!
}

# -----------------------------------------------------------------------------
# Mutation Results
# -----------------------------------------------------------------------------

"""
Result of WAN configuration mutation
"""
type WANMutationResult {
  "Whether the operation succeeded"
  success: Boolean!

  "The configured WAN interface"
  wanInterface: WANInterface

  "Configuration preview (RouterOS commands)"
  preview: ConfigPreview

  "Errors that occurred"
  errors: [MutationError!]
}

# -----------------------------------------------------------------------------
# Query Extensions
# -----------------------------------------------------------------------------

extend type Query {
  """
  Get all WAN interfaces on a router
  """
  wanInterfaces(
    "Router ID"
    routerId: ID!
  ): [WANInterface!]! @capability(requires: ["interface"])

  """
  Get a specific WAN interface by ID
  """
  wanInterface(
    "Router ID"
    routerId: ID!
    "WAN interface ID"
    id: ID!
  ): WANInterface @capability(requires: ["interface"])

  """
  Get connection history for a WAN interface
  """
  wanConnectionHistory(
    "Router ID"
    routerId: ID!
    "WAN interface ID"
    wanInterfaceId: ID!
    "Pagination"
    pagination: PaginationInput
  ): WANConnectionEventConnection! @capability(requires: ["interface"])
}

# -----------------------------------------------------------------------------
# Mutation Extensions
# -----------------------------------------------------------------------------

extend type Mutation {
  """
  Configure DHCP client on a WAN interface
  """
  configureDhcpWAN(
    "Router ID"
    routerId: ID!
    "DHCP configuration"
    input: DhcpClientInput!
  ): WANMutationResult! @capability(requires: ["interface"])

  """
  Configure PPPoE client on a WAN interface
  """
  configurePppoeWAN(
    "Router ID"
    routerId: ID!
    "PPPoE configuration"
    input: PppoeClientInput!
  ): WANMutationResult! @capability(requires: ["interface"])

  """
  Configure static IP on a WAN interface
  """
  configureStaticWAN(
    "Router ID"
    routerId: ID!
    "Static IP configuration"
    input: StaticIPInput!
  ): WANMutationResult! @capability(requires: ["interface"])

  """
  Configure LTE modem
  """
  configureLteWAN(
    "Router ID"
    routerId: ID!
    "LTE configuration"
    input: LteModemInput!
  ): WANMutationResult! @capability(requires: ["interface"])

  """
  Configure health check for WAN interface
  """
  configureWANHealthCheck(
    "Router ID"
    routerId: ID!
    "WAN interface ID"
    wanInterfaceId: ID!
    "Health check configuration"
    input: WANHealthCheckInput!
  ): WANMutationResult! @capability(requires: ["interface"])

  """
  Delete WAN configuration (revert to unconfigured)
  """
  deleteWANConfiguration(
    "Router ID"
    routerId: ID!
    "WAN interface ID"
    wanInterfaceId: ID!
  ): DeleteResult! @capability(requires: ["interface"])
}

# -----------------------------------------------------------------------------
# Subscription Extensions
# -----------------------------------------------------------------------------

extend type Subscription {
  """
  Subscribe to WAN status changes
  """
  wanStatusChanged(
    "Router ID"
    routerId: ID!
    "Optional WAN interface ID filter"
    wanInterfaceId: ID
  ): WANInterface! @capability(requires: ["interface"])

  """
  Subscribe to WAN health check updates
  """
  wanHealthChanged(
    "Router ID"
    routerId: ID!
    "WAN interface ID"
    wanInterfaceId: ID!
  ): WANHealthStatus! @capability(requires: ["interface"])
}
`, BuiltIn: false},
}
var parsedSchema = gqlparser.MustLoadSchema(sources...)

// endregion ************************** generated!.gotpl **************************

// region    ***************************** args.gotpl *****************************

func (ec *executionContext) dir_auth_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["requires"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("requires"))
		arg0, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["requires"] = arg0
	return args, nil
}

func (ec *executionContext) dir_capability_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []string
	if tmp, ok := rawArgs["requires"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("requires"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["requires"] = arg0
	return args, nil
}

func (ec *executionContext) dir_validate_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *int
	if tmp, ok := rawArgs["min"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("min"))
		arg0, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["min"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["max"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("max"))
		arg1, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["max"] = arg1
	var arg2 *int
	if tmp, ok := rawArgs["minLength"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("minLength"))
		arg2, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["minLength"] = arg2
	var arg3 *int
	if tmp, ok := rawArgs["maxLength"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("maxLength"))
		arg3, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["maxLength"] = arg3
	var arg4 *string
	if tmp, ok := rawArgs["pattern"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pattern"))
		arg4, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["pattern"] = arg4
	var arg5 *model.ValidateFormat
	if tmp, ok := rawArgs["format"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("format"))
		arg5, err = ec.unmarshalOValidateFormat2backendgraphmodelValidateFormat(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["format"] = arg5
	return args, nil
}

func (ec *executionContext) field_AlertRule_alerts_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *bool
	if tmp, ok := rawArgs["acknowledged"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("acknowledged"))
		arg0, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["acknowledged"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["limit"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("limit"))
		arg1, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_acknowledgeAlert_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["alertId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("alertId"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["alertId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_acknowledgeAlerts_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []string
	if tmp, ok := rawArgs["alertIds"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("alertIds"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["alertIds"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_addBridgePort_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["bridgeId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("bridgeId"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["bridgeId"] = arg0
	var arg1 model.AddBridgePortInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg1, err = ec.unmarshalNAddBridgePortInput2backendgraphmodelAddBridgePortInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_addChangeSetItem_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["changeSetId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("changeSetId"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["changeSetId"] = arg0
	var arg1 model.ChangeSetItemInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg1, err = ec.unmarshalNChangeSetItemInput2backendgraphmodelChangeSetItemInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_addRouter_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.AddRouterInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNAddRouterInput2backendgraphmodelAddRouterInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_applyChangeSet_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["changeSetId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("changeSetId"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["changeSetId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_applyResource_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["routerId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("routerId"))
		arg1, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["routerId"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_applyTroubleshootFix_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["sessionId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sessionId"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["sessionId"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["issueCode"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("issueCode"))
		arg1, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["issueCode"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_archiveResource_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["routerId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("routerId"))
		arg1, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["routerId"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_batchInterfaceOperation_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["routerId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("routerId"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["routerId"] = arg0
	var arg1 model.BatchInterfaceInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg1, err = ec.unmarshalNBatchInterfaceInput2backendgraphmodelBatchInterfaceInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_cancelChangeSet_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["changeSetId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("changeSetId"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["changeSetId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_cancelScan_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["taskId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("taskId"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["taskId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_cancelTraceroute_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["jobId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("jobId"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["jobId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_cancelTroubleshoot_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["sessionId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sessionId"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["sessionId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_changePassword_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["currentPassword"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("currentPassword"))
		directive0 := func(ctx context.Context) (interface{}, error) { return ec.unmarshalNString2string(ctx, tmp) }
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Sensitive == nil {
				return nil, errors.New("directive sensitive is not implemented")
			}
			return ec.directives.Sensitive(ctx, rawArgs, directive0)
		}

		tmp, err = directive1(ctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if data, ok := tmp.(string); ok {
			arg0 = data
		} else {
			return nil, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp))
		}
	}
	args["currentPassword"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["newPassword"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("newPassword"))
		directive0 := func(ctx context.Context) (interface{}, error) { return ec.unmarshalNString2string(ctx, tmp) }
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Sensitive == nil {
				return nil, errors.New("directive sensitive is not implemented")
			}
			return ec.directives.Sensitive(ctx, rawArgs, directive0)
		}

		tmp, err = directive1(ctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if data, ok := tmp.(string); ok {
			arg1 = data
		} else {
			return nil, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp))
		}
	}
	args["newPassword"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_checkRouterHealth_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["routerId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("routerId"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["routerId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_configureBridgePortVlan_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["routerId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("routerId"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["routerId"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["portId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("portId"))
		arg1, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["portId"] = arg1
	var arg2 model.BridgePortVlanInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg2, err = ec.unmarshalNBridgePortVlanInput2backendgraphmodelBridgePortVlanInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg2
	return args, nil
}

func (ec *executionContext) field_Mutation_configureDhcpWAN_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["routerId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("routerId"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["routerId"] = arg0
	var arg1 model.DhcpClientInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg1, err = ec.unmarshalNDhcpClientInput2backendgraphmodelDhcpClientInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_configureLteWAN_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["routerId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("routerId"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["routerId"] = arg0
	var arg1 model.LteModemInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg1, err = ec.unmarshalNLteModemInput2backendgraphmodelLteModemInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_configurePppoeWAN_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["routerId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("routerId"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["routerId"] = arg0
	var arg1 model.PppoeClientInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg1, err = ec.unmarshalNPppoeClientInput2backendgraphmodelPppoeClientInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_configureStaticWAN_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["routerId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("routerId"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["routerId"] = arg0
	var arg1 model.StaticIPInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg1, err = ec.unmarshalNStaticIPInput2backendgraphmodelStaticIPInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_configureWANHealthCheck_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["routerId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("routerId"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["routerId"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["wanInterfaceId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("wanInterfaceId"))
		arg1, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["wanInterfaceId"] = arg1
	var arg2 model.WANHealthCheckInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg2, err = ec.unmarshalNWANHealthCheckInput2backendgraphmodelWANHealthCheckInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg2
	return args, nil
}

func (ec *executionContext) field_Mutation_connectRouter_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_createAlertRule_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.CreateAlertRuleInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNCreateAlertRuleInput2backendgraphmodelCreateAlertRuleInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_createBridgeVlan_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["bridgeId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("bridgeId"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["bridgeId"] = arg0
	var arg1 model.CreateBridgeVlanInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg1, err = ec.unmarshalNCreateBridgeVlanInput2backendgraphmodelCreateBridgeVlanInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_createBridge_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["routerId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("routerId"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["routerId"] = arg0
	var arg1 model.CreateBridgeInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg1, err = ec.unmarshalNCreateBridgeInput2backendgraphmodelCreateBridgeInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_createChangeSet_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.CreateChangeSetInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNCreateChangeSetInput2backendgraphmodelCreateChangeSetInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_createIpAddress_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["routerId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("routerId"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["routerId"] = arg0
	var arg1 model.IPAddressInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg1, err = ec.unmarshalNIpAddressInput2backendgraphmodelIPAddressInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_createResource_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.CreateResourceInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNCreateResourceInput2backendgraphmodelCreateResourceInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_createRoute_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["routerId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("routerId"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["routerId"] = arg0
	var arg1 model.RouteInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg1, err = ec.unmarshalNRouteInput2backendgraphmodelRouteInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_createRouter_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.CreateRouterInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNCreateRouterInput2backendgraphmodelCreateRouterInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_createVlan_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["routerId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("routerId"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["routerId"] = arg0
	var arg1 model.VlanInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg1, err = ec.unmarshalNVlanInput2backendgraphmodelVlanInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_deleteAlertRule_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_deleteBridgeVlan_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["uuid"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("uuid"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["uuid"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_deleteBridge_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["uuid"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("uuid"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["uuid"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_deleteChangeSet_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["changeSetId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("changeSetId"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["changeSetId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_deleteIpAddress_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["routerId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("routerId"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["routerId"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg1, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_deleteResource_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["routerId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("routerId"))
		arg1, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["routerId"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_deleteRoute_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["routerId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("routerId"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["routerId"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg1, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_deleteRouter_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_deleteVlan_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_deleteWANConfiguration_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["routerId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("routerId"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["routerId"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["wanInterfaceId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("wanInterfaceId"))
		arg1, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["wanInterfaceId"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_deprecateResource_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["routerId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("routerId"))
		arg1, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["routerId"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_disableInterface_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["routerId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("routerId"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["routerId"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["interfaceId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("interfaceId"))
		arg1, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["interfaceId"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_disconnectRouter_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_enableInterface_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["routerId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("routerId"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["routerId"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["interfaceId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("interfaceId"))
		arg1, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["interfaceId"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_exportRouterConfig_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.ExportConfigInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNExportConfigInput2backendgraphmodelExportConfigInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_login_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["username"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("username"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["username"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["password"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("password"))
		directive0 := func(ctx context.Context) (interface{}, error) { return ec.unmarshalNString2string(ctx, tmp) }
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Sensitive == nil {
				return nil, errors.New("directive sensitive is not implemented")
			}
			return ec.directives.Sensitive(ctx, rawArgs, directive0)
		}

		tmp, err = directive1(ctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if data, ok := tmp.(string); ok {
			arg1 = data
		} else {
			return nil, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp))
		}
	}
	args["password"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_reconnectRouter_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["routerId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("routerId"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["routerId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_refreshCapabilities_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["routerId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("routerId"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["routerId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_removeBridgePort_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["portId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("portId"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["portId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_removeChangeSetItem_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["changeSetId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("changeSetId"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["changeSetId"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["itemId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("itemId"))
		arg1, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["itemId"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_resetCircuitBreaker_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["routerId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("routerId"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["routerId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_revokeAllSessions_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["userId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userId"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["userId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_revokeSession_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["sessionId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sessionId"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["sessionId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_rollbackChangeSet_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["changeSetId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("changeSetId"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["changeSetId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_runDiagnostics_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["routerId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("routerId"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["routerId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_runDnsLookup_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.DNSLookupInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNDnsLookupInput2backendgraphmodelDNSLookupInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_runTraceroute_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["deviceId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deviceId"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["deviceId"] = arg0
	var arg1 model.TracerouteInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg1, err = ec.unmarshalNTracerouteInput2backendgraphmodelTracerouteInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_runTroubleshootStep_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["sessionId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sessionId"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["sessionId"] = arg0
	var arg1 model.TroubleshootStepType
	if tmp, ok := rawArgs["stepType"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("stepType"))
		arg1, err = ec.unmarshalNTroubleshootStepType2backendgraphmodelTroubleshootStepType(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["stepType"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_scanNetwork_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.ScanNetworkInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNScanNetworkInput2backendgraphmodelScanNetworkInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_setPreferredProtocol_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["routerId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("routerId"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["routerId"] = arg0
	var arg1 model.Protocol
	if tmp, ok := rawArgs["protocol"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("protocol"))
		arg1, err = ec.unmarshalNProtocol2backendgraphmodelProtocol(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["protocol"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_startTroubleshoot_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["routerId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("routerId"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["routerId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_testNotificationChannel_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["channel"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("channel"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["channel"] = arg0
	var arg1 map[string]interface{}
	if tmp, ok := rawArgs["config"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("config"))
		arg1, err = ec.unmarshalNJSON2map(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["config"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_testRouterConnection_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_testRouterCredentials_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.AddRouterInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNAddRouterInput2backendgraphmodelAddRouterInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_undoBridgeOperation_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["operationId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("operationId"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["operationId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_updateAlertRule_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	var arg1 model.UpdateAlertRuleInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg1, err = ec.unmarshalNUpdateAlertRuleInput2backendgraphmodelUpdateAlertRuleInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_updateBridgePort_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["portId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("portId"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["portId"] = arg0
	var arg1 model.UpdateBridgePortInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg1, err = ec.unmarshalNUpdateBridgePortInput2backendgraphmodelUpdateBridgePortInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_updateBridge_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["uuid"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("uuid"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["uuid"] = arg0
	var arg1 model.UpdateBridgeInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg1, err = ec.unmarshalNUpdateBridgeInput2backendgraphmodelUpdateBridgeInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_updateChangeSetItem_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["changeSetId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("changeSetId"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["changeSetId"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["itemId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("itemId"))
		arg1, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["itemId"] = arg1
	var arg2 model.UpdateChangeSetItemInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg2, err = ec.unmarshalNUpdateChangeSetItemInput2backendgraphmodelUpdateChangeSetItemInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg2
	return args, nil
}

func (ec *executionContext) field_Mutation_updateInterface_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["routerId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("routerId"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["routerId"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["interfaceId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("interfaceId"))
		arg1, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["interfaceId"] = arg1
	var arg2 model.UpdateInterfaceInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg2, err = ec.unmarshalNUpdateInterfaceInput2backendgraphmodelUpdateInterfaceInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg2
	return args, nil
}

func (ec *executionContext) field_Mutation_updateIpAddress_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["routerId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("routerId"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["routerId"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg1, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg1
	var arg2 model.IPAddressInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg2, err = ec.unmarshalNIpAddressInput2backendgraphmodelIPAddressInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg2
	return args, nil
}

func (ec *executionContext) field_Mutation_updateResource_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["routerId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("routerId"))
		arg1, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["routerId"] = arg1
	var arg2 model.UpdateResourceInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg2, err = ec.unmarshalNUpdateResourceInput2backendgraphmodelUpdateResourceInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg2
	return args, nil
}

func (ec *executionContext) field_Mutation_updateRoute_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["routerId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("routerId"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["routerId"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg1, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg1
	var arg2 model.RouteInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg2, err = ec.unmarshalNRouteInput2backendgraphmodelRouteInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg2
	return args, nil
}

func (ec *executionContext) field_Mutation_updateRouterCredentials_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["routerId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("routerId"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["routerId"] = arg0
	var arg1 model.CredentialsInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg1, err = ec.unmarshalNCredentialsInput2backendgraphmodelCredentialsInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_updateRouter_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	var arg1 model.UpdateRouterInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg1, err = ec.unmarshalNUpdateRouterInput2backendgraphmodelUpdateRouterInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_updateVlan_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	var arg1 model.VlanInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg1, err = ec.unmarshalNVlanInput2backendgraphmodelVlanInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_validateChangeSet_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["changeSetId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("changeSetId"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["changeSetId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_validateResource_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["routerId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("routerId"))
		arg1, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["routerId"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_verifyTroubleshootFix_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["sessionId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sessionId"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["sessionId"] = arg0
	var arg1 model.TroubleshootStepType
	if tmp, ok := rawArgs["stepType"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("stepType"))
		arg1, err = ec.unmarshalNTroubleshootStepType2backendgraphmodelTroubleshootStepType(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["stepType"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query___type_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_alertRule_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_alertRules_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["deviceId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deviceId"))
		arg0, err = ec.unmarshalOID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["deviceId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_alerts_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["deviceId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deviceId"))
		arg0, err = ec.unmarshalOID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["deviceId"] = arg0
	var arg1 *model.AlertSeverity
	if tmp, ok := rawArgs["severity"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("severity"))
		arg1, err = ec.unmarshalOAlertSeverity2backendgraphmodelAlertSeverity(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["severity"] = arg1
	var arg2 *bool
	if tmp, ok := rawArgs["acknowledged"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("acknowledged"))
		arg2, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["acknowledged"] = arg2
	var arg3 *int
	if tmp, ok := rawArgs["limit"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("limit"))
		arg3, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg3
	var arg4 *int
	if tmp, ok := rawArgs["offset"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("offset"))
		arg4, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg4
	return args, nil
}

func (ec *executionContext) field_Query_availableInterfacesForBridge_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["routerId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("routerId"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["routerId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_bridgePorts_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["bridgeId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("bridgeId"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["bridgeId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_bridgeVlans_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["bridgeId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("bridgeId"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["bridgeId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_bridge_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["uuid"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("uuid"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["uuid"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_bridges_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["routerId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("routerId"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["routerId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_changeSet_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["routerId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("routerId"))
		arg1, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["routerId"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query_changeSets_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["routerId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("routerId"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["routerId"] = arg0
	var arg1 *model.ChangeSetStatus
	if tmp, ok := rawArgs["status"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("status"))
		arg1, err = ec.unmarshalOChangeSetStatus2backendgraphmodelChangeSetStatus(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["status"] = arg1
	var arg2 *bool
	if tmp, ok := rawArgs["includeCompleted"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("includeCompleted"))
		arg2, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["includeCompleted"] = arg2
	return args, nil
}

func (ec *executionContext) field_Query_checkGatewayReachability_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["routerId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("routerId"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["routerId"] = arg0
	var arg1 model.IPv4
	if tmp, ok := rawArgs["gateway"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("gateway"))
		arg1, err = ec.unmarshalNIPv42backendgraphmodelIPv4(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["gateway"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query_checkIpConflict_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["routerId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("routerId"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["routerId"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["address"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("address"))
		arg1, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["address"] = arg1
	var arg2 *string
	if tmp, ok := rawArgs["interfaceId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("interfaceId"))
		arg2, err = ec.unmarshalOID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["interfaceId"] = arg2
	var arg3 *string
	if tmp, ok := rawArgs["excludeId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("excludeId"))
		arg3, err = ec.unmarshalOID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["excludeId"] = arg3
	return args, nil
}

func (ec *executionContext) field_Query_checkVlanIdAvailable_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["routerId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("routerId"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["routerId"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["parentInterface"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("parentInterface"))
		arg1, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["parentInterface"] = arg1
	var arg2 int
	if tmp, ok := rawArgs["vlanId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("vlanId"))
		arg2, err = ec.unmarshalNInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["vlanId"] = arg2
	return args, nil
}

func (ec *executionContext) field_Query_circuitBreakerStatus_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["routerId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("routerId"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["routerId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_compositeResource_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["routerId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("routerId"))
		arg1, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["routerId"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query_connectionAttempts_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["routerId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("routerId"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["routerId"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["limit"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("limit"))
		arg1, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query_connectionDetails_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["routerId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("routerId"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["routerId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_detectGateway_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["routerId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("routerId"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["routerId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_detectISP_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["routerId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("routerId"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["routerId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_detectWanInterface_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["routerId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("routerId"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["routerId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_device_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_dnsServers_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["deviceId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deviceId"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["deviceId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_interfaceStatsHistory_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["routerId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("routerId"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["routerId"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["interfaceId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("interfaceId"))
		arg1, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["interfaceId"] = arg1
	var arg2 model.StatsTimeRangeInput
	if tmp, ok := rawArgs["timeRange"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("timeRange"))
		arg2, err = ec.unmarshalNStatsTimeRangeInput2backendgraphmodelStatsTimeRangeInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["timeRange"] = arg2
	var arg3 *model.Duration
	if tmp, ok := rawArgs["interval"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("interval"))
		arg3, err = ec.unmarshalODuration2backendgraphmodelDuration(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["interval"] = arg3
	return args, nil
}

func (ec *executionContext) field_Query_interface_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["routerId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("routerId"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["routerId"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg1, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query_interfaces_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["routerId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("routerId"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["routerId"] = arg0
	var arg1 *model.InterfaceType
	if tmp, ok := rawArgs["type"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("type"))
		arg1, err = ec.unmarshalOInterfaceType2backendgraphmodelInterfaceType(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["type"] = arg1
	var arg2 *model.PaginationInput
	if tmp, ok := rawArgs["pagination"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pagination"))
		arg2, err = ec.unmarshalOPaginationInput2backendgraphmodelPaginationInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["pagination"] = arg2
	return args, nil
}

func (ec *executionContext) field_Query_ipAddressDependencies_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["routerId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("routerId"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["routerId"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg1, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query_ipAddress_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["routerId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("routerId"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["routerId"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg1, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query_ipAddresses_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["routerId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("routerId"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["routerId"] = arg0
	var arg1 *string
	if tmp, ok := rawArgs["interfaceId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("interfaceId"))
		arg1, err = ec.unmarshalOID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["interfaceId"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query_isFeatureSupported_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["routerId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("routerId"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["routerId"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["featureId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("featureId"))
		arg1, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["featureId"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query_node_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_resource_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["routerId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("routerId"))
		arg1, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["routerId"] = arg1
	var arg2 []model.ResourceLayer
	if tmp, ok := rawArgs["layers"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("layers"))
		arg2, err = ec.unmarshalOResourceLayer2backendgraphmodelResourceLayer(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["layers"] = arg2
	return args, nil
}

func (ec *executionContext) field_Query_resources_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["routerId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("routerId"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["routerId"] = arg0
	var arg1 *model.ResourceCategory
	if tmp, ok := rawArgs["category"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("category"))
		arg1, err = ec.unmarshalOResourceCategory2backendgraphmodelResourceCategory(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["category"] = arg1
	var arg2 *string
	if tmp, ok := rawArgs["type"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("type"))
		arg2, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["type"] = arg2
	var arg3 *model.ResourceLifecycleState
	if tmp, ok := rawArgs["state"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("state"))
		arg3, err = ec.unmarshalOResourceLifecycleState2backendgraphmodelResourceLifecycleState(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["state"] = arg3
	var arg4 *model.PaginationInput
	if tmp, ok := rawArgs["pagination"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pagination"))
		arg4, err = ec.unmarshalOPaginationInput2backendgraphmodelPaginationInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["pagination"] = arg4
	return args, nil
}

func (ec *executionContext) field_Query_route_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["routerId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("routerId"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["routerId"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg1, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query_routerCapabilities_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["routerId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("routerId"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["routerId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_routerCredentials_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["routerId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("routerId"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["routerId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_routerHealth_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["routerId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("routerId"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["routerId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_router_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_routers_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *model.ConnectionStatus
	if tmp, ok := rawArgs["status"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("status"))
		arg0, err = ec.unmarshalOConnectionStatus2backendgraphmodelConnectionStatus(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["status"] = arg0
	var arg1 *model.PaginationInput
	if tmp, ok := rawArgs["pagination"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pagination"))
		arg1, err = ec.unmarshalOPaginationInput2backendgraphmodelPaginationInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["pagination"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query_routes_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["routerId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("routerId"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["routerId"] = arg0
	var arg1 *string
	if tmp, ok := rawArgs["table"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("table"))
		arg1, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["table"] = arg1
	var arg2 *model.RouteType
	if tmp, ok := rawArgs["type"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("type"))
		arg2, err = ec.unmarshalORouteType2backendgraphmodelRouteType(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["type"] = arg2
	return args, nil
}

func (ec *executionContext) field_Query_scanHistory_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *int
	if tmp, ok := rawArgs["limit"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("limit"))
		arg0, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_scanStatus_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["taskId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("taskId"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["taskId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_supportedFeatures_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["routerId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("routerId"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["routerId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_troubleshootSession_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_unsupportedFeatures_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["routerId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("routerId"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["routerId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_upgradeRecommendation_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["routerId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("routerId"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["routerId"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["featureId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("featureId"))
		arg1, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["featureId"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query_upgradeRecommendations_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["routerId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("routerId"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["routerId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_vlanDependencies_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_vlanTopology_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["routerId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("routerId"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["routerId"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["bridgeId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("bridgeId"))
		arg1, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["bridgeId"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query_vlan_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_vlans_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["routerId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("routerId"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["routerId"] = arg0
	var arg1 *model.VlanFilter
	if tmp, ok := rawArgs["filter"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("filter"))
		arg1, err = ec.unmarshalOVlanFilter2backendgraphmodelVlanFilter(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query_wanConnectionHistory_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["routerId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("routerId"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["routerId"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["wanInterfaceId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("wanInterfaceId"))
		arg1, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["wanInterfaceId"] = arg1
	var arg2 *model.PaginationInput
	if tmp, ok := rawArgs["pagination"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pagination"))
		arg2, err = ec.unmarshalOPaginationInput2backendgraphmodelPaginationInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["pagination"] = arg2
	return args, nil
}

func (ec *executionContext) field_Query_wanInterface_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["routerId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("routerId"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["routerId"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg1, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query_wanInterfaces_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["routerId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("routerId"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["routerId"] = arg0
	return args, nil
}

func (ec *executionContext) field_RouterOSVersion_isAtLeast_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["version"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("version"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["version"] = arg0
	return args, nil
}

func (ec *executionContext) field_RouterOSVersion_supportsFeature_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["featureId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("featureId"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["featureId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Subscription_alertEvents_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["deviceId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deviceId"))
		arg0, err = ec.unmarshalOID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["deviceId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Subscription_bridgePortsChanged_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["bridgeId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("bridgeId"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["bridgeId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Subscription_bridgeStpStatusChanged_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["bridgeId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("bridgeId"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["bridgeId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Subscription_changeSetProgress_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["changeSetId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("changeSetId"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["changeSetId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Subscription_changeSetStatusChanged_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["routerId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("routerId"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["routerId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Subscription_circuitBreakerChanged_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["routerId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("routerId"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["routerId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Subscription_circuitBreakerStateChanged_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["routerId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("routerId"))
		arg0, err = ec.unmarshalOID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["routerId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Subscription_configApplyProgress_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["operationId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("operationId"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["operationId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Subscription_connectionHealth_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["routerId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("routerId"))
		arg0, err = ec.unmarshalOID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["routerId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Subscription_interfaceStatsUpdated_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["routerId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("routerId"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["routerId"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["interfaceId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("interfaceId"))
		arg1, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["interfaceId"] = arg1
	var arg2 *model.Duration
	if tmp, ok := rawArgs["interval"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("interval"))
		arg2, err = ec.unmarshalODuration2backendgraphmodelDuration(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["interval"] = arg2
	return args, nil
}

func (ec *executionContext) field_Subscription_interfaceStatusChanged_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["routerId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("routerId"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["routerId"] = arg0
	var arg1 *string
	if tmp, ok := rawArgs["interfaceId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("interfaceId"))
		arg1, err = ec.unmarshalOID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["interfaceId"] = arg1
	return args, nil
}

func (ec *executionContext) field_Subscription_interfaceTraffic_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["routerId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("routerId"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["routerId"] = arg0
	var arg1 *string
	if tmp, ok := rawArgs["interfaceId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("interfaceId"))
		arg1, err = ec.unmarshalOID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["interfaceId"] = arg1
	return args, nil
}

func (ec *executionContext) field_Subscription_ipAddressChanged_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["routerId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("routerId"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["routerId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Subscription_resourceMetrics_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["deviceId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deviceId"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["deviceId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Subscription_resourceRuntime_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["routerId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("routerId"))
		arg1, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["routerId"] = arg1
	return args, nil
}

func (ec *executionContext) field_Subscription_resourceStateChanged_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalOID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["routerId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("routerId"))
		arg1, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["routerId"] = arg1
	return args, nil
}

func (ec *executionContext) field_Subscription_resourceUpdated_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["resourceId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("resourceId"))
		arg0, err = ec.unmarshalOID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["resourceId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Subscription_routerStatusChanged_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["routerId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("routerId"))
		arg0, err = ec.unmarshalOID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["routerId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Subscription_scanProgress_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["taskId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("taskId"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["taskId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Subscription_tracerouteProgress_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["jobId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("jobId"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["jobId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Subscription_troubleshootProgress_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["sessionId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sessionId"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["sessionId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Subscription_vlanChanged_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["routerId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("routerId"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["routerId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Subscription_wanHealthChanged_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["routerId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("routerId"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["routerId"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["wanInterfaceId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("wanInterfaceId"))
		arg1, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["wanInterfaceId"] = arg1
	return args, nil
}

func (ec *executionContext) field_Subscription_wanStatusChanged_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["routerId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("routerId"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["routerId"] = arg0
	var arg1 *string
	if tmp, ok := rawArgs["wanInterfaceId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("wanInterfaceId"))
		arg1, err = ec.unmarshalOID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["wanInterfaceId"] = arg1
	return args, nil
}

func (ec *executionContext) field___Type_enumValues_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 bool
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("includeDeprecated"))
		arg0, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["includeDeprecated"] = arg0
	return args, nil
}

func (ec *executionContext) field___Type_fields_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 bool
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("includeDeprecated"))
		arg0, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["includeDeprecated"] = arg0
	return args, nil
}

// endregion ***************************** args.gotpl *****************************

// region    ************************** directives.gotpl **************************

// endregion ************************** directives.gotpl **************************

// region    **************************** field.gotpl *****************************

func (ec *executionContext) _AddChangeSetItemPayload_changeSet(ctx context.Context, field graphql.CollectedField, obj *model.AddChangeSetItemPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AddChangeSetItemPayload_changeSet(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ChangeSet, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.ChangeSet)
	fc.Result = res
	return ec.marshalOChangeSet2backendgraphmodelChangeSet(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AddChangeSetItemPayload_changeSet(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AddChangeSetItemPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ChangeSet_id(ctx, field)
			case "name":
				return ec.fieldContext_ChangeSet_name(ctx, field)
			case "description":
				return ec.fieldContext_ChangeSet_description(ctx, field)
			case "routerId":
				return ec.fieldContext_ChangeSet_routerId(ctx, field)
			case "items":
				return ec.fieldContext_ChangeSet_items(ctx, field)
			case "status":
				return ec.fieldContext_ChangeSet_status(ctx, field)
			case "validation":
				return ec.fieldContext_ChangeSet_validation(ctx, field)
			case "rollbackPlan":
				return ec.fieldContext_ChangeSet_rollbackPlan(ctx, field)
			case "error":
				return ec.fieldContext_ChangeSet_error(ctx, field)
			case "createdAt":
				return ec.fieldContext_ChangeSet_createdAt(ctx, field)
			case "applyStartedAt":
				return ec.fieldContext_ChangeSet_applyStartedAt(ctx, field)
			case "completedAt":
				return ec.fieldContext_ChangeSet_completedAt(ctx, field)
			case "createdBy":
				return ec.fieldContext_ChangeSet_createdBy(ctx, field)
			case "source":
				return ec.fieldContext_ChangeSet_source(ctx, field)
			case "version":
				return ec.fieldContext_ChangeSet_version(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ChangeSet", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _AddChangeSetItemPayload_itemId(ctx context.Context, field graphql.CollectedField, obj *model.AddChangeSetItemPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AddChangeSetItemPayload_itemId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ItemID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AddChangeSetItemPayload_itemId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AddChangeSetItemPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AddChangeSetItemPayload_errors(ctx context.Context, field graphql.CollectedField, obj *model.AddChangeSetItemPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AddChangeSetItemPayload_errors(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Errors, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.MutationError)
	fc.Result = res
	return ec.marshalOMutationError2backendgraphmodelMutationError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AddChangeSetItemPayload_errors(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AddChangeSetItemPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "code":
				return ec.fieldContext_MutationError_code(ctx, field)
			case "message":
				return ec.fieldContext_MutationError_message(ctx, field)
			case "field":
				return ec.fieldContext_MutationError_field(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MutationError", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _AddRouterPayload_router(ctx context.Context, field graphql.CollectedField, obj *model.AddRouterPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AddRouterPayload_router(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Router, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Router)
	fc.Result = res
	return ec.marshalORouter2backendgraphmodelRouter(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AddRouterPayload_router(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AddRouterPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Router_id(ctx, field)
			case "name":
				return ec.fieldContext_Router_name(ctx, field)
			case "host":
				return ec.fieldContext_Router_host(ctx, field)
			case "port":
				return ec.fieldContext_Router_port(ctx, field)
			case "status":
				return ec.fieldContext_Router_status(ctx, field)
			case "platform":
				return ec.fieldContext_Router_platform(ctx, field)
			case "version":
				return ec.fieldContext_Router_version(ctx, field)
			case "model":
				return ec.fieldContext_Router_model(ctx, field)
			case "uptime":
				return ec.fieldContext_Router_uptime(ctx, field)
			case "lastConnected":
				return ec.fieldContext_Router_lastConnected(ctx, field)
			case "createdAt":
				return ec.fieldContext_Router_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Router_updatedAt(ctx, field)
			case "capabilities":
				return ec.fieldContext_Router_capabilities(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Router", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _AddRouterPayload_connectionResult(ctx context.Context, field graphql.CollectedField, obj *model.AddRouterPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AddRouterPayload_connectionResult(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ConnectionResult, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.ConnectionTestResult)
	fc.Result = res
	return ec.marshalOConnectionTestResult2backendgraphmodelConnectionTestResult(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AddRouterPayload_connectionResult(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AddRouterPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "success":
				return ec.fieldContext_ConnectionTestResult_success(ctx, field)
			case "protocolUsed":
				return ec.fieldContext_ConnectionTestResult_protocolUsed(ctx, field)
			case "responseTimeMs":
				return ec.fieldContext_ConnectionTestResult_responseTimeMs(ctx, field)
			case "routerVersion":
				return ec.fieldContext_ConnectionTestResult_routerVersion(ctx, field)
			case "routerModel":
				return ec.fieldContext_ConnectionTestResult_routerModel(ctx, field)
			case "boardName":
				return ec.fieldContext_ConnectionTestResult_boardName(ctx, field)
			case "uptime":
				return ec.fieldContext_ConnectionTestResult_uptime(ctx, field)
			case "protocolsAttempted":
				return ec.fieldContext_ConnectionTestResult_protocolsAttempted(ctx, field)
			case "supportsContainers":
				return ec.fieldContext_ConnectionTestResult_supportsContainers(ctx, field)
			case "architecture":
				return ec.fieldContext_ConnectionTestResult_architecture(ctx, field)
			case "error":
				return ec.fieldContext_ConnectionTestResult_error(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ConnectionTestResult", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _AddRouterPayload_validationErrors(ctx context.Context, field graphql.CollectedField, obj *model.AddRouterPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AddRouterPayload_validationErrors(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ValidationErrors, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.ValidationError)
	fc.Result = res
	return ec.marshalOValidationError2backendgraphmodelValidationError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AddRouterPayload_validationErrors(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AddRouterPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "field":
				return ec.fieldContext_ValidationError_field(ctx, field)
			case "code":
				return ec.fieldContext_ValidationError_code(ctx, field)
			case "message":
				return ec.fieldContext_ValidationError_message(ctx, field)
			case "suggestion":
				return ec.fieldContext_ValidationError_suggestion(ctx, field)
			case "providedValue":
				return ec.fieldContext_ValidationError_providedValue(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ValidationError", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _AddRouterPayload_errors(ctx context.Context, field graphql.CollectedField, obj *model.AddRouterPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AddRouterPayload_errors(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Errors, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.MutationError)
	fc.Result = res
	return ec.marshalOMutationError2backendgraphmodelMutationError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AddRouterPayload_errors(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AddRouterPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "code":
				return ec.fieldContext_MutationError_code(ctx, field)
			case "message":
				return ec.fieldContext_MutationError_message(ctx, field)
			case "field":
				return ec.fieldContext_MutationError_field(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MutationError", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _AffectedResource_type(ctx context.Context, field graphql.CollectedField, obj *model.AffectedResource) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AffectedResource_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AffectedResource_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AffectedResource",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AffectedResource_id(ctx context.Context, field graphql.CollectedField, obj *model.AffectedResource) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AffectedResource_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AffectedResource_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AffectedResource",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AffectedResource_name(ctx context.Context, field graphql.CollectedField, obj *model.AffectedResource) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AffectedResource_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AffectedResource_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AffectedResource",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AffectedResource_impact(ctx context.Context, field graphql.CollectedField, obj *model.AffectedResource) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AffectedResource_impact(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Impact, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.ResourceImpact)
	fc.Result = res
	return ec.marshalNResourceImpact2backendgraphmodelResourceImpact(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AffectedResource_impact(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AffectedResource",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ResourceImpact does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Alert_id(ctx context.Context, field graphql.CollectedField, obj *model.Alert) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Alert_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Alert_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Alert",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Alert_rule(ctx context.Context, field graphql.CollectedField, obj *model.Alert) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Alert_rule(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Rule, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.AlertRule)
	fc.Result = res
	return ec.marshalNAlertRule2backendgraphmodelAlertRule(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Alert_rule(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Alert",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_AlertRule_id(ctx, field)
			case "name":
				return ec.fieldContext_AlertRule_name(ctx, field)
			case "description":
				return ec.fieldContext_AlertRule_description(ctx, field)
			case "eventType":
				return ec.fieldContext_AlertRule_eventType(ctx, field)
			case "conditions":
				return ec.fieldContext_AlertRule_conditions(ctx, field)
			case "severity":
				return ec.fieldContext_AlertRule_severity(ctx, field)
			case "channels":
				return ec.fieldContext_AlertRule_channels(ctx, field)
			case "throttle":
				return ec.fieldContext_AlertRule_throttle(ctx, field)
			case "quietHours":
				return ec.fieldContext_AlertRule_quietHours(ctx, field)
			case "deviceId":
				return ec.fieldContext_AlertRule_deviceId(ctx, field)
			case "enabled":
				return ec.fieldContext_AlertRule_enabled(ctx, field)
			case "createdAt":
				return ec.fieldContext_AlertRule_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_AlertRule_updatedAt(ctx, field)
			case "alerts":
				return ec.fieldContext_AlertRule_alerts(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type AlertRule", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Alert_eventType(ctx context.Context, field graphql.CollectedField, obj *model.Alert) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Alert_eventType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EventType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Alert_eventType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Alert",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Alert_severity(ctx context.Context, field graphql.CollectedField, obj *model.Alert) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Alert_severity(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Severity, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.AlertSeverity)
	fc.Result = res
	return ec.marshalNAlertSeverity2backendgraphmodelAlertSeverity(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Alert_severity(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Alert",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type AlertSeverity does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Alert_title(ctx context.Context, field graphql.CollectedField, obj *model.Alert) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Alert_title(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Title, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Alert_title(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Alert",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Alert_message(ctx context.Context, field graphql.CollectedField, obj *model.Alert) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Alert_message(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Alert_message(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Alert",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Alert_data(ctx context.Context, field graphql.CollectedField, obj *model.Alert) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Alert_data(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Data, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOJSON2map(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Alert_data(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Alert",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type JSON does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Alert_deviceId(ctx context.Context, field graphql.CollectedField, obj *model.Alert) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Alert_deviceId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeviceID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Alert_deviceId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Alert",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Alert_triggeredAt(ctx context.Context, field graphql.CollectedField, obj *model.Alert) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Alert_triggeredAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TriggeredAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNDateTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Alert_triggeredAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Alert",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DateTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Alert_acknowledgedAt(ctx context.Context, field graphql.CollectedField, obj *model.Alert) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Alert_acknowledgedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AcknowledgedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalODateTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Alert_acknowledgedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Alert",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DateTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Alert_acknowledgedBy(ctx context.Context, field graphql.CollectedField, obj *model.Alert) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Alert_acknowledgedBy(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AcknowledgedBy, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Alert_acknowledgedBy(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Alert",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Alert_deliveryStatus(ctx context.Context, field graphql.CollectedField, obj *model.Alert) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Alert_deliveryStatus(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeliveryStatus, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOJSON2map(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Alert_deliveryStatus(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Alert",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type JSON does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Alert_updatedAt(ctx context.Context, field graphql.CollectedField, obj *model.Alert) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Alert_updatedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNDateTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Alert_updatedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Alert",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DateTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AlertCondition_field(ctx context.Context, field graphql.CollectedField, obj *model.AlertCondition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AlertCondition_field(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Field, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AlertCondition_field(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AlertCondition",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AlertCondition_operator(ctx context.Context, field graphql.CollectedField, obj *model.AlertCondition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AlertCondition_operator(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Operator, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.ConditionOperator)
	fc.Result = res
	return ec.marshalNConditionOperator2backendgraphmodelConditionOperator(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AlertCondition_operator(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AlertCondition",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ConditionOperator does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AlertCondition_value(ctx context.Context, field graphql.CollectedField, obj *model.AlertCondition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AlertCondition_value(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Value, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AlertCondition_value(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AlertCondition",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AlertConnection_edges(ctx context.Context, field graphql.CollectedField, obj *model.AlertConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AlertConnection_edges(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Edges, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.AlertEdge)
	fc.Result = res
	return ec.marshalNAlertEdge2backendgraphmodelAlertEdge(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AlertConnection_edges(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AlertConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "node":
				return ec.fieldContext_AlertEdge_node(ctx, field)
			case "cursor":
				return ec.fieldContext_AlertEdge_cursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type AlertEdge", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _AlertConnection_pageInfo(ctx context.Context, field graphql.CollectedField, obj *model.AlertConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AlertConnection_pageInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.PageInfo)
	fc.Result = res
	return ec.marshalNPageInfo2backendgraphmodelPageInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AlertConnection_pageInfo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AlertConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			case "hasPreviousPage":
				return ec.fieldContext_PageInfo_hasPreviousPage(ctx, field)
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _AlertConnection_totalCount(ctx context.Context, field graphql.CollectedField, obj *model.AlertConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AlertConnection_totalCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AlertConnection_totalCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AlertConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AlertEdge_node(ctx context.Context, field graphql.CollectedField, obj *model.AlertEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AlertEdge_node(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Node, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Alert)
	fc.Result = res
	return ec.marshalNAlert2backendgraphmodelAlert(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AlertEdge_node(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AlertEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Alert_id(ctx, field)
			case "rule":
				return ec.fieldContext_Alert_rule(ctx, field)
			case "eventType":
				return ec.fieldContext_Alert_eventType(ctx, field)
			case "severity":
				return ec.fieldContext_Alert_severity(ctx, field)
			case "title":
				return ec.fieldContext_Alert_title(ctx, field)
			case "message":
				return ec.fieldContext_Alert_message(ctx, field)
			case "data":
				return ec.fieldContext_Alert_data(ctx, field)
			case "deviceId":
				return ec.fieldContext_Alert_deviceId(ctx, field)
			case "triggeredAt":
				return ec.fieldContext_Alert_triggeredAt(ctx, field)
			case "acknowledgedAt":
				return ec.fieldContext_Alert_acknowledgedAt(ctx, field)
			case "acknowledgedBy":
				return ec.fieldContext_Alert_acknowledgedBy(ctx, field)
			case "deliveryStatus":
				return ec.fieldContext_Alert_deliveryStatus(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Alert_updatedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Alert", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _AlertEdge_cursor(ctx context.Context, field graphql.CollectedField, obj *model.AlertEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AlertEdge_cursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AlertEdge_cursor(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AlertEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AlertEvent_alert(ctx context.Context, field graphql.CollectedField, obj *model.AlertEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AlertEvent_alert(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Alert, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Alert)
	fc.Result = res
	return ec.marshalNAlert2backendgraphmodelAlert(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AlertEvent_alert(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AlertEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Alert_id(ctx, field)
			case "rule":
				return ec.fieldContext_Alert_rule(ctx, field)
			case "eventType":
				return ec.fieldContext_Alert_eventType(ctx, field)
			case "severity":
				return ec.fieldContext_Alert_severity(ctx, field)
			case "title":
				return ec.fieldContext_Alert_title(ctx, field)
			case "message":
				return ec.fieldContext_Alert_message(ctx, field)
			case "data":
				return ec.fieldContext_Alert_data(ctx, field)
			case "deviceId":
				return ec.fieldContext_Alert_deviceId(ctx, field)
			case "triggeredAt":
				return ec.fieldContext_Alert_triggeredAt(ctx, field)
			case "acknowledgedAt":
				return ec.fieldContext_Alert_acknowledgedAt(ctx, field)
			case "acknowledgedBy":
				return ec.fieldContext_Alert_acknowledgedBy(ctx, field)
			case "deliveryStatus":
				return ec.fieldContext_Alert_deliveryStatus(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Alert_updatedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Alert", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _AlertEvent_action(ctx context.Context, field graphql.CollectedField, obj *model.AlertEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AlertEvent_action(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Action, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.AlertAction)
	fc.Result = res
	return ec.marshalNAlertAction2backendgraphmodelAlertAction(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AlertEvent_action(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AlertEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type AlertAction does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AlertPayload_alert(ctx context.Context, field graphql.CollectedField, obj *model.AlertPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AlertPayload_alert(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Alert, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Alert)
	fc.Result = res
	return ec.marshalOAlert2backendgraphmodelAlert(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AlertPayload_alert(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AlertPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Alert_id(ctx, field)
			case "rule":
				return ec.fieldContext_Alert_rule(ctx, field)
			case "eventType":
				return ec.fieldContext_Alert_eventType(ctx, field)
			case "severity":
				return ec.fieldContext_Alert_severity(ctx, field)
			case "title":
				return ec.fieldContext_Alert_title(ctx, field)
			case "message":
				return ec.fieldContext_Alert_message(ctx, field)
			case "data":
				return ec.fieldContext_Alert_data(ctx, field)
			case "deviceId":
				return ec.fieldContext_Alert_deviceId(ctx, field)
			case "triggeredAt":
				return ec.fieldContext_Alert_triggeredAt(ctx, field)
			case "acknowledgedAt":
				return ec.fieldContext_Alert_acknowledgedAt(ctx, field)
			case "acknowledgedBy":
				return ec.fieldContext_Alert_acknowledgedBy(ctx, field)
			case "deliveryStatus":
				return ec.fieldContext_Alert_deliveryStatus(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Alert_updatedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Alert", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _AlertPayload_errors(ctx context.Context, field graphql.CollectedField, obj *model.AlertPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AlertPayload_errors(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Errors, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.MutationError)
	fc.Result = res
	return ec.marshalOMutationError2backendgraphmodelMutationError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AlertPayload_errors(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AlertPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "code":
				return ec.fieldContext_MutationError_code(ctx, field)
			case "message":
				return ec.fieldContext_MutationError_message(ctx, field)
			case "field":
				return ec.fieldContext_MutationError_field(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MutationError", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _AlertRule_id(ctx context.Context, field graphql.CollectedField, obj *model.AlertRule) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AlertRule_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AlertRule_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AlertRule",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AlertRule_name(ctx context.Context, field graphql.CollectedField, obj *model.AlertRule) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AlertRule_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AlertRule_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AlertRule",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AlertRule_description(ctx context.Context, field graphql.CollectedField, obj *model.AlertRule) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AlertRule_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AlertRule_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AlertRule",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AlertRule_eventType(ctx context.Context, field graphql.CollectedField, obj *model.AlertRule) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AlertRule_eventType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EventType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AlertRule_eventType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AlertRule",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AlertRule_conditions(ctx context.Context, field graphql.CollectedField, obj *model.AlertRule) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AlertRule_conditions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Conditions, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.AlertCondition)
	fc.Result = res
	return ec.marshalNAlertCondition2backendgraphmodelAlertCondition(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AlertRule_conditions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AlertRule",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "field":
				return ec.fieldContext_AlertCondition_field(ctx, field)
			case "operator":
				return ec.fieldContext_AlertCondition_operator(ctx, field)
			case "value":
				return ec.fieldContext_AlertCondition_value(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type AlertCondition", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _AlertRule_severity(ctx context.Context, field graphql.CollectedField, obj *model.AlertRule) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AlertRule_severity(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Severity, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.AlertSeverity)
	fc.Result = res
	return ec.marshalNAlertSeverity2backendgraphmodelAlertSeverity(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AlertRule_severity(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AlertRule",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type AlertSeverity does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AlertRule_channels(ctx context.Context, field graphql.CollectedField, obj *model.AlertRule) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AlertRule_channels(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Channels, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AlertRule_channels(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AlertRule",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AlertRule_throttle(ctx context.Context, field graphql.CollectedField, obj *model.AlertRule) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AlertRule_throttle(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Throttle, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.ThrottleConfig)
	fc.Result = res
	return ec.marshalOThrottleConfig2backendgraphmodelThrottleConfig(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AlertRule_throttle(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AlertRule",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "maxAlerts":
				return ec.fieldContext_ThrottleConfig_maxAlerts(ctx, field)
			case "periodSeconds":
				return ec.fieldContext_ThrottleConfig_periodSeconds(ctx, field)
			case "groupByField":
				return ec.fieldContext_ThrottleConfig_groupByField(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ThrottleConfig", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _AlertRule_quietHours(ctx context.Context, field graphql.CollectedField, obj *model.AlertRule) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AlertRule_quietHours(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.QuietHours, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.QuietHoursConfig)
	fc.Result = res
	return ec.marshalOQuietHoursConfig2backendgraphmodelQuietHoursConfig(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AlertRule_quietHours(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AlertRule",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "startTime":
				return ec.fieldContext_QuietHoursConfig_startTime(ctx, field)
			case "endTime":
				return ec.fieldContext_QuietHoursConfig_endTime(ctx, field)
			case "timezone":
				return ec.fieldContext_QuietHoursConfig_timezone(ctx, field)
			case "bypassCritical":
				return ec.fieldContext_QuietHoursConfig_bypassCritical(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type QuietHoursConfig", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _AlertRule_deviceId(ctx context.Context, field graphql.CollectedField, obj *model.AlertRule) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AlertRule_deviceId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeviceID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AlertRule_deviceId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AlertRule",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AlertRule_enabled(ctx context.Context, field graphql.CollectedField, obj *model.AlertRule) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AlertRule_enabled(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Enabled, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AlertRule_enabled(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AlertRule",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AlertRule_createdAt(ctx context.Context, field graphql.CollectedField, obj *model.AlertRule) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AlertRule_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNDateTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AlertRule_createdAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AlertRule",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DateTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AlertRule_updatedAt(ctx context.Context, field graphql.CollectedField, obj *model.AlertRule) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AlertRule_updatedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNDateTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AlertRule_updatedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AlertRule",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DateTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AlertRule_alerts(ctx context.Context, field graphql.CollectedField, obj *model.AlertRule) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AlertRule_alerts(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Alerts, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.Alert)
	fc.Result = res
	return ec.marshalNAlert2backendgraphmodelAlert(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AlertRule_alerts(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AlertRule",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Alert_id(ctx, field)
			case "rule":
				return ec.fieldContext_Alert_rule(ctx, field)
			case "eventType":
				return ec.fieldContext_Alert_eventType(ctx, field)
			case "severity":
				return ec.fieldContext_Alert_severity(ctx, field)
			case "title":
				return ec.fieldContext_Alert_title(ctx, field)
			case "message":
				return ec.fieldContext_Alert_message(ctx, field)
			case "data":
				return ec.fieldContext_Alert_data(ctx, field)
			case "deviceId":
				return ec.fieldContext_Alert_deviceId(ctx, field)
			case "triggeredAt":
				return ec.fieldContext_Alert_triggeredAt(ctx, field)
			case "acknowledgedAt":
				return ec.fieldContext_Alert_acknowledgedAt(ctx, field)
			case "acknowledgedBy":
				return ec.fieldContext_Alert_acknowledgedBy(ctx, field)
			case "deliveryStatus":
				return ec.fieldContext_Alert_deliveryStatus(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Alert_updatedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Alert", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_AlertRule_alerts_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _AlertRulePayload_alertRule(ctx context.Context, field graphql.CollectedField, obj *model.AlertRulePayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AlertRulePayload_alertRule(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AlertRule, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.AlertRule)
	fc.Result = res
	return ec.marshalOAlertRule2backendgraphmodelAlertRule(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AlertRulePayload_alertRule(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AlertRulePayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_AlertRule_id(ctx, field)
			case "name":
				return ec.fieldContext_AlertRule_name(ctx, field)
			case "description":
				return ec.fieldContext_AlertRule_description(ctx, field)
			case "eventType":
				return ec.fieldContext_AlertRule_eventType(ctx, field)
			case "conditions":
				return ec.fieldContext_AlertRule_conditions(ctx, field)
			case "severity":
				return ec.fieldContext_AlertRule_severity(ctx, field)
			case "channels":
				return ec.fieldContext_AlertRule_channels(ctx, field)
			case "throttle":
				return ec.fieldContext_AlertRule_throttle(ctx, field)
			case "quietHours":
				return ec.fieldContext_AlertRule_quietHours(ctx, field)
			case "deviceId":
				return ec.fieldContext_AlertRule_deviceId(ctx, field)
			case "enabled":
				return ec.fieldContext_AlertRule_enabled(ctx, field)
			case "createdAt":
				return ec.fieldContext_AlertRule_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_AlertRule_updatedAt(ctx, field)
			case "alerts":
				return ec.fieldContext_AlertRule_alerts(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type AlertRule", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _AlertRulePayload_errors(ctx context.Context, field graphql.CollectedField, obj *model.AlertRulePayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AlertRulePayload_errors(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Errors, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.MutationError)
	fc.Result = res
	return ec.marshalOMutationError2backendgraphmodelMutationError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AlertRulePayload_errors(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AlertRulePayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "code":
				return ec.fieldContext_MutationError_code(ctx, field)
			case "message":
				return ec.fieldContext_MutationError_message(ctx, field)
			case "field":
				return ec.fieldContext_MutationError_field(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MutationError", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ApplyChangeSetPayload_changeSetId(ctx context.Context, field graphql.CollectedField, obj *model.ApplyChangeSetPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ApplyChangeSetPayload_changeSetId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ChangeSetID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ApplyChangeSetPayload_changeSetId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ApplyChangeSetPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ApplyChangeSetPayload_status(ctx context.Context, field graphql.CollectedField, obj *model.ApplyChangeSetPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ApplyChangeSetPayload_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.ChangeSetStatus)
	fc.Result = res
	return ec.marshalNChangeSetStatus2backendgraphmodelChangeSetStatus(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ApplyChangeSetPayload_status(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ApplyChangeSetPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ChangeSetStatus does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ApplyChangeSetPayload_errors(ctx context.Context, field graphql.CollectedField, obj *model.ApplyChangeSetPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ApplyChangeSetPayload_errors(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Errors, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.MutationError)
	fc.Result = res
	return ec.marshalOMutationError2backendgraphmodelMutationError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ApplyChangeSetPayload_errors(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ApplyChangeSetPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "code":
				return ec.fieldContext_MutationError_code(ctx, field)
			case "message":
				return ec.fieldContext_MutationError_message(ctx, field)
			case "field":
				return ec.fieldContext_MutationError_field(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MutationError", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ApplyFixPayload_success(ctx context.Context, field graphql.CollectedField, obj *model.ApplyFixPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ApplyFixPayload_success(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Success, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ApplyFixPayload_success(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ApplyFixPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ApplyFixPayload_message(ctx context.Context, field graphql.CollectedField, obj *model.ApplyFixPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ApplyFixPayload_message(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ApplyFixPayload_message(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ApplyFixPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ApplyFixPayload_status(ctx context.Context, field graphql.CollectedField, obj *model.ApplyFixPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ApplyFixPayload_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.FixApplicationStatus)
	fc.Result = res
	return ec.marshalNFixApplicationStatus2backendgraphmodelFixApplicationStatus(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ApplyFixPayload_status(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ApplyFixPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type FixApplicationStatus does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ApplyFixPayload_errors(ctx context.Context, field graphql.CollectedField, obj *model.ApplyFixPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ApplyFixPayload_errors(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Errors, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.MutationError)
	fc.Result = res
	return ec.marshalOMutationError2backendgraphmodelMutationError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ApplyFixPayload_errors(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ApplyFixPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "code":
				return ec.fieldContext_MutationError_code(ctx, field)
			case "message":
				return ec.fieldContext_MutationError_message(ctx, field)
			case "field":
				return ec.fieldContext_MutationError_field(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MutationError", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ApplyResourcePayload_resource(ctx context.Context, field graphql.CollectedField, obj *model.ApplyResourcePayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ApplyResourcePayload_resource(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Resource, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(model.Resource)
	fc.Result = res
	return ec.marshalOResource2backendgraphmodelResource(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ApplyResourcePayload_resource(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ApplyResourcePayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("FieldContext.Child cannot be called on type INTERFACE")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ApplyResourcePayload_operationId(ctx context.Context, field graphql.CollectedField, obj *model.ApplyResourcePayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ApplyResourcePayload_operationId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OperationID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ApplyResourcePayload_operationId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ApplyResourcePayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ApplyResourcePayload_errors(ctx context.Context, field graphql.CollectedField, obj *model.ApplyResourcePayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ApplyResourcePayload_errors(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Errors, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.MutationError)
	fc.Result = res
	return ec.marshalOMutationError2backendgraphmodelMutationError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ApplyResourcePayload_errors(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ApplyResourcePayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "code":
				return ec.fieldContext_MutationError_code(ctx, field)
			case "message":
				return ec.fieldContext_MutationError_message(ctx, field)
			case "field":
				return ec.fieldContext_MutationError_field(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MutationError", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ArchiveResourcePayload_success(ctx context.Context, field graphql.CollectedField, obj *model.ArchiveResourcePayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ArchiveResourcePayload_success(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Success, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ArchiveResourcePayload_success(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ArchiveResourcePayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ArchiveResourcePayload_errors(ctx context.Context, field graphql.CollectedField, obj *model.ArchiveResourcePayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ArchiveResourcePayload_errors(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Errors, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.MutationError)
	fc.Result = res
	return ec.marshalOMutationError2backendgraphmodelMutationError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ArchiveResourcePayload_errors(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ArchiveResourcePayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "code":
				return ec.fieldContext_MutationError_code(ctx, field)
			case "message":
				return ec.fieldContext_MutationError_message(ctx, field)
			case "field":
				return ec.fieldContext_MutationError_field(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MutationError", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _AuthPayload_token(ctx context.Context, field graphql.CollectedField, obj *model.AuthPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AuthPayload_token(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Token, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AuthPayload_token(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AuthPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AuthPayload_user(ctx context.Context, field graphql.CollectedField, obj *model.AuthPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AuthPayload_user(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.User, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.User)
	fc.Result = res
	return ec.marshalNUser2backendgraphmodelUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AuthPayload_user(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AuthPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "username":
				return ec.fieldContext_User_username(ctx, field)
			case "role":
				return ec.fieldContext_User_role(ctx, field)
			case "email":
				return ec.fieldContext_User_email(ctx, field)
			case "displayName":
				return ec.fieldContext_User_displayName(ctx, field)
			case "createdAt":
				return ec.fieldContext_User_createdAt(ctx, field)
			case "lastLoginAt":
				return ec.fieldContext_User_lastLoginAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _AuthPayload_expiresAt(ctx context.Context, field graphql.CollectedField, obj *model.AuthPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AuthPayload_expiresAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ExpiresAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNDateTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AuthPayload_expiresAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AuthPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DateTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AuthStatus_tested(ctx context.Context, field graphql.CollectedField, obj *model.AuthStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AuthStatus_tested(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Tested, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AuthStatus_tested(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AuthStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AuthStatus_success(ctx context.Context, field graphql.CollectedField, obj *model.AuthStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AuthStatus_success(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Success, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AuthStatus_success(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AuthStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AuthStatus_error(ctx context.Context, field graphql.CollectedField, obj *model.AuthStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AuthStatus_error(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Error, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AuthStatus_error(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AuthStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AuthStatus_errorCode(ctx context.Context, field graphql.CollectedField, obj *model.AuthStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AuthStatus_errorCode(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ErrorCode, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AuthStatus_errorCode(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AuthStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BandwidthDataPoint_timestamp(ctx context.Context, field graphql.CollectedField, obj *model.BandwidthDataPoint) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BandwidthDataPoint_timestamp(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Timestamp, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNDateTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BandwidthDataPoint_timestamp(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BandwidthDataPoint",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DateTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BandwidthDataPoint_bytesIn(ctx context.Context, field graphql.CollectedField, obj *model.BandwidthDataPoint) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BandwidthDataPoint_bytesIn(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BytesIn, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.Size)
	fc.Result = res
	return ec.marshalNSize2backendgraphmodelSize(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BandwidthDataPoint_bytesIn(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BandwidthDataPoint",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Size does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BandwidthDataPoint_bytesOut(ctx context.Context, field graphql.CollectedField, obj *model.BandwidthDataPoint) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BandwidthDataPoint_bytesOut(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BytesOut, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.Size)
	fc.Result = res
	return ec.marshalNSize2backendgraphmodelSize(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BandwidthDataPoint_bytesOut(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BandwidthDataPoint",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Size does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BandwidthDataPoint_periodSeconds(ctx context.Context, field graphql.CollectedField, obj *model.BandwidthDataPoint) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BandwidthDataPoint_periodSeconds(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PeriodSeconds, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BandwidthDataPoint_periodSeconds(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BandwidthDataPoint",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BatchInterfacePayload_succeeded(ctx context.Context, field graphql.CollectedField, obj *model.BatchInterfacePayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BatchInterfacePayload_succeeded(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Succeeded, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.Interface)
	fc.Result = res
	return ec.marshalNInterface2backendgraphmodelInterface(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BatchInterfacePayload_succeeded(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BatchInterfacePayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Interface_id(ctx, field)
			case "name":
				return ec.fieldContext_Interface_name(ctx, field)
			case "type":
				return ec.fieldContext_Interface_type(ctx, field)
			case "enabled":
				return ec.fieldContext_Interface_enabled(ctx, field)
			case "running":
				return ec.fieldContext_Interface_running(ctx, field)
			case "macAddress":
				return ec.fieldContext_Interface_macAddress(ctx, field)
			case "mtu":
				return ec.fieldContext_Interface_mtu(ctx, field)
			case "comment":
				return ec.fieldContext_Interface_comment(ctx, field)
			case "txBytes":
				return ec.fieldContext_Interface_txBytes(ctx, field)
			case "rxBytes":
				return ec.fieldContext_Interface_rxBytes(ctx, field)
			case "ip":
				return ec.fieldContext_Interface_ip(ctx, field)
			case "status":
				return ec.fieldContext_Interface_status(ctx, field)
			case "txRate":
				return ec.fieldContext_Interface_txRate(ctx, field)
			case "rxRate":
				return ec.fieldContext_Interface_rxRate(ctx, field)
			case "linkSpeed":
				return ec.fieldContext_Interface_linkSpeed(ctx, field)
			case "lastSeen":
				return ec.fieldContext_Interface_lastSeen(ctx, field)
			case "linkPartner":
				return ec.fieldContext_Interface_linkPartner(ctx, field)
			case "usedBy":
				return ec.fieldContext_Interface_usedBy(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Interface", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _BatchInterfacePayload_failed(ctx context.Context, field graphql.CollectedField, obj *model.BatchInterfacePayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BatchInterfacePayload_failed(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Failed, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.InterfaceOperationError)
	fc.Result = res
	return ec.marshalNInterfaceOperationError2backendgraphmodelInterfaceOperationError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BatchInterfacePayload_failed(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BatchInterfacePayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "interfaceId":
				return ec.fieldContext_InterfaceOperationError_interfaceId(ctx, field)
			case "interfaceName":
				return ec.fieldContext_InterfaceOperationError_interfaceName(ctx, field)
			case "error":
				return ec.fieldContext_InterfaceOperationError_error(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type InterfaceOperationError", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _BatchInterfacePayload_errors(ctx context.Context, field graphql.CollectedField, obj *model.BatchInterfacePayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BatchInterfacePayload_errors(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Errors, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.MutationError)
	fc.Result = res
	return ec.marshalOMutationError2backendgraphmodelMutationError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BatchInterfacePayload_errors(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BatchInterfacePayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "code":
				return ec.fieldContext_MutationError_code(ctx, field)
			case "message":
				return ec.fieldContext_MutationError_message(ctx, field)
			case "field":
				return ec.fieldContext_MutationError_field(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MutationError", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Bridge_id(ctx context.Context, field graphql.CollectedField, obj *model.Bridge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Bridge_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Bridge_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Bridge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Bridge_name(ctx context.Context, field graphql.CollectedField, obj *model.Bridge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Bridge_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Bridge_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Bridge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Bridge_comment(ctx context.Context, field graphql.CollectedField, obj *model.Bridge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Bridge_comment(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Comment, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Bridge_comment(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Bridge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Bridge_disabled(ctx context.Context, field graphql.CollectedField, obj *model.Bridge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Bridge_disabled(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Disabled, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Bridge_disabled(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Bridge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Bridge_running(ctx context.Context, field graphql.CollectedField, obj *model.Bridge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Bridge_running(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Running, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Bridge_running(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Bridge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Bridge_macAddress(ctx context.Context, field graphql.CollectedField, obj *model.Bridge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Bridge_macAddress(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MacAddress, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.MAC)
	fc.Result = res
	return ec.marshalOMAC2backendgraphmodelMAC(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Bridge_macAddress(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Bridge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type MAC does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Bridge_mtu(ctx context.Context, field graphql.CollectedField, obj *model.Bridge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Bridge_mtu(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Mtu, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			min, err := ec.unmarshalOInt2int(ctx, 68)
			if err != nil {
				return nil, err
			}
			max, err := ec.unmarshalOInt2int(ctx, 65535)
			if err != nil {
				return nil, err
			}
			if ec.directives.Validate == nil {
				return nil, errors.New("directive validate is not implemented")
			}
			return ec.directives.Validate(ctx, obj, directive0, min, max, nil, nil, nil, nil)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*int); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *int`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Bridge_mtu(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Bridge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Bridge_protocol(ctx context.Context, field graphql.CollectedField, obj *model.Bridge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Bridge_protocol(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Protocol, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.StpProtocol)
	fc.Result = res
	return ec.marshalNStpProtocol2backendgraphmodelStpProtocol(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Bridge_protocol(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Bridge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type StpProtocol does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Bridge_priority(ctx context.Context, field graphql.CollectedField, obj *model.Bridge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Bridge_priority(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Priority, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			min, err := ec.unmarshalOInt2int(ctx, 0)
			if err != nil {
				return nil, err
			}
			max, err := ec.unmarshalOInt2int(ctx, 61440)
			if err != nil {
				return nil, err
			}
			if ec.directives.Validate == nil {
				return nil, errors.New("directive validate is not implemented")
			}
			return ec.directives.Validate(ctx, obj, directive0, min, max, nil, nil, nil, nil)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*int); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *int`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Bridge_priority(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Bridge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Bridge_vlanFiltering(ctx context.Context, field graphql.CollectedField, obj *model.Bridge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Bridge_vlanFiltering(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.VlanFiltering, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Bridge_vlanFiltering(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Bridge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Bridge_pvid(ctx context.Context, field graphql.CollectedField, obj *model.Bridge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Bridge_pvid(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Pvid, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			min, err := ec.unmarshalOInt2int(ctx, 1)
			if err != nil {
				return nil, err
			}
			max, err := ec.unmarshalOInt2int(ctx, 4094)
			if err != nil {
				return nil, err
			}
			if ec.directives.Validate == nil {
				return nil, errors.New("directive validate is not implemented")
			}
			return ec.directives.Validate(ctx, obj, directive0, min, max, nil, nil, nil, nil)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*int); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *int`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Bridge_pvid(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Bridge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Bridge_ports(ctx context.Context, field graphql.CollectedField, obj *model.Bridge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Bridge_ports(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Ports, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.BridgePort)
	fc.Result = res
	return ec.marshalNBridgePort2backendgraphmodelBridgePort(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Bridge_ports(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Bridge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_BridgePort_id(ctx, field)
			case "bridge":
				return ec.fieldContext_BridgePort_bridge(ctx, field)
			case "interface":
				return ec.fieldContext_BridgePort_interface(ctx, field)
			case "pvid":
				return ec.fieldContext_BridgePort_pvid(ctx, field)
			case "frameTypes":
				return ec.fieldContext_BridgePort_frameTypes(ctx, field)
			case "ingressFiltering":
				return ec.fieldContext_BridgePort_ingressFiltering(ctx, field)
			case "taggedVlans":
				return ec.fieldContext_BridgePort_taggedVlans(ctx, field)
			case "untaggedVlans":
				return ec.fieldContext_BridgePort_untaggedVlans(ctx, field)
			case "role":
				return ec.fieldContext_BridgePort_role(ctx, field)
			case "state":
				return ec.fieldContext_BridgePort_state(ctx, field)
			case "pathCost":
				return ec.fieldContext_BridgePort_pathCost(ctx, field)
			case "edge":
				return ec.fieldContext_BridgePort_edge(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type BridgePort", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Bridge_vlans(ctx context.Context, field graphql.CollectedField, obj *model.Bridge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Bridge_vlans(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Vlans, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.BridgeVlan)
	fc.Result = res
	return ec.marshalNBridgeVlan2backendgraphmodelBridgeVlan(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Bridge_vlans(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Bridge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "uuid":
				return ec.fieldContext_BridgeVlan_uuid(ctx, field)
			case "bridge":
				return ec.fieldContext_BridgeVlan_bridge(ctx, field)
			case "vlanId":
				return ec.fieldContext_BridgeVlan_vlanId(ctx, field)
			case "taggedPorts":
				return ec.fieldContext_BridgeVlan_taggedPorts(ctx, field)
			case "untaggedPorts":
				return ec.fieldContext_BridgeVlan_untaggedPorts(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type BridgeVlan", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Bridge_ipAddresses(ctx context.Context, field graphql.CollectedField, obj *model.Bridge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Bridge_ipAddresses(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IPAddresses, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.IPAddress)
	fc.Result = res
	return ec.marshalNIpAddress2backendgraphmodelIPAddress(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Bridge_ipAddresses(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Bridge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_IpAddress_id(ctx, field)
			case "address":
				return ec.fieldContext_IpAddress_address(ctx, field)
			case "network":
				return ec.fieldContext_IpAddress_network(ctx, field)
			case "broadcast":
				return ec.fieldContext_IpAddress_broadcast(ctx, field)
			case "interface":
				return ec.fieldContext_IpAddress_interface(ctx, field)
			case "disabled":
				return ec.fieldContext_IpAddress_disabled(ctx, field)
			case "dynamic":
				return ec.fieldContext_IpAddress_dynamic(ctx, field)
			case "invalid":
				return ec.fieldContext_IpAddress_invalid(ctx, field)
			case "comment":
				return ec.fieldContext_IpAddress_comment(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type IpAddress", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Bridge_stpStatus(ctx context.Context, field graphql.CollectedField, obj *model.Bridge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Bridge_stpStatus(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StpStatus, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.BridgeStpStatus)
	fc.Result = res
	return ec.marshalOBridgeStpStatus2backendgraphmodelBridgeStpStatus(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Bridge_stpStatus(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Bridge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "rootBridge":
				return ec.fieldContext_BridgeStpStatus_rootBridge(ctx, field)
			case "rootBridgeId":
				return ec.fieldContext_BridgeStpStatus_rootBridgeId(ctx, field)
			case "rootPort":
				return ec.fieldContext_BridgeStpStatus_rootPort(ctx, field)
			case "rootPathCost":
				return ec.fieldContext_BridgeStpStatus_rootPathCost(ctx, field)
			case "topologyChangeCount":
				return ec.fieldContext_BridgeStpStatus_topologyChangeCount(ctx, field)
			case "lastTopologyChange":
				return ec.fieldContext_BridgeStpStatus_lastTopologyChange(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type BridgeStpStatus", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Bridge_dependentDhcpServers(ctx context.Context, field graphql.CollectedField, obj *model.Bridge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Bridge_dependentDhcpServers(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DependentDhcpServers, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.DhcpServer)
	fc.Result = res
	return ec.marshalNDhcpServer2backendgraphmodelDhcpServer(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Bridge_dependentDhcpServers(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Bridge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_DhcpServer_id(ctx, field)
			case "name":
				return ec.fieldContext_DhcpServer_name(ctx, field)
			case "interface":
				return ec.fieldContext_DhcpServer_interface(ctx, field)
			case "disabled":
				return ec.fieldContext_DhcpServer_disabled(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DhcpServer", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Bridge_dependentRoutes(ctx context.Context, field graphql.CollectedField, obj *model.Bridge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Bridge_dependentRoutes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DependentRoutes, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.Route)
	fc.Result = res
	return ec.marshalNRoute2backendgraphmodelRoute(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Bridge_dependentRoutes(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Bridge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Route_id(ctx, field)
			case "destination":
				return ec.fieldContext_Route_destination(ctx, field)
			case "gateway":
				return ec.fieldContext_Route_gateway(ctx, field)
			case "interface":
				return ec.fieldContext_Route_interface(ctx, field)
			case "distance":
				return ec.fieldContext_Route_distance(ctx, field)
			case "routingMark":
				return ec.fieldContext_Route_routingMark(ctx, field)
			case "routingTable":
				return ec.fieldContext_Route_routingTable(ctx, field)
			case "type":
				return ec.fieldContext_Route_type(ctx, field)
			case "scope":
				return ec.fieldContext_Route_scope(ctx, field)
			case "comment":
				return ec.fieldContext_Route_comment(ctx, field)
			case "active":
				return ec.fieldContext_Route_active(ctx, field)
			case "disabled":
				return ec.fieldContext_Route_disabled(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Route", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _BridgeMutationResult_success(ctx context.Context, field graphql.CollectedField, obj *model.BridgeMutationResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BridgeMutationResult_success(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Success, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BridgeMutationResult_success(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BridgeMutationResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BridgeMutationResult_bridge(ctx context.Context, field graphql.CollectedField, obj *model.BridgeMutationResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BridgeMutationResult_bridge(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Bridge, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Bridge)
	fc.Result = res
	return ec.marshalOBridge2backendgraphmodelBridge(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BridgeMutationResult_bridge(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BridgeMutationResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Bridge_id(ctx, field)
			case "name":
				return ec.fieldContext_Bridge_name(ctx, field)
			case "comment":
				return ec.fieldContext_Bridge_comment(ctx, field)
			case "disabled":
				return ec.fieldContext_Bridge_disabled(ctx, field)
			case "running":
				return ec.fieldContext_Bridge_running(ctx, field)
			case "macAddress":
				return ec.fieldContext_Bridge_macAddress(ctx, field)
			case "mtu":
				return ec.fieldContext_Bridge_mtu(ctx, field)
			case "protocol":
				return ec.fieldContext_Bridge_protocol(ctx, field)
			case "priority":
				return ec.fieldContext_Bridge_priority(ctx, field)
			case "vlanFiltering":
				return ec.fieldContext_Bridge_vlanFiltering(ctx, field)
			case "pvid":
				return ec.fieldContext_Bridge_pvid(ctx, field)
			case "ports":
				return ec.fieldContext_Bridge_ports(ctx, field)
			case "vlans":
				return ec.fieldContext_Bridge_vlans(ctx, field)
			case "ipAddresses":
				return ec.fieldContext_Bridge_ipAddresses(ctx, field)
			case "stpStatus":
				return ec.fieldContext_Bridge_stpStatus(ctx, field)
			case "dependentDhcpServers":
				return ec.fieldContext_Bridge_dependentDhcpServers(ctx, field)
			case "dependentRoutes":
				return ec.fieldContext_Bridge_dependentRoutes(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Bridge", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _BridgeMutationResult_errors(ctx context.Context, field graphql.CollectedField, obj *model.BridgeMutationResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BridgeMutationResult_errors(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Errors, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.MutationError)
	fc.Result = res
	return ec.marshalOMutationError2backendgraphmodelMutationError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BridgeMutationResult_errors(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BridgeMutationResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "code":
				return ec.fieldContext_MutationError_code(ctx, field)
			case "message":
				return ec.fieldContext_MutationError_message(ctx, field)
			case "field":
				return ec.fieldContext_MutationError_field(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MutationError", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _BridgeMutationResult_previousState(ctx context.Context, field graphql.CollectedField, obj *model.BridgeMutationResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BridgeMutationResult_previousState(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PreviousState, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOJSON2map(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BridgeMutationResult_previousState(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BridgeMutationResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type JSON does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BridgeMutationResult_operationId(ctx context.Context, field graphql.CollectedField, obj *model.BridgeMutationResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BridgeMutationResult_operationId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OperationID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BridgeMutationResult_operationId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BridgeMutationResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BridgePort_id(ctx context.Context, field graphql.CollectedField, obj *model.BridgePort) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BridgePort_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BridgePort_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BridgePort",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BridgePort_bridge(ctx context.Context, field graphql.CollectedField, obj *model.BridgePort) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BridgePort_bridge(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Bridge, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Bridge)
	fc.Result = res
	return ec.marshalNBridge2backendgraphmodelBridge(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BridgePort_bridge(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BridgePort",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Bridge_id(ctx, field)
			case "name":
				return ec.fieldContext_Bridge_name(ctx, field)
			case "comment":
				return ec.fieldContext_Bridge_comment(ctx, field)
			case "disabled":
				return ec.fieldContext_Bridge_disabled(ctx, field)
			case "running":
				return ec.fieldContext_Bridge_running(ctx, field)
			case "macAddress":
				return ec.fieldContext_Bridge_macAddress(ctx, field)
			case "mtu":
				return ec.fieldContext_Bridge_mtu(ctx, field)
			case "protocol":
				return ec.fieldContext_Bridge_protocol(ctx, field)
			case "priority":
				return ec.fieldContext_Bridge_priority(ctx, field)
			case "vlanFiltering":
				return ec.fieldContext_Bridge_vlanFiltering(ctx, field)
			case "pvid":
				return ec.fieldContext_Bridge_pvid(ctx, field)
			case "ports":
				return ec.fieldContext_Bridge_ports(ctx, field)
			case "vlans":
				return ec.fieldContext_Bridge_vlans(ctx, field)
			case "ipAddresses":
				return ec.fieldContext_Bridge_ipAddresses(ctx, field)
			case "stpStatus":
				return ec.fieldContext_Bridge_stpStatus(ctx, field)
			case "dependentDhcpServers":
				return ec.fieldContext_Bridge_dependentDhcpServers(ctx, field)
			case "dependentRoutes":
				return ec.fieldContext_Bridge_dependentRoutes(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Bridge", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _BridgePort_interface(ctx context.Context, field graphql.CollectedField, obj *model.BridgePort) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BridgePort_interface(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Interface, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Interface)
	fc.Result = res
	return ec.marshalNInterface2backendgraphmodelInterface(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BridgePort_interface(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BridgePort",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Interface_id(ctx, field)
			case "name":
				return ec.fieldContext_Interface_name(ctx, field)
			case "type":
				return ec.fieldContext_Interface_type(ctx, field)
			case "enabled":
				return ec.fieldContext_Interface_enabled(ctx, field)
			case "running":
				return ec.fieldContext_Interface_running(ctx, field)
			case "macAddress":
				return ec.fieldContext_Interface_macAddress(ctx, field)
			case "mtu":
				return ec.fieldContext_Interface_mtu(ctx, field)
			case "comment":
				return ec.fieldContext_Interface_comment(ctx, field)
			case "txBytes":
				return ec.fieldContext_Interface_txBytes(ctx, field)
			case "rxBytes":
				return ec.fieldContext_Interface_rxBytes(ctx, field)
			case "ip":
				return ec.fieldContext_Interface_ip(ctx, field)
			case "status":
				return ec.fieldContext_Interface_status(ctx, field)
			case "txRate":
				return ec.fieldContext_Interface_txRate(ctx, field)
			case "rxRate":
				return ec.fieldContext_Interface_rxRate(ctx, field)
			case "linkSpeed":
				return ec.fieldContext_Interface_linkSpeed(ctx, field)
			case "lastSeen":
				return ec.fieldContext_Interface_lastSeen(ctx, field)
			case "linkPartner":
				return ec.fieldContext_Interface_linkPartner(ctx, field)
			case "usedBy":
				return ec.fieldContext_Interface_usedBy(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Interface", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _BridgePort_pvid(ctx context.Context, field graphql.CollectedField, obj *model.BridgePort) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BridgePort_pvid(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Pvid, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			min, err := ec.unmarshalOInt2int(ctx, 1)
			if err != nil {
				return nil, err
			}
			max, err := ec.unmarshalOInt2int(ctx, 4094)
			if err != nil {
				return nil, err
			}
			if ec.directives.Validate == nil {
				return nil, errors.New("directive validate is not implemented")
			}
			return ec.directives.Validate(ctx, obj, directive0, min, max, nil, nil, nil, nil)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(int); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be int`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BridgePort_pvid(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BridgePort",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BridgePort_frameTypes(ctx context.Context, field graphql.CollectedField, obj *model.BridgePort) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BridgePort_frameTypes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FrameTypes, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.FrameTypes)
	fc.Result = res
	return ec.marshalNFrameTypes2backendgraphmodelFrameTypes(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BridgePort_frameTypes(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BridgePort",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type FrameTypes does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BridgePort_ingressFiltering(ctx context.Context, field graphql.CollectedField, obj *model.BridgePort) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BridgePort_ingressFiltering(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IngressFiltering, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BridgePort_ingressFiltering(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BridgePort",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BridgePort_taggedVlans(ctx context.Context, field graphql.CollectedField, obj *model.BridgePort) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BridgePort_taggedVlans(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TaggedVlans, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BridgePort_taggedVlans(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BridgePort",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BridgePort_untaggedVlans(ctx context.Context, field graphql.CollectedField, obj *model.BridgePort) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BridgePort_untaggedVlans(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UntaggedVlans, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BridgePort_untaggedVlans(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BridgePort",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BridgePort_role(ctx context.Context, field graphql.CollectedField, obj *model.BridgePort) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BridgePort_role(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Role, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.StpPortRole)
	fc.Result = res
	return ec.marshalNStpPortRole2backendgraphmodelStpPortRole(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BridgePort_role(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BridgePort",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type StpPortRole does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BridgePort_state(ctx context.Context, field graphql.CollectedField, obj *model.BridgePort) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BridgePort_state(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.State, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.StpPortState)
	fc.Result = res
	return ec.marshalNStpPortState2backendgraphmodelStpPortState(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BridgePort_state(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BridgePort",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type StpPortState does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BridgePort_pathCost(ctx context.Context, field graphql.CollectedField, obj *model.BridgePort) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BridgePort_pathCost(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PathCost, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BridgePort_pathCost(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BridgePort",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BridgePort_edge(ctx context.Context, field graphql.CollectedField, obj *model.BridgePort) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BridgePort_edge(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Edge, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BridgePort_edge(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BridgePort",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BridgePortMutationResult_success(ctx context.Context, field graphql.CollectedField, obj *model.BridgePortMutationResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BridgePortMutationResult_success(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Success, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BridgePortMutationResult_success(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BridgePortMutationResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BridgePortMutationResult_port(ctx context.Context, field graphql.CollectedField, obj *model.BridgePortMutationResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BridgePortMutationResult_port(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Port, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.BridgePort)
	fc.Result = res
	return ec.marshalOBridgePort2backendgraphmodelBridgePort(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BridgePortMutationResult_port(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BridgePortMutationResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_BridgePort_id(ctx, field)
			case "bridge":
				return ec.fieldContext_BridgePort_bridge(ctx, field)
			case "interface":
				return ec.fieldContext_BridgePort_interface(ctx, field)
			case "pvid":
				return ec.fieldContext_BridgePort_pvid(ctx, field)
			case "frameTypes":
				return ec.fieldContext_BridgePort_frameTypes(ctx, field)
			case "ingressFiltering":
				return ec.fieldContext_BridgePort_ingressFiltering(ctx, field)
			case "taggedVlans":
				return ec.fieldContext_BridgePort_taggedVlans(ctx, field)
			case "untaggedVlans":
				return ec.fieldContext_BridgePort_untaggedVlans(ctx, field)
			case "role":
				return ec.fieldContext_BridgePort_role(ctx, field)
			case "state":
				return ec.fieldContext_BridgePort_state(ctx, field)
			case "pathCost":
				return ec.fieldContext_BridgePort_pathCost(ctx, field)
			case "edge":
				return ec.fieldContext_BridgePort_edge(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type BridgePort", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _BridgePortMutationResult_errors(ctx context.Context, field graphql.CollectedField, obj *model.BridgePortMutationResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BridgePortMutationResult_errors(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Errors, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.MutationError)
	fc.Result = res
	return ec.marshalOMutationError2backendgraphmodelMutationError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BridgePortMutationResult_errors(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BridgePortMutationResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "code":
				return ec.fieldContext_MutationError_code(ctx, field)
			case "message":
				return ec.fieldContext_MutationError_message(ctx, field)
			case "field":
				return ec.fieldContext_MutationError_field(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MutationError", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _BridgePortMutationResult_previousState(ctx context.Context, field graphql.CollectedField, obj *model.BridgePortMutationResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BridgePortMutationResult_previousState(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PreviousState, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOJSON2map(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BridgePortMutationResult_previousState(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BridgePortMutationResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type JSON does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BridgePortMutationResult_operationId(ctx context.Context, field graphql.CollectedField, obj *model.BridgePortMutationResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BridgePortMutationResult_operationId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OperationID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BridgePortMutationResult_operationId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BridgePortMutationResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BridgePortVlanConfig_portId(ctx context.Context, field graphql.CollectedField, obj *model.BridgePortVlanConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BridgePortVlanConfig_portId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PortID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BridgePortVlanConfig_portId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BridgePortVlanConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BridgePortVlanConfig_pvid(ctx context.Context, field graphql.CollectedField, obj *model.BridgePortVlanConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BridgePortVlanConfig_pvid(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Pvid, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			min, err := ec.unmarshalOInt2int(ctx, 1)
			if err != nil {
				return nil, err
			}
			max, err := ec.unmarshalOInt2int(ctx, 4094)
			if err != nil {
				return nil, err
			}
			if ec.directives.Validate == nil {
				return nil, errors.New("directive validate is not implemented")
			}
			return ec.directives.Validate(ctx, obj, directive0, min, max, nil, nil, nil, nil)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(int); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be int`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BridgePortVlanConfig_pvid(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BridgePortVlanConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BridgePortVlanConfig_frameTypes(ctx context.Context, field graphql.CollectedField, obj *model.BridgePortVlanConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BridgePortVlanConfig_frameTypes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FrameTypes, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.BridgePortFrameTypes)
	fc.Result = res
	return ec.marshalNBridgePortFrameTypes2backendgraphmodelBridgePortFrameTypes(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BridgePortVlanConfig_frameTypes(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BridgePortVlanConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type BridgePortFrameTypes does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BridgePortVlanConfig_taggedVlans(ctx context.Context, field graphql.CollectedField, obj *model.BridgePortVlanConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BridgePortVlanConfig_taggedVlans(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.TaggedVlans, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			min, err := ec.unmarshalOInt2int(ctx, 1)
			if err != nil {
				return nil, err
			}
			max, err := ec.unmarshalOInt2int(ctx, 4094)
			if err != nil {
				return nil, err
			}
			if ec.directives.Validate == nil {
				return nil, errors.New("directive validate is not implemented")
			}
			return ec.directives.Validate(ctx, obj, directive0, min, max, nil, nil, nil, nil)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]int); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []int`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BridgePortVlanConfig_taggedVlans(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BridgePortVlanConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BridgePortVlanConfig_untaggedVlans(ctx context.Context, field graphql.CollectedField, obj *model.BridgePortVlanConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BridgePortVlanConfig_untaggedVlans(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.UntaggedVlans, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			min, err := ec.unmarshalOInt2int(ctx, 1)
			if err != nil {
				return nil, err
			}
			max, err := ec.unmarshalOInt2int(ctx, 4094)
			if err != nil {
				return nil, err
			}
			if ec.directives.Validate == nil {
				return nil, errors.New("directive validate is not implemented")
			}
			return ec.directives.Validate(ctx, obj, directive0, min, max, nil, nil, nil, nil)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]int); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []int`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BridgePortVlanConfig_untaggedVlans(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BridgePortVlanConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BridgePortVlanConfig_mode(ctx context.Context, field graphql.CollectedField, obj *model.BridgePortVlanConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BridgePortVlanConfig_mode(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Mode, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.PortMode)
	fc.Result = res
	return ec.marshalNPortMode2backendgraphmodelPortMode(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BridgePortVlanConfig_mode(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BridgePortVlanConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type PortMode does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BridgeResource_id(ctx context.Context, field graphql.CollectedField, obj *model.BridgeResource) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BridgeResource_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BridgeResource_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BridgeResource",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BridgeResource_scopedId(ctx context.Context, field graphql.CollectedField, obj *model.BridgeResource) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BridgeResource_scopedId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ScopedID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BridgeResource_scopedId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BridgeResource",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BridgeResource_type(ctx context.Context, field graphql.CollectedField, obj *model.BridgeResource) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BridgeResource_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BridgeResource_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BridgeResource",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BridgeResource_category(ctx context.Context, field graphql.CollectedField, obj *model.BridgeResource) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BridgeResource_category(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Category, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.ResourceCategory)
	fc.Result = res
	return ec.marshalNResourceCategory2backendgraphmodelResourceCategory(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BridgeResource_category(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BridgeResource",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ResourceCategory does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BridgeResource_configuration(ctx context.Context, field graphql.CollectedField, obj *model.BridgeResource) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BridgeResource_configuration(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Configuration, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalNJSON2map(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BridgeResource_configuration(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BridgeResource",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type JSON does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BridgeResource_validation(ctx context.Context, field graphql.CollectedField, obj *model.BridgeResource) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BridgeResource_validation(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Validation, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.ValidationResult)
	fc.Result = res
	return ec.marshalOValidationResult2backendgraphmodelValidationResult(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BridgeResource_validation(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BridgeResource",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "canApply":
				return ec.fieldContext_ValidationResult_canApply(ctx, field)
			case "stage":
				return ec.fieldContext_ValidationResult_stage(ctx, field)
			case "errors":
				return ec.fieldContext_ValidationResult_errors(ctx, field)
			case "warnings":
				return ec.fieldContext_ValidationResult_warnings(ctx, field)
			case "conflicts":
				return ec.fieldContext_ValidationResult_conflicts(ctx, field)
			case "requiredDependencies":
				return ec.fieldContext_ValidationResult_requiredDependencies(ctx, field)
			case "validatedAt":
				return ec.fieldContext_ValidationResult_validatedAt(ctx, field)
			case "validationDurationMs":
				return ec.fieldContext_ValidationResult_validationDurationMs(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ValidationResult", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _BridgeResource_deployment(ctx context.Context, field graphql.CollectedField, obj *model.BridgeResource) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BridgeResource_deployment(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Deployment, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.DeploymentState)
	fc.Result = res
	return ec.marshalODeploymentState2backendgraphmodelDeploymentState(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BridgeResource_deployment(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BridgeResource",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "routerResourceId":
				return ec.fieldContext_DeploymentState_routerResourceId(ctx, field)
			case "appliedAt":
				return ec.fieldContext_DeploymentState_appliedAt(ctx, field)
			case "appliedBy":
				return ec.fieldContext_DeploymentState_appliedBy(ctx, field)
			case "routerVersion":
				return ec.fieldContext_DeploymentState_routerVersion(ctx, field)
			case "generatedFields":
				return ec.fieldContext_DeploymentState_generatedFields(ctx, field)
			case "isInSync":
				return ec.fieldContext_DeploymentState_isInSync(ctx, field)
			case "drift":
				return ec.fieldContext_DeploymentState_drift(ctx, field)
			case "applyOperationId":
				return ec.fieldContext_DeploymentState_applyOperationId(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DeploymentState", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _BridgeResource_runtime(ctx context.Context, field graphql.CollectedField, obj *model.BridgeResource) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BridgeResource_runtime(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Runtime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.RuntimeState)
	fc.Result = res
	return ec.marshalORuntimeState2backendgraphmodelRuntimeState(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BridgeResource_runtime(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BridgeResource",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "isRunning":
				return ec.fieldContext_RuntimeState_isRunning(ctx, field)
			case "health":
				return ec.fieldContext_RuntimeState_health(ctx, field)
			case "errorMessage":
				return ec.fieldContext_RuntimeState_errorMessage(ctx, field)
			case "metrics":
				return ec.fieldContext_RuntimeState_metrics(ctx, field)
			case "lastUpdated":
				return ec.fieldContext_RuntimeState_lastUpdated(ctx, field)
			case "lastSuccessfulOperation":
				return ec.fieldContext_RuntimeState_lastSuccessfulOperation(ctx, field)
			case "activeConnections":
				return ec.fieldContext_RuntimeState_activeConnections(ctx, field)
			case "uptime":
				return ec.fieldContext_RuntimeState_uptime(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RuntimeState", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _BridgeResource_telemetry(ctx context.Context, field graphql.CollectedField, obj *model.BridgeResource) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BridgeResource_telemetry(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Telemetry, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.TelemetryData)
	fc.Result = res
	return ec.marshalOTelemetryData2backendgraphmodelTelemetryData(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BridgeResource_telemetry(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BridgeResource",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "bandwidthHistory":
				return ec.fieldContext_TelemetryData_bandwidthHistory(ctx, field)
			case "uptimeHistory":
				return ec.fieldContext_TelemetryData_uptimeHistory(ctx, field)
			case "hourlyStats":
				return ec.fieldContext_TelemetryData_hourlyStats(ctx, field)
			case "dailyStats":
				return ec.fieldContext_TelemetryData_dailyStats(ctx, field)
			case "dataStartedAt":
				return ec.fieldContext_TelemetryData_dataStartedAt(ctx, field)
			case "lastUpdatedAt":
				return ec.fieldContext_TelemetryData_lastUpdatedAt(ctx, field)
			case "retentionDays":
				return ec.fieldContext_TelemetryData_retentionDays(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TelemetryData", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _BridgeResource_metadata(ctx context.Context, field graphql.CollectedField, obj *model.BridgeResource) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BridgeResource_metadata(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Metadata, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.ResourceMetadata)
	fc.Result = res
	return ec.marshalNResourceMetadata2backendgraphmodelResourceMetadata(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BridgeResource_metadata(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BridgeResource",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "createdAt":
				return ec.fieldContext_ResourceMetadata_createdAt(ctx, field)
			case "createdBy":
				return ec.fieldContext_ResourceMetadata_createdBy(ctx, field)
			case "updatedAt":
				return ec.fieldContext_ResourceMetadata_updatedAt(ctx, field)
			case "updatedBy":
				return ec.fieldContext_ResourceMetadata_updatedBy(ctx, field)
			case "state":
				return ec.fieldContext_ResourceMetadata_state(ctx, field)
			case "version":
				return ec.fieldContext_ResourceMetadata_version(ctx, field)
			case "tags":
				return ec.fieldContext_ResourceMetadata_tags(ctx, field)
			case "description":
				return ec.fieldContext_ResourceMetadata_description(ctx, field)
			case "isFavorite":
				return ec.fieldContext_ResourceMetadata_isFavorite(ctx, field)
			case "isPinned":
				return ec.fieldContext_ResourceMetadata_isPinned(ctx, field)
			case "notes":
				return ec.fieldContext_ResourceMetadata_notes(ctx, field)
			case "recentChanges":
				return ec.fieldContext_ResourceMetadata_recentChanges(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ResourceMetadata", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _BridgeResource_relationships(ctx context.Context, field graphql.CollectedField, obj *model.BridgeResource) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BridgeResource_relationships(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Relationships, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.ResourceRelationships)
	fc.Result = res
	return ec.marshalOResourceRelationships2backendgraphmodelResourceRelationships(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BridgeResource_relationships(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BridgeResource",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "dependsOn":
				return ec.fieldContext_ResourceRelationships_dependsOn(ctx, field)
			case "dependents":
				return ec.fieldContext_ResourceRelationships_dependents(ctx, field)
			case "routesVia":
				return ec.fieldContext_ResourceRelationships_routesVia(ctx, field)
			case "routedBy":
				return ec.fieldContext_ResourceRelationships_routedBy(ctx, field)
			case "parent":
				return ec.fieldContext_ResourceRelationships_parent(ctx, field)
			case "children":
				return ec.fieldContext_ResourceRelationships_children(ctx, field)
			case "custom":
				return ec.fieldContext_ResourceRelationships_custom(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ResourceRelationships", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _BridgeResource_platform(ctx context.Context, field graphql.CollectedField, obj *model.BridgeResource) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BridgeResource_platform(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Platform, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.PlatformInfo)
	fc.Result = res
	return ec.marshalOPlatformInfo2backendgraphmodelPlatformInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BridgeResource_platform(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BridgeResource",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "current":
				return ec.fieldContext_PlatformInfo_current(ctx, field)
			case "capabilities":
				return ec.fieldContext_PlatformInfo_capabilities(ctx, field)
			case "fieldMappings":
				return ec.fieldContext_PlatformInfo_fieldMappings(ctx, field)
			case "limitations":
				return ec.fieldContext_PlatformInfo_limitations(ctx, field)
			case "features":
				return ec.fieldContext_PlatformInfo_features(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PlatformInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _BridgeResource_name(ctx context.Context, field graphql.CollectedField, obj *model.BridgeResource) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BridgeResource_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BridgeResource_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BridgeResource",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BridgeResource_ports(ctx context.Context, field graphql.CollectedField, obj *model.BridgeResource) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BridgeResource_ports(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Ports, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BridgeResource_ports(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BridgeResource",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BridgeResource_protocolMode(ctx context.Context, field graphql.CollectedField, obj *model.BridgeResource) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BridgeResource_protocolMode(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ProtocolMode, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BridgeResource_protocolMode(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BridgeResource",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BridgeStpStatus_rootBridge(ctx context.Context, field graphql.CollectedField, obj *model.BridgeStpStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BridgeStpStatus_rootBridge(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RootBridge, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BridgeStpStatus_rootBridge(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BridgeStpStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BridgeStpStatus_rootBridgeId(ctx context.Context, field graphql.CollectedField, obj *model.BridgeStpStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BridgeStpStatus_rootBridgeId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RootBridgeID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BridgeStpStatus_rootBridgeId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BridgeStpStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BridgeStpStatus_rootPort(ctx context.Context, field graphql.CollectedField, obj *model.BridgeStpStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BridgeStpStatus_rootPort(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RootPort, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BridgeStpStatus_rootPort(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BridgeStpStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BridgeStpStatus_rootPathCost(ctx context.Context, field graphql.CollectedField, obj *model.BridgeStpStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BridgeStpStatus_rootPathCost(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RootPathCost, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BridgeStpStatus_rootPathCost(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BridgeStpStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BridgeStpStatus_topologyChangeCount(ctx context.Context, field graphql.CollectedField, obj *model.BridgeStpStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BridgeStpStatus_topologyChangeCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TopologyChangeCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BridgeStpStatus_topologyChangeCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BridgeStpStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BridgeStpStatus_lastTopologyChange(ctx context.Context, field graphql.CollectedField, obj *model.BridgeStpStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BridgeStpStatus_lastTopologyChange(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LastTopologyChange, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalODateTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BridgeStpStatus_lastTopologyChange(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BridgeStpStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DateTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BridgeVlan_uuid(ctx context.Context, field graphql.CollectedField, obj *model.BridgeVlan) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BridgeVlan_uuid(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UUID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BridgeVlan_uuid(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BridgeVlan",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BridgeVlan_bridge(ctx context.Context, field graphql.CollectedField, obj *model.BridgeVlan) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BridgeVlan_bridge(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Bridge, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Bridge)
	fc.Result = res
	return ec.marshalNBridge2backendgraphmodelBridge(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BridgeVlan_bridge(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BridgeVlan",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Bridge_id(ctx, field)
			case "name":
				return ec.fieldContext_Bridge_name(ctx, field)
			case "comment":
				return ec.fieldContext_Bridge_comment(ctx, field)
			case "disabled":
				return ec.fieldContext_Bridge_disabled(ctx, field)
			case "running":
				return ec.fieldContext_Bridge_running(ctx, field)
			case "macAddress":
				return ec.fieldContext_Bridge_macAddress(ctx, field)
			case "mtu":
				return ec.fieldContext_Bridge_mtu(ctx, field)
			case "protocol":
				return ec.fieldContext_Bridge_protocol(ctx, field)
			case "priority":
				return ec.fieldContext_Bridge_priority(ctx, field)
			case "vlanFiltering":
				return ec.fieldContext_Bridge_vlanFiltering(ctx, field)
			case "pvid":
				return ec.fieldContext_Bridge_pvid(ctx, field)
			case "ports":
				return ec.fieldContext_Bridge_ports(ctx, field)
			case "vlans":
				return ec.fieldContext_Bridge_vlans(ctx, field)
			case "ipAddresses":
				return ec.fieldContext_Bridge_ipAddresses(ctx, field)
			case "stpStatus":
				return ec.fieldContext_Bridge_stpStatus(ctx, field)
			case "dependentDhcpServers":
				return ec.fieldContext_Bridge_dependentDhcpServers(ctx, field)
			case "dependentRoutes":
				return ec.fieldContext_Bridge_dependentRoutes(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Bridge", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _BridgeVlan_vlanId(ctx context.Context, field graphql.CollectedField, obj *model.BridgeVlan) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BridgeVlan_vlanId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.VlanID, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			min, err := ec.unmarshalOInt2int(ctx, 1)
			if err != nil {
				return nil, err
			}
			max, err := ec.unmarshalOInt2int(ctx, 4094)
			if err != nil {
				return nil, err
			}
			if ec.directives.Validate == nil {
				return nil, errors.New("directive validate is not implemented")
			}
			return ec.directives.Validate(ctx, obj, directive0, min, max, nil, nil, nil, nil)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(int); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be int`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BridgeVlan_vlanId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BridgeVlan",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BridgeVlan_taggedPorts(ctx context.Context, field graphql.CollectedField, obj *model.BridgeVlan) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BridgeVlan_taggedPorts(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TaggedPorts, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.BridgePort)
	fc.Result = res
	return ec.marshalNBridgePort2backendgraphmodelBridgePort(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BridgeVlan_taggedPorts(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BridgeVlan",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_BridgePort_id(ctx, field)
			case "bridge":
				return ec.fieldContext_BridgePort_bridge(ctx, field)
			case "interface":
				return ec.fieldContext_BridgePort_interface(ctx, field)
			case "pvid":
				return ec.fieldContext_BridgePort_pvid(ctx, field)
			case "frameTypes":
				return ec.fieldContext_BridgePort_frameTypes(ctx, field)
			case "ingressFiltering":
				return ec.fieldContext_BridgePort_ingressFiltering(ctx, field)
			case "taggedVlans":
				return ec.fieldContext_BridgePort_taggedVlans(ctx, field)
			case "untaggedVlans":
				return ec.fieldContext_BridgePort_untaggedVlans(ctx, field)
			case "role":
				return ec.fieldContext_BridgePort_role(ctx, field)
			case "state":
				return ec.fieldContext_BridgePort_state(ctx, field)
			case "pathCost":
				return ec.fieldContext_BridgePort_pathCost(ctx, field)
			case "edge":
				return ec.fieldContext_BridgePort_edge(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type BridgePort", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _BridgeVlan_untaggedPorts(ctx context.Context, field graphql.CollectedField, obj *model.BridgeVlan) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BridgeVlan_untaggedPorts(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UntaggedPorts, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.BridgePort)
	fc.Result = res
	return ec.marshalNBridgePort2backendgraphmodelBridgePort(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BridgeVlan_untaggedPorts(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BridgeVlan",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_BridgePort_id(ctx, field)
			case "bridge":
				return ec.fieldContext_BridgePort_bridge(ctx, field)
			case "interface":
				return ec.fieldContext_BridgePort_interface(ctx, field)
			case "pvid":
				return ec.fieldContext_BridgePort_pvid(ctx, field)
			case "frameTypes":
				return ec.fieldContext_BridgePort_frameTypes(ctx, field)
			case "ingressFiltering":
				return ec.fieldContext_BridgePort_ingressFiltering(ctx, field)
			case "taggedVlans":
				return ec.fieldContext_BridgePort_taggedVlans(ctx, field)
			case "untaggedVlans":
				return ec.fieldContext_BridgePort_untaggedVlans(ctx, field)
			case "role":
				return ec.fieldContext_BridgePort_role(ctx, field)
			case "state":
				return ec.fieldContext_BridgePort_state(ctx, field)
			case "pathCost":
				return ec.fieldContext_BridgePort_pathCost(ctx, field)
			case "edge":
				return ec.fieldContext_BridgePort_edge(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type BridgePort", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _BridgeVlanMutationResult_success(ctx context.Context, field graphql.CollectedField, obj *model.BridgeVlanMutationResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BridgeVlanMutationResult_success(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Success, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BridgeVlanMutationResult_success(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BridgeVlanMutationResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BridgeVlanMutationResult_vlan(ctx context.Context, field graphql.CollectedField, obj *model.BridgeVlanMutationResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BridgeVlanMutationResult_vlan(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Vlan, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.BridgeVlan)
	fc.Result = res
	return ec.marshalOBridgeVlan2backendgraphmodelBridgeVlan(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BridgeVlanMutationResult_vlan(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BridgeVlanMutationResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "uuid":
				return ec.fieldContext_BridgeVlan_uuid(ctx, field)
			case "bridge":
				return ec.fieldContext_BridgeVlan_bridge(ctx, field)
			case "vlanId":
				return ec.fieldContext_BridgeVlan_vlanId(ctx, field)
			case "taggedPorts":
				return ec.fieldContext_BridgeVlan_taggedPorts(ctx, field)
			case "untaggedPorts":
				return ec.fieldContext_BridgeVlan_untaggedPorts(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type BridgeVlan", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _BridgeVlanMutationResult_errors(ctx context.Context, field graphql.CollectedField, obj *model.BridgeVlanMutationResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BridgeVlanMutationResult_errors(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Errors, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.MutationError)
	fc.Result = res
	return ec.marshalOMutationError2backendgraphmodelMutationError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BridgeVlanMutationResult_errors(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BridgeVlanMutationResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "code":
				return ec.fieldContext_MutationError_code(ctx, field)
			case "message":
				return ec.fieldContext_MutationError_message(ctx, field)
			case "field":
				return ec.fieldContext_MutationError_field(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MutationError", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _BulkAlertPayload_acknowledgedCount(ctx context.Context, field graphql.CollectedField, obj *model.BulkAlertPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BulkAlertPayload_acknowledgedCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AcknowledgedCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BulkAlertPayload_acknowledgedCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BulkAlertPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BulkAlertPayload_errors(ctx context.Context, field graphql.CollectedField, obj *model.BulkAlertPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BulkAlertPayload_errors(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Errors, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.MutationError)
	fc.Result = res
	return ec.marshalOMutationError2backendgraphmodelMutationError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BulkAlertPayload_errors(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BulkAlertPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "code":
				return ec.fieldContext_MutationError_code(ctx, field)
			case "message":
				return ec.fieldContext_MutationError_message(ctx, field)
			case "field":
				return ec.fieldContext_MutationError_field(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MutationError", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CPUMetrics_usage(ctx context.Context, field graphql.CollectedField, obj *model.CPUMetrics) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CPUMetrics_usage(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Usage, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CPUMetrics_usage(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CPUMetrics",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CPUMetrics_cores(ctx context.Context, field graphql.CollectedField, obj *model.CPUMetrics) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CPUMetrics_cores(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cores, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CPUMetrics_cores(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CPUMetrics",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CPUMetrics_perCore(ctx context.Context, field graphql.CollectedField, obj *model.CPUMetrics) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CPUMetrics_perCore(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PerCore, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CPUMetrics_perCore(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CPUMetrics",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CPUMetrics_frequency(ctx context.Context, field graphql.CollectedField, obj *model.CPUMetrics) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CPUMetrics_frequency(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Frequency, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CPUMetrics_frequency(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CPUMetrics",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CancelChangeSetPayload_changeSet(ctx context.Context, field graphql.CollectedField, obj *model.CancelChangeSetPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CancelChangeSetPayload_changeSet(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ChangeSet, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.ChangeSet)
	fc.Result = res
	return ec.marshalOChangeSet2backendgraphmodelChangeSet(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CancelChangeSetPayload_changeSet(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CancelChangeSetPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ChangeSet_id(ctx, field)
			case "name":
				return ec.fieldContext_ChangeSet_name(ctx, field)
			case "description":
				return ec.fieldContext_ChangeSet_description(ctx, field)
			case "routerId":
				return ec.fieldContext_ChangeSet_routerId(ctx, field)
			case "items":
				return ec.fieldContext_ChangeSet_items(ctx, field)
			case "status":
				return ec.fieldContext_ChangeSet_status(ctx, field)
			case "validation":
				return ec.fieldContext_ChangeSet_validation(ctx, field)
			case "rollbackPlan":
				return ec.fieldContext_ChangeSet_rollbackPlan(ctx, field)
			case "error":
				return ec.fieldContext_ChangeSet_error(ctx, field)
			case "createdAt":
				return ec.fieldContext_ChangeSet_createdAt(ctx, field)
			case "applyStartedAt":
				return ec.fieldContext_ChangeSet_applyStartedAt(ctx, field)
			case "completedAt":
				return ec.fieldContext_ChangeSet_completedAt(ctx, field)
			case "createdBy":
				return ec.fieldContext_ChangeSet_createdBy(ctx, field)
			case "source":
				return ec.fieldContext_ChangeSet_source(ctx, field)
			case "version":
				return ec.fieldContext_ChangeSet_version(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ChangeSet", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CancelChangeSetPayload_success(ctx context.Context, field graphql.CollectedField, obj *model.CancelChangeSetPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CancelChangeSetPayload_success(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Success, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CancelChangeSetPayload_success(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CancelChangeSetPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CancelChangeSetPayload_errors(ctx context.Context, field graphql.CollectedField, obj *model.CancelChangeSetPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CancelChangeSetPayload_errors(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Errors, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.MutationError)
	fc.Result = res
	return ec.marshalOMutationError2backendgraphmodelMutationError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CancelChangeSetPayload_errors(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CancelChangeSetPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "code":
				return ec.fieldContext_MutationError_code(ctx, field)
			case "message":
				return ec.fieldContext_MutationError_message(ctx, field)
			case "field":
				return ec.fieldContext_MutationError_field(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MutationError", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CancelScanPayload_task(ctx context.Context, field graphql.CollectedField, obj *model.CancelScanPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CancelScanPayload_task(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Task, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.ScanTask)
	fc.Result = res
	return ec.marshalOScanTask2backendgraphmodelScanTask(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CancelScanPayload_task(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CancelScanPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ScanTask_id(ctx, field)
			case "subnet":
				return ec.fieldContext_ScanTask_subnet(ctx, field)
			case "status":
				return ec.fieldContext_ScanTask_status(ctx, field)
			case "progress":
				return ec.fieldContext_ScanTask_progress(ctx, field)
			case "results":
				return ec.fieldContext_ScanTask_results(ctx, field)
			case "startTime":
				return ec.fieldContext_ScanTask_startTime(ctx, field)
			case "endTime":
				return ec.fieldContext_ScanTask_endTime(ctx, field)
			case "error":
				return ec.fieldContext_ScanTask_error(ctx, field)
			case "totalIPs":
				return ec.fieldContext_ScanTask_totalIPs(ctx, field)
			case "scannedIPs":
				return ec.fieldContext_ScanTask_scannedIPs(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ScanTask", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CancelScanPayload_errors(ctx context.Context, field graphql.CollectedField, obj *model.CancelScanPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CancelScanPayload_errors(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Errors, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.MutationError)
	fc.Result = res
	return ec.marshalOMutationError2backendgraphmodelMutationError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CancelScanPayload_errors(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CancelScanPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "code":
				return ec.fieldContext_MutationError_code(ctx, field)
			case "message":
				return ec.fieldContext_MutationError_message(ctx, field)
			case "field":
				return ec.fieldContext_MutationError_field(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MutationError", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CapabilityEntry_capability(ctx context.Context, field graphql.CollectedField, obj *model.CapabilityEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CapabilityEntry_capability(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Capability, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.Capability)
	fc.Result = res
	return ec.marshalNCapability2backendgraphmodelCapability(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CapabilityEntry_capability(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CapabilityEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Capability does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CapabilityEntry_level(ctx context.Context, field graphql.CollectedField, obj *model.CapabilityEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CapabilityEntry_level(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Level, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.CapabilityLevel)
	fc.Result = res
	return ec.marshalNCapabilityLevel2backendgraphmodelCapabilityLevel(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CapabilityEntry_level(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CapabilityEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type CapabilityLevel does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CapabilityEntry_description(ctx context.Context, field graphql.CollectedField, obj *model.CapabilityEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CapabilityEntry_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CapabilityEntry_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CapabilityEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CapabilityEntry_guidance(ctx context.Context, field graphql.CollectedField, obj *model.CapabilityEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CapabilityEntry_guidance(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Guidance, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CapabilityEntry_guidance(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CapabilityEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChangeLogEntry_timestamp(ctx context.Context, field graphql.CollectedField, obj *model.ChangeLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChangeLogEntry_timestamp(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Timestamp, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNDateTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChangeLogEntry_timestamp(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChangeLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DateTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChangeLogEntry_user(ctx context.Context, field graphql.CollectedField, obj *model.ChangeLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChangeLogEntry_user(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.User, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChangeLogEntry_user(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChangeLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChangeLogEntry_changeType(ctx context.Context, field graphql.CollectedField, obj *model.ChangeLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChangeLogEntry_changeType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ChangeType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.ChangeType)
	fc.Result = res
	return ec.marshalNChangeType2backendgraphmodelChangeType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChangeLogEntry_changeType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChangeLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ChangeType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChangeLogEntry_changedFields(ctx context.Context, field graphql.CollectedField, obj *model.ChangeLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChangeLogEntry_changedFields(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ChangedFields, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChangeLogEntry_changedFields(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChangeLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChangeLogEntry_summary(ctx context.Context, field graphql.CollectedField, obj *model.ChangeLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChangeLogEntry_summary(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Summary, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChangeLogEntry_summary(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChangeLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChangeSet_id(ctx context.Context, field graphql.CollectedField, obj *model.ChangeSet) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChangeSet_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChangeSet_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChangeSet",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChangeSet_name(ctx context.Context, field graphql.CollectedField, obj *model.ChangeSet) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChangeSet_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChangeSet_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChangeSet",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChangeSet_description(ctx context.Context, field graphql.CollectedField, obj *model.ChangeSet) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChangeSet_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChangeSet_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChangeSet",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChangeSet_routerId(ctx context.Context, field graphql.CollectedField, obj *model.ChangeSet) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChangeSet_routerId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RouterID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChangeSet_routerId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChangeSet",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChangeSet_items(ctx context.Context, field graphql.CollectedField, obj *model.ChangeSet) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChangeSet_items(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Items, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.ChangeSetItem)
	fc.Result = res
	return ec.marshalNChangeSetItem2backendgraphmodelChangeSetItem(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChangeSet_items(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChangeSet",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ChangeSetItem_id(ctx, field)
			case "resourceType":
				return ec.fieldContext_ChangeSetItem_resourceType(ctx, field)
			case "resourceCategory":
				return ec.fieldContext_ChangeSetItem_resourceCategory(ctx, field)
			case "resourceUuid":
				return ec.fieldContext_ChangeSetItem_resourceUuid(ctx, field)
			case "name":
				return ec.fieldContext_ChangeSetItem_name(ctx, field)
			case "description":
				return ec.fieldContext_ChangeSetItem_description(ctx, field)
			case "operation":
				return ec.fieldContext_ChangeSetItem_operation(ctx, field)
			case "configuration":
				return ec.fieldContext_ChangeSetItem_configuration(ctx, field)
			case "previousState":
				return ec.fieldContext_ChangeSetItem_previousState(ctx, field)
			case "dependencies":
				return ec.fieldContext_ChangeSetItem_dependencies(ctx, field)
			case "status":
				return ec.fieldContext_ChangeSetItem_status(ctx, field)
			case "error":
				return ec.fieldContext_ChangeSetItem_error(ctx, field)
			case "applyStartedAt":
				return ec.fieldContext_ChangeSetItem_applyStartedAt(ctx, field)
			case "applyCompletedAt":
				return ec.fieldContext_ChangeSetItem_applyCompletedAt(ctx, field)
			case "applyOrder":
				return ec.fieldContext_ChangeSetItem_applyOrder(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ChangeSetItem", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChangeSet_status(ctx context.Context, field graphql.CollectedField, obj *model.ChangeSet) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChangeSet_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.ChangeSetStatus)
	fc.Result = res
	return ec.marshalNChangeSetStatus2backendgraphmodelChangeSetStatus(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChangeSet_status(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChangeSet",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ChangeSetStatus does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChangeSet_validation(ctx context.Context, field graphql.CollectedField, obj *model.ChangeSet) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChangeSet_validation(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Validation, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.ChangeSetValidationResult)
	fc.Result = res
	return ec.marshalOChangeSetValidationResult2backendgraphmodelChangeSetValidationResult(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChangeSet_validation(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChangeSet",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "canApply":
				return ec.fieldContext_ChangeSetValidationResult_canApply(ctx, field)
			case "errors":
				return ec.fieldContext_ChangeSetValidationResult_errors(ctx, field)
			case "warnings":
				return ec.fieldContext_ChangeSetValidationResult_warnings(ctx, field)
			case "conflicts":
				return ec.fieldContext_ChangeSetValidationResult_conflicts(ctx, field)
			case "missingDependencies":
				return ec.fieldContext_ChangeSetValidationResult_missingDependencies(ctx, field)
			case "circularDependencies":
				return ec.fieldContext_ChangeSetValidationResult_circularDependencies(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ChangeSetValidationResult", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChangeSet_rollbackPlan(ctx context.Context, field graphql.CollectedField, obj *model.ChangeSet) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChangeSet_rollbackPlan(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RollbackPlan, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.RollbackStep)
	fc.Result = res
	return ec.marshalNRollbackStep2backendgraphmodelRollbackStep(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChangeSet_rollbackPlan(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChangeSet",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "itemId":
				return ec.fieldContext_RollbackStep_itemId(ctx, field)
			case "operation":
				return ec.fieldContext_RollbackStep_operation(ctx, field)
			case "restoreState":
				return ec.fieldContext_RollbackStep_restoreState(ctx, field)
			case "resourceUuid":
				return ec.fieldContext_RollbackStep_resourceUuid(ctx, field)
			case "success":
				return ec.fieldContext_RollbackStep_success(ctx, field)
			case "error":
				return ec.fieldContext_RollbackStep_error(ctx, field)
			case "rollbackOrder":
				return ec.fieldContext_RollbackStep_rollbackOrder(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RollbackStep", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChangeSet_error(ctx context.Context, field graphql.CollectedField, obj *model.ChangeSet) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChangeSet_error(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Error, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.ChangeSetError)
	fc.Result = res
	return ec.marshalOChangeSetError2backendgraphmodelChangeSetError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChangeSet_error(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChangeSet",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "message":
				return ec.fieldContext_ChangeSetError_message(ctx, field)
			case "failedItemId":
				return ec.fieldContext_ChangeSetError_failedItemId(ctx, field)
			case "code":
				return ec.fieldContext_ChangeSetError_code(ctx, field)
			case "partiallyAppliedItemIds":
				return ec.fieldContext_ChangeSetError_partiallyAppliedItemIds(ctx, field)
			case "failedRollbackItemIds":
				return ec.fieldContext_ChangeSetError_failedRollbackItemIds(ctx, field)
			case "requiresManualIntervention":
				return ec.fieldContext_ChangeSetError_requiresManualIntervention(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ChangeSetError", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChangeSet_createdAt(ctx context.Context, field graphql.CollectedField, obj *model.ChangeSet) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChangeSet_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNDateTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChangeSet_createdAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChangeSet",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DateTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChangeSet_applyStartedAt(ctx context.Context, field graphql.CollectedField, obj *model.ChangeSet) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChangeSet_applyStartedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ApplyStartedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalODateTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChangeSet_applyStartedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChangeSet",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DateTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChangeSet_completedAt(ctx context.Context, field graphql.CollectedField, obj *model.ChangeSet) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChangeSet_completedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CompletedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalODateTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChangeSet_completedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChangeSet",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DateTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChangeSet_createdBy(ctx context.Context, field graphql.CollectedField, obj *model.ChangeSet) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChangeSet_createdBy(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedBy, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChangeSet_createdBy(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChangeSet",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChangeSet_source(ctx context.Context, field graphql.CollectedField, obj *model.ChangeSet) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChangeSet_source(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Source, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChangeSet_source(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChangeSet",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChangeSet_version(ctx context.Context, field graphql.CollectedField, obj *model.ChangeSet) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChangeSet_version(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Version, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChangeSet_version(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChangeSet",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChangeSetConflict_itemId1(ctx context.Context, field graphql.CollectedField, obj *model.ChangeSetConflict) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChangeSetConflict_itemId1(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ItemID1, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChangeSetConflict_itemId1(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChangeSetConflict",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChangeSetConflict_itemId2OrResourceUuid(ctx context.Context, field graphql.CollectedField, obj *model.ChangeSetConflict) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChangeSetConflict_itemId2OrResourceUuid(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ItemID2OrResourceUUID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChangeSetConflict_itemId2OrResourceUuid(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChangeSetConflict",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChangeSetConflict_isExternalConflict(ctx context.Context, field graphql.CollectedField, obj *model.ChangeSetConflict) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChangeSetConflict_isExternalConflict(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsExternalConflict, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChangeSetConflict_isExternalConflict(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChangeSetConflict",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChangeSetConflict_description(ctx context.Context, field graphql.CollectedField, obj *model.ChangeSetConflict) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChangeSetConflict_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChangeSetConflict_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChangeSetConflict",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChangeSetConflict_resolution(ctx context.Context, field graphql.CollectedField, obj *model.ChangeSetConflict) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChangeSetConflict_resolution(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Resolution, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChangeSetConflict_resolution(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChangeSetConflict",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChangeSetError_message(ctx context.Context, field graphql.CollectedField, obj *model.ChangeSetError) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChangeSetError_message(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChangeSetError_message(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChangeSetError",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChangeSetError_failedItemId(ctx context.Context, field graphql.CollectedField, obj *model.ChangeSetError) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChangeSetError_failedItemId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FailedItemID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChangeSetError_failedItemId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChangeSetError",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChangeSetError_code(ctx context.Context, field graphql.CollectedField, obj *model.ChangeSetError) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChangeSetError_code(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Code, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChangeSetError_code(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChangeSetError",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChangeSetError_partiallyAppliedItemIds(ctx context.Context, field graphql.CollectedField, obj *model.ChangeSetError) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChangeSetError_partiallyAppliedItemIds(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PartiallyAppliedItemIds, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChangeSetError_partiallyAppliedItemIds(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChangeSetError",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChangeSetError_failedRollbackItemIds(ctx context.Context, field graphql.CollectedField, obj *model.ChangeSetError) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChangeSetError_failedRollbackItemIds(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FailedRollbackItemIds, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChangeSetError_failedRollbackItemIds(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChangeSetError",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChangeSetError_requiresManualIntervention(ctx context.Context, field graphql.CollectedField, obj *model.ChangeSetError) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChangeSetError_requiresManualIntervention(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RequiresManualIntervention, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChangeSetError_requiresManualIntervention(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChangeSetError",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChangeSetItem_id(ctx context.Context, field graphql.CollectedField, obj *model.ChangeSetItem) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChangeSetItem_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChangeSetItem_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChangeSetItem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChangeSetItem_resourceType(ctx context.Context, field graphql.CollectedField, obj *model.ChangeSetItem) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChangeSetItem_resourceType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ResourceType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChangeSetItem_resourceType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChangeSetItem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChangeSetItem_resourceCategory(ctx context.Context, field graphql.CollectedField, obj *model.ChangeSetItem) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChangeSetItem_resourceCategory(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ResourceCategory, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.ResourceCategory)
	fc.Result = res
	return ec.marshalNResourceCategory2backendgraphmodelResourceCategory(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChangeSetItem_resourceCategory(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChangeSetItem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ResourceCategory does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChangeSetItem_resourceUuid(ctx context.Context, field graphql.CollectedField, obj *model.ChangeSetItem) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChangeSetItem_resourceUuid(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ResourceUUID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChangeSetItem_resourceUuid(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChangeSetItem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChangeSetItem_name(ctx context.Context, field graphql.CollectedField, obj *model.ChangeSetItem) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChangeSetItem_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChangeSetItem_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChangeSetItem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChangeSetItem_description(ctx context.Context, field graphql.CollectedField, obj *model.ChangeSetItem) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChangeSetItem_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChangeSetItem_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChangeSetItem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChangeSetItem_operation(ctx context.Context, field graphql.CollectedField, obj *model.ChangeSetItem) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChangeSetItem_operation(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Operation, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.ChangeOperation)
	fc.Result = res
	return ec.marshalNChangeOperation2backendgraphmodelChangeOperation(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChangeSetItem_operation(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChangeSetItem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ChangeOperation does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChangeSetItem_configuration(ctx context.Context, field graphql.CollectedField, obj *model.ChangeSetItem) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChangeSetItem_configuration(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Configuration, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalNJSON2map(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChangeSetItem_configuration(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChangeSetItem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type JSON does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChangeSetItem_previousState(ctx context.Context, field graphql.CollectedField, obj *model.ChangeSetItem) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChangeSetItem_previousState(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PreviousState, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOJSON2map(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChangeSetItem_previousState(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChangeSetItem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type JSON does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChangeSetItem_dependencies(ctx context.Context, field graphql.CollectedField, obj *model.ChangeSetItem) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChangeSetItem_dependencies(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Dependencies, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChangeSetItem_dependencies(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChangeSetItem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChangeSetItem_status(ctx context.Context, field graphql.CollectedField, obj *model.ChangeSetItem) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChangeSetItem_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.ChangeSetItemStatus)
	fc.Result = res
	return ec.marshalNChangeSetItemStatus2backendgraphmodelChangeSetItemStatus(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChangeSetItem_status(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChangeSetItem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ChangeSetItemStatus does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChangeSetItem_error(ctx context.Context, field graphql.CollectedField, obj *model.ChangeSetItem) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChangeSetItem_error(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Error, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChangeSetItem_error(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChangeSetItem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChangeSetItem_applyStartedAt(ctx context.Context, field graphql.CollectedField, obj *model.ChangeSetItem) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChangeSetItem_applyStartedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ApplyStartedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalODateTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChangeSetItem_applyStartedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChangeSetItem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DateTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChangeSetItem_applyCompletedAt(ctx context.Context, field graphql.CollectedField, obj *model.ChangeSetItem) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChangeSetItem_applyCompletedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ApplyCompletedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalODateTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChangeSetItem_applyCompletedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChangeSetItem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DateTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChangeSetItem_applyOrder(ctx context.Context, field graphql.CollectedField, obj *model.ChangeSetItem) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChangeSetItem_applyOrder(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ApplyOrder, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChangeSetItem_applyOrder(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChangeSetItem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChangeSetProgressEvent_changeSetId(ctx context.Context, field graphql.CollectedField, obj *model.ChangeSetProgressEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChangeSetProgressEvent_changeSetId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ChangeSetID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChangeSetProgressEvent_changeSetId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChangeSetProgressEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChangeSetProgressEvent_status(ctx context.Context, field graphql.CollectedField, obj *model.ChangeSetProgressEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChangeSetProgressEvent_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.ChangeSetStatus)
	fc.Result = res
	return ec.marshalNChangeSetStatus2backendgraphmodelChangeSetStatus(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChangeSetProgressEvent_status(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChangeSetProgressEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ChangeSetStatus does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChangeSetProgressEvent_currentItem(ctx context.Context, field graphql.CollectedField, obj *model.ChangeSetProgressEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChangeSetProgressEvent_currentItem(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CurrentItem, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.CurrentItemInfo)
	fc.Result = res
	return ec.marshalOCurrentItemInfo2backendgraphmodelCurrentItemInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChangeSetProgressEvent_currentItem(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChangeSetProgressEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_CurrentItemInfo_id(ctx, field)
			case "name":
				return ec.fieldContext_CurrentItemInfo_name(ctx, field)
			case "operation":
				return ec.fieldContext_CurrentItemInfo_operation(ctx, field)
			case "status":
				return ec.fieldContext_CurrentItemInfo_status(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CurrentItemInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChangeSetProgressEvent_appliedCount(ctx context.Context, field graphql.CollectedField, obj *model.ChangeSetProgressEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChangeSetProgressEvent_appliedCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AppliedCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChangeSetProgressEvent_appliedCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChangeSetProgressEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChangeSetProgressEvent_totalCount(ctx context.Context, field graphql.CollectedField, obj *model.ChangeSetProgressEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChangeSetProgressEvent_totalCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChangeSetProgressEvent_totalCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChangeSetProgressEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChangeSetProgressEvent_progressPercent(ctx context.Context, field graphql.CollectedField, obj *model.ChangeSetProgressEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChangeSetProgressEvent_progressPercent(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ProgressPercent, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChangeSetProgressEvent_progressPercent(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChangeSetProgressEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChangeSetProgressEvent_estimatedRemainingMs(ctx context.Context, field graphql.CollectedField, obj *model.ChangeSetProgressEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChangeSetProgressEvent_estimatedRemainingMs(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EstimatedRemainingMs, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChangeSetProgressEvent_estimatedRemainingMs(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChangeSetProgressEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChangeSetProgressEvent_error(ctx context.Context, field graphql.CollectedField, obj *model.ChangeSetProgressEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChangeSetProgressEvent_error(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Error, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.ChangeSetError)
	fc.Result = res
	return ec.marshalOChangeSetError2backendgraphmodelChangeSetError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChangeSetProgressEvent_error(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChangeSetProgressEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "message":
				return ec.fieldContext_ChangeSetError_message(ctx, field)
			case "failedItemId":
				return ec.fieldContext_ChangeSetError_failedItemId(ctx, field)
			case "code":
				return ec.fieldContext_ChangeSetError_code(ctx, field)
			case "partiallyAppliedItemIds":
				return ec.fieldContext_ChangeSetError_partiallyAppliedItemIds(ctx, field)
			case "failedRollbackItemIds":
				return ec.fieldContext_ChangeSetError_failedRollbackItemIds(ctx, field)
			case "requiresManualIntervention":
				return ec.fieldContext_ChangeSetError_requiresManualIntervention(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ChangeSetError", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChangeSetProgressEvent_timestamp(ctx context.Context, field graphql.CollectedField, obj *model.ChangeSetProgressEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChangeSetProgressEvent_timestamp(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Timestamp, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNDateTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChangeSetProgressEvent_timestamp(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChangeSetProgressEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DateTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChangeSetStatusEvent_changeSetId(ctx context.Context, field graphql.CollectedField, obj *model.ChangeSetStatusEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChangeSetStatusEvent_changeSetId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ChangeSetID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChangeSetStatusEvent_changeSetId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChangeSetStatusEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChangeSetStatusEvent_previousStatus(ctx context.Context, field graphql.CollectedField, obj *model.ChangeSetStatusEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChangeSetStatusEvent_previousStatus(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PreviousStatus, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.ChangeSetStatus)
	fc.Result = res
	return ec.marshalNChangeSetStatus2backendgraphmodelChangeSetStatus(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChangeSetStatusEvent_previousStatus(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChangeSetStatusEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ChangeSetStatus does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChangeSetStatusEvent_newStatus(ctx context.Context, field graphql.CollectedField, obj *model.ChangeSetStatusEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChangeSetStatusEvent_newStatus(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NewStatus, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.ChangeSetStatus)
	fc.Result = res
	return ec.marshalNChangeSetStatus2backendgraphmodelChangeSetStatus(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChangeSetStatusEvent_newStatus(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChangeSetStatusEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ChangeSetStatus does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChangeSetStatusEvent_error(ctx context.Context, field graphql.CollectedField, obj *model.ChangeSetStatusEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChangeSetStatusEvent_error(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Error, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.ChangeSetError)
	fc.Result = res
	return ec.marshalOChangeSetError2backendgraphmodelChangeSetError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChangeSetStatusEvent_error(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChangeSetStatusEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "message":
				return ec.fieldContext_ChangeSetError_message(ctx, field)
			case "failedItemId":
				return ec.fieldContext_ChangeSetError_failedItemId(ctx, field)
			case "code":
				return ec.fieldContext_ChangeSetError_code(ctx, field)
			case "partiallyAppliedItemIds":
				return ec.fieldContext_ChangeSetError_partiallyAppliedItemIds(ctx, field)
			case "failedRollbackItemIds":
				return ec.fieldContext_ChangeSetError_failedRollbackItemIds(ctx, field)
			case "requiresManualIntervention":
				return ec.fieldContext_ChangeSetError_requiresManualIntervention(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ChangeSetError", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChangeSetStatusEvent_timestamp(ctx context.Context, field graphql.CollectedField, obj *model.ChangeSetStatusEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChangeSetStatusEvent_timestamp(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Timestamp, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNDateTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChangeSetStatusEvent_timestamp(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChangeSetStatusEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DateTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChangeSetSummary_id(ctx context.Context, field graphql.CollectedField, obj *model.ChangeSetSummary) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChangeSetSummary_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChangeSetSummary_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChangeSetSummary",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChangeSetSummary_name(ctx context.Context, field graphql.CollectedField, obj *model.ChangeSetSummary) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChangeSetSummary_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChangeSetSummary_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChangeSetSummary",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChangeSetSummary_status(ctx context.Context, field graphql.CollectedField, obj *model.ChangeSetSummary) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChangeSetSummary_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.ChangeSetStatus)
	fc.Result = res
	return ec.marshalNChangeSetStatus2backendgraphmodelChangeSetStatus(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChangeSetSummary_status(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChangeSetSummary",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ChangeSetStatus does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChangeSetSummary_operationCounts(ctx context.Context, field graphql.CollectedField, obj *model.ChangeSetSummary) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChangeSetSummary_operationCounts(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OperationCounts, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.OperationCounts)
	fc.Result = res
	return ec.marshalNOperationCounts2backendgraphmodelOperationCounts(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChangeSetSummary_operationCounts(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChangeSetSummary",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "create":
				return ec.fieldContext_OperationCounts_create(ctx, field)
			case "update":
				return ec.fieldContext_OperationCounts_update(ctx, field)
			case "delete":
				return ec.fieldContext_OperationCounts_delete(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type OperationCounts", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChangeSetSummary_totalItems(ctx context.Context, field graphql.CollectedField, obj *model.ChangeSetSummary) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChangeSetSummary_totalItems(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalItems, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChangeSetSummary_totalItems(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChangeSetSummary",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChangeSetSummary_createdAt(ctx context.Context, field graphql.CollectedField, obj *model.ChangeSetSummary) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChangeSetSummary_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNDateTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChangeSetSummary_createdAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChangeSetSummary",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DateTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChangeSetSummary_hasErrors(ctx context.Context, field graphql.CollectedField, obj *model.ChangeSetSummary) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChangeSetSummary_hasErrors(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HasErrors, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChangeSetSummary_hasErrors(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChangeSetSummary",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChangeSetSummary_hasWarnings(ctx context.Context, field graphql.CollectedField, obj *model.ChangeSetSummary) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChangeSetSummary_hasWarnings(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HasWarnings, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChangeSetSummary_hasWarnings(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChangeSetSummary",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChangeSetValidationError_itemId(ctx context.Context, field graphql.CollectedField, obj *model.ChangeSetValidationError) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChangeSetValidationError_itemId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ItemID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChangeSetValidationError_itemId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChangeSetValidationError",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChangeSetValidationError_field(ctx context.Context, field graphql.CollectedField, obj *model.ChangeSetValidationError) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChangeSetValidationError_field(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Field, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChangeSetValidationError_field(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChangeSetValidationError",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChangeSetValidationError_message(ctx context.Context, field graphql.CollectedField, obj *model.ChangeSetValidationError) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChangeSetValidationError_message(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChangeSetValidationError_message(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChangeSetValidationError",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChangeSetValidationError_severity(ctx context.Context, field graphql.CollectedField, obj *model.ChangeSetValidationError) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChangeSetValidationError_severity(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Severity, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.ValidationSeverity)
	fc.Result = res
	return ec.marshalNValidationSeverity2backendgraphmodelValidationSeverity(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChangeSetValidationError_severity(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChangeSetValidationError",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ValidationSeverity does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChangeSetValidationError_code(ctx context.Context, field graphql.CollectedField, obj *model.ChangeSetValidationError) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChangeSetValidationError_code(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Code, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChangeSetValidationError_code(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChangeSetValidationError",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChangeSetValidationResult_canApply(ctx context.Context, field graphql.CollectedField, obj *model.ChangeSetValidationResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChangeSetValidationResult_canApply(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CanApply, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChangeSetValidationResult_canApply(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChangeSetValidationResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChangeSetValidationResult_errors(ctx context.Context, field graphql.CollectedField, obj *model.ChangeSetValidationResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChangeSetValidationResult_errors(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Errors, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.ChangeSetValidationError)
	fc.Result = res
	return ec.marshalNChangeSetValidationError2backendgraphmodelChangeSetValidationError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChangeSetValidationResult_errors(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChangeSetValidationResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "itemId":
				return ec.fieldContext_ChangeSetValidationError_itemId(ctx, field)
			case "field":
				return ec.fieldContext_ChangeSetValidationError_field(ctx, field)
			case "message":
				return ec.fieldContext_ChangeSetValidationError_message(ctx, field)
			case "severity":
				return ec.fieldContext_ChangeSetValidationError_severity(ctx, field)
			case "code":
				return ec.fieldContext_ChangeSetValidationError_code(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ChangeSetValidationError", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChangeSetValidationResult_warnings(ctx context.Context, field graphql.CollectedField, obj *model.ChangeSetValidationResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChangeSetValidationResult_warnings(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Warnings, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.ChangeSetValidationError)
	fc.Result = res
	return ec.marshalNChangeSetValidationError2backendgraphmodelChangeSetValidationError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChangeSetValidationResult_warnings(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChangeSetValidationResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "itemId":
				return ec.fieldContext_ChangeSetValidationError_itemId(ctx, field)
			case "field":
				return ec.fieldContext_ChangeSetValidationError_field(ctx, field)
			case "message":
				return ec.fieldContext_ChangeSetValidationError_message(ctx, field)
			case "severity":
				return ec.fieldContext_ChangeSetValidationError_severity(ctx, field)
			case "code":
				return ec.fieldContext_ChangeSetValidationError_code(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ChangeSetValidationError", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChangeSetValidationResult_conflicts(ctx context.Context, field graphql.CollectedField, obj *model.ChangeSetValidationResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChangeSetValidationResult_conflicts(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Conflicts, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.ChangeSetConflict)
	fc.Result = res
	return ec.marshalNChangeSetConflict2backendgraphmodelChangeSetConflict(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChangeSetValidationResult_conflicts(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChangeSetValidationResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "itemId1":
				return ec.fieldContext_ChangeSetConflict_itemId1(ctx, field)
			case "itemId2OrResourceUuid":
				return ec.fieldContext_ChangeSetConflict_itemId2OrResourceUuid(ctx, field)
			case "isExternalConflict":
				return ec.fieldContext_ChangeSetConflict_isExternalConflict(ctx, field)
			case "description":
				return ec.fieldContext_ChangeSetConflict_description(ctx, field)
			case "resolution":
				return ec.fieldContext_ChangeSetConflict_resolution(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ChangeSetConflict", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChangeSetValidationResult_missingDependencies(ctx context.Context, field graphql.CollectedField, obj *model.ChangeSetValidationResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChangeSetValidationResult_missingDependencies(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MissingDependencies, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.MissingDependency)
	fc.Result = res
	return ec.marshalNMissingDependency2backendgraphmodelMissingDependency(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChangeSetValidationResult_missingDependencies(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChangeSetValidationResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "itemId":
				return ec.fieldContext_MissingDependency_itemId(ctx, field)
			case "missingResourceType":
				return ec.fieldContext_MissingDependency_missingResourceType(ctx, field)
			case "missingResourceId":
				return ec.fieldContext_MissingDependency_missingResourceId(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MissingDependency", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChangeSetValidationResult_circularDependencies(ctx context.Context, field graphql.CollectedField, obj *model.ChangeSetValidationResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChangeSetValidationResult_circularDependencies(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CircularDependencies, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([][]string)
	fc.Result = res
	return ec.marshalOID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChangeSetValidationResult_circularDependencies(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChangeSetValidationResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CircuitBreakerEvent_routerId(ctx context.Context, field graphql.CollectedField, obj *model.CircuitBreakerEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CircuitBreakerEvent_routerId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RouterID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CircuitBreakerEvent_routerId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CircuitBreakerEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CircuitBreakerEvent_previousState(ctx context.Context, field graphql.CollectedField, obj *model.CircuitBreakerEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CircuitBreakerEvent_previousState(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PreviousState, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.CircuitBreakerState)
	fc.Result = res
	return ec.marshalNCircuitBreakerState2backendgraphmodelCircuitBreakerState(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CircuitBreakerEvent_previousState(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CircuitBreakerEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type CircuitBreakerState does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CircuitBreakerEvent_newState(ctx context.Context, field graphql.CollectedField, obj *model.CircuitBreakerEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CircuitBreakerEvent_newState(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NewState, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.CircuitBreakerState)
	fc.Result = res
	return ec.marshalNCircuitBreakerState2backendgraphmodelCircuitBreakerState(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CircuitBreakerEvent_newState(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CircuitBreakerEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type CircuitBreakerState does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CircuitBreakerEvent_consecutiveFailures(ctx context.Context, field graphql.CollectedField, obj *model.CircuitBreakerEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CircuitBreakerEvent_consecutiveFailures(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ConsecutiveFailures, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CircuitBreakerEvent_consecutiveFailures(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CircuitBreakerEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CircuitBreakerEvent_timestamp(ctx context.Context, field graphql.CollectedField, obj *model.CircuitBreakerEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CircuitBreakerEvent_timestamp(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Timestamp, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNDateTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CircuitBreakerEvent_timestamp(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CircuitBreakerEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DateTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CircuitBreakerStatus_routerId(ctx context.Context, field graphql.CollectedField, obj *model.CircuitBreakerStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CircuitBreakerStatus_routerId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RouterID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CircuitBreakerStatus_routerId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CircuitBreakerStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CircuitBreakerStatus_state(ctx context.Context, field graphql.CollectedField, obj *model.CircuitBreakerStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CircuitBreakerStatus_state(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.State, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.CircuitBreakerState)
	fc.Result = res
	return ec.marshalNCircuitBreakerState2backendgraphmodelCircuitBreakerState(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CircuitBreakerStatus_state(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CircuitBreakerStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type CircuitBreakerState does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CircuitBreakerStatus_failureCount(ctx context.Context, field graphql.CollectedField, obj *model.CircuitBreakerStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CircuitBreakerStatus_failureCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FailureCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CircuitBreakerStatus_failureCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CircuitBreakerStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CircuitBreakerStatus_failureThreshold(ctx context.Context, field graphql.CollectedField, obj *model.CircuitBreakerStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CircuitBreakerStatus_failureThreshold(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FailureThreshold, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CircuitBreakerStatus_failureThreshold(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CircuitBreakerStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CircuitBreakerStatus_cooldownRemainingSeconds(ctx context.Context, field graphql.CollectedField, obj *model.CircuitBreakerStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CircuitBreakerStatus_cooldownRemainingSeconds(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CooldownRemainingSeconds, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CircuitBreakerStatus_cooldownRemainingSeconds(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CircuitBreakerStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CircuitBreakerStatus_lastFailureAt(ctx context.Context, field graphql.CollectedField, obj *model.CircuitBreakerStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CircuitBreakerStatus_lastFailureAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LastFailureAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalODateTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CircuitBreakerStatus_lastFailureAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CircuitBreakerStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DateTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CircuitBreakerStatus_lastSuccessAt(ctx context.Context, field graphql.CollectedField, obj *model.CircuitBreakerStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CircuitBreakerStatus_lastSuccessAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LastSuccessAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalODateTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CircuitBreakerStatus_lastSuccessAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CircuitBreakerStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DateTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CompositeResource_root(ctx context.Context, field graphql.CollectedField, obj *model.CompositeResource) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CompositeResource_root(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Root, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.Resource)
	fc.Result = res
	return ec.marshalNResource2backendgraphmodelResource(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CompositeResource_root(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CompositeResource",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("FieldContext.Child cannot be called on type INTERFACE")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CompositeResource_children(ctx context.Context, field graphql.CollectedField, obj *model.CompositeResource) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CompositeResource_children(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Children, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]model.Resource)
	fc.Result = res
	return ec.marshalNResource2backendgraphmodelResource(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CompositeResource_children(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CompositeResource",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("FieldContext.Child cannot be called on type INTERFACE")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CompositeResource_relationships(ctx context.Context, field graphql.CollectedField, obj *model.CompositeResource) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CompositeResource_relationships(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Relationships, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.ResourceRelationshipEdge)
	fc.Result = res
	return ec.marshalNResourceRelationshipEdge2backendgraphmodelResourceRelationshipEdge(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CompositeResource_relationships(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CompositeResource",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "from":
				return ec.fieldContext_ResourceRelationshipEdge_from(ctx, field)
			case "to":
				return ec.fieldContext_ResourceRelationshipEdge_to(ctx, field)
			case "type":
				return ec.fieldContext_ResourceRelationshipEdge_type(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ResourceRelationshipEdge", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ConfigPreview_commands(ctx context.Context, field graphql.CollectedField, obj *model.ConfigPreview) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ConfigPreview_commands(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Commands, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ConfigPreview_commands(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ConfigPreview",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ConfigPreview_warnings(ctx context.Context, field graphql.CollectedField, obj *model.ConfigPreview) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ConfigPreview_warnings(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Warnings, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ConfigPreview_warnings(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ConfigPreview",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ConfigPreview_affectedResources(ctx context.Context, field graphql.CollectedField, obj *model.ConfigPreview) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ConfigPreview_affectedResources(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AffectedResources, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.AffectedResource)
	fc.Result = res
	return ec.marshalOAffectedResource2backendgraphmodelAffectedResource(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ConfigPreview_affectedResources(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ConfigPreview",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "type":
				return ec.fieldContext_AffectedResource_type(ctx, field)
			case "id":
				return ec.fieldContext_AffectedResource_id(ctx, field)
			case "name":
				return ec.fieldContext_AffectedResource_name(ctx, field)
			case "impact":
				return ec.fieldContext_AffectedResource_impact(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type AffectedResource", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ConfigProgress_operationId(ctx context.Context, field graphql.CollectedField, obj *model.ConfigProgress) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ConfigProgress_operationId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OperationID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ConfigProgress_operationId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ConfigProgress",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ConfigProgress_status(ctx context.Context, field graphql.CollectedField, obj *model.ConfigProgress) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ConfigProgress_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.ConfigApplyStatus)
	fc.Result = res
	return ec.marshalNConfigApplyStatus2backendgraphmodelConfigApplyStatus(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ConfigProgress_status(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ConfigProgress",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ConfigApplyStatus does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ConfigProgress_percentage(ctx context.Context, field graphql.CollectedField, obj *model.ConfigProgress) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ConfigProgress_percentage(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Percentage, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ConfigProgress_percentage(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ConfigProgress",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ConfigProgress_message(ctx context.Context, field graphql.CollectedField, obj *model.ConfigProgress) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ConfigProgress_message(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ConfigProgress_message(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ConfigProgress",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ConfigProgress_currentStep(ctx context.Context, field graphql.CollectedField, obj *model.ConfigProgress) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ConfigProgress_currentStep(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CurrentStep, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ConfigProgress_currentStep(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ConfigProgress",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ConfigProgress_totalSteps(ctx context.Context, field graphql.CollectedField, obj *model.ConfigProgress) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ConfigProgress_totalSteps(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalSteps, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ConfigProgress_totalSteps(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ConfigProgress",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ConfigProgress_timestamp(ctx context.Context, field graphql.CollectedField, obj *model.ConfigProgress) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ConfigProgress_timestamp(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Timestamp, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNDateTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ConfigProgress_timestamp(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ConfigProgress",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DateTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ConnectRouterPayload_router(ctx context.Context, field graphql.CollectedField, obj *model.ConnectRouterPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ConnectRouterPayload_router(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Router, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Router)
	fc.Result = res
	return ec.marshalORouter2backendgraphmodelRouter(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ConnectRouterPayload_router(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ConnectRouterPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Router_id(ctx, field)
			case "name":
				return ec.fieldContext_Router_name(ctx, field)
			case "host":
				return ec.fieldContext_Router_host(ctx, field)
			case "port":
				return ec.fieldContext_Router_port(ctx, field)
			case "status":
				return ec.fieldContext_Router_status(ctx, field)
			case "platform":
				return ec.fieldContext_Router_platform(ctx, field)
			case "version":
				return ec.fieldContext_Router_version(ctx, field)
			case "model":
				return ec.fieldContext_Router_model(ctx, field)
			case "uptime":
				return ec.fieldContext_Router_uptime(ctx, field)
			case "lastConnected":
				return ec.fieldContext_Router_lastConnected(ctx, field)
			case "createdAt":
				return ec.fieldContext_Router_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Router_updatedAt(ctx, field)
			case "capabilities":
				return ec.fieldContext_Router_capabilities(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Router", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ConnectRouterPayload_errors(ctx context.Context, field graphql.CollectedField, obj *model.ConnectRouterPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ConnectRouterPayload_errors(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Errors, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.MutationError)
	fc.Result = res
	return ec.marshalOMutationError2backendgraphmodelMutationError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ConnectRouterPayload_errors(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ConnectRouterPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "code":
				return ec.fieldContext_MutationError_code(ctx, field)
			case "message":
				return ec.fieldContext_MutationError_message(ctx, field)
			case "field":
				return ec.fieldContext_MutationError_field(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MutationError", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ConnectionAttempt_protocol(ctx context.Context, field graphql.CollectedField, obj *model.ConnectionAttempt) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ConnectionAttempt_protocol(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Protocol, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.Protocol)
	fc.Result = res
	return ec.marshalNProtocol2backendgraphmodelProtocol(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ConnectionAttempt_protocol(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ConnectionAttempt",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Protocol does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ConnectionAttempt_startedAt(ctx context.Context, field graphql.CollectedField, obj *model.ConnectionAttempt) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ConnectionAttempt_startedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StartedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNDateTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ConnectionAttempt_startedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ConnectionAttempt",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DateTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ConnectionAttempt_endedAt(ctx context.Context, field graphql.CollectedField, obj *model.ConnectionAttempt) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ConnectionAttempt_endedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EndedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNDateTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ConnectionAttempt_endedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ConnectionAttempt",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DateTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ConnectionAttempt_success(ctx context.Context, field graphql.CollectedField, obj *model.ConnectionAttempt) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ConnectionAttempt_success(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Success, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ConnectionAttempt_success(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ConnectionAttempt",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ConnectionAttempt_errorCode(ctx context.Context, field graphql.CollectedField, obj *model.ConnectionAttempt) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ConnectionAttempt_errorCode(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ErrorCode, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ConnectionAttempt_errorCode(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ConnectionAttempt",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ConnectionAttempt_errorMessage(ctx context.Context, field graphql.CollectedField, obj *model.ConnectionAttempt) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ConnectionAttempt_errorMessage(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ErrorMessage, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ConnectionAttempt_errorMessage(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ConnectionAttempt",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ConnectionAttempt_errorCategory(ctx context.Context, field graphql.CollectedField, obj *model.ConnectionAttempt) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ConnectionAttempt_errorCategory(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ErrorCategory, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.ErrorCategory)
	fc.Result = res
	return ec.marshalOErrorCategory2backendgraphmodelErrorCategory(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ConnectionAttempt_errorCategory(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ConnectionAttempt",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ErrorCategory does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ConnectionDetails_state(ctx context.Context, field graphql.CollectedField, obj *model.ConnectionDetails) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ConnectionDetails_state(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.State, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.ConnectionStatus)
	fc.Result = res
	return ec.marshalNConnectionStatus2backendgraphmodelConnectionStatus(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ConnectionDetails_state(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ConnectionDetails",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ConnectionStatus does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ConnectionDetails_protocol(ctx context.Context, field graphql.CollectedField, obj *model.ConnectionDetails) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ConnectionDetails_protocol(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Protocol, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Protocol)
	fc.Result = res
	return ec.marshalOProtocol2backendgraphmodelProtocol(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ConnectionDetails_protocol(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ConnectionDetails",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Protocol does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ConnectionDetails_preferredProtocol(ctx context.Context, field graphql.CollectedField, obj *model.ConnectionDetails) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ConnectionDetails_preferredProtocol(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PreferredProtocol, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Protocol)
	fc.Result = res
	return ec.marshalOProtocol2backendgraphmodelProtocol(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ConnectionDetails_preferredProtocol(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ConnectionDetails",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Protocol does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ConnectionDetails_connectedAt(ctx context.Context, field graphql.CollectedField, obj *model.ConnectionDetails) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ConnectionDetails_connectedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ConnectedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalODateTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ConnectionDetails_connectedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ConnectionDetails",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DateTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ConnectionDetails_uptime(ctx context.Context, field graphql.CollectedField, obj *model.ConnectionDetails) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ConnectionDetails_uptime(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Uptime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Duration)
	fc.Result = res
	return ec.marshalODuration2backendgraphmodelDuration(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ConnectionDetails_uptime(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ConnectionDetails",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Duration does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ConnectionDetails_disconnectedAt(ctx context.Context, field graphql.CollectedField, obj *model.ConnectionDetails) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ConnectionDetails_disconnectedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DisconnectedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalODateTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ConnectionDetails_disconnectedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ConnectionDetails",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DateTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ConnectionDetails_lastError(ctx context.Context, field graphql.CollectedField, obj *model.ConnectionDetails) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ConnectionDetails_lastError(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LastError, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ConnectionDetails_lastError(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ConnectionDetails",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ConnectionDetails_lastErrorTime(ctx context.Context, field graphql.CollectedField, obj *model.ConnectionDetails) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ConnectionDetails_lastErrorTime(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LastErrorTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalODateTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ConnectionDetails_lastErrorTime(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ConnectionDetails",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DateTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ConnectionDetails_disconnectReason(ctx context.Context, field graphql.CollectedField, obj *model.ConnectionDetails) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ConnectionDetails_disconnectReason(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DisconnectReason, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.DisconnectReason)
	fc.Result = res
	return ec.marshalODisconnectReason2backendgraphmodelDisconnectReason(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ConnectionDetails_disconnectReason(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ConnectionDetails",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DisconnectReason does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ConnectionDetails_reconnectAttempts(ctx context.Context, field graphql.CollectedField, obj *model.ConnectionDetails) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ConnectionDetails_reconnectAttempts(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ReconnectAttempts, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ConnectionDetails_reconnectAttempts(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ConnectionDetails",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ConnectionDetails_nextReconnectAt(ctx context.Context, field graphql.CollectedField, obj *model.ConnectionDetails) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ConnectionDetails_nextReconnectAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NextReconnectAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalODateTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ConnectionDetails_nextReconnectAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ConnectionDetails",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DateTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ConnectionDetails_circuitBreakerState(ctx context.Context, field graphql.CollectedField, obj *model.ConnectionDetails) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ConnectionDetails_circuitBreakerState(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CircuitBreakerState, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.CircuitBreakerState)
	fc.Result = res
	return ec.marshalNCircuitBreakerState2backendgraphmodelCircuitBreakerState(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ConnectionDetails_circuitBreakerState(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ConnectionDetails",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type CircuitBreakerState does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ConnectionDetails_version(ctx context.Context, field graphql.CollectedField, obj *model.ConnectionDetails) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ConnectionDetails_version(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Version, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ConnectionDetails_version(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ConnectionDetails",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ConnectionDetails_lastHealthCheck(ctx context.Context, field graphql.CollectedField, obj *model.ConnectionDetails) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ConnectionDetails_lastHealthCheck(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LastHealthCheck, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalODateTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ConnectionDetails_lastHealthCheck(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ConnectionDetails",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DateTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ConnectionDetails_healthChecksPassed(ctx context.Context, field graphql.CollectedField, obj *model.ConnectionDetails) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ConnectionDetails_healthChecksPassed(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HealthChecksPassed, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ConnectionDetails_healthChecksPassed(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ConnectionDetails",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ConnectionDetails_healthChecksFailed(ctx context.Context, field graphql.CollectedField, obj *model.ConnectionDetails) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ConnectionDetails_healthChecksFailed(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HealthChecksFailed, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ConnectionDetails_healthChecksFailed(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ConnectionDetails",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ConnectionDetails_securityWarning(ctx context.Context, field graphql.CollectedField, obj *model.ConnectionDetails) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ConnectionDetails_securityWarning(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SecurityWarning, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ConnectionDetails_securityWarning(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ConnectionDetails",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ConnectionDetails_upgradeRecommendation(ctx context.Context, field graphql.CollectedField, obj *model.ConnectionDetails) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ConnectionDetails_upgradeRecommendation(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpgradeRecommendation, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ConnectionDetails_upgradeRecommendation(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ConnectionDetails",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ConnectionDetails_isLegacyProtocol(ctx context.Context, field graphql.CollectedField, obj *model.ConnectionDetails) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ConnectionDetails_isLegacyProtocol(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsLegacyProtocol, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ConnectionDetails_isLegacyProtocol(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ConnectionDetails",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ConnectionError_code(ctx context.Context, field graphql.CollectedField, obj *model.ConnectionError) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ConnectionError_code(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Code, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.ConnectionErrorCode)
	fc.Result = res
	return ec.marshalNConnectionErrorCode2backendgraphmodelConnectionErrorCode(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ConnectionError_code(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ConnectionError",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ConnectionErrorCode does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ConnectionError_message(ctx context.Context, field graphql.CollectedField, obj *model.ConnectionError) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ConnectionError_message(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ConnectionError_message(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ConnectionError",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ConnectionError_protocol(ctx context.Context, field graphql.CollectedField, obj *model.ConnectionError) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ConnectionError_protocol(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Protocol, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Protocol)
	fc.Result = res
	return ec.marshalOProtocol2backendgraphmodelProtocol(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ConnectionError_protocol(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ConnectionError",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Protocol does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ConnectionError_retryable(ctx context.Context, field graphql.CollectedField, obj *model.ConnectionError) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ConnectionError_retryable(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Retryable, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ConnectionError_retryable(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ConnectionError",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ConnectionError_suggestedAction(ctx context.Context, field graphql.CollectedField, obj *model.ConnectionError) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ConnectionError_suggestedAction(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SuggestedAction, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ConnectionError_suggestedAction(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ConnectionError",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ConnectionError_timeoutMs(ctx context.Context, field graphql.CollectedField, obj *model.ConnectionError) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ConnectionError_timeoutMs(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TimeoutMs, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ConnectionError_timeoutMs(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ConnectionError",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ConnectionStats_totalConnections(ctx context.Context, field graphql.CollectedField, obj *model.ConnectionStats) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ConnectionStats_totalConnections(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalConnections, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ConnectionStats_totalConnections(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ConnectionStats",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ConnectionStats_connected(ctx context.Context, field graphql.CollectedField, obj *model.ConnectionStats) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ConnectionStats_connected(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Connected, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ConnectionStats_connected(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ConnectionStats",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ConnectionStats_connecting(ctx context.Context, field graphql.CollectedField, obj *model.ConnectionStats) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ConnectionStats_connecting(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Connecting, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ConnectionStats_connecting(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ConnectionStats",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ConnectionStats_disconnected(ctx context.Context, field graphql.CollectedField, obj *model.ConnectionStats) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ConnectionStats_disconnected(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Disconnected, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ConnectionStats_disconnected(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ConnectionStats",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ConnectionStats_reconnecting(ctx context.Context, field graphql.CollectedField, obj *model.ConnectionStats) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ConnectionStats_reconnecting(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Reconnecting, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ConnectionStats_reconnecting(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ConnectionStats",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ConnectionStats_error(ctx context.Context, field graphql.CollectedField, obj *model.ConnectionStats) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ConnectionStats_error(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Error, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ConnectionStats_error(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ConnectionStats",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ConnectionTestResult_success(ctx context.Context, field graphql.CollectedField, obj *model.ConnectionTestResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ConnectionTestResult_success(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Success, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ConnectionTestResult_success(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ConnectionTestResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ConnectionTestResult_protocolUsed(ctx context.Context, field graphql.CollectedField, obj *model.ConnectionTestResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ConnectionTestResult_protocolUsed(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ProtocolUsed, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Protocol)
	fc.Result = res
	return ec.marshalOProtocol2backendgraphmodelProtocol(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ConnectionTestResult_protocolUsed(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ConnectionTestResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Protocol does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ConnectionTestResult_responseTimeMs(ctx context.Context, field graphql.CollectedField, obj *model.ConnectionTestResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ConnectionTestResult_responseTimeMs(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ResponseTimeMs, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ConnectionTestResult_responseTimeMs(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ConnectionTestResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ConnectionTestResult_routerVersion(ctx context.Context, field graphql.CollectedField, obj *model.ConnectionTestResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ConnectionTestResult_routerVersion(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RouterVersion, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ConnectionTestResult_routerVersion(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ConnectionTestResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ConnectionTestResult_routerModel(ctx context.Context, field graphql.CollectedField, obj *model.ConnectionTestResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ConnectionTestResult_routerModel(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RouterModel, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ConnectionTestResult_routerModel(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ConnectionTestResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ConnectionTestResult_boardName(ctx context.Context, field graphql.CollectedField, obj *model.ConnectionTestResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ConnectionTestResult_boardName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BoardName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ConnectionTestResult_boardName(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ConnectionTestResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ConnectionTestResult_uptime(ctx context.Context, field graphql.CollectedField, obj *model.ConnectionTestResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ConnectionTestResult_uptime(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Uptime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Duration)
	fc.Result = res
	return ec.marshalODuration2backendgraphmodelDuration(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ConnectionTestResult_uptime(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ConnectionTestResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Duration does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ConnectionTestResult_protocolsAttempted(ctx context.Context, field graphql.CollectedField, obj *model.ConnectionTestResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ConnectionTestResult_protocolsAttempted(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ProtocolsAttempted, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]model.Protocol)
	fc.Result = res
	return ec.marshalNProtocol2backendgraphmodelProtocol(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ConnectionTestResult_protocolsAttempted(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ConnectionTestResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Protocol does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ConnectionTestResult_supportsContainers(ctx context.Context, field graphql.CollectedField, obj *model.ConnectionTestResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ConnectionTestResult_supportsContainers(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SupportsContainers, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ConnectionTestResult_supportsContainers(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ConnectionTestResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ConnectionTestResult_architecture(ctx context.Context, field graphql.CollectedField, obj *model.ConnectionTestResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ConnectionTestResult_architecture(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Architecture, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ConnectionTestResult_architecture(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ConnectionTestResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ConnectionTestResult_error(ctx context.Context, field graphql.CollectedField, obj *model.ConnectionTestResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ConnectionTestResult_error(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Error, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.ConnectionError)
	fc.Result = res
	return ec.marshalOConnectionError2backendgraphmodelConnectionError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ConnectionTestResult_error(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ConnectionTestResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "code":
				return ec.fieldContext_ConnectionError_code(ctx, field)
			case "message":
				return ec.fieldContext_ConnectionError_message(ctx, field)
			case "protocol":
				return ec.fieldContext_ConnectionError_protocol(ctx, field)
			case "retryable":
				return ec.fieldContext_ConnectionError_retryable(ctx, field)
			case "suggestedAction":
				return ec.fieldContext_ConnectionError_suggestedAction(ctx, field)
			case "timeoutMs":
				return ec.fieldContext_ConnectionError_timeoutMs(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ConnectionError", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ContainerInfo_packageInstalled(ctx context.Context, field graphql.CollectedField, obj *model.ContainerInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ContainerInfo_packageInstalled(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PackageInstalled, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ContainerInfo_packageInstalled(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ContainerInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ContainerInfo_enabled(ctx context.Context, field graphql.CollectedField, obj *model.ContainerInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ContainerInfo_enabled(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Enabled, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ContainerInfo_enabled(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ContainerInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ContainerInfo_registryConfigured(ctx context.Context, field graphql.CollectedField, obj *model.ContainerInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ContainerInfo_registryConfigured(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RegistryConfigured, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ContainerInfo_registryConfigured(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ContainerInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ContainerInfo_storageAvailable(ctx context.Context, field graphql.CollectedField, obj *model.ContainerInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ContainerInfo_storageAvailable(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StorageAvailable, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.Size)
	fc.Result = res
	return ec.marshalNSize2backendgraphmodelSize(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ContainerInfo_storageAvailable(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ContainerInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Size does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ContainerInfo_supportsNetworkNamespace(ctx context.Context, field graphql.CollectedField, obj *model.ContainerInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ContainerInfo_supportsNetworkNamespace(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SupportsNetworkNamespace, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ContainerInfo_supportsNetworkNamespace(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ContainerInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ContainerInfo_maxContainers(ctx context.Context, field graphql.CollectedField, obj *model.ContainerInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ContainerInfo_maxContainers(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MaxContainers, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ContainerInfo_maxContainers(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ContainerInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CreateChangeSetPayload_changeSet(ctx context.Context, field graphql.CollectedField, obj *model.CreateChangeSetPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CreateChangeSetPayload_changeSet(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ChangeSet, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.ChangeSet)
	fc.Result = res
	return ec.marshalOChangeSet2backendgraphmodelChangeSet(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CreateChangeSetPayload_changeSet(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CreateChangeSetPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ChangeSet_id(ctx, field)
			case "name":
				return ec.fieldContext_ChangeSet_name(ctx, field)
			case "description":
				return ec.fieldContext_ChangeSet_description(ctx, field)
			case "routerId":
				return ec.fieldContext_ChangeSet_routerId(ctx, field)
			case "items":
				return ec.fieldContext_ChangeSet_items(ctx, field)
			case "status":
				return ec.fieldContext_ChangeSet_status(ctx, field)
			case "validation":
				return ec.fieldContext_ChangeSet_validation(ctx, field)
			case "rollbackPlan":
				return ec.fieldContext_ChangeSet_rollbackPlan(ctx, field)
			case "error":
				return ec.fieldContext_ChangeSet_error(ctx, field)
			case "createdAt":
				return ec.fieldContext_ChangeSet_createdAt(ctx, field)
			case "applyStartedAt":
				return ec.fieldContext_ChangeSet_applyStartedAt(ctx, field)
			case "completedAt":
				return ec.fieldContext_ChangeSet_completedAt(ctx, field)
			case "createdBy":
				return ec.fieldContext_ChangeSet_createdBy(ctx, field)
			case "source":
				return ec.fieldContext_ChangeSet_source(ctx, field)
			case "version":
				return ec.fieldContext_ChangeSet_version(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ChangeSet", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CreateChangeSetPayload_errors(ctx context.Context, field graphql.CollectedField, obj *model.CreateChangeSetPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CreateChangeSetPayload_errors(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Errors, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.MutationError)
	fc.Result = res
	return ec.marshalOMutationError2backendgraphmodelMutationError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CreateChangeSetPayload_errors(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CreateChangeSetPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "code":
				return ec.fieldContext_MutationError_code(ctx, field)
			case "message":
				return ec.fieldContext_MutationError_message(ctx, field)
			case "field":
				return ec.fieldContext_MutationError_field(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MutationError", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CreateResourcePayload_resource(ctx context.Context, field graphql.CollectedField, obj *model.CreateResourcePayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CreateResourcePayload_resource(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Resource, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(model.Resource)
	fc.Result = res
	return ec.marshalOResource2backendgraphmodelResource(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CreateResourcePayload_resource(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CreateResourcePayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("FieldContext.Child cannot be called on type INTERFACE")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CreateResourcePayload_errors(ctx context.Context, field graphql.CollectedField, obj *model.CreateResourcePayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CreateResourcePayload_errors(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Errors, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.MutationError)
	fc.Result = res
	return ec.marshalOMutationError2backendgraphmodelMutationError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CreateResourcePayload_errors(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CreateResourcePayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "code":
				return ec.fieldContext_MutationError_code(ctx, field)
			case "message":
				return ec.fieldContext_MutationError_message(ctx, field)
			case "field":
				return ec.fieldContext_MutationError_field(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MutationError", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CreateRouterPayload_router(ctx context.Context, field graphql.CollectedField, obj *model.CreateRouterPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CreateRouterPayload_router(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Router, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Router)
	fc.Result = res
	return ec.marshalORouter2backendgraphmodelRouter(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CreateRouterPayload_router(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CreateRouterPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Router_id(ctx, field)
			case "name":
				return ec.fieldContext_Router_name(ctx, field)
			case "host":
				return ec.fieldContext_Router_host(ctx, field)
			case "port":
				return ec.fieldContext_Router_port(ctx, field)
			case "status":
				return ec.fieldContext_Router_status(ctx, field)
			case "platform":
				return ec.fieldContext_Router_platform(ctx, field)
			case "version":
				return ec.fieldContext_Router_version(ctx, field)
			case "model":
				return ec.fieldContext_Router_model(ctx, field)
			case "uptime":
				return ec.fieldContext_Router_uptime(ctx, field)
			case "lastConnected":
				return ec.fieldContext_Router_lastConnected(ctx, field)
			case "createdAt":
				return ec.fieldContext_Router_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Router_updatedAt(ctx, field)
			case "capabilities":
				return ec.fieldContext_Router_capabilities(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Router", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CreateRouterPayload_errors(ctx context.Context, field graphql.CollectedField, obj *model.CreateRouterPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CreateRouterPayload_errors(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Errors, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.MutationError)
	fc.Result = res
	return ec.marshalOMutationError2backendgraphmodelMutationError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CreateRouterPayload_errors(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CreateRouterPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "code":
				return ec.fieldContext_MutationError_code(ctx, field)
			case "message":
				return ec.fieldContext_MutationError_message(ctx, field)
			case "field":
				return ec.fieldContext_MutationError_field(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MutationError", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CredentialTestResult_routerId(ctx context.Context, field graphql.CollectedField, obj *model.CredentialTestResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CredentialTestResult_routerId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RouterID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CredentialTestResult_routerId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CredentialTestResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CredentialTestResult_routerName(ctx context.Context, field graphql.CollectedField, obj *model.CredentialTestResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CredentialTestResult_routerName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RouterName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CredentialTestResult_routerName(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CredentialTestResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CredentialTestResult_success(ctx context.Context, field graphql.CollectedField, obj *model.CredentialTestResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CredentialTestResult_success(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Success, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CredentialTestResult_success(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CredentialTestResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CredentialTestResult_status(ctx context.Context, field graphql.CollectedField, obj *model.CredentialTestResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CredentialTestResult_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.CredentialTestStatus)
	fc.Result = res
	return ec.marshalNCredentialTestStatus2backendgraphmodelCredentialTestStatus(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CredentialTestResult_status(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CredentialTestResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type CredentialTestStatus does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CredentialTestResult_responseTimeMs(ctx context.Context, field graphql.CollectedField, obj *model.CredentialTestResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CredentialTestResult_responseTimeMs(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ResponseTimeMs, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CredentialTestResult_responseTimeMs(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CredentialTestResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CredentialTestResult_error(ctx context.Context, field graphql.CollectedField, obj *model.CredentialTestResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CredentialTestResult_error(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Error, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CredentialTestResult_error(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CredentialTestResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CredentialUpdatePayload_success(ctx context.Context, field graphql.CollectedField, obj *model.CredentialUpdatePayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CredentialUpdatePayload_success(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Success, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CredentialUpdatePayload_success(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CredentialUpdatePayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CredentialUpdatePayload_message(ctx context.Context, field graphql.CollectedField, obj *model.CredentialUpdatePayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CredentialUpdatePayload_message(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CredentialUpdatePayload_message(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CredentialUpdatePayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CredentialUpdatePayload_credentials(ctx context.Context, field graphql.CollectedField, obj *model.CredentialUpdatePayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CredentialUpdatePayload_credentials(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Credentials, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.RouterCredentials)
	fc.Result = res
	return ec.marshalORouterCredentials2backendgraphmodelRouterCredentials(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CredentialUpdatePayload_credentials(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CredentialUpdatePayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "routerId":
				return ec.fieldContext_RouterCredentials_routerId(ctx, field)
			case "username":
				return ec.fieldContext_RouterCredentials_username(ctx, field)
			case "hasPassword":
				return ec.fieldContext_RouterCredentials_hasPassword(ctx, field)
			case "encryptionStatus":
				return ec.fieldContext_RouterCredentials_encryptionStatus(ctx, field)
			case "keyVersion":
				return ec.fieldContext_RouterCredentials_keyVersion(ctx, field)
			case "lastUpdated":
				return ec.fieldContext_RouterCredentials_lastUpdated(ctx, field)
			case "createdAt":
				return ec.fieldContext_RouterCredentials_createdAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RouterCredentials", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CredentialUpdatePayload_errorCode(ctx context.Context, field graphql.CollectedField, obj *model.CredentialUpdatePayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CredentialUpdatePayload_errorCode(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ErrorCode, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.CredentialErrorCode)
	fc.Result = res
	return ec.marshalOCredentialErrorCode2backendgraphmodelCredentialErrorCode(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CredentialUpdatePayload_errorCode(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CredentialUpdatePayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type CredentialErrorCode does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CredentialUpdatePayload_errors(ctx context.Context, field graphql.CollectedField, obj *model.CredentialUpdatePayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CredentialUpdatePayload_errors(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Errors, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.MutationError)
	fc.Result = res
	return ec.marshalOMutationError2backendgraphmodelMutationError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CredentialUpdatePayload_errors(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CredentialUpdatePayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "code":
				return ec.fieldContext_MutationError_code(ctx, field)
			case "message":
				return ec.fieldContext_MutationError_message(ctx, field)
			case "field":
				return ec.fieldContext_MutationError_field(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MutationError", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CurrentItemInfo_id(ctx context.Context, field graphql.CollectedField, obj *model.CurrentItemInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CurrentItemInfo_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CurrentItemInfo_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CurrentItemInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CurrentItemInfo_name(ctx context.Context, field graphql.CollectedField, obj *model.CurrentItemInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CurrentItemInfo_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CurrentItemInfo_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CurrentItemInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CurrentItemInfo_operation(ctx context.Context, field graphql.CollectedField, obj *model.CurrentItemInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CurrentItemInfo_operation(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Operation, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.ChangeOperation)
	fc.Result = res
	return ec.marshalNChangeOperation2backendgraphmodelChangeOperation(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CurrentItemInfo_operation(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CurrentItemInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ChangeOperation does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CurrentItemInfo_status(ctx context.Context, field graphql.CollectedField, obj *model.CurrentItemInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CurrentItemInfo_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.ChangeSetItemStatus)
	fc.Result = res
	return ec.marshalNChangeSetItemStatus2backendgraphmodelChangeSetItemStatus(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CurrentItemInfo_status(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CurrentItemInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ChangeSetItemStatus does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DHCPServerResource_id(ctx context.Context, field graphql.CollectedField, obj *model.DHCPServerResource) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DHCPServerResource_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DHCPServerResource_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DHCPServerResource",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DHCPServerResource_scopedId(ctx context.Context, field graphql.CollectedField, obj *model.DHCPServerResource) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DHCPServerResource_scopedId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ScopedID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DHCPServerResource_scopedId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DHCPServerResource",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DHCPServerResource_type(ctx context.Context, field graphql.CollectedField, obj *model.DHCPServerResource) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DHCPServerResource_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DHCPServerResource_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DHCPServerResource",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DHCPServerResource_category(ctx context.Context, field graphql.CollectedField, obj *model.DHCPServerResource) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DHCPServerResource_category(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Category, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.ResourceCategory)
	fc.Result = res
	return ec.marshalNResourceCategory2backendgraphmodelResourceCategory(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DHCPServerResource_category(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DHCPServerResource",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ResourceCategory does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DHCPServerResource_configuration(ctx context.Context, field graphql.CollectedField, obj *model.DHCPServerResource) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DHCPServerResource_configuration(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Configuration, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalNJSON2map(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DHCPServerResource_configuration(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DHCPServerResource",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type JSON does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DHCPServerResource_validation(ctx context.Context, field graphql.CollectedField, obj *model.DHCPServerResource) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DHCPServerResource_validation(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Validation, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.ValidationResult)
	fc.Result = res
	return ec.marshalOValidationResult2backendgraphmodelValidationResult(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DHCPServerResource_validation(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DHCPServerResource",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "canApply":
				return ec.fieldContext_ValidationResult_canApply(ctx, field)
			case "stage":
				return ec.fieldContext_ValidationResult_stage(ctx, field)
			case "errors":
				return ec.fieldContext_ValidationResult_errors(ctx, field)
			case "warnings":
				return ec.fieldContext_ValidationResult_warnings(ctx, field)
			case "conflicts":
				return ec.fieldContext_ValidationResult_conflicts(ctx, field)
			case "requiredDependencies":
				return ec.fieldContext_ValidationResult_requiredDependencies(ctx, field)
			case "validatedAt":
				return ec.fieldContext_ValidationResult_validatedAt(ctx, field)
			case "validationDurationMs":
				return ec.fieldContext_ValidationResult_validationDurationMs(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ValidationResult", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _DHCPServerResource_deployment(ctx context.Context, field graphql.CollectedField, obj *model.DHCPServerResource) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DHCPServerResource_deployment(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Deployment, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.DeploymentState)
	fc.Result = res
	return ec.marshalODeploymentState2backendgraphmodelDeploymentState(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DHCPServerResource_deployment(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DHCPServerResource",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "routerResourceId":
				return ec.fieldContext_DeploymentState_routerResourceId(ctx, field)
			case "appliedAt":
				return ec.fieldContext_DeploymentState_appliedAt(ctx, field)
			case "appliedBy":
				return ec.fieldContext_DeploymentState_appliedBy(ctx, field)
			case "routerVersion":
				return ec.fieldContext_DeploymentState_routerVersion(ctx, field)
			case "generatedFields":
				return ec.fieldContext_DeploymentState_generatedFields(ctx, field)
			case "isInSync":
				return ec.fieldContext_DeploymentState_isInSync(ctx, field)
			case "drift":
				return ec.fieldContext_DeploymentState_drift(ctx, field)
			case "applyOperationId":
				return ec.fieldContext_DeploymentState_applyOperationId(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DeploymentState", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _DHCPServerResource_runtime(ctx context.Context, field graphql.CollectedField, obj *model.DHCPServerResource) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DHCPServerResource_runtime(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Runtime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.RuntimeState)
	fc.Result = res
	return ec.marshalORuntimeState2backendgraphmodelRuntimeState(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DHCPServerResource_runtime(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DHCPServerResource",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "isRunning":
				return ec.fieldContext_RuntimeState_isRunning(ctx, field)
			case "health":
				return ec.fieldContext_RuntimeState_health(ctx, field)
			case "errorMessage":
				return ec.fieldContext_RuntimeState_errorMessage(ctx, field)
			case "metrics":
				return ec.fieldContext_RuntimeState_metrics(ctx, field)
			case "lastUpdated":
				return ec.fieldContext_RuntimeState_lastUpdated(ctx, field)
			case "lastSuccessfulOperation":
				return ec.fieldContext_RuntimeState_lastSuccessfulOperation(ctx, field)
			case "activeConnections":
				return ec.fieldContext_RuntimeState_activeConnections(ctx, field)
			case "uptime":
				return ec.fieldContext_RuntimeState_uptime(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RuntimeState", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _DHCPServerResource_telemetry(ctx context.Context, field graphql.CollectedField, obj *model.DHCPServerResource) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DHCPServerResource_telemetry(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Telemetry, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.TelemetryData)
	fc.Result = res
	return ec.marshalOTelemetryData2backendgraphmodelTelemetryData(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DHCPServerResource_telemetry(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DHCPServerResource",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "bandwidthHistory":
				return ec.fieldContext_TelemetryData_bandwidthHistory(ctx, field)
			case "uptimeHistory":
				return ec.fieldContext_TelemetryData_uptimeHistory(ctx, field)
			case "hourlyStats":
				return ec.fieldContext_TelemetryData_hourlyStats(ctx, field)
			case "dailyStats":
				return ec.fieldContext_TelemetryData_dailyStats(ctx, field)
			case "dataStartedAt":
				return ec.fieldContext_TelemetryData_dataStartedAt(ctx, field)
			case "lastUpdatedAt":
				return ec.fieldContext_TelemetryData_lastUpdatedAt(ctx, field)
			case "retentionDays":
				return ec.fieldContext_TelemetryData_retentionDays(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TelemetryData", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _DHCPServerResource_metadata(ctx context.Context, field graphql.CollectedField, obj *model.DHCPServerResource) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DHCPServerResource_metadata(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Metadata, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.ResourceMetadata)
	fc.Result = res
	return ec.marshalNResourceMetadata2backendgraphmodelResourceMetadata(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DHCPServerResource_metadata(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DHCPServerResource",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "createdAt":
				return ec.fieldContext_ResourceMetadata_createdAt(ctx, field)
			case "createdBy":
				return ec.fieldContext_ResourceMetadata_createdBy(ctx, field)
			case "updatedAt":
				return ec.fieldContext_ResourceMetadata_updatedAt(ctx, field)
			case "updatedBy":
				return ec.fieldContext_ResourceMetadata_updatedBy(ctx, field)
			case "state":
				return ec.fieldContext_ResourceMetadata_state(ctx, field)
			case "version":
				return ec.fieldContext_ResourceMetadata_version(ctx, field)
			case "tags":
				return ec.fieldContext_ResourceMetadata_tags(ctx, field)
			case "description":
				return ec.fieldContext_ResourceMetadata_description(ctx, field)
			case "isFavorite":
				return ec.fieldContext_ResourceMetadata_isFavorite(ctx, field)
			case "isPinned":
				return ec.fieldContext_ResourceMetadata_isPinned(ctx, field)
			case "notes":
				return ec.fieldContext_ResourceMetadata_notes(ctx, field)
			case "recentChanges":
				return ec.fieldContext_ResourceMetadata_recentChanges(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ResourceMetadata", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _DHCPServerResource_relationships(ctx context.Context, field graphql.CollectedField, obj *model.DHCPServerResource) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DHCPServerResource_relationships(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Relationships, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.ResourceRelationships)
	fc.Result = res
	return ec.marshalOResourceRelationships2backendgraphmodelResourceRelationships(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DHCPServerResource_relationships(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DHCPServerResource",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "dependsOn":
				return ec.fieldContext_ResourceRelationships_dependsOn(ctx, field)
			case "dependents":
				return ec.fieldContext_ResourceRelationships_dependents(ctx, field)
			case "routesVia":
				return ec.fieldContext_ResourceRelationships_routesVia(ctx, field)
			case "routedBy":
				return ec.fieldContext_ResourceRelationships_routedBy(ctx, field)
			case "parent":
				return ec.fieldContext_ResourceRelationships_parent(ctx, field)
			case "children":
				return ec.fieldContext_ResourceRelationships_children(ctx, field)
			case "custom":
				return ec.fieldContext_ResourceRelationships_custom(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ResourceRelationships", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _DHCPServerResource_platform(ctx context.Context, field graphql.CollectedField, obj *model.DHCPServerResource) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DHCPServerResource_platform(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Platform, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.PlatformInfo)
	fc.Result = res
	return ec.marshalOPlatformInfo2backendgraphmodelPlatformInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DHCPServerResource_platform(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DHCPServerResource",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "current":
				return ec.fieldContext_PlatformInfo_current(ctx, field)
			case "capabilities":
				return ec.fieldContext_PlatformInfo_capabilities(ctx, field)
			case "fieldMappings":
				return ec.fieldContext_PlatformInfo_fieldMappings(ctx, field)
			case "limitations":
				return ec.fieldContext_PlatformInfo_limitations(ctx, field)
			case "features":
				return ec.fieldContext_PlatformInfo_features(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PlatformInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _DHCPServerResource_name(ctx context.Context, field graphql.CollectedField, obj *model.DHCPServerResource) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DHCPServerResource_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DHCPServerResource_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DHCPServerResource",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DHCPServerResource_interface(ctx context.Context, field graphql.CollectedField, obj *model.DHCPServerResource) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DHCPServerResource_interface(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Interface, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DHCPServerResource_interface(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DHCPServerResource",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DHCPServerResource_addressPool(ctx context.Context, field graphql.CollectedField, obj *model.DHCPServerResource) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DHCPServerResource_addressPool(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AddressPool, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DHCPServerResource_addressPool(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DHCPServerResource",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DHCPServerResource_leaseTime(ctx context.Context, field graphql.CollectedField, obj *model.DHCPServerResource) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DHCPServerResource_leaseTime(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LeaseTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.Duration)
	fc.Result = res
	return ec.marshalNDuration2backendgraphmodelDuration(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DHCPServerResource_leaseTime(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DHCPServerResource",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Duration does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DHCPServerResource_activeLeases(ctx context.Context, field graphql.CollectedField, obj *model.DHCPServerResource) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DHCPServerResource_activeLeases(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ActiveLeases, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DHCPServerResource_activeLeases(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DHCPServerResource",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DailyStats_date(ctx context.Context, field graphql.CollectedField, obj *model.DailyStats) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DailyStats_date(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Date, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNDateTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DailyStats_date(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DailyStats",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DateTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DailyStats_totalBytesIn(ctx context.Context, field graphql.CollectedField, obj *model.DailyStats) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DailyStats_totalBytesIn(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalBytesIn, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.Size)
	fc.Result = res
	return ec.marshalNSize2backendgraphmodelSize(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DailyStats_totalBytesIn(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DailyStats",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Size does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DailyStats_totalBytesOut(ctx context.Context, field graphql.CollectedField, obj *model.DailyStats) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DailyStats_totalBytesOut(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalBytesOut, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.Size)
	fc.Result = res
	return ec.marshalNSize2backendgraphmodelSize(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DailyStats_totalBytesOut(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DailyStats",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Size does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DailyStats_uptimePercent(ctx context.Context, field graphql.CollectedField, obj *model.DailyStats) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DailyStats_uptimePercent(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UptimePercent, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DailyStats_uptimePercent(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DailyStats",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DailyStats_errorCount(ctx context.Context, field graphql.CollectedField, obj *model.DailyStats) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DailyStats_errorCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ErrorCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DailyStats_errorCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DailyStats",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DailyStats_peakThroughputIn(ctx context.Context, field graphql.CollectedField, obj *model.DailyStats) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DailyStats_peakThroughputIn(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PeakThroughputIn, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.Size)
	fc.Result = res
	return ec.marshalNSize2backendgraphmodelSize(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DailyStats_peakThroughputIn(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DailyStats",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Size does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DailyStats_peakThroughputOut(ctx context.Context, field graphql.CollectedField, obj *model.DailyStats) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DailyStats_peakThroughputOut(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PeakThroughputOut, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.Size)
	fc.Result = res
	return ec.marshalNSize2backendgraphmodelSize(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DailyStats_peakThroughputOut(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DailyStats",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Size does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DeleteChangeSetPayload_success(ctx context.Context, field graphql.CollectedField, obj *model.DeleteChangeSetPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DeleteChangeSetPayload_success(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Success, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DeleteChangeSetPayload_success(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DeleteChangeSetPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DeleteChangeSetPayload_errors(ctx context.Context, field graphql.CollectedField, obj *model.DeleteChangeSetPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DeleteChangeSetPayload_errors(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Errors, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.MutationError)
	fc.Result = res
	return ec.marshalOMutationError2backendgraphmodelMutationError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DeleteChangeSetPayload_errors(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DeleteChangeSetPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "code":
				return ec.fieldContext_MutationError_code(ctx, field)
			case "message":
				return ec.fieldContext_MutationError_message(ctx, field)
			case "field":
				return ec.fieldContext_MutationError_field(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MutationError", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _DeletePayload_success(ctx context.Context, field graphql.CollectedField, obj *model.DeletePayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DeletePayload_success(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Success, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DeletePayload_success(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DeletePayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DeletePayload_deletedId(ctx context.Context, field graphql.CollectedField, obj *model.DeletePayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DeletePayload_deletedId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeletedID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DeletePayload_deletedId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DeletePayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DeletePayload_errors(ctx context.Context, field graphql.CollectedField, obj *model.DeletePayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DeletePayload_errors(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Errors, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.MutationError)
	fc.Result = res
	return ec.marshalOMutationError2backendgraphmodelMutationError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DeletePayload_errors(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DeletePayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "code":
				return ec.fieldContext_MutationError_code(ctx, field)
			case "message":
				return ec.fieldContext_MutationError_message(ctx, field)
			case "field":
				return ec.fieldContext_MutationError_field(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MutationError", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _DeleteResourcePayload_success(ctx context.Context, field graphql.CollectedField, obj *model.DeleteResourcePayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DeleteResourcePayload_success(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Success, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DeleteResourcePayload_success(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DeleteResourcePayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DeleteResourcePayload_deletedId(ctx context.Context, field graphql.CollectedField, obj *model.DeleteResourcePayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DeleteResourcePayload_deletedId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeletedID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DeleteResourcePayload_deletedId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DeleteResourcePayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DeleteResourcePayload_errors(ctx context.Context, field graphql.CollectedField, obj *model.DeleteResourcePayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DeleteResourcePayload_errors(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Errors, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.MutationError)
	fc.Result = res
	return ec.marshalOMutationError2backendgraphmodelMutationError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DeleteResourcePayload_errors(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DeleteResourcePayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "code":
				return ec.fieldContext_MutationError_code(ctx, field)
			case "message":
				return ec.fieldContext_MutationError_message(ctx, field)
			case "field":
				return ec.fieldContext_MutationError_field(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MutationError", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _DeleteResult_success(ctx context.Context, field graphql.CollectedField, obj *model.DeleteResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DeleteResult_success(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Success, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DeleteResult_success(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DeleteResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DeleteResult_message(ctx context.Context, field graphql.CollectedField, obj *model.DeleteResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DeleteResult_message(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DeleteResult_message(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DeleteResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DeleteResult_errors(ctx context.Context, field graphql.CollectedField, obj *model.DeleteResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DeleteResult_errors(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Errors, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.MutationError)
	fc.Result = res
	return ec.marshalOMutationError2backendgraphmodelMutationError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DeleteResult_errors(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DeleteResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "code":
				return ec.fieldContext_MutationError_code(ctx, field)
			case "message":
				return ec.fieldContext_MutationError_message(ctx, field)
			case "field":
				return ec.fieldContext_MutationError_field(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MutationError", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _DeleteRouterPayload_success(ctx context.Context, field graphql.CollectedField, obj *model.DeleteRouterPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DeleteRouterPayload_success(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Success, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DeleteRouterPayload_success(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DeleteRouterPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DeleteRouterPayload_deletedRouterId(ctx context.Context, field graphql.CollectedField, obj *model.DeleteRouterPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DeleteRouterPayload_deletedRouterId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeletedRouterID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DeleteRouterPayload_deletedRouterId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DeleteRouterPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DeleteRouterPayload_errors(ctx context.Context, field graphql.CollectedField, obj *model.DeleteRouterPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DeleteRouterPayload_errors(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Errors, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.MutationError)
	fc.Result = res
	return ec.marshalOMutationError2backendgraphmodelMutationError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DeleteRouterPayload_errors(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DeleteRouterPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "code":
				return ec.fieldContext_MutationError_code(ctx, field)
			case "message":
				return ec.fieldContext_MutationError_message(ctx, field)
			case "field":
				return ec.fieldContext_MutationError_field(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MutationError", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _DependencyStatus_resourceUuid(ctx context.Context, field graphql.CollectedField, obj *model.DependencyStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DependencyStatus_resourceUuid(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ResourceUUID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DependencyStatus_resourceUuid(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DependencyStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DependencyStatus_resourceType(ctx context.Context, field graphql.CollectedField, obj *model.DependencyStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DependencyStatus_resourceType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ResourceType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DependencyStatus_resourceType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DependencyStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DependencyStatus_isActive(ctx context.Context, field graphql.CollectedField, obj *model.DependencyStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DependencyStatus_isActive(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsActive, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DependencyStatus_isActive(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DependencyStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DependencyStatus_state(ctx context.Context, field graphql.CollectedField, obj *model.DependencyStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DependencyStatus_state(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.State, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.ResourceLifecycleState)
	fc.Result = res
	return ec.marshalNResourceLifecycleState2backendgraphmodelResourceLifecycleState(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DependencyStatus_state(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DependencyStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ResourceLifecycleState does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DependencyStatus_reason(ctx context.Context, field graphql.CollectedField, obj *model.DependencyStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DependencyStatus_reason(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Reason, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DependencyStatus_reason(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DependencyStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DeploymentState_routerResourceId(ctx context.Context, field graphql.CollectedField, obj *model.DeploymentState) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DeploymentState_routerResourceId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RouterResourceID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DeploymentState_routerResourceId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DeploymentState",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DeploymentState_appliedAt(ctx context.Context, field graphql.CollectedField, obj *model.DeploymentState) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DeploymentState_appliedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AppliedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNDateTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DeploymentState_appliedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DeploymentState",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DateTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DeploymentState_appliedBy(ctx context.Context, field graphql.CollectedField, obj *model.DeploymentState) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DeploymentState_appliedBy(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AppliedBy, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DeploymentState_appliedBy(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DeploymentState",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DeploymentState_routerVersion(ctx context.Context, field graphql.CollectedField, obj *model.DeploymentState) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DeploymentState_routerVersion(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RouterVersion, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DeploymentState_routerVersion(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DeploymentState",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DeploymentState_generatedFields(ctx context.Context, field graphql.CollectedField, obj *model.DeploymentState) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DeploymentState_generatedFields(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.GeneratedFields, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOJSON2map(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DeploymentState_generatedFields(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DeploymentState",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type JSON does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DeploymentState_isInSync(ctx context.Context, field graphql.CollectedField, obj *model.DeploymentState) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DeploymentState_isInSync(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsInSync, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DeploymentState_isInSync(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DeploymentState",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DeploymentState_drift(ctx context.Context, field graphql.CollectedField, obj *model.DeploymentState) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DeploymentState_drift(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Drift, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.DriftInfo)
	fc.Result = res
	return ec.marshalODriftInfo2backendgraphmodelDriftInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DeploymentState_drift(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DeploymentState",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "detectedAt":
				return ec.fieldContext_DriftInfo_detectedAt(ctx, field)
			case "driftedFields":
				return ec.fieldContext_DriftInfo_driftedFields(ctx, field)
			case "suggestedAction":
				return ec.fieldContext_DriftInfo_suggestedAction(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DriftInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _DeploymentState_applyOperationId(ctx context.Context, field graphql.CollectedField, obj *model.DeploymentState) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DeploymentState_applyOperationId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ApplyOperationID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DeploymentState_applyOperationId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DeploymentState",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DeprecateResourcePayload_resource(ctx context.Context, field graphql.CollectedField, obj *model.DeprecateResourcePayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DeprecateResourcePayload_resource(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Resource, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(model.Resource)
	fc.Result = res
	return ec.marshalOResource2backendgraphmodelResource(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DeprecateResourcePayload_resource(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DeprecateResourcePayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("FieldContext.Child cannot be called on type INTERFACE")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DeprecateResourcePayload_errors(ctx context.Context, field graphql.CollectedField, obj *model.DeprecateResourcePayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DeprecateResourcePayload_errors(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Errors, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.MutationError)
	fc.Result = res
	return ec.marshalOMutationError2backendgraphmodelMutationError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DeprecateResourcePayload_errors(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DeprecateResourcePayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "code":
				return ec.fieldContext_MutationError_code(ctx, field)
			case "message":
				return ec.fieldContext_MutationError_message(ctx, field)
			case "field":
				return ec.fieldContext_MutationError_field(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MutationError", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Device_id(ctx context.Context, field graphql.CollectedField, obj *model.Device) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Device_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Device_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Device",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Device_resourceMetrics(ctx context.Context, field graphql.CollectedField, obj *model.Device) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Device_resourceMetrics(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ResourceMetrics, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.ResourceMetrics)
	fc.Result = res
	return ec.marshalNResourceMetrics2backendgraphmodelResourceMetrics(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Device_resourceMetrics(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Device",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "cpu":
				return ec.fieldContext_ResourceMetrics_cpu(ctx, field)
			case "memory":
				return ec.fieldContext_ResourceMetrics_memory(ctx, field)
			case "storage":
				return ec.fieldContext_ResourceMetrics_storage(ctx, field)
			case "temperature":
				return ec.fieldContext_ResourceMetrics_temperature(ctx, field)
			case "timestamp":
				return ec.fieldContext_ResourceMetrics_timestamp(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ResourceMetrics", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _DhcpClient_id(ctx context.Context, field graphql.CollectedField, obj *model.DhcpClient) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DhcpClient_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DhcpClient_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DhcpClient",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DhcpClient_interface(ctx context.Context, field graphql.CollectedField, obj *model.DhcpClient) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DhcpClient_interface(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Interface, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DhcpClient_interface(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DhcpClient",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DhcpClient_disabled(ctx context.Context, field graphql.CollectedField, obj *model.DhcpClient) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DhcpClient_disabled(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Disabled, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DhcpClient_disabled(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DhcpClient",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DhcpClient_addDefaultRoute(ctx context.Context, field graphql.CollectedField, obj *model.DhcpClient) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DhcpClient_addDefaultRoute(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AddDefaultRoute, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DhcpClient_addDefaultRoute(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DhcpClient",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DhcpClient_usePeerDNS(ctx context.Context, field graphql.CollectedField, obj *model.DhcpClient) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DhcpClient_usePeerDNS(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UsePeerDNS, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DhcpClient_usePeerDNS(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DhcpClient",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DhcpClient_usePeerNTP(ctx context.Context, field graphql.CollectedField, obj *model.DhcpClient) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DhcpClient_usePeerNTP(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UsePeerNtp, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DhcpClient_usePeerNTP(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DhcpClient",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DhcpClient_status(ctx context.Context, field graphql.CollectedField, obj *model.DhcpClient) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DhcpClient_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DhcpClient_status(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DhcpClient",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DhcpClient_address(ctx context.Context, field graphql.CollectedField, obj *model.DhcpClient) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DhcpClient_address(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Address, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.IPv4)
	fc.Result = res
	return ec.marshalOIPv42backendgraphmodelIPv4(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DhcpClient_address(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DhcpClient",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type IPv4 does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DhcpClient_dhcpServer(ctx context.Context, field graphql.CollectedField, obj *model.DhcpClient) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DhcpClient_dhcpServer(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DhcpServer, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.IPv4)
	fc.Result = res
	return ec.marshalOIPv42backendgraphmodelIPv4(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DhcpClient_dhcpServer(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DhcpClient",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type IPv4 does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DhcpClient_gateway(ctx context.Context, field graphql.CollectedField, obj *model.DhcpClient) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DhcpClient_gateway(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Gateway, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.IPv4)
	fc.Result = res
	return ec.marshalOIPv42backendgraphmodelIPv4(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DhcpClient_gateway(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DhcpClient",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type IPv4 does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DhcpClient_expiresAfter(ctx context.Context, field graphql.CollectedField, obj *model.DhcpClient) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DhcpClient_expiresAfter(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ExpiresAfter, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Duration)
	fc.Result = res
	return ec.marshalODuration2backendgraphmodelDuration(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DhcpClient_expiresAfter(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DhcpClient",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Duration does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DhcpClient_comment(ctx context.Context, field graphql.CollectedField, obj *model.DhcpClient) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DhcpClient_comment(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Comment, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DhcpClient_comment(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DhcpClient",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DhcpServer_id(ctx context.Context, field graphql.CollectedField, obj *model.DhcpServer) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DhcpServer_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DhcpServer_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DhcpServer",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DhcpServer_name(ctx context.Context, field graphql.CollectedField, obj *model.DhcpServer) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DhcpServer_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DhcpServer_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DhcpServer",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DhcpServer_interface(ctx context.Context, field graphql.CollectedField, obj *model.DhcpServer) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DhcpServer_interface(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Interface, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Interface)
	fc.Result = res
	return ec.marshalNInterface2backendgraphmodelInterface(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DhcpServer_interface(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DhcpServer",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Interface_id(ctx, field)
			case "name":
				return ec.fieldContext_Interface_name(ctx, field)
			case "type":
				return ec.fieldContext_Interface_type(ctx, field)
			case "enabled":
				return ec.fieldContext_Interface_enabled(ctx, field)
			case "running":
				return ec.fieldContext_Interface_running(ctx, field)
			case "macAddress":
				return ec.fieldContext_Interface_macAddress(ctx, field)
			case "mtu":
				return ec.fieldContext_Interface_mtu(ctx, field)
			case "comment":
				return ec.fieldContext_Interface_comment(ctx, field)
			case "txBytes":
				return ec.fieldContext_Interface_txBytes(ctx, field)
			case "rxBytes":
				return ec.fieldContext_Interface_rxBytes(ctx, field)
			case "ip":
				return ec.fieldContext_Interface_ip(ctx, field)
			case "status":
				return ec.fieldContext_Interface_status(ctx, field)
			case "txRate":
				return ec.fieldContext_Interface_txRate(ctx, field)
			case "rxRate":
				return ec.fieldContext_Interface_rxRate(ctx, field)
			case "linkSpeed":
				return ec.fieldContext_Interface_linkSpeed(ctx, field)
			case "lastSeen":
				return ec.fieldContext_Interface_lastSeen(ctx, field)
			case "linkPartner":
				return ec.fieldContext_Interface_linkPartner(ctx, field)
			case "usedBy":
				return ec.fieldContext_Interface_usedBy(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Interface", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _DhcpServer_disabled(ctx context.Context, field graphql.CollectedField, obj *model.DhcpServer) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DhcpServer_disabled(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Disabled, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DhcpServer_disabled(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DhcpServer",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DiagnosticReport_routerId(ctx context.Context, field graphql.CollectedField, obj *model.DiagnosticReport) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DiagnosticReport_routerId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RouterID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DiagnosticReport_routerId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DiagnosticReport",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DiagnosticReport_timestamp(ctx context.Context, field graphql.CollectedField, obj *model.DiagnosticReport) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DiagnosticReport_timestamp(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Timestamp, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNDateTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DiagnosticReport_timestamp(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DiagnosticReport",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DateTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DiagnosticReport_networkReachable(ctx context.Context, field graphql.CollectedField, obj *model.DiagnosticReport) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DiagnosticReport_networkReachable(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NetworkReachable, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DiagnosticReport_networkReachable(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DiagnosticReport",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DiagnosticReport_portStatus(ctx context.Context, field graphql.CollectedField, obj *model.DiagnosticReport) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DiagnosticReport_portStatus(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PortStatus, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.PortStatus)
	fc.Result = res
	return ec.marshalNPortStatus2backendgraphmodelPortStatus(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DiagnosticReport_portStatus(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DiagnosticReport",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "port":
				return ec.fieldContext_PortStatus_port(ctx, field)
			case "service":
				return ec.fieldContext_PortStatus_service(ctx, field)
			case "open":
				return ec.fieldContext_PortStatus_open(ctx, field)
			case "responseTimeMs":
				return ec.fieldContext_PortStatus_responseTimeMs(ctx, field)
			case "error":
				return ec.fieldContext_PortStatus_error(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PortStatus", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _DiagnosticReport_tlsStatus(ctx context.Context, field graphql.CollectedField, obj *model.DiagnosticReport) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DiagnosticReport_tlsStatus(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TLSStatus, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.TLSStatus)
	fc.Result = res
	return ec.marshalOTLSStatus2backendgraphmodelTLSStatus(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DiagnosticReport_tlsStatus(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DiagnosticReport",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "valid":
				return ec.fieldContext_TLSStatus_valid(ctx, field)
			case "issuer":
				return ec.fieldContext_TLSStatus_issuer(ctx, field)
			case "subject":
				return ec.fieldContext_TLSStatus_subject(ctx, field)
			case "expiresAt":
				return ec.fieldContext_TLSStatus_expiresAt(ctx, field)
			case "error":
				return ec.fieldContext_TLSStatus_error(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TLSStatus", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _DiagnosticReport_authStatus(ctx context.Context, field graphql.CollectedField, obj *model.DiagnosticReport) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DiagnosticReport_authStatus(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AuthStatus, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.AuthStatus)
	fc.Result = res
	return ec.marshalNAuthStatus2backendgraphmodelAuthStatus(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DiagnosticReport_authStatus(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DiagnosticReport",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "tested":
				return ec.fieldContext_AuthStatus_tested(ctx, field)
			case "success":
				return ec.fieldContext_AuthStatus_success(ctx, field)
			case "error":
				return ec.fieldContext_AuthStatus_error(ctx, field)
			case "errorCode":
				return ec.fieldContext_AuthStatus_errorCode(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type AuthStatus", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _DiagnosticReport_suggestions(ctx context.Context, field graphql.CollectedField, obj *model.DiagnosticReport) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DiagnosticReport_suggestions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Suggestions, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.DiagnosticSuggestion)
	fc.Result = res
	return ec.marshalNDiagnosticSuggestion2backendgraphmodelDiagnosticSuggestion(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DiagnosticReport_suggestions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DiagnosticReport",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "severity":
				return ec.fieldContext_DiagnosticSuggestion_severity(ctx, field)
			case "title":
				return ec.fieldContext_DiagnosticSuggestion_title(ctx, field)
			case "description":
				return ec.fieldContext_DiagnosticSuggestion_description(ctx, field)
			case "action":
				return ec.fieldContext_DiagnosticSuggestion_action(ctx, field)
			case "docsUrl":
				return ec.fieldContext_DiagnosticSuggestion_docsUrl(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DiagnosticSuggestion", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _DiagnosticReport_rawReport(ctx context.Context, field graphql.CollectedField, obj *model.DiagnosticReport) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DiagnosticReport_rawReport(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RawReport, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DiagnosticReport_rawReport(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DiagnosticReport",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DiagnosticSuggestion_severity(ctx context.Context, field graphql.CollectedField, obj *model.DiagnosticSuggestion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DiagnosticSuggestion_severity(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Severity, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.SuggestionSeverity)
	fc.Result = res
	return ec.marshalNSuggestionSeverity2backendgraphmodelSuggestionSeverity(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DiagnosticSuggestion_severity(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DiagnosticSuggestion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type SuggestionSeverity does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DiagnosticSuggestion_title(ctx context.Context, field graphql.CollectedField, obj *model.DiagnosticSuggestion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DiagnosticSuggestion_title(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Title, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DiagnosticSuggestion_title(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DiagnosticSuggestion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DiagnosticSuggestion_description(ctx context.Context, field graphql.CollectedField, obj *model.DiagnosticSuggestion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DiagnosticSuggestion_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DiagnosticSuggestion_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DiagnosticSuggestion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DiagnosticSuggestion_action(ctx context.Context, field graphql.CollectedField, obj *model.DiagnosticSuggestion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DiagnosticSuggestion_action(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Action, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DiagnosticSuggestion_action(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DiagnosticSuggestion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DiagnosticSuggestion_docsUrl(ctx context.Context, field graphql.CollectedField, obj *model.DiagnosticSuggestion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DiagnosticSuggestion_docsUrl(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DocsURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DiagnosticSuggestion_docsUrl(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DiagnosticSuggestion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DisconnectRouterPayload_router(ctx context.Context, field graphql.CollectedField, obj *model.DisconnectRouterPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DisconnectRouterPayload_router(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Router, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Router)
	fc.Result = res
	return ec.marshalORouter2backendgraphmodelRouter(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DisconnectRouterPayload_router(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DisconnectRouterPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Router_id(ctx, field)
			case "name":
				return ec.fieldContext_Router_name(ctx, field)
			case "host":
				return ec.fieldContext_Router_host(ctx, field)
			case "port":
				return ec.fieldContext_Router_port(ctx, field)
			case "status":
				return ec.fieldContext_Router_status(ctx, field)
			case "platform":
				return ec.fieldContext_Router_platform(ctx, field)
			case "version":
				return ec.fieldContext_Router_version(ctx, field)
			case "model":
				return ec.fieldContext_Router_model(ctx, field)
			case "uptime":
				return ec.fieldContext_Router_uptime(ctx, field)
			case "lastConnected":
				return ec.fieldContext_Router_lastConnected(ctx, field)
			case "createdAt":
				return ec.fieldContext_Router_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Router_updatedAt(ctx, field)
			case "capabilities":
				return ec.fieldContext_Router_capabilities(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Router", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _DisconnectRouterPayload_errors(ctx context.Context, field graphql.CollectedField, obj *model.DisconnectRouterPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DisconnectRouterPayload_errors(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Errors, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.MutationError)
	fc.Result = res
	return ec.marshalOMutationError2backendgraphmodelMutationError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DisconnectRouterPayload_errors(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DisconnectRouterPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "code":
				return ec.fieldContext_MutationError_code(ctx, field)
			case "message":
				return ec.fieldContext_MutationError_message(ctx, field)
			case "field":
				return ec.fieldContext_MutationError_field(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MutationError", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _DiscoveredDevice_ip(ctx context.Context, field graphql.CollectedField, obj *model.DiscoveredDevice) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DiscoveredDevice_ip(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IP, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DiscoveredDevice_ip(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DiscoveredDevice",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DiscoveredDevice_hostname(ctx context.Context, field graphql.CollectedField, obj *model.DiscoveredDevice) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DiscoveredDevice_hostname(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Hostname, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DiscoveredDevice_hostname(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DiscoveredDevice",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DiscoveredDevice_ports(ctx context.Context, field graphql.CollectedField, obj *model.DiscoveredDevice) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DiscoveredDevice_ports(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Ports, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DiscoveredDevice_ports(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DiscoveredDevice",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DiscoveredDevice_deviceType(ctx context.Context, field graphql.CollectedField, obj *model.DiscoveredDevice) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DiscoveredDevice_deviceType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeviceType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DiscoveredDevice_deviceType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DiscoveredDevice",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DiscoveredDevice_vendor(ctx context.Context, field graphql.CollectedField, obj *model.DiscoveredDevice) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DiscoveredDevice_vendor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Vendor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DiscoveredDevice_vendor(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DiscoveredDevice",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DiscoveredDevice_routerOSInfo(ctx context.Context, field graphql.CollectedField, obj *model.DiscoveredDevice) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DiscoveredDevice_routerOSInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RouterOSInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.RouterOSInfo)
	fc.Result = res
	return ec.marshalORouterOSInfo2backendgraphmodelRouterOSInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DiscoveredDevice_routerOSInfo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DiscoveredDevice",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "version":
				return ec.fieldContext_RouterOSInfo_version(ctx, field)
			case "boardName":
				return ec.fieldContext_RouterOSInfo_boardName(ctx, field)
			case "architecture":
				return ec.fieldContext_RouterOSInfo_architecture(ctx, field)
			case "platform":
				return ec.fieldContext_RouterOSInfo_platform(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RouterOSInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _DiscoveredDevice_confidence(ctx context.Context, field graphql.CollectedField, obj *model.DiscoveredDevice) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DiscoveredDevice_confidence(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Confidence, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DiscoveredDevice_confidence(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DiscoveredDevice",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DiscoveredDevice_services(ctx context.Context, field graphql.CollectedField, obj *model.DiscoveredDevice) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DiscoveredDevice_services(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Services, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DiscoveredDevice_services(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DiscoveredDevice",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DnsLookupResult_hostname(ctx context.Context, field graphql.CollectedField, obj *model.DNSLookupResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DnsLookupResult_hostname(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Hostname, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DnsLookupResult_hostname(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DnsLookupResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DnsLookupResult_recordType(ctx context.Context, field graphql.CollectedField, obj *model.DNSLookupResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DnsLookupResult_recordType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RecordType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.DNSRecordType)
	fc.Result = res
	return ec.marshalNDnsRecordType2backendgraphmodelDNSRecordType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DnsLookupResult_recordType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DnsLookupResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DnsRecordType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DnsLookupResult_status(ctx context.Context, field graphql.CollectedField, obj *model.DNSLookupResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DnsLookupResult_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.DNSLookupStatus)
	fc.Result = res
	return ec.marshalNDnsLookupStatus2backendgraphmodelDNSLookupStatus(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DnsLookupResult_status(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DnsLookupResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DnsLookupStatus does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DnsLookupResult_records(ctx context.Context, field graphql.CollectedField, obj *model.DNSLookupResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DnsLookupResult_records(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Records, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.DNSRecord)
	fc.Result = res
	return ec.marshalNDnsRecord2backendgraphmodelDNSRecord(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DnsLookupResult_records(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DnsLookupResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_DnsRecord_name(ctx, field)
			case "type":
				return ec.fieldContext_DnsRecord_type(ctx, field)
			case "ttl":
				return ec.fieldContext_DnsRecord_ttl(ctx, field)
			case "data":
				return ec.fieldContext_DnsRecord_data(ctx, field)
			case "priority":
				return ec.fieldContext_DnsRecord_priority(ctx, field)
			case "weight":
				return ec.fieldContext_DnsRecord_weight(ctx, field)
			case "port":
				return ec.fieldContext_DnsRecord_port(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DnsRecord", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _DnsLookupResult_server(ctx context.Context, field graphql.CollectedField, obj *model.DNSLookupResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DnsLookupResult_server(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Server, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DnsLookupResult_server(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DnsLookupResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DnsLookupResult_queryTime(ctx context.Context, field graphql.CollectedField, obj *model.DNSLookupResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DnsLookupResult_queryTime(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.QueryTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DnsLookupResult_queryTime(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DnsLookupResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DnsLookupResult_authoritative(ctx context.Context, field graphql.CollectedField, obj *model.DNSLookupResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DnsLookupResult_authoritative(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Authoritative, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DnsLookupResult_authoritative(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DnsLookupResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DnsLookupResult_error(ctx context.Context, field graphql.CollectedField, obj *model.DNSLookupResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DnsLookupResult_error(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Error, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DnsLookupResult_error(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DnsLookupResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DnsLookupResult_timestamp(ctx context.Context, field graphql.CollectedField, obj *model.DNSLookupResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DnsLookupResult_timestamp(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Timestamp, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNDateTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DnsLookupResult_timestamp(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DnsLookupResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DateTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DnsRecord_name(ctx context.Context, field graphql.CollectedField, obj *model.DNSRecord) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DnsRecord_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DnsRecord_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DnsRecord",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DnsRecord_type(ctx context.Context, field graphql.CollectedField, obj *model.DNSRecord) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DnsRecord_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.DNSRecordType)
	fc.Result = res
	return ec.marshalNDnsRecordType2backendgraphmodelDNSRecordType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DnsRecord_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DnsRecord",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DnsRecordType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DnsRecord_ttl(ctx context.Context, field graphql.CollectedField, obj *model.DNSRecord) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DnsRecord_ttl(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TTL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DnsRecord_ttl(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DnsRecord",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DnsRecord_data(ctx context.Context, field graphql.CollectedField, obj *model.DNSRecord) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DnsRecord_data(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Data, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DnsRecord_data(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DnsRecord",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DnsRecord_priority(ctx context.Context, field graphql.CollectedField, obj *model.DNSRecord) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DnsRecord_priority(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Priority, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DnsRecord_priority(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DnsRecord",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DnsRecord_weight(ctx context.Context, field graphql.CollectedField, obj *model.DNSRecord) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DnsRecord_weight(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Weight, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DnsRecord_weight(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DnsRecord",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DnsRecord_port(ctx context.Context, field graphql.CollectedField, obj *model.DNSRecord) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DnsRecord_port(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Port, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DnsRecord_port(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DnsRecord",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DnsServer_address(ctx context.Context, field graphql.CollectedField, obj *model.DNSServer) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DnsServer_address(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Address, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DnsServer_address(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DnsServer",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DnsServer_isPrimary(ctx context.Context, field graphql.CollectedField, obj *model.DNSServer) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DnsServer_isPrimary(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsPrimary, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DnsServer_isPrimary(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DnsServer",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DnsServer_isSecondary(ctx context.Context, field graphql.CollectedField, obj *model.DNSServer) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DnsServer_isSecondary(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsSecondary, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DnsServer_isSecondary(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DnsServer",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DnsServers_servers(ctx context.Context, field graphql.CollectedField, obj *model.DNSServers) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DnsServers_servers(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Servers, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.DNSServer)
	fc.Result = res
	return ec.marshalNDnsServer2backendgraphmodelDNSServer(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DnsServers_servers(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DnsServers",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "address":
				return ec.fieldContext_DnsServer_address(ctx, field)
			case "isPrimary":
				return ec.fieldContext_DnsServer_isPrimary(ctx, field)
			case "isSecondary":
				return ec.fieldContext_DnsServer_isSecondary(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DnsServer", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _DnsServers_primary(ctx context.Context, field graphql.CollectedField, obj *model.DNSServers) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DnsServers_primary(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Primary, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DnsServers_primary(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DnsServers",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DnsServers_secondary(ctx context.Context, field graphql.CollectedField, obj *model.DNSServers) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DnsServers_secondary(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Secondary, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DnsServers_secondary(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DnsServers",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DriftField_path(ctx context.Context, field graphql.CollectedField, obj *model.DriftField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DriftField_path(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Path, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DriftField_path(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DriftField",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DriftField_expected(ctx context.Context, field graphql.CollectedField, obj *model.DriftField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DriftField_expected(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Expected, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOJSON2map(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DriftField_expected(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DriftField",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type JSON does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DriftField_actual(ctx context.Context, field graphql.CollectedField, obj *model.DriftField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DriftField_actual(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Actual, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOJSON2map(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DriftField_actual(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DriftField",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type JSON does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DriftInfo_detectedAt(ctx context.Context, field graphql.CollectedField, obj *model.DriftInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DriftInfo_detectedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DetectedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNDateTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DriftInfo_detectedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DriftInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DateTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DriftInfo_driftedFields(ctx context.Context, field graphql.CollectedField, obj *model.DriftInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DriftInfo_driftedFields(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DriftedFields, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.DriftField)
	fc.Result = res
	return ec.marshalNDriftField2backendgraphmodelDriftField(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DriftInfo_driftedFields(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DriftInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "path":
				return ec.fieldContext_DriftField_path(ctx, field)
			case "expected":
				return ec.fieldContext_DriftField_expected(ctx, field)
			case "actual":
				return ec.fieldContext_DriftField_actual(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DriftField", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _DriftInfo_suggestedAction(ctx context.Context, field graphql.CollectedField, obj *model.DriftInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DriftInfo_suggestedAction(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SuggestedAction, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.DriftAction)
	fc.Result = res
	return ec.marshalNDriftAction2backendgraphmodelDriftAction(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DriftInfo_suggestedAction(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DriftInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DriftAction does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ErrorExtensions_code(ctx context.Context, field graphql.CollectedField, obj *model.ErrorExtensions) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ErrorExtensions_code(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Code, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ErrorExtensions_code(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ErrorExtensions",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ErrorExtensions_category(ctx context.Context, field graphql.CollectedField, obj *model.ErrorExtensions) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ErrorExtensions_category(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Category, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ErrorExtensions_category(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ErrorExtensions",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ErrorExtensions_field(ctx context.Context, field graphql.CollectedField, obj *model.ErrorExtensions) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ErrorExtensions_field(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Field, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ErrorExtensions_field(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ErrorExtensions",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ErrorExtensions_value(ctx context.Context, field graphql.CollectedField, obj *model.ErrorExtensions) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ErrorExtensions_value(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Value, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOJSON2map(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ErrorExtensions_value(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ErrorExtensions",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type JSON does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ErrorExtensions_suggestedFix(ctx context.Context, field graphql.CollectedField, obj *model.ErrorExtensions) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ErrorExtensions_suggestedFix(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SuggestedFix, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ErrorExtensions_suggestedFix(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ErrorExtensions",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ErrorExtensions_docsUrl(ctx context.Context, field graphql.CollectedField, obj *model.ErrorExtensions) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ErrorExtensions_docsUrl(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DocsURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ErrorExtensions_docsUrl(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ErrorExtensions",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ErrorExtensions_requestId(ctx context.Context, field graphql.CollectedField, obj *model.ErrorExtensions) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ErrorExtensions_requestId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RequestID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ErrorExtensions_requestId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ErrorExtensions",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ErrorExtensions_recoverable(ctx context.Context, field graphql.CollectedField, obj *model.ErrorExtensions) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ErrorExtensions_recoverable(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Recoverable, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ErrorExtensions_recoverable(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ErrorExtensions",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ErrorExtensions_troubleshootingSteps(ctx context.Context, field graphql.CollectedField, obj *model.ErrorExtensions) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ErrorExtensions_troubleshootingSteps(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TroubleshootingSteps, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ErrorExtensions_troubleshootingSteps(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ErrorExtensions",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ExportConfigPayload_success(ctx context.Context, field graphql.CollectedField, obj *model.ExportConfigPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ExportConfigPayload_success(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Success, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ExportConfigPayload_success(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ExportConfigPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ExportConfigPayload_config(ctx context.Context, field graphql.CollectedField, obj *model.ExportConfigPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ExportConfigPayload_config(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Config, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOJSON2map(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ExportConfigPayload_config(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ExportConfigPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type JSON does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ExportConfigPayload_securityWarning(ctx context.Context, field graphql.CollectedField, obj *model.ExportConfigPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ExportConfigPayload_securityWarning(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SecurityWarning, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ExportConfigPayload_securityWarning(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ExportConfigPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ExportConfigPayload_errors(ctx context.Context, field graphql.CollectedField, obj *model.ExportConfigPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ExportConfigPayload_errors(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Errors, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.MutationError)
	fc.Result = res
	return ec.marshalOMutationError2backendgraphmodelMutationError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ExportConfigPayload_errors(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ExportConfigPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "code":
				return ec.fieldContext_MutationError_code(ctx, field)
			case "message":
				return ec.fieldContext_MutationError_message(ctx, field)
			case "field":
				return ec.fieldContext_MutationError_field(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MutationError", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeatureCompatibilityInfo_featureId(ctx context.Context, field graphql.CollectedField, obj *model.FeatureCompatibilityInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeatureCompatibilityInfo_featureId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FeatureID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeatureCompatibilityInfo_featureId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeatureCompatibilityInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeatureCompatibilityInfo_name(ctx context.Context, field graphql.CollectedField, obj *model.FeatureCompatibilityInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeatureCompatibilityInfo_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeatureCompatibilityInfo_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeatureCompatibilityInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeatureCompatibilityInfo_minVersion(ctx context.Context, field graphql.CollectedField, obj *model.FeatureCompatibilityInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeatureCompatibilityInfo_minVersion(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MinVersion, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeatureCompatibilityInfo_minVersion(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeatureCompatibilityInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeatureCompatibilityInfo_maxVersion(ctx context.Context, field graphql.CollectedField, obj *model.FeatureCompatibilityInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeatureCompatibilityInfo_maxVersion(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MaxVersion, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeatureCompatibilityInfo_maxVersion(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeatureCompatibilityInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeatureCompatibilityInfo_minVersionCHR(ctx context.Context, field graphql.CollectedField, obj *model.FeatureCompatibilityInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeatureCompatibilityInfo_minVersionCHR(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MinVersionChr, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeatureCompatibilityInfo_minVersionCHR(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeatureCompatibilityInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeatureCompatibilityInfo_requiredPackages(ctx context.Context, field graphql.CollectedField, obj *model.FeatureCompatibilityInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeatureCompatibilityInfo_requiredPackages(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RequiredPackages, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeatureCompatibilityInfo_requiredPackages(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeatureCompatibilityInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeatureCompatibilityInfo_dependsOn(ctx context.Context, field graphql.CollectedField, obj *model.FeatureCompatibilityInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeatureCompatibilityInfo_dependsOn(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DependsOn, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeatureCompatibilityInfo_dependsOn(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeatureCompatibilityInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeatureCompatibilityInfo_upgradeUrl(ctx context.Context, field graphql.CollectedField, obj *model.FeatureCompatibilityInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeatureCompatibilityInfo_upgradeUrl(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpgradeURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeatureCompatibilityInfo_upgradeUrl(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeatureCompatibilityInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeatureDeployment_routerResourceId(ctx context.Context, field graphql.CollectedField, obj *model.FeatureDeployment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeatureDeployment_routerResourceId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RouterResourceID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeatureDeployment_routerResourceId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeatureDeployment",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeatureDeployment_appliedAt(ctx context.Context, field graphql.CollectedField, obj *model.FeatureDeployment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeatureDeployment_appliedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AppliedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNDateTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeatureDeployment_appliedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeatureDeployment",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DateTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeatureDeployment_appliedBy(ctx context.Context, field graphql.CollectedField, obj *model.FeatureDeployment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeatureDeployment_appliedBy(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AppliedBy, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeatureDeployment_appliedBy(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeatureDeployment",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeatureDeployment_routerVersion(ctx context.Context, field graphql.CollectedField, obj *model.FeatureDeployment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeatureDeployment_routerVersion(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RouterVersion, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeatureDeployment_routerVersion(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeatureDeployment",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeatureDeployment_isInSync(ctx context.Context, field graphql.CollectedField, obj *model.FeatureDeployment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeatureDeployment_isInSync(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsInSync, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeatureDeployment_isInSync(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeatureDeployment",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeatureDeployment_drift(ctx context.Context, field graphql.CollectedField, obj *model.FeatureDeployment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeatureDeployment_drift(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Drift, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.DriftInfo)
	fc.Result = res
	return ec.marshalODriftInfo2backendgraphmodelDriftInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeatureDeployment_drift(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeatureDeployment",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "detectedAt":
				return ec.fieldContext_DriftInfo_detectedAt(ctx, field)
			case "driftedFields":
				return ec.fieldContext_DriftInfo_driftedFields(ctx, field)
			case "suggestedAction":
				return ec.fieldContext_DriftInfo_suggestedAction(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DriftInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeatureDeployment_containerId(ctx context.Context, field graphql.CollectedField, obj *model.FeatureDeployment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeatureDeployment_containerId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ContainerID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeatureDeployment_containerId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeatureDeployment",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeatureDeployment_containerImage(ctx context.Context, field graphql.CollectedField, obj *model.FeatureDeployment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeatureDeployment_containerImage(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ContainerImage, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeatureDeployment_containerImage(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeatureDeployment",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeatureDeployment_assignedPorts(ctx context.Context, field graphql.CollectedField, obj *model.FeatureDeployment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeatureDeployment_assignedPorts(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AssignedPorts, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]model.Port)
	fc.Result = res
	return ec.marshalOPort2backendgraphmodelPort(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeatureDeployment_assignedPorts(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeatureDeployment",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Port does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeatureDeployment_assignedIP(ctx context.Context, field graphql.CollectedField, obj *model.FeatureDeployment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeatureDeployment_assignedIP(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AssignedIP, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.IPv4)
	fc.Result = res
	return ec.marshalOIPv42backendgraphmodelIPv4(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeatureDeployment_assignedIP(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeatureDeployment",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type IPv4 does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeatureResource_id(ctx context.Context, field graphql.CollectedField, obj *model.FeatureResource) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeatureResource_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeatureResource_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeatureResource",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeatureResource_scopedId(ctx context.Context, field graphql.CollectedField, obj *model.FeatureResource) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeatureResource_scopedId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ScopedID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeatureResource_scopedId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeatureResource",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeatureResource_type(ctx context.Context, field graphql.CollectedField, obj *model.FeatureResource) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeatureResource_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeatureResource_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeatureResource",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeatureResource_category(ctx context.Context, field graphql.CollectedField, obj *model.FeatureResource) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeatureResource_category(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Category, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.ResourceCategory)
	fc.Result = res
	return ec.marshalNResourceCategory2backendgraphmodelResourceCategory(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeatureResource_category(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeatureResource",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ResourceCategory does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeatureResource_configuration(ctx context.Context, field graphql.CollectedField, obj *model.FeatureResource) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeatureResource_configuration(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Configuration, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOJSON2map(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeatureResource_configuration(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeatureResource",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type JSON does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeatureResource_validation(ctx context.Context, field graphql.CollectedField, obj *model.FeatureResource) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeatureResource_validation(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Validation, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.ValidationResult)
	fc.Result = res
	return ec.marshalOValidationResult2backendgraphmodelValidationResult(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeatureResource_validation(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeatureResource",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "canApply":
				return ec.fieldContext_ValidationResult_canApply(ctx, field)
			case "stage":
				return ec.fieldContext_ValidationResult_stage(ctx, field)
			case "errors":
				return ec.fieldContext_ValidationResult_errors(ctx, field)
			case "warnings":
				return ec.fieldContext_ValidationResult_warnings(ctx, field)
			case "conflicts":
				return ec.fieldContext_ValidationResult_conflicts(ctx, field)
			case "requiredDependencies":
				return ec.fieldContext_ValidationResult_requiredDependencies(ctx, field)
			case "validatedAt":
				return ec.fieldContext_ValidationResult_validatedAt(ctx, field)
			case "validationDurationMs":
				return ec.fieldContext_ValidationResult_validationDurationMs(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ValidationResult", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeatureResource_deployment(ctx context.Context, field graphql.CollectedField, obj *model.FeatureResource) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeatureResource_deployment(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Deployment, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.DeploymentState)
	fc.Result = res
	return ec.marshalODeploymentState2backendgraphmodelDeploymentState(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeatureResource_deployment(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeatureResource",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "routerResourceId":
				return ec.fieldContext_DeploymentState_routerResourceId(ctx, field)
			case "appliedAt":
				return ec.fieldContext_DeploymentState_appliedAt(ctx, field)
			case "appliedBy":
				return ec.fieldContext_DeploymentState_appliedBy(ctx, field)
			case "routerVersion":
				return ec.fieldContext_DeploymentState_routerVersion(ctx, field)
			case "generatedFields":
				return ec.fieldContext_DeploymentState_generatedFields(ctx, field)
			case "isInSync":
				return ec.fieldContext_DeploymentState_isInSync(ctx, field)
			case "drift":
				return ec.fieldContext_DeploymentState_drift(ctx, field)
			case "applyOperationId":
				return ec.fieldContext_DeploymentState_applyOperationId(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DeploymentState", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeatureResource_runtime(ctx context.Context, field graphql.CollectedField, obj *model.FeatureResource) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeatureResource_runtime(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Runtime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.RuntimeState)
	fc.Result = res
	return ec.marshalORuntimeState2backendgraphmodelRuntimeState(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeatureResource_runtime(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeatureResource",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "isRunning":
				return ec.fieldContext_RuntimeState_isRunning(ctx, field)
			case "health":
				return ec.fieldContext_RuntimeState_health(ctx, field)
			case "errorMessage":
				return ec.fieldContext_RuntimeState_errorMessage(ctx, field)
			case "metrics":
				return ec.fieldContext_RuntimeState_metrics(ctx, field)
			case "lastUpdated":
				return ec.fieldContext_RuntimeState_lastUpdated(ctx, field)
			case "lastSuccessfulOperation":
				return ec.fieldContext_RuntimeState_lastSuccessfulOperation(ctx, field)
			case "activeConnections":
				return ec.fieldContext_RuntimeState_activeConnections(ctx, field)
			case "uptime":
				return ec.fieldContext_RuntimeState_uptime(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RuntimeState", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeatureResource_telemetry(ctx context.Context, field graphql.CollectedField, obj *model.FeatureResource) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeatureResource_telemetry(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Telemetry, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.TelemetryData)
	fc.Result = res
	return ec.marshalOTelemetryData2backendgraphmodelTelemetryData(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeatureResource_telemetry(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeatureResource",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "bandwidthHistory":
				return ec.fieldContext_TelemetryData_bandwidthHistory(ctx, field)
			case "uptimeHistory":
				return ec.fieldContext_TelemetryData_uptimeHistory(ctx, field)
			case "hourlyStats":
				return ec.fieldContext_TelemetryData_hourlyStats(ctx, field)
			case "dailyStats":
				return ec.fieldContext_TelemetryData_dailyStats(ctx, field)
			case "dataStartedAt":
				return ec.fieldContext_TelemetryData_dataStartedAt(ctx, field)
			case "lastUpdatedAt":
				return ec.fieldContext_TelemetryData_lastUpdatedAt(ctx, field)
			case "retentionDays":
				return ec.fieldContext_TelemetryData_retentionDays(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TelemetryData", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeatureResource_metadata(ctx context.Context, field graphql.CollectedField, obj *model.FeatureResource) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeatureResource_metadata(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Metadata, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.ResourceMetadata)
	fc.Result = res
	return ec.marshalNResourceMetadata2backendgraphmodelResourceMetadata(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeatureResource_metadata(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeatureResource",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "createdAt":
				return ec.fieldContext_ResourceMetadata_createdAt(ctx, field)
			case "createdBy":
				return ec.fieldContext_ResourceMetadata_createdBy(ctx, field)
			case "updatedAt":
				return ec.fieldContext_ResourceMetadata_updatedAt(ctx, field)
			case "updatedBy":
				return ec.fieldContext_ResourceMetadata_updatedBy(ctx, field)
			case "state":
				return ec.fieldContext_ResourceMetadata_state(ctx, field)
			case "version":
				return ec.fieldContext_ResourceMetadata_version(ctx, field)
			case "tags":
				return ec.fieldContext_ResourceMetadata_tags(ctx, field)
			case "description":
				return ec.fieldContext_ResourceMetadata_description(ctx, field)
			case "isFavorite":
				return ec.fieldContext_ResourceMetadata_isFavorite(ctx, field)
			case "isPinned":
				return ec.fieldContext_ResourceMetadata_isPinned(ctx, field)
			case "notes":
				return ec.fieldContext_ResourceMetadata_notes(ctx, field)
			case "recentChanges":
				return ec.fieldContext_ResourceMetadata_recentChanges(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ResourceMetadata", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeatureResource_relationships(ctx context.Context, field graphql.CollectedField, obj *model.FeatureResource) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeatureResource_relationships(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Relationships, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.ResourceRelationships)
	fc.Result = res
	return ec.marshalOResourceRelationships2backendgraphmodelResourceRelationships(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeatureResource_relationships(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeatureResource",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "dependsOn":
				return ec.fieldContext_ResourceRelationships_dependsOn(ctx, field)
			case "dependents":
				return ec.fieldContext_ResourceRelationships_dependents(ctx, field)
			case "routesVia":
				return ec.fieldContext_ResourceRelationships_routesVia(ctx, field)
			case "routedBy":
				return ec.fieldContext_ResourceRelationships_routedBy(ctx, field)
			case "parent":
				return ec.fieldContext_ResourceRelationships_parent(ctx, field)
			case "children":
				return ec.fieldContext_ResourceRelationships_children(ctx, field)
			case "custom":
				return ec.fieldContext_ResourceRelationships_custom(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ResourceRelationships", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeatureResource_platform(ctx context.Context, field graphql.CollectedField, obj *model.FeatureResource) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeatureResource_platform(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Platform, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.PlatformInfo)
	fc.Result = res
	return ec.marshalOPlatformInfo2backendgraphmodelPlatformInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeatureResource_platform(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeatureResource",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "current":
				return ec.fieldContext_PlatformInfo_current(ctx, field)
			case "capabilities":
				return ec.fieldContext_PlatformInfo_capabilities(ctx, field)
			case "fieldMappings":
				return ec.fieldContext_PlatformInfo_fieldMappings(ctx, field)
			case "limitations":
				return ec.fieldContext_PlatformInfo_limitations(ctx, field)
			case "features":
				return ec.fieldContext_PlatformInfo_features(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PlatformInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeatureResource_featureDeployment(ctx context.Context, field graphql.CollectedField, obj *model.FeatureResource) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeatureResource_featureDeployment(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FeatureDeployment, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.FeatureDeployment)
	fc.Result = res
	return ec.marshalOFeatureDeployment2backendgraphmodelFeatureDeployment(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeatureResource_featureDeployment(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeatureResource",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "routerResourceId":
				return ec.fieldContext_FeatureDeployment_routerResourceId(ctx, field)
			case "appliedAt":
				return ec.fieldContext_FeatureDeployment_appliedAt(ctx, field)
			case "appliedBy":
				return ec.fieldContext_FeatureDeployment_appliedBy(ctx, field)
			case "routerVersion":
				return ec.fieldContext_FeatureDeployment_routerVersion(ctx, field)
			case "isInSync":
				return ec.fieldContext_FeatureDeployment_isInSync(ctx, field)
			case "drift":
				return ec.fieldContext_FeatureDeployment_drift(ctx, field)
			case "containerId":
				return ec.fieldContext_FeatureDeployment_containerId(ctx, field)
			case "containerImage":
				return ec.fieldContext_FeatureDeployment_containerImage(ctx, field)
			case "assignedPorts":
				return ec.fieldContext_FeatureDeployment_assignedPorts(ctx, field)
			case "assignedIP":
				return ec.fieldContext_FeatureDeployment_assignedIP(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FeatureDeployment", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeatureResource_featureRuntime(ctx context.Context, field graphql.CollectedField, obj *model.FeatureResource) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeatureResource_featureRuntime(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FeatureRuntime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.FeatureRuntime)
	fc.Result = res
	return ec.marshalOFeatureRuntime2backendgraphmodelFeatureRuntime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeatureResource_featureRuntime(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeatureResource",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "isRunning":
				return ec.fieldContext_FeatureRuntime_isRunning(ctx, field)
			case "health":
				return ec.fieldContext_FeatureRuntime_health(ctx, field)
			case "errorMessage":
				return ec.fieldContext_FeatureRuntime_errorMessage(ctx, field)
			case "lastUpdated":
				return ec.fieldContext_FeatureRuntime_lastUpdated(ctx, field)
			case "containerStatus":
				return ec.fieldContext_FeatureRuntime_containerStatus(ctx, field)
			case "memoryUsage":
				return ec.fieldContext_FeatureRuntime_memoryUsage(ctx, field)
			case "cpuUsagePercent":
				return ec.fieldContext_FeatureRuntime_cpuUsagePercent(ctx, field)
			case "routedDevices":
				return ec.fieldContext_FeatureRuntime_routedDevices(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FeatureRuntime", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeatureResource_featureId(ctx context.Context, field graphql.CollectedField, obj *model.FeatureResource) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeatureResource_featureId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FeatureID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeatureResource_featureId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeatureResource",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeatureResource_name(ctx context.Context, field graphql.CollectedField, obj *model.FeatureResource) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeatureResource_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeatureResource_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeatureResource",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeatureResource_version(ctx context.Context, field graphql.CollectedField, obj *model.FeatureResource) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeatureResource_version(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Version, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeatureResource_version(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeatureResource",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeatureResource_virtualInterface(ctx context.Context, field graphql.CollectedField, obj *model.FeatureResource) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeatureResource_virtualInterface(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.VirtualInterface, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeatureResource_virtualInterface(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeatureResource",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeatureRuntime_isRunning(ctx context.Context, field graphql.CollectedField, obj *model.FeatureRuntime) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeatureRuntime_isRunning(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsRunning, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeatureRuntime_isRunning(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeatureRuntime",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeatureRuntime_health(ctx context.Context, field graphql.CollectedField, obj *model.FeatureRuntime) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeatureRuntime_health(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Health, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.RuntimeHealth)
	fc.Result = res
	return ec.marshalNRuntimeHealth2backendgraphmodelRuntimeHealth(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeatureRuntime_health(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeatureRuntime",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type RuntimeHealth does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeatureRuntime_errorMessage(ctx context.Context, field graphql.CollectedField, obj *model.FeatureRuntime) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeatureRuntime_errorMessage(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ErrorMessage, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeatureRuntime_errorMessage(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeatureRuntime",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeatureRuntime_lastUpdated(ctx context.Context, field graphql.CollectedField, obj *model.FeatureRuntime) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeatureRuntime_lastUpdated(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LastUpdated, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNDateTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeatureRuntime_lastUpdated(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeatureRuntime",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DateTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeatureRuntime_containerStatus(ctx context.Context, field graphql.CollectedField, obj *model.FeatureRuntime) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeatureRuntime_containerStatus(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ContainerStatus, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeatureRuntime_containerStatus(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeatureRuntime",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeatureRuntime_memoryUsage(ctx context.Context, field graphql.CollectedField, obj *model.FeatureRuntime) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeatureRuntime_memoryUsage(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MemoryUsage, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Size)
	fc.Result = res
	return ec.marshalOSize2backendgraphmodelSize(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeatureRuntime_memoryUsage(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeatureRuntime",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Size does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeatureRuntime_cpuUsagePercent(ctx context.Context, field graphql.CollectedField, obj *model.FeatureRuntime) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeatureRuntime_cpuUsagePercent(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CPUUsagePercent, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeatureRuntime_cpuUsagePercent(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeatureRuntime",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeatureRuntime_routedDevices(ctx context.Context, field graphql.CollectedField, obj *model.FeatureRuntime) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeatureRuntime_routedDevices(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RoutedDevices, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeatureRuntime_routedDevices(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeatureRuntime",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeatureSupport_featureId(ctx context.Context, field graphql.CollectedField, obj *model.FeatureSupport) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeatureSupport_featureId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FeatureID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeatureSupport_featureId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeatureSupport",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeatureSupport_name(ctx context.Context, field graphql.CollectedField, obj *model.FeatureSupport) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeatureSupport_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeatureSupport_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeatureSupport",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeatureSupport_supported(ctx context.Context, field graphql.CollectedField, obj *model.FeatureSupport) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeatureSupport_supported(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Supported, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeatureSupport_supported(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeatureSupport",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeatureSupport_level(ctx context.Context, field graphql.CollectedField, obj *model.FeatureSupport) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeatureSupport_level(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Level, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.CapabilityLevel)
	fc.Result = res
	return ec.marshalNCapabilityLevel2backendgraphmodelCapabilityLevel(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeatureSupport_level(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeatureSupport",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type CapabilityLevel does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeatureSupport_reason(ctx context.Context, field graphql.CollectedField, obj *model.FeatureSupport) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeatureSupport_reason(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Reason, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeatureSupport_reason(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeatureSupport",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeatureSupport_requiredVersion(ctx context.Context, field graphql.CollectedField, obj *model.FeatureSupport) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeatureSupport_requiredVersion(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RequiredVersion, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeatureSupport_requiredVersion(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeatureSupport",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeatureSupport_upgradeUrl(ctx context.Context, field graphql.CollectedField, obj *model.FeatureSupport) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeatureSupport_upgradeUrl(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpgradeURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeatureSupport_upgradeUrl(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeatureSupport",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeatureSupport_requiredPackages(ctx context.Context, field graphql.CollectedField, obj *model.FeatureSupport) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeatureSupport_requiredPackages(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RequiredPackages, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeatureSupport_requiredPackages(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeatureSupport",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeatureSupport_missingPackages(ctx context.Context, field graphql.CollectedField, obj *model.FeatureSupport) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeatureSupport_missingPackages(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MissingPackages, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeatureSupport_missingPackages(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeatureSupport",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FirewallRule_id(ctx context.Context, field graphql.CollectedField, obj *model.FirewallRule) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FirewallRule_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FirewallRule_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FirewallRule",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FirewallRule_chain(ctx context.Context, field graphql.CollectedField, obj *model.FirewallRule) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FirewallRule_chain(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Chain, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FirewallRule_chain(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FirewallRule",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FirewallRule_action(ctx context.Context, field graphql.CollectedField, obj *model.FirewallRule) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FirewallRule_action(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Action, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FirewallRule_action(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FirewallRule",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FirewallRule_inInterface(ctx context.Context, field graphql.CollectedField, obj *model.FirewallRule) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FirewallRule_inInterface(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.InInterface, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FirewallRule_inInterface(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FirewallRule",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FirewallRule_outInterface(ctx context.Context, field graphql.CollectedField, obj *model.FirewallRule) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FirewallRule_outInterface(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OutInterface, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FirewallRule_outInterface(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FirewallRule",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FirewallRule_disabled(ctx context.Context, field graphql.CollectedField, obj *model.FirewallRule) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FirewallRule_disabled(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Disabled, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FirewallRule_disabled(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FirewallRule",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FirewallRuleResource_id(ctx context.Context, field graphql.CollectedField, obj *model.FirewallRuleResource) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FirewallRuleResource_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FirewallRuleResource_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FirewallRuleResource",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FirewallRuleResource_scopedId(ctx context.Context, field graphql.CollectedField, obj *model.FirewallRuleResource) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FirewallRuleResource_scopedId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ScopedID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FirewallRuleResource_scopedId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FirewallRuleResource",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FirewallRuleResource_type(ctx context.Context, field graphql.CollectedField, obj *model.FirewallRuleResource) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FirewallRuleResource_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FirewallRuleResource_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FirewallRuleResource",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FirewallRuleResource_category(ctx context.Context, field graphql.CollectedField, obj *model.FirewallRuleResource) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FirewallRuleResource_category(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Category, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.ResourceCategory)
	fc.Result = res
	return ec.marshalNResourceCategory2backendgraphmodelResourceCategory(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FirewallRuleResource_category(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FirewallRuleResource",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ResourceCategory does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FirewallRuleResource_configuration(ctx context.Context, field graphql.CollectedField, obj *model.FirewallRuleResource) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FirewallRuleResource_configuration(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Configuration, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalNJSON2map(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FirewallRuleResource_configuration(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FirewallRuleResource",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type JSON does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FirewallRuleResource_validation(ctx context.Context, field graphql.CollectedField, obj *model.FirewallRuleResource) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FirewallRuleResource_validation(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Validation, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.ValidationResult)
	fc.Result = res
	return ec.marshalOValidationResult2backendgraphmodelValidationResult(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FirewallRuleResource_validation(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FirewallRuleResource",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "canApply":
				return ec.fieldContext_ValidationResult_canApply(ctx, field)
			case "stage":
				return ec.fieldContext_ValidationResult_stage(ctx, field)
			case "errors":
				return ec.fieldContext_ValidationResult_errors(ctx, field)
			case "warnings":
				return ec.fieldContext_ValidationResult_warnings(ctx, field)
			case "conflicts":
				return ec.fieldContext_ValidationResult_conflicts(ctx, field)
			case "requiredDependencies":
				return ec.fieldContext_ValidationResult_requiredDependencies(ctx, field)
			case "validatedAt":
				return ec.fieldContext_ValidationResult_validatedAt(ctx, field)
			case "validationDurationMs":
				return ec.fieldContext_ValidationResult_validationDurationMs(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ValidationResult", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _FirewallRuleResource_deployment(ctx context.Context, field graphql.CollectedField, obj *model.FirewallRuleResource) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FirewallRuleResource_deployment(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Deployment, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.DeploymentState)
	fc.Result = res
	return ec.marshalODeploymentState2backendgraphmodelDeploymentState(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FirewallRuleResource_deployment(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FirewallRuleResource",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "routerResourceId":
				return ec.fieldContext_DeploymentState_routerResourceId(ctx, field)
			case "appliedAt":
				return ec.fieldContext_DeploymentState_appliedAt(ctx, field)
			case "appliedBy":
				return ec.fieldContext_DeploymentState_appliedBy(ctx, field)
			case "routerVersion":
				return ec.fieldContext_DeploymentState_routerVersion(ctx, field)
			case "generatedFields":
				return ec.fieldContext_DeploymentState_generatedFields(ctx, field)
			case "isInSync":
				return ec.fieldContext_DeploymentState_isInSync(ctx, field)
			case "drift":
				return ec.fieldContext_DeploymentState_drift(ctx, field)
			case "applyOperationId":
				return ec.fieldContext_DeploymentState_applyOperationId(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DeploymentState", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _FirewallRuleResource_runtime(ctx context.Context, field graphql.CollectedField, obj *model.FirewallRuleResource) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FirewallRuleResource_runtime(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Runtime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.RuntimeState)
	fc.Result = res
	return ec.marshalORuntimeState2backendgraphmodelRuntimeState(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FirewallRuleResource_runtime(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FirewallRuleResource",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "isRunning":
				return ec.fieldContext_RuntimeState_isRunning(ctx, field)
			case "health":
				return ec.fieldContext_RuntimeState_health(ctx, field)
			case "errorMessage":
				return ec.fieldContext_RuntimeState_errorMessage(ctx, field)
			case "metrics":
				return ec.fieldContext_RuntimeState_metrics(ctx, field)
			case "lastUpdated":
				return ec.fieldContext_RuntimeState_lastUpdated(ctx, field)
			case "lastSuccessfulOperation":
				return ec.fieldContext_RuntimeState_lastSuccessfulOperation(ctx, field)
			case "activeConnections":
				return ec.fieldContext_RuntimeState_activeConnections(ctx, field)
			case "uptime":
				return ec.fieldContext_RuntimeState_uptime(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RuntimeState", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _FirewallRuleResource_telemetry(ctx context.Context, field graphql.CollectedField, obj *model.FirewallRuleResource) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FirewallRuleResource_telemetry(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Telemetry, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.TelemetryData)
	fc.Result = res
	return ec.marshalOTelemetryData2backendgraphmodelTelemetryData(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FirewallRuleResource_telemetry(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FirewallRuleResource",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "bandwidthHistory":
				return ec.fieldContext_TelemetryData_bandwidthHistory(ctx, field)
			case "uptimeHistory":
				return ec.fieldContext_TelemetryData_uptimeHistory(ctx, field)
			case "hourlyStats":
				return ec.fieldContext_TelemetryData_hourlyStats(ctx, field)
			case "dailyStats":
				return ec.fieldContext_TelemetryData_dailyStats(ctx, field)
			case "dataStartedAt":
				return ec.fieldContext_TelemetryData_dataStartedAt(ctx, field)
			case "lastUpdatedAt":
				return ec.fieldContext_TelemetryData_lastUpdatedAt(ctx, field)
			case "retentionDays":
				return ec.fieldContext_TelemetryData_retentionDays(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TelemetryData", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _FirewallRuleResource_metadata(ctx context.Context, field graphql.CollectedField, obj *model.FirewallRuleResource) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FirewallRuleResource_metadata(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Metadata, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.ResourceMetadata)
	fc.Result = res
	return ec.marshalNResourceMetadata2backendgraphmodelResourceMetadata(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FirewallRuleResource_metadata(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FirewallRuleResource",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "createdAt":
				return ec.fieldContext_ResourceMetadata_createdAt(ctx, field)
			case "createdBy":
				return ec.fieldContext_ResourceMetadata_createdBy(ctx, field)
			case "updatedAt":
				return ec.fieldContext_ResourceMetadata_updatedAt(ctx, field)
			case "updatedBy":
				return ec.fieldContext_ResourceMetadata_updatedBy(ctx, field)
			case "state":
				return ec.fieldContext_ResourceMetadata_state(ctx, field)
			case "version":
				return ec.fieldContext_ResourceMetadata_version(ctx, field)
			case "tags":
				return ec.fieldContext_ResourceMetadata_tags(ctx, field)
			case "description":
				return ec.fieldContext_ResourceMetadata_description(ctx, field)
			case "isFavorite":
				return ec.fieldContext_ResourceMetadata_isFavorite(ctx, field)
			case "isPinned":
				return ec.fieldContext_ResourceMetadata_isPinned(ctx, field)
			case "notes":
				return ec.fieldContext_ResourceMetadata_notes(ctx, field)
			case "recentChanges":
				return ec.fieldContext_ResourceMetadata_recentChanges(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ResourceMetadata", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _FirewallRuleResource_relationships(ctx context.Context, field graphql.CollectedField, obj *model.FirewallRuleResource) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FirewallRuleResource_relationships(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Relationships, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.ResourceRelationships)
	fc.Result = res
	return ec.marshalOResourceRelationships2backendgraphmodelResourceRelationships(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FirewallRuleResource_relationships(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FirewallRuleResource",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "dependsOn":
				return ec.fieldContext_ResourceRelationships_dependsOn(ctx, field)
			case "dependents":
				return ec.fieldContext_ResourceRelationships_dependents(ctx, field)
			case "routesVia":
				return ec.fieldContext_ResourceRelationships_routesVia(ctx, field)
			case "routedBy":
				return ec.fieldContext_ResourceRelationships_routedBy(ctx, field)
			case "parent":
				return ec.fieldContext_ResourceRelationships_parent(ctx, field)
			case "children":
				return ec.fieldContext_ResourceRelationships_children(ctx, field)
			case "custom":
				return ec.fieldContext_ResourceRelationships_custom(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ResourceRelationships", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _FirewallRuleResource_platform(ctx context.Context, field graphql.CollectedField, obj *model.FirewallRuleResource) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FirewallRuleResource_platform(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Platform, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.PlatformInfo)
	fc.Result = res
	return ec.marshalOPlatformInfo2backendgraphmodelPlatformInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FirewallRuleResource_platform(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FirewallRuleResource",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "current":
				return ec.fieldContext_PlatformInfo_current(ctx, field)
			case "capabilities":
				return ec.fieldContext_PlatformInfo_capabilities(ctx, field)
			case "fieldMappings":
				return ec.fieldContext_PlatformInfo_fieldMappings(ctx, field)
			case "limitations":
				return ec.fieldContext_PlatformInfo_limitations(ctx, field)
			case "features":
				return ec.fieldContext_PlatformInfo_features(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PlatformInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _FirewallRuleResource_chain(ctx context.Context, field graphql.CollectedField, obj *model.FirewallRuleResource) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FirewallRuleResource_chain(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Chain, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FirewallRuleResource_chain(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FirewallRuleResource",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FirewallRuleResource_action(ctx context.Context, field graphql.CollectedField, obj *model.FirewallRuleResource) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FirewallRuleResource_action(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Action, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FirewallRuleResource_action(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FirewallRuleResource",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FirewallRuleResource_srcAddress(ctx context.Context, field graphql.CollectedField, obj *model.FirewallRuleResource) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FirewallRuleResource_srcAddress(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SrcAddress, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FirewallRuleResource_srcAddress(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FirewallRuleResource",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FirewallRuleResource_dstAddress(ctx context.Context, field graphql.CollectedField, obj *model.FirewallRuleResource) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FirewallRuleResource_dstAddress(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DstAddress, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FirewallRuleResource_dstAddress(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FirewallRuleResource",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FirewallRuleResource_srcPort(ctx context.Context, field graphql.CollectedField, obj *model.FirewallRuleResource) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FirewallRuleResource_srcPort(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SrcPort, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FirewallRuleResource_srcPort(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FirewallRuleResource",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FirewallRuleResource_dstPort(ctx context.Context, field graphql.CollectedField, obj *model.FirewallRuleResource) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FirewallRuleResource_dstPort(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DstPort, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FirewallRuleResource_dstPort(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FirewallRuleResource",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FirewallRuleResource_protocol(ctx context.Context, field graphql.CollectedField, obj *model.FirewallRuleResource) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FirewallRuleResource_protocol(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Protocol, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FirewallRuleResource_protocol(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FirewallRuleResource",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FirewallRuleResource_comment(ctx context.Context, field graphql.CollectedField, obj *model.FirewallRuleResource) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FirewallRuleResource_comment(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Comment, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FirewallRuleResource_comment(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FirewallRuleResource",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FirewallRuleResource_enabled(ctx context.Context, field graphql.CollectedField, obj *model.FirewallRuleResource) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FirewallRuleResource_enabled(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Enabled, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FirewallRuleResource_enabled(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FirewallRuleResource",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FirewallRuleResource_hitCount(ctx context.Context, field graphql.CollectedField, obj *model.FirewallRuleResource) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FirewallRuleResource_hitCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HitCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FirewallRuleResource_hitCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FirewallRuleResource",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GatewayReachabilityResult_reachable(ctx context.Context, field graphql.CollectedField, obj *model.GatewayReachabilityResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GatewayReachabilityResult_reachable(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Reachable, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GatewayReachabilityResult_reachable(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GatewayReachabilityResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GatewayReachabilityResult_latency(ctx context.Context, field graphql.CollectedField, obj *model.GatewayReachabilityResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GatewayReachabilityResult_latency(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Latency, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GatewayReachabilityResult_latency(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GatewayReachabilityResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GatewayReachabilityResult_interface(ctx context.Context, field graphql.CollectedField, obj *model.GatewayReachabilityResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GatewayReachabilityResult_interface(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Interface, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GatewayReachabilityResult_interface(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GatewayReachabilityResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GatewayReachabilityResult_message(ctx context.Context, field graphql.CollectedField, obj *model.GatewayReachabilityResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GatewayReachabilityResult_message(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GatewayReachabilityResult_message(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GatewayReachabilityResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HardwareInfo_architecture(ctx context.Context, field graphql.CollectedField, obj *model.HardwareInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HardwareInfo_architecture(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Architecture, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HardwareInfo_architecture(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HardwareInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HardwareInfo_model(ctx context.Context, field graphql.CollectedField, obj *model.HardwareInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HardwareInfo_model(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Model, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HardwareInfo_model(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HardwareInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HardwareInfo_boardName(ctx context.Context, field graphql.CollectedField, obj *model.HardwareInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HardwareInfo_boardName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BoardName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HardwareInfo_boardName(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HardwareInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HardwareInfo_totalMemory(ctx context.Context, field graphql.CollectedField, obj *model.HardwareInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HardwareInfo_totalMemory(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalMemory, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.Size)
	fc.Result = res
	return ec.marshalNSize2backendgraphmodelSize(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HardwareInfo_totalMemory(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HardwareInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Size does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HardwareInfo_availableStorage(ctx context.Context, field graphql.CollectedField, obj *model.HardwareInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HardwareInfo_availableStorage(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AvailableStorage, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.Size)
	fc.Result = res
	return ec.marshalNSize2backendgraphmodelSize(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HardwareInfo_availableStorage(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HardwareInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Size does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HardwareInfo_cpuCount(ctx context.Context, field graphql.CollectedField, obj *model.HardwareInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HardwareInfo_cpuCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CPUCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HardwareInfo_cpuCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HardwareInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HardwareInfo_hasWirelessChip(ctx context.Context, field graphql.CollectedField, obj *model.HardwareInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HardwareInfo_hasWirelessChip(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HasWirelessChip, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HardwareInfo_hasWirelessChip(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HardwareInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HardwareInfo_hasLTEModule(ctx context.Context, field graphql.CollectedField, obj *model.HardwareInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HardwareInfo_hasLTEModule(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HasLTEModule, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HardwareInfo_hasLTEModule(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HardwareInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HealthCheckResult_routerId(ctx context.Context, field graphql.CollectedField, obj *model.HealthCheckResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HealthCheckResult_routerId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RouterID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HealthCheckResult_routerId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HealthCheckResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HealthCheckResult_healthy(ctx context.Context, field graphql.CollectedField, obj *model.HealthCheckResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HealthCheckResult_healthy(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Healthy, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HealthCheckResult_healthy(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HealthCheckResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HealthCheckResult_checkedAt(ctx context.Context, field graphql.CollectedField, obj *model.HealthCheckResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HealthCheckResult_checkedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CheckedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNDateTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HealthCheckResult_checkedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HealthCheckResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DateTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HealthCheckResult_responseTimeMs(ctx context.Context, field graphql.CollectedField, obj *model.HealthCheckResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HealthCheckResult_responseTimeMs(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ResponseTimeMs, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HealthCheckResult_responseTimeMs(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HealthCheckResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HealthCheckResult_error(ctx context.Context, field graphql.CollectedField, obj *model.HealthCheckResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HealthCheckResult_error(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Error, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HealthCheckResult_error(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HealthCheckResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HealthStatus_status(ctx context.Context, field graphql.CollectedField, obj *model.HealthStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HealthStatus_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.ServiceStatus)
	fc.Result = res
	return ec.marshalNServiceStatus2backendgraphmodelServiceStatus(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HealthStatus_status(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HealthStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ServiceStatus does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HealthStatus_version(ctx context.Context, field graphql.CollectedField, obj *model.HealthStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HealthStatus_version(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Version, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HealthStatus_version(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HealthStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HealthStatus_uptime(ctx context.Context, field graphql.CollectedField, obj *model.HealthStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HealthStatus_uptime(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Uptime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Duration)
	fc.Result = res
	return ec.marshalODuration2backendgraphmodelDuration(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HealthStatus_uptime(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HealthStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Duration does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HealthStatus_connectedRouters(ctx context.Context, field graphql.CollectedField, obj *model.HealthStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HealthStatus_connectedRouters(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ConnectedRouters, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HealthStatus_connectedRouters(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HealthStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HealthStatus_checkedAt(ctx context.Context, field graphql.CollectedField, obj *model.HealthStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HealthStatus_checkedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CheckedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNDateTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HealthStatus_checkedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HealthStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DateTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HopProbe_probeNumber(ctx context.Context, field graphql.CollectedField, obj *model.HopProbe) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HopProbe_probeNumber(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ProbeNumber, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HopProbe_probeNumber(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HopProbe",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HopProbe_latencyMs(ctx context.Context, field graphql.CollectedField, obj *model.HopProbe) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HopProbe_latencyMs(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LatencyMs, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HopProbe_latencyMs(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HopProbe",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HopProbe_success(ctx context.Context, field graphql.CollectedField, obj *model.HopProbe) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HopProbe_success(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Success, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HopProbe_success(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HopProbe",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HopProbe_icmpCode(ctx context.Context, field graphql.CollectedField, obj *model.HopProbe) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HopProbe_icmpCode(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ICMPCode, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HopProbe_icmpCode(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HopProbe",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HourlyStats_hour(ctx context.Context, field graphql.CollectedField, obj *model.HourlyStats) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HourlyStats_hour(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Hour, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNDateTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HourlyStats_hour(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HourlyStats",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DateTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HourlyStats_totalBytesIn(ctx context.Context, field graphql.CollectedField, obj *model.HourlyStats) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HourlyStats_totalBytesIn(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalBytesIn, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.Size)
	fc.Result = res
	return ec.marshalNSize2backendgraphmodelSize(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HourlyStats_totalBytesIn(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HourlyStats",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Size does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HourlyStats_totalBytesOut(ctx context.Context, field graphql.CollectedField, obj *model.HourlyStats) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HourlyStats_totalBytesOut(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalBytesOut, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.Size)
	fc.Result = res
	return ec.marshalNSize2backendgraphmodelSize(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HourlyStats_totalBytesOut(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HourlyStats",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Size does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HourlyStats_uptimePercent(ctx context.Context, field graphql.CollectedField, obj *model.HourlyStats) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HourlyStats_uptimePercent(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UptimePercent, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HourlyStats_uptimePercent(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HourlyStats",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HourlyStats_errorCount(ctx context.Context, field graphql.CollectedField, obj *model.HourlyStats) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HourlyStats_errorCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ErrorCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HourlyStats_errorCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HourlyStats",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ISPInfo_name(ctx context.Context, field graphql.CollectedField, obj *model.ISPInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ISPInfo_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ISPInfo_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ISPInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ISPInfo_phone(ctx context.Context, field graphql.CollectedField, obj *model.ISPInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ISPInfo_phone(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Phone, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ISPInfo_phone(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ISPInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ISPInfo_url(ctx context.Context, field graphql.CollectedField, obj *model.ISPInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ISPInfo_url(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.URL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ISPInfo_url(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ISPInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Interface_id(ctx context.Context, field graphql.CollectedField, obj *model.Interface) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Interface_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Interface_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Interface",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Interface_name(ctx context.Context, field graphql.CollectedField, obj *model.Interface) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Interface_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Interface_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Interface",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Interface_type(ctx context.Context, field graphql.CollectedField, obj *model.Interface) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Interface_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.InterfaceType)
	fc.Result = res
	return ec.marshalNInterfaceType2backendgraphmodelInterfaceType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Interface_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Interface",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type InterfaceType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Interface_enabled(ctx context.Context, field graphql.CollectedField, obj *model.Interface) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Interface_enabled(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Enabled, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Interface_enabled(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Interface",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Interface_running(ctx context.Context, field graphql.CollectedField, obj *model.Interface) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Interface_running(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Running, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Interface_running(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Interface",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Interface_macAddress(ctx context.Context, field graphql.CollectedField, obj *model.Interface) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Interface_macAddress(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MacAddress, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.MAC)
	fc.Result = res
	return ec.marshalOMAC2backendgraphmodelMAC(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Interface_macAddress(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Interface",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type MAC does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Interface_mtu(ctx context.Context, field graphql.CollectedField, obj *model.Interface) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Interface_mtu(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Mtu, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Interface_mtu(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Interface",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Interface_comment(ctx context.Context, field graphql.CollectedField, obj *model.Interface) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Interface_comment(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Comment, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Interface_comment(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Interface",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Interface_txBytes(ctx context.Context, field graphql.CollectedField, obj *model.Interface) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Interface_txBytes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TxBytes, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Size)
	fc.Result = res
	return ec.marshalOSize2backendgraphmodelSize(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Interface_txBytes(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Interface",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Size does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Interface_rxBytes(ctx context.Context, field graphql.CollectedField, obj *model.Interface) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Interface_rxBytes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RxBytes, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Size)
	fc.Result = res
	return ec.marshalOSize2backendgraphmodelSize(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Interface_rxBytes(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Interface",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Size does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Interface_ip(ctx context.Context, field graphql.CollectedField, obj *model.Interface) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Interface_ip(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IP, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.IPv4)
	fc.Result = res
	return ec.marshalOIPv42backendgraphmodelIPv4(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Interface_ip(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Interface",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type IPv4 does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Interface_status(ctx context.Context, field graphql.CollectedField, obj *model.Interface) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Interface_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.InterfaceStatus)
	fc.Result = res
	return ec.marshalNInterfaceStatus2backendgraphmodelInterfaceStatus(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Interface_status(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Interface",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type InterfaceStatus does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Interface_txRate(ctx context.Context, field graphql.CollectedField, obj *model.Interface) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Interface_txRate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TxRate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Size)
	fc.Result = res
	return ec.marshalOSize2backendgraphmodelSize(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Interface_txRate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Interface",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Size does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Interface_rxRate(ctx context.Context, field graphql.CollectedField, obj *model.Interface) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Interface_rxRate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RxRate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Size)
	fc.Result = res
	return ec.marshalOSize2backendgraphmodelSize(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Interface_rxRate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Interface",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Size does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Interface_linkSpeed(ctx context.Context, field graphql.CollectedField, obj *model.Interface) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Interface_linkSpeed(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LinkSpeed, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Interface_linkSpeed(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Interface",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Interface_lastSeen(ctx context.Context, field graphql.CollectedField, obj *model.Interface) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Interface_lastSeen(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LastSeen, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalODateTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Interface_lastSeen(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Interface",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DateTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Interface_linkPartner(ctx context.Context, field graphql.CollectedField, obj *model.Interface) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Interface_linkPartner(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LinkPartner, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Interface_linkPartner(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Interface",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Interface_usedBy(ctx context.Context, field graphql.CollectedField, obj *model.Interface) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Interface_usedBy(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UsedBy, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Interface_usedBy(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Interface",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _InterfaceConnection_edges(ctx context.Context, field graphql.CollectedField, obj *model.InterfaceConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_InterfaceConnection_edges(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Edges, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.InterfaceEdge)
	fc.Result = res
	return ec.marshalNInterfaceEdge2backendgraphmodelInterfaceEdge(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_InterfaceConnection_edges(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "InterfaceConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "node":
				return ec.fieldContext_InterfaceEdge_node(ctx, field)
			case "cursor":
				return ec.fieldContext_InterfaceEdge_cursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type InterfaceEdge", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _InterfaceConnection_pageInfo(ctx context.Context, field graphql.CollectedField, obj *model.InterfaceConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_InterfaceConnection_pageInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.PageInfo)
	fc.Result = res
	return ec.marshalNPageInfo2backendgraphmodelPageInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_InterfaceConnection_pageInfo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "InterfaceConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			case "hasPreviousPage":
				return ec.fieldContext_PageInfo_hasPreviousPage(ctx, field)
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _InterfaceConnection_totalCount(ctx context.Context, field graphql.CollectedField, obj *model.InterfaceConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_InterfaceConnection_totalCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_InterfaceConnection_totalCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "InterfaceConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _InterfaceEdge_node(ctx context.Context, field graphql.CollectedField, obj *model.InterfaceEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_InterfaceEdge_node(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Node, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Interface)
	fc.Result = res
	return ec.marshalNInterface2backendgraphmodelInterface(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_InterfaceEdge_node(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "InterfaceEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Interface_id(ctx, field)
			case "name":
				return ec.fieldContext_Interface_name(ctx, field)
			case "type":
				return ec.fieldContext_Interface_type(ctx, field)
			case "enabled":
				return ec.fieldContext_Interface_enabled(ctx, field)
			case "running":
				return ec.fieldContext_Interface_running(ctx, field)
			case "macAddress":
				return ec.fieldContext_Interface_macAddress(ctx, field)
			case "mtu":
				return ec.fieldContext_Interface_mtu(ctx, field)
			case "comment":
				return ec.fieldContext_Interface_comment(ctx, field)
			case "txBytes":
				return ec.fieldContext_Interface_txBytes(ctx, field)
			case "rxBytes":
				return ec.fieldContext_Interface_rxBytes(ctx, field)
			case "ip":
				return ec.fieldContext_Interface_ip(ctx, field)
			case "status":
				return ec.fieldContext_Interface_status(ctx, field)
			case "txRate":
				return ec.fieldContext_Interface_txRate(ctx, field)
			case "rxRate":
				return ec.fieldContext_Interface_rxRate(ctx, field)
			case "linkSpeed":
				return ec.fieldContext_Interface_linkSpeed(ctx, field)
			case "lastSeen":
				return ec.fieldContext_Interface_lastSeen(ctx, field)
			case "linkPartner":
				return ec.fieldContext_Interface_linkPartner(ctx, field)
			case "usedBy":
				return ec.fieldContext_Interface_usedBy(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Interface", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _InterfaceEdge_cursor(ctx context.Context, field graphql.CollectedField, obj *model.InterfaceEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_InterfaceEdge_cursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_InterfaceEdge_cursor(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "InterfaceEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _InterfaceOperationError_interfaceId(ctx context.Context, field graphql.CollectedField, obj *model.InterfaceOperationError) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_InterfaceOperationError_interfaceId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.InterfaceID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_InterfaceOperationError_interfaceId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "InterfaceOperationError",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _InterfaceOperationError_interfaceName(ctx context.Context, field graphql.CollectedField, obj *model.InterfaceOperationError) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_InterfaceOperationError_interfaceName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.InterfaceName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_InterfaceOperationError_interfaceName(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "InterfaceOperationError",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _InterfaceOperationError_error(ctx context.Context, field graphql.CollectedField, obj *model.InterfaceOperationError) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_InterfaceOperationError_error(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Error, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_InterfaceOperationError_error(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "InterfaceOperationError",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _InterfaceStats_txBytes(ctx context.Context, field graphql.CollectedField, obj *model.InterfaceStats) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_InterfaceStats_txBytes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TxBytes, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.Size)
	fc.Result = res
	return ec.marshalNSize2backendgraphmodelSize(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_InterfaceStats_txBytes(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "InterfaceStats",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Size does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _InterfaceStats_rxBytes(ctx context.Context, field graphql.CollectedField, obj *model.InterfaceStats) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_InterfaceStats_rxBytes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RxBytes, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.Size)
	fc.Result = res
	return ec.marshalNSize2backendgraphmodelSize(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_InterfaceStats_rxBytes(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "InterfaceStats",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Size does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _InterfaceStats_txPackets(ctx context.Context, field graphql.CollectedField, obj *model.InterfaceStats) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_InterfaceStats_txPackets(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TxPackets, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.Size)
	fc.Result = res
	return ec.marshalNSize2backendgraphmodelSize(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_InterfaceStats_txPackets(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "InterfaceStats",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Size does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _InterfaceStats_rxPackets(ctx context.Context, field graphql.CollectedField, obj *model.InterfaceStats) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_InterfaceStats_rxPackets(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RxPackets, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.Size)
	fc.Result = res
	return ec.marshalNSize2backendgraphmodelSize(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_InterfaceStats_rxPackets(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "InterfaceStats",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Size does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _InterfaceStats_txErrors(ctx context.Context, field graphql.CollectedField, obj *model.InterfaceStats) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_InterfaceStats_txErrors(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TxErrors, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_InterfaceStats_txErrors(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "InterfaceStats",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _InterfaceStats_rxErrors(ctx context.Context, field graphql.CollectedField, obj *model.InterfaceStats) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_InterfaceStats_rxErrors(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RxErrors, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_InterfaceStats_rxErrors(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "InterfaceStats",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _InterfaceStats_txDrops(ctx context.Context, field graphql.CollectedField, obj *model.InterfaceStats) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_InterfaceStats_txDrops(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TxDrops, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_InterfaceStats_txDrops(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "InterfaceStats",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _InterfaceStats_rxDrops(ctx context.Context, field graphql.CollectedField, obj *model.InterfaceStats) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_InterfaceStats_rxDrops(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RxDrops, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_InterfaceStats_rxDrops(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "InterfaceStats",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _InterfaceStatsHistory_interfaceId(ctx context.Context, field graphql.CollectedField, obj *model.InterfaceStatsHistory) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_InterfaceStatsHistory_interfaceId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.InterfaceID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_InterfaceStatsHistory_interfaceId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "InterfaceStatsHistory",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _InterfaceStatsHistory_dataPoints(ctx context.Context, field graphql.CollectedField, obj *model.InterfaceStatsHistory) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_InterfaceStatsHistory_dataPoints(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DataPoints, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.StatsDataPoint)
	fc.Result = res
	return ec.marshalNStatsDataPoint2backendgraphmodelStatsDataPoint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_InterfaceStatsHistory_dataPoints(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "InterfaceStatsHistory",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "timestamp":
				return ec.fieldContext_StatsDataPoint_timestamp(ctx, field)
			case "txBytesPerSec":
				return ec.fieldContext_StatsDataPoint_txBytesPerSec(ctx, field)
			case "rxBytesPerSec":
				return ec.fieldContext_StatsDataPoint_rxBytesPerSec(ctx, field)
			case "txPacketsPerSec":
				return ec.fieldContext_StatsDataPoint_txPacketsPerSec(ctx, field)
			case "rxPacketsPerSec":
				return ec.fieldContext_StatsDataPoint_rxPacketsPerSec(ctx, field)
			case "txErrors":
				return ec.fieldContext_StatsDataPoint_txErrors(ctx, field)
			case "rxErrors":
				return ec.fieldContext_StatsDataPoint_rxErrors(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type StatsDataPoint", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _InterfaceStatsHistory_interval(ctx context.Context, field graphql.CollectedField, obj *model.InterfaceStatsHistory) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_InterfaceStatsHistory_interval(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Interval, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.Duration)
	fc.Result = res
	return ec.marshalNDuration2backendgraphmodelDuration(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_InterfaceStatsHistory_interval(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "InterfaceStatsHistory",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Duration does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _InterfaceStatsHistory_startTime(ctx context.Context, field graphql.CollectedField, obj *model.InterfaceStatsHistory) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_InterfaceStatsHistory_startTime(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StartTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNDateTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_InterfaceStatsHistory_startTime(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "InterfaceStatsHistory",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DateTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _InterfaceStatsHistory_endTime(ctx context.Context, field graphql.CollectedField, obj *model.InterfaceStatsHistory) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_InterfaceStatsHistory_endTime(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EndTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNDateTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_InterfaceStatsHistory_endTime(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "InterfaceStatsHistory",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DateTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _InterfaceStatusEvent_interfaceId(ctx context.Context, field graphql.CollectedField, obj *model.InterfaceStatusEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_InterfaceStatusEvent_interfaceId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.InterfaceID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_InterfaceStatusEvent_interfaceId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "InterfaceStatusEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _InterfaceStatusEvent_interfaceName(ctx context.Context, field graphql.CollectedField, obj *model.InterfaceStatusEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_InterfaceStatusEvent_interfaceName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.InterfaceName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_InterfaceStatusEvent_interfaceName(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "InterfaceStatusEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _InterfaceStatusEvent_status(ctx context.Context, field graphql.CollectedField, obj *model.InterfaceStatusEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_InterfaceStatusEvent_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.InterfaceStatus)
	fc.Result = res
	return ec.marshalNInterfaceStatus2backendgraphmodelInterfaceStatus(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_InterfaceStatusEvent_status(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "InterfaceStatusEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type InterfaceStatus does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _InterfaceStatusEvent_previousStatus(ctx context.Context, field graphql.CollectedField, obj *model.InterfaceStatusEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_InterfaceStatusEvent_previousStatus(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PreviousStatus, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.InterfaceStatus)
	fc.Result = res
	return ec.marshalNInterfaceStatus2backendgraphmodelInterfaceStatus(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_InterfaceStatusEvent_previousStatus(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "InterfaceStatusEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type InterfaceStatus does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _InterfaceStatusEvent_timestamp(ctx context.Context, field graphql.CollectedField, obj *model.InterfaceStatusEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_InterfaceStatusEvent_timestamp(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Timestamp, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNDateTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_InterfaceStatusEvent_timestamp(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "InterfaceStatusEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DateTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _InterfaceTrafficEvent_interfaceId(ctx context.Context, field graphql.CollectedField, obj *model.InterfaceTrafficEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_InterfaceTrafficEvent_interfaceId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.InterfaceID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_InterfaceTrafficEvent_interfaceId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "InterfaceTrafficEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _InterfaceTrafficEvent_interfaceName(ctx context.Context, field graphql.CollectedField, obj *model.InterfaceTrafficEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_InterfaceTrafficEvent_interfaceName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.InterfaceName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_InterfaceTrafficEvent_interfaceName(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "InterfaceTrafficEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _InterfaceTrafficEvent_txRate(ctx context.Context, field graphql.CollectedField, obj *model.InterfaceTrafficEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_InterfaceTrafficEvent_txRate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TxRate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.Size)
	fc.Result = res
	return ec.marshalNSize2backendgraphmodelSize(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_InterfaceTrafficEvent_txRate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "InterfaceTrafficEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Size does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _InterfaceTrafficEvent_rxRate(ctx context.Context, field graphql.CollectedField, obj *model.InterfaceTrafficEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_InterfaceTrafficEvent_rxRate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RxRate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.Size)
	fc.Result = res
	return ec.marshalNSize2backendgraphmodelSize(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_InterfaceTrafficEvent_rxRate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "InterfaceTrafficEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Size does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _InterfaceTrafficEvent_txTotal(ctx context.Context, field graphql.CollectedField, obj *model.InterfaceTrafficEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_InterfaceTrafficEvent_txTotal(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TxTotal, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.Size)
	fc.Result = res
	return ec.marshalNSize2backendgraphmodelSize(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_InterfaceTrafficEvent_txTotal(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "InterfaceTrafficEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Size does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _InterfaceTrafficEvent_rxTotal(ctx context.Context, field graphql.CollectedField, obj *model.InterfaceTrafficEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_InterfaceTrafficEvent_rxTotal(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RxTotal, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.Size)
	fc.Result = res
	return ec.marshalNSize2backendgraphmodelSize(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_InterfaceTrafficEvent_rxTotal(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "InterfaceTrafficEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Size does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _InterfaceTrafficEvent_timestamp(ctx context.Context, field graphql.CollectedField, obj *model.InterfaceTrafficEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_InterfaceTrafficEvent_timestamp(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Timestamp, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNDateTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_InterfaceTrafficEvent_timestamp(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "InterfaceTrafficEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DateTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _IpAddress_id(ctx context.Context, field graphql.CollectedField, obj *model.IPAddress) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_IpAddress_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_IpAddress_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "IpAddress",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _IpAddress_address(ctx context.Context, field graphql.CollectedField, obj *model.IPAddress) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_IpAddress_address(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Address, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			format, err := ec.unmarshalOValidateFormat2backendgraphmodelValidateFormat(ctx, "CIDR")
			if err != nil {
				return nil, err
			}
			if ec.directives.Validate == nil {
				return nil, errors.New("directive validate is not implemented")
			}
			return ec.directives.Validate(ctx, obj, directive0, nil, nil, nil, nil, nil, format)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_IpAddress_address(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "IpAddress",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _IpAddress_network(ctx context.Context, field graphql.CollectedField, obj *model.IPAddress) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_IpAddress_network(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Network, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_IpAddress_network(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "IpAddress",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _IpAddress_broadcast(ctx context.Context, field graphql.CollectedField, obj *model.IPAddress) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_IpAddress_broadcast(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Broadcast, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_IpAddress_broadcast(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "IpAddress",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _IpAddress_interface(ctx context.Context, field graphql.CollectedField, obj *model.IPAddress) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_IpAddress_interface(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Interface, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Interface)
	fc.Result = res
	return ec.marshalNInterface2backendgraphmodelInterface(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_IpAddress_interface(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "IpAddress",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Interface_id(ctx, field)
			case "name":
				return ec.fieldContext_Interface_name(ctx, field)
			case "type":
				return ec.fieldContext_Interface_type(ctx, field)
			case "enabled":
				return ec.fieldContext_Interface_enabled(ctx, field)
			case "running":
				return ec.fieldContext_Interface_running(ctx, field)
			case "macAddress":
				return ec.fieldContext_Interface_macAddress(ctx, field)
			case "mtu":
				return ec.fieldContext_Interface_mtu(ctx, field)
			case "comment":
				return ec.fieldContext_Interface_comment(ctx, field)
			case "txBytes":
				return ec.fieldContext_Interface_txBytes(ctx, field)
			case "rxBytes":
				return ec.fieldContext_Interface_rxBytes(ctx, field)
			case "ip":
				return ec.fieldContext_Interface_ip(ctx, field)
			case "status":
				return ec.fieldContext_Interface_status(ctx, field)
			case "txRate":
				return ec.fieldContext_Interface_txRate(ctx, field)
			case "rxRate":
				return ec.fieldContext_Interface_rxRate(ctx, field)
			case "linkSpeed":
				return ec.fieldContext_Interface_linkSpeed(ctx, field)
			case "lastSeen":
				return ec.fieldContext_Interface_lastSeen(ctx, field)
			case "linkPartner":
				return ec.fieldContext_Interface_linkPartner(ctx, field)
			case "usedBy":
				return ec.fieldContext_Interface_usedBy(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Interface", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _IpAddress_disabled(ctx context.Context, field graphql.CollectedField, obj *model.IPAddress) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_IpAddress_disabled(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Disabled, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_IpAddress_disabled(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "IpAddress",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _IpAddress_dynamic(ctx context.Context, field graphql.CollectedField, obj *model.IPAddress) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_IpAddress_dynamic(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Dynamic, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_IpAddress_dynamic(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "IpAddress",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _IpAddress_invalid(ctx context.Context, field graphql.CollectedField, obj *model.IPAddress) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_IpAddress_invalid(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Invalid, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_IpAddress_invalid(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "IpAddress",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _IpAddress_comment(ctx context.Context, field graphql.CollectedField, obj *model.IPAddress) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_IpAddress_comment(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Comment, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			maxLength, err := ec.unmarshalOInt2int(ctx, 255)
			if err != nil {
				return nil, err
			}
			if ec.directives.Validate == nil {
				return nil, errors.New("directive validate is not implemented")
			}
			return ec.directives.Validate(ctx, obj, directive0, nil, nil, nil, maxLength, nil, nil)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_IpAddress_comment(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "IpAddress",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _IpAddressChangeEvent_changeType(ctx context.Context, field graphql.CollectedField, obj *model.IPAddressChangeEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_IpAddressChangeEvent_changeType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ChangeType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.ChangeType)
	fc.Result = res
	return ec.marshalNChangeType2backendgraphmodelChangeType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_IpAddressChangeEvent_changeType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "IpAddressChangeEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ChangeType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _IpAddressChangeEvent_ipAddress(ctx context.Context, field graphql.CollectedField, obj *model.IPAddressChangeEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_IpAddressChangeEvent_ipAddress(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IPAddress, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.IPAddress)
	fc.Result = res
	return ec.marshalOIpAddress2backendgraphmodelIPAddress(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_IpAddressChangeEvent_ipAddress(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "IpAddressChangeEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_IpAddress_id(ctx, field)
			case "address":
				return ec.fieldContext_IpAddress_address(ctx, field)
			case "network":
				return ec.fieldContext_IpAddress_network(ctx, field)
			case "broadcast":
				return ec.fieldContext_IpAddress_broadcast(ctx, field)
			case "interface":
				return ec.fieldContext_IpAddress_interface(ctx, field)
			case "disabled":
				return ec.fieldContext_IpAddress_disabled(ctx, field)
			case "dynamic":
				return ec.fieldContext_IpAddress_dynamic(ctx, field)
			case "invalid":
				return ec.fieldContext_IpAddress_invalid(ctx, field)
			case "comment":
				return ec.fieldContext_IpAddress_comment(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type IpAddress", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _IpAddressChangeEvent_ipAddressId(ctx context.Context, field graphql.CollectedField, obj *model.IPAddressChangeEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_IpAddressChangeEvent_ipAddressId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IPAddressID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_IpAddressChangeEvent_ipAddressId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "IpAddressChangeEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _IpAddressChangeEvent_timestamp(ctx context.Context, field graphql.CollectedField, obj *model.IPAddressChangeEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_IpAddressChangeEvent_timestamp(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Timestamp, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNDateTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_IpAddressChangeEvent_timestamp(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "IpAddressChangeEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DateTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _IpAddressDeleteResult_success(ctx context.Context, field graphql.CollectedField, obj *model.IPAddressDeleteResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_IpAddressDeleteResult_success(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Success, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_IpAddressDeleteResult_success(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "IpAddressDeleteResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _IpAddressDeleteResult_message(ctx context.Context, field graphql.CollectedField, obj *model.IPAddressDeleteResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_IpAddressDeleteResult_message(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_IpAddressDeleteResult_message(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "IpAddressDeleteResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _IpAddressDeleteResult_impactAnalysis(ctx context.Context, field graphql.CollectedField, obj *model.IPAddressDeleteResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_IpAddressDeleteResult_impactAnalysis(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ImpactAnalysis, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.IPAddressImpactAnalysis)
	fc.Result = res
	return ec.marshalOIpAddressImpactAnalysis2backendgraphmodelIPAddressImpactAnalysis(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_IpAddressDeleteResult_impactAnalysis(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "IpAddressDeleteResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "usedByDhcpServers":
				return ec.fieldContext_IpAddressImpactAnalysis_usedByDhcpServers(ctx, field)
			case "usedInFirewallRules":
				return ec.fieldContext_IpAddressImpactAnalysis_usedInFirewallRules(ctx, field)
			case "usedInNatRules":
				return ec.fieldContext_IpAddressImpactAnalysis_usedInNatRules(ctx, field)
			case "activeConnections":
				return ec.fieldContext_IpAddressImpactAnalysis_activeConnections(ctx, field)
			case "severity":
				return ec.fieldContext_IpAddressImpactAnalysis_severity(ctx, field)
			case "message":
				return ec.fieldContext_IpAddressImpactAnalysis_message(ctx, field)
			case "consequences":
				return ec.fieldContext_IpAddressImpactAnalysis_consequences(ctx, field)
			case "canDelete":
				return ec.fieldContext_IpAddressImpactAnalysis_canDelete(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type IpAddressImpactAnalysis", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _IpAddressDeleteResult_errors(ctx context.Context, field graphql.CollectedField, obj *model.IPAddressDeleteResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_IpAddressDeleteResult_errors(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Errors, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.MutationError)
	fc.Result = res
	return ec.marshalOMutationError2backendgraphmodelMutationError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_IpAddressDeleteResult_errors(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "IpAddressDeleteResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "code":
				return ec.fieldContext_MutationError_code(ctx, field)
			case "message":
				return ec.fieldContext_MutationError_message(ctx, field)
			case "field":
				return ec.fieldContext_MutationError_field(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MutationError", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _IpAddressDependencies_ipAddressId(ctx context.Context, field graphql.CollectedField, obj *model.IPAddressDependencies) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_IpAddressDependencies_ipAddressId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IPAddressID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_IpAddressDependencies_ipAddressId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "IpAddressDependencies",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _IpAddressDependencies_dhcpServers(ctx context.Context, field graphql.CollectedField, obj *model.IPAddressDependencies) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_IpAddressDependencies_dhcpServers(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DhcpServers, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.DhcpServer)
	fc.Result = res
	return ec.marshalNDhcpServer2backendgraphmodelDhcpServer(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_IpAddressDependencies_dhcpServers(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "IpAddressDependencies",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_DhcpServer_id(ctx, field)
			case "name":
				return ec.fieldContext_DhcpServer_name(ctx, field)
			case "interface":
				return ec.fieldContext_DhcpServer_interface(ctx, field)
			case "disabled":
				return ec.fieldContext_DhcpServer_disabled(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DhcpServer", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _IpAddressDependencies_routes(ctx context.Context, field graphql.CollectedField, obj *model.IPAddressDependencies) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_IpAddressDependencies_routes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Routes, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.Route)
	fc.Result = res
	return ec.marshalNRoute2backendgraphmodelRoute(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_IpAddressDependencies_routes(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "IpAddressDependencies",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Route_id(ctx, field)
			case "destination":
				return ec.fieldContext_Route_destination(ctx, field)
			case "gateway":
				return ec.fieldContext_Route_gateway(ctx, field)
			case "interface":
				return ec.fieldContext_Route_interface(ctx, field)
			case "distance":
				return ec.fieldContext_Route_distance(ctx, field)
			case "routingMark":
				return ec.fieldContext_Route_routingMark(ctx, field)
			case "routingTable":
				return ec.fieldContext_Route_routingTable(ctx, field)
			case "type":
				return ec.fieldContext_Route_type(ctx, field)
			case "scope":
				return ec.fieldContext_Route_scope(ctx, field)
			case "comment":
				return ec.fieldContext_Route_comment(ctx, field)
			case "active":
				return ec.fieldContext_Route_active(ctx, field)
			case "disabled":
				return ec.fieldContext_Route_disabled(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Route", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _IpAddressDependencies_natRules(ctx context.Context, field graphql.CollectedField, obj *model.IPAddressDependencies) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_IpAddressDependencies_natRules(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NatRules, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.NatRule)
	fc.Result = res
	return ec.marshalNNatRule2backendgraphmodelNatRule(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_IpAddressDependencies_natRules(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "IpAddressDependencies",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_NatRule_id(ctx, field)
			case "chain":
				return ec.fieldContext_NatRule_chain(ctx, field)
			case "action":
				return ec.fieldContext_NatRule_action(ctx, field)
			case "srcAddress":
				return ec.fieldContext_NatRule_srcAddress(ctx, field)
			case "dstAddress":
				return ec.fieldContext_NatRule_dstAddress(ctx, field)
			case "toAddress":
				return ec.fieldContext_NatRule_toAddress(ctx, field)
			case "disabled":
				return ec.fieldContext_NatRule_disabled(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type NatRule", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _IpAddressDependencies_firewallRules(ctx context.Context, field graphql.CollectedField, obj *model.IPAddressDependencies) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_IpAddressDependencies_firewallRules(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FirewallRules, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.FirewallRule)
	fc.Result = res
	return ec.marshalNFirewallRule2backendgraphmodelFirewallRule(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_IpAddressDependencies_firewallRules(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "IpAddressDependencies",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_FirewallRule_id(ctx, field)
			case "chain":
				return ec.fieldContext_FirewallRule_chain(ctx, field)
			case "action":
				return ec.fieldContext_FirewallRule_action(ctx, field)
			case "inInterface":
				return ec.fieldContext_FirewallRule_inInterface(ctx, field)
			case "outInterface":
				return ec.fieldContext_FirewallRule_outInterface(ctx, field)
			case "disabled":
				return ec.fieldContext_FirewallRule_disabled(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FirewallRule", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _IpAddressDependencies_hasDependencies(ctx context.Context, field graphql.CollectedField, obj *model.IPAddressDependencies) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_IpAddressDependencies_hasDependencies(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HasDependencies, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_IpAddressDependencies_hasDependencies(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "IpAddressDependencies",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _IpAddressImpactAnalysis_usedByDhcpServers(ctx context.Context, field graphql.CollectedField, obj *model.IPAddressImpactAnalysis) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_IpAddressImpactAnalysis_usedByDhcpServers(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UsedByDhcpServers, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.DhcpServer)
	fc.Result = res
	return ec.marshalNDhcpServer2backendgraphmodelDhcpServer(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_IpAddressImpactAnalysis_usedByDhcpServers(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "IpAddressImpactAnalysis",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_DhcpServer_id(ctx, field)
			case "name":
				return ec.fieldContext_DhcpServer_name(ctx, field)
			case "interface":
				return ec.fieldContext_DhcpServer_interface(ctx, field)
			case "disabled":
				return ec.fieldContext_DhcpServer_disabled(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DhcpServer", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _IpAddressImpactAnalysis_usedInFirewallRules(ctx context.Context, field graphql.CollectedField, obj *model.IPAddressImpactAnalysis) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_IpAddressImpactAnalysis_usedInFirewallRules(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UsedInFirewallRules, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.FirewallRule)
	fc.Result = res
	return ec.marshalNFirewallRule2backendgraphmodelFirewallRule(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_IpAddressImpactAnalysis_usedInFirewallRules(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "IpAddressImpactAnalysis",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_FirewallRule_id(ctx, field)
			case "chain":
				return ec.fieldContext_FirewallRule_chain(ctx, field)
			case "action":
				return ec.fieldContext_FirewallRule_action(ctx, field)
			case "inInterface":
				return ec.fieldContext_FirewallRule_inInterface(ctx, field)
			case "outInterface":
				return ec.fieldContext_FirewallRule_outInterface(ctx, field)
			case "disabled":
				return ec.fieldContext_FirewallRule_disabled(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FirewallRule", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _IpAddressImpactAnalysis_usedInNatRules(ctx context.Context, field graphql.CollectedField, obj *model.IPAddressImpactAnalysis) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_IpAddressImpactAnalysis_usedInNatRules(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UsedInNatRules, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.NatRule)
	fc.Result = res
	return ec.marshalNNatRule2backendgraphmodelNatRule(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_IpAddressImpactAnalysis_usedInNatRules(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "IpAddressImpactAnalysis",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_NatRule_id(ctx, field)
			case "chain":
				return ec.fieldContext_NatRule_chain(ctx, field)
			case "action":
				return ec.fieldContext_NatRule_action(ctx, field)
			case "srcAddress":
				return ec.fieldContext_NatRule_srcAddress(ctx, field)
			case "dstAddress":
				return ec.fieldContext_NatRule_dstAddress(ctx, field)
			case "toAddress":
				return ec.fieldContext_NatRule_toAddress(ctx, field)
			case "disabled":
				return ec.fieldContext_NatRule_disabled(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type NatRule", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _IpAddressImpactAnalysis_activeConnections(ctx context.Context, field graphql.CollectedField, obj *model.IPAddressImpactAnalysis) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_IpAddressImpactAnalysis_activeConnections(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ActiveConnections, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_IpAddressImpactAnalysis_activeConnections(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "IpAddressImpactAnalysis",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _IpAddressImpactAnalysis_severity(ctx context.Context, field graphql.CollectedField, obj *model.IPAddressImpactAnalysis) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_IpAddressImpactAnalysis_severity(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Severity, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.ConfirmationSeverity)
	fc.Result = res
	return ec.marshalNConfirmationSeverity2backendgraphmodelConfirmationSeverity(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_IpAddressImpactAnalysis_severity(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "IpAddressImpactAnalysis",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ConfirmationSeverity does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _IpAddressImpactAnalysis_message(ctx context.Context, field graphql.CollectedField, obj *model.IPAddressImpactAnalysis) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_IpAddressImpactAnalysis_message(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_IpAddressImpactAnalysis_message(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "IpAddressImpactAnalysis",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _IpAddressImpactAnalysis_consequences(ctx context.Context, field graphql.CollectedField, obj *model.IPAddressImpactAnalysis) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_IpAddressImpactAnalysis_consequences(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Consequences, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_IpAddressImpactAnalysis_consequences(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "IpAddressImpactAnalysis",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _IpAddressImpactAnalysis_canDelete(ctx context.Context, field graphql.CollectedField, obj *model.IPAddressImpactAnalysis) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_IpAddressImpactAnalysis_canDelete(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CanDelete, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_IpAddressImpactAnalysis_canDelete(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "IpAddressImpactAnalysis",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _IpAddressMutationResult_success(ctx context.Context, field graphql.CollectedField, obj *model.IPAddressMutationResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_IpAddressMutationResult_success(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Success, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_IpAddressMutationResult_success(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "IpAddressMutationResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _IpAddressMutationResult_ipAddress(ctx context.Context, field graphql.CollectedField, obj *model.IPAddressMutationResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_IpAddressMutationResult_ipAddress(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IPAddress, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.IPAddress)
	fc.Result = res
	return ec.marshalOIpAddress2backendgraphmodelIPAddress(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_IpAddressMutationResult_ipAddress(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "IpAddressMutationResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_IpAddress_id(ctx, field)
			case "address":
				return ec.fieldContext_IpAddress_address(ctx, field)
			case "network":
				return ec.fieldContext_IpAddress_network(ctx, field)
			case "broadcast":
				return ec.fieldContext_IpAddress_broadcast(ctx, field)
			case "interface":
				return ec.fieldContext_IpAddress_interface(ctx, field)
			case "disabled":
				return ec.fieldContext_IpAddress_disabled(ctx, field)
			case "dynamic":
				return ec.fieldContext_IpAddress_dynamic(ctx, field)
			case "invalid":
				return ec.fieldContext_IpAddress_invalid(ctx, field)
			case "comment":
				return ec.fieldContext_IpAddress_comment(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type IpAddress", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _IpAddressMutationResult_preview(ctx context.Context, field graphql.CollectedField, obj *model.IPAddressMutationResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_IpAddressMutationResult_preview(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Preview, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.ConfigPreview)
	fc.Result = res
	return ec.marshalOConfigPreview2backendgraphmodelConfigPreview(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_IpAddressMutationResult_preview(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "IpAddressMutationResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "commands":
				return ec.fieldContext_ConfigPreview_commands(ctx, field)
			case "warnings":
				return ec.fieldContext_ConfigPreview_warnings(ctx, field)
			case "affectedResources":
				return ec.fieldContext_ConfigPreview_affectedResources(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ConfigPreview", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _IpAddressMutationResult_errors(ctx context.Context, field graphql.CollectedField, obj *model.IPAddressMutationResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_IpAddressMutationResult_errors(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Errors, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.MutationError)
	fc.Result = res
	return ec.marshalOMutationError2backendgraphmodelMutationError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_IpAddressMutationResult_errors(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "IpAddressMutationResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "code":
				return ec.fieldContext_MutationError_code(ctx, field)
			case "message":
				return ec.fieldContext_MutationError_message(ctx, field)
			case "field":
				return ec.fieldContext_MutationError_field(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MutationError", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _IpConflict_id(ctx context.Context, field graphql.CollectedField, obj *model.IPConflict) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_IpConflict_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_IpConflict_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "IpConflict",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _IpConflict_address(ctx context.Context, field graphql.CollectedField, obj *model.IPConflict) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_IpConflict_address(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Address, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_IpConflict_address(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "IpConflict",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _IpConflict_interface(ctx context.Context, field graphql.CollectedField, obj *model.IPConflict) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_IpConflict_interface(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Interface, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Interface)
	fc.Result = res
	return ec.marshalNInterface2backendgraphmodelInterface(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_IpConflict_interface(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "IpConflict",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Interface_id(ctx, field)
			case "name":
				return ec.fieldContext_Interface_name(ctx, field)
			case "type":
				return ec.fieldContext_Interface_type(ctx, field)
			case "enabled":
				return ec.fieldContext_Interface_enabled(ctx, field)
			case "running":
				return ec.fieldContext_Interface_running(ctx, field)
			case "macAddress":
				return ec.fieldContext_Interface_macAddress(ctx, field)
			case "mtu":
				return ec.fieldContext_Interface_mtu(ctx, field)
			case "comment":
				return ec.fieldContext_Interface_comment(ctx, field)
			case "txBytes":
				return ec.fieldContext_Interface_txBytes(ctx, field)
			case "rxBytes":
				return ec.fieldContext_Interface_rxBytes(ctx, field)
			case "ip":
				return ec.fieldContext_Interface_ip(ctx, field)
			case "status":
				return ec.fieldContext_Interface_status(ctx, field)
			case "txRate":
				return ec.fieldContext_Interface_txRate(ctx, field)
			case "rxRate":
				return ec.fieldContext_Interface_rxRate(ctx, field)
			case "linkSpeed":
				return ec.fieldContext_Interface_linkSpeed(ctx, field)
			case "lastSeen":
				return ec.fieldContext_Interface_lastSeen(ctx, field)
			case "linkPartner":
				return ec.fieldContext_Interface_linkPartner(ctx, field)
			case "usedBy":
				return ec.fieldContext_Interface_usedBy(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Interface", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _IpConflict_conflictType(ctx context.Context, field graphql.CollectedField, obj *model.IPConflict) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_IpConflict_conflictType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ConflictType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.IPConflictType)
	fc.Result = res
	return ec.marshalNIpConflictType2backendgraphmodelIPConflictType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_IpConflict_conflictType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "IpConflict",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type IpConflictType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _IpConflict_explanation(ctx context.Context, field graphql.CollectedField, obj *model.IPConflict) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_IpConflict_explanation(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Explanation, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_IpConflict_explanation(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "IpConflict",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _IpConflictResult_hasConflict(ctx context.Context, field graphql.CollectedField, obj *model.IPConflictResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_IpConflictResult_hasConflict(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HasConflict, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_IpConflictResult_hasConflict(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "IpConflictResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _IpConflictResult_conflicts(ctx context.Context, field graphql.CollectedField, obj *model.IPConflictResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_IpConflictResult_conflicts(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Conflicts, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.IPConflict)
	fc.Result = res
	return ec.marshalNIpConflict2backendgraphmodelIPConflict(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_IpConflictResult_conflicts(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "IpConflictResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_IpConflict_id(ctx, field)
			case "address":
				return ec.fieldContext_IpConflict_address(ctx, field)
			case "interface":
				return ec.fieldContext_IpConflict_interface(ctx, field)
			case "conflictType":
				return ec.fieldContext_IpConflict_conflictType(ctx, field)
			case "explanation":
				return ec.fieldContext_IpConflict_explanation(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type IpConflict", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _IpConflictResult_message(ctx context.Context, field graphql.CollectedField, obj *model.IPConflictResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_IpConflictResult_message(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_IpConflictResult_message(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "IpConflictResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LANNetwork_id(ctx context.Context, field graphql.CollectedField, obj *model.LANNetwork) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LANNetwork_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LANNetwork_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LANNetwork",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LANNetwork_scopedId(ctx context.Context, field graphql.CollectedField, obj *model.LANNetwork) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LANNetwork_scopedId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ScopedID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LANNetwork_scopedId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LANNetwork",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LANNetwork_type(ctx context.Context, field graphql.CollectedField, obj *model.LANNetwork) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LANNetwork_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LANNetwork_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LANNetwork",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LANNetwork_category(ctx context.Context, field graphql.CollectedField, obj *model.LANNetwork) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LANNetwork_category(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Category, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.ResourceCategory)
	fc.Result = res
	return ec.marshalNResourceCategory2backendgraphmodelResourceCategory(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LANNetwork_category(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LANNetwork",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ResourceCategory does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LANNetwork_configuration(ctx context.Context, field graphql.CollectedField, obj *model.LANNetwork) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LANNetwork_configuration(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Configuration, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOJSON2map(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LANNetwork_configuration(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LANNetwork",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type JSON does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LANNetwork_validation(ctx context.Context, field graphql.CollectedField, obj *model.LANNetwork) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LANNetwork_validation(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Validation, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.ValidationResult)
	fc.Result = res
	return ec.marshalOValidationResult2backendgraphmodelValidationResult(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LANNetwork_validation(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LANNetwork",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "canApply":
				return ec.fieldContext_ValidationResult_canApply(ctx, field)
			case "stage":
				return ec.fieldContext_ValidationResult_stage(ctx, field)
			case "errors":
				return ec.fieldContext_ValidationResult_errors(ctx, field)
			case "warnings":
				return ec.fieldContext_ValidationResult_warnings(ctx, field)
			case "conflicts":
				return ec.fieldContext_ValidationResult_conflicts(ctx, field)
			case "requiredDependencies":
				return ec.fieldContext_ValidationResult_requiredDependencies(ctx, field)
			case "validatedAt":
				return ec.fieldContext_ValidationResult_validatedAt(ctx, field)
			case "validationDurationMs":
				return ec.fieldContext_ValidationResult_validationDurationMs(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ValidationResult", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _LANNetwork_deployment(ctx context.Context, field graphql.CollectedField, obj *model.LANNetwork) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LANNetwork_deployment(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Deployment, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.DeploymentState)
	fc.Result = res
	return ec.marshalODeploymentState2backendgraphmodelDeploymentState(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LANNetwork_deployment(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LANNetwork",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "routerResourceId":
				return ec.fieldContext_DeploymentState_routerResourceId(ctx, field)
			case "appliedAt":
				return ec.fieldContext_DeploymentState_appliedAt(ctx, field)
			case "appliedBy":
				return ec.fieldContext_DeploymentState_appliedBy(ctx, field)
			case "routerVersion":
				return ec.fieldContext_DeploymentState_routerVersion(ctx, field)
			case "generatedFields":
				return ec.fieldContext_DeploymentState_generatedFields(ctx, field)
			case "isInSync":
				return ec.fieldContext_DeploymentState_isInSync(ctx, field)
			case "drift":
				return ec.fieldContext_DeploymentState_drift(ctx, field)
			case "applyOperationId":
				return ec.fieldContext_DeploymentState_applyOperationId(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DeploymentState", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _LANNetwork_runtime(ctx context.Context, field graphql.CollectedField, obj *model.LANNetwork) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LANNetwork_runtime(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Runtime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.RuntimeState)
	fc.Result = res
	return ec.marshalORuntimeState2backendgraphmodelRuntimeState(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LANNetwork_runtime(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LANNetwork",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "isRunning":
				return ec.fieldContext_RuntimeState_isRunning(ctx, field)
			case "health":
				return ec.fieldContext_RuntimeState_health(ctx, field)
			case "errorMessage":
				return ec.fieldContext_RuntimeState_errorMessage(ctx, field)
			case "metrics":
				return ec.fieldContext_RuntimeState_metrics(ctx, field)
			case "lastUpdated":
				return ec.fieldContext_RuntimeState_lastUpdated(ctx, field)
			case "lastSuccessfulOperation":
				return ec.fieldContext_RuntimeState_lastSuccessfulOperation(ctx, field)
			case "activeConnections":
				return ec.fieldContext_RuntimeState_activeConnections(ctx, field)
			case "uptime":
				return ec.fieldContext_RuntimeState_uptime(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RuntimeState", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _LANNetwork_telemetry(ctx context.Context, field graphql.CollectedField, obj *model.LANNetwork) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LANNetwork_telemetry(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Telemetry, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.TelemetryData)
	fc.Result = res
	return ec.marshalOTelemetryData2backendgraphmodelTelemetryData(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LANNetwork_telemetry(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LANNetwork",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "bandwidthHistory":
				return ec.fieldContext_TelemetryData_bandwidthHistory(ctx, field)
			case "uptimeHistory":
				return ec.fieldContext_TelemetryData_uptimeHistory(ctx, field)
			case "hourlyStats":
				return ec.fieldContext_TelemetryData_hourlyStats(ctx, field)
			case "dailyStats":
				return ec.fieldContext_TelemetryData_dailyStats(ctx, field)
			case "dataStartedAt":
				return ec.fieldContext_TelemetryData_dataStartedAt(ctx, field)
			case "lastUpdatedAt":
				return ec.fieldContext_TelemetryData_lastUpdatedAt(ctx, field)
			case "retentionDays":
				return ec.fieldContext_TelemetryData_retentionDays(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TelemetryData", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _LANNetwork_metadata(ctx context.Context, field graphql.CollectedField, obj *model.LANNetwork) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LANNetwork_metadata(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Metadata, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.ResourceMetadata)
	fc.Result = res
	return ec.marshalNResourceMetadata2backendgraphmodelResourceMetadata(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LANNetwork_metadata(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LANNetwork",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "createdAt":
				return ec.fieldContext_ResourceMetadata_createdAt(ctx, field)
			case "createdBy":
				return ec.fieldContext_ResourceMetadata_createdBy(ctx, field)
			case "updatedAt":
				return ec.fieldContext_ResourceMetadata_updatedAt(ctx, field)
			case "updatedBy":
				return ec.fieldContext_ResourceMetadata_updatedBy(ctx, field)
			case "state":
				return ec.fieldContext_ResourceMetadata_state(ctx, field)
			case "version":
				return ec.fieldContext_ResourceMetadata_version(ctx, field)
			case "tags":
				return ec.fieldContext_ResourceMetadata_tags(ctx, field)
			case "description":
				return ec.fieldContext_ResourceMetadata_description(ctx, field)
			case "isFavorite":
				return ec.fieldContext_ResourceMetadata_isFavorite(ctx, field)
			case "isPinned":
				return ec.fieldContext_ResourceMetadata_isPinned(ctx, field)
			case "notes":
				return ec.fieldContext_ResourceMetadata_notes(ctx, field)
			case "recentChanges":
				return ec.fieldContext_ResourceMetadata_recentChanges(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ResourceMetadata", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _LANNetwork_relationships(ctx context.Context, field graphql.CollectedField, obj *model.LANNetwork) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LANNetwork_relationships(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Relationships, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.ResourceRelationships)
	fc.Result = res
	return ec.marshalOResourceRelationships2backendgraphmodelResourceRelationships(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LANNetwork_relationships(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LANNetwork",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "dependsOn":
				return ec.fieldContext_ResourceRelationships_dependsOn(ctx, field)
			case "dependents":
				return ec.fieldContext_ResourceRelationships_dependents(ctx, field)
			case "routesVia":
				return ec.fieldContext_ResourceRelationships_routesVia(ctx, field)
			case "routedBy":
				return ec.fieldContext_ResourceRelationships_routedBy(ctx, field)
			case "parent":
				return ec.fieldContext_ResourceRelationships_parent(ctx, field)
			case "children":
				return ec.fieldContext_ResourceRelationships_children(ctx, field)
			case "custom":
				return ec.fieldContext_ResourceRelationships_custom(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ResourceRelationships", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _LANNetwork_platform(ctx context.Context, field graphql.CollectedField, obj *model.LANNetwork) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LANNetwork_platform(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Platform, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.PlatformInfo)
	fc.Result = res
	return ec.marshalOPlatformInfo2backendgraphmodelPlatformInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LANNetwork_platform(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LANNetwork",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "current":
				return ec.fieldContext_PlatformInfo_current(ctx, field)
			case "capabilities":
				return ec.fieldContext_PlatformInfo_capabilities(ctx, field)
			case "fieldMappings":
				return ec.fieldContext_PlatformInfo_fieldMappings(ctx, field)
			case "limitations":
				return ec.fieldContext_PlatformInfo_limitations(ctx, field)
			case "features":
				return ec.fieldContext_PlatformInfo_features(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PlatformInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _LANNetwork_config(ctx context.Context, field graphql.CollectedField, obj *model.LANNetwork) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LANNetwork_config(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Config, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.LANNetworkConfig)
	fc.Result = res
	return ec.marshalNLANNetworkConfig2backendgraphmodelLANNetworkConfig(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LANNetwork_config(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LANNetwork",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_LANNetworkConfig_name(ctx, field)
			case "ipAddress":
				return ec.fieldContext_LANNetworkConfig_ipAddress(ctx, field)
			case "subnetMask":
				return ec.fieldContext_LANNetworkConfig_subnetMask(ctx, field)
			case "interfaces":
				return ec.fieldContext_LANNetworkConfig_interfaces(ctx, field)
			case "dhcpEnabled":
				return ec.fieldContext_LANNetworkConfig_dhcpEnabled(ctx, field)
			case "dhcpPoolStart":
				return ec.fieldContext_LANNetworkConfig_dhcpPoolStart(ctx, field)
			case "dhcpPoolEnd":
				return ec.fieldContext_LANNetworkConfig_dhcpPoolEnd(ctx, field)
			case "dhcpLeaseTime":
				return ec.fieldContext_LANNetworkConfig_dhcpLeaseTime(ctx, field)
			case "dnsServers":
				return ec.fieldContext_LANNetworkConfig_dnsServers(ctx, field)
			case "enableNat":
				return ec.fieldContext_LANNetworkConfig_enableNat(ctx, field)
			case "vlanId":
				return ec.fieldContext_LANNetworkConfig_vlanId(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type LANNetworkConfig", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _LANNetwork_lanDeployment(ctx context.Context, field graphql.CollectedField, obj *model.LANNetwork) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LANNetwork_lanDeployment(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LanDeployment, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.LANNetworkDeployment)
	fc.Result = res
	return ec.marshalOLANNetworkDeployment2backendgraphmodelLANNetworkDeployment(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LANNetwork_lanDeployment(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LANNetwork",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "routerResourceId":
				return ec.fieldContext_LANNetworkDeployment_routerResourceId(ctx, field)
			case "appliedAt":
				return ec.fieldContext_LANNetworkDeployment_appliedAt(ctx, field)
			case "appliedBy":
				return ec.fieldContext_LANNetworkDeployment_appliedBy(ctx, field)
			case "routerVersion":
				return ec.fieldContext_LANNetworkDeployment_routerVersion(ctx, field)
			case "isInSync":
				return ec.fieldContext_LANNetworkDeployment_isInSync(ctx, field)
			case "drift":
				return ec.fieldContext_LANNetworkDeployment_drift(ctx, field)
			case "bridgeId":
				return ec.fieldContext_LANNetworkDeployment_bridgeId(ctx, field)
			case "dhcpServerId":
				return ec.fieldContext_LANNetworkDeployment_dhcpServerId(ctx, field)
			case "ipAddressId":
				return ec.fieldContext_LANNetworkDeployment_ipAddressId(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type LANNetworkDeployment", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _LANNetwork_lanRuntime(ctx context.Context, field graphql.CollectedField, obj *model.LANNetwork) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LANNetwork_lanRuntime(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LanRuntime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.LANNetworkRuntime)
	fc.Result = res
	return ec.marshalOLANNetworkRuntime2backendgraphmodelLANNetworkRuntime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LANNetwork_lanRuntime(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LANNetwork",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "isRunning":
				return ec.fieldContext_LANNetworkRuntime_isRunning(ctx, field)
			case "health":
				return ec.fieldContext_LANNetworkRuntime_health(ctx, field)
			case "errorMessage":
				return ec.fieldContext_LANNetworkRuntime_errorMessage(ctx, field)
			case "lastUpdated":
				return ec.fieldContext_LANNetworkRuntime_lastUpdated(ctx, field)
			case "activeClients":
				return ec.fieldContext_LANNetworkRuntime_activeClients(ctx, field)
			case "dhcpLeases":
				return ec.fieldContext_LANNetworkRuntime_dhcpLeases(ctx, field)
			case "totalBytesIn":
				return ec.fieldContext_LANNetworkRuntime_totalBytesIn(ctx, field)
			case "totalBytesOut":
				return ec.fieldContext_LANNetworkRuntime_totalBytesOut(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type LANNetworkRuntime", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _LANNetwork_bridge(ctx context.Context, field graphql.CollectedField, obj *model.LANNetwork) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LANNetwork_bridge(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Bridge, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.BridgeResource)
	fc.Result = res
	return ec.marshalOBridgeResource2backendgraphmodelBridgeResource(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LANNetwork_bridge(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LANNetwork",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_BridgeResource_id(ctx, field)
			case "scopedId":
				return ec.fieldContext_BridgeResource_scopedId(ctx, field)
			case "type":
				return ec.fieldContext_BridgeResource_type(ctx, field)
			case "category":
				return ec.fieldContext_BridgeResource_category(ctx, field)
			case "configuration":
				return ec.fieldContext_BridgeResource_configuration(ctx, field)
			case "validation":
				return ec.fieldContext_BridgeResource_validation(ctx, field)
			case "deployment":
				return ec.fieldContext_BridgeResource_deployment(ctx, field)
			case "runtime":
				return ec.fieldContext_BridgeResource_runtime(ctx, field)
			case "telemetry":
				return ec.fieldContext_BridgeResource_telemetry(ctx, field)
			case "metadata":
				return ec.fieldContext_BridgeResource_metadata(ctx, field)
			case "relationships":
				return ec.fieldContext_BridgeResource_relationships(ctx, field)
			case "platform":
				return ec.fieldContext_BridgeResource_platform(ctx, field)
			case "name":
				return ec.fieldContext_BridgeResource_name(ctx, field)
			case "ports":
				return ec.fieldContext_BridgeResource_ports(ctx, field)
			case "protocolMode":
				return ec.fieldContext_BridgeResource_protocolMode(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type BridgeResource", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _LANNetwork_dhcpServer(ctx context.Context, field graphql.CollectedField, obj *model.LANNetwork) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LANNetwork_dhcpServer(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DhcpServer, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.DHCPServerResource)
	fc.Result = res
	return ec.marshalODHCPServerResource2backendgraphmodelDHCPServerResource(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LANNetwork_dhcpServer(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LANNetwork",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_DHCPServerResource_id(ctx, field)
			case "scopedId":
				return ec.fieldContext_DHCPServerResource_scopedId(ctx, field)
			case "type":
				return ec.fieldContext_DHCPServerResource_type(ctx, field)
			case "category":
				return ec.fieldContext_DHCPServerResource_category(ctx, field)
			case "configuration":
				return ec.fieldContext_DHCPServerResource_configuration(ctx, field)
			case "validation":
				return ec.fieldContext_DHCPServerResource_validation(ctx, field)
			case "deployment":
				return ec.fieldContext_DHCPServerResource_deployment(ctx, field)
			case "runtime":
				return ec.fieldContext_DHCPServerResource_runtime(ctx, field)
			case "telemetry":
				return ec.fieldContext_DHCPServerResource_telemetry(ctx, field)
			case "metadata":
				return ec.fieldContext_DHCPServerResource_metadata(ctx, field)
			case "relationships":
				return ec.fieldContext_DHCPServerResource_relationships(ctx, field)
			case "platform":
				return ec.fieldContext_DHCPServerResource_platform(ctx, field)
			case "name":
				return ec.fieldContext_DHCPServerResource_name(ctx, field)
			case "interface":
				return ec.fieldContext_DHCPServerResource_interface(ctx, field)
			case "addressPool":
				return ec.fieldContext_DHCPServerResource_addressPool(ctx, field)
			case "leaseTime":
				return ec.fieldContext_DHCPServerResource_leaseTime(ctx, field)
			case "activeLeases":
				return ec.fieldContext_DHCPServerResource_activeLeases(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DHCPServerResource", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _LANNetwork_firewallRules(ctx context.Context, field graphql.CollectedField, obj *model.LANNetwork) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LANNetwork_firewallRules(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FirewallRules, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.FirewallRuleResource)
	fc.Result = res
	return ec.marshalNFirewallRuleResource2backendgraphmodelFirewallRuleResource(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LANNetwork_firewallRules(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LANNetwork",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_FirewallRuleResource_id(ctx, field)
			case "scopedId":
				return ec.fieldContext_FirewallRuleResource_scopedId(ctx, field)
			case "type":
				return ec.fieldContext_FirewallRuleResource_type(ctx, field)
			case "category":
				return ec.fieldContext_FirewallRuleResource_category(ctx, field)
			case "configuration":
				return ec.fieldContext_FirewallRuleResource_configuration(ctx, field)
			case "validation":
				return ec.fieldContext_FirewallRuleResource_validation(ctx, field)
			case "deployment":
				return ec.fieldContext_FirewallRuleResource_deployment(ctx, field)
			case "runtime":
				return ec.fieldContext_FirewallRuleResource_runtime(ctx, field)
			case "telemetry":
				return ec.fieldContext_FirewallRuleResource_telemetry(ctx, field)
			case "metadata":
				return ec.fieldContext_FirewallRuleResource_metadata(ctx, field)
			case "relationships":
				return ec.fieldContext_FirewallRuleResource_relationships(ctx, field)
			case "platform":
				return ec.fieldContext_FirewallRuleResource_platform(ctx, field)
			case "chain":
				return ec.fieldContext_FirewallRuleResource_chain(ctx, field)
			case "action":
				return ec.fieldContext_FirewallRuleResource_action(ctx, field)
			case "srcAddress":
				return ec.fieldContext_FirewallRuleResource_srcAddress(ctx, field)
			case "dstAddress":
				return ec.fieldContext_FirewallRuleResource_dstAddress(ctx, field)
			case "srcPort":
				return ec.fieldContext_FirewallRuleResource_srcPort(ctx, field)
			case "dstPort":
				return ec.fieldContext_FirewallRuleResource_dstPort(ctx, field)
			case "protocol":
				return ec.fieldContext_FirewallRuleResource_protocol(ctx, field)
			case "comment":
				return ec.fieldContext_FirewallRuleResource_comment(ctx, field)
			case "enabled":
				return ec.fieldContext_FirewallRuleResource_enabled(ctx, field)
			case "hitCount":
				return ec.fieldContext_FirewallRuleResource_hitCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FirewallRuleResource", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _LANNetwork_routes(ctx context.Context, field graphql.CollectedField, obj *model.LANNetwork) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LANNetwork_routes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Routes, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.RouteResource)
	fc.Result = res
	return ec.marshalNRouteResource2backendgraphmodelRouteResource(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LANNetwork_routes(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LANNetwork",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_RouteResource_id(ctx, field)
			case "scopedId":
				return ec.fieldContext_RouteResource_scopedId(ctx, field)
			case "type":
				return ec.fieldContext_RouteResource_type(ctx, field)
			case "category":
				return ec.fieldContext_RouteResource_category(ctx, field)
			case "configuration":
				return ec.fieldContext_RouteResource_configuration(ctx, field)
			case "validation":
				return ec.fieldContext_RouteResource_validation(ctx, field)
			case "deployment":
				return ec.fieldContext_RouteResource_deployment(ctx, field)
			case "runtime":
				return ec.fieldContext_RouteResource_runtime(ctx, field)
			case "telemetry":
				return ec.fieldContext_RouteResource_telemetry(ctx, field)
			case "metadata":
				return ec.fieldContext_RouteResource_metadata(ctx, field)
			case "relationships":
				return ec.fieldContext_RouteResource_relationships(ctx, field)
			case "platform":
				return ec.fieldContext_RouteResource_platform(ctx, field)
			case "dstAddress":
				return ec.fieldContext_RouteResource_dstAddress(ctx, field)
			case "gateway":
				return ec.fieldContext_RouteResource_gateway(ctx, field)
			case "interface":
				return ec.fieldContext_RouteResource_interface(ctx, field)
			case "distance":
				return ec.fieldContext_RouteResource_distance(ctx, field)
			case "active":
				return ec.fieldContext_RouteResource_active(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RouteResource", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _LANNetworkConfig_name(ctx context.Context, field graphql.CollectedField, obj *model.LANNetworkConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LANNetworkConfig_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LANNetworkConfig_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LANNetworkConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LANNetworkConfig_ipAddress(ctx context.Context, field graphql.CollectedField, obj *model.LANNetworkConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LANNetworkConfig_ipAddress(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IPAddress, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.IPv4)
	fc.Result = res
	return ec.marshalNIPv42backendgraphmodelIPv4(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LANNetworkConfig_ipAddress(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LANNetworkConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type IPv4 does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LANNetworkConfig_subnetMask(ctx context.Context, field graphql.CollectedField, obj *model.LANNetworkConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LANNetworkConfig_subnetMask(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.SubnetMask, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			min, err := ec.unmarshalOInt2int(ctx, 1)
			if err != nil {
				return nil, err
			}
			max, err := ec.unmarshalOInt2int(ctx, 32)
			if err != nil {
				return nil, err
			}
			if ec.directives.Validate == nil {
				return nil, errors.New("directive validate is not implemented")
			}
			return ec.directives.Validate(ctx, obj, directive0, min, max, nil, nil, nil, nil)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(int); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be int`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LANNetworkConfig_subnetMask(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LANNetworkConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LANNetworkConfig_interfaces(ctx context.Context, field graphql.CollectedField, obj *model.LANNetworkConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LANNetworkConfig_interfaces(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Interfaces, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LANNetworkConfig_interfaces(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LANNetworkConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LANNetworkConfig_dhcpEnabled(ctx context.Context, field graphql.CollectedField, obj *model.LANNetworkConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LANNetworkConfig_dhcpEnabled(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DhcpEnabled, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LANNetworkConfig_dhcpEnabled(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LANNetworkConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LANNetworkConfig_dhcpPoolStart(ctx context.Context, field graphql.CollectedField, obj *model.LANNetworkConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LANNetworkConfig_dhcpPoolStart(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DhcpPoolStart, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.IPv4)
	fc.Result = res
	return ec.marshalOIPv42backendgraphmodelIPv4(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LANNetworkConfig_dhcpPoolStart(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LANNetworkConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type IPv4 does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LANNetworkConfig_dhcpPoolEnd(ctx context.Context, field graphql.CollectedField, obj *model.LANNetworkConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LANNetworkConfig_dhcpPoolEnd(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DhcpPoolEnd, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.IPv4)
	fc.Result = res
	return ec.marshalOIPv42backendgraphmodelIPv4(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LANNetworkConfig_dhcpPoolEnd(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LANNetworkConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type IPv4 does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LANNetworkConfig_dhcpLeaseTime(ctx context.Context, field graphql.CollectedField, obj *model.LANNetworkConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LANNetworkConfig_dhcpLeaseTime(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DhcpLeaseTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Duration)
	fc.Result = res
	return ec.marshalODuration2backendgraphmodelDuration(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LANNetworkConfig_dhcpLeaseTime(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LANNetworkConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Duration does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LANNetworkConfig_dnsServers(ctx context.Context, field graphql.CollectedField, obj *model.LANNetworkConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LANNetworkConfig_dnsServers(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DNSServers, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]model.IPv4)
	fc.Result = res
	return ec.marshalOIPv42backendgraphmodelIPv4(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LANNetworkConfig_dnsServers(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LANNetworkConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type IPv4 does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LANNetworkConfig_enableNat(ctx context.Context, field graphql.CollectedField, obj *model.LANNetworkConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LANNetworkConfig_enableNat(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EnableNat, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LANNetworkConfig_enableNat(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LANNetworkConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LANNetworkConfig_vlanId(ctx context.Context, field graphql.CollectedField, obj *model.LANNetworkConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LANNetworkConfig_vlanId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.VlanID, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			min, err := ec.unmarshalOInt2int(ctx, 1)
			if err != nil {
				return nil, err
			}
			max, err := ec.unmarshalOInt2int(ctx, 4094)
			if err != nil {
				return nil, err
			}
			if ec.directives.Validate == nil {
				return nil, errors.New("directive validate is not implemented")
			}
			return ec.directives.Validate(ctx, obj, directive0, min, max, nil, nil, nil, nil)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*int); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *int`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LANNetworkConfig_vlanId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LANNetworkConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LANNetworkDeployment_routerResourceId(ctx context.Context, field graphql.CollectedField, obj *model.LANNetworkDeployment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LANNetworkDeployment_routerResourceId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RouterResourceID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LANNetworkDeployment_routerResourceId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LANNetworkDeployment",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LANNetworkDeployment_appliedAt(ctx context.Context, field graphql.CollectedField, obj *model.LANNetworkDeployment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LANNetworkDeployment_appliedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AppliedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNDateTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LANNetworkDeployment_appliedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LANNetworkDeployment",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DateTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LANNetworkDeployment_appliedBy(ctx context.Context, field graphql.CollectedField, obj *model.LANNetworkDeployment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LANNetworkDeployment_appliedBy(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AppliedBy, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LANNetworkDeployment_appliedBy(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LANNetworkDeployment",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LANNetworkDeployment_routerVersion(ctx context.Context, field graphql.CollectedField, obj *model.LANNetworkDeployment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LANNetworkDeployment_routerVersion(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RouterVersion, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LANNetworkDeployment_routerVersion(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LANNetworkDeployment",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LANNetworkDeployment_isInSync(ctx context.Context, field graphql.CollectedField, obj *model.LANNetworkDeployment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LANNetworkDeployment_isInSync(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsInSync, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LANNetworkDeployment_isInSync(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LANNetworkDeployment",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LANNetworkDeployment_drift(ctx context.Context, field graphql.CollectedField, obj *model.LANNetworkDeployment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LANNetworkDeployment_drift(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Drift, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.DriftInfo)
	fc.Result = res
	return ec.marshalODriftInfo2backendgraphmodelDriftInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LANNetworkDeployment_drift(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LANNetworkDeployment",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "detectedAt":
				return ec.fieldContext_DriftInfo_detectedAt(ctx, field)
			case "driftedFields":
				return ec.fieldContext_DriftInfo_driftedFields(ctx, field)
			case "suggestedAction":
				return ec.fieldContext_DriftInfo_suggestedAction(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DriftInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _LANNetworkDeployment_bridgeId(ctx context.Context, field graphql.CollectedField, obj *model.LANNetworkDeployment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LANNetworkDeployment_bridgeId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BridgeID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LANNetworkDeployment_bridgeId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LANNetworkDeployment",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LANNetworkDeployment_dhcpServerId(ctx context.Context, field graphql.CollectedField, obj *model.LANNetworkDeployment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LANNetworkDeployment_dhcpServerId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DhcpServerID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LANNetworkDeployment_dhcpServerId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LANNetworkDeployment",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LANNetworkDeployment_ipAddressId(ctx context.Context, field graphql.CollectedField, obj *model.LANNetworkDeployment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LANNetworkDeployment_ipAddressId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IPAddressID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LANNetworkDeployment_ipAddressId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LANNetworkDeployment",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LANNetworkRuntime_isRunning(ctx context.Context, field graphql.CollectedField, obj *model.LANNetworkRuntime) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LANNetworkRuntime_isRunning(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsRunning, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LANNetworkRuntime_isRunning(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LANNetworkRuntime",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LANNetworkRuntime_health(ctx context.Context, field graphql.CollectedField, obj *model.LANNetworkRuntime) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LANNetworkRuntime_health(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Health, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.RuntimeHealth)
	fc.Result = res
	return ec.marshalNRuntimeHealth2backendgraphmodelRuntimeHealth(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LANNetworkRuntime_health(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LANNetworkRuntime",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type RuntimeHealth does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LANNetworkRuntime_errorMessage(ctx context.Context, field graphql.CollectedField, obj *model.LANNetworkRuntime) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LANNetworkRuntime_errorMessage(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ErrorMessage, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LANNetworkRuntime_errorMessage(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LANNetworkRuntime",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LANNetworkRuntime_lastUpdated(ctx context.Context, field graphql.CollectedField, obj *model.LANNetworkRuntime) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LANNetworkRuntime_lastUpdated(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LastUpdated, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNDateTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LANNetworkRuntime_lastUpdated(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LANNetworkRuntime",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DateTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LANNetworkRuntime_activeClients(ctx context.Context, field graphql.CollectedField, obj *model.LANNetworkRuntime) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LANNetworkRuntime_activeClients(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ActiveClients, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LANNetworkRuntime_activeClients(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LANNetworkRuntime",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LANNetworkRuntime_dhcpLeases(ctx context.Context, field graphql.CollectedField, obj *model.LANNetworkRuntime) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LANNetworkRuntime_dhcpLeases(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DhcpLeases, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LANNetworkRuntime_dhcpLeases(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LANNetworkRuntime",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LANNetworkRuntime_totalBytesIn(ctx context.Context, field graphql.CollectedField, obj *model.LANNetworkRuntime) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LANNetworkRuntime_totalBytesIn(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalBytesIn, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.Size)
	fc.Result = res
	return ec.marshalNSize2backendgraphmodelSize(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LANNetworkRuntime_totalBytesIn(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LANNetworkRuntime",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Size does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LANNetworkRuntime_totalBytesOut(ctx context.Context, field graphql.CollectedField, obj *model.LANNetworkRuntime) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LANNetworkRuntime_totalBytesOut(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalBytesOut, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.Size)
	fc.Result = res
	return ec.marshalNSize2backendgraphmodelSize(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LANNetworkRuntime_totalBytesOut(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LANNetworkRuntime",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Size does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LteModem_id(ctx context.Context, field graphql.CollectedField, obj *model.LteModem) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LteModem_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LteModem_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LteModem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LteModem_name(ctx context.Context, field graphql.CollectedField, obj *model.LteModem) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LteModem_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LteModem_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LteModem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LteModem_apn(ctx context.Context, field graphql.CollectedField, obj *model.LteModem) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LteModem_apn(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Apn, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LteModem_apn(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LteModem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LteModem_signalStrength(ctx context.Context, field graphql.CollectedField, obj *model.LteModem) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LteModem_signalStrength(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SignalStrength, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LteModem_signalStrength(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LteModem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LteModem_running(ctx context.Context, field graphql.CollectedField, obj *model.LteModem) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LteModem_running(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Running, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LteModem_running(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LteModem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LteModem_operator(ctx context.Context, field graphql.CollectedField, obj *model.LteModem) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LteModem_operator(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Operator, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LteModem_operator(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LteModem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LteModem_networkType(ctx context.Context, field graphql.CollectedField, obj *model.LteModem) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LteModem_networkType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NetworkType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LteModem_networkType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LteModem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LteModem_pinConfigured(ctx context.Context, field graphql.CollectedField, obj *model.LteModem) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LteModem_pinConfigured(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PinConfigured, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LteModem_pinConfigured(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LteModem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LteModem_comment(ctx context.Context, field graphql.CollectedField, obj *model.LteModem) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LteModem_comment(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Comment, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LteModem_comment(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LteModem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MemoryMetrics_used(ctx context.Context, field graphql.CollectedField, obj *model.MemoryMetrics) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MemoryMetrics_used(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Used, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MemoryMetrics_used(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MemoryMetrics",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MemoryMetrics_total(ctx context.Context, field graphql.CollectedField, obj *model.MemoryMetrics) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MemoryMetrics_total(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Total, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MemoryMetrics_total(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MemoryMetrics",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MemoryMetrics_percentage(ctx context.Context, field graphql.CollectedField, obj *model.MemoryMetrics) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MemoryMetrics_percentage(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Percentage, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MemoryMetrics_percentage(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MemoryMetrics",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MissingDependency_itemId(ctx context.Context, field graphql.CollectedField, obj *model.MissingDependency) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MissingDependency_itemId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ItemID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MissingDependency_itemId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MissingDependency",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MissingDependency_missingResourceType(ctx context.Context, field graphql.CollectedField, obj *model.MissingDependency) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MissingDependency_missingResourceType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MissingResourceType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MissingDependency_missingResourceType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MissingDependency",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MissingDependency_missingResourceId(ctx context.Context, field graphql.CollectedField, obj *model.MissingDependency) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MissingDependency_missingResourceId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MissingResourceID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MissingDependency_missingResourceId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MissingDependency",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createRouter(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_createRouter(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CreateRouter(rctx, fc.Args["input"].(model.CreateRouterInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.CreateRouterPayload)
	fc.Result = res
	return ec.marshalNCreateRouterPayload2backendgraphmodelCreateRouterPayload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_createRouter(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "router":
				return ec.fieldContext_CreateRouterPayload_router(ctx, field)
			case "errors":
				return ec.fieldContext_CreateRouterPayload_errors(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CreateRouterPayload", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createRouter_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateRouter(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateRouter(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UpdateRouter(rctx, fc.Args["id"].(string), fc.Args["input"].(model.UpdateRouterInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.UpdateRouterPayload)
	fc.Result = res
	return ec.marshalNUpdateRouterPayload2backendgraphmodelUpdateRouterPayload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateRouter(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "router":
				return ec.fieldContext_UpdateRouterPayload_router(ctx, field)
			case "errors":
				return ec.fieldContext_UpdateRouterPayload_errors(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UpdateRouterPayload", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateRouter_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_deleteRouter(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_deleteRouter(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().DeleteRouter(rctx, fc.Args["id"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.DeleteRouterPayload)
	fc.Result = res
	return ec.marshalNDeleteRouterPayload2backendgraphmodelDeleteRouterPayload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_deleteRouter(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "success":
				return ec.fieldContext_DeleteRouterPayload_success(ctx, field)
			case "deletedRouterId":
				return ec.fieldContext_DeleteRouterPayload_deletedRouterId(ctx, field)
			case "errors":
				return ec.fieldContext_DeleteRouterPayload_errors(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DeleteRouterPayload", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deleteRouter_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_testRouterConnection(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_testRouterConnection(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().TestRouterConnection(rctx, fc.Args["id"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.TestConnectionPayload)
	fc.Result = res
	return ec.marshalNTestConnectionPayload2backendgraphmodelTestConnectionPayload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_testRouterConnection(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "success":
				return ec.fieldContext_TestConnectionPayload_success(ctx, field)
			case "responseTimeMs":
				return ec.fieldContext_TestConnectionPayload_responseTimeMs(ctx, field)
			case "version":
				return ec.fieldContext_TestConnectionPayload_version(ctx, field)
			case "error":
				return ec.fieldContext_TestConnectionPayload_error(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TestConnectionPayload", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_testRouterConnection_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_connectRouter(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_connectRouter(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().ConnectRouter(rctx, fc.Args["id"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.ConnectRouterPayload)
	fc.Result = res
	return ec.marshalNConnectRouterPayload2backendgraphmodelConnectRouterPayload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_connectRouter(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "router":
				return ec.fieldContext_ConnectRouterPayload_router(ctx, field)
			case "errors":
				return ec.fieldContext_ConnectRouterPayload_errors(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ConnectRouterPayload", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_connectRouter_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_disconnectRouter(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_disconnectRouter(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().DisconnectRouter(rctx, fc.Args["id"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.DisconnectRouterPayload)
	fc.Result = res
	return ec.marshalNDisconnectRouterPayload2backendgraphmodelDisconnectRouterPayload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_disconnectRouter(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "router":
				return ec.fieldContext_DisconnectRouterPayload_router(ctx, field)
			case "errors":
				return ec.fieldContext_DisconnectRouterPayload_errors(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DisconnectRouterPayload", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_disconnectRouter_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_refreshCapabilities(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_refreshCapabilities(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().RefreshCapabilities(rctx, fc.Args["routerId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.RefreshCapabilitiesPayload)
	fc.Result = res
	return ec.marshalNRefreshCapabilitiesPayload2backendgraphmodelRefreshCapabilitiesPayload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_refreshCapabilities(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "capabilities":
				return ec.fieldContext_RefreshCapabilitiesPayload_capabilities(ctx, field)
			case "errors":
				return ec.fieldContext_RefreshCapabilitiesPayload_errors(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RefreshCapabilitiesPayload", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_refreshCapabilities_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateInterface(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateInterface(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UpdateInterface(rctx, fc.Args["routerId"].(string), fc.Args["interfaceId"].(string), fc.Args["input"].(model.UpdateInterfaceInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.UpdateInterfacePayload)
	fc.Result = res
	return ec.marshalNUpdateInterfacePayload2backendgraphmodelUpdateInterfacePayload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateInterface(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "interface":
				return ec.fieldContext_UpdateInterfacePayload_interface(ctx, field)
			case "errors":
				return ec.fieldContext_UpdateInterfacePayload_errors(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UpdateInterfacePayload", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateInterface_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_enableInterface(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_enableInterface(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().EnableInterface(rctx, fc.Args["routerId"].(string), fc.Args["interfaceId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.UpdateInterfacePayload)
	fc.Result = res
	return ec.marshalNUpdateInterfacePayload2backendgraphmodelUpdateInterfacePayload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_enableInterface(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "interface":
				return ec.fieldContext_UpdateInterfacePayload_interface(ctx, field)
			case "errors":
				return ec.fieldContext_UpdateInterfacePayload_errors(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UpdateInterfacePayload", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_enableInterface_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_disableInterface(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_disableInterface(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().DisableInterface(rctx, fc.Args["routerId"].(string), fc.Args["interfaceId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.UpdateInterfacePayload)
	fc.Result = res
	return ec.marshalNUpdateInterfacePayload2backendgraphmodelUpdateInterfacePayload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_disableInterface(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "interface":
				return ec.fieldContext_UpdateInterfacePayload_interface(ctx, field)
			case "errors":
				return ec.fieldContext_UpdateInterfacePayload_errors(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UpdateInterfacePayload", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_disableInterface_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_batchInterfaceOperation(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_batchInterfaceOperation(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().BatchInterfaceOperation(rctx, fc.Args["routerId"].(string), fc.Args["input"].(model.BatchInterfaceInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.BatchInterfacePayload)
	fc.Result = res
	return ec.marshalNBatchInterfacePayload2backendgraphmodelBatchInterfacePayload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_batchInterfaceOperation(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "succeeded":
				return ec.fieldContext_BatchInterfacePayload_succeeded(ctx, field)
			case "failed":
				return ec.fieldContext_BatchInterfacePayload_failed(ctx, field)
			case "errors":
				return ec.fieldContext_BatchInterfacePayload_errors(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type BatchInterfacePayload", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_batchInterfaceOperation_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_login(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_login(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().Login(rctx, fc.Args["username"].(string), fc.Args["password"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.AuthPayload)
	fc.Result = res
	return ec.marshalNAuthPayload2backendgraphmodelAuthPayload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_login(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "token":
				return ec.fieldContext_AuthPayload_token(ctx, field)
			case "user":
				return ec.fieldContext_AuthPayload_user(ctx, field)
			case "expiresAt":
				return ec.fieldContext_AuthPayload_expiresAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type AuthPayload", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_login_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_logout(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_logout(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().Logout(rctx)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Auth == nil {
				return nil, errors.New("directive auth is not implemented")
			}
			return ec.directives.Auth(ctx, nil, directive0, nil)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_logout(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_changePassword(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_changePassword(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().ChangePassword(rctx, fc.Args["currentPassword"].(string), fc.Args["newPassword"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Auth == nil {
				return nil, errors.New("directive auth is not implemented")
			}
			return ec.directives.Auth(ctx, nil, directive0, nil)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_changePassword(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_changePassword_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_revokeAllSessions(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_revokeAllSessions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().RevokeAllSessions(rctx, fc.Args["userId"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			requires, err := ec.unmarshalOString2string(ctx, "admin")
			if err != nil {
				return nil, err
			}
			if ec.directives.Auth == nil {
				return nil, errors.New("directive auth is not implemented")
			}
			return ec.directives.Auth(ctx, nil, directive0, requires)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_revokeAllSessions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_revokeAllSessions_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_revokeSession(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_revokeSession(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().RevokeSession(rctx, fc.Args["sessionId"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Auth == nil {
				return nil, errors.New("directive auth is not implemented")
			}
			return ec.directives.Auth(ctx, nil, directive0, nil)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_revokeSession(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_revokeSession_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_setPreferredProtocol(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_setPreferredProtocol(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().SetPreferredProtocol(rctx, fc.Args["routerId"].(string), fc.Args["protocol"].(model.Protocol))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.SetPreferredProtocolPayload)
	fc.Result = res
	return ec.marshalNSetPreferredProtocolPayload2backendgraphmodelSetPreferredProtocolPayload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_setPreferredProtocol(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "router":
				return ec.fieldContext_SetPreferredProtocolPayload_router(ctx, field)
			case "connectionDetails":
				return ec.fieldContext_SetPreferredProtocolPayload_connectionDetails(ctx, field)
			case "errors":
				return ec.fieldContext_SetPreferredProtocolPayload_errors(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SetPreferredProtocolPayload", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_setPreferredProtocol_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_reconnectRouter(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_reconnectRouter(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().ReconnectRouter(rctx, fc.Args["routerId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.ReconnectRouterPayload)
	fc.Result = res
	return ec.marshalNReconnectRouterPayload2backendgraphmodelReconnectRouterPayload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_reconnectRouter(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "router":
				return ec.fieldContext_ReconnectRouterPayload_router(ctx, field)
			case "connectionDetails":
				return ec.fieldContext_ReconnectRouterPayload_connectionDetails(ctx, field)
			case "initiated":
				return ec.fieldContext_ReconnectRouterPayload_initiated(ctx, field)
			case "waitTimeMs":
				return ec.fieldContext_ReconnectRouterPayload_waitTimeMs(ctx, field)
			case "errors":
				return ec.fieldContext_ReconnectRouterPayload_errors(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ReconnectRouterPayload", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_reconnectRouter_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_checkRouterHealth(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_checkRouterHealth(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CheckRouterHealth(rctx, fc.Args["routerId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.HealthCheckResult)
	fc.Result = res
	return ec.marshalNHealthCheckResult2backendgraphmodelHealthCheckResult(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_checkRouterHealth(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "routerId":
				return ec.fieldContext_HealthCheckResult_routerId(ctx, field)
			case "healthy":
				return ec.fieldContext_HealthCheckResult_healthy(ctx, field)
			case "checkedAt":
				return ec.fieldContext_HealthCheckResult_checkedAt(ctx, field)
			case "responseTimeMs":
				return ec.fieldContext_HealthCheckResult_responseTimeMs(ctx, field)
			case "error":
				return ec.fieldContext_HealthCheckResult_error(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type HealthCheckResult", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_checkRouterHealth_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateRouterCredentials(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateRouterCredentials(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().UpdateRouterCredentials(rctx, fc.Args["routerId"].(string), fc.Args["input"].(model.CredentialsInput))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Auth == nil {
				return nil, errors.New("directive auth is not implemented")
			}
			return ec.directives.Auth(ctx, nil, directive0, nil)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.CredentialUpdatePayload); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *backend/graph/model.CredentialUpdatePayload`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.CredentialUpdatePayload)
	fc.Result = res
	return ec.marshalNCredentialUpdatePayload2backendgraphmodelCredentialUpdatePayload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateRouterCredentials(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "success":
				return ec.fieldContext_CredentialUpdatePayload_success(ctx, field)
			case "message":
				return ec.fieldContext_CredentialUpdatePayload_message(ctx, field)
			case "credentials":
				return ec.fieldContext_CredentialUpdatePayload_credentials(ctx, field)
			case "errorCode":
				return ec.fieldContext_CredentialUpdatePayload_errorCode(ctx, field)
			case "errors":
				return ec.fieldContext_CredentialUpdatePayload_errors(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CredentialUpdatePayload", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateRouterCredentials_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_testAllCredentials(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_testAllCredentials(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().TestAllCredentials(rctx)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Auth == nil {
				return nil, errors.New("directive auth is not implemented")
			}
			return ec.directives.Auth(ctx, nil, directive0, nil)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.TestAllCredentialsPayload); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *backend/graph/model.TestAllCredentialsPayload`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.TestAllCredentialsPayload)
	fc.Result = res
	return ec.marshalNTestAllCredentialsPayload2backendgraphmodelTestAllCredentialsPayload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_testAllCredentials(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "totalRouters":
				return ec.fieldContext_TestAllCredentialsPayload_totalRouters(ctx, field)
			case "successCount":
				return ec.fieldContext_TestAllCredentialsPayload_successCount(ctx, field)
			case "failureCount":
				return ec.fieldContext_TestAllCredentialsPayload_failureCount(ctx, field)
			case "results":
				return ec.fieldContext_TestAllCredentialsPayload_results(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TestAllCredentialsPayload", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_exportRouterConfig(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_exportRouterConfig(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().ExportRouterConfig(rctx, fc.Args["input"].(model.ExportConfigInput))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Auth == nil {
				return nil, errors.New("directive auth is not implemented")
			}
			return ec.directives.Auth(ctx, nil, directive0, nil)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.ExportConfigPayload); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *backend/graph/model.ExportConfigPayload`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.ExportConfigPayload)
	fc.Result = res
	return ec.marshalNExportConfigPayload2backendgraphmodelExportConfigPayload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_exportRouterConfig(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "success":
				return ec.fieldContext_ExportConfigPayload_success(ctx, field)
			case "config":
				return ec.fieldContext_ExportConfigPayload_config(ctx, field)
			case "securityWarning":
				return ec.fieldContext_ExportConfigPayload_securityWarning(ctx, field)
			case "errors":
				return ec.fieldContext_ExportConfigPayload_errors(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ExportConfigPayload", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_exportRouterConfig_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_scanNetwork(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_scanNetwork(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().ScanNetwork(rctx, fc.Args["input"].(model.ScanNetworkInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.ScanNetworkPayload)
	fc.Result = res
	return ec.marshalNScanNetworkPayload2backendgraphmodelScanNetworkPayload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_scanNetwork(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "task":
				return ec.fieldContext_ScanNetworkPayload_task(ctx, field)
			case "errors":
				return ec.fieldContext_ScanNetworkPayload_errors(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ScanNetworkPayload", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_scanNetwork_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_autoScanGateways(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_autoScanGateways(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().AutoScanGateways(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.ScanNetworkPayload)
	fc.Result = res
	return ec.marshalNScanNetworkPayload2backendgraphmodelScanNetworkPayload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_autoScanGateways(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "task":
				return ec.fieldContext_ScanNetworkPayload_task(ctx, field)
			case "errors":
				return ec.fieldContext_ScanNetworkPayload_errors(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ScanNetworkPayload", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_cancelScan(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_cancelScan(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CancelScan(rctx, fc.Args["taskId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.CancelScanPayload)
	fc.Result = res
	return ec.marshalNCancelScanPayload2backendgraphmodelCancelScanPayload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_cancelScan(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "task":
				return ec.fieldContext_CancelScanPayload_task(ctx, field)
			case "errors":
				return ec.fieldContext_CancelScanPayload_errors(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CancelScanPayload", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_cancelScan_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createChangeSet(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_createChangeSet(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CreateChangeSet(rctx, fc.Args["input"].(model.CreateChangeSetInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.CreateChangeSetPayload)
	fc.Result = res
	return ec.marshalNCreateChangeSetPayload2backendgraphmodelCreateChangeSetPayload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_createChangeSet(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "changeSet":
				return ec.fieldContext_CreateChangeSetPayload_changeSet(ctx, field)
			case "errors":
				return ec.fieldContext_CreateChangeSetPayload_errors(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CreateChangeSetPayload", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createChangeSet_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_addChangeSetItem(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_addChangeSetItem(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().AddChangeSetItem(rctx, fc.Args["changeSetId"].(string), fc.Args["input"].(model.ChangeSetItemInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.AddChangeSetItemPayload)
	fc.Result = res
	return ec.marshalNAddChangeSetItemPayload2backendgraphmodelAddChangeSetItemPayload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_addChangeSetItem(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "changeSet":
				return ec.fieldContext_AddChangeSetItemPayload_changeSet(ctx, field)
			case "itemId":
				return ec.fieldContext_AddChangeSetItemPayload_itemId(ctx, field)
			case "errors":
				return ec.fieldContext_AddChangeSetItemPayload_errors(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type AddChangeSetItemPayload", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_addChangeSetItem_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateChangeSetItem(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateChangeSetItem(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UpdateChangeSetItem(rctx, fc.Args["changeSetId"].(string), fc.Args["itemId"].(string), fc.Args["input"].(model.UpdateChangeSetItemInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.UpdateChangeSetItemPayload)
	fc.Result = res
	return ec.marshalNUpdateChangeSetItemPayload2backendgraphmodelUpdateChangeSetItemPayload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateChangeSetItem(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "changeSet":
				return ec.fieldContext_UpdateChangeSetItemPayload_changeSet(ctx, field)
			case "errors":
				return ec.fieldContext_UpdateChangeSetItemPayload_errors(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UpdateChangeSetItemPayload", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateChangeSetItem_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_removeChangeSetItem(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_removeChangeSetItem(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().RemoveChangeSetItem(rctx, fc.Args["changeSetId"].(string), fc.Args["itemId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.RemoveChangeSetItemPayload)
	fc.Result = res
	return ec.marshalNRemoveChangeSetItemPayload2backendgraphmodelRemoveChangeSetItemPayload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_removeChangeSetItem(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "changeSet":
				return ec.fieldContext_RemoveChangeSetItemPayload_changeSet(ctx, field)
			case "errors":
				return ec.fieldContext_RemoveChangeSetItemPayload_errors(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RemoveChangeSetItemPayload", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_removeChangeSetItem_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_validateChangeSet(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_validateChangeSet(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().ValidateChangeSet(rctx, fc.Args["changeSetId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.ValidateChangeSetPayload)
	fc.Result = res
	return ec.marshalNValidateChangeSetPayload2backendgraphmodelValidateChangeSetPayload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_validateChangeSet(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "changeSet":
				return ec.fieldContext_ValidateChangeSetPayload_changeSet(ctx, field)
			case "validation":
				return ec.fieldContext_ValidateChangeSetPayload_validation(ctx, field)
			case "errors":
				return ec.fieldContext_ValidateChangeSetPayload_errors(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ValidateChangeSetPayload", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_validateChangeSet_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_applyChangeSet(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_applyChangeSet(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().ApplyChangeSet(rctx, fc.Args["changeSetId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.ApplyChangeSetPayload)
	fc.Result = res
	return ec.marshalNApplyChangeSetPayload2backendgraphmodelApplyChangeSetPayload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_applyChangeSet(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "changeSetId":
				return ec.fieldContext_ApplyChangeSetPayload_changeSetId(ctx, field)
			case "status":
				return ec.fieldContext_ApplyChangeSetPayload_status(ctx, field)
			case "errors":
				return ec.fieldContext_ApplyChangeSetPayload_errors(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ApplyChangeSetPayload", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_applyChangeSet_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_cancelChangeSet(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_cancelChangeSet(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CancelChangeSet(rctx, fc.Args["changeSetId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.CancelChangeSetPayload)
	fc.Result = res
	return ec.marshalNCancelChangeSetPayload2backendgraphmodelCancelChangeSetPayload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_cancelChangeSet(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "changeSet":
				return ec.fieldContext_CancelChangeSetPayload_changeSet(ctx, field)
			case "success":
				return ec.fieldContext_CancelChangeSetPayload_success(ctx, field)
			case "errors":
				return ec.fieldContext_CancelChangeSetPayload_errors(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CancelChangeSetPayload", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_cancelChangeSet_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_rollbackChangeSet(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_rollbackChangeSet(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().RollbackChangeSet(rctx, fc.Args["changeSetId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.RollbackChangeSetPayload)
	fc.Result = res
	return ec.marshalNRollbackChangeSetPayload2backendgraphmodelRollbackChangeSetPayload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_rollbackChangeSet(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "changeSet":
				return ec.fieldContext_RollbackChangeSetPayload_changeSet(ctx, field)
			case "success":
				return ec.fieldContext_RollbackChangeSetPayload_success(ctx, field)
			case "failedItems":
				return ec.fieldContext_RollbackChangeSetPayload_failedItems(ctx, field)
			case "errors":
				return ec.fieldContext_RollbackChangeSetPayload_errors(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RollbackChangeSetPayload", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_rollbackChangeSet_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_deleteChangeSet(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_deleteChangeSet(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().DeleteChangeSet(rctx, fc.Args["changeSetId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.DeleteChangeSetPayload)
	fc.Result = res
	return ec.marshalNDeleteChangeSetPayload2backendgraphmodelDeleteChangeSetPayload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_deleteChangeSet(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "success":
				return ec.fieldContext_DeleteChangeSetPayload_success(ctx, field)
			case "errors":
				return ec.fieldContext_DeleteChangeSetPayload_errors(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DeleteChangeSetPayload", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deleteChangeSet_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_runDiagnostics(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_runDiagnostics(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().RunDiagnostics(rctx, fc.Args["routerId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.DiagnosticReport)
	fc.Result = res
	return ec.marshalNDiagnosticReport2backendgraphmodelDiagnosticReport(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_runDiagnostics(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "routerId":
				return ec.fieldContext_DiagnosticReport_routerId(ctx, field)
			case "timestamp":
				return ec.fieldContext_DiagnosticReport_timestamp(ctx, field)
			case "networkReachable":
				return ec.fieldContext_DiagnosticReport_networkReachable(ctx, field)
			case "portStatus":
				return ec.fieldContext_DiagnosticReport_portStatus(ctx, field)
			case "tlsStatus":
				return ec.fieldContext_DiagnosticReport_tlsStatus(ctx, field)
			case "authStatus":
				return ec.fieldContext_DiagnosticReport_authStatus(ctx, field)
			case "suggestions":
				return ec.fieldContext_DiagnosticReport_suggestions(ctx, field)
			case "rawReport":
				return ec.fieldContext_DiagnosticReport_rawReport(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DiagnosticReport", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_runDiagnostics_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_resetCircuitBreaker(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_resetCircuitBreaker(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().ResetCircuitBreaker(rctx, fc.Args["routerId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.CircuitBreakerStatus)
	fc.Result = res
	return ec.marshalNCircuitBreakerStatus2backendgraphmodelCircuitBreakerStatus(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_resetCircuitBreaker(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "routerId":
				return ec.fieldContext_CircuitBreakerStatus_routerId(ctx, field)
			case "state":
				return ec.fieldContext_CircuitBreakerStatus_state(ctx, field)
			case "failureCount":
				return ec.fieldContext_CircuitBreakerStatus_failureCount(ctx, field)
			case "failureThreshold":
				return ec.fieldContext_CircuitBreakerStatus_failureThreshold(ctx, field)
			case "cooldownRemainingSeconds":
				return ec.fieldContext_CircuitBreakerStatus_cooldownRemainingSeconds(ctx, field)
			case "lastFailureAt":
				return ec.fieldContext_CircuitBreakerStatus_lastFailureAt(ctx, field)
			case "lastSuccessAt":
				return ec.fieldContext_CircuitBreakerStatus_lastSuccessAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CircuitBreakerStatus", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_resetCircuitBreaker_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_startTroubleshoot(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_startTroubleshoot(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().StartTroubleshoot(rctx, fc.Args["routerId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.StartTroubleshootPayload)
	fc.Result = res
	return ec.marshalNStartTroubleshootPayload2backendgraphmodelStartTroubleshootPayload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_startTroubleshoot(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "session":
				return ec.fieldContext_StartTroubleshootPayload_session(ctx, field)
			case "errors":
				return ec.fieldContext_StartTroubleshootPayload_errors(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type StartTroubleshootPayload", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_startTroubleshoot_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_runTroubleshootStep(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_runTroubleshootStep(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().RunTroubleshootStep(rctx, fc.Args["sessionId"].(string), fc.Args["stepType"].(model.TroubleshootStepType))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.RunTroubleshootStepPayload)
	fc.Result = res
	return ec.marshalNRunTroubleshootStepPayload2backendgraphmodelRunTroubleshootStepPayload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_runTroubleshootStep(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "step":
				return ec.fieldContext_RunTroubleshootStepPayload_step(ctx, field)
			case "errors":
				return ec.fieldContext_RunTroubleshootStepPayload_errors(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RunTroubleshootStepPayload", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_runTroubleshootStep_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_applyTroubleshootFix(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_applyTroubleshootFix(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().ApplyTroubleshootFix(rctx, fc.Args["sessionId"].(string), fc.Args["issueCode"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.ApplyFixPayload)
	fc.Result = res
	return ec.marshalNApplyFixPayload2backendgraphmodelApplyFixPayload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_applyTroubleshootFix(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "success":
				return ec.fieldContext_ApplyFixPayload_success(ctx, field)
			case "message":
				return ec.fieldContext_ApplyFixPayload_message(ctx, field)
			case "status":
				return ec.fieldContext_ApplyFixPayload_status(ctx, field)
			case "errors":
				return ec.fieldContext_ApplyFixPayload_errors(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ApplyFixPayload", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_applyTroubleshootFix_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_verifyTroubleshootFix(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_verifyTroubleshootFix(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().VerifyTroubleshootFix(rctx, fc.Args["sessionId"].(string), fc.Args["stepType"].(model.TroubleshootStepType))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.RunTroubleshootStepPayload)
	fc.Result = res
	return ec.marshalNRunTroubleshootStepPayload2backendgraphmodelRunTroubleshootStepPayload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_verifyTroubleshootFix(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "step":
				return ec.fieldContext_RunTroubleshootStepPayload_step(ctx, field)
			case "errors":
				return ec.fieldContext_RunTroubleshootStepPayload_errors(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RunTroubleshootStepPayload", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_verifyTroubleshootFix_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_cancelTroubleshoot(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_cancelTroubleshoot(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CancelTroubleshoot(rctx, fc.Args["sessionId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.TroubleshootSession)
	fc.Result = res
	return ec.marshalNTroubleshootSession2backendgraphmodelTroubleshootSession(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_cancelTroubleshoot(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_TroubleshootSession_id(ctx, field)
			case "routerId":
				return ec.fieldContext_TroubleshootSession_routerId(ctx, field)
			case "steps":
				return ec.fieldContext_TroubleshootSession_steps(ctx, field)
			case "currentStepIndex":
				return ec.fieldContext_TroubleshootSession_currentStepIndex(ctx, field)
			case "status":
				return ec.fieldContext_TroubleshootSession_status(ctx, field)
			case "wanInterface":
				return ec.fieldContext_TroubleshootSession_wanInterface(ctx, field)
			case "gateway":
				return ec.fieldContext_TroubleshootSession_gateway(ctx, field)
			case "ispInfo":
				return ec.fieldContext_TroubleshootSession_ispInfo(ctx, field)
			case "appliedFixes":
				return ec.fieldContext_TroubleshootSession_appliedFixes(ctx, field)
			case "startedAt":
				return ec.fieldContext_TroubleshootSession_startedAt(ctx, field)
			case "completedAt":
				return ec.fieldContext_TroubleshootSession_completedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TroubleshootSession", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_cancelTroubleshoot_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_runTraceroute(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_runTraceroute(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().RunTraceroute(rctx, fc.Args["deviceId"].(string), fc.Args["input"].(model.TracerouteInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.TracerouteJob)
	fc.Result = res
	return ec.marshalNTracerouteJob2backendgraphmodelTracerouteJob(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_runTraceroute(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "jobId":
				return ec.fieldContext_TracerouteJob_jobId(ctx, field)
			case "status":
				return ec.fieldContext_TracerouteJob_status(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TracerouteJob", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_runTraceroute_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_cancelTraceroute(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_cancelTraceroute(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CancelTraceroute(rctx, fc.Args["jobId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_cancelTraceroute(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_cancelTraceroute_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_runDnsLookup(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_runDnsLookup(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().RunDNSLookup(rctx, fc.Args["input"].(model.DNSLookupInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.DNSLookupResult)
	fc.Result = res
	return ec.marshalNDnsLookupResult2backendgraphmodelDNSLookupResult(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_runDnsLookup(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hostname":
				return ec.fieldContext_DnsLookupResult_hostname(ctx, field)
			case "recordType":
				return ec.fieldContext_DnsLookupResult_recordType(ctx, field)
			case "status":
				return ec.fieldContext_DnsLookupResult_status(ctx, field)
			case "records":
				return ec.fieldContext_DnsLookupResult_records(ctx, field)
			case "server":
				return ec.fieldContext_DnsLookupResult_server(ctx, field)
			case "queryTime":
				return ec.fieldContext_DnsLookupResult_queryTime(ctx, field)
			case "authoritative":
				return ec.fieldContext_DnsLookupResult_authoritative(ctx, field)
			case "error":
				return ec.fieldContext_DnsLookupResult_error(ctx, field)
			case "timestamp":
				return ec.fieldContext_DnsLookupResult_timestamp(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DnsLookupResult", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_runDnsLookup_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createAlertRule(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_createAlertRule(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CreateAlertRule(rctx, fc.Args["input"].(model.CreateAlertRuleInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.AlertRulePayload)
	fc.Result = res
	return ec.marshalNAlertRulePayload2backendgraphmodelAlertRulePayload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_createAlertRule(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "alertRule":
				return ec.fieldContext_AlertRulePayload_alertRule(ctx, field)
			case "errors":
				return ec.fieldContext_AlertRulePayload_errors(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type AlertRulePayload", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createAlertRule_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateAlertRule(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateAlertRule(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UpdateAlertRule(rctx, fc.Args["id"].(string), fc.Args["input"].(model.UpdateAlertRuleInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.AlertRulePayload)
	fc.Result = res
	return ec.marshalNAlertRulePayload2backendgraphmodelAlertRulePayload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateAlertRule(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "alertRule":
				return ec.fieldContext_AlertRulePayload_alertRule(ctx, field)
			case "errors":
				return ec.fieldContext_AlertRulePayload_errors(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type AlertRulePayload", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateAlertRule_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_deleteAlertRule(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_deleteAlertRule(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().DeleteAlertRule(rctx, fc.Args["id"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.DeletePayload)
	fc.Result = res
	return ec.marshalNDeletePayload2backendgraphmodelDeletePayload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_deleteAlertRule(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "success":
				return ec.fieldContext_DeletePayload_success(ctx, field)
			case "deletedId":
				return ec.fieldContext_DeletePayload_deletedId(ctx, field)
			case "errors":
				return ec.fieldContext_DeletePayload_errors(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DeletePayload", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deleteAlertRule_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_acknowledgeAlert(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_acknowledgeAlert(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().AcknowledgeAlert(rctx, fc.Args["alertId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.AlertPayload)
	fc.Result = res
	return ec.marshalNAlertPayload2backendgraphmodelAlertPayload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_acknowledgeAlert(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "alert":
				return ec.fieldContext_AlertPayload_alert(ctx, field)
			case "errors":
				return ec.fieldContext_AlertPayload_errors(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type AlertPayload", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_acknowledgeAlert_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_acknowledgeAlerts(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_acknowledgeAlerts(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().AcknowledgeAlerts(rctx, fc.Args["alertIds"].([]string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.BulkAlertPayload)
	fc.Result = res
	return ec.marshalNBulkAlertPayload2backendgraphmodelBulkAlertPayload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_acknowledgeAlerts(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "acknowledgedCount":
				return ec.fieldContext_BulkAlertPayload_acknowledgedCount(ctx, field)
			case "errors":
				return ec.fieldContext_BulkAlertPayload_errors(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type BulkAlertPayload", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_acknowledgeAlerts_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_testNotificationChannel(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_testNotificationChannel(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().TestNotificationChannel(rctx, fc.Args["channel"].(string), fc.Args["config"].(map[string]interface{}))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.TestNotificationPayload)
	fc.Result = res
	return ec.marshalNTestNotificationPayload2backendgraphmodelTestNotificationPayload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_testNotificationChannel(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "success":
				return ec.fieldContext_TestNotificationPayload_success(ctx, field)
			case "message":
				return ec.fieldContext_TestNotificationPayload_message(ctx, field)
			case "errors":
				return ec.fieldContext_TestNotificationPayload_errors(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TestNotificationPayload", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_testNotificationChannel_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_addRouter(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_addRouter(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().AddRouter(rctx, fc.Args["input"].(model.AddRouterInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.AddRouterPayload)
	fc.Result = res
	return ec.marshalNAddRouterPayload2backendgraphmodelAddRouterPayload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_addRouter(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "router":
				return ec.fieldContext_AddRouterPayload_router(ctx, field)
			case "connectionResult":
				return ec.fieldContext_AddRouterPayload_connectionResult(ctx, field)
			case "validationErrors":
				return ec.fieldContext_AddRouterPayload_validationErrors(ctx, field)
			case "errors":
				return ec.fieldContext_AddRouterPayload_errors(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type AddRouterPayload", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_addRouter_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_testRouterCredentials(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_testRouterCredentials(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().TestRouterCredentials(rctx, fc.Args["input"].(model.AddRouterInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.ConnectionTestResult)
	fc.Result = res
	return ec.marshalNConnectionTestResult2backendgraphmodelConnectionTestResult(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_testRouterCredentials(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "success":
				return ec.fieldContext_ConnectionTestResult_success(ctx, field)
			case "protocolUsed":
				return ec.fieldContext_ConnectionTestResult_protocolUsed(ctx, field)
			case "responseTimeMs":
				return ec.fieldContext_ConnectionTestResult_responseTimeMs(ctx, field)
			case "routerVersion":
				return ec.fieldContext_ConnectionTestResult_routerVersion(ctx, field)
			case "routerModel":
				return ec.fieldContext_ConnectionTestResult_routerModel(ctx, field)
			case "boardName":
				return ec.fieldContext_ConnectionTestResult_boardName(ctx, field)
			case "uptime":
				return ec.fieldContext_ConnectionTestResult_uptime(ctx, field)
			case "protocolsAttempted":
				return ec.fieldContext_ConnectionTestResult_protocolsAttempted(ctx, field)
			case "supportsContainers":
				return ec.fieldContext_ConnectionTestResult_supportsContainers(ctx, field)
			case "architecture":
				return ec.fieldContext_ConnectionTestResult_architecture(ctx, field)
			case "error":
				return ec.fieldContext_ConnectionTestResult_error(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ConnectionTestResult", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_testRouterCredentials_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createResource(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_createResource(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CreateResource(rctx, fc.Args["input"].(model.CreateResourceInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.CreateResourcePayload)
	fc.Result = res
	return ec.marshalNCreateResourcePayload2backendgraphmodelCreateResourcePayload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_createResource(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "resource":
				return ec.fieldContext_CreateResourcePayload_resource(ctx, field)
			case "errors":
				return ec.fieldContext_CreateResourcePayload_errors(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CreateResourcePayload", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createResource_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateResource(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateResource(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UpdateResource(rctx, fc.Args["id"].(string), fc.Args["routerId"].(string), fc.Args["input"].(model.UpdateResourceInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.UpdateResourcePayload)
	fc.Result = res
	return ec.marshalNUpdateResourcePayload2backendgraphmodelUpdateResourcePayload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateResource(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "resource":
				return ec.fieldContext_UpdateResourcePayload_resource(ctx, field)
			case "errors":
				return ec.fieldContext_UpdateResourcePayload_errors(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UpdateResourcePayload", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateResource_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_validateResource(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_validateResource(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().ValidateResource(rctx, fc.Args["id"].(string), fc.Args["routerId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.ValidateResourcePayload)
	fc.Result = res
	return ec.marshalNValidateResourcePayload2backendgraphmodelValidateResourcePayload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_validateResource(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "resource":
				return ec.fieldContext_ValidateResourcePayload_resource(ctx, field)
			case "validation":
				return ec.fieldContext_ValidateResourcePayload_validation(ctx, field)
			case "errors":
				return ec.fieldContext_ValidateResourcePayload_errors(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ValidateResourcePayload", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_validateResource_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_applyResource(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_applyResource(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().ApplyResource(rctx, fc.Args["id"].(string), fc.Args["routerId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.ApplyResourcePayload)
	fc.Result = res
	return ec.marshalNApplyResourcePayload2backendgraphmodelApplyResourcePayload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_applyResource(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "resource":
				return ec.fieldContext_ApplyResourcePayload_resource(ctx, field)
			case "operationId":
				return ec.fieldContext_ApplyResourcePayload_operationId(ctx, field)
			case "errors":
				return ec.fieldContext_ApplyResourcePayload_errors(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ApplyResourcePayload", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_applyResource_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_deprecateResource(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_deprecateResource(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().DeprecateResource(rctx, fc.Args["id"].(string), fc.Args["routerId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.DeprecateResourcePayload)
	fc.Result = res
	return ec.marshalNDeprecateResourcePayload2backendgraphmodelDeprecateResourcePayload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_deprecateResource(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "resource":
				return ec.fieldContext_DeprecateResourcePayload_resource(ctx, field)
			case "errors":
				return ec.fieldContext_DeprecateResourcePayload_errors(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DeprecateResourcePayload", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deprecateResource_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_archiveResource(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_archiveResource(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().ArchiveResource(rctx, fc.Args["id"].(string), fc.Args["routerId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.ArchiveResourcePayload)
	fc.Result = res
	return ec.marshalNArchiveResourcePayload2backendgraphmodelArchiveResourcePayload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_archiveResource(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "success":
				return ec.fieldContext_ArchiveResourcePayload_success(ctx, field)
			case "errors":
				return ec.fieldContext_ArchiveResourcePayload_errors(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ArchiveResourcePayload", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_archiveResource_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_deleteResource(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_deleteResource(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().DeleteResource(rctx, fc.Args["id"].(string), fc.Args["routerId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.DeleteResourcePayload)
	fc.Result = res
	return ec.marshalNDeleteResourcePayload2backendgraphmodelDeleteResourcePayload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_deleteResource(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "success":
				return ec.fieldContext_DeleteResourcePayload_success(ctx, field)
			case "deletedId":
				return ec.fieldContext_DeleteResourcePayload_deletedId(ctx, field)
			case "errors":
				return ec.fieldContext_DeleteResourcePayload_errors(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DeleteResourcePayload", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deleteResource_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createIpAddress(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_createIpAddress(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().CreateIPAddress(rctx, fc.Args["routerId"].(string), fc.Args["input"].(model.IPAddressInput))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			requires, err := ec.unmarshalNString2string(ctx, []interface{}{"interface"})
			if err != nil {
				return nil, err
			}
			if ec.directives.Capability == nil {
				return nil, errors.New("directive capability is not implemented")
			}
			return ec.directives.Capability(ctx, nil, directive0, requires)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.IPAddressMutationResult); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *backend/graph/model.IPAddressMutationResult`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.IPAddressMutationResult)
	fc.Result = res
	return ec.marshalNIpAddressMutationResult2backendgraphmodelIPAddressMutationResult(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_createIpAddress(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "success":
				return ec.fieldContext_IpAddressMutationResult_success(ctx, field)
			case "ipAddress":
				return ec.fieldContext_IpAddressMutationResult_ipAddress(ctx, field)
			case "preview":
				return ec.fieldContext_IpAddressMutationResult_preview(ctx, field)
			case "errors":
				return ec.fieldContext_IpAddressMutationResult_errors(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type IpAddressMutationResult", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createIpAddress_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateIpAddress(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateIpAddress(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().UpdateIPAddress(rctx, fc.Args["routerId"].(string), fc.Args["id"].(string), fc.Args["input"].(model.IPAddressInput))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			requires, err := ec.unmarshalNString2string(ctx, []interface{}{"interface"})
			if err != nil {
				return nil, err
			}
			if ec.directives.Capability == nil {
				return nil, errors.New("directive capability is not implemented")
			}
			return ec.directives.Capability(ctx, nil, directive0, requires)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.IPAddressMutationResult); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *backend/graph/model.IPAddressMutationResult`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.IPAddressMutationResult)
	fc.Result = res
	return ec.marshalNIpAddressMutationResult2backendgraphmodelIPAddressMutationResult(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateIpAddress(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "success":
				return ec.fieldContext_IpAddressMutationResult_success(ctx, field)
			case "ipAddress":
				return ec.fieldContext_IpAddressMutationResult_ipAddress(ctx, field)
			case "preview":
				return ec.fieldContext_IpAddressMutationResult_preview(ctx, field)
			case "errors":
				return ec.fieldContext_IpAddressMutationResult_errors(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type IpAddressMutationResult", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateIpAddress_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_deleteIpAddress(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_deleteIpAddress(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().DeleteIPAddress(rctx, fc.Args["routerId"].(string), fc.Args["id"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			requires, err := ec.unmarshalNString2string(ctx, []interface{}{"interface"})
			if err != nil {
				return nil, err
			}
			if ec.directives.Capability == nil {
				return nil, errors.New("directive capability is not implemented")
			}
			return ec.directives.Capability(ctx, nil, directive0, requires)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.IPAddressDeleteResult); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *backend/graph/model.IPAddressDeleteResult`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.IPAddressDeleteResult)
	fc.Result = res
	return ec.marshalNIpAddressDeleteResult2backendgraphmodelIPAddressDeleteResult(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_deleteIpAddress(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "success":
				return ec.fieldContext_IpAddressDeleteResult_success(ctx, field)
			case "message":
				return ec.fieldContext_IpAddressDeleteResult_message(ctx, field)
			case "impactAnalysis":
				return ec.fieldContext_IpAddressDeleteResult_impactAnalysis(ctx, field)
			case "errors":
				return ec.fieldContext_IpAddressDeleteResult_errors(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type IpAddressDeleteResult", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deleteIpAddress_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createVlan(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_createVlan(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().CreateVlan(rctx, fc.Args["routerId"].(string), fc.Args["input"].(model.VlanInput))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			requires, err := ec.unmarshalNString2string(ctx, []interface{}{"interface"})
			if err != nil {
				return nil, err
			}
			if ec.directives.Capability == nil {
				return nil, errors.New("directive capability is not implemented")
			}
			return ec.directives.Capability(ctx, nil, directive0, requires)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.VlanMutationResult); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *backend/graph/model.VlanMutationResult`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.VlanMutationResult)
	fc.Result = res
	return ec.marshalNVlanMutationResult2backendgraphmodelVlanMutationResult(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_createVlan(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "success":
				return ec.fieldContext_VlanMutationResult_success(ctx, field)
			case "vlan":
				return ec.fieldContext_VlanMutationResult_vlan(ctx, field)
			case "preview":
				return ec.fieldContext_VlanMutationResult_preview(ctx, field)
			case "errors":
				return ec.fieldContext_VlanMutationResult_errors(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type VlanMutationResult", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createVlan_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateVlan(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateVlan(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().UpdateVlan(rctx, fc.Args["id"].(string), fc.Args["input"].(model.VlanInput))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			requires, err := ec.unmarshalNString2string(ctx, []interface{}{"interface"})
			if err != nil {
				return nil, err
			}
			if ec.directives.Capability == nil {
				return nil, errors.New("directive capability is not implemented")
			}
			return ec.directives.Capability(ctx, nil, directive0, requires)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.VlanMutationResult); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *backend/graph/model.VlanMutationResult`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.VlanMutationResult)
	fc.Result = res
	return ec.marshalNVlanMutationResult2backendgraphmodelVlanMutationResult(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateVlan(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "success":
				return ec.fieldContext_VlanMutationResult_success(ctx, field)
			case "vlan":
				return ec.fieldContext_VlanMutationResult_vlan(ctx, field)
			case "preview":
				return ec.fieldContext_VlanMutationResult_preview(ctx, field)
			case "errors":
				return ec.fieldContext_VlanMutationResult_errors(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type VlanMutationResult", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateVlan_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_deleteVlan(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_deleteVlan(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().DeleteVlan(rctx, fc.Args["id"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			requires, err := ec.unmarshalNString2string(ctx, []interface{}{"interface"})
			if err != nil {
				return nil, err
			}
			if ec.directives.Capability == nil {
				return nil, errors.New("directive capability is not implemented")
			}
			return ec.directives.Capability(ctx, nil, directive0, requires)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.DeleteResult); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *backend/graph/model.DeleteResult`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.DeleteResult)
	fc.Result = res
	return ec.marshalNDeleteResult2backendgraphmodelDeleteResult(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_deleteVlan(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "success":
				return ec.fieldContext_DeleteResult_success(ctx, field)
			case "message":
				return ec.fieldContext_DeleteResult_message(ctx, field)
			case "errors":
				return ec.fieldContext_DeleteResult_errors(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DeleteResult", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deleteVlan_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_configureBridgePortVlan(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_configureBridgePortVlan(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().ConfigureBridgePortVlan(rctx, fc.Args["routerId"].(string), fc.Args["portId"].(string), fc.Args["input"].(model.BridgePortVlanInput))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			requires, err := ec.unmarshalNString2string(ctx, []interface{}{"interface"})
			if err != nil {
				return nil, err
			}
			if ec.directives.Capability == nil {
				return nil, errors.New("directive capability is not implemented")
			}
			return ec.directives.Capability(ctx, nil, directive0, requires)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.VlanMutationResult); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *backend/graph/model.VlanMutationResult`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.VlanMutationResult)
	fc.Result = res
	return ec.marshalNVlanMutationResult2backendgraphmodelVlanMutationResult(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_configureBridgePortVlan(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "success":
				return ec.fieldContext_VlanMutationResult_success(ctx, field)
			case "vlan":
				return ec.fieldContext_VlanMutationResult_vlan(ctx, field)
			case "preview":
				return ec.fieldContext_VlanMutationResult_preview(ctx, field)
			case "errors":
				return ec.fieldContext_VlanMutationResult_errors(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type VlanMutationResult", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_configureBridgePortVlan_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createRoute(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_createRoute(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().CreateRoute(rctx, fc.Args["routerId"].(string), fc.Args["input"].(model.RouteInput))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			requires, err := ec.unmarshalNString2string(ctx, []interface{}{"routing"})
			if err != nil {
				return nil, err
			}
			if ec.directives.Capability == nil {
				return nil, errors.New("directive capability is not implemented")
			}
			return ec.directives.Capability(ctx, nil, directive0, requires)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.RouteMutationResult); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *backend/graph/model.RouteMutationResult`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.RouteMutationResult)
	fc.Result = res
	return ec.marshalNRouteMutationResult2backendgraphmodelRouteMutationResult(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_createRoute(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "success":
				return ec.fieldContext_RouteMutationResult_success(ctx, field)
			case "message":
				return ec.fieldContext_RouteMutationResult_message(ctx, field)
			case "route":
				return ec.fieldContext_RouteMutationResult_route(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RouteMutationResult", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createRoute_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateRoute(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateRoute(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().UpdateRoute(rctx, fc.Args["routerId"].(string), fc.Args["id"].(string), fc.Args["input"].(model.RouteInput))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			requires, err := ec.unmarshalNString2string(ctx, []interface{}{"routing"})
			if err != nil {
				return nil, err
			}
			if ec.directives.Capability == nil {
				return nil, errors.New("directive capability is not implemented")
			}
			return ec.directives.Capability(ctx, nil, directive0, requires)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.RouteMutationResult); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *backend/graph/model.RouteMutationResult`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.RouteMutationResult)
	fc.Result = res
	return ec.marshalNRouteMutationResult2backendgraphmodelRouteMutationResult(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateRoute(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "success":
				return ec.fieldContext_RouteMutationResult_success(ctx, field)
			case "message":
				return ec.fieldContext_RouteMutationResult_message(ctx, field)
			case "route":
				return ec.fieldContext_RouteMutationResult_route(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RouteMutationResult", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateRoute_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_deleteRoute(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_deleteRoute(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().DeleteRoute(rctx, fc.Args["routerId"].(string), fc.Args["id"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			requires, err := ec.unmarshalNString2string(ctx, []interface{}{"routing"})
			if err != nil {
				return nil, err
			}
			if ec.directives.Capability == nil {
				return nil, errors.New("directive capability is not implemented")
			}
			return ec.directives.Capability(ctx, nil, directive0, requires)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.RouteDeleteResult); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *backend/graph/model.RouteDeleteResult`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.RouteDeleteResult)
	fc.Result = res
	return ec.marshalNRouteDeleteResult2backendgraphmodelRouteDeleteResult(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_deleteRoute(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "success":
				return ec.fieldContext_RouteDeleteResult_success(ctx, field)
			case "message":
				return ec.fieldContext_RouteDeleteResult_message(ctx, field)
			case "impactAnalysis":
				return ec.fieldContext_RouteDeleteResult_impactAnalysis(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RouteDeleteResult", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deleteRoute_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createBridge(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_createBridge(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CreateBridge(rctx, fc.Args["routerId"].(string), fc.Args["input"].(model.CreateBridgeInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.BridgeMutationResult)
	fc.Result = res
	return ec.marshalNBridgeMutationResult2backendgraphmodelBridgeMutationResult(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_createBridge(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "success":
				return ec.fieldContext_BridgeMutationResult_success(ctx, field)
			case "bridge":
				return ec.fieldContext_BridgeMutationResult_bridge(ctx, field)
			case "errors":
				return ec.fieldContext_BridgeMutationResult_errors(ctx, field)
			case "previousState":
				return ec.fieldContext_BridgeMutationResult_previousState(ctx, field)
			case "operationId":
				return ec.fieldContext_BridgeMutationResult_operationId(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type BridgeMutationResult", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createBridge_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateBridge(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateBridge(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UpdateBridge(rctx, fc.Args["uuid"].(string), fc.Args["input"].(model.UpdateBridgeInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.BridgeMutationResult)
	fc.Result = res
	return ec.marshalNBridgeMutationResult2backendgraphmodelBridgeMutationResult(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateBridge(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "success":
				return ec.fieldContext_BridgeMutationResult_success(ctx, field)
			case "bridge":
				return ec.fieldContext_BridgeMutationResult_bridge(ctx, field)
			case "errors":
				return ec.fieldContext_BridgeMutationResult_errors(ctx, field)
			case "previousState":
				return ec.fieldContext_BridgeMutationResult_previousState(ctx, field)
			case "operationId":
				return ec.fieldContext_BridgeMutationResult_operationId(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type BridgeMutationResult", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateBridge_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_deleteBridge(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_deleteBridge(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().DeleteBridge(rctx, fc.Args["uuid"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.DeleteResult)
	fc.Result = res
	return ec.marshalNDeleteResult2backendgraphmodelDeleteResult(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_deleteBridge(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "success":
				return ec.fieldContext_DeleteResult_success(ctx, field)
			case "message":
				return ec.fieldContext_DeleteResult_message(ctx, field)
			case "errors":
				return ec.fieldContext_DeleteResult_errors(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DeleteResult", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deleteBridge_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_undoBridgeOperation(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_undoBridgeOperation(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UndoBridgeOperation(rctx, fc.Args["operationId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.BridgeMutationResult)
	fc.Result = res
	return ec.marshalNBridgeMutationResult2backendgraphmodelBridgeMutationResult(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_undoBridgeOperation(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "success":
				return ec.fieldContext_BridgeMutationResult_success(ctx, field)
			case "bridge":
				return ec.fieldContext_BridgeMutationResult_bridge(ctx, field)
			case "errors":
				return ec.fieldContext_BridgeMutationResult_errors(ctx, field)
			case "previousState":
				return ec.fieldContext_BridgeMutationResult_previousState(ctx, field)
			case "operationId":
				return ec.fieldContext_BridgeMutationResult_operationId(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type BridgeMutationResult", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_undoBridgeOperation_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_addBridgePort(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_addBridgePort(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().AddBridgePort(rctx, fc.Args["bridgeId"].(string), fc.Args["input"].(model.AddBridgePortInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.BridgePortMutationResult)
	fc.Result = res
	return ec.marshalNBridgePortMutationResult2backendgraphmodelBridgePortMutationResult(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_addBridgePort(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "success":
				return ec.fieldContext_BridgePortMutationResult_success(ctx, field)
			case "port":
				return ec.fieldContext_BridgePortMutationResult_port(ctx, field)
			case "errors":
				return ec.fieldContext_BridgePortMutationResult_errors(ctx, field)
			case "previousState":
				return ec.fieldContext_BridgePortMutationResult_previousState(ctx, field)
			case "operationId":
				return ec.fieldContext_BridgePortMutationResult_operationId(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type BridgePortMutationResult", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_addBridgePort_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateBridgePort(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateBridgePort(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UpdateBridgePort(rctx, fc.Args["portId"].(string), fc.Args["input"].(model.UpdateBridgePortInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.BridgePortMutationResult)
	fc.Result = res
	return ec.marshalNBridgePortMutationResult2backendgraphmodelBridgePortMutationResult(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateBridgePort(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "success":
				return ec.fieldContext_BridgePortMutationResult_success(ctx, field)
			case "port":
				return ec.fieldContext_BridgePortMutationResult_port(ctx, field)
			case "errors":
				return ec.fieldContext_BridgePortMutationResult_errors(ctx, field)
			case "previousState":
				return ec.fieldContext_BridgePortMutationResult_previousState(ctx, field)
			case "operationId":
				return ec.fieldContext_BridgePortMutationResult_operationId(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type BridgePortMutationResult", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateBridgePort_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_removeBridgePort(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_removeBridgePort(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().RemoveBridgePort(rctx, fc.Args["portId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.DeleteResult)
	fc.Result = res
	return ec.marshalNDeleteResult2backendgraphmodelDeleteResult(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_removeBridgePort(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "success":
				return ec.fieldContext_DeleteResult_success(ctx, field)
			case "message":
				return ec.fieldContext_DeleteResult_message(ctx, field)
			case "errors":
				return ec.fieldContext_DeleteResult_errors(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DeleteResult", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_removeBridgePort_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createBridgeVlan(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_createBridgeVlan(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CreateBridgeVlan(rctx, fc.Args["bridgeId"].(string), fc.Args["input"].(model.CreateBridgeVlanInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.BridgeVlanMutationResult)
	fc.Result = res
	return ec.marshalNBridgeVlanMutationResult2backendgraphmodelBridgeVlanMutationResult(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_createBridgeVlan(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "success":
				return ec.fieldContext_BridgeVlanMutationResult_success(ctx, field)
			case "vlan":
				return ec.fieldContext_BridgeVlanMutationResult_vlan(ctx, field)
			case "errors":
				return ec.fieldContext_BridgeVlanMutationResult_errors(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type BridgeVlanMutationResult", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createBridgeVlan_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_deleteBridgeVlan(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_deleteBridgeVlan(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().DeleteBridgeVlan(rctx, fc.Args["uuid"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.DeleteResult)
	fc.Result = res
	return ec.marshalNDeleteResult2backendgraphmodelDeleteResult(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_deleteBridgeVlan(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "success":
				return ec.fieldContext_DeleteResult_success(ctx, field)
			case "message":
				return ec.fieldContext_DeleteResult_message(ctx, field)
			case "errors":
				return ec.fieldContext_DeleteResult_errors(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DeleteResult", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deleteBridgeVlan_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_configureDhcpWAN(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_configureDhcpWAN(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().ConfigureDhcpWan(rctx, fc.Args["routerId"].(string), fc.Args["input"].(model.DhcpClientInput))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			requires, err := ec.unmarshalNString2string(ctx, []interface{}{"interface"})
			if err != nil {
				return nil, err
			}
			if ec.directives.Capability == nil {
				return nil, errors.New("directive capability is not implemented")
			}
			return ec.directives.Capability(ctx, nil, directive0, requires)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.WANMutationResult); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *backend/graph/model.WANMutationResult`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.WANMutationResult)
	fc.Result = res
	return ec.marshalNWANMutationResult2backendgraphmodelWANMutationResult(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_configureDhcpWAN(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "success":
				return ec.fieldContext_WANMutationResult_success(ctx, field)
			case "wanInterface":
				return ec.fieldContext_WANMutationResult_wanInterface(ctx, field)
			case "preview":
				return ec.fieldContext_WANMutationResult_preview(ctx, field)
			case "errors":
				return ec.fieldContext_WANMutationResult_errors(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type WANMutationResult", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_configureDhcpWAN_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_configurePppoeWAN(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_configurePppoeWAN(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().ConfigurePppoeWan(rctx, fc.Args["routerId"].(string), fc.Args["input"].(model.PppoeClientInput))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			requires, err := ec.unmarshalNString2string(ctx, []interface{}{"interface"})
			if err != nil {
				return nil, err
			}
			if ec.directives.Capability == nil {
				return nil, errors.New("directive capability is not implemented")
			}
			return ec.directives.Capability(ctx, nil, directive0, requires)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.WANMutationResult); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *backend/graph/model.WANMutationResult`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.WANMutationResult)
	fc.Result = res
	return ec.marshalNWANMutationResult2backendgraphmodelWANMutationResult(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_configurePppoeWAN(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "success":
				return ec.fieldContext_WANMutationResult_success(ctx, field)
			case "wanInterface":
				return ec.fieldContext_WANMutationResult_wanInterface(ctx, field)
			case "preview":
				return ec.fieldContext_WANMutationResult_preview(ctx, field)
			case "errors":
				return ec.fieldContext_WANMutationResult_errors(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type WANMutationResult", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_configurePppoeWAN_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_configureStaticWAN(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_configureStaticWAN(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().ConfigureStaticWan(rctx, fc.Args["routerId"].(string), fc.Args["input"].(model.StaticIPInput))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			requires, err := ec.unmarshalNString2string(ctx, []interface{}{"interface"})
			if err != nil {
				return nil, err
			}
			if ec.directives.Capability == nil {
				return nil, errors.New("directive capability is not implemented")
			}
			return ec.directives.Capability(ctx, nil, directive0, requires)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.WANMutationResult); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *backend/graph/model.WANMutationResult`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.WANMutationResult)
	fc.Result = res
	return ec.marshalNWANMutationResult2backendgraphmodelWANMutationResult(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_configureStaticWAN(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "success":
				return ec.fieldContext_WANMutationResult_success(ctx, field)
			case "wanInterface":
				return ec.fieldContext_WANMutationResult_wanInterface(ctx, field)
			case "preview":
				return ec.fieldContext_WANMutationResult_preview(ctx, field)
			case "errors":
				return ec.fieldContext_WANMutationResult_errors(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type WANMutationResult", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_configureStaticWAN_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_configureLteWAN(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_configureLteWAN(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().ConfigureLteWan(rctx, fc.Args["routerId"].(string), fc.Args["input"].(model.LteModemInput))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			requires, err := ec.unmarshalNString2string(ctx, []interface{}{"interface"})
			if err != nil {
				return nil, err
			}
			if ec.directives.Capability == nil {
				return nil, errors.New("directive capability is not implemented")
			}
			return ec.directives.Capability(ctx, nil, directive0, requires)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.WANMutationResult); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *backend/graph/model.WANMutationResult`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.WANMutationResult)
	fc.Result = res
	return ec.marshalNWANMutationResult2backendgraphmodelWANMutationResult(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_configureLteWAN(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "success":
				return ec.fieldContext_WANMutationResult_success(ctx, field)
			case "wanInterface":
				return ec.fieldContext_WANMutationResult_wanInterface(ctx, field)
			case "preview":
				return ec.fieldContext_WANMutationResult_preview(ctx, field)
			case "errors":
				return ec.fieldContext_WANMutationResult_errors(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type WANMutationResult", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_configureLteWAN_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_configureWANHealthCheck(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_configureWANHealthCheck(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().ConfigureWANHealthCheck(rctx, fc.Args["routerId"].(string), fc.Args["wanInterfaceId"].(string), fc.Args["input"].(model.WANHealthCheckInput))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			requires, err := ec.unmarshalNString2string(ctx, []interface{}{"interface"})
			if err != nil {
				return nil, err
			}
			if ec.directives.Capability == nil {
				return nil, errors.New("directive capability is not implemented")
			}
			return ec.directives.Capability(ctx, nil, directive0, requires)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.WANMutationResult); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *backend/graph/model.WANMutationResult`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.WANMutationResult)
	fc.Result = res
	return ec.marshalNWANMutationResult2backendgraphmodelWANMutationResult(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_configureWANHealthCheck(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "success":
				return ec.fieldContext_WANMutationResult_success(ctx, field)
			case "wanInterface":
				return ec.fieldContext_WANMutationResult_wanInterface(ctx, field)
			case "preview":
				return ec.fieldContext_WANMutationResult_preview(ctx, field)
			case "errors":
				return ec.fieldContext_WANMutationResult_errors(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type WANMutationResult", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_configureWANHealthCheck_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_deleteWANConfiguration(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_deleteWANConfiguration(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().DeleteWANConfiguration(rctx, fc.Args["routerId"].(string), fc.Args["wanInterfaceId"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			requires, err := ec.unmarshalNString2string(ctx, []interface{}{"interface"})
			if err != nil {
				return nil, err
			}
			if ec.directives.Capability == nil {
				return nil, errors.New("directive capability is not implemented")
			}
			return ec.directives.Capability(ctx, nil, directive0, requires)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.DeleteResult); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *backend/graph/model.DeleteResult`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.DeleteResult)
	fc.Result = res
	return ec.marshalNDeleteResult2backendgraphmodelDeleteResult(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_deleteWANConfiguration(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "success":
				return ec.fieldContext_DeleteResult_success(ctx, field)
			case "message":
				return ec.fieldContext_DeleteResult_message(ctx, field)
			case "errors":
				return ec.fieldContext_DeleteResult_errors(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DeleteResult", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deleteWANConfiguration_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _MutationError_code(ctx context.Context, field graphql.CollectedField, obj *model.MutationError) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MutationError_code(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Code, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MutationError_code(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MutationError",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MutationError_message(ctx context.Context, field graphql.CollectedField, obj *model.MutationError) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MutationError_message(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MutationError_message(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MutationError",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MutationError_field(ctx context.Context, field graphql.CollectedField, obj *model.MutationError) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MutationError_field(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Field, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MutationError_field(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MutationError",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _NatRule_id(ctx context.Context, field graphql.CollectedField, obj *model.NatRule) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_NatRule_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_NatRule_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "NatRule",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _NatRule_chain(ctx context.Context, field graphql.CollectedField, obj *model.NatRule) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_NatRule_chain(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Chain, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_NatRule_chain(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "NatRule",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _NatRule_action(ctx context.Context, field graphql.CollectedField, obj *model.NatRule) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_NatRule_action(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Action, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_NatRule_action(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "NatRule",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _NatRule_srcAddress(ctx context.Context, field graphql.CollectedField, obj *model.NatRule) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_NatRule_srcAddress(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SrcAddress, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_NatRule_srcAddress(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "NatRule",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _NatRule_dstAddress(ctx context.Context, field graphql.CollectedField, obj *model.NatRule) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_NatRule_dstAddress(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DstAddress, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_NatRule_dstAddress(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "NatRule",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _NatRule_toAddress(ctx context.Context, field graphql.CollectedField, obj *model.NatRule) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_NatRule_toAddress(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ToAddress, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_NatRule_toAddress(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "NatRule",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _NatRule_disabled(ctx context.Context, field graphql.CollectedField, obj *model.NatRule) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_NatRule_disabled(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Disabled, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_NatRule_disabled(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "NatRule",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _NetworkConfigDetection_wanInterface(ctx context.Context, field graphql.CollectedField, obj *model.NetworkConfigDetection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_NetworkConfigDetection_wanInterface(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.WanInterface, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_NetworkConfigDetection_wanInterface(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "NetworkConfigDetection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _NetworkConfigDetection_gateway(ctx context.Context, field graphql.CollectedField, obj *model.NetworkConfigDetection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_NetworkConfigDetection_gateway(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Gateway, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_NetworkConfigDetection_gateway(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "NetworkConfigDetection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _NetworkConfigDetection_ispInfo(ctx context.Context, field graphql.CollectedField, obj *model.NetworkConfigDetection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_NetworkConfigDetection_ispInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IspInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.ISPInfo)
	fc.Result = res
	return ec.marshalOISPInfo2backendgraphmodelISPInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_NetworkConfigDetection_ispInfo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "NetworkConfigDetection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_ISPInfo_name(ctx, field)
			case "phone":
				return ec.fieldContext_ISPInfo_phone(ctx, field)
			case "url":
				return ec.fieldContext_ISPInfo_url(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ISPInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _OperationCounts_create(ctx context.Context, field graphql.CollectedField, obj *model.OperationCounts) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OperationCounts_create(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Create, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OperationCounts_create(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OperationCounts",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OperationCounts_update(ctx context.Context, field graphql.CollectedField, obj *model.OperationCounts) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OperationCounts_update(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Update, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OperationCounts_update(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OperationCounts",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OperationCounts_delete(ctx context.Context, field graphql.CollectedField, obj *model.OperationCounts) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OperationCounts_delete(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Delete, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OperationCounts_delete(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OperationCounts",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PageInfo_hasNextPage(ctx context.Context, field graphql.CollectedField, obj *model.PageInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PageInfo_hasNextPage(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HasNextPage, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PageInfo_hasNextPage(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PageInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PageInfo_hasPreviousPage(ctx context.Context, field graphql.CollectedField, obj *model.PageInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PageInfo_hasPreviousPage(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HasPreviousPage, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PageInfo_hasPreviousPage(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PageInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PageInfo_startCursor(ctx context.Context, field graphql.CollectedField, obj *model.PageInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PageInfo_startCursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StartCursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PageInfo_startCursor(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PageInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PageInfo_endCursor(ctx context.Context, field graphql.CollectedField, obj *model.PageInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PageInfo_endCursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EndCursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PageInfo_endCursor(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PageInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PlatformCapabilities_isSupported(ctx context.Context, field graphql.CollectedField, obj *model.PlatformCapabilities) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PlatformCapabilities_isSupported(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsSupported, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PlatformCapabilities_isSupported(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PlatformCapabilities",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PlatformCapabilities_level(ctx context.Context, field graphql.CollectedField, obj *model.PlatformCapabilities) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PlatformCapabilities_level(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Level, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.CapabilityLevel)
	fc.Result = res
	return ec.marshalNCapabilityLevel2backendgraphmodelCapabilityLevel(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PlatformCapabilities_level(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PlatformCapabilities",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type CapabilityLevel does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PlatformCapabilities_minVersion(ctx context.Context, field graphql.CollectedField, obj *model.PlatformCapabilities) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PlatformCapabilities_minVersion(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MinVersion, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PlatformCapabilities_minVersion(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PlatformCapabilities",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PlatformCapabilities_requiredPackages(ctx context.Context, field graphql.CollectedField, obj *model.PlatformCapabilities) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PlatformCapabilities_requiredPackages(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RequiredPackages, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PlatformCapabilities_requiredPackages(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PlatformCapabilities",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PlatformCapabilities_details(ctx context.Context, field graphql.CollectedField, obj *model.PlatformCapabilities) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PlatformCapabilities_details(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Details, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOJSON2map(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PlatformCapabilities_details(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PlatformCapabilities",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type JSON does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PlatformFeature_id(ctx context.Context, field graphql.CollectedField, obj *model.PlatformFeature) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PlatformFeature_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PlatformFeature_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PlatformFeature",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PlatformFeature_name(ctx context.Context, field graphql.CollectedField, obj *model.PlatformFeature) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PlatformFeature_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PlatformFeature_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PlatformFeature",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PlatformFeature_enabled(ctx context.Context, field graphql.CollectedField, obj *model.PlatformFeature) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PlatformFeature_enabled(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Enabled, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PlatformFeature_enabled(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PlatformFeature",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PlatformFeature_description(ctx context.Context, field graphql.CollectedField, obj *model.PlatformFeature) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PlatformFeature_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PlatformFeature_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PlatformFeature",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PlatformInfo_current(ctx context.Context, field graphql.CollectedField, obj *model.PlatformInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PlatformInfo_current(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Current, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.RouterPlatform)
	fc.Result = res
	return ec.marshalNRouterPlatform2backendgraphmodelRouterPlatform(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PlatformInfo_current(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PlatformInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type RouterPlatform does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PlatformInfo_capabilities(ctx context.Context, field graphql.CollectedField, obj *model.PlatformInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PlatformInfo_capabilities(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Capabilities, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.PlatformCapabilities)
	fc.Result = res
	return ec.marshalNPlatformCapabilities2backendgraphmodelPlatformCapabilities(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PlatformInfo_capabilities(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PlatformInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "isSupported":
				return ec.fieldContext_PlatformCapabilities_isSupported(ctx, field)
			case "level":
				return ec.fieldContext_PlatformCapabilities_level(ctx, field)
			case "minVersion":
				return ec.fieldContext_PlatformCapabilities_minVersion(ctx, field)
			case "requiredPackages":
				return ec.fieldContext_PlatformCapabilities_requiredPackages(ctx, field)
			case "details":
				return ec.fieldContext_PlatformCapabilities_details(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PlatformCapabilities", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _PlatformInfo_fieldMappings(ctx context.Context, field graphql.CollectedField, obj *model.PlatformInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PlatformInfo_fieldMappings(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FieldMappings, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOJSON2map(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PlatformInfo_fieldMappings(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PlatformInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type JSON does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PlatformInfo_limitations(ctx context.Context, field graphql.CollectedField, obj *model.PlatformInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PlatformInfo_limitations(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Limitations, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.PlatformLimitation)
	fc.Result = res
	return ec.marshalOPlatformLimitation2backendgraphmodelPlatformLimitation(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PlatformInfo_limitations(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PlatformInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "code":
				return ec.fieldContext_PlatformLimitation_code(ctx, field)
			case "description":
				return ec.fieldContext_PlatformLimitation_description(ctx, field)
			case "affectedFields":
				return ec.fieldContext_PlatformLimitation_affectedFields(ctx, field)
			case "workaround":
				return ec.fieldContext_PlatformLimitation_workaround(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PlatformLimitation", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _PlatformInfo_features(ctx context.Context, field graphql.CollectedField, obj *model.PlatformInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PlatformInfo_features(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Features, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.PlatformFeature)
	fc.Result = res
	return ec.marshalOPlatformFeature2backendgraphmodelPlatformFeature(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PlatformInfo_features(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PlatformInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_PlatformFeature_id(ctx, field)
			case "name":
				return ec.fieldContext_PlatformFeature_name(ctx, field)
			case "enabled":
				return ec.fieldContext_PlatformFeature_enabled(ctx, field)
			case "description":
				return ec.fieldContext_PlatformFeature_description(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PlatformFeature", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _PlatformLimitation_code(ctx context.Context, field graphql.CollectedField, obj *model.PlatformLimitation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PlatformLimitation_code(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Code, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PlatformLimitation_code(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PlatformLimitation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PlatformLimitation_description(ctx context.Context, field graphql.CollectedField, obj *model.PlatformLimitation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PlatformLimitation_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PlatformLimitation_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PlatformLimitation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PlatformLimitation_affectedFields(ctx context.Context, field graphql.CollectedField, obj *model.PlatformLimitation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PlatformLimitation_affectedFields(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AffectedFields, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PlatformLimitation_affectedFields(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PlatformLimitation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PlatformLimitation_workaround(ctx context.Context, field graphql.CollectedField, obj *model.PlatformLimitation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PlatformLimitation_workaround(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Workaround, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PlatformLimitation_workaround(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PlatformLimitation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PortStatus_port(ctx context.Context, field graphql.CollectedField, obj *model.PortStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PortStatus_port(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Port, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PortStatus_port(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PortStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PortStatus_service(ctx context.Context, field graphql.CollectedField, obj *model.PortStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PortStatus_service(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Service, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PortStatus_service(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PortStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PortStatus_open(ctx context.Context, field graphql.CollectedField, obj *model.PortStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PortStatus_open(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Open, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PortStatus_open(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PortStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PortStatus_responseTimeMs(ctx context.Context, field graphql.CollectedField, obj *model.PortStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PortStatus_responseTimeMs(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ResponseTimeMs, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PortStatus_responseTimeMs(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PortStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PortStatus_error(ctx context.Context, field graphql.CollectedField, obj *model.PortStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PortStatus_error(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Error, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PortStatus_error(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PortStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PppoeClient_id(ctx context.Context, field graphql.CollectedField, obj *model.PppoeClient) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PppoeClient_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PppoeClient_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PppoeClient",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PppoeClient_name(ctx context.Context, field graphql.CollectedField, obj *model.PppoeClient) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PppoeClient_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PppoeClient_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PppoeClient",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PppoeClient_interface(ctx context.Context, field graphql.CollectedField, obj *model.PppoeClient) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PppoeClient_interface(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Interface, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PppoeClient_interface(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PppoeClient",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PppoeClient_disabled(ctx context.Context, field graphql.CollectedField, obj *model.PppoeClient) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PppoeClient_disabled(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Disabled, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PppoeClient_disabled(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PppoeClient",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PppoeClient_username(ctx context.Context, field graphql.CollectedField, obj *model.PppoeClient) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PppoeClient_username(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Username, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PppoeClient_username(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PppoeClient",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PppoeClient_serviceName(ctx context.Context, field graphql.CollectedField, obj *model.PppoeClient) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PppoeClient_serviceName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ServiceName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PppoeClient_serviceName(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PppoeClient",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PppoeClient_addDefaultRoute(ctx context.Context, field graphql.CollectedField, obj *model.PppoeClient) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PppoeClient_addDefaultRoute(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AddDefaultRoute, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PppoeClient_addDefaultRoute(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PppoeClient",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PppoeClient_usePeerDNS(ctx context.Context, field graphql.CollectedField, obj *model.PppoeClient) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PppoeClient_usePeerDNS(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UsePeerDNS, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PppoeClient_usePeerDNS(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PppoeClient",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PppoeClient_running(ctx context.Context, field graphql.CollectedField, obj *model.PppoeClient) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PppoeClient_running(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Running, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PppoeClient_running(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PppoeClient",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PppoeClient_mtu(ctx context.Context, field graphql.CollectedField, obj *model.PppoeClient) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PppoeClient_mtu(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Mtu, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PppoeClient_mtu(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PppoeClient",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PppoeClient_mru(ctx context.Context, field graphql.CollectedField, obj *model.PppoeClient) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PppoeClient_mru(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Mru, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PppoeClient_mru(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PppoeClient",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PppoeClient_comment(ctx context.Context, field graphql.CollectedField, obj *model.PppoeClient) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PppoeClient_comment(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Comment, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PppoeClient_comment(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PppoeClient",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_node(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_node(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Node(rctx, fc.Args["id"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(model.Node)
	fc.Result = res
	return ec.marshalONode2backendgraphmodelNode(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_node(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("FieldContext.Child cannot be called on type INTERFACE")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_node_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_health(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_health(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Health(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.HealthStatus)
	fc.Result = res
	return ec.marshalNHealthStatus2backendgraphmodelHealthStatus(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_health(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "status":
				return ec.fieldContext_HealthStatus_status(ctx, field)
			case "version":
				return ec.fieldContext_HealthStatus_version(ctx, field)
			case "uptime":
				return ec.fieldContext_HealthStatus_uptime(ctx, field)
			case "connectedRouters":
				return ec.fieldContext_HealthStatus_connectedRouters(ctx, field)
			case "checkedAt":
				return ec.fieldContext_HealthStatus_checkedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type HealthStatus", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_version(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_version(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Version(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_version(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_device(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_device(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Device(rctx, fc.Args["id"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Device)
	fc.Result = res
	return ec.marshalODevice2backendgraphmodelDevice(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_device(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Device_id(ctx, field)
			case "resourceMetrics":
				return ec.fieldContext_Device_resourceMetrics(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Device", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_device_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_router(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_router(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Router(rctx, fc.Args["id"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Router)
	fc.Result = res
	return ec.marshalORouter2backendgraphmodelRouter(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_router(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Router_id(ctx, field)
			case "name":
				return ec.fieldContext_Router_name(ctx, field)
			case "host":
				return ec.fieldContext_Router_host(ctx, field)
			case "port":
				return ec.fieldContext_Router_port(ctx, field)
			case "status":
				return ec.fieldContext_Router_status(ctx, field)
			case "platform":
				return ec.fieldContext_Router_platform(ctx, field)
			case "version":
				return ec.fieldContext_Router_version(ctx, field)
			case "model":
				return ec.fieldContext_Router_model(ctx, field)
			case "uptime":
				return ec.fieldContext_Router_uptime(ctx, field)
			case "lastConnected":
				return ec.fieldContext_Router_lastConnected(ctx, field)
			case "createdAt":
				return ec.fieldContext_Router_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Router_updatedAt(ctx, field)
			case "capabilities":
				return ec.fieldContext_Router_capabilities(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Router", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_router_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_routers(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_routers(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Routers(rctx, fc.Args["status"].(*model.ConnectionStatus), fc.Args["pagination"].(*model.PaginationInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.RouterConnection)
	fc.Result = res
	return ec.marshalNRouterConnection2backendgraphmodelRouterConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_routers(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "edges":
				return ec.fieldContext_RouterConnection_edges(ctx, field)
			case "pageInfo":
				return ec.fieldContext_RouterConnection_pageInfo(ctx, field)
			case "totalCount":
				return ec.fieldContext_RouterConnection_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RouterConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_routers_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_interface(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_interface(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().Interface(rctx, fc.Args["routerId"].(string), fc.Args["id"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			requires, err := ec.unmarshalNString2string(ctx, []interface{}{"interface"})
			if err != nil {
				return nil, err
			}
			if ec.directives.Capability == nil {
				return nil, errors.New("directive capability is not implemented")
			}
			return ec.directives.Capability(ctx, nil, directive0, requires)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.Interface); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *backend/graph/model.Interface`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Interface)
	fc.Result = res
	return ec.marshalOInterface2backendgraphmodelInterface(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_interface(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Interface_id(ctx, field)
			case "name":
				return ec.fieldContext_Interface_name(ctx, field)
			case "type":
				return ec.fieldContext_Interface_type(ctx, field)
			case "enabled":
				return ec.fieldContext_Interface_enabled(ctx, field)
			case "running":
				return ec.fieldContext_Interface_running(ctx, field)
			case "macAddress":
				return ec.fieldContext_Interface_macAddress(ctx, field)
			case "mtu":
				return ec.fieldContext_Interface_mtu(ctx, field)
			case "comment":
				return ec.fieldContext_Interface_comment(ctx, field)
			case "txBytes":
				return ec.fieldContext_Interface_txBytes(ctx, field)
			case "rxBytes":
				return ec.fieldContext_Interface_rxBytes(ctx, field)
			case "ip":
				return ec.fieldContext_Interface_ip(ctx, field)
			case "status":
				return ec.fieldContext_Interface_status(ctx, field)
			case "txRate":
				return ec.fieldContext_Interface_txRate(ctx, field)
			case "rxRate":
				return ec.fieldContext_Interface_rxRate(ctx, field)
			case "linkSpeed":
				return ec.fieldContext_Interface_linkSpeed(ctx, field)
			case "lastSeen":
				return ec.fieldContext_Interface_lastSeen(ctx, field)
			case "linkPartner":
				return ec.fieldContext_Interface_linkPartner(ctx, field)
			case "usedBy":
				return ec.fieldContext_Interface_usedBy(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Interface", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_interface_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_interfaces(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_interfaces(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().Interfaces(rctx, fc.Args["routerId"].(string), fc.Args["type"].(*model.InterfaceType), fc.Args["pagination"].(*model.PaginationInput))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			requires, err := ec.unmarshalNString2string(ctx, []interface{}{"interface"})
			if err != nil {
				return nil, err
			}
			if ec.directives.Capability == nil {
				return nil, errors.New("directive capability is not implemented")
			}
			return ec.directives.Capability(ctx, nil, directive0, requires)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.InterfaceConnection); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *backend/graph/model.InterfaceConnection`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.InterfaceConnection)
	fc.Result = res
	return ec.marshalNInterfaceConnection2backendgraphmodelInterfaceConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_interfaces(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "edges":
				return ec.fieldContext_InterfaceConnection_edges(ctx, field)
			case "pageInfo":
				return ec.fieldContext_InterfaceConnection_pageInfo(ctx, field)
			case "totalCount":
				return ec.fieldContext_InterfaceConnection_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type InterfaceConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_interfaces_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_routerCapabilities(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_routerCapabilities(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().RouterCapabilities(rctx, fc.Args["routerId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.RouterCapabilities)
	fc.Result = res
	return ec.marshalORouterCapabilities2backendgraphmodelRouterCapabilities(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_routerCapabilities(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hardware":
				return ec.fieldContext_RouterCapabilities_hardware(ctx, field)
			case "software":
				return ec.fieldContext_RouterCapabilities_software(ctx, field)
			case "container":
				return ec.fieldContext_RouterCapabilities_container(ctx, field)
			case "capabilities":
				return ec.fieldContext_RouterCapabilities_capabilities(ctx, field)
			case "vifRequirements":
				return ec.fieldContext_RouterCapabilities_vifRequirements(ctx, field)
			case "supportedFeatures":
				return ec.fieldContext_RouterCapabilities_supportedFeatures(ctx, field)
			case "unsupportedFeatures":
				return ec.fieldContext_RouterCapabilities_unsupportedFeatures(ctx, field)
			case "routerOSVersion":
				return ec.fieldContext_RouterCapabilities_routerOSVersion(ctx, field)
			case "detectedAt":
				return ec.fieldContext_RouterCapabilities_detectedAt(ctx, field)
			case "expiresAt":
				return ec.fieldContext_RouterCapabilities_expiresAt(ctx, field)
			case "isRefreshing":
				return ec.fieldContext_RouterCapabilities_isRefreshing(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RouterCapabilities", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_routerCapabilities_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_isFeatureSupported(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_isFeatureSupported(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().IsFeatureSupported(rctx, fc.Args["routerId"].(string), fc.Args["featureId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.FeatureSupport)
	fc.Result = res
	return ec.marshalNFeatureSupport2backendgraphmodelFeatureSupport(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_isFeatureSupported(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "featureId":
				return ec.fieldContext_FeatureSupport_featureId(ctx, field)
			case "name":
				return ec.fieldContext_FeatureSupport_name(ctx, field)
			case "supported":
				return ec.fieldContext_FeatureSupport_supported(ctx, field)
			case "level":
				return ec.fieldContext_FeatureSupport_level(ctx, field)
			case "reason":
				return ec.fieldContext_FeatureSupport_reason(ctx, field)
			case "requiredVersion":
				return ec.fieldContext_FeatureSupport_requiredVersion(ctx, field)
			case "upgradeUrl":
				return ec.fieldContext_FeatureSupport_upgradeUrl(ctx, field)
			case "requiredPackages":
				return ec.fieldContext_FeatureSupport_requiredPackages(ctx, field)
			case "missingPackages":
				return ec.fieldContext_FeatureSupport_missingPackages(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FeatureSupport", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_isFeatureSupported_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_supportedFeatures(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_supportedFeatures(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().SupportedFeatures(rctx, fc.Args["routerId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.FeatureSupport)
	fc.Result = res
	return ec.marshalNFeatureSupport2backendgraphmodelFeatureSupport(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_supportedFeatures(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "featureId":
				return ec.fieldContext_FeatureSupport_featureId(ctx, field)
			case "name":
				return ec.fieldContext_FeatureSupport_name(ctx, field)
			case "supported":
				return ec.fieldContext_FeatureSupport_supported(ctx, field)
			case "level":
				return ec.fieldContext_FeatureSupport_level(ctx, field)
			case "reason":
				return ec.fieldContext_FeatureSupport_reason(ctx, field)
			case "requiredVersion":
				return ec.fieldContext_FeatureSupport_requiredVersion(ctx, field)
			case "upgradeUrl":
				return ec.fieldContext_FeatureSupport_upgradeUrl(ctx, field)
			case "requiredPackages":
				return ec.fieldContext_FeatureSupport_requiredPackages(ctx, field)
			case "missingPackages":
				return ec.fieldContext_FeatureSupport_missingPackages(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FeatureSupport", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_supportedFeatures_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_unsupportedFeatures(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_unsupportedFeatures(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().UnsupportedFeatures(rctx, fc.Args["routerId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.FeatureSupport)
	fc.Result = res
	return ec.marshalNFeatureSupport2backendgraphmodelFeatureSupport(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_unsupportedFeatures(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "featureId":
				return ec.fieldContext_FeatureSupport_featureId(ctx, field)
			case "name":
				return ec.fieldContext_FeatureSupport_name(ctx, field)
			case "supported":
				return ec.fieldContext_FeatureSupport_supported(ctx, field)
			case "level":
				return ec.fieldContext_FeatureSupport_level(ctx, field)
			case "reason":
				return ec.fieldContext_FeatureSupport_reason(ctx, field)
			case "requiredVersion":
				return ec.fieldContext_FeatureSupport_requiredVersion(ctx, field)
			case "upgradeUrl":
				return ec.fieldContext_FeatureSupport_upgradeUrl(ctx, field)
			case "requiredPackages":
				return ec.fieldContext_FeatureSupport_requiredPackages(ctx, field)
			case "missingPackages":
				return ec.fieldContext_FeatureSupport_missingPackages(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FeatureSupport", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_unsupportedFeatures_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_compatibilityMatrix(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_compatibilityMatrix(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().CompatibilityMatrix(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.FeatureCompatibilityInfo)
	fc.Result = res
	return ec.marshalNFeatureCompatibilityInfo2backendgraphmodelFeatureCompatibilityInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_compatibilityMatrix(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "featureId":
				return ec.fieldContext_FeatureCompatibilityInfo_featureId(ctx, field)
			case "name":
				return ec.fieldContext_FeatureCompatibilityInfo_name(ctx, field)
			case "minVersion":
				return ec.fieldContext_FeatureCompatibilityInfo_minVersion(ctx, field)
			case "maxVersion":
				return ec.fieldContext_FeatureCompatibilityInfo_maxVersion(ctx, field)
			case "minVersionCHR":
				return ec.fieldContext_FeatureCompatibilityInfo_minVersionCHR(ctx, field)
			case "requiredPackages":
				return ec.fieldContext_FeatureCompatibilityInfo_requiredPackages(ctx, field)
			case "dependsOn":
				return ec.fieldContext_FeatureCompatibilityInfo_dependsOn(ctx, field)
			case "upgradeUrl":
				return ec.fieldContext_FeatureCompatibilityInfo_upgradeUrl(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FeatureCompatibilityInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_upgradeRecommendation(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_upgradeRecommendation(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().UpgradeRecommendation(rctx, fc.Args["routerId"].(string), fc.Args["featureId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.UpgradeRecommendation)
	fc.Result = res
	return ec.marshalOUpgradeRecommendation2backendgraphmodelUpgradeRecommendation(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_upgradeRecommendation(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "featureId":
				return ec.fieldContext_UpgradeRecommendation_featureId(ctx, field)
			case "featureName":
				return ec.fieldContext_UpgradeRecommendation_featureName(ctx, field)
			case "currentVersion":
				return ec.fieldContext_UpgradeRecommendation_currentVersion(ctx, field)
			case "requiredVersion":
				return ec.fieldContext_UpgradeRecommendation_requiredVersion(ctx, field)
			case "isMajorUpgrade":
				return ec.fieldContext_UpgradeRecommendation_isMajorUpgrade(ctx, field)
			case "priority":
				return ec.fieldContext_UpgradeRecommendation_priority(ctx, field)
			case "steps":
				return ec.fieldContext_UpgradeRecommendation_steps(ctx, field)
			case "impact":
				return ec.fieldContext_UpgradeRecommendation_impact(ctx, field)
			case "documentationUrl":
				return ec.fieldContext_UpgradeRecommendation_documentationUrl(ctx, field)
			case "warnings":
				return ec.fieldContext_UpgradeRecommendation_warnings(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UpgradeRecommendation", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_upgradeRecommendation_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_upgradeRecommendations(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_upgradeRecommendations(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().UpgradeRecommendations(rctx, fc.Args["routerId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.UpgradeRecommendation)
	fc.Result = res
	return ec.marshalNUpgradeRecommendation2backendgraphmodelUpgradeRecommendation(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_upgradeRecommendations(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "featureId":
				return ec.fieldContext_UpgradeRecommendation_featureId(ctx, field)
			case "featureName":
				return ec.fieldContext_UpgradeRecommendation_featureName(ctx, field)
			case "currentVersion":
				return ec.fieldContext_UpgradeRecommendation_currentVersion(ctx, field)
			case "requiredVersion":
				return ec.fieldContext_UpgradeRecommendation_requiredVersion(ctx, field)
			case "isMajorUpgrade":
				return ec.fieldContext_UpgradeRecommendation_isMajorUpgrade(ctx, field)
			case "priority":
				return ec.fieldContext_UpgradeRecommendation_priority(ctx, field)
			case "steps":
				return ec.fieldContext_UpgradeRecommendation_steps(ctx, field)
			case "impact":
				return ec.fieldContext_UpgradeRecommendation_impact(ctx, field)
			case "documentationUrl":
				return ec.fieldContext_UpgradeRecommendation_documentationUrl(ctx, field)
			case "warnings":
				return ec.fieldContext_UpgradeRecommendation_warnings(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UpgradeRecommendation", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_upgradeRecommendations_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_me(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_me(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().Me(rctx)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Auth == nil {
				return nil, errors.New("directive auth is not implemented")
			}
			return ec.directives.Auth(ctx, nil, directive0, nil)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.User); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *backend/graph/model.User`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.User)
	fc.Result = res
	return ec.marshalOUser2backendgraphmodelUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_me(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "username":
				return ec.fieldContext_User_username(ctx, field)
			case "role":
				return ec.fieldContext_User_role(ctx, field)
			case "email":
				return ec.fieldContext_User_email(ctx, field)
			case "displayName":
				return ec.fieldContext_User_displayName(ctx, field)
			case "createdAt":
				return ec.fieldContext_User_createdAt(ctx, field)
			case "lastLoginAt":
				return ec.fieldContext_User_lastLoginAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_mySessions(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_mySessions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().MySessions(rctx)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Auth == nil {
				return nil, errors.New("directive auth is not implemented")
			}
			return ec.directives.Auth(ctx, nil, directive0, nil)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*model.Session); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*backend/graph/model.Session`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.Session)
	fc.Result = res
	return ec.marshalNSession2backendgraphmodelSession(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_mySessions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Session_id(ctx, field)
			case "ipAddress":
				return ec.fieldContext_Session_ipAddress(ctx, field)
			case "userAgent":
				return ec.fieldContext_Session_userAgent(ctx, field)
			case "createdAt":
				return ec.fieldContext_Session_createdAt(ctx, field)
			case "lastActivity":
				return ec.fieldContext_Session_lastActivity(ctx, field)
			case "isCurrent":
				return ec.fieldContext_Session_isCurrent(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Session", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_connectionDetails(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_connectionDetails(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().ConnectionDetails(rctx, fc.Args["routerId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.ConnectionDetails)
	fc.Result = res
	return ec.marshalOConnectionDetails2backendgraphmodelConnectionDetails(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_connectionDetails(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "state":
				return ec.fieldContext_ConnectionDetails_state(ctx, field)
			case "protocol":
				return ec.fieldContext_ConnectionDetails_protocol(ctx, field)
			case "preferredProtocol":
				return ec.fieldContext_ConnectionDetails_preferredProtocol(ctx, field)
			case "connectedAt":
				return ec.fieldContext_ConnectionDetails_connectedAt(ctx, field)
			case "uptime":
				return ec.fieldContext_ConnectionDetails_uptime(ctx, field)
			case "disconnectedAt":
				return ec.fieldContext_ConnectionDetails_disconnectedAt(ctx, field)
			case "lastError":
				return ec.fieldContext_ConnectionDetails_lastError(ctx, field)
			case "lastErrorTime":
				return ec.fieldContext_ConnectionDetails_lastErrorTime(ctx, field)
			case "disconnectReason":
				return ec.fieldContext_ConnectionDetails_disconnectReason(ctx, field)
			case "reconnectAttempts":
				return ec.fieldContext_ConnectionDetails_reconnectAttempts(ctx, field)
			case "nextReconnectAt":
				return ec.fieldContext_ConnectionDetails_nextReconnectAt(ctx, field)
			case "circuitBreakerState":
				return ec.fieldContext_ConnectionDetails_circuitBreakerState(ctx, field)
			case "version":
				return ec.fieldContext_ConnectionDetails_version(ctx, field)
			case "lastHealthCheck":
				return ec.fieldContext_ConnectionDetails_lastHealthCheck(ctx, field)
			case "healthChecksPassed":
				return ec.fieldContext_ConnectionDetails_healthChecksPassed(ctx, field)
			case "healthChecksFailed":
				return ec.fieldContext_ConnectionDetails_healthChecksFailed(ctx, field)
			case "securityWarning":
				return ec.fieldContext_ConnectionDetails_securityWarning(ctx, field)
			case "upgradeRecommendation":
				return ec.fieldContext_ConnectionDetails_upgradeRecommendation(ctx, field)
			case "isLegacyProtocol":
				return ec.fieldContext_ConnectionDetails_isLegacyProtocol(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ConnectionDetails", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_connectionDetails_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_routerHealth(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_routerHealth(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().RouterHealth(rctx, fc.Args["routerId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.HealthCheckResult)
	fc.Result = res
	return ec.marshalOHealthCheckResult2backendgraphmodelHealthCheckResult(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_routerHealth(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "routerId":
				return ec.fieldContext_HealthCheckResult_routerId(ctx, field)
			case "healthy":
				return ec.fieldContext_HealthCheckResult_healthy(ctx, field)
			case "checkedAt":
				return ec.fieldContext_HealthCheckResult_checkedAt(ctx, field)
			case "responseTimeMs":
				return ec.fieldContext_HealthCheckResult_responseTimeMs(ctx, field)
			case "error":
				return ec.fieldContext_HealthCheckResult_error(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type HealthCheckResult", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_routerHealth_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_connectionStats(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_connectionStats(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().ConnectionStats(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.ConnectionStats)
	fc.Result = res
	return ec.marshalNConnectionStats2backendgraphmodelConnectionStats(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_connectionStats(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "totalConnections":
				return ec.fieldContext_ConnectionStats_totalConnections(ctx, field)
			case "connected":
				return ec.fieldContext_ConnectionStats_connected(ctx, field)
			case "connecting":
				return ec.fieldContext_ConnectionStats_connecting(ctx, field)
			case "disconnected":
				return ec.fieldContext_ConnectionStats_disconnected(ctx, field)
			case "reconnecting":
				return ec.fieldContext_ConnectionStats_reconnecting(ctx, field)
			case "error":
				return ec.fieldContext_ConnectionStats_error(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ConnectionStats", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_routerCredentials(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_routerCredentials(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().RouterCredentials(rctx, fc.Args["routerId"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Auth == nil {
				return nil, errors.New("directive auth is not implemented")
			}
			return ec.directives.Auth(ctx, nil, directive0, nil)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.RouterCredentials); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *backend/graph/model.RouterCredentials`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.RouterCredentials)
	fc.Result = res
	return ec.marshalORouterCredentials2backendgraphmodelRouterCredentials(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_routerCredentials(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "routerId":
				return ec.fieldContext_RouterCredentials_routerId(ctx, field)
			case "username":
				return ec.fieldContext_RouterCredentials_username(ctx, field)
			case "hasPassword":
				return ec.fieldContext_RouterCredentials_hasPassword(ctx, field)
			case "encryptionStatus":
				return ec.fieldContext_RouterCredentials_encryptionStatus(ctx, field)
			case "keyVersion":
				return ec.fieldContext_RouterCredentials_keyVersion(ctx, field)
			case "lastUpdated":
				return ec.fieldContext_RouterCredentials_lastUpdated(ctx, field)
			case "createdAt":
				return ec.fieldContext_RouterCredentials_createdAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RouterCredentials", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_routerCredentials_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_scanStatus(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_scanStatus(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().ScanStatus(rctx, fc.Args["taskId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.ScanTask)
	fc.Result = res
	return ec.marshalOScanTask2backendgraphmodelScanTask(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_scanStatus(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ScanTask_id(ctx, field)
			case "subnet":
				return ec.fieldContext_ScanTask_subnet(ctx, field)
			case "status":
				return ec.fieldContext_ScanTask_status(ctx, field)
			case "progress":
				return ec.fieldContext_ScanTask_progress(ctx, field)
			case "results":
				return ec.fieldContext_ScanTask_results(ctx, field)
			case "startTime":
				return ec.fieldContext_ScanTask_startTime(ctx, field)
			case "endTime":
				return ec.fieldContext_ScanTask_endTime(ctx, field)
			case "error":
				return ec.fieldContext_ScanTask_error(ctx, field)
			case "totalIPs":
				return ec.fieldContext_ScanTask_totalIPs(ctx, field)
			case "scannedIPs":
				return ec.fieldContext_ScanTask_scannedIPs(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ScanTask", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_scanStatus_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_scanHistory(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_scanHistory(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().ScanHistory(rctx, fc.Args["limit"].(*int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.ScanTask)
	fc.Result = res
	return ec.marshalNScanTask2backendgraphmodelScanTask(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_scanHistory(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ScanTask_id(ctx, field)
			case "subnet":
				return ec.fieldContext_ScanTask_subnet(ctx, field)
			case "status":
				return ec.fieldContext_ScanTask_status(ctx, field)
			case "progress":
				return ec.fieldContext_ScanTask_progress(ctx, field)
			case "results":
				return ec.fieldContext_ScanTask_results(ctx, field)
			case "startTime":
				return ec.fieldContext_ScanTask_startTime(ctx, field)
			case "endTime":
				return ec.fieldContext_ScanTask_endTime(ctx, field)
			case "error":
				return ec.fieldContext_ScanTask_error(ctx, field)
			case "totalIPs":
				return ec.fieldContext_ScanTask_totalIPs(ctx, field)
			case "scannedIPs":
				return ec.fieldContext_ScanTask_scannedIPs(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ScanTask", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_scanHistory_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_changeSet(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_changeSet(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().ChangeSet(rctx, fc.Args["id"].(string), fc.Args["routerId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.ChangeSet)
	fc.Result = res
	return ec.marshalOChangeSet2backendgraphmodelChangeSet(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_changeSet(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ChangeSet_id(ctx, field)
			case "name":
				return ec.fieldContext_ChangeSet_name(ctx, field)
			case "description":
				return ec.fieldContext_ChangeSet_description(ctx, field)
			case "routerId":
				return ec.fieldContext_ChangeSet_routerId(ctx, field)
			case "items":
				return ec.fieldContext_ChangeSet_items(ctx, field)
			case "status":
				return ec.fieldContext_ChangeSet_status(ctx, field)
			case "validation":
				return ec.fieldContext_ChangeSet_validation(ctx, field)
			case "rollbackPlan":
				return ec.fieldContext_ChangeSet_rollbackPlan(ctx, field)
			case "error":
				return ec.fieldContext_ChangeSet_error(ctx, field)
			case "createdAt":
				return ec.fieldContext_ChangeSet_createdAt(ctx, field)
			case "applyStartedAt":
				return ec.fieldContext_ChangeSet_applyStartedAt(ctx, field)
			case "completedAt":
				return ec.fieldContext_ChangeSet_completedAt(ctx, field)
			case "createdBy":
				return ec.fieldContext_ChangeSet_createdBy(ctx, field)
			case "source":
				return ec.fieldContext_ChangeSet_source(ctx, field)
			case "version":
				return ec.fieldContext_ChangeSet_version(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ChangeSet", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_changeSet_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_changeSets(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_changeSets(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().ChangeSets(rctx, fc.Args["routerId"].(string), fc.Args["status"].(*model.ChangeSetStatus), fc.Args["includeCompleted"].(*bool))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.ChangeSetSummary)
	fc.Result = res
	return ec.marshalNChangeSetSummary2backendgraphmodelChangeSetSummary(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_changeSets(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ChangeSetSummary_id(ctx, field)
			case "name":
				return ec.fieldContext_ChangeSetSummary_name(ctx, field)
			case "status":
				return ec.fieldContext_ChangeSetSummary_status(ctx, field)
			case "operationCounts":
				return ec.fieldContext_ChangeSetSummary_operationCounts(ctx, field)
			case "totalItems":
				return ec.fieldContext_ChangeSetSummary_totalItems(ctx, field)
			case "createdAt":
				return ec.fieldContext_ChangeSetSummary_createdAt(ctx, field)
			case "hasErrors":
				return ec.fieldContext_ChangeSetSummary_hasErrors(ctx, field)
			case "hasWarnings":
				return ec.fieldContext_ChangeSetSummary_hasWarnings(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ChangeSetSummary", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_changeSets_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_connectionAttempts(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_connectionAttempts(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().ConnectionAttempts(rctx, fc.Args["routerId"].(string), fc.Args["limit"].(*int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.ConnectionAttempt)
	fc.Result = res
	return ec.marshalNConnectionAttempt2backendgraphmodelConnectionAttempt(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_connectionAttempts(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "protocol":
				return ec.fieldContext_ConnectionAttempt_protocol(ctx, field)
			case "startedAt":
				return ec.fieldContext_ConnectionAttempt_startedAt(ctx, field)
			case "endedAt":
				return ec.fieldContext_ConnectionAttempt_endedAt(ctx, field)
			case "success":
				return ec.fieldContext_ConnectionAttempt_success(ctx, field)
			case "errorCode":
				return ec.fieldContext_ConnectionAttempt_errorCode(ctx, field)
			case "errorMessage":
				return ec.fieldContext_ConnectionAttempt_errorMessage(ctx, field)
			case "errorCategory":
				return ec.fieldContext_ConnectionAttempt_errorCategory(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ConnectionAttempt", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_connectionAttempts_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_circuitBreakerStatus(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_circuitBreakerStatus(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().CircuitBreakerStatus(rctx, fc.Args["routerId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.CircuitBreakerStatus)
	fc.Result = res
	return ec.marshalNCircuitBreakerStatus2backendgraphmodelCircuitBreakerStatus(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_circuitBreakerStatus(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "routerId":
				return ec.fieldContext_CircuitBreakerStatus_routerId(ctx, field)
			case "state":
				return ec.fieldContext_CircuitBreakerStatus_state(ctx, field)
			case "failureCount":
				return ec.fieldContext_CircuitBreakerStatus_failureCount(ctx, field)
			case "failureThreshold":
				return ec.fieldContext_CircuitBreakerStatus_failureThreshold(ctx, field)
			case "cooldownRemainingSeconds":
				return ec.fieldContext_CircuitBreakerStatus_cooldownRemainingSeconds(ctx, field)
			case "lastFailureAt":
				return ec.fieldContext_CircuitBreakerStatus_lastFailureAt(ctx, field)
			case "lastSuccessAt":
				return ec.fieldContext_CircuitBreakerStatus_lastSuccessAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CircuitBreakerStatus", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_circuitBreakerStatus_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_troubleshootSession(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_troubleshootSession(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().TroubleshootSession(rctx, fc.Args["id"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.TroubleshootSession)
	fc.Result = res
	return ec.marshalOTroubleshootSession2backendgraphmodelTroubleshootSession(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_troubleshootSession(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_TroubleshootSession_id(ctx, field)
			case "routerId":
				return ec.fieldContext_TroubleshootSession_routerId(ctx, field)
			case "steps":
				return ec.fieldContext_TroubleshootSession_steps(ctx, field)
			case "currentStepIndex":
				return ec.fieldContext_TroubleshootSession_currentStepIndex(ctx, field)
			case "status":
				return ec.fieldContext_TroubleshootSession_status(ctx, field)
			case "wanInterface":
				return ec.fieldContext_TroubleshootSession_wanInterface(ctx, field)
			case "gateway":
				return ec.fieldContext_TroubleshootSession_gateway(ctx, field)
			case "ispInfo":
				return ec.fieldContext_TroubleshootSession_ispInfo(ctx, field)
			case "appliedFixes":
				return ec.fieldContext_TroubleshootSession_appliedFixes(ctx, field)
			case "startedAt":
				return ec.fieldContext_TroubleshootSession_startedAt(ctx, field)
			case "completedAt":
				return ec.fieldContext_TroubleshootSession_completedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TroubleshootSession", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_troubleshootSession_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_detectWanInterface(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_detectWanInterface(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().DetectWanInterface(rctx, fc.Args["routerId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_detectWanInterface(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_detectWanInterface_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_detectGateway(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_detectGateway(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().DetectGateway(rctx, fc.Args["routerId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_detectGateway(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_detectGateway_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_detectISP(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_detectISP(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().DetectIsp(rctx, fc.Args["routerId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.ISPInfo)
	fc.Result = res
	return ec.marshalOISPInfo2backendgraphmodelISPInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_detectISP(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_ISPInfo_name(ctx, field)
			case "phone":
				return ec.fieldContext_ISPInfo_phone(ctx, field)
			case "url":
				return ec.fieldContext_ISPInfo_url(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ISPInfo", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_detectISP_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_dnsServers(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_dnsServers(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().DNSServers(rctx, fc.Args["deviceId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.DNSServers)
	fc.Result = res
	return ec.marshalNDnsServers2backendgraphmodelDNSServers(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_dnsServers(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "servers":
				return ec.fieldContext_DnsServers_servers(ctx, field)
			case "primary":
				return ec.fieldContext_DnsServers_primary(ctx, field)
			case "secondary":
				return ec.fieldContext_DnsServers_secondary(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DnsServers", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_dnsServers_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_alertRules(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_alertRules(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().AlertRules(rctx, fc.Args["deviceId"].(*string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.AlertRule)
	fc.Result = res
	return ec.marshalNAlertRule2backendgraphmodelAlertRule(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_alertRules(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_AlertRule_id(ctx, field)
			case "name":
				return ec.fieldContext_AlertRule_name(ctx, field)
			case "description":
				return ec.fieldContext_AlertRule_description(ctx, field)
			case "eventType":
				return ec.fieldContext_AlertRule_eventType(ctx, field)
			case "conditions":
				return ec.fieldContext_AlertRule_conditions(ctx, field)
			case "severity":
				return ec.fieldContext_AlertRule_severity(ctx, field)
			case "channels":
				return ec.fieldContext_AlertRule_channels(ctx, field)
			case "throttle":
				return ec.fieldContext_AlertRule_throttle(ctx, field)
			case "quietHours":
				return ec.fieldContext_AlertRule_quietHours(ctx, field)
			case "deviceId":
				return ec.fieldContext_AlertRule_deviceId(ctx, field)
			case "enabled":
				return ec.fieldContext_AlertRule_enabled(ctx, field)
			case "createdAt":
				return ec.fieldContext_AlertRule_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_AlertRule_updatedAt(ctx, field)
			case "alerts":
				return ec.fieldContext_AlertRule_alerts(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type AlertRule", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_alertRules_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_alertRule(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_alertRule(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().AlertRule(rctx, fc.Args["id"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.AlertRule)
	fc.Result = res
	return ec.marshalOAlertRule2backendgraphmodelAlertRule(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_alertRule(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_AlertRule_id(ctx, field)
			case "name":
				return ec.fieldContext_AlertRule_name(ctx, field)
			case "description":
				return ec.fieldContext_AlertRule_description(ctx, field)
			case "eventType":
				return ec.fieldContext_AlertRule_eventType(ctx, field)
			case "conditions":
				return ec.fieldContext_AlertRule_conditions(ctx, field)
			case "severity":
				return ec.fieldContext_AlertRule_severity(ctx, field)
			case "channels":
				return ec.fieldContext_AlertRule_channels(ctx, field)
			case "throttle":
				return ec.fieldContext_AlertRule_throttle(ctx, field)
			case "quietHours":
				return ec.fieldContext_AlertRule_quietHours(ctx, field)
			case "deviceId":
				return ec.fieldContext_AlertRule_deviceId(ctx, field)
			case "enabled":
				return ec.fieldContext_AlertRule_enabled(ctx, field)
			case "createdAt":
				return ec.fieldContext_AlertRule_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_AlertRule_updatedAt(ctx, field)
			case "alerts":
				return ec.fieldContext_AlertRule_alerts(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type AlertRule", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_alertRule_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_alerts(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_alerts(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Alerts(rctx, fc.Args["deviceId"].(*string), fc.Args["severity"].(*model.AlertSeverity), fc.Args["acknowledged"].(*bool), fc.Args["limit"].(*int), fc.Args["offset"].(*int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.AlertConnection)
	fc.Result = res
	return ec.marshalNAlertConnection2backendgraphmodelAlertConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_alerts(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "edges":
				return ec.fieldContext_AlertConnection_edges(ctx, field)
			case "pageInfo":
				return ec.fieldContext_AlertConnection_pageInfo(ctx, field)
			case "totalCount":
				return ec.fieldContext_AlertConnection_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type AlertConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_alerts_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_resource(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_resource(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Resource(rctx, fc.Args["id"].(string), fc.Args["routerId"].(string), fc.Args["layers"].([]model.ResourceLayer))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(model.Resource)
	fc.Result = res
	return ec.marshalOResource2backendgraphmodelResource(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_resource(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("FieldContext.Child cannot be called on type INTERFACE")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_resource_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_resources(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_resources(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Resources(rctx, fc.Args["routerId"].(string), fc.Args["category"].(*model.ResourceCategory), fc.Args["type"].(*string), fc.Args["state"].(*model.ResourceLifecycleState), fc.Args["pagination"].(*model.PaginationInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.ResourceConnection)
	fc.Result = res
	return ec.marshalNResourceConnection2backendgraphmodelResourceConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_resources(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "edges":
				return ec.fieldContext_ResourceConnection_edges(ctx, field)
			case "pageInfo":
				return ec.fieldContext_ResourceConnection_pageInfo(ctx, field)
			case "totalCount":
				return ec.fieldContext_ResourceConnection_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ResourceConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_resources_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_compositeResource(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_compositeResource(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().CompositeResource(rctx, fc.Args["id"].(string), fc.Args["routerId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.CompositeResource)
	fc.Result = res
	return ec.marshalOCompositeResource2backendgraphmodelCompositeResource(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_compositeResource(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "root":
				return ec.fieldContext_CompositeResource_root(ctx, field)
			case "children":
				return ec.fieldContext_CompositeResource_children(ctx, field)
			case "relationships":
				return ec.fieldContext_CompositeResource_relationships(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CompositeResource", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_compositeResource_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_ipAddresses(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_ipAddresses(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().IPAddresses(rctx, fc.Args["routerId"].(string), fc.Args["interfaceId"].(*string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			requires, err := ec.unmarshalNString2string(ctx, []interface{}{"interface"})
			if err != nil {
				return nil, err
			}
			if ec.directives.Capability == nil {
				return nil, errors.New("directive capability is not implemented")
			}
			return ec.directives.Capability(ctx, nil, directive0, requires)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*model.IPAddress); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*backend/graph/model.IPAddress`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.IPAddress)
	fc.Result = res
	return ec.marshalNIpAddress2backendgraphmodelIPAddress(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_ipAddresses(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_IpAddress_id(ctx, field)
			case "address":
				return ec.fieldContext_IpAddress_address(ctx, field)
			case "network":
				return ec.fieldContext_IpAddress_network(ctx, field)
			case "broadcast":
				return ec.fieldContext_IpAddress_broadcast(ctx, field)
			case "interface":
				return ec.fieldContext_IpAddress_interface(ctx, field)
			case "disabled":
				return ec.fieldContext_IpAddress_disabled(ctx, field)
			case "dynamic":
				return ec.fieldContext_IpAddress_dynamic(ctx, field)
			case "invalid":
				return ec.fieldContext_IpAddress_invalid(ctx, field)
			case "comment":
				return ec.fieldContext_IpAddress_comment(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type IpAddress", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_ipAddresses_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_ipAddress(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_ipAddress(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().IPAddress(rctx, fc.Args["routerId"].(string), fc.Args["id"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			requires, err := ec.unmarshalNString2string(ctx, []interface{}{"interface"})
			if err != nil {
				return nil, err
			}
			if ec.directives.Capability == nil {
				return nil, errors.New("directive capability is not implemented")
			}
			return ec.directives.Capability(ctx, nil, directive0, requires)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.IPAddress); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *backend/graph/model.IPAddress`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.IPAddress)
	fc.Result = res
	return ec.marshalOIpAddress2backendgraphmodelIPAddress(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_ipAddress(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_IpAddress_id(ctx, field)
			case "address":
				return ec.fieldContext_IpAddress_address(ctx, field)
			case "network":
				return ec.fieldContext_IpAddress_network(ctx, field)
			case "broadcast":
				return ec.fieldContext_IpAddress_broadcast(ctx, field)
			case "interface":
				return ec.fieldContext_IpAddress_interface(ctx, field)
			case "disabled":
				return ec.fieldContext_IpAddress_disabled(ctx, field)
			case "dynamic":
				return ec.fieldContext_IpAddress_dynamic(ctx, field)
			case "invalid":
				return ec.fieldContext_IpAddress_invalid(ctx, field)
			case "comment":
				return ec.fieldContext_IpAddress_comment(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type IpAddress", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_ipAddress_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_checkIpConflict(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_checkIpConflict(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().CheckIPConflict(rctx, fc.Args["routerId"].(string), fc.Args["address"].(string), fc.Args["interfaceId"].(*string), fc.Args["excludeId"].(*string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			requires, err := ec.unmarshalNString2string(ctx, []interface{}{"interface"})
			if err != nil {
				return nil, err
			}
			if ec.directives.Capability == nil {
				return nil, errors.New("directive capability is not implemented")
			}
			return ec.directives.Capability(ctx, nil, directive0, requires)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.IPConflictResult); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *backend/graph/model.IPConflictResult`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.IPConflictResult)
	fc.Result = res
	return ec.marshalNIpConflictResult2backendgraphmodelIPConflictResult(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_checkIpConflict(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hasConflict":
				return ec.fieldContext_IpConflictResult_hasConflict(ctx, field)
			case "conflicts":
				return ec.fieldContext_IpConflictResult_conflicts(ctx, field)
			case "message":
				return ec.fieldContext_IpConflictResult_message(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type IpConflictResult", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_checkIpConflict_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_ipAddressDependencies(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_ipAddressDependencies(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().IPAddressDependencies(rctx, fc.Args["routerId"].(string), fc.Args["id"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			requires, err := ec.unmarshalNString2string(ctx, []interface{}{"interface"})
			if err != nil {
				return nil, err
			}
			if ec.directives.Capability == nil {
				return nil, errors.New("directive capability is not implemented")
			}
			return ec.directives.Capability(ctx, nil, directive0, requires)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.IPAddressDependencies); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *backend/graph/model.IPAddressDependencies`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.IPAddressDependencies)
	fc.Result = res
	return ec.marshalNIpAddressDependencies2backendgraphmodelIPAddressDependencies(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_ipAddressDependencies(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "ipAddressId":
				return ec.fieldContext_IpAddressDependencies_ipAddressId(ctx, field)
			case "dhcpServers":
				return ec.fieldContext_IpAddressDependencies_dhcpServers(ctx, field)
			case "routes":
				return ec.fieldContext_IpAddressDependencies_routes(ctx, field)
			case "natRules":
				return ec.fieldContext_IpAddressDependencies_natRules(ctx, field)
			case "firewallRules":
				return ec.fieldContext_IpAddressDependencies_firewallRules(ctx, field)
			case "hasDependencies":
				return ec.fieldContext_IpAddressDependencies_hasDependencies(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type IpAddressDependencies", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_ipAddressDependencies_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_vlans(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_vlans(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().Vlans(rctx, fc.Args["routerId"].(string), fc.Args["filter"].(*model.VlanFilter))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			requires, err := ec.unmarshalNString2string(ctx, []interface{}{"interface"})
			if err != nil {
				return nil, err
			}
			if ec.directives.Capability == nil {
				return nil, errors.New("directive capability is not implemented")
			}
			return ec.directives.Capability(ctx, nil, directive0, requires)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*model.Vlan); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*backend/graph/model.Vlan`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.Vlan)
	fc.Result = res
	return ec.marshalNVlan2backendgraphmodelVlan(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_vlans(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Vlan_id(ctx, field)
			case "name":
				return ec.fieldContext_Vlan_name(ctx, field)
			case "vlanId":
				return ec.fieldContext_Vlan_vlanId(ctx, field)
			case "interface":
				return ec.fieldContext_Vlan_interface(ctx, field)
			case "mtu":
				return ec.fieldContext_Vlan_mtu(ctx, field)
			case "macAddress":
				return ec.fieldContext_Vlan_macAddress(ctx, field)
			case "disabled":
				return ec.fieldContext_Vlan_disabled(ctx, field)
			case "running":
				return ec.fieldContext_Vlan_running(ctx, field)
			case "comment":
				return ec.fieldContext_Vlan_comment(ctx, field)
			case "ipAddresses":
				return ec.fieldContext_Vlan_ipAddresses(ctx, field)
			case "statistics":
				return ec.fieldContext_Vlan_statistics(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Vlan", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_vlans_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_vlan(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_vlan(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().Vlan(rctx, fc.Args["id"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			requires, err := ec.unmarshalNString2string(ctx, []interface{}{"interface"})
			if err != nil {
				return nil, err
			}
			if ec.directives.Capability == nil {
				return nil, errors.New("directive capability is not implemented")
			}
			return ec.directives.Capability(ctx, nil, directive0, requires)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.Vlan); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *backend/graph/model.Vlan`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Vlan)
	fc.Result = res
	return ec.marshalOVlan2backendgraphmodelVlan(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_vlan(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Vlan_id(ctx, field)
			case "name":
				return ec.fieldContext_Vlan_name(ctx, field)
			case "vlanId":
				return ec.fieldContext_Vlan_vlanId(ctx, field)
			case "interface":
				return ec.fieldContext_Vlan_interface(ctx, field)
			case "mtu":
				return ec.fieldContext_Vlan_mtu(ctx, field)
			case "macAddress":
				return ec.fieldContext_Vlan_macAddress(ctx, field)
			case "disabled":
				return ec.fieldContext_Vlan_disabled(ctx, field)
			case "running":
				return ec.fieldContext_Vlan_running(ctx, field)
			case "comment":
				return ec.fieldContext_Vlan_comment(ctx, field)
			case "ipAddresses":
				return ec.fieldContext_Vlan_ipAddresses(ctx, field)
			case "statistics":
				return ec.fieldContext_Vlan_statistics(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Vlan", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_vlan_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_checkVlanIdAvailable(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_checkVlanIdAvailable(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().CheckVlanIDAvailable(rctx, fc.Args["routerId"].(string), fc.Args["parentInterface"].(string), fc.Args["vlanId"].(int))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			requires, err := ec.unmarshalNString2string(ctx, []interface{}{"interface"})
			if err != nil {
				return nil, err
			}
			if ec.directives.Capability == nil {
				return nil, errors.New("directive capability is not implemented")
			}
			return ec.directives.Capability(ctx, nil, directive0, requires)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_checkVlanIdAvailable(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_checkVlanIdAvailable_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_vlanDependencies(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_vlanDependencies(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().VlanDependencies(rctx, fc.Args["id"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			requires, err := ec.unmarshalNString2string(ctx, []interface{}{"interface"})
			if err != nil {
				return nil, err
			}
			if ec.directives.Capability == nil {
				return nil, errors.New("directive capability is not implemented")
			}
			return ec.directives.Capability(ctx, nil, directive0, requires)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.VlanDependencies); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *backend/graph/model.VlanDependencies`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.VlanDependencies)
	fc.Result = res
	return ec.marshalOVlanDependencies2backendgraphmodelVlanDependencies(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_vlanDependencies(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "vlanId":
				return ec.fieldContext_VlanDependencies_vlanId(ctx, field)
			case "ipAddresses":
				return ec.fieldContext_VlanDependencies_ipAddresses(ctx, field)
			case "dhcpServers":
				return ec.fieldContext_VlanDependencies_dhcpServers(ctx, field)
			case "firewallRules":
				return ec.fieldContext_VlanDependencies_firewallRules(ctx, field)
			case "routes":
				return ec.fieldContext_VlanDependencies_routes(ctx, field)
			case "activeConnections":
				return ec.fieldContext_VlanDependencies_activeConnections(ctx, field)
			case "hasDependencies":
				return ec.fieldContext_VlanDependencies_hasDependencies(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type VlanDependencies", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_vlanDependencies_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_vlanTopology(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_vlanTopology(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().VlanTopology(rctx, fc.Args["routerId"].(string), fc.Args["bridgeId"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			requires, err := ec.unmarshalNString2string(ctx, []interface{}{"interface"})
			if err != nil {
				return nil, err
			}
			if ec.directives.Capability == nil {
				return nil, errors.New("directive capability is not implemented")
			}
			return ec.directives.Capability(ctx, nil, directive0, requires)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.VlanTopology); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *backend/graph/model.VlanTopology`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.VlanTopology)
	fc.Result = res
	return ec.marshalOVlanTopology2backendgraphmodelVlanTopology(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_vlanTopology(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "nodes":
				return ec.fieldContext_VlanTopology_nodes(ctx, field)
			case "edges":
				return ec.fieldContext_VlanTopology_edges(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type VlanTopology", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_vlanTopology_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_routes(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_routes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().Routes(rctx, fc.Args["routerId"].(string), fc.Args["table"].(*string), fc.Args["type"].(*model.RouteType))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			requires, err := ec.unmarshalNString2string(ctx, []interface{}{"routing"})
			if err != nil {
				return nil, err
			}
			if ec.directives.Capability == nil {
				return nil, errors.New("directive capability is not implemented")
			}
			return ec.directives.Capability(ctx, nil, directive0, requires)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*model.Route); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*backend/graph/model.Route`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.Route)
	fc.Result = res
	return ec.marshalNRoute2backendgraphmodelRoute(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_routes(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Route_id(ctx, field)
			case "destination":
				return ec.fieldContext_Route_destination(ctx, field)
			case "gateway":
				return ec.fieldContext_Route_gateway(ctx, field)
			case "interface":
				return ec.fieldContext_Route_interface(ctx, field)
			case "distance":
				return ec.fieldContext_Route_distance(ctx, field)
			case "routingMark":
				return ec.fieldContext_Route_routingMark(ctx, field)
			case "routingTable":
				return ec.fieldContext_Route_routingTable(ctx, field)
			case "type":
				return ec.fieldContext_Route_type(ctx, field)
			case "scope":
				return ec.fieldContext_Route_scope(ctx, field)
			case "comment":
				return ec.fieldContext_Route_comment(ctx, field)
			case "active":
				return ec.fieldContext_Route_active(ctx, field)
			case "disabled":
				return ec.fieldContext_Route_disabled(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Route", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_routes_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_route(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_route(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().Route(rctx, fc.Args["routerId"].(string), fc.Args["id"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			requires, err := ec.unmarshalNString2string(ctx, []interface{}{"routing"})
			if err != nil {
				return nil, err
			}
			if ec.directives.Capability == nil {
				return nil, errors.New("directive capability is not implemented")
			}
			return ec.directives.Capability(ctx, nil, directive0, requires)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.Route); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *backend/graph/model.Route`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Route)
	fc.Result = res
	return ec.marshalORoute2backendgraphmodelRoute(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_route(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Route_id(ctx, field)
			case "destination":
				return ec.fieldContext_Route_destination(ctx, field)
			case "gateway":
				return ec.fieldContext_Route_gateway(ctx, field)
			case "interface":
				return ec.fieldContext_Route_interface(ctx, field)
			case "distance":
				return ec.fieldContext_Route_distance(ctx, field)
			case "routingMark":
				return ec.fieldContext_Route_routingMark(ctx, field)
			case "routingTable":
				return ec.fieldContext_Route_routingTable(ctx, field)
			case "type":
				return ec.fieldContext_Route_type(ctx, field)
			case "scope":
				return ec.fieldContext_Route_scope(ctx, field)
			case "comment":
				return ec.fieldContext_Route_comment(ctx, field)
			case "active":
				return ec.fieldContext_Route_active(ctx, field)
			case "disabled":
				return ec.fieldContext_Route_disabled(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Route", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_route_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_checkGatewayReachability(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_checkGatewayReachability(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().CheckGatewayReachability(rctx, fc.Args["routerId"].(string), fc.Args["gateway"].(model.IPv4))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			requires, err := ec.unmarshalNString2string(ctx, []interface{}{"routing"})
			if err != nil {
				return nil, err
			}
			if ec.directives.Capability == nil {
				return nil, errors.New("directive capability is not implemented")
			}
			return ec.directives.Capability(ctx, nil, directive0, requires)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.GatewayReachabilityResult); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *backend/graph/model.GatewayReachabilityResult`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.GatewayReachabilityResult)
	fc.Result = res
	return ec.marshalNGatewayReachabilityResult2backendgraphmodelGatewayReachabilityResult(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_checkGatewayReachability(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "reachable":
				return ec.fieldContext_GatewayReachabilityResult_reachable(ctx, field)
			case "latency":
				return ec.fieldContext_GatewayReachabilityResult_latency(ctx, field)
			case "interface":
				return ec.fieldContext_GatewayReachabilityResult_interface(ctx, field)
			case "message":
				return ec.fieldContext_GatewayReachabilityResult_message(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GatewayReachabilityResult", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_checkGatewayReachability_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_interfaceStatsHistory(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_interfaceStatsHistory(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().InterfaceStatsHistory(rctx, fc.Args["routerId"].(string), fc.Args["interfaceId"].(string), fc.Args["timeRange"].(model.StatsTimeRangeInput), fc.Args["interval"].(*model.Duration))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			requires, err := ec.unmarshalNString2string(ctx, []interface{}{"interface"})
			if err != nil {
				return nil, err
			}
			if ec.directives.Capability == nil {
				return nil, errors.New("directive capability is not implemented")
			}
			return ec.directives.Capability(ctx, nil, directive0, requires)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.InterfaceStatsHistory); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *backend/graph/model.InterfaceStatsHistory`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.InterfaceStatsHistory)
	fc.Result = res
	return ec.marshalNInterfaceStatsHistory2backendgraphmodelInterfaceStatsHistory(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_interfaceStatsHistory(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "interfaceId":
				return ec.fieldContext_InterfaceStatsHistory_interfaceId(ctx, field)
			case "dataPoints":
				return ec.fieldContext_InterfaceStatsHistory_dataPoints(ctx, field)
			case "interval":
				return ec.fieldContext_InterfaceStatsHistory_interval(ctx, field)
			case "startTime":
				return ec.fieldContext_InterfaceStatsHistory_startTime(ctx, field)
			case "endTime":
				return ec.fieldContext_InterfaceStatsHistory_endTime(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type InterfaceStatsHistory", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_interfaceStatsHistory_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_bridges(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_bridges(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Bridges(rctx, fc.Args["routerId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.Bridge)
	fc.Result = res
	return ec.marshalNBridge2backendgraphmodelBridge(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_bridges(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Bridge_id(ctx, field)
			case "name":
				return ec.fieldContext_Bridge_name(ctx, field)
			case "comment":
				return ec.fieldContext_Bridge_comment(ctx, field)
			case "disabled":
				return ec.fieldContext_Bridge_disabled(ctx, field)
			case "running":
				return ec.fieldContext_Bridge_running(ctx, field)
			case "macAddress":
				return ec.fieldContext_Bridge_macAddress(ctx, field)
			case "mtu":
				return ec.fieldContext_Bridge_mtu(ctx, field)
			case "protocol":
				return ec.fieldContext_Bridge_protocol(ctx, field)
			case "priority":
				return ec.fieldContext_Bridge_priority(ctx, field)
			case "vlanFiltering":
				return ec.fieldContext_Bridge_vlanFiltering(ctx, field)
			case "pvid":
				return ec.fieldContext_Bridge_pvid(ctx, field)
			case "ports":
				return ec.fieldContext_Bridge_ports(ctx, field)
			case "vlans":
				return ec.fieldContext_Bridge_vlans(ctx, field)
			case "ipAddresses":
				return ec.fieldContext_Bridge_ipAddresses(ctx, field)
			case "stpStatus":
				return ec.fieldContext_Bridge_stpStatus(ctx, field)
			case "dependentDhcpServers":
				return ec.fieldContext_Bridge_dependentDhcpServers(ctx, field)
			case "dependentRoutes":
				return ec.fieldContext_Bridge_dependentRoutes(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Bridge", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_bridges_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_bridge(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_bridge(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Bridge(rctx, fc.Args["uuid"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Bridge)
	fc.Result = res
	return ec.marshalOBridge2backendgraphmodelBridge(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_bridge(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Bridge_id(ctx, field)
			case "name":
				return ec.fieldContext_Bridge_name(ctx, field)
			case "comment":
				return ec.fieldContext_Bridge_comment(ctx, field)
			case "disabled":
				return ec.fieldContext_Bridge_disabled(ctx, field)
			case "running":
				return ec.fieldContext_Bridge_running(ctx, field)
			case "macAddress":
				return ec.fieldContext_Bridge_macAddress(ctx, field)
			case "mtu":
				return ec.fieldContext_Bridge_mtu(ctx, field)
			case "protocol":
				return ec.fieldContext_Bridge_protocol(ctx, field)
			case "priority":
				return ec.fieldContext_Bridge_priority(ctx, field)
			case "vlanFiltering":
				return ec.fieldContext_Bridge_vlanFiltering(ctx, field)
			case "pvid":
				return ec.fieldContext_Bridge_pvid(ctx, field)
			case "ports":
				return ec.fieldContext_Bridge_ports(ctx, field)
			case "vlans":
				return ec.fieldContext_Bridge_vlans(ctx, field)
			case "ipAddresses":
				return ec.fieldContext_Bridge_ipAddresses(ctx, field)
			case "stpStatus":
				return ec.fieldContext_Bridge_stpStatus(ctx, field)
			case "dependentDhcpServers":
				return ec.fieldContext_Bridge_dependentDhcpServers(ctx, field)
			case "dependentRoutes":
				return ec.fieldContext_Bridge_dependentRoutes(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Bridge", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_bridge_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_bridgePorts(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_bridgePorts(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().BridgePorts(rctx, fc.Args["bridgeId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.BridgePort)
	fc.Result = res
	return ec.marshalNBridgePort2backendgraphmodelBridgePort(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_bridgePorts(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_BridgePort_id(ctx, field)
			case "bridge":
				return ec.fieldContext_BridgePort_bridge(ctx, field)
			case "interface":
				return ec.fieldContext_BridgePort_interface(ctx, field)
			case "pvid":
				return ec.fieldContext_BridgePort_pvid(ctx, field)
			case "frameTypes":
				return ec.fieldContext_BridgePort_frameTypes(ctx, field)
			case "ingressFiltering":
				return ec.fieldContext_BridgePort_ingressFiltering(ctx, field)
			case "taggedVlans":
				return ec.fieldContext_BridgePort_taggedVlans(ctx, field)
			case "untaggedVlans":
				return ec.fieldContext_BridgePort_untaggedVlans(ctx, field)
			case "role":
				return ec.fieldContext_BridgePort_role(ctx, field)
			case "state":
				return ec.fieldContext_BridgePort_state(ctx, field)
			case "pathCost":
				return ec.fieldContext_BridgePort_pathCost(ctx, field)
			case "edge":
				return ec.fieldContext_BridgePort_edge(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type BridgePort", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_bridgePorts_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_bridgeVlans(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_bridgeVlans(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().BridgeVlans(rctx, fc.Args["bridgeId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.BridgeVlan)
	fc.Result = res
	return ec.marshalNBridgeVlan2backendgraphmodelBridgeVlan(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_bridgeVlans(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "uuid":
				return ec.fieldContext_BridgeVlan_uuid(ctx, field)
			case "bridge":
				return ec.fieldContext_BridgeVlan_bridge(ctx, field)
			case "vlanId":
				return ec.fieldContext_BridgeVlan_vlanId(ctx, field)
			case "taggedPorts":
				return ec.fieldContext_BridgeVlan_taggedPorts(ctx, field)
			case "untaggedPorts":
				return ec.fieldContext_BridgeVlan_untaggedPorts(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type BridgeVlan", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_bridgeVlans_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_availableInterfacesForBridge(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_availableInterfacesForBridge(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().AvailableInterfacesForBridge(rctx, fc.Args["routerId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.Interface)
	fc.Result = res
	return ec.marshalNInterface2backendgraphmodelInterface(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_availableInterfacesForBridge(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Interface_id(ctx, field)
			case "name":
				return ec.fieldContext_Interface_name(ctx, field)
			case "type":
				return ec.fieldContext_Interface_type(ctx, field)
			case "enabled":
				return ec.fieldContext_Interface_enabled(ctx, field)
			case "running":
				return ec.fieldContext_Interface_running(ctx, field)
			case "macAddress":
				return ec.fieldContext_Interface_macAddress(ctx, field)
			case "mtu":
				return ec.fieldContext_Interface_mtu(ctx, field)
			case "comment":
				return ec.fieldContext_Interface_comment(ctx, field)
			case "txBytes":
				return ec.fieldContext_Interface_txBytes(ctx, field)
			case "rxBytes":
				return ec.fieldContext_Interface_rxBytes(ctx, field)
			case "ip":
				return ec.fieldContext_Interface_ip(ctx, field)
			case "status":
				return ec.fieldContext_Interface_status(ctx, field)
			case "txRate":
				return ec.fieldContext_Interface_txRate(ctx, field)
			case "rxRate":
				return ec.fieldContext_Interface_rxRate(ctx, field)
			case "linkSpeed":
				return ec.fieldContext_Interface_linkSpeed(ctx, field)
			case "lastSeen":
				return ec.fieldContext_Interface_lastSeen(ctx, field)
			case "linkPartner":
				return ec.fieldContext_Interface_linkPartner(ctx, field)
			case "usedBy":
				return ec.fieldContext_Interface_usedBy(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Interface", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_availableInterfacesForBridge_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_wanInterfaces(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_wanInterfaces(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().WanInterfaces(rctx, fc.Args["routerId"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			requires, err := ec.unmarshalNString2string(ctx, []interface{}{"interface"})
			if err != nil {
				return nil, err
			}
			if ec.directives.Capability == nil {
				return nil, errors.New("directive capability is not implemented")
			}
			return ec.directives.Capability(ctx, nil, directive0, requires)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*model.WANInterface); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*backend/graph/model.WANInterface`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.WANInterface)
	fc.Result = res
	return ec.marshalNWANInterface2backendgraphmodelWANInterface(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_wanInterfaces(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_WANInterface_id(ctx, field)
			case "interface":
				return ec.fieldContext_WANInterface_interface(ctx, field)
			case "type":
				return ec.fieldContext_WANInterface_type(ctx, field)
			case "status":
				return ec.fieldContext_WANInterface_status(ctx, field)
			case "publicIP":
				return ec.fieldContext_WANInterface_publicIP(ctx, field)
			case "gateway":
				return ec.fieldContext_WANInterface_gateway(ctx, field)
			case "primaryDNS":
				return ec.fieldContext_WANInterface_primaryDNS(ctx, field)
			case "secondaryDNS":
				return ec.fieldContext_WANInterface_secondaryDNS(ctx, field)
			case "uptime":
				return ec.fieldContext_WANInterface_uptime(ctx, field)
			case "lastConnected":
				return ec.fieldContext_WANInterface_lastConnected(ctx, field)
			case "health":
				return ec.fieldContext_WANInterface_health(ctx, field)
			case "dhcpClient":
				return ec.fieldContext_WANInterface_dhcpClient(ctx, field)
			case "pppoeClient":
				return ec.fieldContext_WANInterface_pppoeClient(ctx, field)
			case "staticConfig":
				return ec.fieldContext_WANInterface_staticConfig(ctx, field)
			case "lteModem":
				return ec.fieldContext_WANInterface_lteModem(ctx, field)
			case "isDefaultRoute":
				return ec.fieldContext_WANInterface_isDefaultRoute(ctx, field)
			case "statistics":
				return ec.fieldContext_WANInterface_statistics(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type WANInterface", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_wanInterfaces_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_wanInterface(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_wanInterface(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().WanInterface(rctx, fc.Args["routerId"].(string), fc.Args["id"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			requires, err := ec.unmarshalNString2string(ctx, []interface{}{"interface"})
			if err != nil {
				return nil, err
			}
			if ec.directives.Capability == nil {
				return nil, errors.New("directive capability is not implemented")
			}
			return ec.directives.Capability(ctx, nil, directive0, requires)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.WANInterface); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *backend/graph/model.WANInterface`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.WANInterface)
	fc.Result = res
	return ec.marshalOWANInterface2backendgraphmodelWANInterface(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_wanInterface(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_WANInterface_id(ctx, field)
			case "interface":
				return ec.fieldContext_WANInterface_interface(ctx, field)
			case "type":
				return ec.fieldContext_WANInterface_type(ctx, field)
			case "status":
				return ec.fieldContext_WANInterface_status(ctx, field)
			case "publicIP":
				return ec.fieldContext_WANInterface_publicIP(ctx, field)
			case "gateway":
				return ec.fieldContext_WANInterface_gateway(ctx, field)
			case "primaryDNS":
				return ec.fieldContext_WANInterface_primaryDNS(ctx, field)
			case "secondaryDNS":
				return ec.fieldContext_WANInterface_secondaryDNS(ctx, field)
			case "uptime":
				return ec.fieldContext_WANInterface_uptime(ctx, field)
			case "lastConnected":
				return ec.fieldContext_WANInterface_lastConnected(ctx, field)
			case "health":
				return ec.fieldContext_WANInterface_health(ctx, field)
			case "dhcpClient":
				return ec.fieldContext_WANInterface_dhcpClient(ctx, field)
			case "pppoeClient":
				return ec.fieldContext_WANInterface_pppoeClient(ctx, field)
			case "staticConfig":
				return ec.fieldContext_WANInterface_staticConfig(ctx, field)
			case "lteModem":
				return ec.fieldContext_WANInterface_lteModem(ctx, field)
			case "isDefaultRoute":
				return ec.fieldContext_WANInterface_isDefaultRoute(ctx, field)
			case "statistics":
				return ec.fieldContext_WANInterface_statistics(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type WANInterface", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_wanInterface_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_wanConnectionHistory(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_wanConnectionHistory(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().WanConnectionHistory(rctx, fc.Args["routerId"].(string), fc.Args["wanInterfaceId"].(string), fc.Args["pagination"].(*model.PaginationInput))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			requires, err := ec.unmarshalNString2string(ctx, []interface{}{"interface"})
			if err != nil {
				return nil, err
			}
			if ec.directives.Capability == nil {
				return nil, errors.New("directive capability is not implemented")
			}
			return ec.directives.Capability(ctx, nil, directive0, requires)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.WANConnectionEventConnection); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *backend/graph/model.WANConnectionEventConnection`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.WANConnectionEventConnection)
	fc.Result = res
	return ec.marshalNWANConnectionEventConnection2backendgraphmodelWANConnectionEventConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_wanConnectionHistory(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "edges":
				return ec.fieldContext_WANConnectionEventConnection_edges(ctx, field)
			case "pageInfo":
				return ec.fieldContext_WANConnectionEventConnection_pageInfo(ctx, field)
			case "totalCount":
				return ec.fieldContext_WANConnectionEventConnection_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type WANConnectionEventConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_wanConnectionHistory_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query___type(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query___type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectType(fc.Args["name"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query___type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query___type_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query___schema(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query___schema(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectSchema()
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Schema)
	fc.Result = res
	return ec.marshalO__Schema2githubcom99designsgqlgengraphqlintrospectionSchema(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query___schema(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "description":
				return ec.fieldContext___Schema_description(ctx, field)
			case "types":
				return ec.fieldContext___Schema_types(ctx, field)
			case "queryType":
				return ec.fieldContext___Schema_queryType(ctx, field)
			case "mutationType":
				return ec.fieldContext___Schema_mutationType(ctx, field)
			case "subscriptionType":
				return ec.fieldContext___Schema_subscriptionType(ctx, field)
			case "directives":
				return ec.fieldContext___Schema_directives(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Schema", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _QuietHoursConfig_startTime(ctx context.Context, field graphql.CollectedField, obj *model.QuietHoursConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_QuietHoursConfig_startTime(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StartTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_QuietHoursConfig_startTime(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "QuietHoursConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _QuietHoursConfig_endTime(ctx context.Context, field graphql.CollectedField, obj *model.QuietHoursConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_QuietHoursConfig_endTime(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EndTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_QuietHoursConfig_endTime(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "QuietHoursConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _QuietHoursConfig_timezone(ctx context.Context, field graphql.CollectedField, obj *model.QuietHoursConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_QuietHoursConfig_timezone(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Timezone, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_QuietHoursConfig_timezone(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "QuietHoursConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _QuietHoursConfig_bypassCritical(ctx context.Context, field graphql.CollectedField, obj *model.QuietHoursConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_QuietHoursConfig_bypassCritical(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BypassCritical, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_QuietHoursConfig_bypassCritical(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "QuietHoursConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ReconnectRouterPayload_router(ctx context.Context, field graphql.CollectedField, obj *model.ReconnectRouterPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ReconnectRouterPayload_router(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Router, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Router)
	fc.Result = res
	return ec.marshalORouter2backendgraphmodelRouter(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ReconnectRouterPayload_router(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ReconnectRouterPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Router_id(ctx, field)
			case "name":
				return ec.fieldContext_Router_name(ctx, field)
			case "host":
				return ec.fieldContext_Router_host(ctx, field)
			case "port":
				return ec.fieldContext_Router_port(ctx, field)
			case "status":
				return ec.fieldContext_Router_status(ctx, field)
			case "platform":
				return ec.fieldContext_Router_platform(ctx, field)
			case "version":
				return ec.fieldContext_Router_version(ctx, field)
			case "model":
				return ec.fieldContext_Router_model(ctx, field)
			case "uptime":
				return ec.fieldContext_Router_uptime(ctx, field)
			case "lastConnected":
				return ec.fieldContext_Router_lastConnected(ctx, field)
			case "createdAt":
				return ec.fieldContext_Router_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Router_updatedAt(ctx, field)
			case "capabilities":
				return ec.fieldContext_Router_capabilities(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Router", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ReconnectRouterPayload_connectionDetails(ctx context.Context, field graphql.CollectedField, obj *model.ReconnectRouterPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ReconnectRouterPayload_connectionDetails(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ConnectionDetails, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.ConnectionDetails)
	fc.Result = res
	return ec.marshalOConnectionDetails2backendgraphmodelConnectionDetails(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ReconnectRouterPayload_connectionDetails(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ReconnectRouterPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "state":
				return ec.fieldContext_ConnectionDetails_state(ctx, field)
			case "protocol":
				return ec.fieldContext_ConnectionDetails_protocol(ctx, field)
			case "preferredProtocol":
				return ec.fieldContext_ConnectionDetails_preferredProtocol(ctx, field)
			case "connectedAt":
				return ec.fieldContext_ConnectionDetails_connectedAt(ctx, field)
			case "uptime":
				return ec.fieldContext_ConnectionDetails_uptime(ctx, field)
			case "disconnectedAt":
				return ec.fieldContext_ConnectionDetails_disconnectedAt(ctx, field)
			case "lastError":
				return ec.fieldContext_ConnectionDetails_lastError(ctx, field)
			case "lastErrorTime":
				return ec.fieldContext_ConnectionDetails_lastErrorTime(ctx, field)
			case "disconnectReason":
				return ec.fieldContext_ConnectionDetails_disconnectReason(ctx, field)
			case "reconnectAttempts":
				return ec.fieldContext_ConnectionDetails_reconnectAttempts(ctx, field)
			case "nextReconnectAt":
				return ec.fieldContext_ConnectionDetails_nextReconnectAt(ctx, field)
			case "circuitBreakerState":
				return ec.fieldContext_ConnectionDetails_circuitBreakerState(ctx, field)
			case "version":
				return ec.fieldContext_ConnectionDetails_version(ctx, field)
			case "lastHealthCheck":
				return ec.fieldContext_ConnectionDetails_lastHealthCheck(ctx, field)
			case "healthChecksPassed":
				return ec.fieldContext_ConnectionDetails_healthChecksPassed(ctx, field)
			case "healthChecksFailed":
				return ec.fieldContext_ConnectionDetails_healthChecksFailed(ctx, field)
			case "securityWarning":
				return ec.fieldContext_ConnectionDetails_securityWarning(ctx, field)
			case "upgradeRecommendation":
				return ec.fieldContext_ConnectionDetails_upgradeRecommendation(ctx, field)
			case "isLegacyProtocol":
				return ec.fieldContext_ConnectionDetails_isLegacyProtocol(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ConnectionDetails", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ReconnectRouterPayload_initiated(ctx context.Context, field graphql.CollectedField, obj *model.ReconnectRouterPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ReconnectRouterPayload_initiated(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Initiated, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ReconnectRouterPayload_initiated(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ReconnectRouterPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ReconnectRouterPayload_waitTimeMs(ctx context.Context, field graphql.CollectedField, obj *model.ReconnectRouterPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ReconnectRouterPayload_waitTimeMs(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.WaitTimeMs, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ReconnectRouterPayload_waitTimeMs(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ReconnectRouterPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ReconnectRouterPayload_errors(ctx context.Context, field graphql.CollectedField, obj *model.ReconnectRouterPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ReconnectRouterPayload_errors(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Errors, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.MutationError)
	fc.Result = res
	return ec.marshalOMutationError2backendgraphmodelMutationError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ReconnectRouterPayload_errors(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ReconnectRouterPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "code":
				return ec.fieldContext_MutationError_code(ctx, field)
			case "message":
				return ec.fieldContext_MutationError_message(ctx, field)
			case "field":
				return ec.fieldContext_MutationError_field(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MutationError", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RefreshCapabilitiesPayload_capabilities(ctx context.Context, field graphql.CollectedField, obj *model.RefreshCapabilitiesPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RefreshCapabilitiesPayload_capabilities(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Capabilities, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.RouterCapabilities)
	fc.Result = res
	return ec.marshalORouterCapabilities2backendgraphmodelRouterCapabilities(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RefreshCapabilitiesPayload_capabilities(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RefreshCapabilitiesPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hardware":
				return ec.fieldContext_RouterCapabilities_hardware(ctx, field)
			case "software":
				return ec.fieldContext_RouterCapabilities_software(ctx, field)
			case "container":
				return ec.fieldContext_RouterCapabilities_container(ctx, field)
			case "capabilities":
				return ec.fieldContext_RouterCapabilities_capabilities(ctx, field)
			case "vifRequirements":
				return ec.fieldContext_RouterCapabilities_vifRequirements(ctx, field)
			case "supportedFeatures":
				return ec.fieldContext_RouterCapabilities_supportedFeatures(ctx, field)
			case "unsupportedFeatures":
				return ec.fieldContext_RouterCapabilities_unsupportedFeatures(ctx, field)
			case "routerOSVersion":
				return ec.fieldContext_RouterCapabilities_routerOSVersion(ctx, field)
			case "detectedAt":
				return ec.fieldContext_RouterCapabilities_detectedAt(ctx, field)
			case "expiresAt":
				return ec.fieldContext_RouterCapabilities_expiresAt(ctx, field)
			case "isRefreshing":
				return ec.fieldContext_RouterCapabilities_isRefreshing(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RouterCapabilities", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RefreshCapabilitiesPayload_errors(ctx context.Context, field graphql.CollectedField, obj *model.RefreshCapabilitiesPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RefreshCapabilitiesPayload_errors(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Errors, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.MutationError)
	fc.Result = res
	return ec.marshalOMutationError2backendgraphmodelMutationError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RefreshCapabilitiesPayload_errors(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RefreshCapabilitiesPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "code":
				return ec.fieldContext_MutationError_code(ctx, field)
			case "message":
				return ec.fieldContext_MutationError_message(ctx, field)
			case "field":
				return ec.fieldContext_MutationError_field(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MutationError", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RemoveChangeSetItemPayload_changeSet(ctx context.Context, field graphql.CollectedField, obj *model.RemoveChangeSetItemPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RemoveChangeSetItemPayload_changeSet(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ChangeSet, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.ChangeSet)
	fc.Result = res
	return ec.marshalOChangeSet2backendgraphmodelChangeSet(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RemoveChangeSetItemPayload_changeSet(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RemoveChangeSetItemPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ChangeSet_id(ctx, field)
			case "name":
				return ec.fieldContext_ChangeSet_name(ctx, field)
			case "description":
				return ec.fieldContext_ChangeSet_description(ctx, field)
			case "routerId":
				return ec.fieldContext_ChangeSet_routerId(ctx, field)
			case "items":
				return ec.fieldContext_ChangeSet_items(ctx, field)
			case "status":
				return ec.fieldContext_ChangeSet_status(ctx, field)
			case "validation":
				return ec.fieldContext_ChangeSet_validation(ctx, field)
			case "rollbackPlan":
				return ec.fieldContext_ChangeSet_rollbackPlan(ctx, field)
			case "error":
				return ec.fieldContext_ChangeSet_error(ctx, field)
			case "createdAt":
				return ec.fieldContext_ChangeSet_createdAt(ctx, field)
			case "applyStartedAt":
				return ec.fieldContext_ChangeSet_applyStartedAt(ctx, field)
			case "completedAt":
				return ec.fieldContext_ChangeSet_completedAt(ctx, field)
			case "createdBy":
				return ec.fieldContext_ChangeSet_createdBy(ctx, field)
			case "source":
				return ec.fieldContext_ChangeSet_source(ctx, field)
			case "version":
				return ec.fieldContext_ChangeSet_version(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ChangeSet", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RemoveChangeSetItemPayload_errors(ctx context.Context, field graphql.CollectedField, obj *model.RemoveChangeSetItemPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RemoveChangeSetItemPayload_errors(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Errors, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.MutationError)
	fc.Result = res
	return ec.marshalOMutationError2backendgraphmodelMutationError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RemoveChangeSetItemPayload_errors(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RemoveChangeSetItemPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "code":
				return ec.fieldContext_MutationError_code(ctx, field)
			case "message":
				return ec.fieldContext_MutationError_message(ctx, field)
			case "field":
				return ec.fieldContext_MutationError_field(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MutationError", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ResourceConflict_type(ctx context.Context, field graphql.CollectedField, obj *model.ResourceConflict) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ResourceConflict_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.ConflictType)
	fc.Result = res
	return ec.marshalNConflictType2backendgraphmodelConflictType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ResourceConflict_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ResourceConflict",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ConflictType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ResourceConflict_conflictingResource(ctx context.Context, field graphql.CollectedField, obj *model.ResourceConflict) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ResourceConflict_conflictingResource(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ConflictingResource, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(model.Resource)
	fc.Result = res
	return ec.marshalOResource2backendgraphmodelResource(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ResourceConflict_conflictingResource(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ResourceConflict",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("FieldContext.Child cannot be called on type INTERFACE")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ResourceConflict_conflictingResourceUuid(ctx context.Context, field graphql.CollectedField, obj *model.ResourceConflict) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ResourceConflict_conflictingResourceUuid(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ConflictingResourceUUID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ResourceConflict_conflictingResourceUuid(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ResourceConflict",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ResourceConflict_description(ctx context.Context, field graphql.CollectedField, obj *model.ResourceConflict) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ResourceConflict_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ResourceConflict_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ResourceConflict",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ResourceConflict_resolution(ctx context.Context, field graphql.CollectedField, obj *model.ResourceConflict) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ResourceConflict_resolution(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Resolution, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ResourceConflict_resolution(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ResourceConflict",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ResourceConnection_edges(ctx context.Context, field graphql.CollectedField, obj *model.ResourceConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ResourceConnection_edges(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Edges, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.ResourceEdge)
	fc.Result = res
	return ec.marshalNResourceEdge2backendgraphmodelResourceEdge(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ResourceConnection_edges(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ResourceConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "cursor":
				return ec.fieldContext_ResourceEdge_cursor(ctx, field)
			case "node":
				return ec.fieldContext_ResourceEdge_node(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ResourceEdge", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ResourceConnection_pageInfo(ctx context.Context, field graphql.CollectedField, obj *model.ResourceConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ResourceConnection_pageInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.PageInfo)
	fc.Result = res
	return ec.marshalNPageInfo2backendgraphmodelPageInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ResourceConnection_pageInfo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ResourceConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			case "hasPreviousPage":
				return ec.fieldContext_PageInfo_hasPreviousPage(ctx, field)
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ResourceConnection_totalCount(ctx context.Context, field graphql.CollectedField, obj *model.ResourceConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ResourceConnection_totalCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ResourceConnection_totalCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ResourceConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ResourceEdge_cursor(ctx context.Context, field graphql.CollectedField, obj *model.ResourceEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ResourceEdge_cursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ResourceEdge_cursor(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ResourceEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ResourceEdge_node(ctx context.Context, field graphql.CollectedField, obj *model.ResourceEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ResourceEdge_node(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Node, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.Resource)
	fc.Result = res
	return ec.marshalNResource2backendgraphmodelResource(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ResourceEdge_node(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ResourceEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("FieldContext.Child cannot be called on type INTERFACE")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ResourceMetadata_createdAt(ctx context.Context, field graphql.CollectedField, obj *model.ResourceMetadata) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ResourceMetadata_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNDateTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ResourceMetadata_createdAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ResourceMetadata",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DateTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ResourceMetadata_createdBy(ctx context.Context, field graphql.CollectedField, obj *model.ResourceMetadata) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ResourceMetadata_createdBy(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedBy, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ResourceMetadata_createdBy(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ResourceMetadata",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ResourceMetadata_updatedAt(ctx context.Context, field graphql.CollectedField, obj *model.ResourceMetadata) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ResourceMetadata_updatedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNDateTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ResourceMetadata_updatedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ResourceMetadata",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DateTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ResourceMetadata_updatedBy(ctx context.Context, field graphql.CollectedField, obj *model.ResourceMetadata) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ResourceMetadata_updatedBy(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedBy, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ResourceMetadata_updatedBy(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ResourceMetadata",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ResourceMetadata_state(ctx context.Context, field graphql.CollectedField, obj *model.ResourceMetadata) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ResourceMetadata_state(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.State, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.ResourceLifecycleState)
	fc.Result = res
	return ec.marshalNResourceLifecycleState2backendgraphmodelResourceLifecycleState(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ResourceMetadata_state(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ResourceMetadata",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ResourceLifecycleState does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ResourceMetadata_version(ctx context.Context, field graphql.CollectedField, obj *model.ResourceMetadata) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ResourceMetadata_version(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Version, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ResourceMetadata_version(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ResourceMetadata",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ResourceMetadata_tags(ctx context.Context, field graphql.CollectedField, obj *model.ResourceMetadata) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ResourceMetadata_tags(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Tags, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ResourceMetadata_tags(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ResourceMetadata",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ResourceMetadata_description(ctx context.Context, field graphql.CollectedField, obj *model.ResourceMetadata) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ResourceMetadata_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ResourceMetadata_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ResourceMetadata",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ResourceMetadata_isFavorite(ctx context.Context, field graphql.CollectedField, obj *model.ResourceMetadata) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ResourceMetadata_isFavorite(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsFavorite, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ResourceMetadata_isFavorite(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ResourceMetadata",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ResourceMetadata_isPinned(ctx context.Context, field graphql.CollectedField, obj *model.ResourceMetadata) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ResourceMetadata_isPinned(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsPinned, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ResourceMetadata_isPinned(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ResourceMetadata",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ResourceMetadata_notes(ctx context.Context, field graphql.CollectedField, obj *model.ResourceMetadata) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ResourceMetadata_notes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Notes, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ResourceMetadata_notes(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ResourceMetadata",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ResourceMetadata_recentChanges(ctx context.Context, field graphql.CollectedField, obj *model.ResourceMetadata) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ResourceMetadata_recentChanges(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RecentChanges, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.ChangeLogEntry)
	fc.Result = res
	return ec.marshalOChangeLogEntry2backendgraphmodelChangeLogEntry(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ResourceMetadata_recentChanges(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ResourceMetadata",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "timestamp":
				return ec.fieldContext_ChangeLogEntry_timestamp(ctx, field)
			case "user":
				return ec.fieldContext_ChangeLogEntry_user(ctx, field)
			case "changeType":
				return ec.fieldContext_ChangeLogEntry_changeType(ctx, field)
			case "changedFields":
				return ec.fieldContext_ChangeLogEntry_changedFields(ctx, field)
			case "summary":
				return ec.fieldContext_ChangeLogEntry_summary(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ChangeLogEntry", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ResourceMetrics_cpu(ctx context.Context, field graphql.CollectedField, obj *model.ResourceMetrics) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ResourceMetrics_cpu(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CPU, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.CPUMetrics)
	fc.Result = res
	return ec.marshalNCPUMetrics2backendgraphmodelCPUMetrics(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ResourceMetrics_cpu(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ResourceMetrics",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "usage":
				return ec.fieldContext_CPUMetrics_usage(ctx, field)
			case "cores":
				return ec.fieldContext_CPUMetrics_cores(ctx, field)
			case "perCore":
				return ec.fieldContext_CPUMetrics_perCore(ctx, field)
			case "frequency":
				return ec.fieldContext_CPUMetrics_frequency(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CPUMetrics", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ResourceMetrics_memory(ctx context.Context, field graphql.CollectedField, obj *model.ResourceMetrics) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ResourceMetrics_memory(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Memory, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.MemoryMetrics)
	fc.Result = res
	return ec.marshalNMemoryMetrics2backendgraphmodelMemoryMetrics(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ResourceMetrics_memory(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ResourceMetrics",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "used":
				return ec.fieldContext_MemoryMetrics_used(ctx, field)
			case "total":
				return ec.fieldContext_MemoryMetrics_total(ctx, field)
			case "percentage":
				return ec.fieldContext_MemoryMetrics_percentage(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MemoryMetrics", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ResourceMetrics_storage(ctx context.Context, field graphql.CollectedField, obj *model.ResourceMetrics) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ResourceMetrics_storage(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Storage, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.StorageMetrics)
	fc.Result = res
	return ec.marshalNStorageMetrics2backendgraphmodelStorageMetrics(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ResourceMetrics_storage(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ResourceMetrics",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "used":
				return ec.fieldContext_StorageMetrics_used(ctx, field)
			case "total":
				return ec.fieldContext_StorageMetrics_total(ctx, field)
			case "percentage":
				return ec.fieldContext_StorageMetrics_percentage(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type StorageMetrics", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ResourceMetrics_temperature(ctx context.Context, field graphql.CollectedField, obj *model.ResourceMetrics) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ResourceMetrics_temperature(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Temperature, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ResourceMetrics_temperature(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ResourceMetrics",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ResourceMetrics_timestamp(ctx context.Context, field graphql.CollectedField, obj *model.ResourceMetrics) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ResourceMetrics_timestamp(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Timestamp, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNDateTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ResourceMetrics_timestamp(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ResourceMetrics",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DateTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ResourceReference_uuid(ctx context.Context, field graphql.CollectedField, obj *model.ResourceReference) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ResourceReference_uuid(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UUID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ResourceReference_uuid(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ResourceReference",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ResourceReference_id(ctx context.Context, field graphql.CollectedField, obj *model.ResourceReference) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ResourceReference_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ResourceReference_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ResourceReference",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ResourceReference_type(ctx context.Context, field graphql.CollectedField, obj *model.ResourceReference) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ResourceReference_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ResourceReference_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ResourceReference",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ResourceReference_category(ctx context.Context, field graphql.CollectedField, obj *model.ResourceReference) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ResourceReference_category(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Category, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.ResourceCategory)
	fc.Result = res
	return ec.marshalNResourceCategory2backendgraphmodelResourceCategory(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ResourceReference_category(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ResourceReference",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ResourceCategory does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ResourceReference_state(ctx context.Context, field graphql.CollectedField, obj *model.ResourceReference) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ResourceReference_state(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.State, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.ResourceLifecycleState)
	fc.Result = res
	return ec.marshalNResourceLifecycleState2backendgraphmodelResourceLifecycleState(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ResourceReference_state(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ResourceReference",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ResourceLifecycleState does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ResourceRelationshipEdge_from(ctx context.Context, field graphql.CollectedField, obj *model.ResourceRelationshipEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ResourceRelationshipEdge_from(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.From, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ResourceRelationshipEdge_from(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ResourceRelationshipEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ResourceRelationshipEdge_to(ctx context.Context, field graphql.CollectedField, obj *model.ResourceRelationshipEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ResourceRelationshipEdge_to(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.To, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ResourceRelationshipEdge_to(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ResourceRelationshipEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ResourceRelationshipEdge_type(ctx context.Context, field graphql.CollectedField, obj *model.ResourceRelationshipEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ResourceRelationshipEdge_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.ResourceRelationshipType)
	fc.Result = res
	return ec.marshalNResourceRelationshipType2backendgraphmodelResourceRelationshipType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ResourceRelationshipEdge_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ResourceRelationshipEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ResourceRelationshipType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ResourceRelationships_dependsOn(ctx context.Context, field graphql.CollectedField, obj *model.ResourceRelationships) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ResourceRelationships_dependsOn(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DependsOn, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.ResourceReference)
	fc.Result = res
	return ec.marshalNResourceReference2backendgraphmodelResourceReference(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ResourceRelationships_dependsOn(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ResourceRelationships",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "uuid":
				return ec.fieldContext_ResourceReference_uuid(ctx, field)
			case "id":
				return ec.fieldContext_ResourceReference_id(ctx, field)
			case "type":
				return ec.fieldContext_ResourceReference_type(ctx, field)
			case "category":
				return ec.fieldContext_ResourceReference_category(ctx, field)
			case "state":
				return ec.fieldContext_ResourceReference_state(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ResourceReference", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ResourceRelationships_dependents(ctx context.Context, field graphql.CollectedField, obj *model.ResourceRelationships) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ResourceRelationships_dependents(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Dependents, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.ResourceReference)
	fc.Result = res
	return ec.marshalNResourceReference2backendgraphmodelResourceReference(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ResourceRelationships_dependents(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ResourceRelationships",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "uuid":
				return ec.fieldContext_ResourceReference_uuid(ctx, field)
			case "id":
				return ec.fieldContext_ResourceReference_id(ctx, field)
			case "type":
				return ec.fieldContext_ResourceReference_type(ctx, field)
			case "category":
				return ec.fieldContext_ResourceReference_category(ctx, field)
			case "state":
				return ec.fieldContext_ResourceReference_state(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ResourceReference", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ResourceRelationships_routesVia(ctx context.Context, field graphql.CollectedField, obj *model.ResourceRelationships) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ResourceRelationships_routesVia(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RoutesVia, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.ResourceReference)
	fc.Result = res
	return ec.marshalOResourceReference2backendgraphmodelResourceReference(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ResourceRelationships_routesVia(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ResourceRelationships",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "uuid":
				return ec.fieldContext_ResourceReference_uuid(ctx, field)
			case "id":
				return ec.fieldContext_ResourceReference_id(ctx, field)
			case "type":
				return ec.fieldContext_ResourceReference_type(ctx, field)
			case "category":
				return ec.fieldContext_ResourceReference_category(ctx, field)
			case "state":
				return ec.fieldContext_ResourceReference_state(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ResourceReference", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ResourceRelationships_routedBy(ctx context.Context, field graphql.CollectedField, obj *model.ResourceRelationships) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ResourceRelationships_routedBy(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RoutedBy, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.ResourceReference)
	fc.Result = res
	return ec.marshalNResourceReference2backendgraphmodelResourceReference(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ResourceRelationships_routedBy(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ResourceRelationships",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "uuid":
				return ec.fieldContext_ResourceReference_uuid(ctx, field)
			case "id":
				return ec.fieldContext_ResourceReference_id(ctx, field)
			case "type":
				return ec.fieldContext_ResourceReference_type(ctx, field)
			case "category":
				return ec.fieldContext_ResourceReference_category(ctx, field)
			case "state":
				return ec.fieldContext_ResourceReference_state(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ResourceReference", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ResourceRelationships_parent(ctx context.Context, field graphql.CollectedField, obj *model.ResourceRelationships) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ResourceRelationships_parent(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Parent, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.ResourceReference)
	fc.Result = res
	return ec.marshalOResourceReference2backendgraphmodelResourceReference(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ResourceRelationships_parent(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ResourceRelationships",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "uuid":
				return ec.fieldContext_ResourceReference_uuid(ctx, field)
			case "id":
				return ec.fieldContext_ResourceReference_id(ctx, field)
			case "type":
				return ec.fieldContext_ResourceReference_type(ctx, field)
			case "category":
				return ec.fieldContext_ResourceReference_category(ctx, field)
			case "state":
				return ec.fieldContext_ResourceReference_state(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ResourceReference", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ResourceRelationships_children(ctx context.Context, field graphql.CollectedField, obj *model.ResourceRelationships) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ResourceRelationships_children(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Children, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.ResourceReference)
	fc.Result = res
	return ec.marshalNResourceReference2backendgraphmodelResourceReference(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ResourceRelationships_children(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ResourceRelationships",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "uuid":
				return ec.fieldContext_ResourceReference_uuid(ctx, field)
			case "id":
				return ec.fieldContext_ResourceReference_id(ctx, field)
			case "type":
				return ec.fieldContext_ResourceReference_type(ctx, field)
			case "category":
				return ec.fieldContext_ResourceReference_category(ctx, field)
			case "state":
				return ec.fieldContext_ResourceReference_state(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ResourceReference", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ResourceRelationships_custom(ctx context.Context, field graphql.CollectedField, obj *model.ResourceRelationships) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ResourceRelationships_custom(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Custom, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOJSON2map(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ResourceRelationships_custom(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ResourceRelationships",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type JSON does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ResourceRuntimeEvent_id(ctx context.Context, field graphql.CollectedField, obj *model.ResourceRuntimeEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ResourceRuntimeEvent_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ResourceRuntimeEvent_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ResourceRuntimeEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ResourceRuntimeEvent_type(ctx context.Context, field graphql.CollectedField, obj *model.ResourceRuntimeEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ResourceRuntimeEvent_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ResourceRuntimeEvent_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ResourceRuntimeEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ResourceRuntimeEvent_runtime(ctx context.Context, field graphql.CollectedField, obj *model.ResourceRuntimeEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ResourceRuntimeEvent_runtime(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Runtime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.RuntimeState)
	fc.Result = res
	return ec.marshalNRuntimeState2backendgraphmodelRuntimeState(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ResourceRuntimeEvent_runtime(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ResourceRuntimeEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "isRunning":
				return ec.fieldContext_RuntimeState_isRunning(ctx, field)
			case "health":
				return ec.fieldContext_RuntimeState_health(ctx, field)
			case "errorMessage":
				return ec.fieldContext_RuntimeState_errorMessage(ctx, field)
			case "metrics":
				return ec.fieldContext_RuntimeState_metrics(ctx, field)
			case "lastUpdated":
				return ec.fieldContext_RuntimeState_lastUpdated(ctx, field)
			case "lastSuccessfulOperation":
				return ec.fieldContext_RuntimeState_lastSuccessfulOperation(ctx, field)
			case "activeConnections":
				return ec.fieldContext_RuntimeState_activeConnections(ctx, field)
			case "uptime":
				return ec.fieldContext_RuntimeState_uptime(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RuntimeState", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ResourceRuntimeEvent_timestamp(ctx context.Context, field graphql.CollectedField, obj *model.ResourceRuntimeEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ResourceRuntimeEvent_timestamp(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Timestamp, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNDateTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ResourceRuntimeEvent_timestamp(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ResourceRuntimeEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DateTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ResourceStateEvent_id(ctx context.Context, field graphql.CollectedField, obj *model.ResourceStateEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ResourceStateEvent_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ResourceStateEvent_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ResourceStateEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ResourceStateEvent_type(ctx context.Context, field graphql.CollectedField, obj *model.ResourceStateEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ResourceStateEvent_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ResourceStateEvent_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ResourceStateEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ResourceStateEvent_previousState(ctx context.Context, field graphql.CollectedField, obj *model.ResourceStateEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ResourceStateEvent_previousState(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PreviousState, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.ResourceLifecycleState)
	fc.Result = res
	return ec.marshalNResourceLifecycleState2backendgraphmodelResourceLifecycleState(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ResourceStateEvent_previousState(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ResourceStateEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ResourceLifecycleState does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ResourceStateEvent_newState(ctx context.Context, field graphql.CollectedField, obj *model.ResourceStateEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ResourceStateEvent_newState(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NewState, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.ResourceLifecycleState)
	fc.Result = res
	return ec.marshalNResourceLifecycleState2backendgraphmodelResourceLifecycleState(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ResourceStateEvent_newState(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ResourceStateEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ResourceLifecycleState does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ResourceStateEvent_errorMessage(ctx context.Context, field graphql.CollectedField, obj *model.ResourceStateEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ResourceStateEvent_errorMessage(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ErrorMessage, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ResourceStateEvent_errorMessage(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ResourceStateEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ResourceStateEvent_timestamp(ctx context.Context, field graphql.CollectedField, obj *model.ResourceStateEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ResourceStateEvent_timestamp(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Timestamp, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNDateTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ResourceStateEvent_timestamp(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ResourceStateEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DateTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ResourceUpdatedEvent_resourceId(ctx context.Context, field graphql.CollectedField, obj *model.ResourceUpdatedEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ResourceUpdatedEvent_resourceId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ResourceID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ResourceUpdatedEvent_resourceId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ResourceUpdatedEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ResourceUpdatedEvent_resourceType(ctx context.Context, field graphql.CollectedField, obj *model.ResourceUpdatedEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ResourceUpdatedEvent_resourceType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ResourceType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ResourceUpdatedEvent_resourceType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ResourceUpdatedEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ResourceUpdatedEvent_routerId(ctx context.Context, field graphql.CollectedField, obj *model.ResourceUpdatedEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ResourceUpdatedEvent_routerId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RouterID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ResourceUpdatedEvent_routerId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ResourceUpdatedEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ResourceUpdatedEvent_version(ctx context.Context, field graphql.CollectedField, obj *model.ResourceUpdatedEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ResourceUpdatedEvent_version(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Version, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ResourceUpdatedEvent_version(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ResourceUpdatedEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ResourceUpdatedEvent_changedFields(ctx context.Context, field graphql.CollectedField, obj *model.ResourceUpdatedEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ResourceUpdatedEvent_changedFields(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ChangedFields, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ResourceUpdatedEvent_changedFields(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ResourceUpdatedEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ResourceUpdatedEvent_changeType(ctx context.Context, field graphql.CollectedField, obj *model.ResourceUpdatedEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ResourceUpdatedEvent_changeType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ChangeType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.ChangeType)
	fc.Result = res
	return ec.marshalNChangeType2backendgraphmodelChangeType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ResourceUpdatedEvent_changeType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ResourceUpdatedEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ChangeType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ResourceUpdatedEvent_timestamp(ctx context.Context, field graphql.CollectedField, obj *model.ResourceUpdatedEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ResourceUpdatedEvent_timestamp(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Timestamp, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNDateTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ResourceUpdatedEvent_timestamp(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ResourceUpdatedEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DateTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RollbackChangeSetPayload_changeSet(ctx context.Context, field graphql.CollectedField, obj *model.RollbackChangeSetPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RollbackChangeSetPayload_changeSet(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ChangeSet, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.ChangeSet)
	fc.Result = res
	return ec.marshalOChangeSet2backendgraphmodelChangeSet(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RollbackChangeSetPayload_changeSet(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RollbackChangeSetPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ChangeSet_id(ctx, field)
			case "name":
				return ec.fieldContext_ChangeSet_name(ctx, field)
			case "description":
				return ec.fieldContext_ChangeSet_description(ctx, field)
			case "routerId":
				return ec.fieldContext_ChangeSet_routerId(ctx, field)
			case "items":
				return ec.fieldContext_ChangeSet_items(ctx, field)
			case "status":
				return ec.fieldContext_ChangeSet_status(ctx, field)
			case "validation":
				return ec.fieldContext_ChangeSet_validation(ctx, field)
			case "rollbackPlan":
				return ec.fieldContext_ChangeSet_rollbackPlan(ctx, field)
			case "error":
				return ec.fieldContext_ChangeSet_error(ctx, field)
			case "createdAt":
				return ec.fieldContext_ChangeSet_createdAt(ctx, field)
			case "applyStartedAt":
				return ec.fieldContext_ChangeSet_applyStartedAt(ctx, field)
			case "completedAt":
				return ec.fieldContext_ChangeSet_completedAt(ctx, field)
			case "createdBy":
				return ec.fieldContext_ChangeSet_createdBy(ctx, field)
			case "source":
				return ec.fieldContext_ChangeSet_source(ctx, field)
			case "version":
				return ec.fieldContext_ChangeSet_version(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ChangeSet", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RollbackChangeSetPayload_success(ctx context.Context, field graphql.CollectedField, obj *model.RollbackChangeSetPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RollbackChangeSetPayload_success(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Success, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RollbackChangeSetPayload_success(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RollbackChangeSetPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RollbackChangeSetPayload_failedItems(ctx context.Context, field graphql.CollectedField, obj *model.RollbackChangeSetPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RollbackChangeSetPayload_failedItems(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FailedItems, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RollbackChangeSetPayload_failedItems(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RollbackChangeSetPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RollbackChangeSetPayload_errors(ctx context.Context, field graphql.CollectedField, obj *model.RollbackChangeSetPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RollbackChangeSetPayload_errors(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Errors, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.MutationError)
	fc.Result = res
	return ec.marshalOMutationError2backendgraphmodelMutationError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RollbackChangeSetPayload_errors(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RollbackChangeSetPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "code":
				return ec.fieldContext_MutationError_code(ctx, field)
			case "message":
				return ec.fieldContext_MutationError_message(ctx, field)
			case "field":
				return ec.fieldContext_MutationError_field(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MutationError", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RollbackStep_itemId(ctx context.Context, field graphql.CollectedField, obj *model.RollbackStep) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RollbackStep_itemId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ItemID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RollbackStep_itemId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RollbackStep",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RollbackStep_operation(ctx context.Context, field graphql.CollectedField, obj *model.RollbackStep) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RollbackStep_operation(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Operation, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.RollbackOperation)
	fc.Result = res
	return ec.marshalNRollbackOperation2backendgraphmodelRollbackOperation(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RollbackStep_operation(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RollbackStep",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type RollbackOperation does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RollbackStep_restoreState(ctx context.Context, field graphql.CollectedField, obj *model.RollbackStep) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RollbackStep_restoreState(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RestoreState, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOJSON2map(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RollbackStep_restoreState(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RollbackStep",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type JSON does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RollbackStep_resourceUuid(ctx context.Context, field graphql.CollectedField, obj *model.RollbackStep) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RollbackStep_resourceUuid(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ResourceUUID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RollbackStep_resourceUuid(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RollbackStep",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RollbackStep_success(ctx context.Context, field graphql.CollectedField, obj *model.RollbackStep) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RollbackStep_success(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Success, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RollbackStep_success(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RollbackStep",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RollbackStep_error(ctx context.Context, field graphql.CollectedField, obj *model.RollbackStep) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RollbackStep_error(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Error, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RollbackStep_error(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RollbackStep",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RollbackStep_rollbackOrder(ctx context.Context, field graphql.CollectedField, obj *model.RollbackStep) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RollbackStep_rollbackOrder(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RollbackOrder, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RollbackStep_rollbackOrder(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RollbackStep",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Route_id(ctx context.Context, field graphql.CollectedField, obj *model.Route) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Route_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Route_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Route",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Route_destination(ctx context.Context, field graphql.CollectedField, obj *model.Route) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Route_destination(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Destination, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.CIDR)
	fc.Result = res
	return ec.marshalNCIDR2backendgraphmodelCIDR(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Route_destination(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Route",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type CIDR does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Route_gateway(ctx context.Context, field graphql.CollectedField, obj *model.Route) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Route_gateway(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Gateway, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.IPv4)
	fc.Result = res
	return ec.marshalOIPv42backendgraphmodelIPv4(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Route_gateway(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Route",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type IPv4 does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Route_interface(ctx context.Context, field graphql.CollectedField, obj *model.Route) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Route_interface(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Interface, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Route_interface(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Route",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Route_distance(ctx context.Context, field graphql.CollectedField, obj *model.Route) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Route_distance(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Distance, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			min, err := ec.unmarshalOInt2int(ctx, 1)
			if err != nil {
				return nil, err
			}
			max, err := ec.unmarshalOInt2int(ctx, 255)
			if err != nil {
				return nil, err
			}
			if ec.directives.Validate == nil {
				return nil, errors.New("directive validate is not implemented")
			}
			return ec.directives.Validate(ctx, obj, directive0, min, max, nil, nil, nil, nil)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(int); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be int`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Route_distance(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Route",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Route_routingMark(ctx context.Context, field graphql.CollectedField, obj *model.Route) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Route_routingMark(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RoutingMark, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Route_routingMark(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Route",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Route_routingTable(ctx context.Context, field graphql.CollectedField, obj *model.Route) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Route_routingTable(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RoutingTable, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Route_routingTable(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Route",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Route_type(ctx context.Context, field graphql.CollectedField, obj *model.Route) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Route_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.RouteType)
	fc.Result = res
	return ec.marshalNRouteType2backendgraphmodelRouteType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Route_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Route",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type RouteType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Route_scope(ctx context.Context, field graphql.CollectedField, obj *model.Route) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Route_scope(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Scope, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.RouteScope)
	fc.Result = res
	return ec.marshalNRouteScope2backendgraphmodelRouteScope(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Route_scope(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Route",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type RouteScope does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Route_comment(ctx context.Context, field graphql.CollectedField, obj *model.Route) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Route_comment(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Comment, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			maxLength, err := ec.unmarshalOInt2int(ctx, 255)
			if err != nil {
				return nil, err
			}
			if ec.directives.Validate == nil {
				return nil, errors.New("directive validate is not implemented")
			}
			return ec.directives.Validate(ctx, obj, directive0, nil, nil, nil, maxLength, nil, nil)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Route_comment(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Route",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Route_active(ctx context.Context, field graphql.CollectedField, obj *model.Route) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Route_active(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Active, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Route_active(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Route",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Route_disabled(ctx context.Context, field graphql.CollectedField, obj *model.Route) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Route_disabled(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Disabled, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Route_disabled(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Route",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RouteDeleteResult_success(ctx context.Context, field graphql.CollectedField, obj *model.RouteDeleteResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RouteDeleteResult_success(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Success, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RouteDeleteResult_success(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RouteDeleteResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RouteDeleteResult_message(ctx context.Context, field graphql.CollectedField, obj *model.RouteDeleteResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RouteDeleteResult_message(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RouteDeleteResult_message(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RouteDeleteResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RouteDeleteResult_impactAnalysis(ctx context.Context, field graphql.CollectedField, obj *model.RouteDeleteResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RouteDeleteResult_impactAnalysis(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ImpactAnalysis, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.RouteImpactAnalysis)
	fc.Result = res
	return ec.marshalNRouteImpactAnalysis2backendgraphmodelRouteImpactAnalysis(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RouteDeleteResult_impactAnalysis(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RouteDeleteResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "isDefaultRoute":
				return ec.fieldContext_RouteImpactAnalysis_isDefaultRoute(ctx, field)
			case "affectedTraffic":
				return ec.fieldContext_RouteImpactAnalysis_affectedTraffic(ctx, field)
			case "severity":
				return ec.fieldContext_RouteImpactAnalysis_severity(ctx, field)
			case "message":
				return ec.fieldContext_RouteImpactAnalysis_message(ctx, field)
			case "consequences":
				return ec.fieldContext_RouteImpactAnalysis_consequences(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RouteImpactAnalysis", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RouteImpactAnalysis_isDefaultRoute(ctx context.Context, field graphql.CollectedField, obj *model.RouteImpactAnalysis) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RouteImpactAnalysis_isDefaultRoute(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDefaultRoute, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RouteImpactAnalysis_isDefaultRoute(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RouteImpactAnalysis",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RouteImpactAnalysis_affectedTraffic(ctx context.Context, field graphql.CollectedField, obj *model.RouteImpactAnalysis) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RouteImpactAnalysis_affectedTraffic(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AffectedTraffic, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RouteImpactAnalysis_affectedTraffic(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RouteImpactAnalysis",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RouteImpactAnalysis_severity(ctx context.Context, field graphql.CollectedField, obj *model.RouteImpactAnalysis) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RouteImpactAnalysis_severity(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Severity, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.ConfirmationSeverity)
	fc.Result = res
	return ec.marshalNConfirmationSeverity2backendgraphmodelConfirmationSeverity(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RouteImpactAnalysis_severity(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RouteImpactAnalysis",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ConfirmationSeverity does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RouteImpactAnalysis_message(ctx context.Context, field graphql.CollectedField, obj *model.RouteImpactAnalysis) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RouteImpactAnalysis_message(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RouteImpactAnalysis_message(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RouteImpactAnalysis",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RouteImpactAnalysis_consequences(ctx context.Context, field graphql.CollectedField, obj *model.RouteImpactAnalysis) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RouteImpactAnalysis_consequences(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Consequences, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RouteImpactAnalysis_consequences(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RouteImpactAnalysis",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RouteMutationResult_success(ctx context.Context, field graphql.CollectedField, obj *model.RouteMutationResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RouteMutationResult_success(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Success, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RouteMutationResult_success(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RouteMutationResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RouteMutationResult_message(ctx context.Context, field graphql.CollectedField, obj *model.RouteMutationResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RouteMutationResult_message(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RouteMutationResult_message(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RouteMutationResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RouteMutationResult_route(ctx context.Context, field graphql.CollectedField, obj *model.RouteMutationResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RouteMutationResult_route(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Route, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Route)
	fc.Result = res
	return ec.marshalORoute2backendgraphmodelRoute(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RouteMutationResult_route(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RouteMutationResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Route_id(ctx, field)
			case "destination":
				return ec.fieldContext_Route_destination(ctx, field)
			case "gateway":
				return ec.fieldContext_Route_gateway(ctx, field)
			case "interface":
				return ec.fieldContext_Route_interface(ctx, field)
			case "distance":
				return ec.fieldContext_Route_distance(ctx, field)
			case "routingMark":
				return ec.fieldContext_Route_routingMark(ctx, field)
			case "routingTable":
				return ec.fieldContext_Route_routingTable(ctx, field)
			case "type":
				return ec.fieldContext_Route_type(ctx, field)
			case "scope":
				return ec.fieldContext_Route_scope(ctx, field)
			case "comment":
				return ec.fieldContext_Route_comment(ctx, field)
			case "active":
				return ec.fieldContext_Route_active(ctx, field)
			case "disabled":
				return ec.fieldContext_Route_disabled(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Route", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RouteResource_id(ctx context.Context, field graphql.CollectedField, obj *model.RouteResource) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RouteResource_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RouteResource_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RouteResource",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RouteResource_scopedId(ctx context.Context, field graphql.CollectedField, obj *model.RouteResource) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RouteResource_scopedId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ScopedID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RouteResource_scopedId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RouteResource",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RouteResource_type(ctx context.Context, field graphql.CollectedField, obj *model.RouteResource) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RouteResource_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RouteResource_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RouteResource",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RouteResource_category(ctx context.Context, field graphql.CollectedField, obj *model.RouteResource) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RouteResource_category(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Category, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.ResourceCategory)
	fc.Result = res
	return ec.marshalNResourceCategory2backendgraphmodelResourceCategory(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RouteResource_category(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RouteResource",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ResourceCategory does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RouteResource_configuration(ctx context.Context, field graphql.CollectedField, obj *model.RouteResource) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RouteResource_configuration(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Configuration, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalNJSON2map(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RouteResource_configuration(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RouteResource",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type JSON does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RouteResource_validation(ctx context.Context, field graphql.CollectedField, obj *model.RouteResource) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RouteResource_validation(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Validation, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.ValidationResult)
	fc.Result = res
	return ec.marshalOValidationResult2backendgraphmodelValidationResult(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RouteResource_validation(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RouteResource",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "canApply":
				return ec.fieldContext_ValidationResult_canApply(ctx, field)
			case "stage":
				return ec.fieldContext_ValidationResult_stage(ctx, field)
			case "errors":
				return ec.fieldContext_ValidationResult_errors(ctx, field)
			case "warnings":
				return ec.fieldContext_ValidationResult_warnings(ctx, field)
			case "conflicts":
				return ec.fieldContext_ValidationResult_conflicts(ctx, field)
			case "requiredDependencies":
				return ec.fieldContext_ValidationResult_requiredDependencies(ctx, field)
			case "validatedAt":
				return ec.fieldContext_ValidationResult_validatedAt(ctx, field)
			case "validationDurationMs":
				return ec.fieldContext_ValidationResult_validationDurationMs(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ValidationResult", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RouteResource_deployment(ctx context.Context, field graphql.CollectedField, obj *model.RouteResource) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RouteResource_deployment(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Deployment, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.DeploymentState)
	fc.Result = res
	return ec.marshalODeploymentState2backendgraphmodelDeploymentState(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RouteResource_deployment(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RouteResource",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "routerResourceId":
				return ec.fieldContext_DeploymentState_routerResourceId(ctx, field)
			case "appliedAt":
				return ec.fieldContext_DeploymentState_appliedAt(ctx, field)
			case "appliedBy":
				return ec.fieldContext_DeploymentState_appliedBy(ctx, field)
			case "routerVersion":
				return ec.fieldContext_DeploymentState_routerVersion(ctx, field)
			case "generatedFields":
				return ec.fieldContext_DeploymentState_generatedFields(ctx, field)
			case "isInSync":
				return ec.fieldContext_DeploymentState_isInSync(ctx, field)
			case "drift":
				return ec.fieldContext_DeploymentState_drift(ctx, field)
			case "applyOperationId":
				return ec.fieldContext_DeploymentState_applyOperationId(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DeploymentState", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RouteResource_runtime(ctx context.Context, field graphql.CollectedField, obj *model.RouteResource) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RouteResource_runtime(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Runtime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.RuntimeState)
	fc.Result = res
	return ec.marshalORuntimeState2backendgraphmodelRuntimeState(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RouteResource_runtime(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RouteResource",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "isRunning":
				return ec.fieldContext_RuntimeState_isRunning(ctx, field)
			case "health":
				return ec.fieldContext_RuntimeState_health(ctx, field)
			case "errorMessage":
				return ec.fieldContext_RuntimeState_errorMessage(ctx, field)
			case "metrics":
				return ec.fieldContext_RuntimeState_metrics(ctx, field)
			case "lastUpdated":
				return ec.fieldContext_RuntimeState_lastUpdated(ctx, field)
			case "lastSuccessfulOperation":
				return ec.fieldContext_RuntimeState_lastSuccessfulOperation(ctx, field)
			case "activeConnections":
				return ec.fieldContext_RuntimeState_activeConnections(ctx, field)
			case "uptime":
				return ec.fieldContext_RuntimeState_uptime(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RuntimeState", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RouteResource_telemetry(ctx context.Context, field graphql.CollectedField, obj *model.RouteResource) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RouteResource_telemetry(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Telemetry, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.TelemetryData)
	fc.Result = res
	return ec.marshalOTelemetryData2backendgraphmodelTelemetryData(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RouteResource_telemetry(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RouteResource",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "bandwidthHistory":
				return ec.fieldContext_TelemetryData_bandwidthHistory(ctx, field)
			case "uptimeHistory":
				return ec.fieldContext_TelemetryData_uptimeHistory(ctx, field)
			case "hourlyStats":
				return ec.fieldContext_TelemetryData_hourlyStats(ctx, field)
			case "dailyStats":
				return ec.fieldContext_TelemetryData_dailyStats(ctx, field)
			case "dataStartedAt":
				return ec.fieldContext_TelemetryData_dataStartedAt(ctx, field)
			case "lastUpdatedAt":
				return ec.fieldContext_TelemetryData_lastUpdatedAt(ctx, field)
			case "retentionDays":
				return ec.fieldContext_TelemetryData_retentionDays(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TelemetryData", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RouteResource_metadata(ctx context.Context, field graphql.CollectedField, obj *model.RouteResource) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RouteResource_metadata(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Metadata, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.ResourceMetadata)
	fc.Result = res
	return ec.marshalNResourceMetadata2backendgraphmodelResourceMetadata(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RouteResource_metadata(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RouteResource",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "createdAt":
				return ec.fieldContext_ResourceMetadata_createdAt(ctx, field)
			case "createdBy":
				return ec.fieldContext_ResourceMetadata_createdBy(ctx, field)
			case "updatedAt":
				return ec.fieldContext_ResourceMetadata_updatedAt(ctx, field)
			case "updatedBy":
				return ec.fieldContext_ResourceMetadata_updatedBy(ctx, field)
			case "state":
				return ec.fieldContext_ResourceMetadata_state(ctx, field)
			case "version":
				return ec.fieldContext_ResourceMetadata_version(ctx, field)
			case "tags":
				return ec.fieldContext_ResourceMetadata_tags(ctx, field)
			case "description":
				return ec.fieldContext_ResourceMetadata_description(ctx, field)
			case "isFavorite":
				return ec.fieldContext_ResourceMetadata_isFavorite(ctx, field)
			case "isPinned":
				return ec.fieldContext_ResourceMetadata_isPinned(ctx, field)
			case "notes":
				return ec.fieldContext_ResourceMetadata_notes(ctx, field)
			case "recentChanges":
				return ec.fieldContext_ResourceMetadata_recentChanges(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ResourceMetadata", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RouteResource_relationships(ctx context.Context, field graphql.CollectedField, obj *model.RouteResource) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RouteResource_relationships(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Relationships, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.ResourceRelationships)
	fc.Result = res
	return ec.marshalOResourceRelationships2backendgraphmodelResourceRelationships(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RouteResource_relationships(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RouteResource",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "dependsOn":
				return ec.fieldContext_ResourceRelationships_dependsOn(ctx, field)
			case "dependents":
				return ec.fieldContext_ResourceRelationships_dependents(ctx, field)
			case "routesVia":
				return ec.fieldContext_ResourceRelationships_routesVia(ctx, field)
			case "routedBy":
				return ec.fieldContext_ResourceRelationships_routedBy(ctx, field)
			case "parent":
				return ec.fieldContext_ResourceRelationships_parent(ctx, field)
			case "children":
				return ec.fieldContext_ResourceRelationships_children(ctx, field)
			case "custom":
				return ec.fieldContext_ResourceRelationships_custom(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ResourceRelationships", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RouteResource_platform(ctx context.Context, field graphql.CollectedField, obj *model.RouteResource) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RouteResource_platform(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Platform, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.PlatformInfo)
	fc.Result = res
	return ec.marshalOPlatformInfo2backendgraphmodelPlatformInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RouteResource_platform(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RouteResource",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "current":
				return ec.fieldContext_PlatformInfo_current(ctx, field)
			case "capabilities":
				return ec.fieldContext_PlatformInfo_capabilities(ctx, field)
			case "fieldMappings":
				return ec.fieldContext_PlatformInfo_fieldMappings(ctx, field)
			case "limitations":
				return ec.fieldContext_PlatformInfo_limitations(ctx, field)
			case "features":
				return ec.fieldContext_PlatformInfo_features(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PlatformInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RouteResource_dstAddress(ctx context.Context, field graphql.CollectedField, obj *model.RouteResource) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RouteResource_dstAddress(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DstAddress, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.CIDR)
	fc.Result = res
	return ec.marshalNCIDR2backendgraphmodelCIDR(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RouteResource_dstAddress(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RouteResource",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type CIDR does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RouteResource_gateway(ctx context.Context, field graphql.CollectedField, obj *model.RouteResource) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RouteResource_gateway(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Gateway, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.IPv4)
	fc.Result = res
	return ec.marshalOIPv42backendgraphmodelIPv4(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RouteResource_gateway(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RouteResource",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type IPv4 does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RouteResource_interface(ctx context.Context, field graphql.CollectedField, obj *model.RouteResource) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RouteResource_interface(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Interface, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RouteResource_interface(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RouteResource",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RouteResource_distance(ctx context.Context, field graphql.CollectedField, obj *model.RouteResource) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RouteResource_distance(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Distance, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RouteResource_distance(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RouteResource",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RouteResource_active(ctx context.Context, field graphql.CollectedField, obj *model.RouteResource) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RouteResource_active(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Active, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RouteResource_active(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RouteResource",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Router_id(ctx context.Context, field graphql.CollectedField, obj *model.Router) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Router_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Router_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Router",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Router_name(ctx context.Context, field graphql.CollectedField, obj *model.Router) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Router_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Router_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Router",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Router_host(ctx context.Context, field graphql.CollectedField, obj *model.Router) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Router_host(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Host, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Router_host(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Router",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Router_port(ctx context.Context, field graphql.CollectedField, obj *model.Router) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Router_port(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Port, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Router_port(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Router",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Router_status(ctx context.Context, field graphql.CollectedField, obj *model.Router) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Router_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.ConnectionStatus)
	fc.Result = res
	return ec.marshalNConnectionStatus2backendgraphmodelConnectionStatus(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Router_status(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Router",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ConnectionStatus does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Router_platform(ctx context.Context, field graphql.CollectedField, obj *model.Router) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Router_platform(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Platform, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.RouterPlatform)
	fc.Result = res
	return ec.marshalNRouterPlatform2backendgraphmodelRouterPlatform(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Router_platform(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Router",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type RouterPlatform does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Router_version(ctx context.Context, field graphql.CollectedField, obj *model.Router) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Router_version(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Version, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Router_version(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Router",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Router_model(ctx context.Context, field graphql.CollectedField, obj *model.Router) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Router_model(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Model, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Router_model(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Router",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Router_uptime(ctx context.Context, field graphql.CollectedField, obj *model.Router) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Router_uptime(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Uptime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Duration)
	fc.Result = res
	return ec.marshalODuration2backendgraphmodelDuration(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Router_uptime(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Router",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Duration does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Router_lastConnected(ctx context.Context, field graphql.CollectedField, obj *model.Router) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Router_lastConnected(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LastConnected, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalODateTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Router_lastConnected(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Router",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DateTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Router_createdAt(ctx context.Context, field graphql.CollectedField, obj *model.Router) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Router_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNDateTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Router_createdAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Router",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DateTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Router_updatedAt(ctx context.Context, field graphql.CollectedField, obj *model.Router) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Router_updatedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNDateTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Router_updatedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Router",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DateTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Router_capabilities(ctx context.Context, field graphql.CollectedField, obj *model.Router) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Router_capabilities(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Capabilities, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.RouterCapabilities)
	fc.Result = res
	return ec.marshalORouterCapabilities2backendgraphmodelRouterCapabilities(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Router_capabilities(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Router",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hardware":
				return ec.fieldContext_RouterCapabilities_hardware(ctx, field)
			case "software":
				return ec.fieldContext_RouterCapabilities_software(ctx, field)
			case "container":
				return ec.fieldContext_RouterCapabilities_container(ctx, field)
			case "capabilities":
				return ec.fieldContext_RouterCapabilities_capabilities(ctx, field)
			case "vifRequirements":
				return ec.fieldContext_RouterCapabilities_vifRequirements(ctx, field)
			case "supportedFeatures":
				return ec.fieldContext_RouterCapabilities_supportedFeatures(ctx, field)
			case "unsupportedFeatures":
				return ec.fieldContext_RouterCapabilities_unsupportedFeatures(ctx, field)
			case "routerOSVersion":
				return ec.fieldContext_RouterCapabilities_routerOSVersion(ctx, field)
			case "detectedAt":
				return ec.fieldContext_RouterCapabilities_detectedAt(ctx, field)
			case "expiresAt":
				return ec.fieldContext_RouterCapabilities_expiresAt(ctx, field)
			case "isRefreshing":
				return ec.fieldContext_RouterCapabilities_isRefreshing(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RouterCapabilities", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RouterAddedEvent_router(ctx context.Context, field graphql.CollectedField, obj *model.RouterAddedEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RouterAddedEvent_router(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Router, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Router)
	fc.Result = res
	return ec.marshalNRouter2backendgraphmodelRouter(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RouterAddedEvent_router(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RouterAddedEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Router_id(ctx, field)
			case "name":
				return ec.fieldContext_Router_name(ctx, field)
			case "host":
				return ec.fieldContext_Router_host(ctx, field)
			case "port":
				return ec.fieldContext_Router_port(ctx, field)
			case "status":
				return ec.fieldContext_Router_status(ctx, field)
			case "platform":
				return ec.fieldContext_Router_platform(ctx, field)
			case "version":
				return ec.fieldContext_Router_version(ctx, field)
			case "model":
				return ec.fieldContext_Router_model(ctx, field)
			case "uptime":
				return ec.fieldContext_Router_uptime(ctx, field)
			case "lastConnected":
				return ec.fieldContext_Router_lastConnected(ctx, field)
			case "createdAt":
				return ec.fieldContext_Router_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Router_updatedAt(ctx, field)
			case "capabilities":
				return ec.fieldContext_Router_capabilities(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Router", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RouterAddedEvent_protocolUsed(ctx context.Context, field graphql.CollectedField, obj *model.RouterAddedEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RouterAddedEvent_protocolUsed(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ProtocolUsed, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.Protocol)
	fc.Result = res
	return ec.marshalNProtocol2backendgraphmodelProtocol(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RouterAddedEvent_protocolUsed(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RouterAddedEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Protocol does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RouterAddedEvent_addedBy(ctx context.Context, field graphql.CollectedField, obj *model.RouterAddedEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RouterAddedEvent_addedBy(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AddedBy, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RouterAddedEvent_addedBy(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RouterAddedEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RouterAddedEvent_timestamp(ctx context.Context, field graphql.CollectedField, obj *model.RouterAddedEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RouterAddedEvent_timestamp(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Timestamp, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNDateTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RouterAddedEvent_timestamp(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RouterAddedEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DateTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RouterCapabilities_hardware(ctx context.Context, field graphql.CollectedField, obj *model.RouterCapabilities) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RouterCapabilities_hardware(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Hardware, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.HardwareInfo)
	fc.Result = res
	return ec.marshalNHardwareInfo2backendgraphmodelHardwareInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RouterCapabilities_hardware(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RouterCapabilities",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "architecture":
				return ec.fieldContext_HardwareInfo_architecture(ctx, field)
			case "model":
				return ec.fieldContext_HardwareInfo_model(ctx, field)
			case "boardName":
				return ec.fieldContext_HardwareInfo_boardName(ctx, field)
			case "totalMemory":
				return ec.fieldContext_HardwareInfo_totalMemory(ctx, field)
			case "availableStorage":
				return ec.fieldContext_HardwareInfo_availableStorage(ctx, field)
			case "cpuCount":
				return ec.fieldContext_HardwareInfo_cpuCount(ctx, field)
			case "hasWirelessChip":
				return ec.fieldContext_HardwareInfo_hasWirelessChip(ctx, field)
			case "hasLTEModule":
				return ec.fieldContext_HardwareInfo_hasLTEModule(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type HardwareInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RouterCapabilities_software(ctx context.Context, field graphql.CollectedField, obj *model.RouterCapabilities) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RouterCapabilities_software(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Software, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.SoftwareInfo)
	fc.Result = res
	return ec.marshalNSoftwareInfo2backendgraphmodelSoftwareInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RouterCapabilities_software(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RouterCapabilities",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "version":
				return ec.fieldContext_SoftwareInfo_version(ctx, field)
			case "versionMajor":
				return ec.fieldContext_SoftwareInfo_versionMajor(ctx, field)
			case "versionMinor":
				return ec.fieldContext_SoftwareInfo_versionMinor(ctx, field)
			case "versionPatch":
				return ec.fieldContext_SoftwareInfo_versionPatch(ctx, field)
			case "installedPackages":
				return ec.fieldContext_SoftwareInfo_installedPackages(ctx, field)
			case "licenseLevel":
				return ec.fieldContext_SoftwareInfo_licenseLevel(ctx, field)
			case "updateChannel":
				return ec.fieldContext_SoftwareInfo_updateChannel(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SoftwareInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RouterCapabilities_container(ctx context.Context, field graphql.CollectedField, obj *model.RouterCapabilities) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RouterCapabilities_container(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Container, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.ContainerInfo)
	fc.Result = res
	return ec.marshalNContainerInfo2backendgraphmodelContainerInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RouterCapabilities_container(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RouterCapabilities",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "packageInstalled":
				return ec.fieldContext_ContainerInfo_packageInstalled(ctx, field)
			case "enabled":
				return ec.fieldContext_ContainerInfo_enabled(ctx, field)
			case "registryConfigured":
				return ec.fieldContext_ContainerInfo_registryConfigured(ctx, field)
			case "storageAvailable":
				return ec.fieldContext_ContainerInfo_storageAvailable(ctx, field)
			case "supportsNetworkNamespace":
				return ec.fieldContext_ContainerInfo_supportsNetworkNamespace(ctx, field)
			case "maxContainers":
				return ec.fieldContext_ContainerInfo_maxContainers(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ContainerInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RouterCapabilities_capabilities(ctx context.Context, field graphql.CollectedField, obj *model.RouterCapabilities) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RouterCapabilities_capabilities(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Capabilities, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.CapabilityEntry)
	fc.Result = res
	return ec.marshalNCapabilityEntry2backendgraphmodelCapabilityEntry(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RouterCapabilities_capabilities(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RouterCapabilities",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "capability":
				return ec.fieldContext_CapabilityEntry_capability(ctx, field)
			case "level":
				return ec.fieldContext_CapabilityEntry_level(ctx, field)
			case "description":
				return ec.fieldContext_CapabilityEntry_description(ctx, field)
			case "guidance":
				return ec.fieldContext_CapabilityEntry_guidance(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CapabilityEntry", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RouterCapabilities_vifRequirements(ctx context.Context, field graphql.CollectedField, obj *model.RouterCapabilities) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RouterCapabilities_vifRequirements(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.VifRequirements, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.VIFRequirements)
	fc.Result = res
	return ec.marshalNVIFRequirements2backendgraphmodelVIFRequirements(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RouterCapabilities_vifRequirements(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RouterCapabilities",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "met":
				return ec.fieldContext_VIFRequirements_met(ctx, field)
			case "routerOSVersion":
				return ec.fieldContext_VIFRequirements_routerOSVersion(ctx, field)
			case "containerPackage":
				return ec.fieldContext_VIFRequirements_containerPackage(ctx, field)
			case "containerEnabled":
				return ec.fieldContext_VIFRequirements_containerEnabled(ctx, field)
			case "sufficientStorage":
				return ec.fieldContext_VIFRequirements_sufficientStorage(ctx, field)
			case "networkNamespace":
				return ec.fieldContext_VIFRequirements_networkNamespace(ctx, field)
			case "missingReasons":
				return ec.fieldContext_VIFRequirements_missingReasons(ctx, field)
			case "guidanceSteps":
				return ec.fieldContext_VIFRequirements_guidanceSteps(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type VIFRequirements", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RouterCapabilities_supportedFeatures(ctx context.Context, field graphql.CollectedField, obj *model.RouterCapabilities) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RouterCapabilities_supportedFeatures(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SupportedFeatures, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.FeatureSupport)
	fc.Result = res
	return ec.marshalNFeatureSupport2backendgraphmodelFeatureSupport(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RouterCapabilities_supportedFeatures(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RouterCapabilities",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "featureId":
				return ec.fieldContext_FeatureSupport_featureId(ctx, field)
			case "name":
				return ec.fieldContext_FeatureSupport_name(ctx, field)
			case "supported":
				return ec.fieldContext_FeatureSupport_supported(ctx, field)
			case "level":
				return ec.fieldContext_FeatureSupport_level(ctx, field)
			case "reason":
				return ec.fieldContext_FeatureSupport_reason(ctx, field)
			case "requiredVersion":
				return ec.fieldContext_FeatureSupport_requiredVersion(ctx, field)
			case "upgradeUrl":
				return ec.fieldContext_FeatureSupport_upgradeUrl(ctx, field)
			case "requiredPackages":
				return ec.fieldContext_FeatureSupport_requiredPackages(ctx, field)
			case "missingPackages":
				return ec.fieldContext_FeatureSupport_missingPackages(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FeatureSupport", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RouterCapabilities_unsupportedFeatures(ctx context.Context, field graphql.CollectedField, obj *model.RouterCapabilities) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RouterCapabilities_unsupportedFeatures(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UnsupportedFeatures, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.FeatureSupport)
	fc.Result = res
	return ec.marshalNFeatureSupport2backendgraphmodelFeatureSupport(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RouterCapabilities_unsupportedFeatures(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RouterCapabilities",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "featureId":
				return ec.fieldContext_FeatureSupport_featureId(ctx, field)
			case "name":
				return ec.fieldContext_FeatureSupport_name(ctx, field)
			case "supported":
				return ec.fieldContext_FeatureSupport_supported(ctx, field)
			case "level":
				return ec.fieldContext_FeatureSupport_level(ctx, field)
			case "reason":
				return ec.fieldContext_FeatureSupport_reason(ctx, field)
			case "requiredVersion":
				return ec.fieldContext_FeatureSupport_requiredVersion(ctx, field)
			case "upgradeUrl":
				return ec.fieldContext_FeatureSupport_upgradeUrl(ctx, field)
			case "requiredPackages":
				return ec.fieldContext_FeatureSupport_requiredPackages(ctx, field)
			case "missingPackages":
				return ec.fieldContext_FeatureSupport_missingPackages(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FeatureSupport", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RouterCapabilities_routerOSVersion(ctx context.Context, field graphql.CollectedField, obj *model.RouterCapabilities) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RouterCapabilities_routerOSVersion(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RouterOSVersion, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.RouterOSVersion)
	fc.Result = res
	return ec.marshalNRouterOSVersion2backendgraphmodelRouterOSVersion(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RouterCapabilities_routerOSVersion(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RouterCapabilities",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "raw":
				return ec.fieldContext_RouterOSVersion_raw(ctx, field)
			case "major":
				return ec.fieldContext_RouterOSVersion_major(ctx, field)
			case "minor":
				return ec.fieldContext_RouterOSVersion_minor(ctx, field)
			case "patch":
				return ec.fieldContext_RouterOSVersion_patch(ctx, field)
			case "channel":
				return ec.fieldContext_RouterOSVersion_channel(ctx, field)
			case "isCHR":
				return ec.fieldContext_RouterOSVersion_isCHR(ctx, field)
			case "supportsFeature":
				return ec.fieldContext_RouterOSVersion_supportsFeature(ctx, field)
			case "isAtLeast":
				return ec.fieldContext_RouterOSVersion_isAtLeast(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RouterOSVersion", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RouterCapabilities_detectedAt(ctx context.Context, field graphql.CollectedField, obj *model.RouterCapabilities) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RouterCapabilities_detectedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DetectedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNDateTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RouterCapabilities_detectedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RouterCapabilities",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DateTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RouterCapabilities_expiresAt(ctx context.Context, field graphql.CollectedField, obj *model.RouterCapabilities) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RouterCapabilities_expiresAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ExpiresAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNDateTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RouterCapabilities_expiresAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RouterCapabilities",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DateTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RouterCapabilities_isRefreshing(ctx context.Context, field graphql.CollectedField, obj *model.RouterCapabilities) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RouterCapabilities_isRefreshing(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsRefreshing, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RouterCapabilities_isRefreshing(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RouterCapabilities",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RouterConnection_edges(ctx context.Context, field graphql.CollectedField, obj *model.RouterConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RouterConnection_edges(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Edges, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.RouterEdge)
	fc.Result = res
	return ec.marshalNRouterEdge2backendgraphmodelRouterEdge(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RouterConnection_edges(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RouterConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "node":
				return ec.fieldContext_RouterEdge_node(ctx, field)
			case "cursor":
				return ec.fieldContext_RouterEdge_cursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RouterEdge", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RouterConnection_pageInfo(ctx context.Context, field graphql.CollectedField, obj *model.RouterConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RouterConnection_pageInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.PageInfo)
	fc.Result = res
	return ec.marshalNPageInfo2backendgraphmodelPageInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RouterConnection_pageInfo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RouterConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			case "hasPreviousPage":
				return ec.fieldContext_PageInfo_hasPreviousPage(ctx, field)
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RouterConnection_totalCount(ctx context.Context, field graphql.CollectedField, obj *model.RouterConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RouterConnection_totalCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RouterConnection_totalCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RouterConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RouterCredentials_routerId(ctx context.Context, field graphql.CollectedField, obj *model.RouterCredentials) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RouterCredentials_routerId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RouterID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RouterCredentials_routerId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RouterCredentials",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RouterCredentials_username(ctx context.Context, field graphql.CollectedField, obj *model.RouterCredentials) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RouterCredentials_username(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Username, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RouterCredentials_username(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RouterCredentials",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RouterCredentials_hasPassword(ctx context.Context, field graphql.CollectedField, obj *model.RouterCredentials) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RouterCredentials_hasPassword(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HasPassword, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RouterCredentials_hasPassword(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RouterCredentials",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RouterCredentials_encryptionStatus(ctx context.Context, field graphql.CollectedField, obj *model.RouterCredentials) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RouterCredentials_encryptionStatus(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EncryptionStatus, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RouterCredentials_encryptionStatus(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RouterCredentials",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RouterCredentials_keyVersion(ctx context.Context, field graphql.CollectedField, obj *model.RouterCredentials) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RouterCredentials_keyVersion(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.KeyVersion, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RouterCredentials_keyVersion(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RouterCredentials",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RouterCredentials_lastUpdated(ctx context.Context, field graphql.CollectedField, obj *model.RouterCredentials) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RouterCredentials_lastUpdated(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LastUpdated, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNDateTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RouterCredentials_lastUpdated(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RouterCredentials",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DateTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RouterCredentials_createdAt(ctx context.Context, field graphql.CollectedField, obj *model.RouterCredentials) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RouterCredentials_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNDateTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RouterCredentials_createdAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RouterCredentials",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DateTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RouterEdge_node(ctx context.Context, field graphql.CollectedField, obj *model.RouterEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RouterEdge_node(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Node, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Router)
	fc.Result = res
	return ec.marshalNRouter2backendgraphmodelRouter(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RouterEdge_node(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RouterEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Router_id(ctx, field)
			case "name":
				return ec.fieldContext_Router_name(ctx, field)
			case "host":
				return ec.fieldContext_Router_host(ctx, field)
			case "port":
				return ec.fieldContext_Router_port(ctx, field)
			case "status":
				return ec.fieldContext_Router_status(ctx, field)
			case "platform":
				return ec.fieldContext_Router_platform(ctx, field)
			case "version":
				return ec.fieldContext_Router_version(ctx, field)
			case "model":
				return ec.fieldContext_Router_model(ctx, field)
			case "uptime":
				return ec.fieldContext_Router_uptime(ctx, field)
			case "lastConnected":
				return ec.fieldContext_Router_lastConnected(ctx, field)
			case "createdAt":
				return ec.fieldContext_Router_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Router_updatedAt(ctx, field)
			case "capabilities":
				return ec.fieldContext_Router_capabilities(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Router", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RouterEdge_cursor(ctx context.Context, field graphql.CollectedField, obj *model.RouterEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RouterEdge_cursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RouterEdge_cursor(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RouterEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RouterOSInfo_version(ctx context.Context, field graphql.CollectedField, obj *model.RouterOSInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RouterOSInfo_version(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Version, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RouterOSInfo_version(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RouterOSInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RouterOSInfo_boardName(ctx context.Context, field graphql.CollectedField, obj *model.RouterOSInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RouterOSInfo_boardName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BoardName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RouterOSInfo_boardName(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RouterOSInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RouterOSInfo_architecture(ctx context.Context, field graphql.CollectedField, obj *model.RouterOSInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RouterOSInfo_architecture(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Architecture, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RouterOSInfo_architecture(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RouterOSInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RouterOSInfo_platform(ctx context.Context, field graphql.CollectedField, obj *model.RouterOSInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RouterOSInfo_platform(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Platform, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RouterOSInfo_platform(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RouterOSInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RouterOSVersion_raw(ctx context.Context, field graphql.CollectedField, obj *model.RouterOSVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RouterOSVersion_raw(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Raw, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RouterOSVersion_raw(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RouterOSVersion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RouterOSVersion_major(ctx context.Context, field graphql.CollectedField, obj *model.RouterOSVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RouterOSVersion_major(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Major, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RouterOSVersion_major(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RouterOSVersion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RouterOSVersion_minor(ctx context.Context, field graphql.CollectedField, obj *model.RouterOSVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RouterOSVersion_minor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Minor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RouterOSVersion_minor(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RouterOSVersion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RouterOSVersion_patch(ctx context.Context, field graphql.CollectedField, obj *model.RouterOSVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RouterOSVersion_patch(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Patch, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RouterOSVersion_patch(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RouterOSVersion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RouterOSVersion_channel(ctx context.Context, field graphql.CollectedField, obj *model.RouterOSVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RouterOSVersion_channel(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Channel, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RouterOSVersion_channel(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RouterOSVersion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RouterOSVersion_isCHR(ctx context.Context, field graphql.CollectedField, obj *model.RouterOSVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RouterOSVersion_isCHR(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsChr, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RouterOSVersion_isCHR(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RouterOSVersion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RouterOSVersion_supportsFeature(ctx context.Context, field graphql.CollectedField, obj *model.RouterOSVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RouterOSVersion_supportsFeature(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SupportsFeature, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RouterOSVersion_supportsFeature(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RouterOSVersion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_RouterOSVersion_supportsFeature_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _RouterOSVersion_isAtLeast(ctx context.Context, field graphql.CollectedField, obj *model.RouterOSVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RouterOSVersion_isAtLeast(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsAtLeast, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RouterOSVersion_isAtLeast(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RouterOSVersion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_RouterOSVersion_isAtLeast_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _RouterStatusEvent_router(ctx context.Context, field graphql.CollectedField, obj *model.RouterStatusEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RouterStatusEvent_router(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Router, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Router)
	fc.Result = res
	return ec.marshalNRouter2backendgraphmodelRouter(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RouterStatusEvent_router(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RouterStatusEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Router_id(ctx, field)
			case "name":
				return ec.fieldContext_Router_name(ctx, field)
			case "host":
				return ec.fieldContext_Router_host(ctx, field)
			case "port":
				return ec.fieldContext_Router_port(ctx, field)
			case "status":
				return ec.fieldContext_Router_status(ctx, field)
			case "platform":
				return ec.fieldContext_Router_platform(ctx, field)
			case "version":
				return ec.fieldContext_Router_version(ctx, field)
			case "model":
				return ec.fieldContext_Router_model(ctx, field)
			case "uptime":
				return ec.fieldContext_Router_uptime(ctx, field)
			case "lastConnected":
				return ec.fieldContext_Router_lastConnected(ctx, field)
			case "createdAt":
				return ec.fieldContext_Router_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Router_updatedAt(ctx, field)
			case "capabilities":
				return ec.fieldContext_Router_capabilities(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Router", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RouterStatusEvent_previousStatus(ctx context.Context, field graphql.CollectedField, obj *model.RouterStatusEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RouterStatusEvent_previousStatus(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PreviousStatus, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.ConnectionStatus)
	fc.Result = res
	return ec.marshalNConnectionStatus2backendgraphmodelConnectionStatus(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RouterStatusEvent_previousStatus(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RouterStatusEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ConnectionStatus does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RouterStatusEvent_newStatus(ctx context.Context, field graphql.CollectedField, obj *model.RouterStatusEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RouterStatusEvent_newStatus(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NewStatus, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.ConnectionStatus)
	fc.Result = res
	return ec.marshalNConnectionStatus2backendgraphmodelConnectionStatus(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RouterStatusEvent_newStatus(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RouterStatusEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ConnectionStatus does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RouterStatusEvent_timestamp(ctx context.Context, field graphql.CollectedField, obj *model.RouterStatusEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RouterStatusEvent_timestamp(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Timestamp, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNDateTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RouterStatusEvent_timestamp(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RouterStatusEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DateTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RunTroubleshootStepPayload_step(ctx context.Context, field graphql.CollectedField, obj *model.RunTroubleshootStepPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RunTroubleshootStepPayload_step(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Step, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.TroubleshootStep)
	fc.Result = res
	return ec.marshalNTroubleshootStep2backendgraphmodelTroubleshootStep(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RunTroubleshootStepPayload_step(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RunTroubleshootStepPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_TroubleshootStep_id(ctx, field)
			case "name":
				return ec.fieldContext_TroubleshootStep_name(ctx, field)
			case "description":
				return ec.fieldContext_TroubleshootStep_description(ctx, field)
			case "status":
				return ec.fieldContext_TroubleshootStep_status(ctx, field)
			case "result":
				return ec.fieldContext_TroubleshootStep_result(ctx, field)
			case "fix":
				return ec.fieldContext_TroubleshootStep_fix(ctx, field)
			case "startedAt":
				return ec.fieldContext_TroubleshootStep_startedAt(ctx, field)
			case "completedAt":
				return ec.fieldContext_TroubleshootStep_completedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TroubleshootStep", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RunTroubleshootStepPayload_errors(ctx context.Context, field graphql.CollectedField, obj *model.RunTroubleshootStepPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RunTroubleshootStepPayload_errors(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Errors, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.MutationError)
	fc.Result = res
	return ec.marshalOMutationError2backendgraphmodelMutationError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RunTroubleshootStepPayload_errors(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RunTroubleshootStepPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "code":
				return ec.fieldContext_MutationError_code(ctx, field)
			case "message":
				return ec.fieldContext_MutationError_message(ctx, field)
			case "field":
				return ec.fieldContext_MutationError_field(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MutationError", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RuntimeMetrics_bytesIn(ctx context.Context, field graphql.CollectedField, obj *model.RuntimeMetrics) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RuntimeMetrics_bytesIn(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BytesIn, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Size)
	fc.Result = res
	return ec.marshalOSize2backendgraphmodelSize(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RuntimeMetrics_bytesIn(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RuntimeMetrics",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Size does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RuntimeMetrics_bytesOut(ctx context.Context, field graphql.CollectedField, obj *model.RuntimeMetrics) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RuntimeMetrics_bytesOut(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BytesOut, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Size)
	fc.Result = res
	return ec.marshalOSize2backendgraphmodelSize(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RuntimeMetrics_bytesOut(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RuntimeMetrics",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Size does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RuntimeMetrics_packetsIn(ctx context.Context, field graphql.CollectedField, obj *model.RuntimeMetrics) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RuntimeMetrics_packetsIn(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PacketsIn, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RuntimeMetrics_packetsIn(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RuntimeMetrics",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RuntimeMetrics_packetsOut(ctx context.Context, field graphql.CollectedField, obj *model.RuntimeMetrics) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RuntimeMetrics_packetsOut(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PacketsOut, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RuntimeMetrics_packetsOut(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RuntimeMetrics",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RuntimeMetrics_errors(ctx context.Context, field graphql.CollectedField, obj *model.RuntimeMetrics) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RuntimeMetrics_errors(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Errors, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RuntimeMetrics_errors(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RuntimeMetrics",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RuntimeMetrics_drops(ctx context.Context, field graphql.CollectedField, obj *model.RuntimeMetrics) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RuntimeMetrics_drops(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Drops, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RuntimeMetrics_drops(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RuntimeMetrics",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RuntimeMetrics_throughputIn(ctx context.Context, field graphql.CollectedField, obj *model.RuntimeMetrics) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RuntimeMetrics_throughputIn(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ThroughputIn, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Size)
	fc.Result = res
	return ec.marshalOSize2backendgraphmodelSize(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RuntimeMetrics_throughputIn(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RuntimeMetrics",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Size does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RuntimeMetrics_throughputOut(ctx context.Context, field graphql.CollectedField, obj *model.RuntimeMetrics) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RuntimeMetrics_throughputOut(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ThroughputOut, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Size)
	fc.Result = res
	return ec.marshalOSize2backendgraphmodelSize(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RuntimeMetrics_throughputOut(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RuntimeMetrics",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Size does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RuntimeMetrics_custom(ctx context.Context, field graphql.CollectedField, obj *model.RuntimeMetrics) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RuntimeMetrics_custom(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Custom, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOJSON2map(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RuntimeMetrics_custom(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RuntimeMetrics",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type JSON does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RuntimeState_isRunning(ctx context.Context, field graphql.CollectedField, obj *model.RuntimeState) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RuntimeState_isRunning(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsRunning, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RuntimeState_isRunning(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RuntimeState",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RuntimeState_health(ctx context.Context, field graphql.CollectedField, obj *model.RuntimeState) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RuntimeState_health(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Health, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.RuntimeHealth)
	fc.Result = res
	return ec.marshalNRuntimeHealth2backendgraphmodelRuntimeHealth(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RuntimeState_health(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RuntimeState",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type RuntimeHealth does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RuntimeState_errorMessage(ctx context.Context, field graphql.CollectedField, obj *model.RuntimeState) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RuntimeState_errorMessage(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ErrorMessage, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RuntimeState_errorMessage(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RuntimeState",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RuntimeState_metrics(ctx context.Context, field graphql.CollectedField, obj *model.RuntimeState) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RuntimeState_metrics(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Metrics, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.RuntimeMetrics)
	fc.Result = res
	return ec.marshalORuntimeMetrics2backendgraphmodelRuntimeMetrics(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RuntimeState_metrics(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RuntimeState",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "bytesIn":
				return ec.fieldContext_RuntimeMetrics_bytesIn(ctx, field)
			case "bytesOut":
				return ec.fieldContext_RuntimeMetrics_bytesOut(ctx, field)
			case "packetsIn":
				return ec.fieldContext_RuntimeMetrics_packetsIn(ctx, field)
			case "packetsOut":
				return ec.fieldContext_RuntimeMetrics_packetsOut(ctx, field)
			case "errors":
				return ec.fieldContext_RuntimeMetrics_errors(ctx, field)
			case "drops":
				return ec.fieldContext_RuntimeMetrics_drops(ctx, field)
			case "throughputIn":
				return ec.fieldContext_RuntimeMetrics_throughputIn(ctx, field)
			case "throughputOut":
				return ec.fieldContext_RuntimeMetrics_throughputOut(ctx, field)
			case "custom":
				return ec.fieldContext_RuntimeMetrics_custom(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RuntimeMetrics", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RuntimeState_lastUpdated(ctx context.Context, field graphql.CollectedField, obj *model.RuntimeState) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RuntimeState_lastUpdated(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LastUpdated, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNDateTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RuntimeState_lastUpdated(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RuntimeState",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DateTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RuntimeState_lastSuccessfulOperation(ctx context.Context, field graphql.CollectedField, obj *model.RuntimeState) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RuntimeState_lastSuccessfulOperation(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LastSuccessfulOperation, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalODateTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RuntimeState_lastSuccessfulOperation(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RuntimeState",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DateTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RuntimeState_activeConnections(ctx context.Context, field graphql.CollectedField, obj *model.RuntimeState) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RuntimeState_activeConnections(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ActiveConnections, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RuntimeState_activeConnections(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RuntimeState",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RuntimeState_uptime(ctx context.Context, field graphql.CollectedField, obj *model.RuntimeState) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RuntimeState_uptime(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Uptime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Duration)
	fc.Result = res
	return ec.marshalODuration2backendgraphmodelDuration(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RuntimeState_uptime(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RuntimeState",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Duration does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ScanNetworkPayload_task(ctx context.Context, field graphql.CollectedField, obj *model.ScanNetworkPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ScanNetworkPayload_task(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Task, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.ScanTask)
	fc.Result = res
	return ec.marshalOScanTask2backendgraphmodelScanTask(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ScanNetworkPayload_task(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ScanNetworkPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ScanTask_id(ctx, field)
			case "subnet":
				return ec.fieldContext_ScanTask_subnet(ctx, field)
			case "status":
				return ec.fieldContext_ScanTask_status(ctx, field)
			case "progress":
				return ec.fieldContext_ScanTask_progress(ctx, field)
			case "results":
				return ec.fieldContext_ScanTask_results(ctx, field)
			case "startTime":
				return ec.fieldContext_ScanTask_startTime(ctx, field)
			case "endTime":
				return ec.fieldContext_ScanTask_endTime(ctx, field)
			case "error":
				return ec.fieldContext_ScanTask_error(ctx, field)
			case "totalIPs":
				return ec.fieldContext_ScanTask_totalIPs(ctx, field)
			case "scannedIPs":
				return ec.fieldContext_ScanTask_scannedIPs(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ScanTask", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ScanNetworkPayload_errors(ctx context.Context, field graphql.CollectedField, obj *model.ScanNetworkPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ScanNetworkPayload_errors(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Errors, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.MutationError)
	fc.Result = res
	return ec.marshalOMutationError2backendgraphmodelMutationError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ScanNetworkPayload_errors(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ScanNetworkPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "code":
				return ec.fieldContext_MutationError_code(ctx, field)
			case "message":
				return ec.fieldContext_MutationError_message(ctx, field)
			case "field":
				return ec.fieldContext_MutationError_field(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MutationError", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ScanProgressEvent_taskId(ctx context.Context, field graphql.CollectedField, obj *model.ScanProgressEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ScanProgressEvent_taskId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TaskID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ScanProgressEvent_taskId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ScanProgressEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ScanProgressEvent_progress(ctx context.Context, field graphql.CollectedField, obj *model.ScanProgressEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ScanProgressEvent_progress(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Progress, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ScanProgressEvent_progress(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ScanProgressEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ScanProgressEvent_devicesFound(ctx context.Context, field graphql.CollectedField, obj *model.ScanProgressEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ScanProgressEvent_devicesFound(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DevicesFound, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ScanProgressEvent_devicesFound(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ScanProgressEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ScanProgressEvent_currentIP(ctx context.Context, field graphql.CollectedField, obj *model.ScanProgressEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ScanProgressEvent_currentIP(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CurrentIP, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ScanProgressEvent_currentIP(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ScanProgressEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ScanProgressEvent_status(ctx context.Context, field graphql.CollectedField, obj *model.ScanProgressEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ScanProgressEvent_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.ScanStatus)
	fc.Result = res
	return ec.marshalNScanStatus2backendgraphmodelScanStatus(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ScanProgressEvent_status(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ScanProgressEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ScanStatus does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ScanProgressEvent_timestamp(ctx context.Context, field graphql.CollectedField, obj *model.ScanProgressEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ScanProgressEvent_timestamp(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Timestamp, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNDateTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ScanProgressEvent_timestamp(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ScanProgressEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DateTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ScanTask_id(ctx context.Context, field graphql.CollectedField, obj *model.ScanTask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ScanTask_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ScanTask_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ScanTask",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ScanTask_subnet(ctx context.Context, field graphql.CollectedField, obj *model.ScanTask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ScanTask_subnet(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Subnet, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ScanTask_subnet(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ScanTask",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ScanTask_status(ctx context.Context, field graphql.CollectedField, obj *model.ScanTask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ScanTask_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.ScanStatus)
	fc.Result = res
	return ec.marshalNScanStatus2backendgraphmodelScanStatus(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ScanTask_status(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ScanTask",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ScanStatus does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ScanTask_progress(ctx context.Context, field graphql.CollectedField, obj *model.ScanTask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ScanTask_progress(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Progress, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ScanTask_progress(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ScanTask",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ScanTask_results(ctx context.Context, field graphql.CollectedField, obj *model.ScanTask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ScanTask_results(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Results, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.DiscoveredDevice)
	fc.Result = res
	return ec.marshalNDiscoveredDevice2backendgraphmodelDiscoveredDevice(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ScanTask_results(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ScanTask",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "ip":
				return ec.fieldContext_DiscoveredDevice_ip(ctx, field)
			case "hostname":
				return ec.fieldContext_DiscoveredDevice_hostname(ctx, field)
			case "ports":
				return ec.fieldContext_DiscoveredDevice_ports(ctx, field)
			case "deviceType":
				return ec.fieldContext_DiscoveredDevice_deviceType(ctx, field)
			case "vendor":
				return ec.fieldContext_DiscoveredDevice_vendor(ctx, field)
			case "routerOSInfo":
				return ec.fieldContext_DiscoveredDevice_routerOSInfo(ctx, field)
			case "confidence":
				return ec.fieldContext_DiscoveredDevice_confidence(ctx, field)
			case "services":
				return ec.fieldContext_DiscoveredDevice_services(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DiscoveredDevice", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ScanTask_startTime(ctx context.Context, field graphql.CollectedField, obj *model.ScanTask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ScanTask_startTime(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StartTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNDateTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ScanTask_startTime(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ScanTask",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DateTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ScanTask_endTime(ctx context.Context, field graphql.CollectedField, obj *model.ScanTask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ScanTask_endTime(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EndTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalODateTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ScanTask_endTime(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ScanTask",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DateTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ScanTask_error(ctx context.Context, field graphql.CollectedField, obj *model.ScanTask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ScanTask_error(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Error, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ScanTask_error(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ScanTask",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ScanTask_totalIPs(ctx context.Context, field graphql.CollectedField, obj *model.ScanTask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ScanTask_totalIPs(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalIPs, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ScanTask_totalIPs(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ScanTask",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ScanTask_scannedIPs(ctx context.Context, field graphql.CollectedField, obj *model.ScanTask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ScanTask_scannedIPs(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ScannedIPs, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ScanTask_scannedIPs(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ScanTask",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Session_id(ctx context.Context, field graphql.CollectedField, obj *model.Session) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Session_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Session_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Session",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Session_ipAddress(ctx context.Context, field graphql.CollectedField, obj *model.Session) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Session_ipAddress(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IPAddress, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Session_ipAddress(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Session",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Session_userAgent(ctx context.Context, field graphql.CollectedField, obj *model.Session) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Session_userAgent(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UserAgent, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Session_userAgent(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Session",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Session_createdAt(ctx context.Context, field graphql.CollectedField, obj *model.Session) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Session_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNDateTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Session_createdAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Session",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DateTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Session_lastActivity(ctx context.Context, field graphql.CollectedField, obj *model.Session) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Session_lastActivity(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LastActivity, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNDateTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Session_lastActivity(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Session",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DateTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Session_isCurrent(ctx context.Context, field graphql.CollectedField, obj *model.Session) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Session_isCurrent(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsCurrent, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Session_isCurrent(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Session",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SetPreferredProtocolPayload_router(ctx context.Context, field graphql.CollectedField, obj *model.SetPreferredProtocolPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SetPreferredProtocolPayload_router(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Router, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Router)
	fc.Result = res
	return ec.marshalORouter2backendgraphmodelRouter(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SetPreferredProtocolPayload_router(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SetPreferredProtocolPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Router_id(ctx, field)
			case "name":
				return ec.fieldContext_Router_name(ctx, field)
			case "host":
				return ec.fieldContext_Router_host(ctx, field)
			case "port":
				return ec.fieldContext_Router_port(ctx, field)
			case "status":
				return ec.fieldContext_Router_status(ctx, field)
			case "platform":
				return ec.fieldContext_Router_platform(ctx, field)
			case "version":
				return ec.fieldContext_Router_version(ctx, field)
			case "model":
				return ec.fieldContext_Router_model(ctx, field)
			case "uptime":
				return ec.fieldContext_Router_uptime(ctx, field)
			case "lastConnected":
				return ec.fieldContext_Router_lastConnected(ctx, field)
			case "createdAt":
				return ec.fieldContext_Router_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Router_updatedAt(ctx, field)
			case "capabilities":
				return ec.fieldContext_Router_capabilities(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Router", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SetPreferredProtocolPayload_connectionDetails(ctx context.Context, field graphql.CollectedField, obj *model.SetPreferredProtocolPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SetPreferredProtocolPayload_connectionDetails(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ConnectionDetails, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.ConnectionDetails)
	fc.Result = res
	return ec.marshalOConnectionDetails2backendgraphmodelConnectionDetails(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SetPreferredProtocolPayload_connectionDetails(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SetPreferredProtocolPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "state":
				return ec.fieldContext_ConnectionDetails_state(ctx, field)
			case "protocol":
				return ec.fieldContext_ConnectionDetails_protocol(ctx, field)
			case "preferredProtocol":
				return ec.fieldContext_ConnectionDetails_preferredProtocol(ctx, field)
			case "connectedAt":
				return ec.fieldContext_ConnectionDetails_connectedAt(ctx, field)
			case "uptime":
				return ec.fieldContext_ConnectionDetails_uptime(ctx, field)
			case "disconnectedAt":
				return ec.fieldContext_ConnectionDetails_disconnectedAt(ctx, field)
			case "lastError":
				return ec.fieldContext_ConnectionDetails_lastError(ctx, field)
			case "lastErrorTime":
				return ec.fieldContext_ConnectionDetails_lastErrorTime(ctx, field)
			case "disconnectReason":
				return ec.fieldContext_ConnectionDetails_disconnectReason(ctx, field)
			case "reconnectAttempts":
				return ec.fieldContext_ConnectionDetails_reconnectAttempts(ctx, field)
			case "nextReconnectAt":
				return ec.fieldContext_ConnectionDetails_nextReconnectAt(ctx, field)
			case "circuitBreakerState":
				return ec.fieldContext_ConnectionDetails_circuitBreakerState(ctx, field)
			case "version":
				return ec.fieldContext_ConnectionDetails_version(ctx, field)
			case "lastHealthCheck":
				return ec.fieldContext_ConnectionDetails_lastHealthCheck(ctx, field)
			case "healthChecksPassed":
				return ec.fieldContext_ConnectionDetails_healthChecksPassed(ctx, field)
			case "healthChecksFailed":
				return ec.fieldContext_ConnectionDetails_healthChecksFailed(ctx, field)
			case "securityWarning":
				return ec.fieldContext_ConnectionDetails_securityWarning(ctx, field)
			case "upgradeRecommendation":
				return ec.fieldContext_ConnectionDetails_upgradeRecommendation(ctx, field)
			case "isLegacyProtocol":
				return ec.fieldContext_ConnectionDetails_isLegacyProtocol(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ConnectionDetails", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SetPreferredProtocolPayload_errors(ctx context.Context, field graphql.CollectedField, obj *model.SetPreferredProtocolPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SetPreferredProtocolPayload_errors(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Errors, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.MutationError)
	fc.Result = res
	return ec.marshalOMutationError2backendgraphmodelMutationError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SetPreferredProtocolPayload_errors(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SetPreferredProtocolPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "code":
				return ec.fieldContext_MutationError_code(ctx, field)
			case "message":
				return ec.fieldContext_MutationError_message(ctx, field)
			case "field":
				return ec.fieldContext_MutationError_field(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MutationError", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SoftwareInfo_version(ctx context.Context, field graphql.CollectedField, obj *model.SoftwareInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SoftwareInfo_version(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Version, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SoftwareInfo_version(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SoftwareInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SoftwareInfo_versionMajor(ctx context.Context, field graphql.CollectedField, obj *model.SoftwareInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SoftwareInfo_versionMajor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.VersionMajor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SoftwareInfo_versionMajor(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SoftwareInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SoftwareInfo_versionMinor(ctx context.Context, field graphql.CollectedField, obj *model.SoftwareInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SoftwareInfo_versionMinor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.VersionMinor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SoftwareInfo_versionMinor(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SoftwareInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SoftwareInfo_versionPatch(ctx context.Context, field graphql.CollectedField, obj *model.SoftwareInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SoftwareInfo_versionPatch(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.VersionPatch, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SoftwareInfo_versionPatch(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SoftwareInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SoftwareInfo_installedPackages(ctx context.Context, field graphql.CollectedField, obj *model.SoftwareInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SoftwareInfo_installedPackages(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.InstalledPackages, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SoftwareInfo_installedPackages(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SoftwareInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SoftwareInfo_licenseLevel(ctx context.Context, field graphql.CollectedField, obj *model.SoftwareInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SoftwareInfo_licenseLevel(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LicenseLevel, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SoftwareInfo_licenseLevel(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SoftwareInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SoftwareInfo_updateChannel(ctx context.Context, field graphql.CollectedField, obj *model.SoftwareInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SoftwareInfo_updateChannel(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdateChannel, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SoftwareInfo_updateChannel(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SoftwareInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StartTroubleshootPayload_session(ctx context.Context, field graphql.CollectedField, obj *model.StartTroubleshootPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StartTroubleshootPayload_session(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Session, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.TroubleshootSession)
	fc.Result = res
	return ec.marshalOTroubleshootSession2backendgraphmodelTroubleshootSession(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StartTroubleshootPayload_session(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StartTroubleshootPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_TroubleshootSession_id(ctx, field)
			case "routerId":
				return ec.fieldContext_TroubleshootSession_routerId(ctx, field)
			case "steps":
				return ec.fieldContext_TroubleshootSession_steps(ctx, field)
			case "currentStepIndex":
				return ec.fieldContext_TroubleshootSession_currentStepIndex(ctx, field)
			case "status":
				return ec.fieldContext_TroubleshootSession_status(ctx, field)
			case "wanInterface":
				return ec.fieldContext_TroubleshootSession_wanInterface(ctx, field)
			case "gateway":
				return ec.fieldContext_TroubleshootSession_gateway(ctx, field)
			case "ispInfo":
				return ec.fieldContext_TroubleshootSession_ispInfo(ctx, field)
			case "appliedFixes":
				return ec.fieldContext_TroubleshootSession_appliedFixes(ctx, field)
			case "startedAt":
				return ec.fieldContext_TroubleshootSession_startedAt(ctx, field)
			case "completedAt":
				return ec.fieldContext_TroubleshootSession_completedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TroubleshootSession", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _StartTroubleshootPayload_errors(ctx context.Context, field graphql.CollectedField, obj *model.StartTroubleshootPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StartTroubleshootPayload_errors(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Errors, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.MutationError)
	fc.Result = res
	return ec.marshalOMutationError2backendgraphmodelMutationError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StartTroubleshootPayload_errors(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StartTroubleshootPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "code":
				return ec.fieldContext_MutationError_code(ctx, field)
			case "message":
				return ec.fieldContext_MutationError_message(ctx, field)
			case "field":
				return ec.fieldContext_MutationError_field(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MutationError", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _StaticIPConfig_id(ctx context.Context, field graphql.CollectedField, obj *model.StaticIPConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StaticIPConfig_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StaticIPConfig_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StaticIPConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StaticIPConfig_interface(ctx context.Context, field graphql.CollectedField, obj *model.StaticIPConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StaticIPConfig_interface(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Interface, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StaticIPConfig_interface(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StaticIPConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StaticIPConfig_address(ctx context.Context, field graphql.CollectedField, obj *model.StaticIPConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StaticIPConfig_address(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Address, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.CIDR)
	fc.Result = res
	return ec.marshalNCIDR2backendgraphmodelCIDR(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StaticIPConfig_address(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StaticIPConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type CIDR does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StaticIPConfig_gateway(ctx context.Context, field graphql.CollectedField, obj *model.StaticIPConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StaticIPConfig_gateway(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Gateway, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.IPv4)
	fc.Result = res
	return ec.marshalNIPv42backendgraphmodelIPv4(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StaticIPConfig_gateway(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StaticIPConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type IPv4 does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StaticIPConfig_primaryDNS(ctx context.Context, field graphql.CollectedField, obj *model.StaticIPConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StaticIPConfig_primaryDNS(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PrimaryDNS, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.IPv4)
	fc.Result = res
	return ec.marshalOIPv42backendgraphmodelIPv4(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StaticIPConfig_primaryDNS(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StaticIPConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type IPv4 does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StaticIPConfig_secondaryDNS(ctx context.Context, field graphql.CollectedField, obj *model.StaticIPConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StaticIPConfig_secondaryDNS(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SecondaryDNS, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.IPv4)
	fc.Result = res
	return ec.marshalOIPv42backendgraphmodelIPv4(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StaticIPConfig_secondaryDNS(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StaticIPConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type IPv4 does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StaticIPConfig_comment(ctx context.Context, field graphql.CollectedField, obj *model.StaticIPConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StaticIPConfig_comment(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Comment, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StaticIPConfig_comment(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StaticIPConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StatsDataPoint_timestamp(ctx context.Context, field graphql.CollectedField, obj *model.StatsDataPoint) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StatsDataPoint_timestamp(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Timestamp, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNDateTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StatsDataPoint_timestamp(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StatsDataPoint",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DateTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StatsDataPoint_txBytesPerSec(ctx context.Context, field graphql.CollectedField, obj *model.StatsDataPoint) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StatsDataPoint_txBytesPerSec(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TxBytesPerSec, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StatsDataPoint_txBytesPerSec(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StatsDataPoint",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StatsDataPoint_rxBytesPerSec(ctx context.Context, field graphql.CollectedField, obj *model.StatsDataPoint) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StatsDataPoint_rxBytesPerSec(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RxBytesPerSec, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StatsDataPoint_rxBytesPerSec(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StatsDataPoint",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StatsDataPoint_txPacketsPerSec(ctx context.Context, field graphql.CollectedField, obj *model.StatsDataPoint) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StatsDataPoint_txPacketsPerSec(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TxPacketsPerSec, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StatsDataPoint_txPacketsPerSec(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StatsDataPoint",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StatsDataPoint_rxPacketsPerSec(ctx context.Context, field graphql.CollectedField, obj *model.StatsDataPoint) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StatsDataPoint_rxPacketsPerSec(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RxPacketsPerSec, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StatsDataPoint_rxPacketsPerSec(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StatsDataPoint",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StatsDataPoint_txErrors(ctx context.Context, field graphql.CollectedField, obj *model.StatsDataPoint) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StatsDataPoint_txErrors(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TxErrors, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StatsDataPoint_txErrors(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StatsDataPoint",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StatsDataPoint_rxErrors(ctx context.Context, field graphql.CollectedField, obj *model.StatsDataPoint) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StatsDataPoint_rxErrors(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RxErrors, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StatsDataPoint_rxErrors(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StatsDataPoint",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StorageMetrics_used(ctx context.Context, field graphql.CollectedField, obj *model.StorageMetrics) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StorageMetrics_used(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Used, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StorageMetrics_used(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StorageMetrics",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StorageMetrics_total(ctx context.Context, field graphql.CollectedField, obj *model.StorageMetrics) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StorageMetrics_total(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Total, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StorageMetrics_total(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StorageMetrics",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StorageMetrics_percentage(ctx context.Context, field graphql.CollectedField, obj *model.StorageMetrics) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StorageMetrics_percentage(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Percentage, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StorageMetrics_percentage(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StorageMetrics",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Subscription_routerStatusChanged(ctx context.Context, field graphql.CollectedField) (ret func(ctx context.Context) graphql.Marshaler) {
	fc, err := ec.fieldContext_Subscription_routerStatusChanged(ctx, field)
	if err != nil {
		return nil
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = nil
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Subscription().RouterStatusChanged(rctx, fc.Args["routerId"].(*string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return nil
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return nil
	}
	return func(ctx context.Context) graphql.Marshaler {
		select {
		case res, ok := <-resTmp.(<-chan *model.RouterStatusEvent):
			if !ok {
				return nil
			}
			return graphql.WriterFunc(func(w io.Writer) {
				w.Write([]byte{'{'})
				graphql.MarshalString(field.Alias).MarshalGQL(w)
				w.Write([]byte{':'})
				ec.marshalNRouterStatusEvent2backendgraphmodelRouterStatusEvent(ctx, field.Selections, res).MarshalGQL(w)
				w.Write([]byte{'}'})
			})
		case <-ctx.Done():
			return nil
		}
	}
}

func (ec *executionContext) fieldContext_Subscription_routerStatusChanged(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Subscription",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "router":
				return ec.fieldContext_RouterStatusEvent_router(ctx, field)
			case "previousStatus":
				return ec.fieldContext_RouterStatusEvent_previousStatus(ctx, field)
			case "newStatus":
				return ec.fieldContext_RouterStatusEvent_newStatus(ctx, field)
			case "timestamp":
				return ec.fieldContext_RouterStatusEvent_timestamp(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RouterStatusEvent", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Subscription_routerStatusChanged_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Subscription_resourceMetrics(ctx context.Context, field graphql.CollectedField) (ret func(ctx context.Context) graphql.Marshaler) {
	fc, err := ec.fieldContext_Subscription_resourceMetrics(ctx, field)
	if err != nil {
		return nil
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = nil
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Subscription().ResourceMetrics(rctx, fc.Args["deviceId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return nil
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return nil
	}
	return func(ctx context.Context) graphql.Marshaler {
		select {
		case res, ok := <-resTmp.(<-chan *model.ResourceMetrics):
			if !ok {
				return nil
			}
			return graphql.WriterFunc(func(w io.Writer) {
				w.Write([]byte{'{'})
				graphql.MarshalString(field.Alias).MarshalGQL(w)
				w.Write([]byte{':'})
				ec.marshalNResourceMetrics2backendgraphmodelResourceMetrics(ctx, field.Selections, res).MarshalGQL(w)
				w.Write([]byte{'}'})
			})
		case <-ctx.Done():
			return nil
		}
	}
}

func (ec *executionContext) fieldContext_Subscription_resourceMetrics(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Subscription",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "cpu":
				return ec.fieldContext_ResourceMetrics_cpu(ctx, field)
			case "memory":
				return ec.fieldContext_ResourceMetrics_memory(ctx, field)
			case "storage":
				return ec.fieldContext_ResourceMetrics_storage(ctx, field)
			case "temperature":
				return ec.fieldContext_ResourceMetrics_temperature(ctx, field)
			case "timestamp":
				return ec.fieldContext_ResourceMetrics_timestamp(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ResourceMetrics", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Subscription_resourceMetrics_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Subscription_interfaceTraffic(ctx context.Context, field graphql.CollectedField) (ret func(ctx context.Context) graphql.Marshaler) {
	fc, err := ec.fieldContext_Subscription_interfaceTraffic(ctx, field)
	if err != nil {
		return nil
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = nil
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Subscription().InterfaceTraffic(rctx, fc.Args["routerId"].(string), fc.Args["interfaceId"].(*string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return nil
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return nil
	}
	return func(ctx context.Context) graphql.Marshaler {
		select {
		case res, ok := <-resTmp.(<-chan *model.InterfaceTrafficEvent):
			if !ok {
				return nil
			}
			return graphql.WriterFunc(func(w io.Writer) {
				w.Write([]byte{'{'})
				graphql.MarshalString(field.Alias).MarshalGQL(w)
				w.Write([]byte{':'})
				ec.marshalNInterfaceTrafficEvent2backendgraphmodelInterfaceTrafficEvent(ctx, field.Selections, res).MarshalGQL(w)
				w.Write([]byte{'}'})
			})
		case <-ctx.Done():
			return nil
		}
	}
}

func (ec *executionContext) fieldContext_Subscription_interfaceTraffic(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Subscription",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "interfaceId":
				return ec.fieldContext_InterfaceTrafficEvent_interfaceId(ctx, field)
			case "interfaceName":
				return ec.fieldContext_InterfaceTrafficEvent_interfaceName(ctx, field)
			case "txRate":
				return ec.fieldContext_InterfaceTrafficEvent_txRate(ctx, field)
			case "rxRate":
				return ec.fieldContext_InterfaceTrafficEvent_rxRate(ctx, field)
			case "txTotal":
				return ec.fieldContext_InterfaceTrafficEvent_txTotal(ctx, field)
			case "rxTotal":
				return ec.fieldContext_InterfaceTrafficEvent_rxTotal(ctx, field)
			case "timestamp":
				return ec.fieldContext_InterfaceTrafficEvent_timestamp(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type InterfaceTrafficEvent", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Subscription_interfaceTraffic_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Subscription_resourceUpdated(ctx context.Context, field graphql.CollectedField) (ret func(ctx context.Context) graphql.Marshaler) {
	fc, err := ec.fieldContext_Subscription_resourceUpdated(ctx, field)
	if err != nil {
		return nil
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = nil
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Subscription().ResourceUpdated(rctx, fc.Args["resourceId"].(*string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return nil
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return nil
	}
	return func(ctx context.Context) graphql.Marshaler {
		select {
		case res, ok := <-resTmp.(<-chan *model.ResourceUpdatedEvent):
			if !ok {
				return nil
			}
			return graphql.WriterFunc(func(w io.Writer) {
				w.Write([]byte{'{'})
				graphql.MarshalString(field.Alias).MarshalGQL(w)
				w.Write([]byte{':'})
				ec.marshalNResourceUpdatedEvent2backendgraphmodelResourceUpdatedEvent(ctx, field.Selections, res).MarshalGQL(w)
				w.Write([]byte{'}'})
			})
		case <-ctx.Done():
			return nil
		}
	}
}

func (ec *executionContext) fieldContext_Subscription_resourceUpdated(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Subscription",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "resourceId":
				return ec.fieldContext_ResourceUpdatedEvent_resourceId(ctx, field)
			case "resourceType":
				return ec.fieldContext_ResourceUpdatedEvent_resourceType(ctx, field)
			case "routerId":
				return ec.fieldContext_ResourceUpdatedEvent_routerId(ctx, field)
			case "version":
				return ec.fieldContext_ResourceUpdatedEvent_version(ctx, field)
			case "changedFields":
				return ec.fieldContext_ResourceUpdatedEvent_changedFields(ctx, field)
			case "changeType":
				return ec.fieldContext_ResourceUpdatedEvent_changeType(ctx, field)
			case "timestamp":
				return ec.fieldContext_ResourceUpdatedEvent_timestamp(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ResourceUpdatedEvent", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Subscription_resourceUpdated_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Subscription_configApplyProgress(ctx context.Context, field graphql.CollectedField) (ret func(ctx context.Context) graphql.Marshaler) {
	fc, err := ec.fieldContext_Subscription_configApplyProgress(ctx, field)
	if err != nil {
		return nil
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = nil
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Subscription().ConfigApplyProgress(rctx, fc.Args["operationId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return nil
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return nil
	}
	return func(ctx context.Context) graphql.Marshaler {
		select {
		case res, ok := <-resTmp.(<-chan *model.ConfigProgress):
			if !ok {
				return nil
			}
			return graphql.WriterFunc(func(w io.Writer) {
				w.Write([]byte{'{'})
				graphql.MarshalString(field.Alias).MarshalGQL(w)
				w.Write([]byte{':'})
				ec.marshalNConfigProgress2backendgraphmodelConfigProgress(ctx, field.Selections, res).MarshalGQL(w)
				w.Write([]byte{'}'})
			})
		case <-ctx.Done():
			return nil
		}
	}
}

func (ec *executionContext) fieldContext_Subscription_configApplyProgress(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Subscription",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "operationId":
				return ec.fieldContext_ConfigProgress_operationId(ctx, field)
			case "status":
				return ec.fieldContext_ConfigProgress_status(ctx, field)
			case "percentage":
				return ec.fieldContext_ConfigProgress_percentage(ctx, field)
			case "message":
				return ec.fieldContext_ConfigProgress_message(ctx, field)
			case "currentStep":
				return ec.fieldContext_ConfigProgress_currentStep(ctx, field)
			case "totalSteps":
				return ec.fieldContext_ConfigProgress_totalSteps(ctx, field)
			case "timestamp":
				return ec.fieldContext_ConfigProgress_timestamp(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ConfigProgress", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Subscription_configApplyProgress_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Subscription_interfaceStatusChanged(ctx context.Context, field graphql.CollectedField) (ret func(ctx context.Context) graphql.Marshaler) {
	fc, err := ec.fieldContext_Subscription_interfaceStatusChanged(ctx, field)
	if err != nil {
		return nil
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = nil
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Subscription().InterfaceStatusChanged(rctx, fc.Args["routerId"].(string), fc.Args["interfaceId"].(*string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return nil
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return nil
	}
	return func(ctx context.Context) graphql.Marshaler {
		select {
		case res, ok := <-resTmp.(<-chan *model.InterfaceStatusEvent):
			if !ok {
				return nil
			}
			return graphql.WriterFunc(func(w io.Writer) {
				w.Write([]byte{'{'})
				graphql.MarshalString(field.Alias).MarshalGQL(w)
				w.Write([]byte{':'})
				ec.marshalNInterfaceStatusEvent2backendgraphmodelInterfaceStatusEvent(ctx, field.Selections, res).MarshalGQL(w)
				w.Write([]byte{'}'})
			})
		case <-ctx.Done():
			return nil
		}
	}
}

func (ec *executionContext) fieldContext_Subscription_interfaceStatusChanged(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Subscription",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "interfaceId":
				return ec.fieldContext_InterfaceStatusEvent_interfaceId(ctx, field)
			case "interfaceName":
				return ec.fieldContext_InterfaceStatusEvent_interfaceName(ctx, field)
			case "status":
				return ec.fieldContext_InterfaceStatusEvent_status(ctx, field)
			case "previousStatus":
				return ec.fieldContext_InterfaceStatusEvent_previousStatus(ctx, field)
			case "timestamp":
				return ec.fieldContext_InterfaceStatusEvent_timestamp(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type InterfaceStatusEvent", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Subscription_interfaceStatusChanged_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Subscription_connectionHealth(ctx context.Context, field graphql.CollectedField) (ret func(ctx context.Context) graphql.Marshaler) {
	fc, err := ec.fieldContext_Subscription_connectionHealth(ctx, field)
	if err != nil {
		return nil
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = nil
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Subscription().ConnectionHealth(rctx, fc.Args["routerId"].(*string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return nil
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return nil
	}
	return func(ctx context.Context) graphql.Marshaler {
		select {
		case res, ok := <-resTmp.(<-chan *model.HealthCheckResult):
			if !ok {
				return nil
			}
			return graphql.WriterFunc(func(w io.Writer) {
				w.Write([]byte{'{'})
				graphql.MarshalString(field.Alias).MarshalGQL(w)
				w.Write([]byte{':'})
				ec.marshalNHealthCheckResult2backendgraphmodelHealthCheckResult(ctx, field.Selections, res).MarshalGQL(w)
				w.Write([]byte{'}'})
			})
		case <-ctx.Done():
			return nil
		}
	}
}

func (ec *executionContext) fieldContext_Subscription_connectionHealth(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Subscription",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "routerId":
				return ec.fieldContext_HealthCheckResult_routerId(ctx, field)
			case "healthy":
				return ec.fieldContext_HealthCheckResult_healthy(ctx, field)
			case "checkedAt":
				return ec.fieldContext_HealthCheckResult_checkedAt(ctx, field)
			case "responseTimeMs":
				return ec.fieldContext_HealthCheckResult_responseTimeMs(ctx, field)
			case "error":
				return ec.fieldContext_HealthCheckResult_error(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type HealthCheckResult", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Subscription_connectionHealth_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Subscription_circuitBreakerChanged(ctx context.Context, field graphql.CollectedField) (ret func(ctx context.Context) graphql.Marshaler) {
	fc, err := ec.fieldContext_Subscription_circuitBreakerChanged(ctx, field)
	if err != nil {
		return nil
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = nil
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Subscription().CircuitBreakerChanged(rctx, fc.Args["routerId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return nil
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return nil
	}
	return func(ctx context.Context) graphql.Marshaler {
		select {
		case res, ok := <-resTmp.(<-chan *model.CircuitBreakerEvent):
			if !ok {
				return nil
			}
			return graphql.WriterFunc(func(w io.Writer) {
				w.Write([]byte{'{'})
				graphql.MarshalString(field.Alias).MarshalGQL(w)
				w.Write([]byte{':'})
				ec.marshalNCircuitBreakerEvent2backendgraphmodelCircuitBreakerEvent(ctx, field.Selections, res).MarshalGQL(w)
				w.Write([]byte{'}'})
			})
		case <-ctx.Done():
			return nil
		}
	}
}

func (ec *executionContext) fieldContext_Subscription_circuitBreakerChanged(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Subscription",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "routerId":
				return ec.fieldContext_CircuitBreakerEvent_routerId(ctx, field)
			case "previousState":
				return ec.fieldContext_CircuitBreakerEvent_previousState(ctx, field)
			case "newState":
				return ec.fieldContext_CircuitBreakerEvent_newState(ctx, field)
			case "consecutiveFailures":
				return ec.fieldContext_CircuitBreakerEvent_consecutiveFailures(ctx, field)
			case "timestamp":
				return ec.fieldContext_CircuitBreakerEvent_timestamp(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CircuitBreakerEvent", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Subscription_circuitBreakerChanged_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Subscription_scanProgress(ctx context.Context, field graphql.CollectedField) (ret func(ctx context.Context) graphql.Marshaler) {
	fc, err := ec.fieldContext_Subscription_scanProgress(ctx, field)
	if err != nil {
		return nil
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = nil
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Subscription().ScanProgress(rctx, fc.Args["taskId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return nil
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return nil
	}
	return func(ctx context.Context) graphql.Marshaler {
		select {
		case res, ok := <-resTmp.(<-chan *model.ScanProgressEvent):
			if !ok {
				return nil
			}
			return graphql.WriterFunc(func(w io.Writer) {
				w.Write([]byte{'{'})
				graphql.MarshalString(field.Alias).MarshalGQL(w)
				w.Write([]byte{':'})
				ec.marshalNScanProgressEvent2backendgraphmodelScanProgressEvent(ctx, field.Selections, res).MarshalGQL(w)
				w.Write([]byte{'}'})
			})
		case <-ctx.Done():
			return nil
		}
	}
}

func (ec *executionContext) fieldContext_Subscription_scanProgress(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Subscription",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "taskId":
				return ec.fieldContext_ScanProgressEvent_taskId(ctx, field)
			case "progress":
				return ec.fieldContext_ScanProgressEvent_progress(ctx, field)
			case "devicesFound":
				return ec.fieldContext_ScanProgressEvent_devicesFound(ctx, field)
			case "currentIP":
				return ec.fieldContext_ScanProgressEvent_currentIP(ctx, field)
			case "status":
				return ec.fieldContext_ScanProgressEvent_status(ctx, field)
			case "timestamp":
				return ec.fieldContext_ScanProgressEvent_timestamp(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ScanProgressEvent", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Subscription_scanProgress_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Subscription_changeSetProgress(ctx context.Context, field graphql.CollectedField) (ret func(ctx context.Context) graphql.Marshaler) {
	fc, err := ec.fieldContext_Subscription_changeSetProgress(ctx, field)
	if err != nil {
		return nil
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = nil
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Subscription().ChangeSetProgress(rctx, fc.Args["changeSetId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return nil
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return nil
	}
	return func(ctx context.Context) graphql.Marshaler {
		select {
		case res, ok := <-resTmp.(<-chan *model.ChangeSetProgressEvent):
			if !ok {
				return nil
			}
			return graphql.WriterFunc(func(w io.Writer) {
				w.Write([]byte{'{'})
				graphql.MarshalString(field.Alias).MarshalGQL(w)
				w.Write([]byte{':'})
				ec.marshalNChangeSetProgressEvent2backendgraphmodelChangeSetProgressEvent(ctx, field.Selections, res).MarshalGQL(w)
				w.Write([]byte{'}'})
			})
		case <-ctx.Done():
			return nil
		}
	}
}

func (ec *executionContext) fieldContext_Subscription_changeSetProgress(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Subscription",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "changeSetId":
				return ec.fieldContext_ChangeSetProgressEvent_changeSetId(ctx, field)
			case "status":
				return ec.fieldContext_ChangeSetProgressEvent_status(ctx, field)
			case "currentItem":
				return ec.fieldContext_ChangeSetProgressEvent_currentItem(ctx, field)
			case "appliedCount":
				return ec.fieldContext_ChangeSetProgressEvent_appliedCount(ctx, field)
			case "totalCount":
				return ec.fieldContext_ChangeSetProgressEvent_totalCount(ctx, field)
			case "progressPercent":
				return ec.fieldContext_ChangeSetProgressEvent_progressPercent(ctx, field)
			case "estimatedRemainingMs":
				return ec.fieldContext_ChangeSetProgressEvent_estimatedRemainingMs(ctx, field)
			case "error":
				return ec.fieldContext_ChangeSetProgressEvent_error(ctx, field)
			case "timestamp":
				return ec.fieldContext_ChangeSetProgressEvent_timestamp(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ChangeSetProgressEvent", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Subscription_changeSetProgress_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Subscription_changeSetStatusChanged(ctx context.Context, field graphql.CollectedField) (ret func(ctx context.Context) graphql.Marshaler) {
	fc, err := ec.fieldContext_Subscription_changeSetStatusChanged(ctx, field)
	if err != nil {
		return nil
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = nil
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Subscription().ChangeSetStatusChanged(rctx, fc.Args["routerId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return nil
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return nil
	}
	return func(ctx context.Context) graphql.Marshaler {
		select {
		case res, ok := <-resTmp.(<-chan *model.ChangeSetStatusEvent):
			if !ok {
				return nil
			}
			return graphql.WriterFunc(func(w io.Writer) {
				w.Write([]byte{'{'})
				graphql.MarshalString(field.Alias).MarshalGQL(w)
				w.Write([]byte{':'})
				ec.marshalNChangeSetStatusEvent2backendgraphmodelChangeSetStatusEvent(ctx, field.Selections, res).MarshalGQL(w)
				w.Write([]byte{'}'})
			})
		case <-ctx.Done():
			return nil
		}
	}
}

func (ec *executionContext) fieldContext_Subscription_changeSetStatusChanged(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Subscription",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "changeSetId":
				return ec.fieldContext_ChangeSetStatusEvent_changeSetId(ctx, field)
			case "previousStatus":
				return ec.fieldContext_ChangeSetStatusEvent_previousStatus(ctx, field)
			case "newStatus":
				return ec.fieldContext_ChangeSetStatusEvent_newStatus(ctx, field)
			case "error":
				return ec.fieldContext_ChangeSetStatusEvent_error(ctx, field)
			case "timestamp":
				return ec.fieldContext_ChangeSetStatusEvent_timestamp(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ChangeSetStatusEvent", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Subscription_changeSetStatusChanged_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Subscription_circuitBreakerStateChanged(ctx context.Context, field graphql.CollectedField) (ret func(ctx context.Context) graphql.Marshaler) {
	fc, err := ec.fieldContext_Subscription_circuitBreakerStateChanged(ctx, field)
	if err != nil {
		return nil
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = nil
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Subscription().CircuitBreakerStateChanged(rctx, fc.Args["routerId"].(*string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return nil
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return nil
	}
	return func(ctx context.Context) graphql.Marshaler {
		select {
		case res, ok := <-resTmp.(<-chan *model.CircuitBreakerStatus):
			if !ok {
				return nil
			}
			return graphql.WriterFunc(func(w io.Writer) {
				w.Write([]byte{'{'})
				graphql.MarshalString(field.Alias).MarshalGQL(w)
				w.Write([]byte{':'})
				ec.marshalNCircuitBreakerStatus2backendgraphmodelCircuitBreakerStatus(ctx, field.Selections, res).MarshalGQL(w)
				w.Write([]byte{'}'})
			})
		case <-ctx.Done():
			return nil
		}
	}
}

func (ec *executionContext) fieldContext_Subscription_circuitBreakerStateChanged(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Subscription",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "routerId":
				return ec.fieldContext_CircuitBreakerStatus_routerId(ctx, field)
			case "state":
				return ec.fieldContext_CircuitBreakerStatus_state(ctx, field)
			case "failureCount":
				return ec.fieldContext_CircuitBreakerStatus_failureCount(ctx, field)
			case "failureThreshold":
				return ec.fieldContext_CircuitBreakerStatus_failureThreshold(ctx, field)
			case "cooldownRemainingSeconds":
				return ec.fieldContext_CircuitBreakerStatus_cooldownRemainingSeconds(ctx, field)
			case "lastFailureAt":
				return ec.fieldContext_CircuitBreakerStatus_lastFailureAt(ctx, field)
			case "lastSuccessAt":
				return ec.fieldContext_CircuitBreakerStatus_lastSuccessAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CircuitBreakerStatus", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Subscription_circuitBreakerStateChanged_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Subscription_troubleshootProgress(ctx context.Context, field graphql.CollectedField) (ret func(ctx context.Context) graphql.Marshaler) {
	fc, err := ec.fieldContext_Subscription_troubleshootProgress(ctx, field)
	if err != nil {
		return nil
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = nil
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Subscription().TroubleshootProgress(rctx, fc.Args["sessionId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return nil
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return nil
	}
	return func(ctx context.Context) graphql.Marshaler {
		select {
		case res, ok := <-resTmp.(<-chan *model.TroubleshootSession):
			if !ok {
				return nil
			}
			return graphql.WriterFunc(func(w io.Writer) {
				w.Write([]byte{'{'})
				graphql.MarshalString(field.Alias).MarshalGQL(w)
				w.Write([]byte{':'})
				ec.marshalNTroubleshootSession2backendgraphmodelTroubleshootSession(ctx, field.Selections, res).MarshalGQL(w)
				w.Write([]byte{'}'})
			})
		case <-ctx.Done():
			return nil
		}
	}
}

func (ec *executionContext) fieldContext_Subscription_troubleshootProgress(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Subscription",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_TroubleshootSession_id(ctx, field)
			case "routerId":
				return ec.fieldContext_TroubleshootSession_routerId(ctx, field)
			case "steps":
				return ec.fieldContext_TroubleshootSession_steps(ctx, field)
			case "currentStepIndex":
				return ec.fieldContext_TroubleshootSession_currentStepIndex(ctx, field)
			case "status":
				return ec.fieldContext_TroubleshootSession_status(ctx, field)
			case "wanInterface":
				return ec.fieldContext_TroubleshootSession_wanInterface(ctx, field)
			case "gateway":
				return ec.fieldContext_TroubleshootSession_gateway(ctx, field)
			case "ispInfo":
				return ec.fieldContext_TroubleshootSession_ispInfo(ctx, field)
			case "appliedFixes":
				return ec.fieldContext_TroubleshootSession_appliedFixes(ctx, field)
			case "startedAt":
				return ec.fieldContext_TroubleshootSession_startedAt(ctx, field)
			case "completedAt":
				return ec.fieldContext_TroubleshootSession_completedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TroubleshootSession", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Subscription_troubleshootProgress_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Subscription_tracerouteProgress(ctx context.Context, field graphql.CollectedField) (ret func(ctx context.Context) graphql.Marshaler) {
	fc, err := ec.fieldContext_Subscription_tracerouteProgress(ctx, field)
	if err != nil {
		return nil
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = nil
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Subscription().TracerouteProgress(rctx, fc.Args["jobId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return nil
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return nil
	}
	return func(ctx context.Context) graphql.Marshaler {
		select {
		case res, ok := <-resTmp.(<-chan *model.TracerouteProgressEvent):
			if !ok {
				return nil
			}
			return graphql.WriterFunc(func(w io.Writer) {
				w.Write([]byte{'{'})
				graphql.MarshalString(field.Alias).MarshalGQL(w)
				w.Write([]byte{':'})
				ec.marshalNTracerouteProgressEvent2backendgraphmodelTracerouteProgressEvent(ctx, field.Selections, res).MarshalGQL(w)
				w.Write([]byte{'}'})
			})
		case <-ctx.Done():
			return nil
		}
	}
}

func (ec *executionContext) fieldContext_Subscription_tracerouteProgress(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Subscription",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "jobId":
				return ec.fieldContext_TracerouteProgressEvent_jobId(ctx, field)
			case "eventType":
				return ec.fieldContext_TracerouteProgressEvent_eventType(ctx, field)
			case "hop":
				return ec.fieldContext_TracerouteProgressEvent_hop(ctx, field)
			case "result":
				return ec.fieldContext_TracerouteProgressEvent_result(ctx, field)
			case "error":
				return ec.fieldContext_TracerouteProgressEvent_error(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TracerouteProgressEvent", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Subscription_tracerouteProgress_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Subscription_alertEvents(ctx context.Context, field graphql.CollectedField) (ret func(ctx context.Context) graphql.Marshaler) {
	fc, err := ec.fieldContext_Subscription_alertEvents(ctx, field)
	if err != nil {
		return nil
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = nil
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Subscription().AlertEvents(rctx, fc.Args["deviceId"].(*string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return nil
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return nil
	}
	return func(ctx context.Context) graphql.Marshaler {
		select {
		case res, ok := <-resTmp.(<-chan *model.AlertEvent):
			if !ok {
				return nil
			}
			return graphql.WriterFunc(func(w io.Writer) {
				w.Write([]byte{'{'})
				graphql.MarshalString(field.Alias).MarshalGQL(w)
				w.Write([]byte{':'})
				ec.marshalNAlertEvent2backendgraphmodelAlertEvent(ctx, field.Selections, res).MarshalGQL(w)
				w.Write([]byte{'}'})
			})
		case <-ctx.Done():
			return nil
		}
	}
}

func (ec *executionContext) fieldContext_Subscription_alertEvents(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Subscription",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "alert":
				return ec.fieldContext_AlertEvent_alert(ctx, field)
			case "action":
				return ec.fieldContext_AlertEvent_action(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type AlertEvent", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Subscription_alertEvents_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Subscription_routerAdded(ctx context.Context, field graphql.CollectedField) (ret func(ctx context.Context) graphql.Marshaler) {
	fc, err := ec.fieldContext_Subscription_routerAdded(ctx, field)
	if err != nil {
		return nil
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = nil
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Subscription().RouterAdded(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return nil
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return nil
	}
	return func(ctx context.Context) graphql.Marshaler {
		select {
		case res, ok := <-resTmp.(<-chan *model.RouterAddedEvent):
			if !ok {
				return nil
			}
			return graphql.WriterFunc(func(w io.Writer) {
				w.Write([]byte{'{'})
				graphql.MarshalString(field.Alias).MarshalGQL(w)
				w.Write([]byte{':'})
				ec.marshalNRouterAddedEvent2backendgraphmodelRouterAddedEvent(ctx, field.Selections, res).MarshalGQL(w)
				w.Write([]byte{'}'})
			})
		case <-ctx.Done():
			return nil
		}
	}
}

func (ec *executionContext) fieldContext_Subscription_routerAdded(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Subscription",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "router":
				return ec.fieldContext_RouterAddedEvent_router(ctx, field)
			case "protocolUsed":
				return ec.fieldContext_RouterAddedEvent_protocolUsed(ctx, field)
			case "addedBy":
				return ec.fieldContext_RouterAddedEvent_addedBy(ctx, field)
			case "timestamp":
				return ec.fieldContext_RouterAddedEvent_timestamp(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RouterAddedEvent", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Subscription_resourceRuntime(ctx context.Context, field graphql.CollectedField) (ret func(ctx context.Context) graphql.Marshaler) {
	fc, err := ec.fieldContext_Subscription_resourceRuntime(ctx, field)
	if err != nil {
		return nil
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = nil
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Subscription().ResourceRuntime(rctx, fc.Args["id"].(string), fc.Args["routerId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return nil
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return nil
	}
	return func(ctx context.Context) graphql.Marshaler {
		select {
		case res, ok := <-resTmp.(<-chan *model.ResourceRuntimeEvent):
			if !ok {
				return nil
			}
			return graphql.WriterFunc(func(w io.Writer) {
				w.Write([]byte{'{'})
				graphql.MarshalString(field.Alias).MarshalGQL(w)
				w.Write([]byte{':'})
				ec.marshalNResourceRuntimeEvent2backendgraphmodelResourceRuntimeEvent(ctx, field.Selections, res).MarshalGQL(w)
				w.Write([]byte{'}'})
			})
		case <-ctx.Done():
			return nil
		}
	}
}

func (ec *executionContext) fieldContext_Subscription_resourceRuntime(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Subscription",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ResourceRuntimeEvent_id(ctx, field)
			case "type":
				return ec.fieldContext_ResourceRuntimeEvent_type(ctx, field)
			case "runtime":
				return ec.fieldContext_ResourceRuntimeEvent_runtime(ctx, field)
			case "timestamp":
				return ec.fieldContext_ResourceRuntimeEvent_timestamp(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ResourceRuntimeEvent", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Subscription_resourceRuntime_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Subscription_resourceStateChanged(ctx context.Context, field graphql.CollectedField) (ret func(ctx context.Context) graphql.Marshaler) {
	fc, err := ec.fieldContext_Subscription_resourceStateChanged(ctx, field)
	if err != nil {
		return nil
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = nil
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Subscription().ResourceStateChanged(rctx, fc.Args["id"].(*string), fc.Args["routerId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return nil
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return nil
	}
	return func(ctx context.Context) graphql.Marshaler {
		select {
		case res, ok := <-resTmp.(<-chan *model.ResourceStateEvent):
			if !ok {
				return nil
			}
			return graphql.WriterFunc(func(w io.Writer) {
				w.Write([]byte{'{'})
				graphql.MarshalString(field.Alias).MarshalGQL(w)
				w.Write([]byte{':'})
				ec.marshalNResourceStateEvent2backendgraphmodelResourceStateEvent(ctx, field.Selections, res).MarshalGQL(w)
				w.Write([]byte{'}'})
			})
		case <-ctx.Done():
			return nil
		}
	}
}

func (ec *executionContext) fieldContext_Subscription_resourceStateChanged(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Subscription",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ResourceStateEvent_id(ctx, field)
			case "type":
				return ec.fieldContext_ResourceStateEvent_type(ctx, field)
			case "previousState":
				return ec.fieldContext_ResourceStateEvent_previousState(ctx, field)
			case "newState":
				return ec.fieldContext_ResourceStateEvent_newState(ctx, field)
			case "errorMessage":
				return ec.fieldContext_ResourceStateEvent_errorMessage(ctx, field)
			case "timestamp":
				return ec.fieldContext_ResourceStateEvent_timestamp(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ResourceStateEvent", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Subscription_resourceStateChanged_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Subscription_ipAddressChanged(ctx context.Context, field graphql.CollectedField) (ret func(ctx context.Context) graphql.Marshaler) {
	fc, err := ec.fieldContext_Subscription_ipAddressChanged(ctx, field)
	if err != nil {
		return nil
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = nil
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Subscription().IPAddressChanged(rctx, fc.Args["routerId"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			requires, err := ec.unmarshalNString2string(ctx, []interface{}{"interface"})
			if err != nil {
				return nil, err
			}
			if ec.directives.Capability == nil {
				return nil, errors.New("directive capability is not implemented")
			}
			return ec.directives.Capability(ctx, nil, directive0, requires)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(<-chan *model.IPAddressChangeEvent); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be <-chan *backend/graph/model.IPAddressChangeEvent`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return nil
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return nil
	}
	return func(ctx context.Context) graphql.Marshaler {
		select {
		case res, ok := <-resTmp.(<-chan *model.IPAddressChangeEvent):
			if !ok {
				return nil
			}
			return graphql.WriterFunc(func(w io.Writer) {
				w.Write([]byte{'{'})
				graphql.MarshalString(field.Alias).MarshalGQL(w)
				w.Write([]byte{':'})
				ec.marshalNIpAddressChangeEvent2backendgraphmodelIPAddressChangeEvent(ctx, field.Selections, res).MarshalGQL(w)
				w.Write([]byte{'}'})
			})
		case <-ctx.Done():
			return nil
		}
	}
}

func (ec *executionContext) fieldContext_Subscription_ipAddressChanged(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Subscription",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "changeType":
				return ec.fieldContext_IpAddressChangeEvent_changeType(ctx, field)
			case "ipAddress":
				return ec.fieldContext_IpAddressChangeEvent_ipAddress(ctx, field)
			case "ipAddressId":
				return ec.fieldContext_IpAddressChangeEvent_ipAddressId(ctx, field)
			case "timestamp":
				return ec.fieldContext_IpAddressChangeEvent_timestamp(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type IpAddressChangeEvent", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Subscription_ipAddressChanged_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Subscription_vlanChanged(ctx context.Context, field graphql.CollectedField) (ret func(ctx context.Context) graphql.Marshaler) {
	fc, err := ec.fieldContext_Subscription_vlanChanged(ctx, field)
	if err != nil {
		return nil
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = nil
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Subscription().VlanChanged(rctx, fc.Args["routerId"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			requires, err := ec.unmarshalNString2string(ctx, []interface{}{"interface"})
			if err != nil {
				return nil, err
			}
			if ec.directives.Capability == nil {
				return nil, errors.New("directive capability is not implemented")
			}
			return ec.directives.Capability(ctx, nil, directive0, requires)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(<-chan *model.Vlan); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be <-chan *backend/graph/model.Vlan`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return nil
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return nil
	}
	return func(ctx context.Context) graphql.Marshaler {
		select {
		case res, ok := <-resTmp.(<-chan *model.Vlan):
			if !ok {
				return nil
			}
			return graphql.WriterFunc(func(w io.Writer) {
				w.Write([]byte{'{'})
				graphql.MarshalString(field.Alias).MarshalGQL(w)
				w.Write([]byte{':'})
				ec.marshalNVlan2backendgraphmodelVlan(ctx, field.Selections, res).MarshalGQL(w)
				w.Write([]byte{'}'})
			})
		case <-ctx.Done():
			return nil
		}
	}
}

func (ec *executionContext) fieldContext_Subscription_vlanChanged(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Subscription",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Vlan_id(ctx, field)
			case "name":
				return ec.fieldContext_Vlan_name(ctx, field)
			case "vlanId":
				return ec.fieldContext_Vlan_vlanId(ctx, field)
			case "interface":
				return ec.fieldContext_Vlan_interface(ctx, field)
			case "mtu":
				return ec.fieldContext_Vlan_mtu(ctx, field)
			case "macAddress":
				return ec.fieldContext_Vlan_macAddress(ctx, field)
			case "disabled":
				return ec.fieldContext_Vlan_disabled(ctx, field)
			case "running":
				return ec.fieldContext_Vlan_running(ctx, field)
			case "comment":
				return ec.fieldContext_Vlan_comment(ctx, field)
			case "ipAddresses":
				return ec.fieldContext_Vlan_ipAddresses(ctx, field)
			case "statistics":
				return ec.fieldContext_Vlan_statistics(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Vlan", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Subscription_vlanChanged_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Subscription_interfaceStatsUpdated(ctx context.Context, field graphql.CollectedField) (ret func(ctx context.Context) graphql.Marshaler) {
	fc, err := ec.fieldContext_Subscription_interfaceStatsUpdated(ctx, field)
	if err != nil {
		return nil
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = nil
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Subscription().InterfaceStatsUpdated(rctx, fc.Args["routerId"].(string), fc.Args["interfaceId"].(string), fc.Args["interval"].(*model.Duration))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			requires, err := ec.unmarshalNString2string(ctx, []interface{}{"interface"})
			if err != nil {
				return nil, err
			}
			if ec.directives.Capability == nil {
				return nil, errors.New("directive capability is not implemented")
			}
			return ec.directives.Capability(ctx, nil, directive0, requires)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(<-chan *model.InterfaceStats); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be <-chan *backend/graph/model.InterfaceStats`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return nil
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return nil
	}
	return func(ctx context.Context) graphql.Marshaler {
		select {
		case res, ok := <-resTmp.(<-chan *model.InterfaceStats):
			if !ok {
				return nil
			}
			return graphql.WriterFunc(func(w io.Writer) {
				w.Write([]byte{'{'})
				graphql.MarshalString(field.Alias).MarshalGQL(w)
				w.Write([]byte{':'})
				ec.marshalNInterfaceStats2backendgraphmodelInterfaceStats(ctx, field.Selections, res).MarshalGQL(w)
				w.Write([]byte{'}'})
			})
		case <-ctx.Done():
			return nil
		}
	}
}

func (ec *executionContext) fieldContext_Subscription_interfaceStatsUpdated(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Subscription",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "txBytes":
				return ec.fieldContext_InterfaceStats_txBytes(ctx, field)
			case "rxBytes":
				return ec.fieldContext_InterfaceStats_rxBytes(ctx, field)
			case "txPackets":
				return ec.fieldContext_InterfaceStats_txPackets(ctx, field)
			case "rxPackets":
				return ec.fieldContext_InterfaceStats_rxPackets(ctx, field)
			case "txErrors":
				return ec.fieldContext_InterfaceStats_txErrors(ctx, field)
			case "rxErrors":
				return ec.fieldContext_InterfaceStats_rxErrors(ctx, field)
			case "txDrops":
				return ec.fieldContext_InterfaceStats_txDrops(ctx, field)
			case "rxDrops":
				return ec.fieldContext_InterfaceStats_rxDrops(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type InterfaceStats", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Subscription_interfaceStatsUpdated_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Subscription_bridgeStpStatusChanged(ctx context.Context, field graphql.CollectedField) (ret func(ctx context.Context) graphql.Marshaler) {
	fc, err := ec.fieldContext_Subscription_bridgeStpStatusChanged(ctx, field)
	if err != nil {
		return nil
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = nil
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Subscription().BridgeStpStatusChanged(rctx, fc.Args["bridgeId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return nil
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return nil
	}
	return func(ctx context.Context) graphql.Marshaler {
		select {
		case res, ok := <-resTmp.(<-chan *model.BridgeStpStatus):
			if !ok {
				return nil
			}
			return graphql.WriterFunc(func(w io.Writer) {
				w.Write([]byte{'{'})
				graphql.MarshalString(field.Alias).MarshalGQL(w)
				w.Write([]byte{':'})
				ec.marshalNBridgeStpStatus2backendgraphmodelBridgeStpStatus(ctx, field.Selections, res).MarshalGQL(w)
				w.Write([]byte{'}'})
			})
		case <-ctx.Done():
			return nil
		}
	}
}

func (ec *executionContext) fieldContext_Subscription_bridgeStpStatusChanged(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Subscription",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "rootBridge":
				return ec.fieldContext_BridgeStpStatus_rootBridge(ctx, field)
			case "rootBridgeId":
				return ec.fieldContext_BridgeStpStatus_rootBridgeId(ctx, field)
			case "rootPort":
				return ec.fieldContext_BridgeStpStatus_rootPort(ctx, field)
			case "rootPathCost":
				return ec.fieldContext_BridgeStpStatus_rootPathCost(ctx, field)
			case "topologyChangeCount":
				return ec.fieldContext_BridgeStpStatus_topologyChangeCount(ctx, field)
			case "lastTopologyChange":
				return ec.fieldContext_BridgeStpStatus_lastTopologyChange(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type BridgeStpStatus", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Subscription_bridgeStpStatusChanged_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Subscription_bridgePortsChanged(ctx context.Context, field graphql.CollectedField) (ret func(ctx context.Context) graphql.Marshaler) {
	fc, err := ec.fieldContext_Subscription_bridgePortsChanged(ctx, field)
	if err != nil {
		return nil
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = nil
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Subscription().BridgePortsChanged(rctx, fc.Args["bridgeId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return nil
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return nil
	}
	return func(ctx context.Context) graphql.Marshaler {
		select {
		case res, ok := <-resTmp.(<-chan []*model.BridgePort):
			if !ok {
				return nil
			}
			return graphql.WriterFunc(func(w io.Writer) {
				w.Write([]byte{'{'})
				graphql.MarshalString(field.Alias).MarshalGQL(w)
				w.Write([]byte{':'})
				ec.marshalNBridgePort2backendgraphmodelBridgePort(ctx, field.Selections, res).MarshalGQL(w)
				w.Write([]byte{'}'})
			})
		case <-ctx.Done():
			return nil
		}
	}
}

func (ec *executionContext) fieldContext_Subscription_bridgePortsChanged(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Subscription",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_BridgePort_id(ctx, field)
			case "bridge":
				return ec.fieldContext_BridgePort_bridge(ctx, field)
			case "interface":
				return ec.fieldContext_BridgePort_interface(ctx, field)
			case "pvid":
				return ec.fieldContext_BridgePort_pvid(ctx, field)
			case "frameTypes":
				return ec.fieldContext_BridgePort_frameTypes(ctx, field)
			case "ingressFiltering":
				return ec.fieldContext_BridgePort_ingressFiltering(ctx, field)
			case "taggedVlans":
				return ec.fieldContext_BridgePort_taggedVlans(ctx, field)
			case "untaggedVlans":
				return ec.fieldContext_BridgePort_untaggedVlans(ctx, field)
			case "role":
				return ec.fieldContext_BridgePort_role(ctx, field)
			case "state":
				return ec.fieldContext_BridgePort_state(ctx, field)
			case "pathCost":
				return ec.fieldContext_BridgePort_pathCost(ctx, field)
			case "edge":
				return ec.fieldContext_BridgePort_edge(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type BridgePort", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Subscription_bridgePortsChanged_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Subscription_wanStatusChanged(ctx context.Context, field graphql.CollectedField) (ret func(ctx context.Context) graphql.Marshaler) {
	fc, err := ec.fieldContext_Subscription_wanStatusChanged(ctx, field)
	if err != nil {
		return nil
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = nil
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Subscription().WanStatusChanged(rctx, fc.Args["routerId"].(string), fc.Args["wanInterfaceId"].(*string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			requires, err := ec.unmarshalNString2string(ctx, []interface{}{"interface"})
			if err != nil {
				return nil, err
			}
			if ec.directives.Capability == nil {
				return nil, errors.New("directive capability is not implemented")
			}
			return ec.directives.Capability(ctx, nil, directive0, requires)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(<-chan *model.WANInterface); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be <-chan *backend/graph/model.WANInterface`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return nil
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return nil
	}
	return func(ctx context.Context) graphql.Marshaler {
		select {
		case res, ok := <-resTmp.(<-chan *model.WANInterface):
			if !ok {
				return nil
			}
			return graphql.WriterFunc(func(w io.Writer) {
				w.Write([]byte{'{'})
				graphql.MarshalString(field.Alias).MarshalGQL(w)
				w.Write([]byte{':'})
				ec.marshalNWANInterface2backendgraphmodelWANInterface(ctx, field.Selections, res).MarshalGQL(w)
				w.Write([]byte{'}'})
			})
		case <-ctx.Done():
			return nil
		}
	}
}

func (ec *executionContext) fieldContext_Subscription_wanStatusChanged(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Subscription",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_WANInterface_id(ctx, field)
			case "interface":
				return ec.fieldContext_WANInterface_interface(ctx, field)
			case "type":
				return ec.fieldContext_WANInterface_type(ctx, field)
			case "status":
				return ec.fieldContext_WANInterface_status(ctx, field)
			case "publicIP":
				return ec.fieldContext_WANInterface_publicIP(ctx, field)
			case "gateway":
				return ec.fieldContext_WANInterface_gateway(ctx, field)
			case "primaryDNS":
				return ec.fieldContext_WANInterface_primaryDNS(ctx, field)
			case "secondaryDNS":
				return ec.fieldContext_WANInterface_secondaryDNS(ctx, field)
			case "uptime":
				return ec.fieldContext_WANInterface_uptime(ctx, field)
			case "lastConnected":
				return ec.fieldContext_WANInterface_lastConnected(ctx, field)
			case "health":
				return ec.fieldContext_WANInterface_health(ctx, field)
			case "dhcpClient":
				return ec.fieldContext_WANInterface_dhcpClient(ctx, field)
			case "pppoeClient":
				return ec.fieldContext_WANInterface_pppoeClient(ctx, field)
			case "staticConfig":
				return ec.fieldContext_WANInterface_staticConfig(ctx, field)
			case "lteModem":
				return ec.fieldContext_WANInterface_lteModem(ctx, field)
			case "isDefaultRoute":
				return ec.fieldContext_WANInterface_isDefaultRoute(ctx, field)
			case "statistics":
				return ec.fieldContext_WANInterface_statistics(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type WANInterface", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Subscription_wanStatusChanged_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Subscription_wanHealthChanged(ctx context.Context, field graphql.CollectedField) (ret func(ctx context.Context) graphql.Marshaler) {
	fc, err := ec.fieldContext_Subscription_wanHealthChanged(ctx, field)
	if err != nil {
		return nil
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = nil
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Subscription().WanHealthChanged(rctx, fc.Args["routerId"].(string), fc.Args["wanInterfaceId"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			requires, err := ec.unmarshalNString2string(ctx, []interface{}{"interface"})
			if err != nil {
				return nil, err
			}
			if ec.directives.Capability == nil {
				return nil, errors.New("directive capability is not implemented")
			}
			return ec.directives.Capability(ctx, nil, directive0, requires)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(<-chan *model.WANHealthStatus); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be <-chan *backend/graph/model.WANHealthStatus`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return nil
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return nil
	}
	return func(ctx context.Context) graphql.Marshaler {
		select {
		case res, ok := <-resTmp.(<-chan *model.WANHealthStatus):
			if !ok {
				return nil
			}
			return graphql.WriterFunc(func(w io.Writer) {
				w.Write([]byte{'{'})
				graphql.MarshalString(field.Alias).MarshalGQL(w)
				w.Write([]byte{':'})
				ec.marshalNWANHealthStatus2backendgraphmodelWANHealthStatus(ctx, field.Selections, res).MarshalGQL(w)
				w.Write([]byte{'}'})
			})
		case <-ctx.Done():
			return nil
		}
	}
}

func (ec *executionContext) fieldContext_Subscription_wanHealthChanged(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Subscription",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "status":
				return ec.fieldContext_WANHealthStatus_status(ctx, field)
			case "target":
				return ec.fieldContext_WANHealthStatus_target(ctx, field)
			case "interval":
				return ec.fieldContext_WANHealthStatus_interval(ctx, field)
			case "latency":
				return ec.fieldContext_WANHealthStatus_latency(ctx, field)
			case "packetLoss":
				return ec.fieldContext_WANHealthStatus_packetLoss(ctx, field)
			case "successCount":
				return ec.fieldContext_WANHealthStatus_successCount(ctx, field)
			case "failureCount":
				return ec.fieldContext_WANHealthStatus_failureCount(ctx, field)
			case "lastCheck":
				return ec.fieldContext_WANHealthStatus_lastCheck(ctx, field)
			case "enabled":
				return ec.fieldContext_WANHealthStatus_enabled(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type WANHealthStatus", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Subscription_wanHealthChanged_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _TLSStatus_valid(ctx context.Context, field graphql.CollectedField, obj *model.TLSStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TLSStatus_valid(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Valid, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TLSStatus_valid(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TLSStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TLSStatus_issuer(ctx context.Context, field graphql.CollectedField, obj *model.TLSStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TLSStatus_issuer(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Issuer, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TLSStatus_issuer(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TLSStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TLSStatus_subject(ctx context.Context, field graphql.CollectedField, obj *model.TLSStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TLSStatus_subject(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Subject, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TLSStatus_subject(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TLSStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TLSStatus_expiresAt(ctx context.Context, field graphql.CollectedField, obj *model.TLSStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TLSStatus_expiresAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ExpiresAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalODateTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TLSStatus_expiresAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TLSStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DateTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TLSStatus_error(ctx context.Context, field graphql.CollectedField, obj *model.TLSStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TLSStatus_error(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Error, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TLSStatus_error(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TLSStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TelemetryData_bandwidthHistory(ctx context.Context, field graphql.CollectedField, obj *model.TelemetryData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TelemetryData_bandwidthHistory(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BandwidthHistory, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.BandwidthDataPoint)
	fc.Result = res
	return ec.marshalOBandwidthDataPoint2backendgraphmodelBandwidthDataPoint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TelemetryData_bandwidthHistory(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TelemetryData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "timestamp":
				return ec.fieldContext_BandwidthDataPoint_timestamp(ctx, field)
			case "bytesIn":
				return ec.fieldContext_BandwidthDataPoint_bytesIn(ctx, field)
			case "bytesOut":
				return ec.fieldContext_BandwidthDataPoint_bytesOut(ctx, field)
			case "periodSeconds":
				return ec.fieldContext_BandwidthDataPoint_periodSeconds(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type BandwidthDataPoint", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TelemetryData_uptimeHistory(ctx context.Context, field graphql.CollectedField, obj *model.TelemetryData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TelemetryData_uptimeHistory(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UptimeHistory, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.UptimeDataPoint)
	fc.Result = res
	return ec.marshalOUptimeDataPoint2backendgraphmodelUptimeDataPoint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TelemetryData_uptimeHistory(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TelemetryData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "timestamp":
				return ec.fieldContext_UptimeDataPoint_timestamp(ctx, field)
			case "isUp":
				return ec.fieldContext_UptimeDataPoint_isUp(ctx, field)
			case "periodSeconds":
				return ec.fieldContext_UptimeDataPoint_periodSeconds(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UptimeDataPoint", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TelemetryData_hourlyStats(ctx context.Context, field graphql.CollectedField, obj *model.TelemetryData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TelemetryData_hourlyStats(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HourlyStats, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.HourlyStats)
	fc.Result = res
	return ec.marshalOHourlyStats2backendgraphmodelHourlyStats(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TelemetryData_hourlyStats(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TelemetryData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hour":
				return ec.fieldContext_HourlyStats_hour(ctx, field)
			case "totalBytesIn":
				return ec.fieldContext_HourlyStats_totalBytesIn(ctx, field)
			case "totalBytesOut":
				return ec.fieldContext_HourlyStats_totalBytesOut(ctx, field)
			case "uptimePercent":
				return ec.fieldContext_HourlyStats_uptimePercent(ctx, field)
			case "errorCount":
				return ec.fieldContext_HourlyStats_errorCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type HourlyStats", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TelemetryData_dailyStats(ctx context.Context, field graphql.CollectedField, obj *model.TelemetryData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TelemetryData_dailyStats(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DailyStats, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.DailyStats)
	fc.Result = res
	return ec.marshalODailyStats2backendgraphmodelDailyStats(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TelemetryData_dailyStats(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TelemetryData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "date":
				return ec.fieldContext_DailyStats_date(ctx, field)
			case "totalBytesIn":
				return ec.fieldContext_DailyStats_totalBytesIn(ctx, field)
			case "totalBytesOut":
				return ec.fieldContext_DailyStats_totalBytesOut(ctx, field)
			case "uptimePercent":
				return ec.fieldContext_DailyStats_uptimePercent(ctx, field)
			case "errorCount":
				return ec.fieldContext_DailyStats_errorCount(ctx, field)
			case "peakThroughputIn":
				return ec.fieldContext_DailyStats_peakThroughputIn(ctx, field)
			case "peakThroughputOut":
				return ec.fieldContext_DailyStats_peakThroughputOut(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DailyStats", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TelemetryData_dataStartedAt(ctx context.Context, field graphql.CollectedField, obj *model.TelemetryData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TelemetryData_dataStartedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DataStartedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalODateTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TelemetryData_dataStartedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TelemetryData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DateTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TelemetryData_lastUpdatedAt(ctx context.Context, field graphql.CollectedField, obj *model.TelemetryData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TelemetryData_lastUpdatedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LastUpdatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalODateTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TelemetryData_lastUpdatedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TelemetryData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DateTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TelemetryData_retentionDays(ctx context.Context, field graphql.CollectedField, obj *model.TelemetryData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TelemetryData_retentionDays(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RetentionDays, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TelemetryData_retentionDays(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TelemetryData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TestAllCredentialsPayload_totalRouters(ctx context.Context, field graphql.CollectedField, obj *model.TestAllCredentialsPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TestAllCredentialsPayload_totalRouters(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalRouters, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TestAllCredentialsPayload_totalRouters(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TestAllCredentialsPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TestAllCredentialsPayload_successCount(ctx context.Context, field graphql.CollectedField, obj *model.TestAllCredentialsPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TestAllCredentialsPayload_successCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SuccessCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TestAllCredentialsPayload_successCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TestAllCredentialsPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TestAllCredentialsPayload_failureCount(ctx context.Context, field graphql.CollectedField, obj *model.TestAllCredentialsPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TestAllCredentialsPayload_failureCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FailureCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TestAllCredentialsPayload_failureCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TestAllCredentialsPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TestAllCredentialsPayload_results(ctx context.Context, field graphql.CollectedField, obj *model.TestAllCredentialsPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TestAllCredentialsPayload_results(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Results, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.CredentialTestResult)
	fc.Result = res
	return ec.marshalNCredentialTestResult2backendgraphmodelCredentialTestResult(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TestAllCredentialsPayload_results(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TestAllCredentialsPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "routerId":
				return ec.fieldContext_CredentialTestResult_routerId(ctx, field)
			case "routerName":
				return ec.fieldContext_CredentialTestResult_routerName(ctx, field)
			case "success":
				return ec.fieldContext_CredentialTestResult_success(ctx, field)
			case "status":
				return ec.fieldContext_CredentialTestResult_status(ctx, field)
			case "responseTimeMs":
				return ec.fieldContext_CredentialTestResult_responseTimeMs(ctx, field)
			case "error":
				return ec.fieldContext_CredentialTestResult_error(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CredentialTestResult", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TestConnectionPayload_success(ctx context.Context, field graphql.CollectedField, obj *model.TestConnectionPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TestConnectionPayload_success(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Success, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TestConnectionPayload_success(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TestConnectionPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TestConnectionPayload_responseTimeMs(ctx context.Context, field graphql.CollectedField, obj *model.TestConnectionPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TestConnectionPayload_responseTimeMs(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ResponseTimeMs, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TestConnectionPayload_responseTimeMs(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TestConnectionPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TestConnectionPayload_version(ctx context.Context, field graphql.CollectedField, obj *model.TestConnectionPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TestConnectionPayload_version(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Version, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TestConnectionPayload_version(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TestConnectionPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TestConnectionPayload_error(ctx context.Context, field graphql.CollectedField, obj *model.TestConnectionPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TestConnectionPayload_error(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Error, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TestConnectionPayload_error(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TestConnectionPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TestNotificationPayload_success(ctx context.Context, field graphql.CollectedField, obj *model.TestNotificationPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TestNotificationPayload_success(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Success, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TestNotificationPayload_success(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TestNotificationPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TestNotificationPayload_message(ctx context.Context, field graphql.CollectedField, obj *model.TestNotificationPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TestNotificationPayload_message(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TestNotificationPayload_message(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TestNotificationPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TestNotificationPayload_errors(ctx context.Context, field graphql.CollectedField, obj *model.TestNotificationPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TestNotificationPayload_errors(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Errors, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.MutationError)
	fc.Result = res
	return ec.marshalOMutationError2backendgraphmodelMutationError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TestNotificationPayload_errors(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TestNotificationPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "code":
				return ec.fieldContext_MutationError_code(ctx, field)
			case "message":
				return ec.fieldContext_MutationError_message(ctx, field)
			case "field":
				return ec.fieldContext_MutationError_field(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MutationError", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ThrottleConfig_maxAlerts(ctx context.Context, field graphql.CollectedField, obj *model.ThrottleConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ThrottleConfig_maxAlerts(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MaxAlerts, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ThrottleConfig_maxAlerts(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ThrottleConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ThrottleConfig_periodSeconds(ctx context.Context, field graphql.CollectedField, obj *model.ThrottleConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ThrottleConfig_periodSeconds(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PeriodSeconds, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ThrottleConfig_periodSeconds(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ThrottleConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ThrottleConfig_groupByField(ctx context.Context, field graphql.CollectedField, obj *model.ThrottleConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ThrottleConfig_groupByField(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.GroupByField, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ThrottleConfig_groupByField(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ThrottleConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TopologyEdge_id(ctx context.Context, field graphql.CollectedField, obj *model.TopologyEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TopologyEdge_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TopologyEdge_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TopologyEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TopologyEdge_source(ctx context.Context, field graphql.CollectedField, obj *model.TopologyEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TopologyEdge_source(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Source, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TopologyEdge_source(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TopologyEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TopologyEdge_target(ctx context.Context, field graphql.CollectedField, obj *model.TopologyEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TopologyEdge_target(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Target, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TopologyEdge_target(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TopologyEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TopologyEdge_label(ctx context.Context, field graphql.CollectedField, obj *model.TopologyEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TopologyEdge_label(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Label, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TopologyEdge_label(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TopologyEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TopologyEdge_data(ctx context.Context, field graphql.CollectedField, obj *model.TopologyEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TopologyEdge_data(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Data, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOJSON2map(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TopologyEdge_data(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TopologyEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type JSON does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TopologyEdge_style(ctx context.Context, field graphql.CollectedField, obj *model.TopologyEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TopologyEdge_style(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Style, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.TopologyEdgeStyle)
	fc.Result = res
	return ec.marshalOTopologyEdgeStyle2backendgraphmodelTopologyEdgeStyle(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TopologyEdge_style(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TopologyEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "stroke":
				return ec.fieldContext_TopologyEdgeStyle_stroke(ctx, field)
			case "strokeWidth":
				return ec.fieldContext_TopologyEdgeStyle_strokeWidth(ctx, field)
			case "strokeDasharray":
				return ec.fieldContext_TopologyEdgeStyle_strokeDasharray(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TopologyEdgeStyle", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TopologyEdgeStyle_stroke(ctx context.Context, field graphql.CollectedField, obj *model.TopologyEdgeStyle) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TopologyEdgeStyle_stroke(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Stroke, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TopologyEdgeStyle_stroke(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TopologyEdgeStyle",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TopologyEdgeStyle_strokeWidth(ctx context.Context, field graphql.CollectedField, obj *model.TopologyEdgeStyle) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TopologyEdgeStyle_strokeWidth(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StrokeWidth, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TopologyEdgeStyle_strokeWidth(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TopologyEdgeStyle",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TopologyEdgeStyle_strokeDasharray(ctx context.Context, field graphql.CollectedField, obj *model.TopologyEdgeStyle) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TopologyEdgeStyle_strokeDasharray(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StrokeDasharray, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TopologyEdgeStyle_strokeDasharray(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TopologyEdgeStyle",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TopologyNode_id(ctx context.Context, field graphql.CollectedField, obj *model.TopologyNode) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TopologyNode_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TopologyNode_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TopologyNode",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TopologyNode_type(ctx context.Context, field graphql.CollectedField, obj *model.TopologyNode) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TopologyNode_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.TopologyNodeType)
	fc.Result = res
	return ec.marshalNTopologyNodeType2backendgraphmodelTopologyNodeType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TopologyNode_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TopologyNode",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type TopologyNodeType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TopologyNode_label(ctx context.Context, field graphql.CollectedField, obj *model.TopologyNode) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TopologyNode_label(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Label, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TopologyNode_label(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TopologyNode",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TopologyNode_sublabel(ctx context.Context, field graphql.CollectedField, obj *model.TopologyNode) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TopologyNode_sublabel(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Sublabel, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TopologyNode_sublabel(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TopologyNode",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TopologyNode_position(ctx context.Context, field graphql.CollectedField, obj *model.TopologyNode) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TopologyNode_position(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Position, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.TopologyPosition)
	fc.Result = res
	return ec.marshalNTopologyPosition2backendgraphmodelTopologyPosition(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TopologyNode_position(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TopologyNode",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "x":
				return ec.fieldContext_TopologyPosition_x(ctx, field)
			case "y":
				return ec.fieldContext_TopologyPosition_y(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TopologyPosition", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TopologyNode_data(ctx context.Context, field graphql.CollectedField, obj *model.TopologyNode) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TopologyNode_data(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Data, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOJSON2map(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TopologyNode_data(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TopologyNode",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type JSON does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TopologyNode_style(ctx context.Context, field graphql.CollectedField, obj *model.TopologyNode) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TopologyNode_style(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Style, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.TopologyNodeStyle)
	fc.Result = res
	return ec.marshalOTopologyNodeStyle2backendgraphmodelTopologyNodeStyle(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TopologyNode_style(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TopologyNode",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "fill":
				return ec.fieldContext_TopologyNodeStyle_fill(ctx, field)
			case "stroke":
				return ec.fieldContext_TopologyNodeStyle_stroke(ctx, field)
			case "strokeWidth":
				return ec.fieldContext_TopologyNodeStyle_strokeWidth(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TopologyNodeStyle", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TopologyNodeStyle_fill(ctx context.Context, field graphql.CollectedField, obj *model.TopologyNodeStyle) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TopologyNodeStyle_fill(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Fill, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TopologyNodeStyle_fill(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TopologyNodeStyle",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TopologyNodeStyle_stroke(ctx context.Context, field graphql.CollectedField, obj *model.TopologyNodeStyle) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TopologyNodeStyle_stroke(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Stroke, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TopologyNodeStyle_stroke(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TopologyNodeStyle",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TopologyNodeStyle_strokeWidth(ctx context.Context, field graphql.CollectedField, obj *model.TopologyNodeStyle) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TopologyNodeStyle_strokeWidth(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StrokeWidth, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TopologyNodeStyle_strokeWidth(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TopologyNodeStyle",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TopologyPosition_x(ctx context.Context, field graphql.CollectedField, obj *model.TopologyPosition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TopologyPosition_x(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.X, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TopologyPosition_x(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TopologyPosition",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TopologyPosition_y(ctx context.Context, field graphql.CollectedField, obj *model.TopologyPosition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TopologyPosition_y(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Y, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TopologyPosition_y(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TopologyPosition",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TracerouteHop_hopNumber(ctx context.Context, field graphql.CollectedField, obj *model.TracerouteHop) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TracerouteHop_hopNumber(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HopNumber, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TracerouteHop_hopNumber(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TracerouteHop",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TracerouteHop_address(ctx context.Context, field graphql.CollectedField, obj *model.TracerouteHop) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TracerouteHop_address(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Address, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TracerouteHop_address(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TracerouteHop",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TracerouteHop_hostname(ctx context.Context, field graphql.CollectedField, obj *model.TracerouteHop) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TracerouteHop_hostname(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Hostname, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TracerouteHop_hostname(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TracerouteHop",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TracerouteHop_probes(ctx context.Context, field graphql.CollectedField, obj *model.TracerouteHop) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TracerouteHop_probes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Probes, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.HopProbe)
	fc.Result = res
	return ec.marshalNHopProbe2backendgraphmodelHopProbe(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TracerouteHop_probes(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TracerouteHop",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "probeNumber":
				return ec.fieldContext_HopProbe_probeNumber(ctx, field)
			case "latencyMs":
				return ec.fieldContext_HopProbe_latencyMs(ctx, field)
			case "success":
				return ec.fieldContext_HopProbe_success(ctx, field)
			case "icmpCode":
				return ec.fieldContext_HopProbe_icmpCode(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type HopProbe", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TracerouteHop_status(ctx context.Context, field graphql.CollectedField, obj *model.TracerouteHop) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TracerouteHop_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.HopStatus)
	fc.Result = res
	return ec.marshalNHopStatus2backendgraphmodelHopStatus(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TracerouteHop_status(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TracerouteHop",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type HopStatus does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TracerouteHop_avgLatencyMs(ctx context.Context, field graphql.CollectedField, obj *model.TracerouteHop) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TracerouteHop_avgLatencyMs(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AvgLatencyMs, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TracerouteHop_avgLatencyMs(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TracerouteHop",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TracerouteHop_packetLoss(ctx context.Context, field graphql.CollectedField, obj *model.TracerouteHop) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TracerouteHop_packetLoss(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PacketLoss, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TracerouteHop_packetLoss(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TracerouteHop",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TracerouteJob_jobId(ctx context.Context, field graphql.CollectedField, obj *model.TracerouteJob) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TracerouteJob_jobId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.JobID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TracerouteJob_jobId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TracerouteJob",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TracerouteJob_status(ctx context.Context, field graphql.CollectedField, obj *model.TracerouteJob) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TracerouteJob_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.JobStatus)
	fc.Result = res
	return ec.marshalNJobStatus2backendgraphmodelJobStatus(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TracerouteJob_status(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TracerouteJob",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type JobStatus does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TracerouteProgressEvent_jobId(ctx context.Context, field graphql.CollectedField, obj *model.TracerouteProgressEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TracerouteProgressEvent_jobId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.JobID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TracerouteProgressEvent_jobId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TracerouteProgressEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TracerouteProgressEvent_eventType(ctx context.Context, field graphql.CollectedField, obj *model.TracerouteProgressEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TracerouteProgressEvent_eventType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EventType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.TracerouteEventType)
	fc.Result = res
	return ec.marshalNTracerouteEventType2backendgraphmodelTracerouteEventType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TracerouteProgressEvent_eventType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TracerouteProgressEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type TracerouteEventType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TracerouteProgressEvent_hop(ctx context.Context, field graphql.CollectedField, obj *model.TracerouteProgressEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TracerouteProgressEvent_hop(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Hop, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.TracerouteHop)
	fc.Result = res
	return ec.marshalOTracerouteHop2backendgraphmodelTracerouteHop(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TracerouteProgressEvent_hop(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TracerouteProgressEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hopNumber":
				return ec.fieldContext_TracerouteHop_hopNumber(ctx, field)
			case "address":
				return ec.fieldContext_TracerouteHop_address(ctx, field)
			case "hostname":
				return ec.fieldContext_TracerouteHop_hostname(ctx, field)
			case "probes":
				return ec.fieldContext_TracerouteHop_probes(ctx, field)
			case "status":
				return ec.fieldContext_TracerouteHop_status(ctx, field)
			case "avgLatencyMs":
				return ec.fieldContext_TracerouteHop_avgLatencyMs(ctx, field)
			case "packetLoss":
				return ec.fieldContext_TracerouteHop_packetLoss(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TracerouteHop", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TracerouteProgressEvent_result(ctx context.Context, field graphql.CollectedField, obj *model.TracerouteProgressEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TracerouteProgressEvent_result(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Result, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.TracerouteResult)
	fc.Result = res
	return ec.marshalOTracerouteResult2backendgraphmodelTracerouteResult(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TracerouteProgressEvent_result(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TracerouteProgressEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "target":
				return ec.fieldContext_TracerouteResult_target(ctx, field)
			case "targetIp":
				return ec.fieldContext_TracerouteResult_targetIp(ctx, field)
			case "protocol":
				return ec.fieldContext_TracerouteResult_protocol(ctx, field)
			case "maxHops":
				return ec.fieldContext_TracerouteResult_maxHops(ctx, field)
			case "hops":
				return ec.fieldContext_TracerouteResult_hops(ctx, field)
			case "completed":
				return ec.fieldContext_TracerouteResult_completed(ctx, field)
			case "reachedDestination":
				return ec.fieldContext_TracerouteResult_reachedDestination(ctx, field)
			case "totalTimeMs":
				return ec.fieldContext_TracerouteResult_totalTimeMs(ctx, field)
			case "startedAt":
				return ec.fieldContext_TracerouteResult_startedAt(ctx, field)
			case "completedAt":
				return ec.fieldContext_TracerouteResult_completedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TracerouteResult", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TracerouteProgressEvent_error(ctx context.Context, field graphql.CollectedField, obj *model.TracerouteProgressEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TracerouteProgressEvent_error(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Error, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TracerouteProgressEvent_error(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TracerouteProgressEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TracerouteResult_target(ctx context.Context, field graphql.CollectedField, obj *model.TracerouteResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TracerouteResult_target(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Target, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TracerouteResult_target(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TracerouteResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TracerouteResult_targetIp(ctx context.Context, field graphql.CollectedField, obj *model.TracerouteResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TracerouteResult_targetIp(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TargetIP, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TracerouteResult_targetIp(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TracerouteResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TracerouteResult_protocol(ctx context.Context, field graphql.CollectedField, obj *model.TracerouteResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TracerouteResult_protocol(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Protocol, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.TracerouteProtocol)
	fc.Result = res
	return ec.marshalNTracerouteProtocol2backendgraphmodelTracerouteProtocol(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TracerouteResult_protocol(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TracerouteResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type TracerouteProtocol does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TracerouteResult_maxHops(ctx context.Context, field graphql.CollectedField, obj *model.TracerouteResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TracerouteResult_maxHops(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MaxHops, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TracerouteResult_maxHops(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TracerouteResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TracerouteResult_hops(ctx context.Context, field graphql.CollectedField, obj *model.TracerouteResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TracerouteResult_hops(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Hops, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.TracerouteHop)
	fc.Result = res
	return ec.marshalNTracerouteHop2backendgraphmodelTracerouteHop(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TracerouteResult_hops(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TracerouteResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hopNumber":
				return ec.fieldContext_TracerouteHop_hopNumber(ctx, field)
			case "address":
				return ec.fieldContext_TracerouteHop_address(ctx, field)
			case "hostname":
				return ec.fieldContext_TracerouteHop_hostname(ctx, field)
			case "probes":
				return ec.fieldContext_TracerouteHop_probes(ctx, field)
			case "status":
				return ec.fieldContext_TracerouteHop_status(ctx, field)
			case "avgLatencyMs":
				return ec.fieldContext_TracerouteHop_avgLatencyMs(ctx, field)
			case "packetLoss":
				return ec.fieldContext_TracerouteHop_packetLoss(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TracerouteHop", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TracerouteResult_completed(ctx context.Context, field graphql.CollectedField, obj *model.TracerouteResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TracerouteResult_completed(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Completed, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TracerouteResult_completed(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TracerouteResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TracerouteResult_reachedDestination(ctx context.Context, field graphql.CollectedField, obj *model.TracerouteResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TracerouteResult_reachedDestination(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ReachedDestination, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TracerouteResult_reachedDestination(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TracerouteResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TracerouteResult_totalTimeMs(ctx context.Context, field graphql.CollectedField, obj *model.TracerouteResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TracerouteResult_totalTimeMs(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalTimeMs, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TracerouteResult_totalTimeMs(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TracerouteResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TracerouteResult_startedAt(ctx context.Context, field graphql.CollectedField, obj *model.TracerouteResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TracerouteResult_startedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StartedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNDateTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TracerouteResult_startedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TracerouteResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DateTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TracerouteResult_completedAt(ctx context.Context, field graphql.CollectedField, obj *model.TracerouteResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TracerouteResult_completedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CompletedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalODateTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TracerouteResult_completedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TracerouteResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DateTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TroubleshootFixSuggestion_issueCode(ctx context.Context, field graphql.CollectedField, obj *model.TroubleshootFixSuggestion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TroubleshootFixSuggestion_issueCode(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IssueCode, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TroubleshootFixSuggestion_issueCode(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TroubleshootFixSuggestion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TroubleshootFixSuggestion_title(ctx context.Context, field graphql.CollectedField, obj *model.TroubleshootFixSuggestion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TroubleshootFixSuggestion_title(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Title, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TroubleshootFixSuggestion_title(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TroubleshootFixSuggestion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TroubleshootFixSuggestion_explanation(ctx context.Context, field graphql.CollectedField, obj *model.TroubleshootFixSuggestion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TroubleshootFixSuggestion_explanation(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Explanation, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TroubleshootFixSuggestion_explanation(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TroubleshootFixSuggestion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TroubleshootFixSuggestion_confidence(ctx context.Context, field graphql.CollectedField, obj *model.TroubleshootFixSuggestion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TroubleshootFixSuggestion_confidence(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Confidence, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.FixConfidence)
	fc.Result = res
	return ec.marshalNFixConfidence2backendgraphmodelFixConfidence(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TroubleshootFixSuggestion_confidence(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TroubleshootFixSuggestion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type FixConfidence does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TroubleshootFixSuggestion_requiresConfirmation(ctx context.Context, field graphql.CollectedField, obj *model.TroubleshootFixSuggestion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TroubleshootFixSuggestion_requiresConfirmation(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RequiresConfirmation, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TroubleshootFixSuggestion_requiresConfirmation(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TroubleshootFixSuggestion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TroubleshootFixSuggestion_isManualFix(ctx context.Context, field graphql.CollectedField, obj *model.TroubleshootFixSuggestion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TroubleshootFixSuggestion_isManualFix(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsManualFix, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TroubleshootFixSuggestion_isManualFix(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TroubleshootFixSuggestion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TroubleshootFixSuggestion_manualSteps(ctx context.Context, field graphql.CollectedField, obj *model.TroubleshootFixSuggestion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TroubleshootFixSuggestion_manualSteps(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ManualSteps, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TroubleshootFixSuggestion_manualSteps(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TroubleshootFixSuggestion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TroubleshootFixSuggestion_command(ctx context.Context, field graphql.CollectedField, obj *model.TroubleshootFixSuggestion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TroubleshootFixSuggestion_command(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Command, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TroubleshootFixSuggestion_command(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TroubleshootFixSuggestion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TroubleshootFixSuggestion_rollbackCommand(ctx context.Context, field graphql.CollectedField, obj *model.TroubleshootFixSuggestion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TroubleshootFixSuggestion_rollbackCommand(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RollbackCommand, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TroubleshootFixSuggestion_rollbackCommand(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TroubleshootFixSuggestion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TroubleshootSession_id(ctx context.Context, field graphql.CollectedField, obj *model.TroubleshootSession) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TroubleshootSession_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TroubleshootSession_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TroubleshootSession",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TroubleshootSession_routerId(ctx context.Context, field graphql.CollectedField, obj *model.TroubleshootSession) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TroubleshootSession_routerId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RouterID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TroubleshootSession_routerId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TroubleshootSession",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TroubleshootSession_steps(ctx context.Context, field graphql.CollectedField, obj *model.TroubleshootSession) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TroubleshootSession_steps(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Steps, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.TroubleshootStep)
	fc.Result = res
	return ec.marshalNTroubleshootStep2backendgraphmodelTroubleshootStep(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TroubleshootSession_steps(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TroubleshootSession",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_TroubleshootStep_id(ctx, field)
			case "name":
				return ec.fieldContext_TroubleshootStep_name(ctx, field)
			case "description":
				return ec.fieldContext_TroubleshootStep_description(ctx, field)
			case "status":
				return ec.fieldContext_TroubleshootStep_status(ctx, field)
			case "result":
				return ec.fieldContext_TroubleshootStep_result(ctx, field)
			case "fix":
				return ec.fieldContext_TroubleshootStep_fix(ctx, field)
			case "startedAt":
				return ec.fieldContext_TroubleshootStep_startedAt(ctx, field)
			case "completedAt":
				return ec.fieldContext_TroubleshootStep_completedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TroubleshootStep", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TroubleshootSession_currentStepIndex(ctx context.Context, field graphql.CollectedField, obj *model.TroubleshootSession) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TroubleshootSession_currentStepIndex(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CurrentStepIndex, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TroubleshootSession_currentStepIndex(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TroubleshootSession",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TroubleshootSession_status(ctx context.Context, field graphql.CollectedField, obj *model.TroubleshootSession) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TroubleshootSession_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.TroubleshootSessionStatus)
	fc.Result = res
	return ec.marshalNTroubleshootSessionStatus2backendgraphmodelTroubleshootSessionStatus(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TroubleshootSession_status(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TroubleshootSession",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type TroubleshootSessionStatus does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TroubleshootSession_wanInterface(ctx context.Context, field graphql.CollectedField, obj *model.TroubleshootSession) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TroubleshootSession_wanInterface(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.WanInterface, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TroubleshootSession_wanInterface(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TroubleshootSession",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TroubleshootSession_gateway(ctx context.Context, field graphql.CollectedField, obj *model.TroubleshootSession) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TroubleshootSession_gateway(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Gateway, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TroubleshootSession_gateway(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TroubleshootSession",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TroubleshootSession_ispInfo(ctx context.Context, field graphql.CollectedField, obj *model.TroubleshootSession) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TroubleshootSession_ispInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IspInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.ISPInfo)
	fc.Result = res
	return ec.marshalOISPInfo2backendgraphmodelISPInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TroubleshootSession_ispInfo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TroubleshootSession",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_ISPInfo_name(ctx, field)
			case "phone":
				return ec.fieldContext_ISPInfo_phone(ctx, field)
			case "url":
				return ec.fieldContext_ISPInfo_url(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ISPInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TroubleshootSession_appliedFixes(ctx context.Context, field graphql.CollectedField, obj *model.TroubleshootSession) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TroubleshootSession_appliedFixes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AppliedFixes, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TroubleshootSession_appliedFixes(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TroubleshootSession",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TroubleshootSession_startedAt(ctx context.Context, field graphql.CollectedField, obj *model.TroubleshootSession) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TroubleshootSession_startedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StartedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNDateTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TroubleshootSession_startedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TroubleshootSession",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DateTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TroubleshootSession_completedAt(ctx context.Context, field graphql.CollectedField, obj *model.TroubleshootSession) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TroubleshootSession_completedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CompletedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalODateTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TroubleshootSession_completedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TroubleshootSession",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DateTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TroubleshootStep_id(ctx context.Context, field graphql.CollectedField, obj *model.TroubleshootStep) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TroubleshootStep_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.TroubleshootStepType)
	fc.Result = res
	return ec.marshalNTroubleshootStepType2backendgraphmodelTroubleshootStepType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TroubleshootStep_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TroubleshootStep",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type TroubleshootStepType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TroubleshootStep_name(ctx context.Context, field graphql.CollectedField, obj *model.TroubleshootStep) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TroubleshootStep_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TroubleshootStep_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TroubleshootStep",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TroubleshootStep_description(ctx context.Context, field graphql.CollectedField, obj *model.TroubleshootStep) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TroubleshootStep_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TroubleshootStep_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TroubleshootStep",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TroubleshootStep_status(ctx context.Context, field graphql.CollectedField, obj *model.TroubleshootStep) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TroubleshootStep_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.TroubleshootStepStatus)
	fc.Result = res
	return ec.marshalNTroubleshootStepStatus2backendgraphmodelTroubleshootStepStatus(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TroubleshootStep_status(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TroubleshootStep",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type TroubleshootStepStatus does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TroubleshootStep_result(ctx context.Context, field graphql.CollectedField, obj *model.TroubleshootStep) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TroubleshootStep_result(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Result, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.TroubleshootStepResult)
	fc.Result = res
	return ec.marshalOTroubleshootStepResult2backendgraphmodelTroubleshootStepResult(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TroubleshootStep_result(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TroubleshootStep",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "success":
				return ec.fieldContext_TroubleshootStepResult_success(ctx, field)
			case "message":
				return ec.fieldContext_TroubleshootStepResult_message(ctx, field)
			case "details":
				return ec.fieldContext_TroubleshootStepResult_details(ctx, field)
			case "executionTimeMs":
				return ec.fieldContext_TroubleshootStepResult_executionTimeMs(ctx, field)
			case "issueCode":
				return ec.fieldContext_TroubleshootStepResult_issueCode(ctx, field)
			case "target":
				return ec.fieldContext_TroubleshootStepResult_target(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TroubleshootStepResult", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TroubleshootStep_fix(ctx context.Context, field graphql.CollectedField, obj *model.TroubleshootStep) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TroubleshootStep_fix(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Fix, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.TroubleshootFixSuggestion)
	fc.Result = res
	return ec.marshalOTroubleshootFixSuggestion2backendgraphmodelTroubleshootFixSuggestion(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TroubleshootStep_fix(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TroubleshootStep",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "issueCode":
				return ec.fieldContext_TroubleshootFixSuggestion_issueCode(ctx, field)
			case "title":
				return ec.fieldContext_TroubleshootFixSuggestion_title(ctx, field)
			case "explanation":
				return ec.fieldContext_TroubleshootFixSuggestion_explanation(ctx, field)
			case "confidence":
				return ec.fieldContext_TroubleshootFixSuggestion_confidence(ctx, field)
			case "requiresConfirmation":
				return ec.fieldContext_TroubleshootFixSuggestion_requiresConfirmation(ctx, field)
			case "isManualFix":
				return ec.fieldContext_TroubleshootFixSuggestion_isManualFix(ctx, field)
			case "manualSteps":
				return ec.fieldContext_TroubleshootFixSuggestion_manualSteps(ctx, field)
			case "command":
				return ec.fieldContext_TroubleshootFixSuggestion_command(ctx, field)
			case "rollbackCommand":
				return ec.fieldContext_TroubleshootFixSuggestion_rollbackCommand(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TroubleshootFixSuggestion", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TroubleshootStep_startedAt(ctx context.Context, field graphql.CollectedField, obj *model.TroubleshootStep) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TroubleshootStep_startedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StartedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalODateTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TroubleshootStep_startedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TroubleshootStep",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DateTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TroubleshootStep_completedAt(ctx context.Context, field graphql.CollectedField, obj *model.TroubleshootStep) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TroubleshootStep_completedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CompletedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalODateTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TroubleshootStep_completedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TroubleshootStep",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DateTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TroubleshootStepResult_success(ctx context.Context, field graphql.CollectedField, obj *model.TroubleshootStepResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TroubleshootStepResult_success(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Success, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TroubleshootStepResult_success(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TroubleshootStepResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TroubleshootStepResult_message(ctx context.Context, field graphql.CollectedField, obj *model.TroubleshootStepResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TroubleshootStepResult_message(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TroubleshootStepResult_message(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TroubleshootStepResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TroubleshootStepResult_details(ctx context.Context, field graphql.CollectedField, obj *model.TroubleshootStepResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TroubleshootStepResult_details(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Details, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TroubleshootStepResult_details(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TroubleshootStepResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TroubleshootStepResult_executionTimeMs(ctx context.Context, field graphql.CollectedField, obj *model.TroubleshootStepResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TroubleshootStepResult_executionTimeMs(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ExecutionTimeMs, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TroubleshootStepResult_executionTimeMs(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TroubleshootStepResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TroubleshootStepResult_issueCode(ctx context.Context, field graphql.CollectedField, obj *model.TroubleshootStepResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TroubleshootStepResult_issueCode(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IssueCode, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TroubleshootStepResult_issueCode(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TroubleshootStepResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TroubleshootStepResult_target(ctx context.Context, field graphql.CollectedField, obj *model.TroubleshootStepResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TroubleshootStepResult_target(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Target, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TroubleshootStepResult_target(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TroubleshootStepResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UpdateChangeSetItemPayload_changeSet(ctx context.Context, field graphql.CollectedField, obj *model.UpdateChangeSetItemPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UpdateChangeSetItemPayload_changeSet(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ChangeSet, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.ChangeSet)
	fc.Result = res
	return ec.marshalOChangeSet2backendgraphmodelChangeSet(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UpdateChangeSetItemPayload_changeSet(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UpdateChangeSetItemPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ChangeSet_id(ctx, field)
			case "name":
				return ec.fieldContext_ChangeSet_name(ctx, field)
			case "description":
				return ec.fieldContext_ChangeSet_description(ctx, field)
			case "routerId":
				return ec.fieldContext_ChangeSet_routerId(ctx, field)
			case "items":
				return ec.fieldContext_ChangeSet_items(ctx, field)
			case "status":
				return ec.fieldContext_ChangeSet_status(ctx, field)
			case "validation":
				return ec.fieldContext_ChangeSet_validation(ctx, field)
			case "rollbackPlan":
				return ec.fieldContext_ChangeSet_rollbackPlan(ctx, field)
			case "error":
				return ec.fieldContext_ChangeSet_error(ctx, field)
			case "createdAt":
				return ec.fieldContext_ChangeSet_createdAt(ctx, field)
			case "applyStartedAt":
				return ec.fieldContext_ChangeSet_applyStartedAt(ctx, field)
			case "completedAt":
				return ec.fieldContext_ChangeSet_completedAt(ctx, field)
			case "createdBy":
				return ec.fieldContext_ChangeSet_createdBy(ctx, field)
			case "source":
				return ec.fieldContext_ChangeSet_source(ctx, field)
			case "version":
				return ec.fieldContext_ChangeSet_version(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ChangeSet", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _UpdateChangeSetItemPayload_errors(ctx context.Context, field graphql.CollectedField, obj *model.UpdateChangeSetItemPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UpdateChangeSetItemPayload_errors(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Errors, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.MutationError)
	fc.Result = res
	return ec.marshalOMutationError2backendgraphmodelMutationError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UpdateChangeSetItemPayload_errors(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UpdateChangeSetItemPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "code":
				return ec.fieldContext_MutationError_code(ctx, field)
			case "message":
				return ec.fieldContext_MutationError_message(ctx, field)
			case "field":
				return ec.fieldContext_MutationError_field(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MutationError", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _UpdateInterfacePayload_interface(ctx context.Context, field graphql.CollectedField, obj *model.UpdateInterfacePayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UpdateInterfacePayload_interface(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Interface, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Interface)
	fc.Result = res
	return ec.marshalOInterface2backendgraphmodelInterface(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UpdateInterfacePayload_interface(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UpdateInterfacePayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Interface_id(ctx, field)
			case "name":
				return ec.fieldContext_Interface_name(ctx, field)
			case "type":
				return ec.fieldContext_Interface_type(ctx, field)
			case "enabled":
				return ec.fieldContext_Interface_enabled(ctx, field)
			case "running":
				return ec.fieldContext_Interface_running(ctx, field)
			case "macAddress":
				return ec.fieldContext_Interface_macAddress(ctx, field)
			case "mtu":
				return ec.fieldContext_Interface_mtu(ctx, field)
			case "comment":
				return ec.fieldContext_Interface_comment(ctx, field)
			case "txBytes":
				return ec.fieldContext_Interface_txBytes(ctx, field)
			case "rxBytes":
				return ec.fieldContext_Interface_rxBytes(ctx, field)
			case "ip":
				return ec.fieldContext_Interface_ip(ctx, field)
			case "status":
				return ec.fieldContext_Interface_status(ctx, field)
			case "txRate":
				return ec.fieldContext_Interface_txRate(ctx, field)
			case "rxRate":
				return ec.fieldContext_Interface_rxRate(ctx, field)
			case "linkSpeed":
				return ec.fieldContext_Interface_linkSpeed(ctx, field)
			case "lastSeen":
				return ec.fieldContext_Interface_lastSeen(ctx, field)
			case "linkPartner":
				return ec.fieldContext_Interface_linkPartner(ctx, field)
			case "usedBy":
				return ec.fieldContext_Interface_usedBy(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Interface", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _UpdateInterfacePayload_errors(ctx context.Context, field graphql.CollectedField, obj *model.UpdateInterfacePayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UpdateInterfacePayload_errors(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Errors, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.MutationError)
	fc.Result = res
	return ec.marshalOMutationError2backendgraphmodelMutationError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UpdateInterfacePayload_errors(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UpdateInterfacePayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "code":
				return ec.fieldContext_MutationError_code(ctx, field)
			case "message":
				return ec.fieldContext_MutationError_message(ctx, field)
			case "field":
				return ec.fieldContext_MutationError_field(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MutationError", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _UpdateResourcePayload_resource(ctx context.Context, field graphql.CollectedField, obj *model.UpdateResourcePayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UpdateResourcePayload_resource(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Resource, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(model.Resource)
	fc.Result = res
	return ec.marshalOResource2backendgraphmodelResource(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UpdateResourcePayload_resource(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UpdateResourcePayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("FieldContext.Child cannot be called on type INTERFACE")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UpdateResourcePayload_errors(ctx context.Context, field graphql.CollectedField, obj *model.UpdateResourcePayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UpdateResourcePayload_errors(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Errors, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.MutationError)
	fc.Result = res
	return ec.marshalOMutationError2backendgraphmodelMutationError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UpdateResourcePayload_errors(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UpdateResourcePayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "code":
				return ec.fieldContext_MutationError_code(ctx, field)
			case "message":
				return ec.fieldContext_MutationError_message(ctx, field)
			case "field":
				return ec.fieldContext_MutationError_field(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MutationError", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _UpdateRouterPayload_router(ctx context.Context, field graphql.CollectedField, obj *model.UpdateRouterPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UpdateRouterPayload_router(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Router, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Router)
	fc.Result = res
	return ec.marshalORouter2backendgraphmodelRouter(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UpdateRouterPayload_router(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UpdateRouterPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Router_id(ctx, field)
			case "name":
				return ec.fieldContext_Router_name(ctx, field)
			case "host":
				return ec.fieldContext_Router_host(ctx, field)
			case "port":
				return ec.fieldContext_Router_port(ctx, field)
			case "status":
				return ec.fieldContext_Router_status(ctx, field)
			case "platform":
				return ec.fieldContext_Router_platform(ctx, field)
			case "version":
				return ec.fieldContext_Router_version(ctx, field)
			case "model":
				return ec.fieldContext_Router_model(ctx, field)
			case "uptime":
				return ec.fieldContext_Router_uptime(ctx, field)
			case "lastConnected":
				return ec.fieldContext_Router_lastConnected(ctx, field)
			case "createdAt":
				return ec.fieldContext_Router_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Router_updatedAt(ctx, field)
			case "capabilities":
				return ec.fieldContext_Router_capabilities(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Router", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _UpdateRouterPayload_errors(ctx context.Context, field graphql.CollectedField, obj *model.UpdateRouterPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UpdateRouterPayload_errors(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Errors, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.MutationError)
	fc.Result = res
	return ec.marshalOMutationError2backendgraphmodelMutationError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UpdateRouterPayload_errors(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UpdateRouterPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "code":
				return ec.fieldContext_MutationError_code(ctx, field)
			case "message":
				return ec.fieldContext_MutationError_message(ctx, field)
			case "field":
				return ec.fieldContext_MutationError_field(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MutationError", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _UpgradeImpact_requiresReboot(ctx context.Context, field graphql.CollectedField, obj *model.UpgradeImpact) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UpgradeImpact_requiresReboot(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RequiresReboot, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UpgradeImpact_requiresReboot(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UpgradeImpact",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UpgradeImpact_estimatedDowntime(ctx context.Context, field graphql.CollectedField, obj *model.UpgradeImpact) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UpgradeImpact_estimatedDowntime(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EstimatedDowntime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UpgradeImpact_estimatedDowntime(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UpgradeImpact",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UpgradeImpact_backupRecommended(ctx context.Context, field graphql.CollectedField, obj *model.UpgradeImpact) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UpgradeImpact_backupRecommended(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BackupRecommended, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UpgradeImpact_backupRecommended(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UpgradeImpact",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UpgradeImpact_breakingChanges(ctx context.Context, field graphql.CollectedField, obj *model.UpgradeImpact) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UpgradeImpact_breakingChanges(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BreakingChanges, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UpgradeImpact_breakingChanges(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UpgradeImpact",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UpgradeRecommendation_featureId(ctx context.Context, field graphql.CollectedField, obj *model.UpgradeRecommendation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UpgradeRecommendation_featureId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FeatureID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UpgradeRecommendation_featureId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UpgradeRecommendation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UpgradeRecommendation_featureName(ctx context.Context, field graphql.CollectedField, obj *model.UpgradeRecommendation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UpgradeRecommendation_featureName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FeatureName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UpgradeRecommendation_featureName(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UpgradeRecommendation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UpgradeRecommendation_currentVersion(ctx context.Context, field graphql.CollectedField, obj *model.UpgradeRecommendation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UpgradeRecommendation_currentVersion(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CurrentVersion, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UpgradeRecommendation_currentVersion(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UpgradeRecommendation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UpgradeRecommendation_requiredVersion(ctx context.Context, field graphql.CollectedField, obj *model.UpgradeRecommendation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UpgradeRecommendation_requiredVersion(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RequiredVersion, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UpgradeRecommendation_requiredVersion(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UpgradeRecommendation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UpgradeRecommendation_isMajorUpgrade(ctx context.Context, field graphql.CollectedField, obj *model.UpgradeRecommendation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UpgradeRecommendation_isMajorUpgrade(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsMajorUpgrade, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UpgradeRecommendation_isMajorUpgrade(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UpgradeRecommendation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UpgradeRecommendation_priority(ctx context.Context, field graphql.CollectedField, obj *model.UpgradeRecommendation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UpgradeRecommendation_priority(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Priority, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.UpgradePriority)
	fc.Result = res
	return ec.marshalNUpgradePriority2backendgraphmodelUpgradePriority(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UpgradeRecommendation_priority(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UpgradeRecommendation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type UpgradePriority does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UpgradeRecommendation_steps(ctx context.Context, field graphql.CollectedField, obj *model.UpgradeRecommendation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UpgradeRecommendation_steps(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Steps, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.UpgradeStep)
	fc.Result = res
	return ec.marshalNUpgradeStep2backendgraphmodelUpgradeStep(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UpgradeRecommendation_steps(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UpgradeRecommendation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "step":
				return ec.fieldContext_UpgradeStep_step(ctx, field)
			case "title":
				return ec.fieldContext_UpgradeStep_title(ctx, field)
			case "description":
				return ec.fieldContext_UpgradeStep_description(ctx, field)
			case "command":
				return ec.fieldContext_UpgradeStep_command(ctx, field)
			case "optional":
				return ec.fieldContext_UpgradeStep_optional(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UpgradeStep", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _UpgradeRecommendation_impact(ctx context.Context, field graphql.CollectedField, obj *model.UpgradeRecommendation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UpgradeRecommendation_impact(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Impact, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.UpgradeImpact)
	fc.Result = res
	return ec.marshalNUpgradeImpact2backendgraphmodelUpgradeImpact(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UpgradeRecommendation_impact(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UpgradeRecommendation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "requiresReboot":
				return ec.fieldContext_UpgradeImpact_requiresReboot(ctx, field)
			case "estimatedDowntime":
				return ec.fieldContext_UpgradeImpact_estimatedDowntime(ctx, field)
			case "backupRecommended":
				return ec.fieldContext_UpgradeImpact_backupRecommended(ctx, field)
			case "breakingChanges":
				return ec.fieldContext_UpgradeImpact_breakingChanges(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UpgradeImpact", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _UpgradeRecommendation_documentationUrl(ctx context.Context, field graphql.CollectedField, obj *model.UpgradeRecommendation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UpgradeRecommendation_documentationUrl(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DocumentationURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UpgradeRecommendation_documentationUrl(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UpgradeRecommendation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UpgradeRecommendation_warnings(ctx context.Context, field graphql.CollectedField, obj *model.UpgradeRecommendation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UpgradeRecommendation_warnings(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Warnings, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UpgradeRecommendation_warnings(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UpgradeRecommendation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UpgradeStep_step(ctx context.Context, field graphql.CollectedField, obj *model.UpgradeStep) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UpgradeStep_step(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Step, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UpgradeStep_step(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UpgradeStep",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UpgradeStep_title(ctx context.Context, field graphql.CollectedField, obj *model.UpgradeStep) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UpgradeStep_title(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Title, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UpgradeStep_title(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UpgradeStep",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UpgradeStep_description(ctx context.Context, field graphql.CollectedField, obj *model.UpgradeStep) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UpgradeStep_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UpgradeStep_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UpgradeStep",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UpgradeStep_command(ctx context.Context, field graphql.CollectedField, obj *model.UpgradeStep) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UpgradeStep_command(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Command, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UpgradeStep_command(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UpgradeStep",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UpgradeStep_optional(ctx context.Context, field graphql.CollectedField, obj *model.UpgradeStep) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UpgradeStep_optional(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Optional, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UpgradeStep_optional(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UpgradeStep",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UptimeDataPoint_timestamp(ctx context.Context, field graphql.CollectedField, obj *model.UptimeDataPoint) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UptimeDataPoint_timestamp(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Timestamp, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNDateTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UptimeDataPoint_timestamp(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UptimeDataPoint",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DateTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UptimeDataPoint_isUp(ctx context.Context, field graphql.CollectedField, obj *model.UptimeDataPoint) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UptimeDataPoint_isUp(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsUp, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UptimeDataPoint_isUp(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UptimeDataPoint",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UptimeDataPoint_periodSeconds(ctx context.Context, field graphql.CollectedField, obj *model.UptimeDataPoint) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UptimeDataPoint_periodSeconds(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PeriodSeconds, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UptimeDataPoint_periodSeconds(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UptimeDataPoint",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_id(ctx context.Context, field graphql.CollectedField, obj *model.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_username(ctx context.Context, field graphql.CollectedField, obj *model.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_username(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Username, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_username(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_role(ctx context.Context, field graphql.CollectedField, obj *model.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_role(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Role, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.UserRole)
	fc.Result = res
	return ec.marshalNUserRole2backendgraphmodelUserRole(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_role(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type UserRole does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_email(ctx context.Context, field graphql.CollectedField, obj *model.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_email(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Email, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_email(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_displayName(ctx context.Context, field graphql.CollectedField, obj *model.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_displayName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DisplayName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_displayName(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_createdAt(ctx context.Context, field graphql.CollectedField, obj *model.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNDateTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_createdAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DateTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_lastLoginAt(ctx context.Context, field graphql.CollectedField, obj *model.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_lastLoginAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LastLoginAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalODateTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_lastLoginAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DateTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _VIFGuidanceStep_step(ctx context.Context, field graphql.CollectedField, obj *model.VIFGuidanceStep) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_VIFGuidanceStep_step(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Step, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_VIFGuidanceStep_step(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "VIFGuidanceStep",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _VIFGuidanceStep_title(ctx context.Context, field graphql.CollectedField, obj *model.VIFGuidanceStep) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_VIFGuidanceStep_title(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Title, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_VIFGuidanceStep_title(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "VIFGuidanceStep",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _VIFGuidanceStep_description(ctx context.Context, field graphql.CollectedField, obj *model.VIFGuidanceStep) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_VIFGuidanceStep_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_VIFGuidanceStep_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "VIFGuidanceStep",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _VIFGuidanceStep_completed(ctx context.Context, field graphql.CollectedField, obj *model.VIFGuidanceStep) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_VIFGuidanceStep_completed(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Completed, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_VIFGuidanceStep_completed(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "VIFGuidanceStep",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _VIFGuidanceStep_routerCommand(ctx context.Context, field graphql.CollectedField, obj *model.VIFGuidanceStep) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_VIFGuidanceStep_routerCommand(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RouterCommand, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_VIFGuidanceStep_routerCommand(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "VIFGuidanceStep",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _VIFRequirements_met(ctx context.Context, field graphql.CollectedField, obj *model.VIFRequirements) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_VIFRequirements_met(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Met, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_VIFRequirements_met(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "VIFRequirements",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _VIFRequirements_routerOSVersion(ctx context.Context, field graphql.CollectedField, obj *model.VIFRequirements) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_VIFRequirements_routerOSVersion(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RouterOSVersion, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_VIFRequirements_routerOSVersion(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "VIFRequirements",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _VIFRequirements_containerPackage(ctx context.Context, field graphql.CollectedField, obj *model.VIFRequirements) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_VIFRequirements_containerPackage(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ContainerPackage, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_VIFRequirements_containerPackage(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "VIFRequirements",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _VIFRequirements_containerEnabled(ctx context.Context, field graphql.CollectedField, obj *model.VIFRequirements) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_VIFRequirements_containerEnabled(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ContainerEnabled, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_VIFRequirements_containerEnabled(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "VIFRequirements",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _VIFRequirements_sufficientStorage(ctx context.Context, field graphql.CollectedField, obj *model.VIFRequirements) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_VIFRequirements_sufficientStorage(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SufficientStorage, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_VIFRequirements_sufficientStorage(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "VIFRequirements",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _VIFRequirements_networkNamespace(ctx context.Context, field graphql.CollectedField, obj *model.VIFRequirements) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_VIFRequirements_networkNamespace(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NetworkNamespace, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_VIFRequirements_networkNamespace(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "VIFRequirements",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _VIFRequirements_missingReasons(ctx context.Context, field graphql.CollectedField, obj *model.VIFRequirements) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_VIFRequirements_missingReasons(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MissingReasons, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_VIFRequirements_missingReasons(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "VIFRequirements",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _VIFRequirements_guidanceSteps(ctx context.Context, field graphql.CollectedField, obj *model.VIFRequirements) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_VIFRequirements_guidanceSteps(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.GuidanceSteps, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.VIFGuidanceStep)
	fc.Result = res
	return ec.marshalNVIFGuidanceStep2backendgraphmodelVIFGuidanceStep(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_VIFRequirements_guidanceSteps(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "VIFRequirements",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "step":
				return ec.fieldContext_VIFGuidanceStep_step(ctx, field)
			case "title":
				return ec.fieldContext_VIFGuidanceStep_title(ctx, field)
			case "description":
				return ec.fieldContext_VIFGuidanceStep_description(ctx, field)
			case "completed":
				return ec.fieldContext_VIFGuidanceStep_completed(ctx, field)
			case "routerCommand":
				return ec.fieldContext_VIFGuidanceStep_routerCommand(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type VIFGuidanceStep", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ValidateChangeSetPayload_changeSet(ctx context.Context, field graphql.CollectedField, obj *model.ValidateChangeSetPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ValidateChangeSetPayload_changeSet(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ChangeSet, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.ChangeSet)
	fc.Result = res
	return ec.marshalOChangeSet2backendgraphmodelChangeSet(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ValidateChangeSetPayload_changeSet(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ValidateChangeSetPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ChangeSet_id(ctx, field)
			case "name":
				return ec.fieldContext_ChangeSet_name(ctx, field)
			case "description":
				return ec.fieldContext_ChangeSet_description(ctx, field)
			case "routerId":
				return ec.fieldContext_ChangeSet_routerId(ctx, field)
			case "items":
				return ec.fieldContext_ChangeSet_items(ctx, field)
			case "status":
				return ec.fieldContext_ChangeSet_status(ctx, field)
			case "validation":
				return ec.fieldContext_ChangeSet_validation(ctx, field)
			case "rollbackPlan":
				return ec.fieldContext_ChangeSet_rollbackPlan(ctx, field)
			case "error":
				return ec.fieldContext_ChangeSet_error(ctx, field)
			case "createdAt":
				return ec.fieldContext_ChangeSet_createdAt(ctx, field)
			case "applyStartedAt":
				return ec.fieldContext_ChangeSet_applyStartedAt(ctx, field)
			case "completedAt":
				return ec.fieldContext_ChangeSet_completedAt(ctx, field)
			case "createdBy":
				return ec.fieldContext_ChangeSet_createdBy(ctx, field)
			case "source":
				return ec.fieldContext_ChangeSet_source(ctx, field)
			case "version":
				return ec.fieldContext_ChangeSet_version(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ChangeSet", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ValidateChangeSetPayload_validation(ctx context.Context, field graphql.CollectedField, obj *model.ValidateChangeSetPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ValidateChangeSetPayload_validation(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Validation, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.ChangeSetValidationResult)
	fc.Result = res
	return ec.marshalOChangeSetValidationResult2backendgraphmodelChangeSetValidationResult(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ValidateChangeSetPayload_validation(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ValidateChangeSetPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "canApply":
				return ec.fieldContext_ChangeSetValidationResult_canApply(ctx, field)
			case "errors":
				return ec.fieldContext_ChangeSetValidationResult_errors(ctx, field)
			case "warnings":
				return ec.fieldContext_ChangeSetValidationResult_warnings(ctx, field)
			case "conflicts":
				return ec.fieldContext_ChangeSetValidationResult_conflicts(ctx, field)
			case "missingDependencies":
				return ec.fieldContext_ChangeSetValidationResult_missingDependencies(ctx, field)
			case "circularDependencies":
				return ec.fieldContext_ChangeSetValidationResult_circularDependencies(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ChangeSetValidationResult", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ValidateChangeSetPayload_errors(ctx context.Context, field graphql.CollectedField, obj *model.ValidateChangeSetPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ValidateChangeSetPayload_errors(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Errors, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.MutationError)
	fc.Result = res
	return ec.marshalOMutationError2backendgraphmodelMutationError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ValidateChangeSetPayload_errors(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ValidateChangeSetPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "code":
				return ec.fieldContext_MutationError_code(ctx, field)
			case "message":
				return ec.fieldContext_MutationError_message(ctx, field)
			case "field":
				return ec.fieldContext_MutationError_field(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MutationError", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ValidateResourcePayload_resource(ctx context.Context, field graphql.CollectedField, obj *model.ValidateResourcePayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ValidateResourcePayload_resource(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Resource, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(model.Resource)
	fc.Result = res
	return ec.marshalOResource2backendgraphmodelResource(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ValidateResourcePayload_resource(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ValidateResourcePayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("FieldContext.Child cannot be called on type INTERFACE")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ValidateResourcePayload_validation(ctx context.Context, field graphql.CollectedField, obj *model.ValidateResourcePayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ValidateResourcePayload_validation(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Validation, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.ValidationResult)
	fc.Result = res
	return ec.marshalOValidationResult2backendgraphmodelValidationResult(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ValidateResourcePayload_validation(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ValidateResourcePayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "canApply":
				return ec.fieldContext_ValidationResult_canApply(ctx, field)
			case "stage":
				return ec.fieldContext_ValidationResult_stage(ctx, field)
			case "errors":
				return ec.fieldContext_ValidationResult_errors(ctx, field)
			case "warnings":
				return ec.fieldContext_ValidationResult_warnings(ctx, field)
			case "conflicts":
				return ec.fieldContext_ValidationResult_conflicts(ctx, field)
			case "requiredDependencies":
				return ec.fieldContext_ValidationResult_requiredDependencies(ctx, field)
			case "validatedAt":
				return ec.fieldContext_ValidationResult_validatedAt(ctx, field)
			case "validationDurationMs":
				return ec.fieldContext_ValidationResult_validationDurationMs(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ValidationResult", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ValidateResourcePayload_errors(ctx context.Context, field graphql.CollectedField, obj *model.ValidateResourcePayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ValidateResourcePayload_errors(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Errors, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.MutationError)
	fc.Result = res
	return ec.marshalOMutationError2backendgraphmodelMutationError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ValidateResourcePayload_errors(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ValidateResourcePayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "code":
				return ec.fieldContext_MutationError_code(ctx, field)
			case "message":
				return ec.fieldContext_MutationError_message(ctx, field)
			case "field":
				return ec.fieldContext_MutationError_field(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MutationError", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ValidationError_field(ctx context.Context, field graphql.CollectedField, obj *model.ValidationError) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ValidationError_field(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Field, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ValidationError_field(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ValidationError",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ValidationError_code(ctx context.Context, field graphql.CollectedField, obj *model.ValidationError) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ValidationError_code(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Code, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ValidationError_code(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ValidationError",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ValidationError_message(ctx context.Context, field graphql.CollectedField, obj *model.ValidationError) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ValidationError_message(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ValidationError_message(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ValidationError",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ValidationError_suggestion(ctx context.Context, field graphql.CollectedField, obj *model.ValidationError) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ValidationError_suggestion(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Suggestion, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ValidationError_suggestion(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ValidationError",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ValidationError_providedValue(ctx context.Context, field graphql.CollectedField, obj *model.ValidationError) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ValidationError_providedValue(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ProvidedValue, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ValidationError_providedValue(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ValidationError",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ValidationIssue_code(ctx context.Context, field graphql.CollectedField, obj *model.ValidationIssue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ValidationIssue_code(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Code, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ValidationIssue_code(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ValidationIssue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ValidationIssue_message(ctx context.Context, field graphql.CollectedField, obj *model.ValidationIssue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ValidationIssue_message(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ValidationIssue_message(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ValidationIssue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ValidationIssue_field(ctx context.Context, field graphql.CollectedField, obj *model.ValidationIssue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ValidationIssue_field(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Field, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ValidationIssue_field(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ValidationIssue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ValidationIssue_severity(ctx context.Context, field graphql.CollectedField, obj *model.ValidationIssue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ValidationIssue_severity(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Severity, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.ValidationSeverity)
	fc.Result = res
	return ec.marshalNValidationSeverity2backendgraphmodelValidationSeverity(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ValidationIssue_severity(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ValidationIssue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ValidationSeverity does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ValidationIssue_suggestedFix(ctx context.Context, field graphql.CollectedField, obj *model.ValidationIssue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ValidationIssue_suggestedFix(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SuggestedFix, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ValidationIssue_suggestedFix(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ValidationIssue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ValidationIssue_docsUrl(ctx context.Context, field graphql.CollectedField, obj *model.ValidationIssue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ValidationIssue_docsUrl(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DocsURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ValidationIssue_docsUrl(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ValidationIssue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ValidationResult_canApply(ctx context.Context, field graphql.CollectedField, obj *model.ValidationResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ValidationResult_canApply(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CanApply, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ValidationResult_canApply(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ValidationResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ValidationResult_stage(ctx context.Context, field graphql.CollectedField, obj *model.ValidationResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ValidationResult_stage(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Stage, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.ValidationStage)
	fc.Result = res
	return ec.marshalNValidationStage2backendgraphmodelValidationStage(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ValidationResult_stage(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ValidationResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ValidationStage does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ValidationResult_errors(ctx context.Context, field graphql.CollectedField, obj *model.ValidationResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ValidationResult_errors(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Errors, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.ValidationIssue)
	fc.Result = res
	return ec.marshalNValidationIssue2backendgraphmodelValidationIssue(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ValidationResult_errors(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ValidationResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "code":
				return ec.fieldContext_ValidationIssue_code(ctx, field)
			case "message":
				return ec.fieldContext_ValidationIssue_message(ctx, field)
			case "field":
				return ec.fieldContext_ValidationIssue_field(ctx, field)
			case "severity":
				return ec.fieldContext_ValidationIssue_severity(ctx, field)
			case "suggestedFix":
				return ec.fieldContext_ValidationIssue_suggestedFix(ctx, field)
			case "docsUrl":
				return ec.fieldContext_ValidationIssue_docsUrl(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ValidationIssue", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ValidationResult_warnings(ctx context.Context, field graphql.CollectedField, obj *model.ValidationResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ValidationResult_warnings(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Warnings, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.ValidationIssue)
	fc.Result = res
	return ec.marshalNValidationIssue2backendgraphmodelValidationIssue(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ValidationResult_warnings(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ValidationResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "code":
				return ec.fieldContext_ValidationIssue_code(ctx, field)
			case "message":
				return ec.fieldContext_ValidationIssue_message(ctx, field)
			case "field":
				return ec.fieldContext_ValidationIssue_field(ctx, field)
			case "severity":
				return ec.fieldContext_ValidationIssue_severity(ctx, field)
			case "suggestedFix":
				return ec.fieldContext_ValidationIssue_suggestedFix(ctx, field)
			case "docsUrl":
				return ec.fieldContext_ValidationIssue_docsUrl(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ValidationIssue", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ValidationResult_conflicts(ctx context.Context, field graphql.CollectedField, obj *model.ValidationResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ValidationResult_conflicts(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Conflicts, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.ResourceConflict)
	fc.Result = res
	return ec.marshalNResourceConflict2backendgraphmodelResourceConflict(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ValidationResult_conflicts(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ValidationResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "type":
				return ec.fieldContext_ResourceConflict_type(ctx, field)
			case "conflictingResource":
				return ec.fieldContext_ResourceConflict_conflictingResource(ctx, field)
			case "conflictingResourceUuid":
				return ec.fieldContext_ResourceConflict_conflictingResourceUuid(ctx, field)
			case "description":
				return ec.fieldContext_ResourceConflict_description(ctx, field)
			case "resolution":
				return ec.fieldContext_ResourceConflict_resolution(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ResourceConflict", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ValidationResult_requiredDependencies(ctx context.Context, field graphql.CollectedField, obj *model.ValidationResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ValidationResult_requiredDependencies(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RequiredDependencies, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.DependencyStatus)
	fc.Result = res
	return ec.marshalNDependencyStatus2backendgraphmodelDependencyStatus(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ValidationResult_requiredDependencies(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ValidationResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "resourceUuid":
				return ec.fieldContext_DependencyStatus_resourceUuid(ctx, field)
			case "resourceType":
				return ec.fieldContext_DependencyStatus_resourceType(ctx, field)
			case "isActive":
				return ec.fieldContext_DependencyStatus_isActive(ctx, field)
			case "state":
				return ec.fieldContext_DependencyStatus_state(ctx, field)
			case "reason":
				return ec.fieldContext_DependencyStatus_reason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DependencyStatus", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ValidationResult_validatedAt(ctx context.Context, field graphql.CollectedField, obj *model.ValidationResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ValidationResult_validatedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ValidatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNDateTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ValidationResult_validatedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ValidationResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DateTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ValidationResult_validationDurationMs(ctx context.Context, field graphql.CollectedField, obj *model.ValidationResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ValidationResult_validationDurationMs(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ValidationDurationMs, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ValidationResult_validationDurationMs(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ValidationResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Vlan_id(ctx context.Context, field graphql.CollectedField, obj *model.Vlan) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Vlan_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Vlan_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Vlan",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Vlan_name(ctx context.Context, field graphql.CollectedField, obj *model.Vlan) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Vlan_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Name, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			minLength, err := ec.unmarshalOInt2int(ctx, 1)
			if err != nil {
				return nil, err
			}
			maxLength, err := ec.unmarshalOInt2int(ctx, 100)
			if err != nil {
				return nil, err
			}
			if ec.directives.Validate == nil {
				return nil, errors.New("directive validate is not implemented")
			}
			return ec.directives.Validate(ctx, obj, directive0, nil, nil, minLength, maxLength, nil, nil)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Vlan_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Vlan",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Vlan_vlanId(ctx context.Context, field graphql.CollectedField, obj *model.Vlan) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Vlan_vlanId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.VlanID, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			min, err := ec.unmarshalOInt2int(ctx, 1)
			if err != nil {
				return nil, err
			}
			max, err := ec.unmarshalOInt2int(ctx, 4094)
			if err != nil {
				return nil, err
			}
			if ec.directives.Validate == nil {
				return nil, errors.New("directive validate is not implemented")
			}
			return ec.directives.Validate(ctx, obj, directive0, min, max, nil, nil, nil, nil)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(int); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be int`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Vlan_vlanId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Vlan",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Vlan_interface(ctx context.Context, field graphql.CollectedField, obj *model.Vlan) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Vlan_interface(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Interface, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Interface)
	fc.Result = res
	return ec.marshalNInterface2backendgraphmodelInterface(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Vlan_interface(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Vlan",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Interface_id(ctx, field)
			case "name":
				return ec.fieldContext_Interface_name(ctx, field)
			case "type":
				return ec.fieldContext_Interface_type(ctx, field)
			case "enabled":
				return ec.fieldContext_Interface_enabled(ctx, field)
			case "running":
				return ec.fieldContext_Interface_running(ctx, field)
			case "macAddress":
				return ec.fieldContext_Interface_macAddress(ctx, field)
			case "mtu":
				return ec.fieldContext_Interface_mtu(ctx, field)
			case "comment":
				return ec.fieldContext_Interface_comment(ctx, field)
			case "txBytes":
				return ec.fieldContext_Interface_txBytes(ctx, field)
			case "rxBytes":
				return ec.fieldContext_Interface_rxBytes(ctx, field)
			case "ip":
				return ec.fieldContext_Interface_ip(ctx, field)
			case "status":
				return ec.fieldContext_Interface_status(ctx, field)
			case "txRate":
				return ec.fieldContext_Interface_txRate(ctx, field)
			case "rxRate":
				return ec.fieldContext_Interface_rxRate(ctx, field)
			case "linkSpeed":
				return ec.fieldContext_Interface_linkSpeed(ctx, field)
			case "lastSeen":
				return ec.fieldContext_Interface_lastSeen(ctx, field)
			case "linkPartner":
				return ec.fieldContext_Interface_linkPartner(ctx, field)
			case "usedBy":
				return ec.fieldContext_Interface_usedBy(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Interface", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Vlan_mtu(ctx context.Context, field graphql.CollectedField, obj *model.Vlan) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Vlan_mtu(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Mtu, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			min, err := ec.unmarshalOInt2int(ctx, 68)
			if err != nil {
				return nil, err
			}
			max, err := ec.unmarshalOInt2int(ctx, 65535)
			if err != nil {
				return nil, err
			}
			if ec.directives.Validate == nil {
				return nil, errors.New("directive validate is not implemented")
			}
			return ec.directives.Validate(ctx, obj, directive0, min, max, nil, nil, nil, nil)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*int); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *int`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Vlan_mtu(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Vlan",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Vlan_macAddress(ctx context.Context, field graphql.CollectedField, obj *model.Vlan) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Vlan_macAddress(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MacAddress, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.MAC)
	fc.Result = res
	return ec.marshalOMAC2backendgraphmodelMAC(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Vlan_macAddress(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Vlan",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type MAC does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Vlan_disabled(ctx context.Context, field graphql.CollectedField, obj *model.Vlan) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Vlan_disabled(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Disabled, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Vlan_disabled(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Vlan",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Vlan_running(ctx context.Context, field graphql.CollectedField, obj *model.Vlan) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Vlan_running(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Running, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Vlan_running(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Vlan",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Vlan_comment(ctx context.Context, field graphql.CollectedField, obj *model.Vlan) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Vlan_comment(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Comment, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Vlan_comment(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Vlan",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Vlan_ipAddresses(ctx context.Context, field graphql.CollectedField, obj *model.Vlan) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Vlan_ipAddresses(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IPAddresses, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.IPAddress)
	fc.Result = res
	return ec.marshalNIpAddress2backendgraphmodelIPAddress(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Vlan_ipAddresses(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Vlan",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_IpAddress_id(ctx, field)
			case "address":
				return ec.fieldContext_IpAddress_address(ctx, field)
			case "network":
				return ec.fieldContext_IpAddress_network(ctx, field)
			case "broadcast":
				return ec.fieldContext_IpAddress_broadcast(ctx, field)
			case "interface":
				return ec.fieldContext_IpAddress_interface(ctx, field)
			case "disabled":
				return ec.fieldContext_IpAddress_disabled(ctx, field)
			case "dynamic":
				return ec.fieldContext_IpAddress_dynamic(ctx, field)
			case "invalid":
				return ec.fieldContext_IpAddress_invalid(ctx, field)
			case "comment":
				return ec.fieldContext_IpAddress_comment(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type IpAddress", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Vlan_statistics(ctx context.Context, field graphql.CollectedField, obj *model.Vlan) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Vlan_statistics(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Statistics, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.InterfaceStats)
	fc.Result = res
	return ec.marshalOInterfaceStats2backendgraphmodelInterfaceStats(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Vlan_statistics(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Vlan",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "txBytes":
				return ec.fieldContext_InterfaceStats_txBytes(ctx, field)
			case "rxBytes":
				return ec.fieldContext_InterfaceStats_rxBytes(ctx, field)
			case "txPackets":
				return ec.fieldContext_InterfaceStats_txPackets(ctx, field)
			case "rxPackets":
				return ec.fieldContext_InterfaceStats_rxPackets(ctx, field)
			case "txErrors":
				return ec.fieldContext_InterfaceStats_txErrors(ctx, field)
			case "rxErrors":
				return ec.fieldContext_InterfaceStats_rxErrors(ctx, field)
			case "txDrops":
				return ec.fieldContext_InterfaceStats_txDrops(ctx, field)
			case "rxDrops":
				return ec.fieldContext_InterfaceStats_rxDrops(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type InterfaceStats", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _VlanDependencies_vlanId(ctx context.Context, field graphql.CollectedField, obj *model.VlanDependencies) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_VlanDependencies_vlanId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.VlanID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_VlanDependencies_vlanId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "VlanDependencies",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _VlanDependencies_ipAddresses(ctx context.Context, field graphql.CollectedField, obj *model.VlanDependencies) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_VlanDependencies_ipAddresses(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IPAddresses, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.IPAddress)
	fc.Result = res
	return ec.marshalNIpAddress2backendgraphmodelIPAddress(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_VlanDependencies_ipAddresses(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "VlanDependencies",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_IpAddress_id(ctx, field)
			case "address":
				return ec.fieldContext_IpAddress_address(ctx, field)
			case "network":
				return ec.fieldContext_IpAddress_network(ctx, field)
			case "broadcast":
				return ec.fieldContext_IpAddress_broadcast(ctx, field)
			case "interface":
				return ec.fieldContext_IpAddress_interface(ctx, field)
			case "disabled":
				return ec.fieldContext_IpAddress_disabled(ctx, field)
			case "dynamic":
				return ec.fieldContext_IpAddress_dynamic(ctx, field)
			case "invalid":
				return ec.fieldContext_IpAddress_invalid(ctx, field)
			case "comment":
				return ec.fieldContext_IpAddress_comment(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type IpAddress", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _VlanDependencies_dhcpServers(ctx context.Context, field graphql.CollectedField, obj *model.VlanDependencies) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_VlanDependencies_dhcpServers(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DhcpServers, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.DhcpServer)
	fc.Result = res
	return ec.marshalNDhcpServer2backendgraphmodelDhcpServer(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_VlanDependencies_dhcpServers(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "VlanDependencies",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_DhcpServer_id(ctx, field)
			case "name":
				return ec.fieldContext_DhcpServer_name(ctx, field)
			case "interface":
				return ec.fieldContext_DhcpServer_interface(ctx, field)
			case "disabled":
				return ec.fieldContext_DhcpServer_disabled(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DhcpServer", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _VlanDependencies_firewallRules(ctx context.Context, field graphql.CollectedField, obj *model.VlanDependencies) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_VlanDependencies_firewallRules(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FirewallRules, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.FirewallRule)
	fc.Result = res
	return ec.marshalNFirewallRule2backendgraphmodelFirewallRule(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_VlanDependencies_firewallRules(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "VlanDependencies",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_FirewallRule_id(ctx, field)
			case "chain":
				return ec.fieldContext_FirewallRule_chain(ctx, field)
			case "action":
				return ec.fieldContext_FirewallRule_action(ctx, field)
			case "inInterface":
				return ec.fieldContext_FirewallRule_inInterface(ctx, field)
			case "outInterface":
				return ec.fieldContext_FirewallRule_outInterface(ctx, field)
			case "disabled":
				return ec.fieldContext_FirewallRule_disabled(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FirewallRule", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _VlanDependencies_routes(ctx context.Context, field graphql.CollectedField, obj *model.VlanDependencies) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_VlanDependencies_routes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Routes, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.Route)
	fc.Result = res
	return ec.marshalNRoute2backendgraphmodelRoute(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_VlanDependencies_routes(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "VlanDependencies",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Route_id(ctx, field)
			case "destination":
				return ec.fieldContext_Route_destination(ctx, field)
			case "gateway":
				return ec.fieldContext_Route_gateway(ctx, field)
			case "interface":
				return ec.fieldContext_Route_interface(ctx, field)
			case "distance":
				return ec.fieldContext_Route_distance(ctx, field)
			case "routingMark":
				return ec.fieldContext_Route_routingMark(ctx, field)
			case "routingTable":
				return ec.fieldContext_Route_routingTable(ctx, field)
			case "type":
				return ec.fieldContext_Route_type(ctx, field)
			case "scope":
				return ec.fieldContext_Route_scope(ctx, field)
			case "comment":
				return ec.fieldContext_Route_comment(ctx, field)
			case "active":
				return ec.fieldContext_Route_active(ctx, field)
			case "disabled":
				return ec.fieldContext_Route_disabled(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Route", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _VlanDependencies_activeConnections(ctx context.Context, field graphql.CollectedField, obj *model.VlanDependencies) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_VlanDependencies_activeConnections(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ActiveConnections, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_VlanDependencies_activeConnections(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "VlanDependencies",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _VlanDependencies_hasDependencies(ctx context.Context, field graphql.CollectedField, obj *model.VlanDependencies) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_VlanDependencies_hasDependencies(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HasDependencies, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_VlanDependencies_hasDependencies(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "VlanDependencies",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _VlanMutationResult_success(ctx context.Context, field graphql.CollectedField, obj *model.VlanMutationResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_VlanMutationResult_success(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Success, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_VlanMutationResult_success(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "VlanMutationResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _VlanMutationResult_vlan(ctx context.Context, field graphql.CollectedField, obj *model.VlanMutationResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_VlanMutationResult_vlan(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Vlan, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Vlan)
	fc.Result = res
	return ec.marshalOVlan2backendgraphmodelVlan(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_VlanMutationResult_vlan(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "VlanMutationResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Vlan_id(ctx, field)
			case "name":
				return ec.fieldContext_Vlan_name(ctx, field)
			case "vlanId":
				return ec.fieldContext_Vlan_vlanId(ctx, field)
			case "interface":
				return ec.fieldContext_Vlan_interface(ctx, field)
			case "mtu":
				return ec.fieldContext_Vlan_mtu(ctx, field)
			case "macAddress":
				return ec.fieldContext_Vlan_macAddress(ctx, field)
			case "disabled":
				return ec.fieldContext_Vlan_disabled(ctx, field)
			case "running":
				return ec.fieldContext_Vlan_running(ctx, field)
			case "comment":
				return ec.fieldContext_Vlan_comment(ctx, field)
			case "ipAddresses":
				return ec.fieldContext_Vlan_ipAddresses(ctx, field)
			case "statistics":
				return ec.fieldContext_Vlan_statistics(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Vlan", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _VlanMutationResult_preview(ctx context.Context, field graphql.CollectedField, obj *model.VlanMutationResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_VlanMutationResult_preview(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Preview, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.ConfigPreview)
	fc.Result = res
	return ec.marshalOConfigPreview2backendgraphmodelConfigPreview(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_VlanMutationResult_preview(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "VlanMutationResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "commands":
				return ec.fieldContext_ConfigPreview_commands(ctx, field)
			case "warnings":
				return ec.fieldContext_ConfigPreview_warnings(ctx, field)
			case "affectedResources":
				return ec.fieldContext_ConfigPreview_affectedResources(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ConfigPreview", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _VlanMutationResult_errors(ctx context.Context, field graphql.CollectedField, obj *model.VlanMutationResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_VlanMutationResult_errors(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Errors, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.MutationError)
	fc.Result = res
	return ec.marshalOMutationError2backendgraphmodelMutationError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_VlanMutationResult_errors(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "VlanMutationResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "code":
				return ec.fieldContext_MutationError_code(ctx, field)
			case "message":
				return ec.fieldContext_MutationError_message(ctx, field)
			case "field":
				return ec.fieldContext_MutationError_field(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MutationError", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _VlanTopology_nodes(ctx context.Context, field graphql.CollectedField, obj *model.VlanTopology) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_VlanTopology_nodes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Nodes, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.TopologyNode)
	fc.Result = res
	return ec.marshalNTopologyNode2backendgraphmodelTopologyNode(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_VlanTopology_nodes(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "VlanTopology",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_TopologyNode_id(ctx, field)
			case "type":
				return ec.fieldContext_TopologyNode_type(ctx, field)
			case "label":
				return ec.fieldContext_TopologyNode_label(ctx, field)
			case "sublabel":
				return ec.fieldContext_TopologyNode_sublabel(ctx, field)
			case "position":
				return ec.fieldContext_TopologyNode_position(ctx, field)
			case "data":
				return ec.fieldContext_TopologyNode_data(ctx, field)
			case "style":
				return ec.fieldContext_TopologyNode_style(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TopologyNode", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _VlanTopology_edges(ctx context.Context, field graphql.CollectedField, obj *model.VlanTopology) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_VlanTopology_edges(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Edges, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.TopologyEdge)
	fc.Result = res
	return ec.marshalNTopologyEdge2backendgraphmodelTopologyEdge(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_VlanTopology_edges(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "VlanTopology",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_TopologyEdge_id(ctx, field)
			case "source":
				return ec.fieldContext_TopologyEdge_source(ctx, field)
			case "target":
				return ec.fieldContext_TopologyEdge_target(ctx, field)
			case "label":
				return ec.fieldContext_TopologyEdge_label(ctx, field)
			case "data":
				return ec.fieldContext_TopologyEdge_data(ctx, field)
			case "style":
				return ec.fieldContext_TopologyEdge_style(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TopologyEdge", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _WANConnectionEvent_id(ctx context.Context, field graphql.CollectedField, obj *model.WANConnectionEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WANConnectionEvent_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WANConnectionEvent_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WANConnectionEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WANConnectionEvent_wanInterfaceId(ctx context.Context, field graphql.CollectedField, obj *model.WANConnectionEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WANConnectionEvent_wanInterfaceId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.WanInterfaceID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WANConnectionEvent_wanInterfaceId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WANConnectionEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WANConnectionEvent_eventType(ctx context.Context, field graphql.CollectedField, obj *model.WANConnectionEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WANConnectionEvent_eventType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EventType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.WANEventType)
	fc.Result = res
	return ec.marshalNWANEventType2backendgraphmodelWANEventType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WANConnectionEvent_eventType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WANConnectionEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type WANEventType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WANConnectionEvent_timestamp(ctx context.Context, field graphql.CollectedField, obj *model.WANConnectionEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WANConnectionEvent_timestamp(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Timestamp, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNDateTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WANConnectionEvent_timestamp(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WANConnectionEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DateTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WANConnectionEvent_publicIP(ctx context.Context, field graphql.CollectedField, obj *model.WANConnectionEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WANConnectionEvent_publicIP(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PublicIP, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.IPv4)
	fc.Result = res
	return ec.marshalOIPv42backendgraphmodelIPv4(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WANConnectionEvent_publicIP(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WANConnectionEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type IPv4 does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WANConnectionEvent_gateway(ctx context.Context, field graphql.CollectedField, obj *model.WANConnectionEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WANConnectionEvent_gateway(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Gateway, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.IPv4)
	fc.Result = res
	return ec.marshalOIPv42backendgraphmodelIPv4(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WANConnectionEvent_gateway(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WANConnectionEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type IPv4 does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WANConnectionEvent_reason(ctx context.Context, field graphql.CollectedField, obj *model.WANConnectionEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WANConnectionEvent_reason(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Reason, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WANConnectionEvent_reason(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WANConnectionEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WANConnectionEvent_duration(ctx context.Context, field graphql.CollectedField, obj *model.WANConnectionEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WANConnectionEvent_duration(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Duration, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Duration)
	fc.Result = res
	return ec.marshalODuration2backendgraphmodelDuration(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WANConnectionEvent_duration(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WANConnectionEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Duration does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WANConnectionEventConnection_edges(ctx context.Context, field graphql.CollectedField, obj *model.WANConnectionEventConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WANConnectionEventConnection_edges(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Edges, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.WANConnectionEventEdge)
	fc.Result = res
	return ec.marshalNWANConnectionEventEdge2backendgraphmodelWANConnectionEventEdge(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WANConnectionEventConnection_edges(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WANConnectionEventConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "node":
				return ec.fieldContext_WANConnectionEventEdge_node(ctx, field)
			case "cursor":
				return ec.fieldContext_WANConnectionEventEdge_cursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type WANConnectionEventEdge", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _WANConnectionEventConnection_pageInfo(ctx context.Context, field graphql.CollectedField, obj *model.WANConnectionEventConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WANConnectionEventConnection_pageInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.PageInfo)
	fc.Result = res
	return ec.marshalNPageInfo2backendgraphmodelPageInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WANConnectionEventConnection_pageInfo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WANConnectionEventConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			case "hasPreviousPage":
				return ec.fieldContext_PageInfo_hasPreviousPage(ctx, field)
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _WANConnectionEventConnection_totalCount(ctx context.Context, field graphql.CollectedField, obj *model.WANConnectionEventConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WANConnectionEventConnection_totalCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WANConnectionEventConnection_totalCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WANConnectionEventConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WANConnectionEventEdge_node(ctx context.Context, field graphql.CollectedField, obj *model.WANConnectionEventEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WANConnectionEventEdge_node(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Node, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.WANConnectionEvent)
	fc.Result = res
	return ec.marshalNWANConnectionEvent2backendgraphmodelWANConnectionEvent(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WANConnectionEventEdge_node(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WANConnectionEventEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_WANConnectionEvent_id(ctx, field)
			case "wanInterfaceId":
				return ec.fieldContext_WANConnectionEvent_wanInterfaceId(ctx, field)
			case "eventType":
				return ec.fieldContext_WANConnectionEvent_eventType(ctx, field)
			case "timestamp":
				return ec.fieldContext_WANConnectionEvent_timestamp(ctx, field)
			case "publicIP":
				return ec.fieldContext_WANConnectionEvent_publicIP(ctx, field)
			case "gateway":
				return ec.fieldContext_WANConnectionEvent_gateway(ctx, field)
			case "reason":
				return ec.fieldContext_WANConnectionEvent_reason(ctx, field)
			case "duration":
				return ec.fieldContext_WANConnectionEvent_duration(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type WANConnectionEvent", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _WANConnectionEventEdge_cursor(ctx context.Context, field graphql.CollectedField, obj *model.WANConnectionEventEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WANConnectionEventEdge_cursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WANConnectionEventEdge_cursor(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WANConnectionEventEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WANHealthStatus_status(ctx context.Context, field graphql.CollectedField, obj *model.WANHealthStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WANHealthStatus_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.HealthCheckStatus)
	fc.Result = res
	return ec.marshalNHealthCheckStatus2backendgraphmodelHealthCheckStatus(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WANHealthStatus_status(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WANHealthStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type HealthCheckStatus does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WANHealthStatus_target(ctx context.Context, field graphql.CollectedField, obj *model.WANHealthStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WANHealthStatus_target(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Target, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WANHealthStatus_target(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WANHealthStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WANHealthStatus_interval(ctx context.Context, field graphql.CollectedField, obj *model.WANHealthStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WANHealthStatus_interval(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Interval, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.Duration)
	fc.Result = res
	return ec.marshalNDuration2backendgraphmodelDuration(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WANHealthStatus_interval(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WANHealthStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Duration does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WANHealthStatus_latency(ctx context.Context, field graphql.CollectedField, obj *model.WANHealthStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WANHealthStatus_latency(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Latency, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WANHealthStatus_latency(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WANHealthStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WANHealthStatus_packetLoss(ctx context.Context, field graphql.CollectedField, obj *model.WANHealthStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WANHealthStatus_packetLoss(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PacketLoss, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WANHealthStatus_packetLoss(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WANHealthStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WANHealthStatus_successCount(ctx context.Context, field graphql.CollectedField, obj *model.WANHealthStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WANHealthStatus_successCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SuccessCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WANHealthStatus_successCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WANHealthStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WANHealthStatus_failureCount(ctx context.Context, field graphql.CollectedField, obj *model.WANHealthStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WANHealthStatus_failureCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FailureCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WANHealthStatus_failureCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WANHealthStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WANHealthStatus_lastCheck(ctx context.Context, field graphql.CollectedField, obj *model.WANHealthStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WANHealthStatus_lastCheck(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LastCheck, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNDateTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WANHealthStatus_lastCheck(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WANHealthStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DateTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WANHealthStatus_enabled(ctx context.Context, field graphql.CollectedField, obj *model.WANHealthStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WANHealthStatus_enabled(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Enabled, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WANHealthStatus_enabled(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WANHealthStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WANInterface_id(ctx context.Context, field graphql.CollectedField, obj *model.WANInterface) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WANInterface_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WANInterface_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WANInterface",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WANInterface_interface(ctx context.Context, field graphql.CollectedField, obj *model.WANInterface) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WANInterface_interface(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Interface, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Interface)
	fc.Result = res
	return ec.marshalNInterface2backendgraphmodelInterface(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WANInterface_interface(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WANInterface",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Interface_id(ctx, field)
			case "name":
				return ec.fieldContext_Interface_name(ctx, field)
			case "type":
				return ec.fieldContext_Interface_type(ctx, field)
			case "enabled":
				return ec.fieldContext_Interface_enabled(ctx, field)
			case "running":
				return ec.fieldContext_Interface_running(ctx, field)
			case "macAddress":
				return ec.fieldContext_Interface_macAddress(ctx, field)
			case "mtu":
				return ec.fieldContext_Interface_mtu(ctx, field)
			case "comment":
				return ec.fieldContext_Interface_comment(ctx, field)
			case "txBytes":
				return ec.fieldContext_Interface_txBytes(ctx, field)
			case "rxBytes":
				return ec.fieldContext_Interface_rxBytes(ctx, field)
			case "ip":
				return ec.fieldContext_Interface_ip(ctx, field)
			case "status":
				return ec.fieldContext_Interface_status(ctx, field)
			case "txRate":
				return ec.fieldContext_Interface_txRate(ctx, field)
			case "rxRate":
				return ec.fieldContext_Interface_rxRate(ctx, field)
			case "linkSpeed":
				return ec.fieldContext_Interface_linkSpeed(ctx, field)
			case "lastSeen":
				return ec.fieldContext_Interface_lastSeen(ctx, field)
			case "linkPartner":
				return ec.fieldContext_Interface_linkPartner(ctx, field)
			case "usedBy":
				return ec.fieldContext_Interface_usedBy(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Interface", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _WANInterface_type(ctx context.Context, field graphql.CollectedField, obj *model.WANInterface) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WANInterface_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.WANConnectionType)
	fc.Result = res
	return ec.marshalNWANConnectionType2backendgraphmodelWANConnectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WANInterface_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WANInterface",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type WANConnectionType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WANInterface_status(ctx context.Context, field graphql.CollectedField, obj *model.WANInterface) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WANInterface_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.WANStatus)
	fc.Result = res
	return ec.marshalNWANStatus2backendgraphmodelWANStatus(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WANInterface_status(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WANInterface",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type WANStatus does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WANInterface_publicIP(ctx context.Context, field graphql.CollectedField, obj *model.WANInterface) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WANInterface_publicIP(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PublicIP, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.IPv4)
	fc.Result = res
	return ec.marshalOIPv42backendgraphmodelIPv4(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WANInterface_publicIP(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WANInterface",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type IPv4 does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WANInterface_gateway(ctx context.Context, field graphql.CollectedField, obj *model.WANInterface) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WANInterface_gateway(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Gateway, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.IPv4)
	fc.Result = res
	return ec.marshalOIPv42backendgraphmodelIPv4(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WANInterface_gateway(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WANInterface",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type IPv4 does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WANInterface_primaryDNS(ctx context.Context, field graphql.CollectedField, obj *model.WANInterface) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WANInterface_primaryDNS(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PrimaryDNS, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.IPv4)
	fc.Result = res
	return ec.marshalOIPv42backendgraphmodelIPv4(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WANInterface_primaryDNS(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WANInterface",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type IPv4 does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WANInterface_secondaryDNS(ctx context.Context, field graphql.CollectedField, obj *model.WANInterface) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WANInterface_secondaryDNS(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SecondaryDNS, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.IPv4)
	fc.Result = res
	return ec.marshalOIPv42backendgraphmodelIPv4(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WANInterface_secondaryDNS(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WANInterface",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type IPv4 does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WANInterface_uptime(ctx context.Context, field graphql.CollectedField, obj *model.WANInterface) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WANInterface_uptime(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Uptime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Duration)
	fc.Result = res
	return ec.marshalODuration2backendgraphmodelDuration(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WANInterface_uptime(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WANInterface",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Duration does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WANInterface_lastConnected(ctx context.Context, field graphql.CollectedField, obj *model.WANInterface) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WANInterface_lastConnected(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LastConnected, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalODateTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WANInterface_lastConnected(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WANInterface",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DateTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WANInterface_health(ctx context.Context, field graphql.CollectedField, obj *model.WANInterface) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WANInterface_health(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Health, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.WANHealthStatus)
	fc.Result = res
	return ec.marshalOWANHealthStatus2backendgraphmodelWANHealthStatus(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WANInterface_health(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WANInterface",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "status":
				return ec.fieldContext_WANHealthStatus_status(ctx, field)
			case "target":
				return ec.fieldContext_WANHealthStatus_target(ctx, field)
			case "interval":
				return ec.fieldContext_WANHealthStatus_interval(ctx, field)
			case "latency":
				return ec.fieldContext_WANHealthStatus_latency(ctx, field)
			case "packetLoss":
				return ec.fieldContext_WANHealthStatus_packetLoss(ctx, field)
			case "successCount":
				return ec.fieldContext_WANHealthStatus_successCount(ctx, field)
			case "failureCount":
				return ec.fieldContext_WANHealthStatus_failureCount(ctx, field)
			case "lastCheck":
				return ec.fieldContext_WANHealthStatus_lastCheck(ctx, field)
			case "enabled":
				return ec.fieldContext_WANHealthStatus_enabled(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type WANHealthStatus", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _WANInterface_dhcpClient(ctx context.Context, field graphql.CollectedField, obj *model.WANInterface) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WANInterface_dhcpClient(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DhcpClient, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.DhcpClient)
	fc.Result = res
	return ec.marshalODhcpClient2backendgraphmodelDhcpClient(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WANInterface_dhcpClient(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WANInterface",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_DhcpClient_id(ctx, field)
			case "interface":
				return ec.fieldContext_DhcpClient_interface(ctx, field)
			case "disabled":
				return ec.fieldContext_DhcpClient_disabled(ctx, field)
			case "addDefaultRoute":
				return ec.fieldContext_DhcpClient_addDefaultRoute(ctx, field)
			case "usePeerDNS":
				return ec.fieldContext_DhcpClient_usePeerDNS(ctx, field)
			case "usePeerNTP":
				return ec.fieldContext_DhcpClient_usePeerNTP(ctx, field)
			case "status":
				return ec.fieldContext_DhcpClient_status(ctx, field)
			case "address":
				return ec.fieldContext_DhcpClient_address(ctx, field)
			case "dhcpServer":
				return ec.fieldContext_DhcpClient_dhcpServer(ctx, field)
			case "gateway":
				return ec.fieldContext_DhcpClient_gateway(ctx, field)
			case "expiresAfter":
				return ec.fieldContext_DhcpClient_expiresAfter(ctx, field)
			case "comment":
				return ec.fieldContext_DhcpClient_comment(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DhcpClient", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _WANInterface_pppoeClient(ctx context.Context, field graphql.CollectedField, obj *model.WANInterface) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WANInterface_pppoeClient(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PppoeClient, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.PppoeClient)
	fc.Result = res
	return ec.marshalOPppoeClient2backendgraphmodelPppoeClient(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WANInterface_pppoeClient(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WANInterface",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_PppoeClient_id(ctx, field)
			case "name":
				return ec.fieldContext_PppoeClient_name(ctx, field)
			case "interface":
				return ec.fieldContext_PppoeClient_interface(ctx, field)
			case "disabled":
				return ec.fieldContext_PppoeClient_disabled(ctx, field)
			case "username":
				return ec.fieldContext_PppoeClient_username(ctx, field)
			case "serviceName":
				return ec.fieldContext_PppoeClient_serviceName(ctx, field)
			case "addDefaultRoute":
				return ec.fieldContext_PppoeClient_addDefaultRoute(ctx, field)
			case "usePeerDNS":
				return ec.fieldContext_PppoeClient_usePeerDNS(ctx, field)
			case "running":
				return ec.fieldContext_PppoeClient_running(ctx, field)
			case "mtu":
				return ec.fieldContext_PppoeClient_mtu(ctx, field)
			case "mru":
				return ec.fieldContext_PppoeClient_mru(ctx, field)
			case "comment":
				return ec.fieldContext_PppoeClient_comment(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PppoeClient", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _WANInterface_staticConfig(ctx context.Context, field graphql.CollectedField, obj *model.WANInterface) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WANInterface_staticConfig(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StaticConfig, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.StaticIPConfig)
	fc.Result = res
	return ec.marshalOStaticIPConfig2backendgraphmodelStaticIPConfig(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WANInterface_staticConfig(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WANInterface",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_StaticIPConfig_id(ctx, field)
			case "interface":
				return ec.fieldContext_StaticIPConfig_interface(ctx, field)
			case "address":
				return ec.fieldContext_StaticIPConfig_address(ctx, field)
			case "gateway":
				return ec.fieldContext_StaticIPConfig_gateway(ctx, field)
			case "primaryDNS":
				return ec.fieldContext_StaticIPConfig_primaryDNS(ctx, field)
			case "secondaryDNS":
				return ec.fieldContext_StaticIPConfig_secondaryDNS(ctx, field)
			case "comment":
				return ec.fieldContext_StaticIPConfig_comment(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type StaticIPConfig", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _WANInterface_lteModem(ctx context.Context, field graphql.CollectedField, obj *model.WANInterface) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WANInterface_lteModem(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LteModem, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.LteModem)
	fc.Result = res
	return ec.marshalOLteModem2backendgraphmodelLteModem(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WANInterface_lteModem(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WANInterface",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_LteModem_id(ctx, field)
			case "name":
				return ec.fieldContext_LteModem_name(ctx, field)
			case "apn":
				return ec.fieldContext_LteModem_apn(ctx, field)
			case "signalStrength":
				return ec.fieldContext_LteModem_signalStrength(ctx, field)
			case "running":
				return ec.fieldContext_LteModem_running(ctx, field)
			case "operator":
				return ec.fieldContext_LteModem_operator(ctx, field)
			case "networkType":
				return ec.fieldContext_LteModem_networkType(ctx, field)
			case "pinConfigured":
				return ec.fieldContext_LteModem_pinConfigured(ctx, field)
			case "comment":
				return ec.fieldContext_LteModem_comment(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type LteModem", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _WANInterface_isDefaultRoute(ctx context.Context, field graphql.CollectedField, obj *model.WANInterface) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WANInterface_isDefaultRoute(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDefaultRoute, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WANInterface_isDefaultRoute(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WANInterface",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WANInterface_statistics(ctx context.Context, field graphql.CollectedField, obj *model.WANInterface) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WANInterface_statistics(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Statistics, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.InterfaceStats)
	fc.Result = res
	return ec.marshalOInterfaceStats2backendgraphmodelInterfaceStats(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WANInterface_statistics(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WANInterface",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "txBytes":
				return ec.fieldContext_InterfaceStats_txBytes(ctx, field)
			case "rxBytes":
				return ec.fieldContext_InterfaceStats_rxBytes(ctx, field)
			case "txPackets":
				return ec.fieldContext_InterfaceStats_txPackets(ctx, field)
			case "rxPackets":
				return ec.fieldContext_InterfaceStats_rxPackets(ctx, field)
			case "txErrors":
				return ec.fieldContext_InterfaceStats_txErrors(ctx, field)
			case "rxErrors":
				return ec.fieldContext_InterfaceStats_rxErrors(ctx, field)
			case "txDrops":
				return ec.fieldContext_InterfaceStats_txDrops(ctx, field)
			case "rxDrops":
				return ec.fieldContext_InterfaceStats_rxDrops(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type InterfaceStats", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _WANLink_id(ctx context.Context, field graphql.CollectedField, obj *model.WANLink) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WANLink_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WANLink_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WANLink",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WANLink_scopedId(ctx context.Context, field graphql.CollectedField, obj *model.WANLink) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WANLink_scopedId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ScopedID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WANLink_scopedId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WANLink",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WANLink_type(ctx context.Context, field graphql.CollectedField, obj *model.WANLink) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WANLink_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WANLink_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WANLink",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WANLink_category(ctx context.Context, field graphql.CollectedField, obj *model.WANLink) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WANLink_category(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Category, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.ResourceCategory)
	fc.Result = res
	return ec.marshalNResourceCategory2backendgraphmodelResourceCategory(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WANLink_category(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WANLink",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ResourceCategory does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WANLink_configuration(ctx context.Context, field graphql.CollectedField, obj *model.WANLink) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WANLink_configuration(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Configuration, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOJSON2map(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WANLink_configuration(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WANLink",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type JSON does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WANLink_validation(ctx context.Context, field graphql.CollectedField, obj *model.WANLink) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WANLink_validation(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Validation, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.ValidationResult)
	fc.Result = res
	return ec.marshalOValidationResult2backendgraphmodelValidationResult(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WANLink_validation(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WANLink",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "canApply":
				return ec.fieldContext_ValidationResult_canApply(ctx, field)
			case "stage":
				return ec.fieldContext_ValidationResult_stage(ctx, field)
			case "errors":
				return ec.fieldContext_ValidationResult_errors(ctx, field)
			case "warnings":
				return ec.fieldContext_ValidationResult_warnings(ctx, field)
			case "conflicts":
				return ec.fieldContext_ValidationResult_conflicts(ctx, field)
			case "requiredDependencies":
				return ec.fieldContext_ValidationResult_requiredDependencies(ctx, field)
			case "validatedAt":
				return ec.fieldContext_ValidationResult_validatedAt(ctx, field)
			case "validationDurationMs":
				return ec.fieldContext_ValidationResult_validationDurationMs(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ValidationResult", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _WANLink_deployment(ctx context.Context, field graphql.CollectedField, obj *model.WANLink) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WANLink_deployment(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Deployment, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.DeploymentState)
	fc.Result = res
	return ec.marshalODeploymentState2backendgraphmodelDeploymentState(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WANLink_deployment(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WANLink",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "routerResourceId":
				return ec.fieldContext_DeploymentState_routerResourceId(ctx, field)
			case "appliedAt":
				return ec.fieldContext_DeploymentState_appliedAt(ctx, field)
			case "appliedBy":
				return ec.fieldContext_DeploymentState_appliedBy(ctx, field)
			case "routerVersion":
				return ec.fieldContext_DeploymentState_routerVersion(ctx, field)
			case "generatedFields":
				return ec.fieldContext_DeploymentState_generatedFields(ctx, field)
			case "isInSync":
				return ec.fieldContext_DeploymentState_isInSync(ctx, field)
			case "drift":
				return ec.fieldContext_DeploymentState_drift(ctx, field)
			case "applyOperationId":
				return ec.fieldContext_DeploymentState_applyOperationId(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DeploymentState", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _WANLink_runtime(ctx context.Context, field graphql.CollectedField, obj *model.WANLink) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WANLink_runtime(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Runtime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.RuntimeState)
	fc.Result = res
	return ec.marshalORuntimeState2backendgraphmodelRuntimeState(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WANLink_runtime(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WANLink",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "isRunning":
				return ec.fieldContext_RuntimeState_isRunning(ctx, field)
			case "health":
				return ec.fieldContext_RuntimeState_health(ctx, field)
			case "errorMessage":
				return ec.fieldContext_RuntimeState_errorMessage(ctx, field)
			case "metrics":
				return ec.fieldContext_RuntimeState_metrics(ctx, field)
			case "lastUpdated":
				return ec.fieldContext_RuntimeState_lastUpdated(ctx, field)
			case "lastSuccessfulOperation":
				return ec.fieldContext_RuntimeState_lastSuccessfulOperation(ctx, field)
			case "activeConnections":
				return ec.fieldContext_RuntimeState_activeConnections(ctx, field)
			case "uptime":
				return ec.fieldContext_RuntimeState_uptime(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RuntimeState", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _WANLink_telemetry(ctx context.Context, field graphql.CollectedField, obj *model.WANLink) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WANLink_telemetry(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Telemetry, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.TelemetryData)
	fc.Result = res
	return ec.marshalOTelemetryData2backendgraphmodelTelemetryData(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WANLink_telemetry(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WANLink",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "bandwidthHistory":
				return ec.fieldContext_TelemetryData_bandwidthHistory(ctx, field)
			case "uptimeHistory":
				return ec.fieldContext_TelemetryData_uptimeHistory(ctx, field)
			case "hourlyStats":
				return ec.fieldContext_TelemetryData_hourlyStats(ctx, field)
			case "dailyStats":
				return ec.fieldContext_TelemetryData_dailyStats(ctx, field)
			case "dataStartedAt":
				return ec.fieldContext_TelemetryData_dataStartedAt(ctx, field)
			case "lastUpdatedAt":
				return ec.fieldContext_TelemetryData_lastUpdatedAt(ctx, field)
			case "retentionDays":
				return ec.fieldContext_TelemetryData_retentionDays(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TelemetryData", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _WANLink_metadata(ctx context.Context, field graphql.CollectedField, obj *model.WANLink) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WANLink_metadata(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Metadata, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.ResourceMetadata)
	fc.Result = res
	return ec.marshalNResourceMetadata2backendgraphmodelResourceMetadata(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WANLink_metadata(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WANLink",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "createdAt":
				return ec.fieldContext_ResourceMetadata_createdAt(ctx, field)
			case "createdBy":
				return ec.fieldContext_ResourceMetadata_createdBy(ctx, field)
			case "updatedAt":
				return ec.fieldContext_ResourceMetadata_updatedAt(ctx, field)
			case "updatedBy":
				return ec.fieldContext_ResourceMetadata_updatedBy(ctx, field)
			case "state":
				return ec.fieldContext_ResourceMetadata_state(ctx, field)
			case "version":
				return ec.fieldContext_ResourceMetadata_version(ctx, field)
			case "tags":
				return ec.fieldContext_ResourceMetadata_tags(ctx, field)
			case "description":
				return ec.fieldContext_ResourceMetadata_description(ctx, field)
			case "isFavorite":
				return ec.fieldContext_ResourceMetadata_isFavorite(ctx, field)
			case "isPinned":
				return ec.fieldContext_ResourceMetadata_isPinned(ctx, field)
			case "notes":
				return ec.fieldContext_ResourceMetadata_notes(ctx, field)
			case "recentChanges":
				return ec.fieldContext_ResourceMetadata_recentChanges(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ResourceMetadata", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _WANLink_relationships(ctx context.Context, field graphql.CollectedField, obj *model.WANLink) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WANLink_relationships(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Relationships, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.ResourceRelationships)
	fc.Result = res
	return ec.marshalOResourceRelationships2backendgraphmodelResourceRelationships(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WANLink_relationships(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WANLink",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "dependsOn":
				return ec.fieldContext_ResourceRelationships_dependsOn(ctx, field)
			case "dependents":
				return ec.fieldContext_ResourceRelationships_dependents(ctx, field)
			case "routesVia":
				return ec.fieldContext_ResourceRelationships_routesVia(ctx, field)
			case "routedBy":
				return ec.fieldContext_ResourceRelationships_routedBy(ctx, field)
			case "parent":
				return ec.fieldContext_ResourceRelationships_parent(ctx, field)
			case "children":
				return ec.fieldContext_ResourceRelationships_children(ctx, field)
			case "custom":
				return ec.fieldContext_ResourceRelationships_custom(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ResourceRelationships", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _WANLink_platform(ctx context.Context, field graphql.CollectedField, obj *model.WANLink) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WANLink_platform(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Platform, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.PlatformInfo)
	fc.Result = res
	return ec.marshalOPlatformInfo2backendgraphmodelPlatformInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WANLink_platform(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WANLink",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "current":
				return ec.fieldContext_PlatformInfo_current(ctx, field)
			case "capabilities":
				return ec.fieldContext_PlatformInfo_capabilities(ctx, field)
			case "fieldMappings":
				return ec.fieldContext_PlatformInfo_fieldMappings(ctx, field)
			case "limitations":
				return ec.fieldContext_PlatformInfo_limitations(ctx, field)
			case "features":
				return ec.fieldContext_PlatformInfo_features(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PlatformInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _WANLink_wanRuntime(ctx context.Context, field graphql.CollectedField, obj *model.WANLink) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WANLink_wanRuntime(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.WanRuntime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.WANLinkRuntime)
	fc.Result = res
	return ec.marshalOWANLinkRuntime2backendgraphmodelWANLinkRuntime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WANLink_wanRuntime(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WANLink",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "isRunning":
				return ec.fieldContext_WANLinkRuntime_isRunning(ctx, field)
			case "health":
				return ec.fieldContext_WANLinkRuntime_health(ctx, field)
			case "errorMessage":
				return ec.fieldContext_WANLinkRuntime_errorMessage(ctx, field)
			case "lastUpdated":
				return ec.fieldContext_WANLinkRuntime_lastUpdated(ctx, field)
			case "currentIP":
				return ec.fieldContext_WANLinkRuntime_currentIP(ctx, field)
			case "gateway":
				return ec.fieldContext_WANLinkRuntime_gateway(ctx, field)
			case "publicIP":
				return ec.fieldContext_WANLinkRuntime_publicIP(ctx, field)
			case "dnsServers":
				return ec.fieldContext_WANLinkRuntime_dnsServers(ctx, field)
			case "uplinkSpeed":
				return ec.fieldContext_WANLinkRuntime_uplinkSpeed(ctx, field)
			case "downlinkSpeed":
				return ec.fieldContext_WANLinkRuntime_downlinkSpeed(ctx, field)
			case "uptime":
				return ec.fieldContext_WANLinkRuntime_uptime(ctx, field)
			case "lastStateChange":
				return ec.fieldContext_WANLinkRuntime_lastStateChange(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type WANLinkRuntime", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _WANLink_interface(ctx context.Context, field graphql.CollectedField, obj *model.WANLink) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WANLink_interface(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Interface, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WANLink_interface(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WANLink",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WANLink_connectionType(ctx context.Context, field graphql.CollectedField, obj *model.WANLink) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WANLink_connectionType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ConnectionType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.WANConnectionType)
	fc.Result = res
	return ec.marshalNWANConnectionType2backendgraphmodelWANConnectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WANLink_connectionType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WANLink",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type WANConnectionType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WANLink_isPrimary(ctx context.Context, field graphql.CollectedField, obj *model.WANLink) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WANLink_isPrimary(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsPrimary, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WANLink_isPrimary(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WANLink",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WANLink_failoverPriority(ctx context.Context, field graphql.CollectedField, obj *model.WANLink) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WANLink_failoverPriority(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FailoverPriority, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WANLink_failoverPriority(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WANLink",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WANLinkRuntime_isRunning(ctx context.Context, field graphql.CollectedField, obj *model.WANLinkRuntime) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WANLinkRuntime_isRunning(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsRunning, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WANLinkRuntime_isRunning(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WANLinkRuntime",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WANLinkRuntime_health(ctx context.Context, field graphql.CollectedField, obj *model.WANLinkRuntime) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WANLinkRuntime_health(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Health, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.RuntimeHealth)
	fc.Result = res
	return ec.marshalNRuntimeHealth2backendgraphmodelRuntimeHealth(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WANLinkRuntime_health(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WANLinkRuntime",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type RuntimeHealth does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WANLinkRuntime_errorMessage(ctx context.Context, field graphql.CollectedField, obj *model.WANLinkRuntime) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WANLinkRuntime_errorMessage(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ErrorMessage, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WANLinkRuntime_errorMessage(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WANLinkRuntime",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WANLinkRuntime_lastUpdated(ctx context.Context, field graphql.CollectedField, obj *model.WANLinkRuntime) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WANLinkRuntime_lastUpdated(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LastUpdated, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNDateTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WANLinkRuntime_lastUpdated(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WANLinkRuntime",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DateTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WANLinkRuntime_currentIP(ctx context.Context, field graphql.CollectedField, obj *model.WANLinkRuntime) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WANLinkRuntime_currentIP(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CurrentIP, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.IPv4)
	fc.Result = res
	return ec.marshalOIPv42backendgraphmodelIPv4(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WANLinkRuntime_currentIP(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WANLinkRuntime",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type IPv4 does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WANLinkRuntime_gateway(ctx context.Context, field graphql.CollectedField, obj *model.WANLinkRuntime) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WANLinkRuntime_gateway(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Gateway, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.IPv4)
	fc.Result = res
	return ec.marshalOIPv42backendgraphmodelIPv4(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WANLinkRuntime_gateway(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WANLinkRuntime",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type IPv4 does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WANLinkRuntime_publicIP(ctx context.Context, field graphql.CollectedField, obj *model.WANLinkRuntime) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WANLinkRuntime_publicIP(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PublicIP, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.IPv4)
	fc.Result = res
	return ec.marshalOIPv42backendgraphmodelIPv4(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WANLinkRuntime_publicIP(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WANLinkRuntime",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type IPv4 does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WANLinkRuntime_dnsServers(ctx context.Context, field graphql.CollectedField, obj *model.WANLinkRuntime) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WANLinkRuntime_dnsServers(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DNSServers, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]model.IPv4)
	fc.Result = res
	return ec.marshalOIPv42backendgraphmodelIPv4(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WANLinkRuntime_dnsServers(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WANLinkRuntime",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type IPv4 does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WANLinkRuntime_uplinkSpeed(ctx context.Context, field graphql.CollectedField, obj *model.WANLinkRuntime) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WANLinkRuntime_uplinkSpeed(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UplinkSpeed, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Size)
	fc.Result = res
	return ec.marshalOSize2backendgraphmodelSize(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WANLinkRuntime_uplinkSpeed(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WANLinkRuntime",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Size does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WANLinkRuntime_downlinkSpeed(ctx context.Context, field graphql.CollectedField, obj *model.WANLinkRuntime) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WANLinkRuntime_downlinkSpeed(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DownlinkSpeed, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Size)
	fc.Result = res
	return ec.marshalOSize2backendgraphmodelSize(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WANLinkRuntime_downlinkSpeed(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WANLinkRuntime",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Size does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WANLinkRuntime_uptime(ctx context.Context, field graphql.CollectedField, obj *model.WANLinkRuntime) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WANLinkRuntime_uptime(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Uptime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Duration)
	fc.Result = res
	return ec.marshalODuration2backendgraphmodelDuration(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WANLinkRuntime_uptime(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WANLinkRuntime",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Duration does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WANLinkRuntime_lastStateChange(ctx context.Context, field graphql.CollectedField, obj *model.WANLinkRuntime) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WANLinkRuntime_lastStateChange(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LastStateChange, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalODateTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WANLinkRuntime_lastStateChange(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WANLinkRuntime",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DateTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WANMutationResult_success(ctx context.Context, field graphql.CollectedField, obj *model.WANMutationResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WANMutationResult_success(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Success, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WANMutationResult_success(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WANMutationResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WANMutationResult_wanInterface(ctx context.Context, field graphql.CollectedField, obj *model.WANMutationResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WANMutationResult_wanInterface(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.WanInterface, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.WANInterface)
	fc.Result = res
	return ec.marshalOWANInterface2backendgraphmodelWANInterface(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WANMutationResult_wanInterface(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WANMutationResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_WANInterface_id(ctx, field)
			case "interface":
				return ec.fieldContext_WANInterface_interface(ctx, field)
			case "type":
				return ec.fieldContext_WANInterface_type(ctx, field)
			case "status":
				return ec.fieldContext_WANInterface_status(ctx, field)
			case "publicIP":
				return ec.fieldContext_WANInterface_publicIP(ctx, field)
			case "gateway":
				return ec.fieldContext_WANInterface_gateway(ctx, field)
			case "primaryDNS":
				return ec.fieldContext_WANInterface_primaryDNS(ctx, field)
			case "secondaryDNS":
				return ec.fieldContext_WANInterface_secondaryDNS(ctx, field)
			case "uptime":
				return ec.fieldContext_WANInterface_uptime(ctx, field)
			case "lastConnected":
				return ec.fieldContext_WANInterface_lastConnected(ctx, field)
			case "health":
				return ec.fieldContext_WANInterface_health(ctx, field)
			case "dhcpClient":
				return ec.fieldContext_WANInterface_dhcpClient(ctx, field)
			case "pppoeClient":
				return ec.fieldContext_WANInterface_pppoeClient(ctx, field)
			case "staticConfig":
				return ec.fieldContext_WANInterface_staticConfig(ctx, field)
			case "lteModem":
				return ec.fieldContext_WANInterface_lteModem(ctx, field)
			case "isDefaultRoute":
				return ec.fieldContext_WANInterface_isDefaultRoute(ctx, field)
			case "statistics":
				return ec.fieldContext_WANInterface_statistics(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type WANInterface", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _WANMutationResult_preview(ctx context.Context, field graphql.CollectedField, obj *model.WANMutationResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WANMutationResult_preview(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Preview, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.ConfigPreview)
	fc.Result = res
	return ec.marshalOConfigPreview2backendgraphmodelConfigPreview(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WANMutationResult_preview(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WANMutationResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "commands":
				return ec.fieldContext_ConfigPreview_commands(ctx, field)
			case "warnings":
				return ec.fieldContext_ConfigPreview_warnings(ctx, field)
			case "affectedResources":
				return ec.fieldContext_ConfigPreview_affectedResources(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ConfigPreview", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _WANMutationResult_errors(ctx context.Context, field graphql.CollectedField, obj *model.WANMutationResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WANMutationResult_errors(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Errors, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.MutationError)
	fc.Result = res
	return ec.marshalOMutationError2backendgraphmodelMutationError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WANMutationResult_errors(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WANMutationResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "code":
				return ec.fieldContext_MutationError_code(ctx, field)
			case "message":
				return ec.fieldContext_MutationError_message(ctx, field)
			case "field":
				return ec.fieldContext_MutationError_field(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MutationError", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _WireGuardClient_id(ctx context.Context, field graphql.CollectedField, obj *model.WireGuardClient) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WireGuardClient_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WireGuardClient_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WireGuardClient",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WireGuardClient_scopedId(ctx context.Context, field graphql.CollectedField, obj *model.WireGuardClient) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WireGuardClient_scopedId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ScopedID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WireGuardClient_scopedId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WireGuardClient",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WireGuardClient_type(ctx context.Context, field graphql.CollectedField, obj *model.WireGuardClient) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WireGuardClient_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WireGuardClient_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WireGuardClient",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WireGuardClient_category(ctx context.Context, field graphql.CollectedField, obj *model.WireGuardClient) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WireGuardClient_category(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Category, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.ResourceCategory)
	fc.Result = res
	return ec.marshalNResourceCategory2backendgraphmodelResourceCategory(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WireGuardClient_category(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WireGuardClient",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ResourceCategory does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WireGuardClient_configuration(ctx context.Context, field graphql.CollectedField, obj *model.WireGuardClient) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WireGuardClient_configuration(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Configuration, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOJSON2map(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WireGuardClient_configuration(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WireGuardClient",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type JSON does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WireGuardClient_validation(ctx context.Context, field graphql.CollectedField, obj *model.WireGuardClient) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WireGuardClient_validation(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Validation, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.ValidationResult)
	fc.Result = res
	return ec.marshalOValidationResult2backendgraphmodelValidationResult(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WireGuardClient_validation(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WireGuardClient",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "canApply":
				return ec.fieldContext_ValidationResult_canApply(ctx, field)
			case "stage":
				return ec.fieldContext_ValidationResult_stage(ctx, field)
			case "errors":
				return ec.fieldContext_ValidationResult_errors(ctx, field)
			case "warnings":
				return ec.fieldContext_ValidationResult_warnings(ctx, field)
			case "conflicts":
				return ec.fieldContext_ValidationResult_conflicts(ctx, field)
			case "requiredDependencies":
				return ec.fieldContext_ValidationResult_requiredDependencies(ctx, field)
			case "validatedAt":
				return ec.fieldContext_ValidationResult_validatedAt(ctx, field)
			case "validationDurationMs":
				return ec.fieldContext_ValidationResult_validationDurationMs(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ValidationResult", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _WireGuardClient_deployment(ctx context.Context, field graphql.CollectedField, obj *model.WireGuardClient) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WireGuardClient_deployment(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Deployment, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.DeploymentState)
	fc.Result = res
	return ec.marshalODeploymentState2backendgraphmodelDeploymentState(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WireGuardClient_deployment(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WireGuardClient",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "routerResourceId":
				return ec.fieldContext_DeploymentState_routerResourceId(ctx, field)
			case "appliedAt":
				return ec.fieldContext_DeploymentState_appliedAt(ctx, field)
			case "appliedBy":
				return ec.fieldContext_DeploymentState_appliedBy(ctx, field)
			case "routerVersion":
				return ec.fieldContext_DeploymentState_routerVersion(ctx, field)
			case "generatedFields":
				return ec.fieldContext_DeploymentState_generatedFields(ctx, field)
			case "isInSync":
				return ec.fieldContext_DeploymentState_isInSync(ctx, field)
			case "drift":
				return ec.fieldContext_DeploymentState_drift(ctx, field)
			case "applyOperationId":
				return ec.fieldContext_DeploymentState_applyOperationId(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DeploymentState", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _WireGuardClient_runtime(ctx context.Context, field graphql.CollectedField, obj *model.WireGuardClient) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WireGuardClient_runtime(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Runtime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.RuntimeState)
	fc.Result = res
	return ec.marshalORuntimeState2backendgraphmodelRuntimeState(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WireGuardClient_runtime(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WireGuardClient",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "isRunning":
				return ec.fieldContext_RuntimeState_isRunning(ctx, field)
			case "health":
				return ec.fieldContext_RuntimeState_health(ctx, field)
			case "errorMessage":
				return ec.fieldContext_RuntimeState_errorMessage(ctx, field)
			case "metrics":
				return ec.fieldContext_RuntimeState_metrics(ctx, field)
			case "lastUpdated":
				return ec.fieldContext_RuntimeState_lastUpdated(ctx, field)
			case "lastSuccessfulOperation":
				return ec.fieldContext_RuntimeState_lastSuccessfulOperation(ctx, field)
			case "activeConnections":
				return ec.fieldContext_RuntimeState_activeConnections(ctx, field)
			case "uptime":
				return ec.fieldContext_RuntimeState_uptime(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RuntimeState", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _WireGuardClient_telemetry(ctx context.Context, field graphql.CollectedField, obj *model.WireGuardClient) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WireGuardClient_telemetry(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Telemetry, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.TelemetryData)
	fc.Result = res
	return ec.marshalOTelemetryData2backendgraphmodelTelemetryData(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WireGuardClient_telemetry(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WireGuardClient",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "bandwidthHistory":
				return ec.fieldContext_TelemetryData_bandwidthHistory(ctx, field)
			case "uptimeHistory":
				return ec.fieldContext_TelemetryData_uptimeHistory(ctx, field)
			case "hourlyStats":
				return ec.fieldContext_TelemetryData_hourlyStats(ctx, field)
			case "dailyStats":
				return ec.fieldContext_TelemetryData_dailyStats(ctx, field)
			case "dataStartedAt":
				return ec.fieldContext_TelemetryData_dataStartedAt(ctx, field)
			case "lastUpdatedAt":
				return ec.fieldContext_TelemetryData_lastUpdatedAt(ctx, field)
			case "retentionDays":
				return ec.fieldContext_TelemetryData_retentionDays(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TelemetryData", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _WireGuardClient_metadata(ctx context.Context, field graphql.CollectedField, obj *model.WireGuardClient) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WireGuardClient_metadata(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Metadata, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.ResourceMetadata)
	fc.Result = res
	return ec.marshalNResourceMetadata2backendgraphmodelResourceMetadata(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WireGuardClient_metadata(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WireGuardClient",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "createdAt":
				return ec.fieldContext_ResourceMetadata_createdAt(ctx, field)
			case "createdBy":
				return ec.fieldContext_ResourceMetadata_createdBy(ctx, field)
			case "updatedAt":
				return ec.fieldContext_ResourceMetadata_updatedAt(ctx, field)
			case "updatedBy":
				return ec.fieldContext_ResourceMetadata_updatedBy(ctx, field)
			case "state":
				return ec.fieldContext_ResourceMetadata_state(ctx, field)
			case "version":
				return ec.fieldContext_ResourceMetadata_version(ctx, field)
			case "tags":
				return ec.fieldContext_ResourceMetadata_tags(ctx, field)
			case "description":
				return ec.fieldContext_ResourceMetadata_description(ctx, field)
			case "isFavorite":
				return ec.fieldContext_ResourceMetadata_isFavorite(ctx, field)
			case "isPinned":
				return ec.fieldContext_ResourceMetadata_isPinned(ctx, field)
			case "notes":
				return ec.fieldContext_ResourceMetadata_notes(ctx, field)
			case "recentChanges":
				return ec.fieldContext_ResourceMetadata_recentChanges(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ResourceMetadata", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _WireGuardClient_relationships(ctx context.Context, field graphql.CollectedField, obj *model.WireGuardClient) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WireGuardClient_relationships(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Relationships, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.ResourceRelationships)
	fc.Result = res
	return ec.marshalOResourceRelationships2backendgraphmodelResourceRelationships(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WireGuardClient_relationships(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WireGuardClient",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "dependsOn":
				return ec.fieldContext_ResourceRelationships_dependsOn(ctx, field)
			case "dependents":
				return ec.fieldContext_ResourceRelationships_dependents(ctx, field)
			case "routesVia":
				return ec.fieldContext_ResourceRelationships_routesVia(ctx, field)
			case "routedBy":
				return ec.fieldContext_ResourceRelationships_routedBy(ctx, field)
			case "parent":
				return ec.fieldContext_ResourceRelationships_parent(ctx, field)
			case "children":
				return ec.fieldContext_ResourceRelationships_children(ctx, field)
			case "custom":
				return ec.fieldContext_ResourceRelationships_custom(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ResourceRelationships", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _WireGuardClient_platform(ctx context.Context, field graphql.CollectedField, obj *model.WireGuardClient) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WireGuardClient_platform(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Platform, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.PlatformInfo)
	fc.Result = res
	return ec.marshalOPlatformInfo2backendgraphmodelPlatformInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WireGuardClient_platform(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WireGuardClient",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "current":
				return ec.fieldContext_PlatformInfo_current(ctx, field)
			case "capabilities":
				return ec.fieldContext_PlatformInfo_capabilities(ctx, field)
			case "fieldMappings":
				return ec.fieldContext_PlatformInfo_fieldMappings(ctx, field)
			case "limitations":
				return ec.fieldContext_PlatformInfo_limitations(ctx, field)
			case "features":
				return ec.fieldContext_PlatformInfo_features(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PlatformInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _WireGuardClient_config(ctx context.Context, field graphql.CollectedField, obj *model.WireGuardClient) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WireGuardClient_config(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Config, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.WireGuardClientConfig)
	fc.Result = res
	return ec.marshalNWireGuardClientConfig2backendgraphmodelWireGuardClientConfig(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WireGuardClient_config(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WireGuardClient",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_WireGuardClientConfig_name(ctx, field)
			case "privateKey":
				return ec.fieldContext_WireGuardClientConfig_privateKey(ctx, field)
			case "peerPublicKey":
				return ec.fieldContext_WireGuardClientConfig_peerPublicKey(ctx, field)
			case "peerEndpoint":
				return ec.fieldContext_WireGuardClientConfig_peerEndpoint(ctx, field)
			case "allowedIPs":
				return ec.fieldContext_WireGuardClientConfig_allowedIPs(ctx, field)
			case "persistentKeepalive":
				return ec.fieldContext_WireGuardClientConfig_persistentKeepalive(ctx, field)
			case "listenPort":
				return ec.fieldContext_WireGuardClientConfig_listenPort(ctx, field)
			case "wanInterface":
				return ec.fieldContext_WireGuardClientConfig_wanInterface(ctx, field)
			case "killSwitch":
				return ec.fieldContext_WireGuardClientConfig_killSwitch(ctx, field)
			case "dnsServers":
				return ec.fieldContext_WireGuardClientConfig_dnsServers(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type WireGuardClientConfig", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _WireGuardClient_wireguardDeployment(ctx context.Context, field graphql.CollectedField, obj *model.WireGuardClient) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WireGuardClient_wireguardDeployment(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.WireguardDeployment, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.WireGuardDeployment)
	fc.Result = res
	return ec.marshalOWireGuardDeployment2backendgraphmodelWireGuardDeployment(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WireGuardClient_wireguardDeployment(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WireGuardClient",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "routerResourceId":
				return ec.fieldContext_WireGuardDeployment_routerResourceId(ctx, field)
			case "appliedAt":
				return ec.fieldContext_WireGuardDeployment_appliedAt(ctx, field)
			case "appliedBy":
				return ec.fieldContext_WireGuardDeployment_appliedBy(ctx, field)
			case "routerVersion":
				return ec.fieldContext_WireGuardDeployment_routerVersion(ctx, field)
			case "isInSync":
				return ec.fieldContext_WireGuardDeployment_isInSync(ctx, field)
			case "drift":
				return ec.fieldContext_WireGuardDeployment_drift(ctx, field)
			case "publicKey":
				return ec.fieldContext_WireGuardDeployment_publicKey(ctx, field)
			case "interfaceName":
				return ec.fieldContext_WireGuardDeployment_interfaceName(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type WireGuardDeployment", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _WireGuardClient_wireguardRuntime(ctx context.Context, field graphql.CollectedField, obj *model.WireGuardClient) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WireGuardClient_wireguardRuntime(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.WireguardRuntime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.WireGuardRuntime)
	fc.Result = res
	return ec.marshalOWireGuardRuntime2backendgraphmodelWireGuardRuntime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WireGuardClient_wireguardRuntime(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WireGuardClient",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "isRunning":
				return ec.fieldContext_WireGuardRuntime_isRunning(ctx, field)
			case "health":
				return ec.fieldContext_WireGuardRuntime_health(ctx, field)
			case "errorMessage":
				return ec.fieldContext_WireGuardRuntime_errorMessage(ctx, field)
			case "lastUpdated":
				return ec.fieldContext_WireGuardRuntime_lastUpdated(ctx, field)
			case "isConnected":
				return ec.fieldContext_WireGuardRuntime_isConnected(ctx, field)
			case "lastHandshake":
				return ec.fieldContext_WireGuardRuntime_lastHandshake(ctx, field)
			case "currentEndpoint":
				return ec.fieldContext_WireGuardRuntime_currentEndpoint(ctx, field)
			case "bytesIn":
				return ec.fieldContext_WireGuardRuntime_bytesIn(ctx, field)
			case "bytesOut":
				return ec.fieldContext_WireGuardRuntime_bytesOut(ctx, field)
			case "activePeers":
				return ec.fieldContext_WireGuardRuntime_activePeers(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type WireGuardRuntime", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _WireGuardClientConfig_name(ctx context.Context, field graphql.CollectedField, obj *model.WireGuardClientConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WireGuardClientConfig_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WireGuardClientConfig_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WireGuardClientConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WireGuardClientConfig_privateKey(ctx context.Context, field graphql.CollectedField, obj *model.WireGuardClientConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WireGuardClientConfig_privateKey(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.PrivateKey, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Sensitive == nil {
				return nil, errors.New("directive sensitive is not implemented")
			}
			return ec.directives.Sensitive(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WireGuardClientConfig_privateKey(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WireGuardClientConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WireGuardClientConfig_peerPublicKey(ctx context.Context, field graphql.CollectedField, obj *model.WireGuardClientConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WireGuardClientConfig_peerPublicKey(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PeerPublicKey, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WireGuardClientConfig_peerPublicKey(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WireGuardClientConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WireGuardClientConfig_peerEndpoint(ctx context.Context, field graphql.CollectedField, obj *model.WireGuardClientConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WireGuardClientConfig_peerEndpoint(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PeerEndpoint, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WireGuardClientConfig_peerEndpoint(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WireGuardClientConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WireGuardClientConfig_allowedIPs(ctx context.Context, field graphql.CollectedField, obj *model.WireGuardClientConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WireGuardClientConfig_allowedIPs(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AllowedIPs, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]model.CIDR)
	fc.Result = res
	return ec.marshalNCIDR2backendgraphmodelCIDR(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WireGuardClientConfig_allowedIPs(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WireGuardClientConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type CIDR does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WireGuardClientConfig_persistentKeepalive(ctx context.Context, field graphql.CollectedField, obj *model.WireGuardClientConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WireGuardClientConfig_persistentKeepalive(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PersistentKeepalive, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Duration)
	fc.Result = res
	return ec.marshalODuration2backendgraphmodelDuration(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WireGuardClientConfig_persistentKeepalive(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WireGuardClientConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Duration does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WireGuardClientConfig_listenPort(ctx context.Context, field graphql.CollectedField, obj *model.WireGuardClientConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WireGuardClientConfig_listenPort(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ListenPort, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Port)
	fc.Result = res
	return ec.marshalOPort2backendgraphmodelPort(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WireGuardClientConfig_listenPort(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WireGuardClientConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Port does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WireGuardClientConfig_wanInterface(ctx context.Context, field graphql.CollectedField, obj *model.WireGuardClientConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WireGuardClientConfig_wanInterface(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.WanInterface, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WireGuardClientConfig_wanInterface(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WireGuardClientConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WireGuardClientConfig_killSwitch(ctx context.Context, field graphql.CollectedField, obj *model.WireGuardClientConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WireGuardClientConfig_killSwitch(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.KillSwitch, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WireGuardClientConfig_killSwitch(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WireGuardClientConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WireGuardClientConfig_dnsServers(ctx context.Context, field graphql.CollectedField, obj *model.WireGuardClientConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WireGuardClientConfig_dnsServers(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DNSServers, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]model.IPv4)
	fc.Result = res
	return ec.marshalOIPv42backendgraphmodelIPv4(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WireGuardClientConfig_dnsServers(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WireGuardClientConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type IPv4 does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WireGuardDeployment_routerResourceId(ctx context.Context, field graphql.CollectedField, obj *model.WireGuardDeployment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WireGuardDeployment_routerResourceId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RouterResourceID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WireGuardDeployment_routerResourceId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WireGuardDeployment",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WireGuardDeployment_appliedAt(ctx context.Context, field graphql.CollectedField, obj *model.WireGuardDeployment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WireGuardDeployment_appliedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AppliedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNDateTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WireGuardDeployment_appliedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WireGuardDeployment",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DateTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WireGuardDeployment_appliedBy(ctx context.Context, field graphql.CollectedField, obj *model.WireGuardDeployment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WireGuardDeployment_appliedBy(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AppliedBy, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WireGuardDeployment_appliedBy(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WireGuardDeployment",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WireGuardDeployment_routerVersion(ctx context.Context, field graphql.CollectedField, obj *model.WireGuardDeployment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WireGuardDeployment_routerVersion(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RouterVersion, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WireGuardDeployment_routerVersion(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WireGuardDeployment",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WireGuardDeployment_isInSync(ctx context.Context, field graphql.CollectedField, obj *model.WireGuardDeployment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WireGuardDeployment_isInSync(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsInSync, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WireGuardDeployment_isInSync(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WireGuardDeployment",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WireGuardDeployment_drift(ctx context.Context, field graphql.CollectedField, obj *model.WireGuardDeployment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WireGuardDeployment_drift(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Drift, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.DriftInfo)
	fc.Result = res
	return ec.marshalODriftInfo2backendgraphmodelDriftInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WireGuardDeployment_drift(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WireGuardDeployment",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "detectedAt":
				return ec.fieldContext_DriftInfo_detectedAt(ctx, field)
			case "driftedFields":
				return ec.fieldContext_DriftInfo_driftedFields(ctx, field)
			case "suggestedAction":
				return ec.fieldContext_DriftInfo_suggestedAction(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DriftInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _WireGuardDeployment_publicKey(ctx context.Context, field graphql.CollectedField, obj *model.WireGuardDeployment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WireGuardDeployment_publicKey(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PublicKey, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WireGuardDeployment_publicKey(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WireGuardDeployment",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WireGuardDeployment_interfaceName(ctx context.Context, field graphql.CollectedField, obj *model.WireGuardDeployment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WireGuardDeployment_interfaceName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.InterfaceName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WireGuardDeployment_interfaceName(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WireGuardDeployment",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WireGuardRuntime_isRunning(ctx context.Context, field graphql.CollectedField, obj *model.WireGuardRuntime) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WireGuardRuntime_isRunning(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsRunning, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WireGuardRuntime_isRunning(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WireGuardRuntime",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WireGuardRuntime_health(ctx context.Context, field graphql.CollectedField, obj *model.WireGuardRuntime) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WireGuardRuntime_health(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Health, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.RuntimeHealth)
	fc.Result = res
	return ec.marshalNRuntimeHealth2backendgraphmodelRuntimeHealth(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WireGuardRuntime_health(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WireGuardRuntime",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type RuntimeHealth does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WireGuardRuntime_errorMessage(ctx context.Context, field graphql.CollectedField, obj *model.WireGuardRuntime) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WireGuardRuntime_errorMessage(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ErrorMessage, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WireGuardRuntime_errorMessage(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WireGuardRuntime",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WireGuardRuntime_lastUpdated(ctx context.Context, field graphql.CollectedField, obj *model.WireGuardRuntime) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WireGuardRuntime_lastUpdated(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LastUpdated, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNDateTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WireGuardRuntime_lastUpdated(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WireGuardRuntime",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DateTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WireGuardRuntime_isConnected(ctx context.Context, field graphql.CollectedField, obj *model.WireGuardRuntime) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WireGuardRuntime_isConnected(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsConnected, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WireGuardRuntime_isConnected(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WireGuardRuntime",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WireGuardRuntime_lastHandshake(ctx context.Context, field graphql.CollectedField, obj *model.WireGuardRuntime) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WireGuardRuntime_lastHandshake(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LastHandshake, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalODateTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WireGuardRuntime_lastHandshake(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WireGuardRuntime",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DateTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WireGuardRuntime_currentEndpoint(ctx context.Context, field graphql.CollectedField, obj *model.WireGuardRuntime) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WireGuardRuntime_currentEndpoint(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CurrentEndpoint, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WireGuardRuntime_currentEndpoint(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WireGuardRuntime",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WireGuardRuntime_bytesIn(ctx context.Context, field graphql.CollectedField, obj *model.WireGuardRuntime) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WireGuardRuntime_bytesIn(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BytesIn, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.Size)
	fc.Result = res
	return ec.marshalNSize2backendgraphmodelSize(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WireGuardRuntime_bytesIn(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WireGuardRuntime",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Size does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WireGuardRuntime_bytesOut(ctx context.Context, field graphql.CollectedField, obj *model.WireGuardRuntime) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WireGuardRuntime_bytesOut(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BytesOut, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.Size)
	fc.Result = res
	return ec.marshalNSize2backendgraphmodelSize(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WireGuardRuntime_bytesOut(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WireGuardRuntime",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Size does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WireGuardRuntime_activePeers(ctx context.Context, field graphql.CollectedField, obj *model.WireGuardRuntime) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WireGuardRuntime_activePeers(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ActivePeers, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WireGuardRuntime_activePeers(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WireGuardRuntime",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_locations(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_locations(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Locations, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalN__DirectiveLocation2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_locations(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type __DirectiveLocation does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_args(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_args(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_isRepeatable(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_isRepeatable(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsRepeatable, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_isRepeatable(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_isDeprecated(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_isDeprecated(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_deprecationReason(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_deprecationReason(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_args(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_args(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_type(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_isDeprecated(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_isDeprecated(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_deprecationReason(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_deprecationReason(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_type(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_defaultValue(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_defaultValue(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DefaultValue, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_defaultValue(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_types(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_types(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Types(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_types(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_queryType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_queryType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.QueryType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_queryType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_mutationType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_mutationType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MutationType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_mutationType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_subscriptionType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_subscriptionType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SubscriptionType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_subscriptionType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_directives(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_directives(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Directives(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Directive)
	fc.Result = res
	return ec.marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_directives(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___Directive_name(ctx, field)
			case "description":
				return ec.fieldContext___Directive_description(ctx, field)
			case "locations":
				return ec.fieldContext___Directive_locations(ctx, field)
			case "args":
				return ec.fieldContext___Directive_args(ctx, field)
			case "isRepeatable":
				return ec.fieldContext___Directive_isRepeatable(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Directive", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_kind(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_kind(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Kind(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalN__TypeKind2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_kind(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type __TypeKind does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_fields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_fields(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Fields(fc.Args["includeDeprecated"].(bool)), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Field)
	fc.Result = res
	return ec.marshalO__Field2githubcom99designsgqlgengraphqlintrospectionField(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_fields(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___Field_name(ctx, field)
			case "description":
				return ec.fieldContext___Field_description(ctx, field)
			case "args":
				return ec.fieldContext___Field_args(ctx, field)
			case "type":
				return ec.fieldContext___Field_type(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___Field_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___Field_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Field", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field___Type_fields_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) ___Type_interfaces(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_interfaces(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Interfaces(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_interfaces(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_possibleTypes(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_possibleTypes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PossibleTypes(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_possibleTypes(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_enumValues(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_enumValues(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EnumValues(fc.Args["includeDeprecated"].(bool)), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.EnumValue)
	fc.Result = res
	return ec.marshalO__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_enumValues(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___EnumValue_name(ctx, field)
			case "description":
				return ec.fieldContext___EnumValue_description(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___EnumValue_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___EnumValue_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __EnumValue", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field___Type_enumValues_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) ___Type_inputFields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_inputFields(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.InputFields(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalO__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_inputFields(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_ofType(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_ofType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OfType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_ofType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_specifiedByURL(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_specifiedByURL(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SpecifiedByURL(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_specifiedByURL(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

// endregion **************************** field.gotpl *****************************

// region    **************************** input.gotpl *****************************

func (ec *executionContext) unmarshalInputAddBridgePortInput(ctx context.Context, obj interface{}) (model.AddBridgePortInput, error) {
	var it model.AddBridgePortInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"interfaceId", "pvid", "frameTypes", "ingressFiltering"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "interfaceId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("interfaceId"))
			data, err := ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.InterfaceID = data
		case "pvid":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pvid"))
			directive0 := func(ctx context.Context) (interface{}, error) { return ec.unmarshalOInt2int(ctx, v) }
			directive1 := func(ctx context.Context) (interface{}, error) {
				min, err := ec.unmarshalOInt2int(ctx, 1)
				if err != nil {
					return nil, err
				}
				max, err := ec.unmarshalOInt2int(ctx, 4094)
				if err != nil {
					return nil, err
				}
				if ec.directives.Validate == nil {
					return nil, errors.New("directive validate is not implemented")
				}
				return ec.directives.Validate(ctx, obj, directive0, min, max, nil, nil, nil, nil)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*int); ok {
				it.Pvid = graphql.OmittableOf(data)
			} else if tmp == nil {
				it.Pvid = graphql.OmittableOf[*int](nil)
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *int`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "frameTypes":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("frameTypes"))
			data, err := ec.unmarshalOFrameTypes2backendgraphmodelFrameTypes(ctx, v)
			if err != nil {
				return it, err
			}
			it.FrameTypes = graphql.OmittableOf(data)
		case "ingressFiltering":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ingressFiltering"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.IngressFiltering = graphql.OmittableOf(data)
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputAddRouterInput(ctx context.Context, obj interface{}) (model.AddRouterInput, error) {
	var it model.AddRouterInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"host", "port", "username", "password", "protocolPreference", "name"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "host":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("host"))
			directive0 := func(ctx context.Context) (interface{}, error) { return ec.unmarshalNString2string(ctx, v) }
			directive1 := func(ctx context.Context) (interface{}, error) {
				minLength, err := ec.unmarshalOInt2int(ctx, 1)
				if err != nil {
					return nil, err
				}
				maxLength, err := ec.unmarshalOInt2int(ctx, 253)
				if err != nil {
					return nil, err
				}
				if ec.directives.Validate == nil {
					return nil, errors.New("directive validate is not implemented")
				}
				return ec.directives.Validate(ctx, obj, directive0, nil, nil, minLength, maxLength, nil, nil)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(string); ok {
				it.Host = data
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "port":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("port"))
			directive0 := func(ctx context.Context) (interface{}, error) { return ec.unmarshalOInt2int(ctx, v) }
			directive1 := func(ctx context.Context) (interface{}, error) {
				min, err := ec.unmarshalOInt2int(ctx, 1)
				if err != nil {
					return nil, err
				}
				max, err := ec.unmarshalOInt2int(ctx, 65535)
				if err != nil {
					return nil, err
				}
				if ec.directives.Validate == nil {
					return nil, errors.New("directive validate is not implemented")
				}
				return ec.directives.Validate(ctx, obj, directive0, min, max, nil, nil, nil, nil)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*int); ok {
				it.Port = graphql.OmittableOf(data)
			} else if tmp == nil {
				it.Port = graphql.OmittableOf[*int](nil)
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *int`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "username":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("username"))
			directive0 := func(ctx context.Context) (interface{}, error) { return ec.unmarshalNString2string(ctx, v) }
			directive1 := func(ctx context.Context) (interface{}, error) {
				minLength, err := ec.unmarshalOInt2int(ctx, 1)
				if err != nil {
					return nil, err
				}
				maxLength, err := ec.unmarshalOInt2int(ctx, 64)
				if err != nil {
					return nil, err
				}
				if ec.directives.Validate == nil {
					return nil, errors.New("directive validate is not implemented")
				}
				return ec.directives.Validate(ctx, obj, directive0, nil, nil, minLength, maxLength, nil, nil)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(string); ok {
				it.Username = data
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "password":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("password"))
			directive0 := func(ctx context.Context) (interface{}, error) { return ec.unmarshalNString2string(ctx, v) }
			directive1 := func(ctx context.Context) (interface{}, error) {
				if ec.directives.Sensitive == nil {
					return nil, errors.New("directive sensitive is not implemented")
				}
				return ec.directives.Sensitive(ctx, obj, directive0)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(string); ok {
				it.Password = data
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "protocolPreference":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("protocolPreference"))
			data, err := ec.unmarshalOProtocolPreference2backendgraphmodelProtocolPreference(ctx, v)
			if err != nil {
				return it, err
			}
			it.ProtocolPreference = graphql.OmittableOf(data)
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			directive0 := func(ctx context.Context) (interface{}, error) { return ec.unmarshalOString2string(ctx, v) }
			directive1 := func(ctx context.Context) (interface{}, error) {
				maxLength, err := ec.unmarshalOInt2int(ctx, 128)
				if err != nil {
					return nil, err
				}
				if ec.directives.Validate == nil {
					return nil, errors.New("directive validate is not implemented")
				}
				return ec.directives.Validate(ctx, obj, directive0, nil, nil, nil, maxLength, nil, nil)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*string); ok {
				it.Name = graphql.OmittableOf(data)
			} else if tmp == nil {
				it.Name = graphql.OmittableOf[*string](nil)
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputAlertConditionInput(ctx context.Context, obj interface{}) (model.AlertConditionInput, error) {
	var it model.AlertConditionInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"field", "operator", "value"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "field":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("field"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Field = data
		case "operator":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("operator"))
			data, err := ec.unmarshalNConditionOperator2backendgraphmodelConditionOperator(ctx, v)
			if err != nil {
				return it, err
			}
			it.Operator = data
		case "value":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("value"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Value = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputBatchInterfaceInput(ctx context.Context, obj interface{}) (model.BatchInterfaceInput, error) {
	var it model.BatchInterfaceInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"interfaceIds", "action", "input"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "interfaceIds":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("interfaceIds"))
			data, err := ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.InterfaceIds = data
		case "action":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("action"))
			data, err := ec.unmarshalNBatchInterfaceAction2backendgraphmodelBatchInterfaceAction(ctx, v)
			if err != nil {
				return it, err
			}
			it.Action = data
		case "input":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
			data, err := ec.unmarshalOUpdateInterfaceInput2backendgraphmodelUpdateInterfaceInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Input = graphql.OmittableOf(data)
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputBridgePortVlanInput(ctx context.Context, obj interface{}) (model.BridgePortVlanInput, error) {
	var it model.BridgePortVlanInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"pvid", "frameTypes", "taggedVlans", "mode"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "pvid":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pvid"))
			directive0 := func(ctx context.Context) (interface{}, error) { return ec.unmarshalNInt2int(ctx, v) }
			directive1 := func(ctx context.Context) (interface{}, error) {
				min, err := ec.unmarshalOInt2int(ctx, 1)
				if err != nil {
					return nil, err
				}
				max, err := ec.unmarshalOInt2int(ctx, 4094)
				if err != nil {
					return nil, err
				}
				if ec.directives.Validate == nil {
					return nil, errors.New("directive validate is not implemented")
				}
				return ec.directives.Validate(ctx, obj, directive0, min, max, nil, nil, nil, nil)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(int); ok {
				it.Pvid = data
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be int`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "frameTypes":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("frameTypes"))
			data, err := ec.unmarshalNBridgePortFrameTypes2backendgraphmodelBridgePortFrameTypes(ctx, v)
			if err != nil {
				return it, err
			}
			it.FrameTypes = data
		case "taggedVlans":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("taggedVlans"))
			directive0 := func(ctx context.Context) (interface{}, error) { return ec.unmarshalOInt2int(ctx, v) }
			directive1 := func(ctx context.Context) (interface{}, error) {
				min, err := ec.unmarshalOInt2int(ctx, 1)
				if err != nil {
					return nil, err
				}
				max, err := ec.unmarshalOInt2int(ctx, 4094)
				if err != nil {
					return nil, err
				}
				if ec.directives.Validate == nil {
					return nil, errors.New("directive validate is not implemented")
				}
				return ec.directives.Validate(ctx, obj, directive0, min, max, nil, nil, nil, nil)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.([]int); ok {
				it.TaggedVlans = graphql.OmittableOf(data)
			} else if tmp == nil {
				it.TaggedVlans = graphql.OmittableOf[[]int](nil)
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be []int`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "mode":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("mode"))
			data, err := ec.unmarshalNPortMode2backendgraphmodelPortMode(ctx, v)
			if err != nil {
				return it, err
			}
			it.Mode = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputChangeSetItemInput(ctx context.Context, obj interface{}) (model.ChangeSetItemInput, error) {
	var it model.ChangeSetItemInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"resourceType", "resourceCategory", "resourceUuid", "name", "description", "operation", "configuration", "previousState", "dependencies"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "resourceType":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("resourceType"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ResourceType = data
		case "resourceCategory":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("resourceCategory"))
			data, err := ec.unmarshalNResourceCategory2backendgraphmodelResourceCategory(ctx, v)
			if err != nil {
				return it, err
			}
			it.ResourceCategory = data
		case "resourceUuid":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("resourceUuid"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ResourceUUID = graphql.OmittableOf(data)
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "description":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = graphql.OmittableOf(data)
		case "operation":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("operation"))
			data, err := ec.unmarshalNChangeOperation2backendgraphmodelChangeOperation(ctx, v)
			if err != nil {
				return it, err
			}
			it.Operation = data
		case "configuration":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("configuration"))
			data, err := ec.unmarshalNJSON2map(ctx, v)
			if err != nil {
				return it, err
			}
			it.Configuration = data
		case "previousState":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("previousState"))
			data, err := ec.unmarshalOJSON2map(ctx, v)
			if err != nil {
				return it, err
			}
			it.PreviousState = graphql.OmittableOf(data)
		case "dependencies":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("dependencies"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Dependencies = graphql.OmittableOf(data)
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCreateAlertRuleInput(ctx context.Context, obj interface{}) (model.CreateAlertRuleInput, error) {
	var it model.CreateAlertRuleInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	if _, present := asMap["enabled"]; !present {
		asMap["enabled"] = true
	}

	fieldsInOrder := [...]string{"name", "description", "eventType", "conditions", "severity", "channels", "throttle", "quietHours", "deviceId", "enabled"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "description":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = graphql.OmittableOf(data)
		case "eventType":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("eventType"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.EventType = data
		case "conditions":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("conditions"))
			data, err := ec.unmarshalOAlertConditionInput2backendgraphmodelAlertConditionInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Conditions = graphql.OmittableOf(data)
		case "severity":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("severity"))
			data, err := ec.unmarshalNAlertSeverity2backendgraphmodelAlertSeverity(ctx, v)
			if err != nil {
				return it, err
			}
			it.Severity = data
		case "channels":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("channels"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Channels = data
		case "throttle":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("throttle"))
			data, err := ec.unmarshalOThrottleConfigInput2backendgraphmodelThrottleConfigInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Throttle = graphql.OmittableOf(data)
		case "quietHours":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("quietHours"))
			data, err := ec.unmarshalOQuietHoursConfigInput2backendgraphmodelQuietHoursConfigInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.QuietHours = graphql.OmittableOf(data)
		case "deviceId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deviceId"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeviceID = graphql.OmittableOf(data)
		case "enabled":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("enabled"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Enabled = graphql.OmittableOf(data)
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCreateBridgeInput(ctx context.Context, obj interface{}) (model.CreateBridgeInput, error) {
	var it model.CreateBridgeInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "comment", "protocol", "priority", "vlanFiltering", "pvid", "mtu"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			directive0 := func(ctx context.Context) (interface{}, error) { return ec.unmarshalNString2string(ctx, v) }
			directive1 := func(ctx context.Context) (interface{}, error) {
				minLength, err := ec.unmarshalOInt2int(ctx, 1)
				if err != nil {
					return nil, err
				}
				maxLength, err := ec.unmarshalOInt2int(ctx, 100)
				if err != nil {
					return nil, err
				}
				pattern, err := ec.unmarshalOString2string(ctx, "^[a-zA-Z][a-zA-Z0-9_-]*$")
				if err != nil {
					return nil, err
				}
				if ec.directives.Validate == nil {
					return nil, errors.New("directive validate is not implemented")
				}
				return ec.directives.Validate(ctx, obj, directive0, nil, nil, minLength, maxLength, pattern, nil)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(string); ok {
				it.Name = data
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "comment":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("comment"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Comment = graphql.OmittableOf(data)
		case "protocol":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("protocol"))
			data, err := ec.unmarshalOStpProtocol2backendgraphmodelStpProtocol(ctx, v)
			if err != nil {
				return it, err
			}
			it.Protocol = graphql.OmittableOf(data)
		case "priority":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("priority"))
			directive0 := func(ctx context.Context) (interface{}, error) { return ec.unmarshalOInt2int(ctx, v) }
			directive1 := func(ctx context.Context) (interface{}, error) {
				min, err := ec.unmarshalOInt2int(ctx, 0)
				if err != nil {
					return nil, err
				}
				max, err := ec.unmarshalOInt2int(ctx, 61440)
				if err != nil {
					return nil, err
				}
				if ec.directives.Validate == nil {
					return nil, errors.New("directive validate is not implemented")
				}
				return ec.directives.Validate(ctx, obj, directive0, min, max, nil, nil, nil, nil)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*int); ok {
				it.Priority = graphql.OmittableOf(data)
			} else if tmp == nil {
				it.Priority = graphql.OmittableOf[*int](nil)
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *int`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "vlanFiltering":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("vlanFiltering"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.VlanFiltering = graphql.OmittableOf(data)
		case "pvid":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pvid"))
			directive0 := func(ctx context.Context) (interface{}, error) { return ec.unmarshalOInt2int(ctx, v) }
			directive1 := func(ctx context.Context) (interface{}, error) {
				min, err := ec.unmarshalOInt2int(ctx, 1)
				if err != nil {
					return nil, err
				}
				max, err := ec.unmarshalOInt2int(ctx, 4094)
				if err != nil {
					return nil, err
				}
				if ec.directives.Validate == nil {
					return nil, errors.New("directive validate is not implemented")
				}
				return ec.directives.Validate(ctx, obj, directive0, min, max, nil, nil, nil, nil)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*int); ok {
				it.Pvid = graphql.OmittableOf(data)
			} else if tmp == nil {
				it.Pvid = graphql.OmittableOf[*int](nil)
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *int`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "mtu":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("mtu"))
			directive0 := func(ctx context.Context) (interface{}, error) { return ec.unmarshalOInt2int(ctx, v) }
			directive1 := func(ctx context.Context) (interface{}, error) {
				min, err := ec.unmarshalOInt2int(ctx, 68)
				if err != nil {
					return nil, err
				}
				max, err := ec.unmarshalOInt2int(ctx, 65535)
				if err != nil {
					return nil, err
				}
				if ec.directives.Validate == nil {
					return nil, errors.New("directive validate is not implemented")
				}
				return ec.directives.Validate(ctx, obj, directive0, min, max, nil, nil, nil, nil)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*int); ok {
				it.Mtu = graphql.OmittableOf(data)
			} else if tmp == nil {
				it.Mtu = graphql.OmittableOf[*int](nil)
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *int`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCreateBridgeVlanInput(ctx context.Context, obj interface{}) (model.CreateBridgeVlanInput, error) {
	var it model.CreateBridgeVlanInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"vlanId", "taggedPortIds", "untaggedPortIds"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "vlanId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("vlanId"))
			directive0 := func(ctx context.Context) (interface{}, error) { return ec.unmarshalNInt2int(ctx, v) }
			directive1 := func(ctx context.Context) (interface{}, error) {
				min, err := ec.unmarshalOInt2int(ctx, 1)
				if err != nil {
					return nil, err
				}
				max, err := ec.unmarshalOInt2int(ctx, 4094)
				if err != nil {
					return nil, err
				}
				if ec.directives.Validate == nil {
					return nil, errors.New("directive validate is not implemented")
				}
				return ec.directives.Validate(ctx, obj, directive0, min, max, nil, nil, nil, nil)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(int); ok {
				it.VlanID = data
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be int`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "taggedPortIds":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("taggedPortIds"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.TaggedPortIds = graphql.OmittableOf(data)
		case "untaggedPortIds":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("untaggedPortIds"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UntaggedPortIds = graphql.OmittableOf(data)
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCreateChangeSetInput(ctx context.Context, obj interface{}) (model.CreateChangeSetInput, error) {
	var it model.CreateChangeSetInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"routerId", "name", "description", "source"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "routerId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("routerId"))
			data, err := ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.RouterID = data
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "description":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = graphql.OmittableOf(data)
		case "source":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("source"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Source = graphql.OmittableOf(data)
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCreateResourceInput(ctx context.Context, obj interface{}) (model.CreateResourceInput, error) {
	var it model.CreateResourceInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"routerId", "type", "category", "configuration", "relationships", "tags", "description"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "routerId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("routerId"))
			data, err := ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.RouterID = data
		case "type":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("type"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Type = data
		case "category":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("category"))
			data, err := ec.unmarshalNResourceCategory2backendgraphmodelResourceCategory(ctx, v)
			if err != nil {
				return it, err
			}
			it.Category = data
		case "configuration":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("configuration"))
			data, err := ec.unmarshalNJSON2map(ctx, v)
			if err != nil {
				return it, err
			}
			it.Configuration = data
		case "relationships":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("relationships"))
			data, err := ec.unmarshalOResourceRelationshipsInput2backendgraphmodelResourceRelationshipsInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Relationships = graphql.OmittableOf(data)
		case "tags":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tags"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Tags = graphql.OmittableOf(data)
		case "description":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = graphql.OmittableOf(data)
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCreateRouterInput(ctx context.Context, obj interface{}) (model.CreateRouterInput, error) {
	var it model.CreateRouterInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "host", "port", "username", "password", "platform"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			directive0 := func(ctx context.Context) (interface{}, error) { return ec.unmarshalNString2string(ctx, v) }
			directive1 := func(ctx context.Context) (interface{}, error) {
				minLength, err := ec.unmarshalOInt2int(ctx, 1)
				if err != nil {
					return nil, err
				}
				maxLength, err := ec.unmarshalOInt2int(ctx, 64)
				if err != nil {
					return nil, err
				}
				if ec.directives.Validate == nil {
					return nil, errors.New("directive validate is not implemented")
				}
				return ec.directives.Validate(ctx, obj, directive0, nil, nil, minLength, maxLength, nil, nil)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(string); ok {
				it.Name = data
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "host":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("host"))
			directive0 := func(ctx context.Context) (interface{}, error) { return ec.unmarshalNString2string(ctx, v) }
			directive1 := func(ctx context.Context) (interface{}, error) {
				minLength, err := ec.unmarshalOInt2int(ctx, 1)
				if err != nil {
					return nil, err
				}
				maxLength, err := ec.unmarshalOInt2int(ctx, 255)
				if err != nil {
					return nil, err
				}
				if ec.directives.Validate == nil {
					return nil, errors.New("directive validate is not implemented")
				}
				return ec.directives.Validate(ctx, obj, directive0, nil, nil, minLength, maxLength, nil, nil)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(string); ok {
				it.Host = data
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "port":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("port"))
			directive0 := func(ctx context.Context) (interface{}, error) { return ec.unmarshalOInt2int(ctx, v) }
			directive1 := func(ctx context.Context) (interface{}, error) {
				min, err := ec.unmarshalOInt2int(ctx, 1)
				if err != nil {
					return nil, err
				}
				max, err := ec.unmarshalOInt2int(ctx, 65535)
				if err != nil {
					return nil, err
				}
				if ec.directives.Validate == nil {
					return nil, errors.New("directive validate is not implemented")
				}
				return ec.directives.Validate(ctx, obj, directive0, min, max, nil, nil, nil, nil)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*int); ok {
				it.Port = graphql.OmittableOf(data)
			} else if tmp == nil {
				it.Port = graphql.OmittableOf[*int](nil)
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *int`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "username":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("username"))
			directive0 := func(ctx context.Context) (interface{}, error) { return ec.unmarshalNString2string(ctx, v) }
			directive1 := func(ctx context.Context) (interface{}, error) {
				minLength, err := ec.unmarshalOInt2int(ctx, 1)
				if err != nil {
					return nil, err
				}
				maxLength, err := ec.unmarshalOInt2int(ctx, 64)
				if err != nil {
					return nil, err
				}
				if ec.directives.Validate == nil {
					return nil, errors.New("directive validate is not implemented")
				}
				return ec.directives.Validate(ctx, obj, directive0, nil, nil, minLength, maxLength, nil, nil)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(string); ok {
				it.Username = data
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "password":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("password"))
			directive0 := func(ctx context.Context) (interface{}, error) { return ec.unmarshalNString2string(ctx, v) }
			directive1 := func(ctx context.Context) (interface{}, error) {
				minLength, err := ec.unmarshalOInt2int(ctx, 1)
				if err != nil {
					return nil, err
				}
				maxLength, err := ec.unmarshalOInt2int(ctx, 128)
				if err != nil {
					return nil, err
				}
				if ec.directives.Validate == nil {
					return nil, errors.New("directive validate is not implemented")
				}
				return ec.directives.Validate(ctx, obj, directive0, nil, nil, minLength, maxLength, nil, nil)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(string); ok {
				it.Password = data
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "platform":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("platform"))
			data, err := ec.unmarshalORouterPlatform2backendgraphmodelRouterPlatform(ctx, v)
			if err != nil {
				return it, err
			}
			it.Platform = graphql.OmittableOf(data)
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCredentialsInput(ctx context.Context, obj interface{}) (model.CredentialsInput, error) {
	var it model.CredentialsInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"username", "password"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "username":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("username"))
			directive0 := func(ctx context.Context) (interface{}, error) { return ec.unmarshalNString2string(ctx, v) }
			directive1 := func(ctx context.Context) (interface{}, error) {
				minLength, err := ec.unmarshalOInt2int(ctx, 1)
				if err != nil {
					return nil, err
				}
				maxLength, err := ec.unmarshalOInt2int(ctx, 64)
				if err != nil {
					return nil, err
				}
				if ec.directives.Validate == nil {
					return nil, errors.New("directive validate is not implemented")
				}
				return ec.directives.Validate(ctx, obj, directive0, nil, nil, minLength, maxLength, nil, nil)
			}
			directive2 := func(ctx context.Context) (interface{}, error) {
				if ec.directives.Sensitive == nil {
					return nil, errors.New("directive sensitive is not implemented")
				}
				return ec.directives.Sensitive(ctx, obj, directive1)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(string); ok {
				it.Username = data
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "password":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("password"))
			directive0 := func(ctx context.Context) (interface{}, error) { return ec.unmarshalNString2string(ctx, v) }
			directive1 := func(ctx context.Context) (interface{}, error) {
				minLength, err := ec.unmarshalOInt2int(ctx, 1)
				if err != nil {
					return nil, err
				}
				maxLength, err := ec.unmarshalOInt2int(ctx, 128)
				if err != nil {
					return nil, err
				}
				if ec.directives.Validate == nil {
					return nil, errors.New("directive validate is not implemented")
				}
				return ec.directives.Validate(ctx, obj, directive0, nil, nil, minLength, maxLength, nil, nil)
			}
			directive2 := func(ctx context.Context) (interface{}, error) {
				if ec.directives.Sensitive == nil {
					return nil, errors.New("directive sensitive is not implemented")
				}
				return ec.directives.Sensitive(ctx, obj, directive1)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(string); ok {
				it.Password = data
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputDhcpClientInput(ctx context.Context, obj interface{}) (model.DhcpClientInput, error) {
	var it model.DhcpClientInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"interface", "addDefaultRoute", "usePeerDNS", "usePeerNTP", "comment"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "interface":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("interface"))
			directive0 := func(ctx context.Context) (interface{}, error) { return ec.unmarshalNString2string(ctx, v) }
			directive1 := func(ctx context.Context) (interface{}, error) {
				minLength, err := ec.unmarshalOInt2int(ctx, 1)
				if err != nil {
					return nil, err
				}
				maxLength, err := ec.unmarshalOInt2int(ctx, 100)
				if err != nil {
					return nil, err
				}
				if ec.directives.Validate == nil {
					return nil, errors.New("directive validate is not implemented")
				}
				return ec.directives.Validate(ctx, obj, directive0, nil, nil, minLength, maxLength, nil, nil)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(string); ok {
				it.Interface = data
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "addDefaultRoute":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("addDefaultRoute"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.AddDefaultRoute = graphql.OmittableOf(data)
		case "usePeerDNS":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("usePeerDNS"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.UsePeerDNS = graphql.OmittableOf(data)
		case "usePeerNTP":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("usePeerNTP"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.UsePeerNtp = graphql.OmittableOf(data)
		case "comment":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("comment"))
			directive0 := func(ctx context.Context) (interface{}, error) { return ec.unmarshalOString2string(ctx, v) }
			directive1 := func(ctx context.Context) (interface{}, error) {
				maxLength, err := ec.unmarshalOInt2int(ctx, 255)
				if err != nil {
					return nil, err
				}
				if ec.directives.Validate == nil {
					return nil, errors.New("directive validate is not implemented")
				}
				return ec.directives.Validate(ctx, obj, directive0, nil, nil, nil, maxLength, nil, nil)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*string); ok {
				it.Comment = graphql.OmittableOf(data)
			} else if tmp == nil {
				it.Comment = graphql.OmittableOf[*string](nil)
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputDnsLookupInput(ctx context.Context, obj interface{}) (model.DNSLookupInput, error) {
	var it model.DNSLookupInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"deviceId", "hostname", "recordType", "server", "timeout"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "deviceId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deviceId"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeviceID = data
		case "hostname":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hostname"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Hostname = data
		case "recordType":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("recordType"))
			data, err := ec.unmarshalNDnsRecordType2backendgraphmodelDNSRecordType(ctx, v)
			if err != nil {
				return it, err
			}
			it.RecordType = data
		case "server":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("server"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Server = graphql.OmittableOf(data)
		case "timeout":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("timeout"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Timeout = graphql.OmittableOf(data)
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputExportConfigInput(ctx context.Context, obj interface{}) (model.ExportConfigInput, error) {
	var it model.ExportConfigInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"routerId", "includeCredentials", "encryptionKey"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "routerId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("routerId"))
			data, err := ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.RouterID = data
		case "includeCredentials":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("includeCredentials"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.IncludeCredentials = graphql.OmittableOf(data)
		case "encryptionKey":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("encryptionKey"))
			directive0 := func(ctx context.Context) (interface{}, error) { return ec.unmarshalOString2string(ctx, v) }
			directive1 := func(ctx context.Context) (interface{}, error) {
				if ec.directives.Sensitive == nil {
					return nil, errors.New("directive sensitive is not implemented")
				}
				return ec.directives.Sensitive(ctx, obj, directive0)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*string); ok {
				it.EncryptionKey = graphql.OmittableOf(data)
			} else if tmp == nil {
				it.EncryptionKey = graphql.OmittableOf[*string](nil)
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputFeatureCompatibilityInput(ctx context.Context, obj interface{}) (model.FeatureCompatibilityInput, error) {
	var it model.FeatureCompatibilityInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"featureId", "isCHR"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "featureId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("featureId"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.FeatureID = data
		case "isCHR":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("isCHR"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.IsChr = graphql.OmittableOf(data)
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputIntRange(ctx context.Context, obj interface{}) (model.IntRange, error) {
	var it model.IntRange
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"min", "max"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "min":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("min"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Min = graphql.OmittableOf(data)
		case "max":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("max"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Max = graphql.OmittableOf(data)
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputIpAddressInput(ctx context.Context, obj interface{}) (model.IPAddressInput, error) {
	var it model.IPAddressInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"address", "interfaceId", "comment", "disabled"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "address":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("address"))
			directive0 := func(ctx context.Context) (interface{}, error) { return ec.unmarshalNString2string(ctx, v) }
			directive1 := func(ctx context.Context) (interface{}, error) {
				format, err := ec.unmarshalOValidateFormat2backendgraphmodelValidateFormat(ctx, "CIDR")
				if err != nil {
					return nil, err
				}
				if ec.directives.Validate == nil {
					return nil, errors.New("directive validate is not implemented")
				}
				return ec.directives.Validate(ctx, obj, directive0, nil, nil, nil, nil, nil, format)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(string); ok {
				it.Address = data
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "interfaceId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("interfaceId"))
			data, err := ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.InterfaceID = data
		case "comment":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("comment"))
			directive0 := func(ctx context.Context) (interface{}, error) { return ec.unmarshalOString2string(ctx, v) }
			directive1 := func(ctx context.Context) (interface{}, error) {
				maxLength, err := ec.unmarshalOInt2int(ctx, 255)
				if err != nil {
					return nil, err
				}
				if ec.directives.Validate == nil {
					return nil, errors.New("directive validate is not implemented")
				}
				return ec.directives.Validate(ctx, obj, directive0, nil, nil, nil, maxLength, nil, nil)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*string); ok {
				it.Comment = graphql.OmittableOf(data)
			} else if tmp == nil {
				it.Comment = graphql.OmittableOf[*string](nil)
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "disabled":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("disabled"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Disabled = graphql.OmittableOf(data)
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputLteModemInput(ctx context.Context, obj interface{}) (model.LteModemInput, error) {
	var it model.LteModemInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "apn", "pin", "comment"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			directive0 := func(ctx context.Context) (interface{}, error) { return ec.unmarshalNString2string(ctx, v) }
			directive1 := func(ctx context.Context) (interface{}, error) {
				minLength, err := ec.unmarshalOInt2int(ctx, 1)
				if err != nil {
					return nil, err
				}
				maxLength, err := ec.unmarshalOInt2int(ctx, 100)
				if err != nil {
					return nil, err
				}
				if ec.directives.Validate == nil {
					return nil, errors.New("directive validate is not implemented")
				}
				return ec.directives.Validate(ctx, obj, directive0, nil, nil, minLength, maxLength, nil, nil)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(string); ok {
				it.Name = data
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "apn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("apn"))
			directive0 := func(ctx context.Context) (interface{}, error) { return ec.unmarshalNString2string(ctx, v) }
			directive1 := func(ctx context.Context) (interface{}, error) {
				minLength, err := ec.unmarshalOInt2int(ctx, 1)
				if err != nil {
					return nil, err
				}
				maxLength, err := ec.unmarshalOInt2int(ctx, 100)
				if err != nil {
					return nil, err
				}
				if ec.directives.Validate == nil {
					return nil, errors.New("directive validate is not implemented")
				}
				return ec.directives.Validate(ctx, obj, directive0, nil, nil, minLength, maxLength, nil, nil)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(string); ok {
				it.Apn = data
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "pin":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pin"))
			directive0 := func(ctx context.Context) (interface{}, error) { return ec.unmarshalOString2string(ctx, v) }
			directive1 := func(ctx context.Context) (interface{}, error) {
				minLength, err := ec.unmarshalOInt2int(ctx, 4)
				if err != nil {
					return nil, err
				}
				maxLength, err := ec.unmarshalOInt2int(ctx, 8)
				if err != nil {
					return nil, err
				}
				pattern, err := ec.unmarshalOString2string(ctx, "^[0-9]+$")
				if err != nil {
					return nil, err
				}
				if ec.directives.Validate == nil {
					return nil, errors.New("directive validate is not implemented")
				}
				return ec.directives.Validate(ctx, obj, directive0, nil, nil, minLength, maxLength, pattern, nil)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*string); ok {
				it.Pin = graphql.OmittableOf(data)
			} else if tmp == nil {
				it.Pin = graphql.OmittableOf[*string](nil)
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "comment":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("comment"))
			directive0 := func(ctx context.Context) (interface{}, error) { return ec.unmarshalOString2string(ctx, v) }
			directive1 := func(ctx context.Context) (interface{}, error) {
				maxLength, err := ec.unmarshalOInt2int(ctx, 255)
				if err != nil {
					return nil, err
				}
				if ec.directives.Validate == nil {
					return nil, errors.New("directive validate is not implemented")
				}
				return ec.directives.Validate(ctx, obj, directive0, nil, nil, nil, maxLength, nil, nil)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*string); ok {
				it.Comment = graphql.OmittableOf(data)
			} else if tmp == nil {
				it.Comment = graphql.OmittableOf[*string](nil)
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputPaginationInput(ctx context.Context, obj interface{}) (model.PaginationInput, error) {
	var it model.PaginationInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"first", "after", "last", "before"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "first":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.First = graphql.OmittableOf(data)
		case "after":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.After = graphql.OmittableOf(data)
		case "last":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("last"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Last = graphql.OmittableOf(data)
		case "before":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Before = graphql.OmittableOf(data)
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputPppoeClientInput(ctx context.Context, obj interface{}) (model.PppoeClientInput, error) {
	var it model.PppoeClientInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "interface", "username", "password", "serviceName", "addDefaultRoute", "usePeerDNS", "mtu", "mru", "comment"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			directive0 := func(ctx context.Context) (interface{}, error) { return ec.unmarshalNString2string(ctx, v) }
			directive1 := func(ctx context.Context) (interface{}, error) {
				minLength, err := ec.unmarshalOInt2int(ctx, 1)
				if err != nil {
					return nil, err
				}
				maxLength, err := ec.unmarshalOInt2int(ctx, 100)
				if err != nil {
					return nil, err
				}
				pattern, err := ec.unmarshalOString2string(ctx, "^[a-zA-Z0-9_-]+$")
				if err != nil {
					return nil, err
				}
				if ec.directives.Validate == nil {
					return nil, errors.New("directive validate is not implemented")
				}
				return ec.directives.Validate(ctx, obj, directive0, nil, nil, minLength, maxLength, pattern, nil)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(string); ok {
				it.Name = data
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "interface":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("interface"))
			directive0 := func(ctx context.Context) (interface{}, error) { return ec.unmarshalNString2string(ctx, v) }
			directive1 := func(ctx context.Context) (interface{}, error) {
				minLength, err := ec.unmarshalOInt2int(ctx, 1)
				if err != nil {
					return nil, err
				}
				maxLength, err := ec.unmarshalOInt2int(ctx, 100)
				if err != nil {
					return nil, err
				}
				if ec.directives.Validate == nil {
					return nil, errors.New("directive validate is not implemented")
				}
				return ec.directives.Validate(ctx, obj, directive0, nil, nil, minLength, maxLength, nil, nil)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(string); ok {
				it.Interface = data
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "username":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("username"))
			directive0 := func(ctx context.Context) (interface{}, error) { return ec.unmarshalNString2string(ctx, v) }
			directive1 := func(ctx context.Context) (interface{}, error) {
				minLength, err := ec.unmarshalOInt2int(ctx, 1)
				if err != nil {
					return nil, err
				}
				maxLength, err := ec.unmarshalOInt2int(ctx, 128)
				if err != nil {
					return nil, err
				}
				if ec.directives.Validate == nil {
					return nil, errors.New("directive validate is not implemented")
				}
				return ec.directives.Validate(ctx, obj, directive0, nil, nil, minLength, maxLength, nil, nil)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(string); ok {
				it.Username = data
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "password":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("password"))
			directive0 := func(ctx context.Context) (interface{}, error) { return ec.unmarshalNString2string(ctx, v) }
			directive1 := func(ctx context.Context) (interface{}, error) {
				minLength, err := ec.unmarshalOInt2int(ctx, 1)
				if err != nil {
					return nil, err
				}
				maxLength, err := ec.unmarshalOInt2int(ctx, 128)
				if err != nil {
					return nil, err
				}
				if ec.directives.Validate == nil {
					return nil, errors.New("directive validate is not implemented")
				}
				return ec.directives.Validate(ctx, obj, directive0, nil, nil, minLength, maxLength, nil, nil)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(string); ok {
				it.Password = data
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "serviceName":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("serviceName"))
			directive0 := func(ctx context.Context) (interface{}, error) { return ec.unmarshalOString2string(ctx, v) }
			directive1 := func(ctx context.Context) (interface{}, error) {
				maxLength, err := ec.unmarshalOInt2int(ctx, 100)
				if err != nil {
					return nil, err
				}
				if ec.directives.Validate == nil {
					return nil, errors.New("directive validate is not implemented")
				}
				return ec.directives.Validate(ctx, obj, directive0, nil, nil, nil, maxLength, nil, nil)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*string); ok {
				it.ServiceName = graphql.OmittableOf(data)
			} else if tmp == nil {
				it.ServiceName = graphql.OmittableOf[*string](nil)
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "addDefaultRoute":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("addDefaultRoute"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.AddDefaultRoute = graphql.OmittableOf(data)
		case "usePeerDNS":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("usePeerDNS"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.UsePeerDNS = graphql.OmittableOf(data)
		case "mtu":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("mtu"))
			directive0 := func(ctx context.Context) (interface{}, error) { return ec.unmarshalOInt2int(ctx, v) }
			directive1 := func(ctx context.Context) (interface{}, error) {
				min, err := ec.unmarshalOInt2int(ctx, 576)
				if err != nil {
					return nil, err
				}
				max, err := ec.unmarshalOInt2int(ctx, 1500)
				if err != nil {
					return nil, err
				}
				if ec.directives.Validate == nil {
					return nil, errors.New("directive validate is not implemented")
				}
				return ec.directives.Validate(ctx, obj, directive0, min, max, nil, nil, nil, nil)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*int); ok {
				it.Mtu = graphql.OmittableOf(data)
			} else if tmp == nil {
				it.Mtu = graphql.OmittableOf[*int](nil)
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *int`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "mru":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("mru"))
			directive0 := func(ctx context.Context) (interface{}, error) { return ec.unmarshalOInt2int(ctx, v) }
			directive1 := func(ctx context.Context) (interface{}, error) {
				min, err := ec.unmarshalOInt2int(ctx, 576)
				if err != nil {
					return nil, err
				}
				max, err := ec.unmarshalOInt2int(ctx, 1500)
				if err != nil {
					return nil, err
				}
				if ec.directives.Validate == nil {
					return nil, errors.New("directive validate is not implemented")
				}
				return ec.directives.Validate(ctx, obj, directive0, min, max, nil, nil, nil, nil)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*int); ok {
				it.Mru = graphql.OmittableOf(data)
			} else if tmp == nil {
				it.Mru = graphql.OmittableOf[*int](nil)
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *int`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "comment":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("comment"))
			directive0 := func(ctx context.Context) (interface{}, error) { return ec.unmarshalOString2string(ctx, v) }
			directive1 := func(ctx context.Context) (interface{}, error) {
				maxLength, err := ec.unmarshalOInt2int(ctx, 255)
				if err != nil {
					return nil, err
				}
				if ec.directives.Validate == nil {
					return nil, errors.New("directive validate is not implemented")
				}
				return ec.directives.Validate(ctx, obj, directive0, nil, nil, nil, maxLength, nil, nil)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*string); ok {
				it.Comment = graphql.OmittableOf(data)
			} else if tmp == nil {
				it.Comment = graphql.OmittableOf[*string](nil)
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputQuietHoursConfigInput(ctx context.Context, obj interface{}) (model.QuietHoursConfigInput, error) {
	var it model.QuietHoursConfigInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	if _, present := asMap["timezone"]; !present {
		asMap["timezone"] = "UTC"
	}
	if _, present := asMap["bypassCritical"]; !present {
		asMap["bypassCritical"] = true
	}

	fieldsInOrder := [...]string{"startTime", "endTime", "timezone", "bypassCritical"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "startTime":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("startTime"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.StartTime = data
		case "endTime":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("endTime"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.EndTime = data
		case "timezone":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("timezone"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Timezone = graphql.OmittableOf(data)
		case "bypassCritical":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("bypassCritical"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.BypassCritical = graphql.OmittableOf(data)
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputResourceRelationshipsInput(ctx context.Context, obj interface{}) (model.ResourceRelationshipsInput, error) {
	var it model.ResourceRelationshipsInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"dependsOn", "routesVia", "parent", "custom"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "dependsOn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("dependsOn"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DependsOn = graphql.OmittableOf(data)
		case "routesVia":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("routesVia"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.RoutesVia = graphql.OmittableOf(data)
		case "parent":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("parent"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Parent = graphql.OmittableOf(data)
		case "custom":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("custom"))
			data, err := ec.unmarshalOJSON2map(ctx, v)
			if err != nil {
				return it, err
			}
			it.Custom = graphql.OmittableOf(data)
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputRouteInput(ctx context.Context, obj interface{}) (model.RouteInput, error) {
	var it model.RouteInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"destination", "gateway", "interface", "distance", "routingMark", "routingTable", "comment"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "destination":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("destination"))
			data, err := ec.unmarshalNCIDR2backendgraphmodelCIDR(ctx, v)
			if err != nil {
				return it, err
			}
			it.Destination = data
		case "gateway":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("gateway"))
			data, err := ec.unmarshalOIPv42backendgraphmodelIPv4(ctx, v)
			if err != nil {
				return it, err
			}
			it.Gateway = graphql.OmittableOf(data)
		case "interface":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("interface"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Interface = graphql.OmittableOf(data)
		case "distance":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("distance"))
			directive0 := func(ctx context.Context) (interface{}, error) { return ec.unmarshalOInt2int(ctx, v) }
			directive1 := func(ctx context.Context) (interface{}, error) {
				min, err := ec.unmarshalOInt2int(ctx, 1)
				if err != nil {
					return nil, err
				}
				max, err := ec.unmarshalOInt2int(ctx, 255)
				if err != nil {
					return nil, err
				}
				if ec.directives.Validate == nil {
					return nil, errors.New("directive validate is not implemented")
				}
				return ec.directives.Validate(ctx, obj, directive0, min, max, nil, nil, nil, nil)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*int); ok {
				it.Distance = graphql.OmittableOf(data)
			} else if tmp == nil {
				it.Distance = graphql.OmittableOf[*int](nil)
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *int`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "routingMark":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("routingMark"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.RoutingMark = graphql.OmittableOf(data)
		case "routingTable":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("routingTable"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.RoutingTable = graphql.OmittableOf(data)
		case "comment":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("comment"))
			directive0 := func(ctx context.Context) (interface{}, error) { return ec.unmarshalOString2string(ctx, v) }
			directive1 := func(ctx context.Context) (interface{}, error) {
				maxLength, err := ec.unmarshalOInt2int(ctx, 255)
				if err != nil {
					return nil, err
				}
				if ec.directives.Validate == nil {
					return nil, errors.New("directive validate is not implemented")
				}
				return ec.directives.Validate(ctx, obj, directive0, nil, nil, nil, maxLength, nil, nil)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*string); ok {
				it.Comment = graphql.OmittableOf(data)
			} else if tmp == nil {
				it.Comment = graphql.OmittableOf[*string](nil)
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputScanNetworkInput(ctx context.Context, obj interface{}) (model.ScanNetworkInput, error) {
	var it model.ScanNetworkInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"subnet"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "subnet":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("subnet"))
			directive0 := func(ctx context.Context) (interface{}, error) { return ec.unmarshalNString2string(ctx, v) }
			directive1 := func(ctx context.Context) (interface{}, error) {
				minLength, err := ec.unmarshalOInt2int(ctx, 7)
				if err != nil {
					return nil, err
				}
				maxLength, err := ec.unmarshalOInt2int(ctx, 43)
				if err != nil {
					return nil, err
				}
				if ec.directives.Validate == nil {
					return nil, errors.New("directive validate is not implemented")
				}
				return ec.directives.Validate(ctx, obj, directive0, nil, nil, minLength, maxLength, nil, nil)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(string); ok {
				it.Subnet = data
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputStaticIPInput(ctx context.Context, obj interface{}) (model.StaticIPInput, error) {
	var it model.StaticIPInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"interface", "address", "gateway", "primaryDNS", "secondaryDNS", "comment"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "interface":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("interface"))
			directive0 := func(ctx context.Context) (interface{}, error) { return ec.unmarshalNString2string(ctx, v) }
			directive1 := func(ctx context.Context) (interface{}, error) {
				minLength, err := ec.unmarshalOInt2int(ctx, 1)
				if err != nil {
					return nil, err
				}
				maxLength, err := ec.unmarshalOInt2int(ctx, 100)
				if err != nil {
					return nil, err
				}
				if ec.directives.Validate == nil {
					return nil, errors.New("directive validate is not implemented")
				}
				return ec.directives.Validate(ctx, obj, directive0, nil, nil, minLength, maxLength, nil, nil)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(string); ok {
				it.Interface = data
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "address":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("address"))
			data, err := ec.unmarshalNCIDR2backendgraphmodelCIDR(ctx, v)
			if err != nil {
				return it, err
			}
			it.Address = data
		case "gateway":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("gateway"))
			data, err := ec.unmarshalNIPv42backendgraphmodelIPv4(ctx, v)
			if err != nil {
				return it, err
			}
			it.Gateway = data
		case "primaryDNS":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("primaryDNS"))
			data, err := ec.unmarshalOIPv42backendgraphmodelIPv4(ctx, v)
			if err != nil {
				return it, err
			}
			it.PrimaryDNS = graphql.OmittableOf(data)
		case "secondaryDNS":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("secondaryDNS"))
			data, err := ec.unmarshalOIPv42backendgraphmodelIPv4(ctx, v)
			if err != nil {
				return it, err
			}
			it.SecondaryDNS = graphql.OmittableOf(data)
		case "comment":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("comment"))
			directive0 := func(ctx context.Context) (interface{}, error) { return ec.unmarshalOString2string(ctx, v) }
			directive1 := func(ctx context.Context) (interface{}, error) {
				maxLength, err := ec.unmarshalOInt2int(ctx, 255)
				if err != nil {
					return nil, err
				}
				if ec.directives.Validate == nil {
					return nil, errors.New("directive validate is not implemented")
				}
				return ec.directives.Validate(ctx, obj, directive0, nil, nil, nil, maxLength, nil, nil)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*string); ok {
				it.Comment = graphql.OmittableOf(data)
			} else if tmp == nil {
				it.Comment = graphql.OmittableOf[*string](nil)
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputStatsTimeRangeInput(ctx context.Context, obj interface{}) (model.StatsTimeRangeInput, error) {
	var it model.StatsTimeRangeInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"start", "end"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "start":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("start"))
			data, err := ec.unmarshalNDateTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.Start = data
		case "end":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("end"))
			data, err := ec.unmarshalNDateTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.End = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputThrottleConfigInput(ctx context.Context, obj interface{}) (model.ThrottleConfigInput, error) {
	var it model.ThrottleConfigInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"maxAlerts", "periodSeconds", "groupByField"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "maxAlerts":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("maxAlerts"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.MaxAlerts = data
		case "periodSeconds":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("periodSeconds"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.PeriodSeconds = data
		case "groupByField":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("groupByField"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.GroupByField = graphql.OmittableOf(data)
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputTracerouteInput(ctx context.Context, obj interface{}) (model.TracerouteInput, error) {
	var it model.TracerouteInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	if _, present := asMap["maxHops"]; !present {
		asMap["maxHops"] = 30
	}
	if _, present := asMap["timeout"]; !present {
		asMap["timeout"] = 3000
	}
	if _, present := asMap["probeCount"]; !present {
		asMap["probeCount"] = 3
	}
	if _, present := asMap["protocol"]; !present {
		asMap["protocol"] = "ICMP"
	}

	fieldsInOrder := [...]string{"target", "maxHops", "timeout", "probeCount", "protocol"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "target":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("target"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Target = data
		case "maxHops":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("maxHops"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.MaxHops = graphql.OmittableOf(data)
		case "timeout":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("timeout"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Timeout = graphql.OmittableOf(data)
		case "probeCount":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("probeCount"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.ProbeCount = graphql.OmittableOf(data)
		case "protocol":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("protocol"))
			data, err := ec.unmarshalOTracerouteProtocol2backendgraphmodelTracerouteProtocol(ctx, v)
			if err != nil {
				return it, err
			}
			it.Protocol = graphql.OmittableOf(data)
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateAlertRuleInput(ctx context.Context, obj interface{}) (model.UpdateAlertRuleInput, error) {
	var it model.UpdateAlertRuleInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "description", "eventType", "conditions", "severity", "channels", "throttle", "quietHours", "deviceId", "enabled"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = graphql.OmittableOf(data)
		case "description":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = graphql.OmittableOf(data)
		case "eventType":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("eventType"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.EventType = graphql.OmittableOf(data)
		case "conditions":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("conditions"))
			data, err := ec.unmarshalOAlertConditionInput2backendgraphmodelAlertConditionInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Conditions = graphql.OmittableOf(data)
		case "severity":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("severity"))
			data, err := ec.unmarshalOAlertSeverity2backendgraphmodelAlertSeverity(ctx, v)
			if err != nil {
				return it, err
			}
			it.Severity = graphql.OmittableOf(data)
		case "channels":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("channels"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Channels = graphql.OmittableOf(data)
		case "throttle":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("throttle"))
			data, err := ec.unmarshalOThrottleConfigInput2backendgraphmodelThrottleConfigInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Throttle = graphql.OmittableOf(data)
		case "quietHours":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("quietHours"))
			data, err := ec.unmarshalOQuietHoursConfigInput2backendgraphmodelQuietHoursConfigInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.QuietHours = graphql.OmittableOf(data)
		case "deviceId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deviceId"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeviceID = graphql.OmittableOf(data)
		case "enabled":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("enabled"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Enabled = graphql.OmittableOf(data)
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateBridgeInput(ctx context.Context, obj interface{}) (model.UpdateBridgeInput, error) {
	var it model.UpdateBridgeInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"comment", "protocol", "priority", "vlanFiltering", "pvid", "mtu", "disabled"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "comment":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("comment"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Comment = graphql.OmittableOf(data)
		case "protocol":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("protocol"))
			data, err := ec.unmarshalOStpProtocol2backendgraphmodelStpProtocol(ctx, v)
			if err != nil {
				return it, err
			}
			it.Protocol = graphql.OmittableOf(data)
		case "priority":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("priority"))
			directive0 := func(ctx context.Context) (interface{}, error) { return ec.unmarshalOInt2int(ctx, v) }
			directive1 := func(ctx context.Context) (interface{}, error) {
				min, err := ec.unmarshalOInt2int(ctx, 0)
				if err != nil {
					return nil, err
				}
				max, err := ec.unmarshalOInt2int(ctx, 61440)
				if err != nil {
					return nil, err
				}
				if ec.directives.Validate == nil {
					return nil, errors.New("directive validate is not implemented")
				}
				return ec.directives.Validate(ctx, obj, directive0, min, max, nil, nil, nil, nil)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*int); ok {
				it.Priority = graphql.OmittableOf(data)
			} else if tmp == nil {
				it.Priority = graphql.OmittableOf[*int](nil)
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *int`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "vlanFiltering":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("vlanFiltering"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.VlanFiltering = graphql.OmittableOf(data)
		case "pvid":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pvid"))
			directive0 := func(ctx context.Context) (interface{}, error) { return ec.unmarshalOInt2int(ctx, v) }
			directive1 := func(ctx context.Context) (interface{}, error) {
				min, err := ec.unmarshalOInt2int(ctx, 1)
				if err != nil {
					return nil, err
				}
				max, err := ec.unmarshalOInt2int(ctx, 4094)
				if err != nil {
					return nil, err
				}
				if ec.directives.Validate == nil {
					return nil, errors.New("directive validate is not implemented")
				}
				return ec.directives.Validate(ctx, obj, directive0, min, max, nil, nil, nil, nil)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*int); ok {
				it.Pvid = graphql.OmittableOf(data)
			} else if tmp == nil {
				it.Pvid = graphql.OmittableOf[*int](nil)
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *int`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "mtu":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("mtu"))
			directive0 := func(ctx context.Context) (interface{}, error) { return ec.unmarshalOInt2int(ctx, v) }
			directive1 := func(ctx context.Context) (interface{}, error) {
				min, err := ec.unmarshalOInt2int(ctx, 68)
				if err != nil {
					return nil, err
				}
				max, err := ec.unmarshalOInt2int(ctx, 65535)
				if err != nil {
					return nil, err
				}
				if ec.directives.Validate == nil {
					return nil, errors.New("directive validate is not implemented")
				}
				return ec.directives.Validate(ctx, obj, directive0, min, max, nil, nil, nil, nil)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*int); ok {
				it.Mtu = graphql.OmittableOf(data)
			} else if tmp == nil {
				it.Mtu = graphql.OmittableOf[*int](nil)
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *int`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "disabled":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("disabled"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Disabled = graphql.OmittableOf(data)
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateBridgePortInput(ctx context.Context, obj interface{}) (model.UpdateBridgePortInput, error) {
	var it model.UpdateBridgePortInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"pvid", "frameTypes", "ingressFiltering", "taggedVlans", "untaggedVlans", "edge", "pathCost"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "pvid":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pvid"))
			directive0 := func(ctx context.Context) (interface{}, error) { return ec.unmarshalOInt2int(ctx, v) }
			directive1 := func(ctx context.Context) (interface{}, error) {
				min, err := ec.unmarshalOInt2int(ctx, 1)
				if err != nil {
					return nil, err
				}
				max, err := ec.unmarshalOInt2int(ctx, 4094)
				if err != nil {
					return nil, err
				}
				if ec.directives.Validate == nil {
					return nil, errors.New("directive validate is not implemented")
				}
				return ec.directives.Validate(ctx, obj, directive0, min, max, nil, nil, nil, nil)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*int); ok {
				it.Pvid = graphql.OmittableOf(data)
			} else if tmp == nil {
				it.Pvid = graphql.OmittableOf[*int](nil)
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *int`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "frameTypes":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("frameTypes"))
			data, err := ec.unmarshalOFrameTypes2backendgraphmodelFrameTypes(ctx, v)
			if err != nil {
				return it, err
			}
			it.FrameTypes = graphql.OmittableOf(data)
		case "ingressFiltering":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ingressFiltering"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.IngressFiltering = graphql.OmittableOf(data)
		case "taggedVlans":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("taggedVlans"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.TaggedVlans = graphql.OmittableOf(data)
		case "untaggedVlans":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("untaggedVlans"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.UntaggedVlans = graphql.OmittableOf(data)
		case "edge":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("edge"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Edge = graphql.OmittableOf(data)
		case "pathCost":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pathCost"))
			directive0 := func(ctx context.Context) (interface{}, error) { return ec.unmarshalOInt2int(ctx, v) }
			directive1 := func(ctx context.Context) (interface{}, error) {
				min, err := ec.unmarshalOInt2int(ctx, 1)
				if err != nil {
					return nil, err
				}
				max, err := ec.unmarshalOInt2int(ctx, 65535)
				if err != nil {
					return nil, err
				}
				if ec.directives.Validate == nil {
					return nil, errors.New("directive validate is not implemented")
				}
				return ec.directives.Validate(ctx, obj, directive0, min, max, nil, nil, nil, nil)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*int); ok {
				it.PathCost = graphql.OmittableOf(data)
			} else if tmp == nil {
				it.PathCost = graphql.OmittableOf[*int](nil)
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *int`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateChangeSetItemInput(ctx context.Context, obj interface{}) (model.UpdateChangeSetItemInput, error) {
	var it model.UpdateChangeSetItemInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "description", "configuration", "dependencies"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = graphql.OmittableOf(data)
		case "description":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = graphql.OmittableOf(data)
		case "configuration":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("configuration"))
			data, err := ec.unmarshalOJSON2map(ctx, v)
			if err != nil {
				return it, err
			}
			it.Configuration = graphql.OmittableOf(data)
		case "dependencies":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("dependencies"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Dependencies = graphql.OmittableOf(data)
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateInterfaceInput(ctx context.Context, obj interface{}) (model.UpdateInterfaceInput, error) {
	var it model.UpdateInterfaceInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"enabled", "mtu", "comment"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "enabled":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("enabled"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Enabled = graphql.OmittableOf(data)
		case "mtu":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("mtu"))
			directive0 := func(ctx context.Context) (interface{}, error) { return ec.unmarshalOInt2int(ctx, v) }
			directive1 := func(ctx context.Context) (interface{}, error) {
				min, err := ec.unmarshalOInt2int(ctx, 68)
				if err != nil {
					return nil, err
				}
				max, err := ec.unmarshalOInt2int(ctx, 9000)
				if err != nil {
					return nil, err
				}
				if ec.directives.Validate == nil {
					return nil, errors.New("directive validate is not implemented")
				}
				return ec.directives.Validate(ctx, obj, directive0, min, max, nil, nil, nil, nil)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*int); ok {
				it.Mtu = graphql.OmittableOf(data)
			} else if tmp == nil {
				it.Mtu = graphql.OmittableOf[*int](nil)
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *int`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "comment":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("comment"))
			directive0 := func(ctx context.Context) (interface{}, error) { return ec.unmarshalOString2string(ctx, v) }
			directive1 := func(ctx context.Context) (interface{}, error) {
				maxLength, err := ec.unmarshalOInt2int(ctx, 255)
				if err != nil {
					return nil, err
				}
				if ec.directives.Validate == nil {
					return nil, errors.New("directive validate is not implemented")
				}
				return ec.directives.Validate(ctx, obj, directive0, nil, nil, nil, maxLength, nil, nil)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*string); ok {
				it.Comment = graphql.OmittableOf(data)
			} else if tmp == nil {
				it.Comment = graphql.OmittableOf[*string](nil)
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateResourceInput(ctx context.Context, obj interface{}) (model.UpdateResourceInput, error) {
	var it model.UpdateResourceInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"configuration", "relationships", "tags", "description"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "configuration":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("configuration"))
			data, err := ec.unmarshalOJSON2map(ctx, v)
			if err != nil {
				return it, err
			}
			it.Configuration = graphql.OmittableOf(data)
		case "relationships":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("relationships"))
			data, err := ec.unmarshalOResourceRelationshipsInput2backendgraphmodelResourceRelationshipsInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Relationships = graphql.OmittableOf(data)
		case "tags":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tags"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Tags = graphql.OmittableOf(data)
		case "description":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = graphql.OmittableOf(data)
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateRouterInput(ctx context.Context, obj interface{}) (model.UpdateRouterInput, error) {
	var it model.UpdateRouterInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "host", "port", "username", "password"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			directive0 := func(ctx context.Context) (interface{}, error) { return ec.unmarshalOString2string(ctx, v) }
			directive1 := func(ctx context.Context) (interface{}, error) {
				minLength, err := ec.unmarshalOInt2int(ctx, 1)
				if err != nil {
					return nil, err
				}
				maxLength, err := ec.unmarshalOInt2int(ctx, 64)
				if err != nil {
					return nil, err
				}
				if ec.directives.Validate == nil {
					return nil, errors.New("directive validate is not implemented")
				}
				return ec.directives.Validate(ctx, obj, directive0, nil, nil, minLength, maxLength, nil, nil)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*string); ok {
				it.Name = graphql.OmittableOf(data)
			} else if tmp == nil {
				it.Name = graphql.OmittableOf[*string](nil)
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "host":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("host"))
			directive0 := func(ctx context.Context) (interface{}, error) { return ec.unmarshalOString2string(ctx, v) }
			directive1 := func(ctx context.Context) (interface{}, error) {
				minLength, err := ec.unmarshalOInt2int(ctx, 1)
				if err != nil {
					return nil, err
				}
				maxLength, err := ec.unmarshalOInt2int(ctx, 255)
				if err != nil {
					return nil, err
				}
				if ec.directives.Validate == nil {
					return nil, errors.New("directive validate is not implemented")
				}
				return ec.directives.Validate(ctx, obj, directive0, nil, nil, minLength, maxLength, nil, nil)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*string); ok {
				it.Host = graphql.OmittableOf(data)
			} else if tmp == nil {
				it.Host = graphql.OmittableOf[*string](nil)
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "port":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("port"))
			directive0 := func(ctx context.Context) (interface{}, error) { return ec.unmarshalOInt2int(ctx, v) }
			directive1 := func(ctx context.Context) (interface{}, error) {
				min, err := ec.unmarshalOInt2int(ctx, 1)
				if err != nil {
					return nil, err
				}
				max, err := ec.unmarshalOInt2int(ctx, 65535)
				if err != nil {
					return nil, err
				}
				if ec.directives.Validate == nil {
					return nil, errors.New("directive validate is not implemented")
				}
				return ec.directives.Validate(ctx, obj, directive0, min, max, nil, nil, nil, nil)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*int); ok {
				it.Port = graphql.OmittableOf(data)
			} else if tmp == nil {
				it.Port = graphql.OmittableOf[*int](nil)
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *int`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "username":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("username"))
			directive0 := func(ctx context.Context) (interface{}, error) { return ec.unmarshalOString2string(ctx, v) }
			directive1 := func(ctx context.Context) (interface{}, error) {
				minLength, err := ec.unmarshalOInt2int(ctx, 1)
				if err != nil {
					return nil, err
				}
				maxLength, err := ec.unmarshalOInt2int(ctx, 64)
				if err != nil {
					return nil, err
				}
				if ec.directives.Validate == nil {
					return nil, errors.New("directive validate is not implemented")
				}
				return ec.directives.Validate(ctx, obj, directive0, nil, nil, minLength, maxLength, nil, nil)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*string); ok {
				it.Username = graphql.OmittableOf(data)
			} else if tmp == nil {
				it.Username = graphql.OmittableOf[*string](nil)
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "password":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("password"))
			directive0 := func(ctx context.Context) (interface{}, error) { return ec.unmarshalOString2string(ctx, v) }
			directive1 := func(ctx context.Context) (interface{}, error) {
				minLength, err := ec.unmarshalOInt2int(ctx, 1)
				if err != nil {
					return nil, err
				}
				maxLength, err := ec.unmarshalOInt2int(ctx, 128)
				if err != nil {
					return nil, err
				}
				if ec.directives.Validate == nil {
					return nil, errors.New("directive validate is not implemented")
				}
				return ec.directives.Validate(ctx, obj, directive0, nil, nil, minLength, maxLength, nil, nil)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*string); ok {
				it.Password = graphql.OmittableOf(data)
			} else if tmp == nil {
				it.Password = graphql.OmittableOf[*string](nil)
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputVlanFilter(ctx context.Context, obj interface{}) (model.VlanFilter, error) {
	var it model.VlanFilter
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"parentInterface", "vlanIdRange", "nameContains"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "parentInterface":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("parentInterface"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ParentInterface = graphql.OmittableOf(data)
		case "vlanIdRange":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("vlanIdRange"))
			data, err := ec.unmarshalOIntRange2backendgraphmodelIntRange(ctx, v)
			if err != nil {
				return it, err
			}
			it.VlanIDRange = graphql.OmittableOf(data)
		case "nameContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameContains"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameContains = graphql.OmittableOf(data)
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputVlanInput(ctx context.Context, obj interface{}) (model.VlanInput, error) {
	var it model.VlanInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "vlanId", "interface", "mtu", "comment"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			directive0 := func(ctx context.Context) (interface{}, error) { return ec.unmarshalNString2string(ctx, v) }
			directive1 := func(ctx context.Context) (interface{}, error) {
				minLength, err := ec.unmarshalOInt2int(ctx, 1)
				if err != nil {
					return nil, err
				}
				maxLength, err := ec.unmarshalOInt2int(ctx, 100)
				if err != nil {
					return nil, err
				}
				pattern, err := ec.unmarshalOString2string(ctx, "^[a-zA-Z0-9_-]+$")
				if err != nil {
					return nil, err
				}
				if ec.directives.Validate == nil {
					return nil, errors.New("directive validate is not implemented")
				}
				return ec.directives.Validate(ctx, obj, directive0, nil, nil, minLength, maxLength, pattern, nil)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(string); ok {
				it.Name = data
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "vlanId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("vlanId"))
			directive0 := func(ctx context.Context) (interface{}, error) { return ec.unmarshalNInt2int(ctx, v) }
			directive1 := func(ctx context.Context) (interface{}, error) {
				min, err := ec.unmarshalOInt2int(ctx, 1)
				if err != nil {
					return nil, err
				}
				max, err := ec.unmarshalOInt2int(ctx, 4094)
				if err != nil {
					return nil, err
				}
				if ec.directives.Validate == nil {
					return nil, errors.New("directive validate is not implemented")
				}
				return ec.directives.Validate(ctx, obj, directive0, min, max, nil, nil, nil, nil)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(int); ok {
				it.VlanID = data
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be int`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "interface":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("interface"))
			data, err := ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Interface = data
		case "mtu":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("mtu"))
			directive0 := func(ctx context.Context) (interface{}, error) { return ec.unmarshalOInt2int(ctx, v) }
			directive1 := func(ctx context.Context) (interface{}, error) {
				min, err := ec.unmarshalOInt2int(ctx, 68)
				if err != nil {
					return nil, err
				}
				max, err := ec.unmarshalOInt2int(ctx, 65535)
				if err != nil {
					return nil, err
				}
				if ec.directives.Validate == nil {
					return nil, errors.New("directive validate is not implemented")
				}
				return ec.directives.Validate(ctx, obj, directive0, min, max, nil, nil, nil, nil)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*int); ok {
				it.Mtu = graphql.OmittableOf(data)
			} else if tmp == nil {
				it.Mtu = graphql.OmittableOf[*int](nil)
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *int`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "comment":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("comment"))
			directive0 := func(ctx context.Context) (interface{}, error) { return ec.unmarshalOString2string(ctx, v) }
			directive1 := func(ctx context.Context) (interface{}, error) {
				maxLength, err := ec.unmarshalOInt2int(ctx, 255)
				if err != nil {
					return nil, err
				}
				if ec.directives.Validate == nil {
					return nil, errors.New("directive validate is not implemented")
				}
				return ec.directives.Validate(ctx, obj, directive0, nil, nil, nil, maxLength, nil, nil)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*string); ok {
				it.Comment = graphql.OmittableOf(data)
			} else if tmp == nil {
				it.Comment = graphql.OmittableOf[*string](nil)
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputWANHealthCheckInput(ctx context.Context, obj interface{}) (model.WANHealthCheckInput, error) {
	var it model.WANHealthCheckInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"target", "interval", "enabled"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "target":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("target"))
			directive0 := func(ctx context.Context) (interface{}, error) { return ec.unmarshalNString2string(ctx, v) }
			directive1 := func(ctx context.Context) (interface{}, error) {
				minLength, err := ec.unmarshalOInt2int(ctx, 1)
				if err != nil {
					return nil, err
				}
				maxLength, err := ec.unmarshalOInt2int(ctx, 255)
				if err != nil {
					return nil, err
				}
				if ec.directives.Validate == nil {
					return nil, errors.New("directive validate is not implemented")
				}
				return ec.directives.Validate(ctx, obj, directive0, nil, nil, minLength, maxLength, nil, nil)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(string); ok {
				it.Target = data
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "interval":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("interval"))
			directive0 := func(ctx context.Context) (interface{}, error) { return ec.unmarshalNInt2int(ctx, v) }
			directive1 := func(ctx context.Context) (interface{}, error) {
				min, err := ec.unmarshalOInt2int(ctx, 5)
				if err != nil {
					return nil, err
				}
				max, err := ec.unmarshalOInt2int(ctx, 300)
				if err != nil {
					return nil, err
				}
				if ec.directives.Validate == nil {
					return nil, errors.New("directive validate is not implemented")
				}
				return ec.directives.Validate(ctx, obj, directive0, min, max, nil, nil, nil, nil)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(int); ok {
				it.Interval = data
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be int`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "enabled":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("enabled"))
			data, err := ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Enabled = data
		}
	}

	return it, nil
}

// endregion **************************** input.gotpl *****************************

// region    ************************** interface.gotpl ***************************

func (ec *executionContext) _Connection(ctx context.Context, sel ast.SelectionSet, obj model.Connection) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case model.RouterConnection:
		return ec._RouterConnection(ctx, sel, &obj)
	case *model.RouterConnection:
		if obj == nil {
			return graphql.Null
		}
		return ec._RouterConnection(ctx, sel, obj)
	case model.InterfaceConnection:
		return ec._InterfaceConnection(ctx, sel, &obj)
	case *model.InterfaceConnection:
		if obj == nil {
			return graphql.Null
		}
		return ec._InterfaceConnection(ctx, sel, obj)
	case model.AlertConnection:
		return ec._AlertConnection(ctx, sel, &obj)
	case *model.AlertConnection:
		if obj == nil {
			return graphql.Null
		}
		return ec._AlertConnection(ctx, sel, obj)
	case model.ResourceConnection:
		return ec._ResourceConnection(ctx, sel, &obj)
	case *model.ResourceConnection:
		if obj == nil {
			return graphql.Null
		}
		return ec._ResourceConnection(ctx, sel, obj)
	case model.WANConnectionEventConnection:
		return ec._WANConnectionEventConnection(ctx, sel, &obj)
	case *model.WANConnectionEventConnection:
		if obj == nil {
			return graphql.Null
		}
		return ec._WANConnectionEventConnection(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _Edge(ctx context.Context, sel ast.SelectionSet, obj model.Edge) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case model.RouterEdge:
		return ec._RouterEdge(ctx, sel, &obj)
	case *model.RouterEdge:
		if obj == nil {
			return graphql.Null
		}
		return ec._RouterEdge(ctx, sel, obj)
	case model.InterfaceEdge:
		return ec._InterfaceEdge(ctx, sel, &obj)
	case *model.InterfaceEdge:
		if obj == nil {
			return graphql.Null
		}
		return ec._InterfaceEdge(ctx, sel, obj)
	case model.AlertEdge:
		return ec._AlertEdge(ctx, sel, &obj)
	case *model.AlertEdge:
		if obj == nil {
			return graphql.Null
		}
		return ec._AlertEdge(ctx, sel, obj)
	case model.ResourceEdge:
		return ec._ResourceEdge(ctx, sel, &obj)
	case *model.ResourceEdge:
		if obj == nil {
			return graphql.Null
		}
		return ec._ResourceEdge(ctx, sel, obj)
	case model.WANConnectionEventEdge:
		return ec._WANConnectionEventEdge(ctx, sel, &obj)
	case *model.WANConnectionEventEdge:
		if obj == nil {
			return graphql.Null
		}
		return ec._WANConnectionEventEdge(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _Node(ctx context.Context, sel ast.SelectionSet, obj model.Node) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case model.RouteResource:
		return ec._RouteResource(ctx, sel, &obj)
	case *model.RouteResource:
		if obj == nil {
			return graphql.Null
		}
		return ec._RouteResource(ctx, sel, obj)
	case model.DHCPServerResource:
		return ec._DHCPServerResource(ctx, sel, &obj)
	case *model.DHCPServerResource:
		if obj == nil {
			return graphql.Null
		}
		return ec._DHCPServerResource(ctx, sel, obj)
	case model.BridgeResource:
		return ec._BridgeResource(ctx, sel, &obj)
	case *model.BridgeResource:
		if obj == nil {
			return graphql.Null
		}
		return ec._BridgeResource(ctx, sel, obj)
	case model.FirewallRuleResource:
		return ec._FirewallRuleResource(ctx, sel, &obj)
	case *model.FirewallRuleResource:
		if obj == nil {
			return graphql.Null
		}
		return ec._FirewallRuleResource(ctx, sel, obj)
	case model.WANLink:
		return ec._WANLink(ctx, sel, &obj)
	case *model.WANLink:
		if obj == nil {
			return graphql.Null
		}
		return ec._WANLink(ctx, sel, obj)
	case model.WireGuardClient:
		return ec._WireGuardClient(ctx, sel, &obj)
	case *model.WireGuardClient:
		if obj == nil {
			return graphql.Null
		}
		return ec._WireGuardClient(ctx, sel, obj)
	case model.LANNetwork:
		return ec._LANNetwork(ctx, sel, &obj)
	case *model.LANNetwork:
		if obj == nil {
			return graphql.Null
		}
		return ec._LANNetwork(ctx, sel, obj)
	case model.FeatureResource:
		return ec._FeatureResource(ctx, sel, &obj)
	case *model.FeatureResource:
		if obj == nil {
			return graphql.Null
		}
		return ec._FeatureResource(ctx, sel, obj)
	case model.Bridge:
		return ec._Bridge(ctx, sel, &obj)
	case *model.Bridge:
		if obj == nil {
			return graphql.Null
		}
		return ec._Bridge(ctx, sel, obj)
	case model.WANInterface:
		return ec._WANInterface(ctx, sel, &obj)
	case *model.WANInterface:
		if obj == nil {
			return graphql.Null
		}
		return ec._WANInterface(ctx, sel, obj)
	case model.Interface:
		return ec._Interface(ctx, sel, &obj)
	case *model.Interface:
		if obj == nil {
			return graphql.Null
		}
		return ec._Interface(ctx, sel, obj)
	case model.Router:
		return ec._Router(ctx, sel, &obj)
	case *model.Router:
		if obj == nil {
			return graphql.Null
		}
		return ec._Router(ctx, sel, obj)
	case model.User:
		return ec._User(ctx, sel, &obj)
	case *model.User:
		if obj == nil {
			return graphql.Null
		}
		return ec._User(ctx, sel, obj)
	case model.Alert:
		return ec._Alert(ctx, sel, &obj)
	case *model.Alert:
		if obj == nil {
			return graphql.Null
		}
		return ec._Alert(ctx, sel, obj)
	case model.AlertRule:
		return ec._AlertRule(ctx, sel, &obj)
	case *model.AlertRule:
		if obj == nil {
			return graphql.Null
		}
		return ec._AlertRule(ctx, sel, obj)
	case model.IPAddress:
		return ec._IpAddress(ctx, sel, &obj)
	case *model.IPAddress:
		if obj == nil {
			return graphql.Null
		}
		return ec._IpAddress(ctx, sel, obj)
	case model.Vlan:
		return ec._Vlan(ctx, sel, &obj)
	case *model.Vlan:
		if obj == nil {
			return graphql.Null
		}
		return ec._Vlan(ctx, sel, obj)
	case model.BridgePort:
		return ec._BridgePort(ctx, sel, &obj)
	case *model.BridgePort:
		if obj == nil {
			return graphql.Null
		}
		return ec._BridgePort(ctx, sel, obj)
	case model.Route:
		return ec._Route(ctx, sel, &obj)
	case *model.Route:
		if obj == nil {
			return graphql.Null
		}
		return ec._Route(ctx, sel, obj)
	case model.DhcpClient:
		return ec._DhcpClient(ctx, sel, &obj)
	case *model.DhcpClient:
		if obj == nil {
			return graphql.Null
		}
		return ec._DhcpClient(ctx, sel, obj)
	case model.PppoeClient:
		return ec._PppoeClient(ctx, sel, &obj)
	case *model.PppoeClient:
		if obj == nil {
			return graphql.Null
		}
		return ec._PppoeClient(ctx, sel, obj)
	case model.StaticIPConfig:
		return ec._StaticIPConfig(ctx, sel, &obj)
	case *model.StaticIPConfig:
		if obj == nil {
			return graphql.Null
		}
		return ec._StaticIPConfig(ctx, sel, obj)
	case model.LteModem:
		return ec._LteModem(ctx, sel, &obj)
	case *model.LteModem:
		if obj == nil {
			return graphql.Null
		}
		return ec._LteModem(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _Resource(ctx context.Context, sel ast.SelectionSet, obj model.Resource) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case model.WireGuardClient:
		return ec._WireGuardClient(ctx, sel, &obj)
	case *model.WireGuardClient:
		if obj == nil {
			return graphql.Null
		}
		return ec._WireGuardClient(ctx, sel, obj)
	case model.LANNetwork:
		return ec._LANNetwork(ctx, sel, &obj)
	case *model.LANNetwork:
		if obj == nil {
			return graphql.Null
		}
		return ec._LANNetwork(ctx, sel, obj)
	case model.BridgeResource:
		return ec._BridgeResource(ctx, sel, &obj)
	case *model.BridgeResource:
		if obj == nil {
			return graphql.Null
		}
		return ec._BridgeResource(ctx, sel, obj)
	case model.DHCPServerResource:
		return ec._DHCPServerResource(ctx, sel, &obj)
	case *model.DHCPServerResource:
		if obj == nil {
			return graphql.Null
		}
		return ec._DHCPServerResource(ctx, sel, obj)
	case model.FirewallRuleResource:
		return ec._FirewallRuleResource(ctx, sel, &obj)
	case *model.FirewallRuleResource:
		if obj == nil {
			return graphql.Null
		}
		return ec._FirewallRuleResource(ctx, sel, obj)
	case model.RouteResource:
		return ec._RouteResource(ctx, sel, &obj)
	case *model.RouteResource:
		if obj == nil {
			return graphql.Null
		}
		return ec._RouteResource(ctx, sel, obj)
	case model.WANLink:
		return ec._WANLink(ctx, sel, &obj)
	case *model.WANLink:
		if obj == nil {
			return graphql.Null
		}
		return ec._WANLink(ctx, sel, obj)
	case model.FeatureResource:
		return ec._FeatureResource(ctx, sel, &obj)
	case *model.FeatureResource:
		if obj == nil {
			return graphql.Null
		}
		return ec._FeatureResource(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

// endregion ************************** interface.gotpl ***************************

// region    **************************** object.gotpl ****************************

var addChangeSetItemPayloadImplementors = []string{"AddChangeSetItemPayload"}

func (ec *executionContext) _AddChangeSetItemPayload(ctx context.Context, sel ast.SelectionSet, obj *model.AddChangeSetItemPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, addChangeSetItemPayloadImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AddChangeSetItemPayload")
		case "changeSet":
			out.Values[i] = ec._AddChangeSetItemPayload_changeSet(ctx, field, obj)
		case "itemId":
			out.Values[i] = ec._AddChangeSetItemPayload_itemId(ctx, field, obj)
		case "errors":
			out.Values[i] = ec._AddChangeSetItemPayload_errors(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var addRouterPayloadImplementors = []string{"AddRouterPayload"}

func (ec *executionContext) _AddRouterPayload(ctx context.Context, sel ast.SelectionSet, obj *model.AddRouterPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, addRouterPayloadImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AddRouterPayload")
		case "router":
			out.Values[i] = ec._AddRouterPayload_router(ctx, field, obj)
		case "connectionResult":
			out.Values[i] = ec._AddRouterPayload_connectionResult(ctx, field, obj)
		case "validationErrors":
			out.Values[i] = ec._AddRouterPayload_validationErrors(ctx, field, obj)
		case "errors":
			out.Values[i] = ec._AddRouterPayload_errors(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var affectedResourceImplementors = []string{"AffectedResource"}

func (ec *executionContext) _AffectedResource(ctx context.Context, sel ast.SelectionSet, obj *model.AffectedResource) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, affectedResourceImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AffectedResource")
		case "type":
			out.Values[i] = ec._AffectedResource_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "id":
			out.Values[i] = ec._AffectedResource_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec._AffectedResource_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "impact":
			out.Values[i] = ec._AffectedResource_impact(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var alertImplementors = []string{"Alert", "Node"}

func (ec *executionContext) _Alert(ctx context.Context, sel ast.SelectionSet, obj *model.Alert) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, alertImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Alert")
		case "id":
			out.Values[i] = ec._Alert_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "rule":
			out.Values[i] = ec._Alert_rule(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "eventType":
			out.Values[i] = ec._Alert_eventType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "severity":
			out.Values[i] = ec._Alert_severity(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "title":
			out.Values[i] = ec._Alert_title(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "message":
			out.Values[i] = ec._Alert_message(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "data":
			out.Values[i] = ec._Alert_data(ctx, field, obj)
		case "deviceId":
			out.Values[i] = ec._Alert_deviceId(ctx, field, obj)
		case "triggeredAt":
			out.Values[i] = ec._Alert_triggeredAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "acknowledgedAt":
			out.Values[i] = ec._Alert_acknowledgedAt(ctx, field, obj)
		case "acknowledgedBy":
			out.Values[i] = ec._Alert_acknowledgedBy(ctx, field, obj)
		case "deliveryStatus":
			out.Values[i] = ec._Alert_deliveryStatus(ctx, field, obj)
		case "updatedAt":
			out.Values[i] = ec._Alert_updatedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var alertConditionImplementors = []string{"AlertCondition"}

func (ec *executionContext) _AlertCondition(ctx context.Context, sel ast.SelectionSet, obj *model.AlertCondition) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, alertConditionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AlertCondition")
		case "field":
			out.Values[i] = ec._AlertCondition_field(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "operator":
			out.Values[i] = ec._AlertCondition_operator(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "value":
			out.Values[i] = ec._AlertCondition_value(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var alertConnectionImplementors = []string{"AlertConnection", "Connection"}

func (ec *executionContext) _AlertConnection(ctx context.Context, sel ast.SelectionSet, obj *model.AlertConnection) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, alertConnectionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AlertConnection")
		case "edges":
			out.Values[i] = ec._AlertConnection_edges(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "pageInfo":
			out.Values[i] = ec._AlertConnection_pageInfo(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "totalCount":
			out.Values[i] = ec._AlertConnection_totalCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var alertEdgeImplementors = []string{"AlertEdge", "Edge"}

func (ec *executionContext) _AlertEdge(ctx context.Context, sel ast.SelectionSet, obj *model.AlertEdge) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, alertEdgeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AlertEdge")
		case "node":
			out.Values[i] = ec._AlertEdge_node(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "cursor":
			out.Values[i] = ec._AlertEdge_cursor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var alertEventImplementors = []string{"AlertEvent"}

func (ec *executionContext) _AlertEvent(ctx context.Context, sel ast.SelectionSet, obj *model.AlertEvent) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, alertEventImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AlertEvent")
		case "alert":
			out.Values[i] = ec._AlertEvent_alert(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "action":
			out.Values[i] = ec._AlertEvent_action(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var alertPayloadImplementors = []string{"AlertPayload"}

func (ec *executionContext) _AlertPayload(ctx context.Context, sel ast.SelectionSet, obj *model.AlertPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, alertPayloadImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AlertPayload")
		case "alert":
			out.Values[i] = ec._AlertPayload_alert(ctx, field, obj)
		case "errors":
			out.Values[i] = ec._AlertPayload_errors(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var alertRuleImplementors = []string{"AlertRule", "Node"}

func (ec *executionContext) _AlertRule(ctx context.Context, sel ast.SelectionSet, obj *model.AlertRule) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, alertRuleImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AlertRule")
		case "id":
			out.Values[i] = ec._AlertRule_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec._AlertRule_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec._AlertRule_description(ctx, field, obj)
		case "eventType":
			out.Values[i] = ec._AlertRule_eventType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "conditions":
			out.Values[i] = ec._AlertRule_conditions(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "severity":
			out.Values[i] = ec._AlertRule_severity(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "channels":
			out.Values[i] = ec._AlertRule_channels(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "throttle":
			out.Values[i] = ec._AlertRule_throttle(ctx, field, obj)
		case "quietHours":
			out.Values[i] = ec._AlertRule_quietHours(ctx, field, obj)
		case "deviceId":
			out.Values[i] = ec._AlertRule_deviceId(ctx, field, obj)
		case "enabled":
			out.Values[i] = ec._AlertRule_enabled(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createdAt":
			out.Values[i] = ec._AlertRule_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updatedAt":
			out.Values[i] = ec._AlertRule_updatedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "alerts":
			out.Values[i] = ec._AlertRule_alerts(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var alertRulePayloadImplementors = []string{"AlertRulePayload"}

func (ec *executionContext) _AlertRulePayload(ctx context.Context, sel ast.SelectionSet, obj *model.AlertRulePayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, alertRulePayloadImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AlertRulePayload")
		case "alertRule":
			out.Values[i] = ec._AlertRulePayload_alertRule(ctx, field, obj)
		case "errors":
			out.Values[i] = ec._AlertRulePayload_errors(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var applyChangeSetPayloadImplementors = []string{"ApplyChangeSetPayload"}

func (ec *executionContext) _ApplyChangeSetPayload(ctx context.Context, sel ast.SelectionSet, obj *model.ApplyChangeSetPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, applyChangeSetPayloadImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ApplyChangeSetPayload")
		case "changeSetId":
			out.Values[i] = ec._ApplyChangeSetPayload_changeSetId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "status":
			out.Values[i] = ec._ApplyChangeSetPayload_status(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "errors":
			out.Values[i] = ec._ApplyChangeSetPayload_errors(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var applyFixPayloadImplementors = []string{"ApplyFixPayload"}

func (ec *executionContext) _ApplyFixPayload(ctx context.Context, sel ast.SelectionSet, obj *model.ApplyFixPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, applyFixPayloadImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ApplyFixPayload")
		case "success":
			out.Values[i] = ec._ApplyFixPayload_success(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "message":
			out.Values[i] = ec._ApplyFixPayload_message(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "status":
			out.Values[i] = ec._ApplyFixPayload_status(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "errors":
			out.Values[i] = ec._ApplyFixPayload_errors(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var applyResourcePayloadImplementors = []string{"ApplyResourcePayload"}

func (ec *executionContext) _ApplyResourcePayload(ctx context.Context, sel ast.SelectionSet, obj *model.ApplyResourcePayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, applyResourcePayloadImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ApplyResourcePayload")
		case "resource":
			out.Values[i] = ec._ApplyResourcePayload_resource(ctx, field, obj)
		case "operationId":
			out.Values[i] = ec._ApplyResourcePayload_operationId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "errors":
			out.Values[i] = ec._ApplyResourcePayload_errors(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var archiveResourcePayloadImplementors = []string{"ArchiveResourcePayload"}

func (ec *executionContext) _ArchiveResourcePayload(ctx context.Context, sel ast.SelectionSet, obj *model.ArchiveResourcePayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, archiveResourcePayloadImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ArchiveResourcePayload")
		case "success":
			out.Values[i] = ec._ArchiveResourcePayload_success(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "errors":
			out.Values[i] = ec._ArchiveResourcePayload_errors(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var authPayloadImplementors = []string{"AuthPayload"}

func (ec *executionContext) _AuthPayload(ctx context.Context, sel ast.SelectionSet, obj *model.AuthPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, authPayloadImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AuthPayload")
		case "token":
			out.Values[i] = ec._AuthPayload_token(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "user":
			out.Values[i] = ec._AuthPayload_user(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "expiresAt":
			out.Values[i] = ec._AuthPayload_expiresAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var authStatusImplementors = []string{"AuthStatus"}

func (ec *executionContext) _AuthStatus(ctx context.Context, sel ast.SelectionSet, obj *model.AuthStatus) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, authStatusImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AuthStatus")
		case "tested":
			out.Values[i] = ec._AuthStatus_tested(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "success":
			out.Values[i] = ec._AuthStatus_success(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "error":
			out.Values[i] = ec._AuthStatus_error(ctx, field, obj)
		case "errorCode":
			out.Values[i] = ec._AuthStatus_errorCode(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var bandwidthDataPointImplementors = []string{"BandwidthDataPoint"}

func (ec *executionContext) _BandwidthDataPoint(ctx context.Context, sel ast.SelectionSet, obj *model.BandwidthDataPoint) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, bandwidthDataPointImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("BandwidthDataPoint")
		case "timestamp":
			out.Values[i] = ec._BandwidthDataPoint_timestamp(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "bytesIn":
			out.Values[i] = ec._BandwidthDataPoint_bytesIn(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "bytesOut":
			out.Values[i] = ec._BandwidthDataPoint_bytesOut(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "periodSeconds":
			out.Values[i] = ec._BandwidthDataPoint_periodSeconds(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var batchInterfacePayloadImplementors = []string{"BatchInterfacePayload"}

func (ec *executionContext) _BatchInterfacePayload(ctx context.Context, sel ast.SelectionSet, obj *model.BatchInterfacePayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, batchInterfacePayloadImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("BatchInterfacePayload")
		case "succeeded":
			out.Values[i] = ec._BatchInterfacePayload_succeeded(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "failed":
			out.Values[i] = ec._BatchInterfacePayload_failed(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "errors":
			out.Values[i] = ec._BatchInterfacePayload_errors(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var bridgeImplementors = []string{"Bridge", "Node"}

func (ec *executionContext) _Bridge(ctx context.Context, sel ast.SelectionSet, obj *model.Bridge) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, bridgeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Bridge")
		case "id":
			out.Values[i] = ec._Bridge_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec._Bridge_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "comment":
			out.Values[i] = ec._Bridge_comment(ctx, field, obj)
		case "disabled":
			out.Values[i] = ec._Bridge_disabled(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "running":
			out.Values[i] = ec._Bridge_running(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "macAddress":
			out.Values[i] = ec._Bridge_macAddress(ctx, field, obj)
		case "mtu":
			out.Values[i] = ec._Bridge_mtu(ctx, field, obj)
		case "protocol":
			out.Values[i] = ec._Bridge_protocol(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "priority":
			out.Values[i] = ec._Bridge_priority(ctx, field, obj)
		case "vlanFiltering":
			out.Values[i] = ec._Bridge_vlanFiltering(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "pvid":
			out.Values[i] = ec._Bridge_pvid(ctx, field, obj)
		case "ports":
			out.Values[i] = ec._Bridge_ports(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "vlans":
			out.Values[i] = ec._Bridge_vlans(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "ipAddresses":
			out.Values[i] = ec._Bridge_ipAddresses(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "stpStatus":
			out.Values[i] = ec._Bridge_stpStatus(ctx, field, obj)
		case "dependentDhcpServers":
			out.Values[i] = ec._Bridge_dependentDhcpServers(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "dependentRoutes":
			out.Values[i] = ec._Bridge_dependentRoutes(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var bridgeMutationResultImplementors = []string{"BridgeMutationResult"}

func (ec *executionContext) _BridgeMutationResult(ctx context.Context, sel ast.SelectionSet, obj *model.BridgeMutationResult) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, bridgeMutationResultImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("BridgeMutationResult")
		case "success":
			out.Values[i] = ec._BridgeMutationResult_success(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "bridge":
			out.Values[i] = ec._BridgeMutationResult_bridge(ctx, field, obj)
		case "errors":
			out.Values[i] = ec._BridgeMutationResult_errors(ctx, field, obj)
		case "previousState":
			out.Values[i] = ec._BridgeMutationResult_previousState(ctx, field, obj)
		case "operationId":
			out.Values[i] = ec._BridgeMutationResult_operationId(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var bridgePortImplementors = []string{"BridgePort", "Node"}

func (ec *executionContext) _BridgePort(ctx context.Context, sel ast.SelectionSet, obj *model.BridgePort) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, bridgePortImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("BridgePort")
		case "id":
			out.Values[i] = ec._BridgePort_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "bridge":
			out.Values[i] = ec._BridgePort_bridge(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "interface":
			out.Values[i] = ec._BridgePort_interface(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "pvid":
			out.Values[i] = ec._BridgePort_pvid(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "frameTypes":
			out.Values[i] = ec._BridgePort_frameTypes(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "ingressFiltering":
			out.Values[i] = ec._BridgePort_ingressFiltering(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "taggedVlans":
			out.Values[i] = ec._BridgePort_taggedVlans(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "untaggedVlans":
			out.Values[i] = ec._BridgePort_untaggedVlans(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "role":
			out.Values[i] = ec._BridgePort_role(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "state":
			out.Values[i] = ec._BridgePort_state(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "pathCost":
			out.Values[i] = ec._BridgePort_pathCost(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "edge":
			out.Values[i] = ec._BridgePort_edge(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var bridgePortMutationResultImplementors = []string{"BridgePortMutationResult"}

func (ec *executionContext) _BridgePortMutationResult(ctx context.Context, sel ast.SelectionSet, obj *model.BridgePortMutationResult) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, bridgePortMutationResultImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("BridgePortMutationResult")
		case "success":
			out.Values[i] = ec._BridgePortMutationResult_success(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "port":
			out.Values[i] = ec._BridgePortMutationResult_port(ctx, field, obj)
		case "errors":
			out.Values[i] = ec._BridgePortMutationResult_errors(ctx, field, obj)
		case "previousState":
			out.Values[i] = ec._BridgePortMutationResult_previousState(ctx, field, obj)
		case "operationId":
			out.Values[i] = ec._BridgePortMutationResult_operationId(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var bridgePortVlanConfigImplementors = []string{"BridgePortVlanConfig"}

func (ec *executionContext) _BridgePortVlanConfig(ctx context.Context, sel ast.SelectionSet, obj *model.BridgePortVlanConfig) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, bridgePortVlanConfigImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("BridgePortVlanConfig")
		case "portId":
			out.Values[i] = ec._BridgePortVlanConfig_portId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "pvid":
			out.Values[i] = ec._BridgePortVlanConfig_pvid(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "frameTypes":
			out.Values[i] = ec._BridgePortVlanConfig_frameTypes(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "taggedVlans":
			out.Values[i] = ec._BridgePortVlanConfig_taggedVlans(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "untaggedVlans":
			out.Values[i] = ec._BridgePortVlanConfig_untaggedVlans(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "mode":
			out.Values[i] = ec._BridgePortVlanConfig_mode(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var bridgeResourceImplementors = []string{"BridgeResource", "Resource", "Node"}

func (ec *executionContext) _BridgeResource(ctx context.Context, sel ast.SelectionSet, obj *model.BridgeResource) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, bridgeResourceImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("BridgeResource")
		case "id":
			out.Values[i] = ec._BridgeResource_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "scopedId":
			out.Values[i] = ec._BridgeResource_scopedId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "type":
			out.Values[i] = ec._BridgeResource_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "category":
			out.Values[i] = ec._BridgeResource_category(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "configuration":
			out.Values[i] = ec._BridgeResource_configuration(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "validation":
			out.Values[i] = ec._BridgeResource_validation(ctx, field, obj)
		case "deployment":
			out.Values[i] = ec._BridgeResource_deployment(ctx, field, obj)
		case "runtime":
			out.Values[i] = ec._BridgeResource_runtime(ctx, field, obj)
		case "telemetry":
			out.Values[i] = ec._BridgeResource_telemetry(ctx, field, obj)
		case "metadata":
			out.Values[i] = ec._BridgeResource_metadata(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "relationships":
			out.Values[i] = ec._BridgeResource_relationships(ctx, field, obj)
		case "platform":
			out.Values[i] = ec._BridgeResource_platform(ctx, field, obj)
		case "name":
			out.Values[i] = ec._BridgeResource_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "ports":
			out.Values[i] = ec._BridgeResource_ports(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "protocolMode":
			out.Values[i] = ec._BridgeResource_protocolMode(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var bridgeStpStatusImplementors = []string{"BridgeStpStatus"}

func (ec *executionContext) _BridgeStpStatus(ctx context.Context, sel ast.SelectionSet, obj *model.BridgeStpStatus) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, bridgeStpStatusImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("BridgeStpStatus")
		case "rootBridge":
			out.Values[i] = ec._BridgeStpStatus_rootBridge(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "rootBridgeId":
			out.Values[i] = ec._BridgeStpStatus_rootBridgeId(ctx, field, obj)
		case "rootPort":
			out.Values[i] = ec._BridgeStpStatus_rootPort(ctx, field, obj)
		case "rootPathCost":
			out.Values[i] = ec._BridgeStpStatus_rootPathCost(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "topologyChangeCount":
			out.Values[i] = ec._BridgeStpStatus_topologyChangeCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "lastTopologyChange":
			out.Values[i] = ec._BridgeStpStatus_lastTopologyChange(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var bridgeVlanImplementors = []string{"BridgeVlan"}

func (ec *executionContext) _BridgeVlan(ctx context.Context, sel ast.SelectionSet, obj *model.BridgeVlan) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, bridgeVlanImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("BridgeVlan")
		case "uuid":
			out.Values[i] = ec._BridgeVlan_uuid(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "bridge":
			out.Values[i] = ec._BridgeVlan_bridge(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "vlanId":
			out.Values[i] = ec._BridgeVlan_vlanId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "taggedPorts":
			out.Values[i] = ec._BridgeVlan_taggedPorts(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "untaggedPorts":
			out.Values[i] = ec._BridgeVlan_untaggedPorts(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var bridgeVlanMutationResultImplementors = []string{"BridgeVlanMutationResult"}

func (ec *executionContext) _BridgeVlanMutationResult(ctx context.Context, sel ast.SelectionSet, obj *model.BridgeVlanMutationResult) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, bridgeVlanMutationResultImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("BridgeVlanMutationResult")
		case "success":
			out.Values[i] = ec._BridgeVlanMutationResult_success(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "vlan":
			out.Values[i] = ec._BridgeVlanMutationResult_vlan(ctx, field, obj)
		case "errors":
			out.Values[i] = ec._BridgeVlanMutationResult_errors(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var bulkAlertPayloadImplementors = []string{"BulkAlertPayload"}

func (ec *executionContext) _BulkAlertPayload(ctx context.Context, sel ast.SelectionSet, obj *model.BulkAlertPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, bulkAlertPayloadImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("BulkAlertPayload")
		case "acknowledgedCount":
			out.Values[i] = ec._BulkAlertPayload_acknowledgedCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "errors":
			out.Values[i] = ec._BulkAlertPayload_errors(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var cPUMetricsImplementors = []string{"CPUMetrics"}

func (ec *executionContext) _CPUMetrics(ctx context.Context, sel ast.SelectionSet, obj *model.CPUMetrics) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, cPUMetricsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CPUMetrics")
		case "usage":
			out.Values[i] = ec._CPUMetrics_usage(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "cores":
			out.Values[i] = ec._CPUMetrics_cores(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "perCore":
			out.Values[i] = ec._CPUMetrics_perCore(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "frequency":
			out.Values[i] = ec._CPUMetrics_frequency(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var cancelChangeSetPayloadImplementors = []string{"CancelChangeSetPayload"}

func (ec *executionContext) _CancelChangeSetPayload(ctx context.Context, sel ast.SelectionSet, obj *model.CancelChangeSetPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, cancelChangeSetPayloadImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CancelChangeSetPayload")
		case "changeSet":
			out.Values[i] = ec._CancelChangeSetPayload_changeSet(ctx, field, obj)
		case "success":
			out.Values[i] = ec._CancelChangeSetPayload_success(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "errors":
			out.Values[i] = ec._CancelChangeSetPayload_errors(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var cancelScanPayloadImplementors = []string{"CancelScanPayload"}

func (ec *executionContext) _CancelScanPayload(ctx context.Context, sel ast.SelectionSet, obj *model.CancelScanPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, cancelScanPayloadImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CancelScanPayload")
		case "task":
			out.Values[i] = ec._CancelScanPayload_task(ctx, field, obj)
		case "errors":
			out.Values[i] = ec._CancelScanPayload_errors(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var capabilityEntryImplementors = []string{"CapabilityEntry"}

func (ec *executionContext) _CapabilityEntry(ctx context.Context, sel ast.SelectionSet, obj *model.CapabilityEntry) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, capabilityEntryImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CapabilityEntry")
		case "capability":
			out.Values[i] = ec._CapabilityEntry_capability(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "level":
			out.Values[i] = ec._CapabilityEntry_level(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec._CapabilityEntry_description(ctx, field, obj)
		case "guidance":
			out.Values[i] = ec._CapabilityEntry_guidance(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var changeLogEntryImplementors = []string{"ChangeLogEntry"}

func (ec *executionContext) _ChangeLogEntry(ctx context.Context, sel ast.SelectionSet, obj *model.ChangeLogEntry) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, changeLogEntryImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ChangeLogEntry")
		case "timestamp":
			out.Values[i] = ec._ChangeLogEntry_timestamp(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "user":
			out.Values[i] = ec._ChangeLogEntry_user(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "changeType":
			out.Values[i] = ec._ChangeLogEntry_changeType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "changedFields":
			out.Values[i] = ec._ChangeLogEntry_changedFields(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "summary":
			out.Values[i] = ec._ChangeLogEntry_summary(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var changeSetImplementors = []string{"ChangeSet"}

func (ec *executionContext) _ChangeSet(ctx context.Context, sel ast.SelectionSet, obj *model.ChangeSet) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, changeSetImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ChangeSet")
		case "id":
			out.Values[i] = ec._ChangeSet_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec._ChangeSet_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec._ChangeSet_description(ctx, field, obj)
		case "routerId":
			out.Values[i] = ec._ChangeSet_routerId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "items":
			out.Values[i] = ec._ChangeSet_items(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "status":
			out.Values[i] = ec._ChangeSet_status(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "validation":
			out.Values[i] = ec._ChangeSet_validation(ctx, field, obj)
		case "rollbackPlan":
			out.Values[i] = ec._ChangeSet_rollbackPlan(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "error":
			out.Values[i] = ec._ChangeSet_error(ctx, field, obj)
		case "createdAt":
			out.Values[i] = ec._ChangeSet_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "applyStartedAt":
			out.Values[i] = ec._ChangeSet_applyStartedAt(ctx, field, obj)
		case "completedAt":
			out.Values[i] = ec._ChangeSet_completedAt(ctx, field, obj)
		case "createdBy":
			out.Values[i] = ec._ChangeSet_createdBy(ctx, field, obj)
		case "source":
			out.Values[i] = ec._ChangeSet_source(ctx, field, obj)
		case "version":
			out.Values[i] = ec._ChangeSet_version(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var changeSetConflictImplementors = []string{"ChangeSetConflict"}

func (ec *executionContext) _ChangeSetConflict(ctx context.Context, sel ast.SelectionSet, obj *model.ChangeSetConflict) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, changeSetConflictImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ChangeSetConflict")
		case "itemId1":
			out.Values[i] = ec._ChangeSetConflict_itemId1(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "itemId2OrResourceUuid":
			out.Values[i] = ec._ChangeSetConflict_itemId2OrResourceUuid(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "isExternalConflict":
			out.Values[i] = ec._ChangeSetConflict_isExternalConflict(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec._ChangeSetConflict_description(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "resolution":
			out.Values[i] = ec._ChangeSetConflict_resolution(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var changeSetErrorImplementors = []string{"ChangeSetError"}

func (ec *executionContext) _ChangeSetError(ctx context.Context, sel ast.SelectionSet, obj *model.ChangeSetError) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, changeSetErrorImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ChangeSetError")
		case "message":
			out.Values[i] = ec._ChangeSetError_message(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "failedItemId":
			out.Values[i] = ec._ChangeSetError_failedItemId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "code":
			out.Values[i] = ec._ChangeSetError_code(ctx, field, obj)
		case "partiallyAppliedItemIds":
			out.Values[i] = ec._ChangeSetError_partiallyAppliedItemIds(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "failedRollbackItemIds":
			out.Values[i] = ec._ChangeSetError_failedRollbackItemIds(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "requiresManualIntervention":
			out.Values[i] = ec._ChangeSetError_requiresManualIntervention(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var changeSetItemImplementors = []string{"ChangeSetItem"}

func (ec *executionContext) _ChangeSetItem(ctx context.Context, sel ast.SelectionSet, obj *model.ChangeSetItem) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, changeSetItemImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ChangeSetItem")
		case "id":
			out.Values[i] = ec._ChangeSetItem_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "resourceType":
			out.Values[i] = ec._ChangeSetItem_resourceType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "resourceCategory":
			out.Values[i] = ec._ChangeSetItem_resourceCategory(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "resourceUuid":
			out.Values[i] = ec._ChangeSetItem_resourceUuid(ctx, field, obj)
		case "name":
			out.Values[i] = ec._ChangeSetItem_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec._ChangeSetItem_description(ctx, field, obj)
		case "operation":
			out.Values[i] = ec._ChangeSetItem_operation(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "configuration":
			out.Values[i] = ec._ChangeSetItem_configuration(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "previousState":
			out.Values[i] = ec._ChangeSetItem_previousState(ctx, field, obj)
		case "dependencies":
			out.Values[i] = ec._ChangeSetItem_dependencies(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "status":
			out.Values[i] = ec._ChangeSetItem_status(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "error":
			out.Values[i] = ec._ChangeSetItem_error(ctx, field, obj)
		case "applyStartedAt":
			out.Values[i] = ec._ChangeSetItem_applyStartedAt(ctx, field, obj)
		case "applyCompletedAt":
			out.Values[i] = ec._ChangeSetItem_applyCompletedAt(ctx, field, obj)
		case "applyOrder":
			out.Values[i] = ec._ChangeSetItem_applyOrder(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var changeSetProgressEventImplementors = []string{"ChangeSetProgressEvent"}

func (ec *executionContext) _ChangeSetProgressEvent(ctx context.Context, sel ast.SelectionSet, obj *model.ChangeSetProgressEvent) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, changeSetProgressEventImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ChangeSetProgressEvent")
		case "changeSetId":
			out.Values[i] = ec._ChangeSetProgressEvent_changeSetId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "status":
			out.Values[i] = ec._ChangeSetProgressEvent_status(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "currentItem":
			out.Values[i] = ec._ChangeSetProgressEvent_currentItem(ctx, field, obj)
		case "appliedCount":
			out.Values[i] = ec._ChangeSetProgressEvent_appliedCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "totalCount":
			out.Values[i] = ec._ChangeSetProgressEvent_totalCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "progressPercent":
			out.Values[i] = ec._ChangeSetProgressEvent_progressPercent(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "estimatedRemainingMs":
			out.Values[i] = ec._ChangeSetProgressEvent_estimatedRemainingMs(ctx, field, obj)
		case "error":
			out.Values[i] = ec._ChangeSetProgressEvent_error(ctx, field, obj)
		case "timestamp":
			out.Values[i] = ec._ChangeSetProgressEvent_timestamp(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var changeSetStatusEventImplementors = []string{"ChangeSetStatusEvent"}

func (ec *executionContext) _ChangeSetStatusEvent(ctx context.Context, sel ast.SelectionSet, obj *model.ChangeSetStatusEvent) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, changeSetStatusEventImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ChangeSetStatusEvent")
		case "changeSetId":
			out.Values[i] = ec._ChangeSetStatusEvent_changeSetId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "previousStatus":
			out.Values[i] = ec._ChangeSetStatusEvent_previousStatus(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "newStatus":
			out.Values[i] = ec._ChangeSetStatusEvent_newStatus(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "error":
			out.Values[i] = ec._ChangeSetStatusEvent_error(ctx, field, obj)
		case "timestamp":
			out.Values[i] = ec._ChangeSetStatusEvent_timestamp(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var changeSetSummaryImplementors = []string{"ChangeSetSummary"}

func (ec *executionContext) _ChangeSetSummary(ctx context.Context, sel ast.SelectionSet, obj *model.ChangeSetSummary) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, changeSetSummaryImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ChangeSetSummary")
		case "id":
			out.Values[i] = ec._ChangeSetSummary_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec._ChangeSetSummary_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "status":
			out.Values[i] = ec._ChangeSetSummary_status(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "operationCounts":
			out.Values[i] = ec._ChangeSetSummary_operationCounts(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "totalItems":
			out.Values[i] = ec._ChangeSetSummary_totalItems(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createdAt":
			out.Values[i] = ec._ChangeSetSummary_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "hasErrors":
			out.Values[i] = ec._ChangeSetSummary_hasErrors(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "hasWarnings":
			out.Values[i] = ec._ChangeSetSummary_hasWarnings(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var changeSetValidationErrorImplementors = []string{"ChangeSetValidationError"}

func (ec *executionContext) _ChangeSetValidationError(ctx context.Context, sel ast.SelectionSet, obj *model.ChangeSetValidationError) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, changeSetValidationErrorImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ChangeSetValidationError")
		case "itemId":
			out.Values[i] = ec._ChangeSetValidationError_itemId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "field":
			out.Values[i] = ec._ChangeSetValidationError_field(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "message":
			out.Values[i] = ec._ChangeSetValidationError_message(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "severity":
			out.Values[i] = ec._ChangeSetValidationError_severity(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "code":
			out.Values[i] = ec._ChangeSetValidationError_code(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var changeSetValidationResultImplementors = []string{"ChangeSetValidationResult"}

func (ec *executionContext) _ChangeSetValidationResult(ctx context.Context, sel ast.SelectionSet, obj *model.ChangeSetValidationResult) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, changeSetValidationResultImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ChangeSetValidationResult")
		case "canApply":
			out.Values[i] = ec._ChangeSetValidationResult_canApply(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "errors":
			out.Values[i] = ec._ChangeSetValidationResult_errors(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "warnings":
			out.Values[i] = ec._ChangeSetValidationResult_warnings(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "conflicts":
			out.Values[i] = ec._ChangeSetValidationResult_conflicts(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "missingDependencies":
			out.Values[i] = ec._ChangeSetValidationResult_missingDependencies(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "circularDependencies":
			out.Values[i] = ec._ChangeSetValidationResult_circularDependencies(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var circuitBreakerEventImplementors = []string{"CircuitBreakerEvent"}

func (ec *executionContext) _CircuitBreakerEvent(ctx context.Context, sel ast.SelectionSet, obj *model.CircuitBreakerEvent) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, circuitBreakerEventImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CircuitBreakerEvent")
		case "routerId":
			out.Values[i] = ec._CircuitBreakerEvent_routerId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "previousState":
			out.Values[i] = ec._CircuitBreakerEvent_previousState(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "newState":
			out.Values[i] = ec._CircuitBreakerEvent_newState(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "consecutiveFailures":
			out.Values[i] = ec._CircuitBreakerEvent_consecutiveFailures(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "timestamp":
			out.Values[i] = ec._CircuitBreakerEvent_timestamp(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var circuitBreakerStatusImplementors = []string{"CircuitBreakerStatus"}

func (ec *executionContext) _CircuitBreakerStatus(ctx context.Context, sel ast.SelectionSet, obj *model.CircuitBreakerStatus) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, circuitBreakerStatusImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CircuitBreakerStatus")
		case "routerId":
			out.Values[i] = ec._CircuitBreakerStatus_routerId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "state":
			out.Values[i] = ec._CircuitBreakerStatus_state(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "failureCount":
			out.Values[i] = ec._CircuitBreakerStatus_failureCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "failureThreshold":
			out.Values[i] = ec._CircuitBreakerStatus_failureThreshold(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "cooldownRemainingSeconds":
			out.Values[i] = ec._CircuitBreakerStatus_cooldownRemainingSeconds(ctx, field, obj)
		case "lastFailureAt":
			out.Values[i] = ec._CircuitBreakerStatus_lastFailureAt(ctx, field, obj)
		case "lastSuccessAt":
			out.Values[i] = ec._CircuitBreakerStatus_lastSuccessAt(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var compositeResourceImplementors = []string{"CompositeResource"}

func (ec *executionContext) _CompositeResource(ctx context.Context, sel ast.SelectionSet, obj *model.CompositeResource) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, compositeResourceImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CompositeResource")
		case "root":
			out.Values[i] = ec._CompositeResource_root(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "children":
			out.Values[i] = ec._CompositeResource_children(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "relationships":
			out.Values[i] = ec._CompositeResource_relationships(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var configPreviewImplementors = []string{"ConfigPreview"}

func (ec *executionContext) _ConfigPreview(ctx context.Context, sel ast.SelectionSet, obj *model.ConfigPreview) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, configPreviewImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ConfigPreview")
		case "commands":
			out.Values[i] = ec._ConfigPreview_commands(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "warnings":
			out.Values[i] = ec._ConfigPreview_warnings(ctx, field, obj)
		case "affectedResources":
			out.Values[i] = ec._ConfigPreview_affectedResources(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var configProgressImplementors = []string{"ConfigProgress"}

func (ec *executionContext) _ConfigProgress(ctx context.Context, sel ast.SelectionSet, obj *model.ConfigProgress) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, configProgressImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ConfigProgress")
		case "operationId":
			out.Values[i] = ec._ConfigProgress_operationId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "status":
			out.Values[i] = ec._ConfigProgress_status(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "percentage":
			out.Values[i] = ec._ConfigProgress_percentage(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "message":
			out.Values[i] = ec._ConfigProgress_message(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "currentStep":
			out.Values[i] = ec._ConfigProgress_currentStep(ctx, field, obj)
		case "totalSteps":
			out.Values[i] = ec._ConfigProgress_totalSteps(ctx, field, obj)
		case "timestamp":
			out.Values[i] = ec._ConfigProgress_timestamp(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var connectRouterPayloadImplementors = []string{"ConnectRouterPayload"}

func (ec *executionContext) _ConnectRouterPayload(ctx context.Context, sel ast.SelectionSet, obj *model.ConnectRouterPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, connectRouterPayloadImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ConnectRouterPayload")
		case "router":
			out.Values[i] = ec._ConnectRouterPayload_router(ctx, field, obj)
		case "errors":
			out.Values[i] = ec._ConnectRouterPayload_errors(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var connectionAttemptImplementors = []string{"ConnectionAttempt"}

func (ec *executionContext) _ConnectionAttempt(ctx context.Context, sel ast.SelectionSet, obj *model.ConnectionAttempt) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, connectionAttemptImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ConnectionAttempt")
		case "protocol":
			out.Values[i] = ec._ConnectionAttempt_protocol(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "startedAt":
			out.Values[i] = ec._ConnectionAttempt_startedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "endedAt":
			out.Values[i] = ec._ConnectionAttempt_endedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "success":
			out.Values[i] = ec._ConnectionAttempt_success(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "errorCode":
			out.Values[i] = ec._ConnectionAttempt_errorCode(ctx, field, obj)
		case "errorMessage":
			out.Values[i] = ec._ConnectionAttempt_errorMessage(ctx, field, obj)
		case "errorCategory":
			out.Values[i] = ec._ConnectionAttempt_errorCategory(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var connectionDetailsImplementors = []string{"ConnectionDetails"}

func (ec *executionContext) _ConnectionDetails(ctx context.Context, sel ast.SelectionSet, obj *model.ConnectionDetails) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, connectionDetailsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ConnectionDetails")
		case "state":
			out.Values[i] = ec._ConnectionDetails_state(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "protocol":
			out.Values[i] = ec._ConnectionDetails_protocol(ctx, field, obj)
		case "preferredProtocol":
			out.Values[i] = ec._ConnectionDetails_preferredProtocol(ctx, field, obj)
		case "connectedAt":
			out.Values[i] = ec._ConnectionDetails_connectedAt(ctx, field, obj)
		case "uptime":
			out.Values[i] = ec._ConnectionDetails_uptime(ctx, field, obj)
		case "disconnectedAt":
			out.Values[i] = ec._ConnectionDetails_disconnectedAt(ctx, field, obj)
		case "lastError":
			out.Values[i] = ec._ConnectionDetails_lastError(ctx, field, obj)
		case "lastErrorTime":
			out.Values[i] = ec._ConnectionDetails_lastErrorTime(ctx, field, obj)
		case "disconnectReason":
			out.Values[i] = ec._ConnectionDetails_disconnectReason(ctx, field, obj)
		case "reconnectAttempts":
			out.Values[i] = ec._ConnectionDetails_reconnectAttempts(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "nextReconnectAt":
			out.Values[i] = ec._ConnectionDetails_nextReconnectAt(ctx, field, obj)
		case "circuitBreakerState":
			out.Values[i] = ec._ConnectionDetails_circuitBreakerState(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "version":
			out.Values[i] = ec._ConnectionDetails_version(ctx, field, obj)
		case "lastHealthCheck":
			out.Values[i] = ec._ConnectionDetails_lastHealthCheck(ctx, field, obj)
		case "healthChecksPassed":
			out.Values[i] = ec._ConnectionDetails_healthChecksPassed(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "healthChecksFailed":
			out.Values[i] = ec._ConnectionDetails_healthChecksFailed(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "securityWarning":
			out.Values[i] = ec._ConnectionDetails_securityWarning(ctx, field, obj)
		case "upgradeRecommendation":
			out.Values[i] = ec._ConnectionDetails_upgradeRecommendation(ctx, field, obj)
		case "isLegacyProtocol":
			out.Values[i] = ec._ConnectionDetails_isLegacyProtocol(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var connectionErrorImplementors = []string{"ConnectionError"}

func (ec *executionContext) _ConnectionError(ctx context.Context, sel ast.SelectionSet, obj *model.ConnectionError) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, connectionErrorImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ConnectionError")
		case "code":
			out.Values[i] = ec._ConnectionError_code(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "message":
			out.Values[i] = ec._ConnectionError_message(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "protocol":
			out.Values[i] = ec._ConnectionError_protocol(ctx, field, obj)
		case "retryable":
			out.Values[i] = ec._ConnectionError_retryable(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "suggestedAction":
			out.Values[i] = ec._ConnectionError_suggestedAction(ctx, field, obj)
		case "timeoutMs":
			out.Values[i] = ec._ConnectionError_timeoutMs(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var connectionStatsImplementors = []string{"ConnectionStats"}

func (ec *executionContext) _ConnectionStats(ctx context.Context, sel ast.SelectionSet, obj *model.ConnectionStats) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, connectionStatsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ConnectionStats")
		case "totalConnections":
			out.Values[i] = ec._ConnectionStats_totalConnections(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "connected":
			out.Values[i] = ec._ConnectionStats_connected(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "connecting":
			out.Values[i] = ec._ConnectionStats_connecting(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "disconnected":
			out.Values[i] = ec._ConnectionStats_disconnected(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "reconnecting":
			out.Values[i] = ec._ConnectionStats_reconnecting(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "error":
			out.Values[i] = ec._ConnectionStats_error(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var connectionTestResultImplementors = []string{"ConnectionTestResult"}

func (ec *executionContext) _ConnectionTestResult(ctx context.Context, sel ast.SelectionSet, obj *model.ConnectionTestResult) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, connectionTestResultImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ConnectionTestResult")
		case "success":
			out.Values[i] = ec._ConnectionTestResult_success(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "protocolUsed":
			out.Values[i] = ec._ConnectionTestResult_protocolUsed(ctx, field, obj)
		case "responseTimeMs":
			out.Values[i] = ec._ConnectionTestResult_responseTimeMs(ctx, field, obj)
		case "routerVersion":
			out.Values[i] = ec._ConnectionTestResult_routerVersion(ctx, field, obj)
		case "routerModel":
			out.Values[i] = ec._ConnectionTestResult_routerModel(ctx, field, obj)
		case "boardName":
			out.Values[i] = ec._ConnectionTestResult_boardName(ctx, field, obj)
		case "uptime":
			out.Values[i] = ec._ConnectionTestResult_uptime(ctx, field, obj)
		case "protocolsAttempted":
			out.Values[i] = ec._ConnectionTestResult_protocolsAttempted(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "supportsContainers":
			out.Values[i] = ec._ConnectionTestResult_supportsContainers(ctx, field, obj)
		case "architecture":
			out.Values[i] = ec._ConnectionTestResult_architecture(ctx, field, obj)
		case "error":
			out.Values[i] = ec._ConnectionTestResult_error(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var containerInfoImplementors = []string{"ContainerInfo"}

func (ec *executionContext) _ContainerInfo(ctx context.Context, sel ast.SelectionSet, obj *model.ContainerInfo) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, containerInfoImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ContainerInfo")
		case "packageInstalled":
			out.Values[i] = ec._ContainerInfo_packageInstalled(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "enabled":
			out.Values[i] = ec._ContainerInfo_enabled(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "registryConfigured":
			out.Values[i] = ec._ContainerInfo_registryConfigured(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "storageAvailable":
			out.Values[i] = ec._ContainerInfo_storageAvailable(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "supportsNetworkNamespace":
			out.Values[i] = ec._ContainerInfo_supportsNetworkNamespace(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "maxContainers":
			out.Values[i] = ec._ContainerInfo_maxContainers(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var createChangeSetPayloadImplementors = []string{"CreateChangeSetPayload"}

func (ec *executionContext) _CreateChangeSetPayload(ctx context.Context, sel ast.SelectionSet, obj *model.CreateChangeSetPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, createChangeSetPayloadImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CreateChangeSetPayload")
		case "changeSet":
			out.Values[i] = ec._CreateChangeSetPayload_changeSet(ctx, field, obj)
		case "errors":
			out.Values[i] = ec._CreateChangeSetPayload_errors(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var createResourcePayloadImplementors = []string{"CreateResourcePayload"}

func (ec *executionContext) _CreateResourcePayload(ctx context.Context, sel ast.SelectionSet, obj *model.CreateResourcePayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, createResourcePayloadImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CreateResourcePayload")
		case "resource":
			out.Values[i] = ec._CreateResourcePayload_resource(ctx, field, obj)
		case "errors":
			out.Values[i] = ec._CreateResourcePayload_errors(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var createRouterPayloadImplementors = []string{"CreateRouterPayload"}

func (ec *executionContext) _CreateRouterPayload(ctx context.Context, sel ast.SelectionSet, obj *model.CreateRouterPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, createRouterPayloadImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CreateRouterPayload")
		case "router":
			out.Values[i] = ec._CreateRouterPayload_router(ctx, field, obj)
		case "errors":
			out.Values[i] = ec._CreateRouterPayload_errors(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var credentialTestResultImplementors = []string{"CredentialTestResult"}

func (ec *executionContext) _CredentialTestResult(ctx context.Context, sel ast.SelectionSet, obj *model.CredentialTestResult) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, credentialTestResultImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CredentialTestResult")
		case "routerId":
			out.Values[i] = ec._CredentialTestResult_routerId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "routerName":
			out.Values[i] = ec._CredentialTestResult_routerName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "success":
			out.Values[i] = ec._CredentialTestResult_success(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "status":
			out.Values[i] = ec._CredentialTestResult_status(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "responseTimeMs":
			out.Values[i] = ec._CredentialTestResult_responseTimeMs(ctx, field, obj)
		case "error":
			out.Values[i] = ec._CredentialTestResult_error(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var credentialUpdatePayloadImplementors = []string{"CredentialUpdatePayload"}

func (ec *executionContext) _CredentialUpdatePayload(ctx context.Context, sel ast.SelectionSet, obj *model.CredentialUpdatePayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, credentialUpdatePayloadImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CredentialUpdatePayload")
		case "success":
			out.Values[i] = ec._CredentialUpdatePayload_success(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "message":
			out.Values[i] = ec._CredentialUpdatePayload_message(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "credentials":
			out.Values[i] = ec._CredentialUpdatePayload_credentials(ctx, field, obj)
		case "errorCode":
			out.Values[i] = ec._CredentialUpdatePayload_errorCode(ctx, field, obj)
		case "errors":
			out.Values[i] = ec._CredentialUpdatePayload_errors(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var currentItemInfoImplementors = []string{"CurrentItemInfo"}

func (ec *executionContext) _CurrentItemInfo(ctx context.Context, sel ast.SelectionSet, obj *model.CurrentItemInfo) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, currentItemInfoImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CurrentItemInfo")
		case "id":
			out.Values[i] = ec._CurrentItemInfo_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec._CurrentItemInfo_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "operation":
			out.Values[i] = ec._CurrentItemInfo_operation(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "status":
			out.Values[i] = ec._CurrentItemInfo_status(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var dHCPServerResourceImplementors = []string{"DHCPServerResource", "Resource", "Node"}

func (ec *executionContext) _DHCPServerResource(ctx context.Context, sel ast.SelectionSet, obj *model.DHCPServerResource) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, dHCPServerResourceImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DHCPServerResource")
		case "id":
			out.Values[i] = ec._DHCPServerResource_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "scopedId":
			out.Values[i] = ec._DHCPServerResource_scopedId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "type":
			out.Values[i] = ec._DHCPServerResource_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "category":
			out.Values[i] = ec._DHCPServerResource_category(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "configuration":
			out.Values[i] = ec._DHCPServerResource_configuration(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "validation":
			out.Values[i] = ec._DHCPServerResource_validation(ctx, field, obj)
		case "deployment":
			out.Values[i] = ec._DHCPServerResource_deployment(ctx, field, obj)
		case "runtime":
			out.Values[i] = ec._DHCPServerResource_runtime(ctx, field, obj)
		case "telemetry":
			out.Values[i] = ec._DHCPServerResource_telemetry(ctx, field, obj)
		case "metadata":
			out.Values[i] = ec._DHCPServerResource_metadata(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "relationships":
			out.Values[i] = ec._DHCPServerResource_relationships(ctx, field, obj)
		case "platform":
			out.Values[i] = ec._DHCPServerResource_platform(ctx, field, obj)
		case "name":
			out.Values[i] = ec._DHCPServerResource_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "interface":
			out.Values[i] = ec._DHCPServerResource_interface(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "addressPool":
			out.Values[i] = ec._DHCPServerResource_addressPool(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "leaseTime":
			out.Values[i] = ec._DHCPServerResource_leaseTime(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "activeLeases":
			out.Values[i] = ec._DHCPServerResource_activeLeases(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var dailyStatsImplementors = []string{"DailyStats"}

func (ec *executionContext) _DailyStats(ctx context.Context, sel ast.SelectionSet, obj *model.DailyStats) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, dailyStatsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DailyStats")
		case "date":
			out.Values[i] = ec._DailyStats_date(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "totalBytesIn":
			out.Values[i] = ec._DailyStats_totalBytesIn(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "totalBytesOut":
			out.Values[i] = ec._DailyStats_totalBytesOut(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "uptimePercent":
			out.Values[i] = ec._DailyStats_uptimePercent(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "errorCount":
			out.Values[i] = ec._DailyStats_errorCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "peakThroughputIn":
			out.Values[i] = ec._DailyStats_peakThroughputIn(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "peakThroughputOut":
			out.Values[i] = ec._DailyStats_peakThroughputOut(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var deleteChangeSetPayloadImplementors = []string{"DeleteChangeSetPayload"}

func (ec *executionContext) _DeleteChangeSetPayload(ctx context.Context, sel ast.SelectionSet, obj *model.DeleteChangeSetPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, deleteChangeSetPayloadImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DeleteChangeSetPayload")
		case "success":
			out.Values[i] = ec._DeleteChangeSetPayload_success(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "errors":
			out.Values[i] = ec._DeleteChangeSetPayload_errors(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var deletePayloadImplementors = []string{"DeletePayload"}

func (ec *executionContext) _DeletePayload(ctx context.Context, sel ast.SelectionSet, obj *model.DeletePayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, deletePayloadImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DeletePayload")
		case "success":
			out.Values[i] = ec._DeletePayload_success(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deletedId":
			out.Values[i] = ec._DeletePayload_deletedId(ctx, field, obj)
		case "errors":
			out.Values[i] = ec._DeletePayload_errors(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var deleteResourcePayloadImplementors = []string{"DeleteResourcePayload"}

func (ec *executionContext) _DeleteResourcePayload(ctx context.Context, sel ast.SelectionSet, obj *model.DeleteResourcePayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, deleteResourcePayloadImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DeleteResourcePayload")
		case "success":
			out.Values[i] = ec._DeleteResourcePayload_success(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deletedId":
			out.Values[i] = ec._DeleteResourcePayload_deletedId(ctx, field, obj)
		case "errors":
			out.Values[i] = ec._DeleteResourcePayload_errors(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var deleteResultImplementors = []string{"DeleteResult"}

func (ec *executionContext) _DeleteResult(ctx context.Context, sel ast.SelectionSet, obj *model.DeleteResult) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, deleteResultImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DeleteResult")
		case "success":
			out.Values[i] = ec._DeleteResult_success(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "message":
			out.Values[i] = ec._DeleteResult_message(ctx, field, obj)
		case "errors":
			out.Values[i] = ec._DeleteResult_errors(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var deleteRouterPayloadImplementors = []string{"DeleteRouterPayload"}

func (ec *executionContext) _DeleteRouterPayload(ctx context.Context, sel ast.SelectionSet, obj *model.DeleteRouterPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, deleteRouterPayloadImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DeleteRouterPayload")
		case "success":
			out.Values[i] = ec._DeleteRouterPayload_success(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deletedRouterId":
			out.Values[i] = ec._DeleteRouterPayload_deletedRouterId(ctx, field, obj)
		case "errors":
			out.Values[i] = ec._DeleteRouterPayload_errors(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var dependencyStatusImplementors = []string{"DependencyStatus"}

func (ec *executionContext) _DependencyStatus(ctx context.Context, sel ast.SelectionSet, obj *model.DependencyStatus) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, dependencyStatusImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DependencyStatus")
		case "resourceUuid":
			out.Values[i] = ec._DependencyStatus_resourceUuid(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "resourceType":
			out.Values[i] = ec._DependencyStatus_resourceType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "isActive":
			out.Values[i] = ec._DependencyStatus_isActive(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "state":
			out.Values[i] = ec._DependencyStatus_state(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "reason":
			out.Values[i] = ec._DependencyStatus_reason(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var deploymentStateImplementors = []string{"DeploymentState"}

func (ec *executionContext) _DeploymentState(ctx context.Context, sel ast.SelectionSet, obj *model.DeploymentState) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, deploymentStateImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DeploymentState")
		case "routerResourceId":
			out.Values[i] = ec._DeploymentState_routerResourceId(ctx, field, obj)
		case "appliedAt":
			out.Values[i] = ec._DeploymentState_appliedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "appliedBy":
			out.Values[i] = ec._DeploymentState_appliedBy(ctx, field, obj)
		case "routerVersion":
			out.Values[i] = ec._DeploymentState_routerVersion(ctx, field, obj)
		case "generatedFields":
			out.Values[i] = ec._DeploymentState_generatedFields(ctx, field, obj)
		case "isInSync":
			out.Values[i] = ec._DeploymentState_isInSync(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "drift":
			out.Values[i] = ec._DeploymentState_drift(ctx, field, obj)
		case "applyOperationId":
			out.Values[i] = ec._DeploymentState_applyOperationId(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var deprecateResourcePayloadImplementors = []string{"DeprecateResourcePayload"}

func (ec *executionContext) _DeprecateResourcePayload(ctx context.Context, sel ast.SelectionSet, obj *model.DeprecateResourcePayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, deprecateResourcePayloadImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DeprecateResourcePayload")
		case "resource":
			out.Values[i] = ec._DeprecateResourcePayload_resource(ctx, field, obj)
		case "errors":
			out.Values[i] = ec._DeprecateResourcePayload_errors(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var deviceImplementors = []string{"Device"}

func (ec *executionContext) _Device(ctx context.Context, sel ast.SelectionSet, obj *model.Device) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, deviceImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Device")
		case "id":
			out.Values[i] = ec._Device_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "resourceMetrics":
			out.Values[i] = ec._Device_resourceMetrics(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var dhcpClientImplementors = []string{"DhcpClient", "Node"}

func (ec *executionContext) _DhcpClient(ctx context.Context, sel ast.SelectionSet, obj *model.DhcpClient) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, dhcpClientImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DhcpClient")
		case "id":
			out.Values[i] = ec._DhcpClient_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "interface":
			out.Values[i] = ec._DhcpClient_interface(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "disabled":
			out.Values[i] = ec._DhcpClient_disabled(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "addDefaultRoute":
			out.Values[i] = ec._DhcpClient_addDefaultRoute(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "usePeerDNS":
			out.Values[i] = ec._DhcpClient_usePeerDNS(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "usePeerNTP":
			out.Values[i] = ec._DhcpClient_usePeerNTP(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "status":
			out.Values[i] = ec._DhcpClient_status(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "address":
			out.Values[i] = ec._DhcpClient_address(ctx, field, obj)
		case "dhcpServer":
			out.Values[i] = ec._DhcpClient_dhcpServer(ctx, field, obj)
		case "gateway":
			out.Values[i] = ec._DhcpClient_gateway(ctx, field, obj)
		case "expiresAfter":
			out.Values[i] = ec._DhcpClient_expiresAfter(ctx, field, obj)
		case "comment":
			out.Values[i] = ec._DhcpClient_comment(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var dhcpServerImplementors = []string{"DhcpServer"}

func (ec *executionContext) _DhcpServer(ctx context.Context, sel ast.SelectionSet, obj *model.DhcpServer) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, dhcpServerImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DhcpServer")
		case "id":
			out.Values[i] = ec._DhcpServer_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec._DhcpServer_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "interface":
			out.Values[i] = ec._DhcpServer_interface(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "disabled":
			out.Values[i] = ec._DhcpServer_disabled(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var diagnosticReportImplementors = []string{"DiagnosticReport"}

func (ec *executionContext) _DiagnosticReport(ctx context.Context, sel ast.SelectionSet, obj *model.DiagnosticReport) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, diagnosticReportImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DiagnosticReport")
		case "routerId":
			out.Values[i] = ec._DiagnosticReport_routerId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "timestamp":
			out.Values[i] = ec._DiagnosticReport_timestamp(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "networkReachable":
			out.Values[i] = ec._DiagnosticReport_networkReachable(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "portStatus":
			out.Values[i] = ec._DiagnosticReport_portStatus(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "tlsStatus":
			out.Values[i] = ec._DiagnosticReport_tlsStatus(ctx, field, obj)
		case "authStatus":
			out.Values[i] = ec._DiagnosticReport_authStatus(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "suggestions":
			out.Values[i] = ec._DiagnosticReport_suggestions(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "rawReport":
			out.Values[i] = ec._DiagnosticReport_rawReport(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var diagnosticSuggestionImplementors = []string{"DiagnosticSuggestion"}

func (ec *executionContext) _DiagnosticSuggestion(ctx context.Context, sel ast.SelectionSet, obj *model.DiagnosticSuggestion) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, diagnosticSuggestionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DiagnosticSuggestion")
		case "severity":
			out.Values[i] = ec._DiagnosticSuggestion_severity(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "title":
			out.Values[i] = ec._DiagnosticSuggestion_title(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec._DiagnosticSuggestion_description(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "action":
			out.Values[i] = ec._DiagnosticSuggestion_action(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "docsUrl":
			out.Values[i] = ec._DiagnosticSuggestion_docsUrl(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var disconnectRouterPayloadImplementors = []string{"DisconnectRouterPayload"}

func (ec *executionContext) _DisconnectRouterPayload(ctx context.Context, sel ast.SelectionSet, obj *model.DisconnectRouterPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, disconnectRouterPayloadImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DisconnectRouterPayload")
		case "router":
			out.Values[i] = ec._DisconnectRouterPayload_router(ctx, field, obj)
		case "errors":
			out.Values[i] = ec._DisconnectRouterPayload_errors(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var discoveredDeviceImplementors = []string{"DiscoveredDevice"}

func (ec *executionContext) _DiscoveredDevice(ctx context.Context, sel ast.SelectionSet, obj *model.DiscoveredDevice) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, discoveredDeviceImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DiscoveredDevice")
		case "ip":
			out.Values[i] = ec._DiscoveredDevice_ip(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "hostname":
			out.Values[i] = ec._DiscoveredDevice_hostname(ctx, field, obj)
		case "ports":
			out.Values[i] = ec._DiscoveredDevice_ports(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deviceType":
			out.Values[i] = ec._DiscoveredDevice_deviceType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "vendor":
			out.Values[i] = ec._DiscoveredDevice_vendor(ctx, field, obj)
		case "routerOSInfo":
			out.Values[i] = ec._DiscoveredDevice_routerOSInfo(ctx, field, obj)
		case "confidence":
			out.Values[i] = ec._DiscoveredDevice_confidence(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "services":
			out.Values[i] = ec._DiscoveredDevice_services(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var dnsLookupResultImplementors = []string{"DnsLookupResult"}

func (ec *executionContext) _DnsLookupResult(ctx context.Context, sel ast.SelectionSet, obj *model.DNSLookupResult) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, dnsLookupResultImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DnsLookupResult")
		case "hostname":
			out.Values[i] = ec._DnsLookupResult_hostname(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "recordType":
			out.Values[i] = ec._DnsLookupResult_recordType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "status":
			out.Values[i] = ec._DnsLookupResult_status(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "records":
			out.Values[i] = ec._DnsLookupResult_records(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "server":
			out.Values[i] = ec._DnsLookupResult_server(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "queryTime":
			out.Values[i] = ec._DnsLookupResult_queryTime(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "authoritative":
			out.Values[i] = ec._DnsLookupResult_authoritative(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "error":
			out.Values[i] = ec._DnsLookupResult_error(ctx, field, obj)
		case "timestamp":
			out.Values[i] = ec._DnsLookupResult_timestamp(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var dnsRecordImplementors = []string{"DnsRecord"}

func (ec *executionContext) _DnsRecord(ctx context.Context, sel ast.SelectionSet, obj *model.DNSRecord) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, dnsRecordImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DnsRecord")
		case "name":
			out.Values[i] = ec._DnsRecord_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "type":
			out.Values[i] = ec._DnsRecord_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "ttl":
			out.Values[i] = ec._DnsRecord_ttl(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "data":
			out.Values[i] = ec._DnsRecord_data(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "priority":
			out.Values[i] = ec._DnsRecord_priority(ctx, field, obj)
		case "weight":
			out.Values[i] = ec._DnsRecord_weight(ctx, field, obj)
		case "port":
			out.Values[i] = ec._DnsRecord_port(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var dnsServerImplementors = []string{"DnsServer"}

func (ec *executionContext) _DnsServer(ctx context.Context, sel ast.SelectionSet, obj *model.DNSServer) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, dnsServerImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DnsServer")
		case "address":
			out.Values[i] = ec._DnsServer_address(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "isPrimary":
			out.Values[i] = ec._DnsServer_isPrimary(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "isSecondary":
			out.Values[i] = ec._DnsServer_isSecondary(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var dnsServersImplementors = []string{"DnsServers"}

func (ec *executionContext) _DnsServers(ctx context.Context, sel ast.SelectionSet, obj *model.DNSServers) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, dnsServersImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DnsServers")
		case "servers":
			out.Values[i] = ec._DnsServers_servers(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "primary":
			out.Values[i] = ec._DnsServers_primary(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "secondary":
			out.Values[i] = ec._DnsServers_secondary(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var driftFieldImplementors = []string{"DriftField"}

func (ec *executionContext) _DriftField(ctx context.Context, sel ast.SelectionSet, obj *model.DriftField) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, driftFieldImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DriftField")
		case "path":
			out.Values[i] = ec._DriftField_path(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "expected":
			out.Values[i] = ec._DriftField_expected(ctx, field, obj)
		case "actual":
			out.Values[i] = ec._DriftField_actual(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var driftInfoImplementors = []string{"DriftInfo"}

func (ec *executionContext) _DriftInfo(ctx context.Context, sel ast.SelectionSet, obj *model.DriftInfo) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, driftInfoImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DriftInfo")
		case "detectedAt":
			out.Values[i] = ec._DriftInfo_detectedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "driftedFields":
			out.Values[i] = ec._DriftInfo_driftedFields(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "suggestedAction":
			out.Values[i] = ec._DriftInfo_suggestedAction(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var errorExtensionsImplementors = []string{"ErrorExtensions"}

func (ec *executionContext) _ErrorExtensions(ctx context.Context, sel ast.SelectionSet, obj *model.ErrorExtensions) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, errorExtensionsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ErrorExtensions")
		case "code":
			out.Values[i] = ec._ErrorExtensions_code(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "category":
			out.Values[i] = ec._ErrorExtensions_category(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "field":
			out.Values[i] = ec._ErrorExtensions_field(ctx, field, obj)
		case "value":
			out.Values[i] = ec._ErrorExtensions_value(ctx, field, obj)
		case "suggestedFix":
			out.Values[i] = ec._ErrorExtensions_suggestedFix(ctx, field, obj)
		case "docsUrl":
			out.Values[i] = ec._ErrorExtensions_docsUrl(ctx, field, obj)
		case "requestId":
			out.Values[i] = ec._ErrorExtensions_requestId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "recoverable":
			out.Values[i] = ec._ErrorExtensions_recoverable(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "troubleshootingSteps":
			out.Values[i] = ec._ErrorExtensions_troubleshootingSteps(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var exportConfigPayloadImplementors = []string{"ExportConfigPayload"}

func (ec *executionContext) _ExportConfigPayload(ctx context.Context, sel ast.SelectionSet, obj *model.ExportConfigPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, exportConfigPayloadImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ExportConfigPayload")
		case "success":
			out.Values[i] = ec._ExportConfigPayload_success(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "config":
			out.Values[i] = ec._ExportConfigPayload_config(ctx, field, obj)
		case "securityWarning":
			out.Values[i] = ec._ExportConfigPayload_securityWarning(ctx, field, obj)
		case "errors":
			out.Values[i] = ec._ExportConfigPayload_errors(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var featureCompatibilityInfoImplementors = []string{"FeatureCompatibilityInfo"}

func (ec *executionContext) _FeatureCompatibilityInfo(ctx context.Context, sel ast.SelectionSet, obj *model.FeatureCompatibilityInfo) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, featureCompatibilityInfoImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("FeatureCompatibilityInfo")
		case "featureId":
			out.Values[i] = ec._FeatureCompatibilityInfo_featureId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec._FeatureCompatibilityInfo_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "minVersion":
			out.Values[i] = ec._FeatureCompatibilityInfo_minVersion(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "maxVersion":
			out.Values[i] = ec._FeatureCompatibilityInfo_maxVersion(ctx, field, obj)
		case "minVersionCHR":
			out.Values[i] = ec._FeatureCompatibilityInfo_minVersionCHR(ctx, field, obj)
		case "requiredPackages":
			out.Values[i] = ec._FeatureCompatibilityInfo_requiredPackages(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "dependsOn":
			out.Values[i] = ec._FeatureCompatibilityInfo_dependsOn(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "upgradeUrl":
			out.Values[i] = ec._FeatureCompatibilityInfo_upgradeUrl(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var featureDeploymentImplementors = []string{"FeatureDeployment"}

func (ec *executionContext) _FeatureDeployment(ctx context.Context, sel ast.SelectionSet, obj *model.FeatureDeployment) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, featureDeploymentImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("FeatureDeployment")
		case "routerResourceId":
			out.Values[i] = ec._FeatureDeployment_routerResourceId(ctx, field, obj)
		case "appliedAt":
			out.Values[i] = ec._FeatureDeployment_appliedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "appliedBy":
			out.Values[i] = ec._FeatureDeployment_appliedBy(ctx, field, obj)
		case "routerVersion":
			out.Values[i] = ec._FeatureDeployment_routerVersion(ctx, field, obj)
		case "isInSync":
			out.Values[i] = ec._FeatureDeployment_isInSync(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "drift":
			out.Values[i] = ec._FeatureDeployment_drift(ctx, field, obj)
		case "containerId":
			out.Values[i] = ec._FeatureDeployment_containerId(ctx, field, obj)
		case "containerImage":
			out.Values[i] = ec._FeatureDeployment_containerImage(ctx, field, obj)
		case "assignedPorts":
			out.Values[i] = ec._FeatureDeployment_assignedPorts(ctx, field, obj)
		case "assignedIP":
			out.Values[i] = ec._FeatureDeployment_assignedIP(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var featureResourceImplementors = []string{"FeatureResource", "Resource", "Node"}

func (ec *executionContext) _FeatureResource(ctx context.Context, sel ast.SelectionSet, obj *model.FeatureResource) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, featureResourceImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("FeatureResource")
		case "id":
			out.Values[i] = ec._FeatureResource_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "scopedId":
			out.Values[i] = ec._FeatureResource_scopedId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "type":
			out.Values[i] = ec._FeatureResource_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "category":
			out.Values[i] = ec._FeatureResource_category(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "configuration":
			out.Values[i] = ec._FeatureResource_configuration(ctx, field, obj)
		case "validation":
			out.Values[i] = ec._FeatureResource_validation(ctx, field, obj)
		case "deployment":
			out.Values[i] = ec._FeatureResource_deployment(ctx, field, obj)
		case "runtime":
			out.Values[i] = ec._FeatureResource_runtime(ctx, field, obj)
		case "telemetry":
			out.Values[i] = ec._FeatureResource_telemetry(ctx, field, obj)
		case "metadata":
			out.Values[i] = ec._FeatureResource_metadata(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "relationships":
			out.Values[i] = ec._FeatureResource_relationships(ctx, field, obj)
		case "platform":
			out.Values[i] = ec._FeatureResource_platform(ctx, field, obj)
		case "featureDeployment":
			out.Values[i] = ec._FeatureResource_featureDeployment(ctx, field, obj)
		case "featureRuntime":
			out.Values[i] = ec._FeatureResource_featureRuntime(ctx, field, obj)
		case "featureId":
			out.Values[i] = ec._FeatureResource_featureId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec._FeatureResource_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "version":
			out.Values[i] = ec._FeatureResource_version(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "virtualInterface":
			out.Values[i] = ec._FeatureResource_virtualInterface(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var featureRuntimeImplementors = []string{"FeatureRuntime"}

func (ec *executionContext) _FeatureRuntime(ctx context.Context, sel ast.SelectionSet, obj *model.FeatureRuntime) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, featureRuntimeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("FeatureRuntime")
		case "isRunning":
			out.Values[i] = ec._FeatureRuntime_isRunning(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "health":
			out.Values[i] = ec._FeatureRuntime_health(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "errorMessage":
			out.Values[i] = ec._FeatureRuntime_errorMessage(ctx, field, obj)
		case "lastUpdated":
			out.Values[i] = ec._FeatureRuntime_lastUpdated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "containerStatus":
			out.Values[i] = ec._FeatureRuntime_containerStatus(ctx, field, obj)
		case "memoryUsage":
			out.Values[i] = ec._FeatureRuntime_memoryUsage(ctx, field, obj)
		case "cpuUsagePercent":
			out.Values[i] = ec._FeatureRuntime_cpuUsagePercent(ctx, field, obj)
		case "routedDevices":
			out.Values[i] = ec._FeatureRuntime_routedDevices(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var featureSupportImplementors = []string{"FeatureSupport"}

func (ec *executionContext) _FeatureSupport(ctx context.Context, sel ast.SelectionSet, obj *model.FeatureSupport) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, featureSupportImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("FeatureSupport")
		case "featureId":
			out.Values[i] = ec._FeatureSupport_featureId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec._FeatureSupport_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "supported":
			out.Values[i] = ec._FeatureSupport_supported(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "level":
			out.Values[i] = ec._FeatureSupport_level(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "reason":
			out.Values[i] = ec._FeatureSupport_reason(ctx, field, obj)
		case "requiredVersion":
			out.Values[i] = ec._FeatureSupport_requiredVersion(ctx, field, obj)
		case "upgradeUrl":
			out.Values[i] = ec._FeatureSupport_upgradeUrl(ctx, field, obj)
		case "requiredPackages":
			out.Values[i] = ec._FeatureSupport_requiredPackages(ctx, field, obj)
		case "missingPackages":
			out.Values[i] = ec._FeatureSupport_missingPackages(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var firewallRuleImplementors = []string{"FirewallRule"}

func (ec *executionContext) _FirewallRule(ctx context.Context, sel ast.SelectionSet, obj *model.FirewallRule) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, firewallRuleImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("FirewallRule")
		case "id":
			out.Values[i] = ec._FirewallRule_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "chain":
			out.Values[i] = ec._FirewallRule_chain(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "action":
			out.Values[i] = ec._FirewallRule_action(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "inInterface":
			out.Values[i] = ec._FirewallRule_inInterface(ctx, field, obj)
		case "outInterface":
			out.Values[i] = ec._FirewallRule_outInterface(ctx, field, obj)
		case "disabled":
			out.Values[i] = ec._FirewallRule_disabled(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var firewallRuleResourceImplementors = []string{"FirewallRuleResource", "Resource", "Node"}

func (ec *executionContext) _FirewallRuleResource(ctx context.Context, sel ast.SelectionSet, obj *model.FirewallRuleResource) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, firewallRuleResourceImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("FirewallRuleResource")
		case "id":
			out.Values[i] = ec._FirewallRuleResource_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "scopedId":
			out.Values[i] = ec._FirewallRuleResource_scopedId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "type":
			out.Values[i] = ec._FirewallRuleResource_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "category":
			out.Values[i] = ec._FirewallRuleResource_category(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "configuration":
			out.Values[i] = ec._FirewallRuleResource_configuration(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "validation":
			out.Values[i] = ec._FirewallRuleResource_validation(ctx, field, obj)
		case "deployment":
			out.Values[i] = ec._FirewallRuleResource_deployment(ctx, field, obj)
		case "runtime":
			out.Values[i] = ec._FirewallRuleResource_runtime(ctx, field, obj)
		case "telemetry":
			out.Values[i] = ec._FirewallRuleResource_telemetry(ctx, field, obj)
		case "metadata":
			out.Values[i] = ec._FirewallRuleResource_metadata(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "relationships":
			out.Values[i] = ec._FirewallRuleResource_relationships(ctx, field, obj)
		case "platform":
			out.Values[i] = ec._FirewallRuleResource_platform(ctx, field, obj)
		case "chain":
			out.Values[i] = ec._FirewallRuleResource_chain(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "action":
			out.Values[i] = ec._FirewallRuleResource_action(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "srcAddress":
			out.Values[i] = ec._FirewallRuleResource_srcAddress(ctx, field, obj)
		case "dstAddress":
			out.Values[i] = ec._FirewallRuleResource_dstAddress(ctx, field, obj)
		case "srcPort":
			out.Values[i] = ec._FirewallRuleResource_srcPort(ctx, field, obj)
		case "dstPort":
			out.Values[i] = ec._FirewallRuleResource_dstPort(ctx, field, obj)
		case "protocol":
			out.Values[i] = ec._FirewallRuleResource_protocol(ctx, field, obj)
		case "comment":
			out.Values[i] = ec._FirewallRuleResource_comment(ctx, field, obj)
		case "enabled":
			out.Values[i] = ec._FirewallRuleResource_enabled(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "hitCount":
			out.Values[i] = ec._FirewallRuleResource_hitCount(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var gatewayReachabilityResultImplementors = []string{"GatewayReachabilityResult"}

func (ec *executionContext) _GatewayReachabilityResult(ctx context.Context, sel ast.SelectionSet, obj *model.GatewayReachabilityResult) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, gatewayReachabilityResultImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GatewayReachabilityResult")
		case "reachable":
			out.Values[i] = ec._GatewayReachabilityResult_reachable(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "latency":
			out.Values[i] = ec._GatewayReachabilityResult_latency(ctx, field, obj)
		case "interface":
			out.Values[i] = ec._GatewayReachabilityResult_interface(ctx, field, obj)
		case "message":
			out.Values[i] = ec._GatewayReachabilityResult_message(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var hardwareInfoImplementors = []string{"HardwareInfo"}

func (ec *executionContext) _HardwareInfo(ctx context.Context, sel ast.SelectionSet, obj *model.HardwareInfo) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, hardwareInfoImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("HardwareInfo")
		case "architecture":
			out.Values[i] = ec._HardwareInfo_architecture(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "model":
			out.Values[i] = ec._HardwareInfo_model(ctx, field, obj)
		case "boardName":
			out.Values[i] = ec._HardwareInfo_boardName(ctx, field, obj)
		case "totalMemory":
			out.Values[i] = ec._HardwareInfo_totalMemory(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "availableStorage":
			out.Values[i] = ec._HardwareInfo_availableStorage(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "cpuCount":
			out.Values[i] = ec._HardwareInfo_cpuCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "hasWirelessChip":
			out.Values[i] = ec._HardwareInfo_hasWirelessChip(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "hasLTEModule":
			out.Values[i] = ec._HardwareInfo_hasLTEModule(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var healthCheckResultImplementors = []string{"HealthCheckResult"}

func (ec *executionContext) _HealthCheckResult(ctx context.Context, sel ast.SelectionSet, obj *model.HealthCheckResult) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, healthCheckResultImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("HealthCheckResult")
		case "routerId":
			out.Values[i] = ec._HealthCheckResult_routerId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "healthy":
			out.Values[i] = ec._HealthCheckResult_healthy(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "checkedAt":
			out.Values[i] = ec._HealthCheckResult_checkedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "responseTimeMs":
			out.Values[i] = ec._HealthCheckResult_responseTimeMs(ctx, field, obj)
		case "error":
			out.Values[i] = ec._HealthCheckResult_error(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var healthStatusImplementors = []string{"HealthStatus"}

func (ec *executionContext) _HealthStatus(ctx context.Context, sel ast.SelectionSet, obj *model.HealthStatus) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, healthStatusImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("HealthStatus")
		case "status":
			out.Values[i] = ec._HealthStatus_status(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "version":
			out.Values[i] = ec._HealthStatus_version(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "uptime":
			out.Values[i] = ec._HealthStatus_uptime(ctx, field, obj)
		case "connectedRouters":
			out.Values[i] = ec._HealthStatus_connectedRouters(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "checkedAt":
			out.Values[i] = ec._HealthStatus_checkedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var hopProbeImplementors = []string{"HopProbe"}

func (ec *executionContext) _HopProbe(ctx context.Context, sel ast.SelectionSet, obj *model.HopProbe) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, hopProbeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("HopProbe")
		case "probeNumber":
			out.Values[i] = ec._HopProbe_probeNumber(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "latencyMs":
			out.Values[i] = ec._HopProbe_latencyMs(ctx, field, obj)
		case "success":
			out.Values[i] = ec._HopProbe_success(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "icmpCode":
			out.Values[i] = ec._HopProbe_icmpCode(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var hourlyStatsImplementors = []string{"HourlyStats"}

func (ec *executionContext) _HourlyStats(ctx context.Context, sel ast.SelectionSet, obj *model.HourlyStats) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, hourlyStatsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("HourlyStats")
		case "hour":
			out.Values[i] = ec._HourlyStats_hour(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "totalBytesIn":
			out.Values[i] = ec._HourlyStats_totalBytesIn(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "totalBytesOut":
			out.Values[i] = ec._HourlyStats_totalBytesOut(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "uptimePercent":
			out.Values[i] = ec._HourlyStats_uptimePercent(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "errorCount":
			out.Values[i] = ec._HourlyStats_errorCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var iSPInfoImplementors = []string{"ISPInfo"}

func (ec *executionContext) _ISPInfo(ctx context.Context, sel ast.SelectionSet, obj *model.ISPInfo) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, iSPInfoImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ISPInfo")
		case "name":
			out.Values[i] = ec._ISPInfo_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "phone":
			out.Values[i] = ec._ISPInfo_phone(ctx, field, obj)
		case "url":
			out.Values[i] = ec._ISPInfo_url(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var interfaceImplementors = []string{"Interface", "Node"}

func (ec *executionContext) _Interface(ctx context.Context, sel ast.SelectionSet, obj *model.Interface) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, interfaceImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Interface")
		case "id":
			out.Values[i] = ec._Interface_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec._Interface_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "type":
			out.Values[i] = ec._Interface_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "enabled":
			out.Values[i] = ec._Interface_enabled(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "running":
			out.Values[i] = ec._Interface_running(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "macAddress":
			out.Values[i] = ec._Interface_macAddress(ctx, field, obj)
		case "mtu":
			out.Values[i] = ec._Interface_mtu(ctx, field, obj)
		case "comment":
			out.Values[i] = ec._Interface_comment(ctx, field, obj)
		case "txBytes":
			out.Values[i] = ec._Interface_txBytes(ctx, field, obj)
		case "rxBytes":
			out.Values[i] = ec._Interface_rxBytes(ctx, field, obj)
		case "ip":
			out.Values[i] = ec._Interface_ip(ctx, field, obj)
		case "status":
			out.Values[i] = ec._Interface_status(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "txRate":
			out.Values[i] = ec._Interface_txRate(ctx, field, obj)
		case "rxRate":
			out.Values[i] = ec._Interface_rxRate(ctx, field, obj)
		case "linkSpeed":
			out.Values[i] = ec._Interface_linkSpeed(ctx, field, obj)
		case "lastSeen":
			out.Values[i] = ec._Interface_lastSeen(ctx, field, obj)
		case "linkPartner":
			out.Values[i] = ec._Interface_linkPartner(ctx, field, obj)
		case "usedBy":
			out.Values[i] = ec._Interface_usedBy(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var interfaceConnectionImplementors = []string{"InterfaceConnection", "Connection"}

func (ec *executionContext) _InterfaceConnection(ctx context.Context, sel ast.SelectionSet, obj *model.InterfaceConnection) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, interfaceConnectionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("InterfaceConnection")
		case "edges":
			out.Values[i] = ec._InterfaceConnection_edges(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "pageInfo":
			out.Values[i] = ec._InterfaceConnection_pageInfo(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "totalCount":
			out.Values[i] = ec._InterfaceConnection_totalCount(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var interfaceEdgeImplementors = []string{"InterfaceEdge", "Edge"}

func (ec *executionContext) _InterfaceEdge(ctx context.Context, sel ast.SelectionSet, obj *model.InterfaceEdge) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, interfaceEdgeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("InterfaceEdge")
		case "node":
			out.Values[i] = ec._InterfaceEdge_node(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "cursor":
			out.Values[i] = ec._InterfaceEdge_cursor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var interfaceOperationErrorImplementors = []string{"InterfaceOperationError"}

func (ec *executionContext) _InterfaceOperationError(ctx context.Context, sel ast.SelectionSet, obj *model.InterfaceOperationError) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, interfaceOperationErrorImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("InterfaceOperationError")
		case "interfaceId":
			out.Values[i] = ec._InterfaceOperationError_interfaceId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "interfaceName":
			out.Values[i] = ec._InterfaceOperationError_interfaceName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "error":
			out.Values[i] = ec._InterfaceOperationError_error(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var interfaceStatsImplementors = []string{"InterfaceStats"}

func (ec *executionContext) _InterfaceStats(ctx context.Context, sel ast.SelectionSet, obj *model.InterfaceStats) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, interfaceStatsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("InterfaceStats")
		case "txBytes":
			out.Values[i] = ec._InterfaceStats_txBytes(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "rxBytes":
			out.Values[i] = ec._InterfaceStats_rxBytes(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "txPackets":
			out.Values[i] = ec._InterfaceStats_txPackets(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "rxPackets":
			out.Values[i] = ec._InterfaceStats_rxPackets(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "txErrors":
			out.Values[i] = ec._InterfaceStats_txErrors(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "rxErrors":
			out.Values[i] = ec._InterfaceStats_rxErrors(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "txDrops":
			out.Values[i] = ec._InterfaceStats_txDrops(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "rxDrops":
			out.Values[i] = ec._InterfaceStats_rxDrops(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var interfaceStatsHistoryImplementors = []string{"InterfaceStatsHistory"}

func (ec *executionContext) _InterfaceStatsHistory(ctx context.Context, sel ast.SelectionSet, obj *model.InterfaceStatsHistory) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, interfaceStatsHistoryImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("InterfaceStatsHistory")
		case "interfaceId":
			out.Values[i] = ec._InterfaceStatsHistory_interfaceId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "dataPoints":
			out.Values[i] = ec._InterfaceStatsHistory_dataPoints(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "interval":
			out.Values[i] = ec._InterfaceStatsHistory_interval(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "startTime":
			out.Values[i] = ec._InterfaceStatsHistory_startTime(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "endTime":
			out.Values[i] = ec._InterfaceStatsHistory_endTime(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var interfaceStatusEventImplementors = []string{"InterfaceStatusEvent"}

func (ec *executionContext) _InterfaceStatusEvent(ctx context.Context, sel ast.SelectionSet, obj *model.InterfaceStatusEvent) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, interfaceStatusEventImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("InterfaceStatusEvent")
		case "interfaceId":
			out.Values[i] = ec._InterfaceStatusEvent_interfaceId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "interfaceName":
			out.Values[i] = ec._InterfaceStatusEvent_interfaceName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "status":
			out.Values[i] = ec._InterfaceStatusEvent_status(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "previousStatus":
			out.Values[i] = ec._InterfaceStatusEvent_previousStatus(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "timestamp":
			out.Values[i] = ec._InterfaceStatusEvent_timestamp(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var interfaceTrafficEventImplementors = []string{"InterfaceTrafficEvent"}

func (ec *executionContext) _InterfaceTrafficEvent(ctx context.Context, sel ast.SelectionSet, obj *model.InterfaceTrafficEvent) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, interfaceTrafficEventImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("InterfaceTrafficEvent")
		case "interfaceId":
			out.Values[i] = ec._InterfaceTrafficEvent_interfaceId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "interfaceName":
			out.Values[i] = ec._InterfaceTrafficEvent_interfaceName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "txRate":
			out.Values[i] = ec._InterfaceTrafficEvent_txRate(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "rxRate":
			out.Values[i] = ec._InterfaceTrafficEvent_rxRate(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "txTotal":
			out.Values[i] = ec._InterfaceTrafficEvent_txTotal(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "rxTotal":
			out.Values[i] = ec._InterfaceTrafficEvent_rxTotal(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "timestamp":
			out.Values[i] = ec._InterfaceTrafficEvent_timestamp(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var ipAddressImplementors = []string{"IpAddress", "Node"}

func (ec *executionContext) _IpAddress(ctx context.Context, sel ast.SelectionSet, obj *model.IPAddress) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, ipAddressImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("IpAddress")
		case "id":
			out.Values[i] = ec._IpAddress_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "address":
			out.Values[i] = ec._IpAddress_address(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "network":
			out.Values[i] = ec._IpAddress_network(ctx, field, obj)
		case "broadcast":
			out.Values[i] = ec._IpAddress_broadcast(ctx, field, obj)
		case "interface":
			out.Values[i] = ec._IpAddress_interface(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "disabled":
			out.Values[i] = ec._IpAddress_disabled(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "dynamic":
			out.Values[i] = ec._IpAddress_dynamic(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "invalid":
			out.Values[i] = ec._IpAddress_invalid(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "comment":
			out.Values[i] = ec._IpAddress_comment(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var ipAddressChangeEventImplementors = []string{"IpAddressChangeEvent"}

func (ec *executionContext) _IpAddressChangeEvent(ctx context.Context, sel ast.SelectionSet, obj *model.IPAddressChangeEvent) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, ipAddressChangeEventImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("IpAddressChangeEvent")
		case "changeType":
			out.Values[i] = ec._IpAddressChangeEvent_changeType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "ipAddress":
			out.Values[i] = ec._IpAddressChangeEvent_ipAddress(ctx, field, obj)
		case "ipAddressId":
			out.Values[i] = ec._IpAddressChangeEvent_ipAddressId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "timestamp":
			out.Values[i] = ec._IpAddressChangeEvent_timestamp(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var ipAddressDeleteResultImplementors = []string{"IpAddressDeleteResult"}

func (ec *executionContext) _IpAddressDeleteResult(ctx context.Context, sel ast.SelectionSet, obj *model.IPAddressDeleteResult) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, ipAddressDeleteResultImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("IpAddressDeleteResult")
		case "success":
			out.Values[i] = ec._IpAddressDeleteResult_success(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "message":
			out.Values[i] = ec._IpAddressDeleteResult_message(ctx, field, obj)
		case "impactAnalysis":
			out.Values[i] = ec._IpAddressDeleteResult_impactAnalysis(ctx, field, obj)
		case "errors":
			out.Values[i] = ec._IpAddressDeleteResult_errors(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var ipAddressDependenciesImplementors = []string{"IpAddressDependencies"}

func (ec *executionContext) _IpAddressDependencies(ctx context.Context, sel ast.SelectionSet, obj *model.IPAddressDependencies) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, ipAddressDependenciesImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("IpAddressDependencies")
		case "ipAddressId":
			out.Values[i] = ec._IpAddressDependencies_ipAddressId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "dhcpServers":
			out.Values[i] = ec._IpAddressDependencies_dhcpServers(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "routes":
			out.Values[i] = ec._IpAddressDependencies_routes(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "natRules":
			out.Values[i] = ec._IpAddressDependencies_natRules(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "firewallRules":
			out.Values[i] = ec._IpAddressDependencies_firewallRules(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "hasDependencies":
			out.Values[i] = ec._IpAddressDependencies_hasDependencies(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var ipAddressImpactAnalysisImplementors = []string{"IpAddressImpactAnalysis"}

func (ec *executionContext) _IpAddressImpactAnalysis(ctx context.Context, sel ast.SelectionSet, obj *model.IPAddressImpactAnalysis) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, ipAddressImpactAnalysisImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("IpAddressImpactAnalysis")
		case "usedByDhcpServers":
			out.Values[i] = ec._IpAddressImpactAnalysis_usedByDhcpServers(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "usedInFirewallRules":
			out.Values[i] = ec._IpAddressImpactAnalysis_usedInFirewallRules(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "usedInNatRules":
			out.Values[i] = ec._IpAddressImpactAnalysis_usedInNatRules(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "activeConnections":
			out.Values[i] = ec._IpAddressImpactAnalysis_activeConnections(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "severity":
			out.Values[i] = ec._IpAddressImpactAnalysis_severity(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "message":
			out.Values[i] = ec._IpAddressImpactAnalysis_message(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "consequences":
			out.Values[i] = ec._IpAddressImpactAnalysis_consequences(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "canDelete":
			out.Values[i] = ec._IpAddressImpactAnalysis_canDelete(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var ipAddressMutationResultImplementors = []string{"IpAddressMutationResult"}

func (ec *executionContext) _IpAddressMutationResult(ctx context.Context, sel ast.SelectionSet, obj *model.IPAddressMutationResult) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, ipAddressMutationResultImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("IpAddressMutationResult")
		case "success":
			out.Values[i] = ec._IpAddressMutationResult_success(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "ipAddress":
			out.Values[i] = ec._IpAddressMutationResult_ipAddress(ctx, field, obj)
		case "preview":
			out.Values[i] = ec._IpAddressMutationResult_preview(ctx, field, obj)
		case "errors":
			out.Values[i] = ec._IpAddressMutationResult_errors(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var ipConflictImplementors = []string{"IpConflict"}

func (ec *executionContext) _IpConflict(ctx context.Context, sel ast.SelectionSet, obj *model.IPConflict) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, ipConflictImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("IpConflict")
		case "id":
			out.Values[i] = ec._IpConflict_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "address":
			out.Values[i] = ec._IpConflict_address(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "interface":
			out.Values[i] = ec._IpConflict_interface(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "conflictType":
			out.Values[i] = ec._IpConflict_conflictType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "explanation":
			out.Values[i] = ec._IpConflict_explanation(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var ipConflictResultImplementors = []string{"IpConflictResult"}

func (ec *executionContext) _IpConflictResult(ctx context.Context, sel ast.SelectionSet, obj *model.IPConflictResult) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, ipConflictResultImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("IpConflictResult")
		case "hasConflict":
			out.Values[i] = ec._IpConflictResult_hasConflict(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "conflicts":
			out.Values[i] = ec._IpConflictResult_conflicts(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "message":
			out.Values[i] = ec._IpConflictResult_message(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var lANNetworkImplementors = []string{"LANNetwork", "Resource", "Node"}

func (ec *executionContext) _LANNetwork(ctx context.Context, sel ast.SelectionSet, obj *model.LANNetwork) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, lANNetworkImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("LANNetwork")
		case "id":
			out.Values[i] = ec._LANNetwork_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "scopedId":
			out.Values[i] = ec._LANNetwork_scopedId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "type":
			out.Values[i] = ec._LANNetwork_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "category":
			out.Values[i] = ec._LANNetwork_category(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "configuration":
			out.Values[i] = ec._LANNetwork_configuration(ctx, field, obj)
		case "validation":
			out.Values[i] = ec._LANNetwork_validation(ctx, field, obj)
		case "deployment":
			out.Values[i] = ec._LANNetwork_deployment(ctx, field, obj)
		case "runtime":
			out.Values[i] = ec._LANNetwork_runtime(ctx, field, obj)
		case "telemetry":
			out.Values[i] = ec._LANNetwork_telemetry(ctx, field, obj)
		case "metadata":
			out.Values[i] = ec._LANNetwork_metadata(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "relationships":
			out.Values[i] = ec._LANNetwork_relationships(ctx, field, obj)
		case "platform":
			out.Values[i] = ec._LANNetwork_platform(ctx, field, obj)
		case "config":
			out.Values[i] = ec._LANNetwork_config(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "lanDeployment":
			out.Values[i] = ec._LANNetwork_lanDeployment(ctx, field, obj)
		case "lanRuntime":
			out.Values[i] = ec._LANNetwork_lanRuntime(ctx, field, obj)
		case "bridge":
			out.Values[i] = ec._LANNetwork_bridge(ctx, field, obj)
		case "dhcpServer":
			out.Values[i] = ec._LANNetwork_dhcpServer(ctx, field, obj)
		case "firewallRules":
			out.Values[i] = ec._LANNetwork_firewallRules(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "routes":
			out.Values[i] = ec._LANNetwork_routes(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var lANNetworkConfigImplementors = []string{"LANNetworkConfig"}

func (ec *executionContext) _LANNetworkConfig(ctx context.Context, sel ast.SelectionSet, obj *model.LANNetworkConfig) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, lANNetworkConfigImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("LANNetworkConfig")
		case "name":
			out.Values[i] = ec._LANNetworkConfig_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "ipAddress":
			out.Values[i] = ec._LANNetworkConfig_ipAddress(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "subnetMask":
			out.Values[i] = ec._LANNetworkConfig_subnetMask(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "interfaces":
			out.Values[i] = ec._LANNetworkConfig_interfaces(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "dhcpEnabled":
			out.Values[i] = ec._LANNetworkConfig_dhcpEnabled(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "dhcpPoolStart":
			out.Values[i] = ec._LANNetworkConfig_dhcpPoolStart(ctx, field, obj)
		case "dhcpPoolEnd":
			out.Values[i] = ec._LANNetworkConfig_dhcpPoolEnd(ctx, field, obj)
		case "dhcpLeaseTime":
			out.Values[i] = ec._LANNetworkConfig_dhcpLeaseTime(ctx, field, obj)
		case "dnsServers":
			out.Values[i] = ec._LANNetworkConfig_dnsServers(ctx, field, obj)
		case "enableNat":
			out.Values[i] = ec._LANNetworkConfig_enableNat(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "vlanId":
			out.Values[i] = ec._LANNetworkConfig_vlanId(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var lANNetworkDeploymentImplementors = []string{"LANNetworkDeployment"}

func (ec *executionContext) _LANNetworkDeployment(ctx context.Context, sel ast.SelectionSet, obj *model.LANNetworkDeployment) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, lANNetworkDeploymentImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("LANNetworkDeployment")
		case "routerResourceId":
			out.Values[i] = ec._LANNetworkDeployment_routerResourceId(ctx, field, obj)
		case "appliedAt":
			out.Values[i] = ec._LANNetworkDeployment_appliedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "appliedBy":
			out.Values[i] = ec._LANNetworkDeployment_appliedBy(ctx, field, obj)
		case "routerVersion":
			out.Values[i] = ec._LANNetworkDeployment_routerVersion(ctx, field, obj)
		case "isInSync":
			out.Values[i] = ec._LANNetworkDeployment_isInSync(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "drift":
			out.Values[i] = ec._LANNetworkDeployment_drift(ctx, field, obj)
		case "bridgeId":
			out.Values[i] = ec._LANNetworkDeployment_bridgeId(ctx, field, obj)
		case "dhcpServerId":
			out.Values[i] = ec._LANNetworkDeployment_dhcpServerId(ctx, field, obj)
		case "ipAddressId":
			out.Values[i] = ec._LANNetworkDeployment_ipAddressId(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var lANNetworkRuntimeImplementors = []string{"LANNetworkRuntime"}

func (ec *executionContext) _LANNetworkRuntime(ctx context.Context, sel ast.SelectionSet, obj *model.LANNetworkRuntime) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, lANNetworkRuntimeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("LANNetworkRuntime")
		case "isRunning":
			out.Values[i] = ec._LANNetworkRuntime_isRunning(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "health":
			out.Values[i] = ec._LANNetworkRuntime_health(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "errorMessage":
			out.Values[i] = ec._LANNetworkRuntime_errorMessage(ctx, field, obj)
		case "lastUpdated":
			out.Values[i] = ec._LANNetworkRuntime_lastUpdated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "activeClients":
			out.Values[i] = ec._LANNetworkRuntime_activeClients(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "dhcpLeases":
			out.Values[i] = ec._LANNetworkRuntime_dhcpLeases(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "totalBytesIn":
			out.Values[i] = ec._LANNetworkRuntime_totalBytesIn(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "totalBytesOut":
			out.Values[i] = ec._LANNetworkRuntime_totalBytesOut(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var lteModemImplementors = []string{"LteModem", "Node"}

func (ec *executionContext) _LteModem(ctx context.Context, sel ast.SelectionSet, obj *model.LteModem) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, lteModemImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("LteModem")
		case "id":
			out.Values[i] = ec._LteModem_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec._LteModem_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "apn":
			out.Values[i] = ec._LteModem_apn(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "signalStrength":
			out.Values[i] = ec._LteModem_signalStrength(ctx, field, obj)
		case "running":
			out.Values[i] = ec._LteModem_running(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "operator":
			out.Values[i] = ec._LteModem_operator(ctx, field, obj)
		case "networkType":
			out.Values[i] = ec._LteModem_networkType(ctx, field, obj)
		case "pinConfigured":
			out.Values[i] = ec._LteModem_pinConfigured(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "comment":
			out.Values[i] = ec._LteModem_comment(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var memoryMetricsImplementors = []string{"MemoryMetrics"}

func (ec *executionContext) _MemoryMetrics(ctx context.Context, sel ast.SelectionSet, obj *model.MemoryMetrics) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, memoryMetricsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("MemoryMetrics")
		case "used":
			out.Values[i] = ec._MemoryMetrics_used(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "total":
			out.Values[i] = ec._MemoryMetrics_total(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "percentage":
			out.Values[i] = ec._MemoryMetrics_percentage(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var missingDependencyImplementors = []string{"MissingDependency"}

func (ec *executionContext) _MissingDependency(ctx context.Context, sel ast.SelectionSet, obj *model.MissingDependency) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, missingDependencyImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("MissingDependency")
		case "itemId":
			out.Values[i] = ec._MissingDependency_itemId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "missingResourceType":
			out.Values[i] = ec._MissingDependency_missingResourceType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "missingResourceId":
			out.Values[i] = ec._MissingDependency_missingResourceId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var mutationImplementors = []string{"Mutation"}

func (ec *executionContext) _Mutation(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, mutationImplementors)
	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Mutation",
	})

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		innerCtx := graphql.WithRootFieldContext(ctx, &graphql.RootFieldContext{
			Object: field.Name,
			Field:  field,
		})

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Mutation")
		case "createRouter":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createRouter(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updateRouter":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateRouter(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deleteRouter":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_deleteRouter(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "testRouterConnection":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_testRouterConnection(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "connectRouter":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_connectRouter(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "disconnectRouter":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_disconnectRouter(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "refreshCapabilities":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_refreshCapabilities(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updateInterface":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateInterface(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "enableInterface":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_enableInterface(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "disableInterface":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_disableInterface(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "batchInterfaceOperation":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_batchInterfaceOperation(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "login":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_login(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "logout":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_logout(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "changePassword":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_changePassword(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "revokeAllSessions":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_revokeAllSessions(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "revokeSession":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_revokeSession(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "setPreferredProtocol":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_setPreferredProtocol(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "reconnectRouter":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_reconnectRouter(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "checkRouterHealth":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_checkRouterHealth(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updateRouterCredentials":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateRouterCredentials(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "testAllCredentials":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_testAllCredentials(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "exportRouterConfig":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_exportRouterConfig(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "scanNetwork":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_scanNetwork(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "autoScanGateways":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_autoScanGateways(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "cancelScan":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_cancelScan(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createChangeSet":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createChangeSet(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "addChangeSetItem":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_addChangeSetItem(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updateChangeSetItem":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateChangeSetItem(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "removeChangeSetItem":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_removeChangeSetItem(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "validateChangeSet":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_validateChangeSet(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "applyChangeSet":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_applyChangeSet(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "cancelChangeSet":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_cancelChangeSet(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "rollbackChangeSet":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_rollbackChangeSet(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deleteChangeSet":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_deleteChangeSet(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "runDiagnostics":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_runDiagnostics(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "resetCircuitBreaker":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_resetCircuitBreaker(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "startTroubleshoot":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_startTroubleshoot(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "runTroubleshootStep":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_runTroubleshootStep(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "applyTroubleshootFix":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_applyTroubleshootFix(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "verifyTroubleshootFix":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_verifyTroubleshootFix(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "cancelTroubleshoot":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_cancelTroubleshoot(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "runTraceroute":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_runTraceroute(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "cancelTraceroute":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_cancelTraceroute(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "runDnsLookup":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_runDnsLookup(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createAlertRule":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createAlertRule(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updateAlertRule":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateAlertRule(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deleteAlertRule":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_deleteAlertRule(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "acknowledgeAlert":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_acknowledgeAlert(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "acknowledgeAlerts":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_acknowledgeAlerts(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "testNotificationChannel":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_testNotificationChannel(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "addRouter":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_addRouter(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "testRouterCredentials":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_testRouterCredentials(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createResource":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createResource(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updateResource":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateResource(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "validateResource":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_validateResource(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "applyResource":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_applyResource(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deprecateResource":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_deprecateResource(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "archiveResource":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_archiveResource(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deleteResource":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_deleteResource(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createIpAddress":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createIpAddress(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updateIpAddress":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateIpAddress(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deleteIpAddress":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_deleteIpAddress(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createVlan":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createVlan(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updateVlan":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateVlan(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deleteVlan":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_deleteVlan(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "configureBridgePortVlan":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_configureBridgePortVlan(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createRoute":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createRoute(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updateRoute":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateRoute(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deleteRoute":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_deleteRoute(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createBridge":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createBridge(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updateBridge":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateBridge(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deleteBridge":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_deleteBridge(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "undoBridgeOperation":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_undoBridgeOperation(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "addBridgePort":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_addBridgePort(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updateBridgePort":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateBridgePort(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "removeBridgePort":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_removeBridgePort(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createBridgeVlan":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createBridgeVlan(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deleteBridgeVlan":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_deleteBridgeVlan(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "configureDhcpWAN":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_configureDhcpWAN(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "configurePppoeWAN":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_configurePppoeWAN(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "configureStaticWAN":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_configureStaticWAN(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "configureLteWAN":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_configureLteWAN(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "configureWANHealthCheck":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_configureWANHealthCheck(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deleteWANConfiguration":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_deleteWANConfiguration(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var mutationErrorImplementors = []string{"MutationError"}

func (ec *executionContext) _MutationError(ctx context.Context, sel ast.SelectionSet, obj *model.MutationError) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, mutationErrorImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("MutationError")
		case "code":
			out.Values[i] = ec._MutationError_code(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "message":
			out.Values[i] = ec._MutationError_message(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "field":
			out.Values[i] = ec._MutationError_field(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var natRuleImplementors = []string{"NatRule"}

func (ec *executionContext) _NatRule(ctx context.Context, sel ast.SelectionSet, obj *model.NatRule) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, natRuleImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("NatRule")
		case "id":
			out.Values[i] = ec._NatRule_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "chain":
			out.Values[i] = ec._NatRule_chain(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "action":
			out.Values[i] = ec._NatRule_action(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "srcAddress":
			out.Values[i] = ec._NatRule_srcAddress(ctx, field, obj)
		case "dstAddress":
			out.Values[i] = ec._NatRule_dstAddress(ctx, field, obj)
		case "toAddress":
			out.Values[i] = ec._NatRule_toAddress(ctx, field, obj)
		case "disabled":
			out.Values[i] = ec._NatRule_disabled(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var networkConfigDetectionImplementors = []string{"NetworkConfigDetection"}

func (ec *executionContext) _NetworkConfigDetection(ctx context.Context, sel ast.SelectionSet, obj *model.NetworkConfigDetection) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, networkConfigDetectionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("NetworkConfigDetection")
		case "wanInterface":
			out.Values[i] = ec._NetworkConfigDetection_wanInterface(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "gateway":
			out.Values[i] = ec._NetworkConfigDetection_gateway(ctx, field, obj)
		case "ispInfo":
			out.Values[i] = ec._NetworkConfigDetection_ispInfo(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var operationCountsImplementors = []string{"OperationCounts"}

func (ec *executionContext) _OperationCounts(ctx context.Context, sel ast.SelectionSet, obj *model.OperationCounts) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, operationCountsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("OperationCounts")
		case "create":
			out.Values[i] = ec._OperationCounts_create(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "update":
			out.Values[i] = ec._OperationCounts_update(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "delete":
			out.Values[i] = ec._OperationCounts_delete(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var pageInfoImplementors = []string{"PageInfo"}

func (ec *executionContext) _PageInfo(ctx context.Context, sel ast.SelectionSet, obj *model.PageInfo) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, pageInfoImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PageInfo")
		case "hasNextPage":
			out.Values[i] = ec._PageInfo_hasNextPage(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "hasPreviousPage":
			out.Values[i] = ec._PageInfo_hasPreviousPage(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "startCursor":
			out.Values[i] = ec._PageInfo_startCursor(ctx, field, obj)
		case "endCursor":
			out.Values[i] = ec._PageInfo_endCursor(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var platformCapabilitiesImplementors = []string{"PlatformCapabilities"}

func (ec *executionContext) _PlatformCapabilities(ctx context.Context, sel ast.SelectionSet, obj *model.PlatformCapabilities) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, platformCapabilitiesImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PlatformCapabilities")
		case "isSupported":
			out.Values[i] = ec._PlatformCapabilities_isSupported(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "level":
			out.Values[i] = ec._PlatformCapabilities_level(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "minVersion":
			out.Values[i] = ec._PlatformCapabilities_minVersion(ctx, field, obj)
		case "requiredPackages":
			out.Values[i] = ec._PlatformCapabilities_requiredPackages(ctx, field, obj)
		case "details":
			out.Values[i] = ec._PlatformCapabilities_details(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var platformFeatureImplementors = []string{"PlatformFeature"}

func (ec *executionContext) _PlatformFeature(ctx context.Context, sel ast.SelectionSet, obj *model.PlatformFeature) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, platformFeatureImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PlatformFeature")
		case "id":
			out.Values[i] = ec._PlatformFeature_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec._PlatformFeature_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "enabled":
			out.Values[i] = ec._PlatformFeature_enabled(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec._PlatformFeature_description(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var platformInfoImplementors = []string{"PlatformInfo"}

func (ec *executionContext) _PlatformInfo(ctx context.Context, sel ast.SelectionSet, obj *model.PlatformInfo) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, platformInfoImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PlatformInfo")
		case "current":
			out.Values[i] = ec._PlatformInfo_current(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "capabilities":
			out.Values[i] = ec._PlatformInfo_capabilities(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "fieldMappings":
			out.Values[i] = ec._PlatformInfo_fieldMappings(ctx, field, obj)
		case "limitations":
			out.Values[i] = ec._PlatformInfo_limitations(ctx, field, obj)
		case "features":
			out.Values[i] = ec._PlatformInfo_features(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var platformLimitationImplementors = []string{"PlatformLimitation"}

func (ec *executionContext) _PlatformLimitation(ctx context.Context, sel ast.SelectionSet, obj *model.PlatformLimitation) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, platformLimitationImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PlatformLimitation")
		case "code":
			out.Values[i] = ec._PlatformLimitation_code(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec._PlatformLimitation_description(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "affectedFields":
			out.Values[i] = ec._PlatformLimitation_affectedFields(ctx, field, obj)
		case "workaround":
			out.Values[i] = ec._PlatformLimitation_workaround(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var portStatusImplementors = []string{"PortStatus"}

func (ec *executionContext) _PortStatus(ctx context.Context, sel ast.SelectionSet, obj *model.PortStatus) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, portStatusImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PortStatus")
		case "port":
			out.Values[i] = ec._PortStatus_port(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "service":
			out.Values[i] = ec._PortStatus_service(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "open":
			out.Values[i] = ec._PortStatus_open(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "responseTimeMs":
			out.Values[i] = ec._PortStatus_responseTimeMs(ctx, field, obj)
		case "error":
			out.Values[i] = ec._PortStatus_error(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var pppoeClientImplementors = []string{"PppoeClient", "Node"}

func (ec *executionContext) _PppoeClient(ctx context.Context, sel ast.SelectionSet, obj *model.PppoeClient) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, pppoeClientImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PppoeClient")
		case "id":
			out.Values[i] = ec._PppoeClient_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec._PppoeClient_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "interface":
			out.Values[i] = ec._PppoeClient_interface(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "disabled":
			out.Values[i] = ec._PppoeClient_disabled(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "username":
			out.Values[i] = ec._PppoeClient_username(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "serviceName":
			out.Values[i] = ec._PppoeClient_serviceName(ctx, field, obj)
		case "addDefaultRoute":
			out.Values[i] = ec._PppoeClient_addDefaultRoute(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "usePeerDNS":
			out.Values[i] = ec._PppoeClient_usePeerDNS(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "running":
			out.Values[i] = ec._PppoeClient_running(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "mtu":
			out.Values[i] = ec._PppoeClient_mtu(ctx, field, obj)
		case "mru":
			out.Values[i] = ec._PppoeClient_mru(ctx, field, obj)
		case "comment":
			out.Values[i] = ec._PppoeClient_comment(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var queryImplementors = []string{"Query"}

func (ec *executionContext) _Query(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, queryImplementors)
	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Query",
	})

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		innerCtx := graphql.WithRootFieldContext(ctx, &graphql.RootFieldContext{
			Object: field.Name,
			Field:  field,
		})

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Query")
		case "node":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_node(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "health":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_health(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "version":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_version(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "device":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_device(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "router":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_router(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "routers":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_routers(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "interface":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_interface(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "interfaces":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_interfaces(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "routerCapabilities":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_routerCapabilities(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "isFeatureSupported":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_isFeatureSupported(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "supportedFeatures":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_supportedFeatures(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "unsupportedFeatures":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_unsupportedFeatures(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "compatibilityMatrix":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_compatibilityMatrix(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "upgradeRecommendation":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_upgradeRecommendation(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "upgradeRecommendations":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_upgradeRecommendations(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "me":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_me(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "mySessions":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_mySessions(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "connectionDetails":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_connectionDetails(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "routerHealth":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_routerHealth(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "connectionStats":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_connectionStats(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "routerCredentials":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_routerCredentials(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "scanStatus":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_scanStatus(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "scanHistory":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_scanHistory(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "changeSet":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_changeSet(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "changeSets":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_changeSets(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "connectionAttempts":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_connectionAttempts(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "circuitBreakerStatus":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_circuitBreakerStatus(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "troubleshootSession":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_troubleshootSession(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "detectWanInterface":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_detectWanInterface(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "detectGateway":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_detectGateway(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "detectISP":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_detectISP(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "dnsServers":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_dnsServers(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "alertRules":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_alertRules(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "alertRule":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_alertRule(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "alerts":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_alerts(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "resource":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_resource(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "resources":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_resources(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "compositeResource":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_compositeResource(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "ipAddresses":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_ipAddresses(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "ipAddress":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_ipAddress(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "checkIpConflict":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_checkIpConflict(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "ipAddressDependencies":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_ipAddressDependencies(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "vlans":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_vlans(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "vlan":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_vlan(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "checkVlanIdAvailable":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_checkVlanIdAvailable(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "vlanDependencies":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_vlanDependencies(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "vlanTopology":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_vlanTopology(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "routes":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_routes(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "route":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_route(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "checkGatewayReachability":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_checkGatewayReachability(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "interfaceStatsHistory":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_interfaceStatsHistory(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "bridges":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_bridges(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "bridge":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_bridge(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "bridgePorts":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_bridgePorts(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "bridgeVlans":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_bridgeVlans(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "availableInterfacesForBridge":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_availableInterfacesForBridge(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "wanInterfaces":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_wanInterfaces(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "wanInterface":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_wanInterface(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "wanConnectionHistory":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_wanConnectionHistory(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "__type":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Query___type(ctx, field)
			})
		case "__schema":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Query___schema(ctx, field)
			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var quietHoursConfigImplementors = []string{"QuietHoursConfig"}

func (ec *executionContext) _QuietHoursConfig(ctx context.Context, sel ast.SelectionSet, obj *model.QuietHoursConfig) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, quietHoursConfigImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("QuietHoursConfig")
		case "startTime":
			out.Values[i] = ec._QuietHoursConfig_startTime(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "endTime":
			out.Values[i] = ec._QuietHoursConfig_endTime(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "timezone":
			out.Values[i] = ec._QuietHoursConfig_timezone(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "bypassCritical":
			out.Values[i] = ec._QuietHoursConfig_bypassCritical(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var reconnectRouterPayloadImplementors = []string{"ReconnectRouterPayload"}

func (ec *executionContext) _ReconnectRouterPayload(ctx context.Context, sel ast.SelectionSet, obj *model.ReconnectRouterPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, reconnectRouterPayloadImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ReconnectRouterPayload")
		case "router":
			out.Values[i] = ec._ReconnectRouterPayload_router(ctx, field, obj)
		case "connectionDetails":
			out.Values[i] = ec._ReconnectRouterPayload_connectionDetails(ctx, field, obj)
		case "initiated":
			out.Values[i] = ec._ReconnectRouterPayload_initiated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "waitTimeMs":
			out.Values[i] = ec._ReconnectRouterPayload_waitTimeMs(ctx, field, obj)
		case "errors":
			out.Values[i] = ec._ReconnectRouterPayload_errors(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var refreshCapabilitiesPayloadImplementors = []string{"RefreshCapabilitiesPayload"}

func (ec *executionContext) _RefreshCapabilitiesPayload(ctx context.Context, sel ast.SelectionSet, obj *model.RefreshCapabilitiesPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, refreshCapabilitiesPayloadImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RefreshCapabilitiesPayload")
		case "capabilities":
			out.Values[i] = ec._RefreshCapabilitiesPayload_capabilities(ctx, field, obj)
		case "errors":
			out.Values[i] = ec._RefreshCapabilitiesPayload_errors(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var removeChangeSetItemPayloadImplementors = []string{"RemoveChangeSetItemPayload"}

func (ec *executionContext) _RemoveChangeSetItemPayload(ctx context.Context, sel ast.SelectionSet, obj *model.RemoveChangeSetItemPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, removeChangeSetItemPayloadImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RemoveChangeSetItemPayload")
		case "changeSet":
			out.Values[i] = ec._RemoveChangeSetItemPayload_changeSet(ctx, field, obj)
		case "errors":
			out.Values[i] = ec._RemoveChangeSetItemPayload_errors(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var resourceConflictImplementors = []string{"ResourceConflict"}

func (ec *executionContext) _ResourceConflict(ctx context.Context, sel ast.SelectionSet, obj *model.ResourceConflict) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, resourceConflictImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ResourceConflict")
		case "type":
			out.Values[i] = ec._ResourceConflict_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "conflictingResource":
			out.Values[i] = ec._ResourceConflict_conflictingResource(ctx, field, obj)
		case "conflictingResourceUuid":
			out.Values[i] = ec._ResourceConflict_conflictingResourceUuid(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec._ResourceConflict_description(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "resolution":
			out.Values[i] = ec._ResourceConflict_resolution(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var resourceConnectionImplementors = []string{"ResourceConnection", "Connection"}

func (ec *executionContext) _ResourceConnection(ctx context.Context, sel ast.SelectionSet, obj *model.ResourceConnection) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, resourceConnectionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ResourceConnection")
		case "edges":
			out.Values[i] = ec._ResourceConnection_edges(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "pageInfo":
			out.Values[i] = ec._ResourceConnection_pageInfo(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "totalCount":
			out.Values[i] = ec._ResourceConnection_totalCount(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var resourceEdgeImplementors = []string{"ResourceEdge", "Edge"}

func (ec *executionContext) _ResourceEdge(ctx context.Context, sel ast.SelectionSet, obj *model.ResourceEdge) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, resourceEdgeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ResourceEdge")
		case "cursor":
			out.Values[i] = ec._ResourceEdge_cursor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "node":
			out.Values[i] = ec._ResourceEdge_node(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var resourceMetadataImplementors = []string{"ResourceMetadata"}

func (ec *executionContext) _ResourceMetadata(ctx context.Context, sel ast.SelectionSet, obj *model.ResourceMetadata) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, resourceMetadataImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ResourceMetadata")
		case "createdAt":
			out.Values[i] = ec._ResourceMetadata_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createdBy":
			out.Values[i] = ec._ResourceMetadata_createdBy(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updatedAt":
			out.Values[i] = ec._ResourceMetadata_updatedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updatedBy":
			out.Values[i] = ec._ResourceMetadata_updatedBy(ctx, field, obj)
		case "state":
			out.Values[i] = ec._ResourceMetadata_state(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "version":
			out.Values[i] = ec._ResourceMetadata_version(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "tags":
			out.Values[i] = ec._ResourceMetadata_tags(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec._ResourceMetadata_description(ctx, field, obj)
		case "isFavorite":
			out.Values[i] = ec._ResourceMetadata_isFavorite(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "isPinned":
			out.Values[i] = ec._ResourceMetadata_isPinned(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "notes":
			out.Values[i] = ec._ResourceMetadata_notes(ctx, field, obj)
		case "recentChanges":
			out.Values[i] = ec._ResourceMetadata_recentChanges(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var resourceMetricsImplementors = []string{"ResourceMetrics"}

func (ec *executionContext) _ResourceMetrics(ctx context.Context, sel ast.SelectionSet, obj *model.ResourceMetrics) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, resourceMetricsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ResourceMetrics")
		case "cpu":
			out.Values[i] = ec._ResourceMetrics_cpu(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "memory":
			out.Values[i] = ec._ResourceMetrics_memory(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "storage":
			out.Values[i] = ec._ResourceMetrics_storage(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "temperature":
			out.Values[i] = ec._ResourceMetrics_temperature(ctx, field, obj)
		case "timestamp":
			out.Values[i] = ec._ResourceMetrics_timestamp(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var resourceReferenceImplementors = []string{"ResourceReference"}

func (ec *executionContext) _ResourceReference(ctx context.Context, sel ast.SelectionSet, obj *model.ResourceReference) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, resourceReferenceImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ResourceReference")
		case "uuid":
			out.Values[i] = ec._ResourceReference_uuid(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "id":
			out.Values[i] = ec._ResourceReference_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "type":
			out.Values[i] = ec._ResourceReference_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "category":
			out.Values[i] = ec._ResourceReference_category(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "state":
			out.Values[i] = ec._ResourceReference_state(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var resourceRelationshipEdgeImplementors = []string{"ResourceRelationshipEdge"}

func (ec *executionContext) _ResourceRelationshipEdge(ctx context.Context, sel ast.SelectionSet, obj *model.ResourceRelationshipEdge) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, resourceRelationshipEdgeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ResourceRelationshipEdge")
		case "from":
			out.Values[i] = ec._ResourceRelationshipEdge_from(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "to":
			out.Values[i] = ec._ResourceRelationshipEdge_to(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "type":
			out.Values[i] = ec._ResourceRelationshipEdge_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var resourceRelationshipsImplementors = []string{"ResourceRelationships"}

func (ec *executionContext) _ResourceRelationships(ctx context.Context, sel ast.SelectionSet, obj *model.ResourceRelationships) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, resourceRelationshipsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ResourceRelationships")
		case "dependsOn":
			out.Values[i] = ec._ResourceRelationships_dependsOn(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "dependents":
			out.Values[i] = ec._ResourceRelationships_dependents(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "routesVia":
			out.Values[i] = ec._ResourceRelationships_routesVia(ctx, field, obj)
		case "routedBy":
			out.Values[i] = ec._ResourceRelationships_routedBy(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "parent":
			out.Values[i] = ec._ResourceRelationships_parent(ctx, field, obj)
		case "children":
			out.Values[i] = ec._ResourceRelationships_children(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "custom":
			out.Values[i] = ec._ResourceRelationships_custom(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var resourceRuntimeEventImplementors = []string{"ResourceRuntimeEvent"}

func (ec *executionContext) _ResourceRuntimeEvent(ctx context.Context, sel ast.SelectionSet, obj *model.ResourceRuntimeEvent) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, resourceRuntimeEventImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ResourceRuntimeEvent")
		case "id":
			out.Values[i] = ec._ResourceRuntimeEvent_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "type":
			out.Values[i] = ec._ResourceRuntimeEvent_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "runtime":
			out.Values[i] = ec._ResourceRuntimeEvent_runtime(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "timestamp":
			out.Values[i] = ec._ResourceRuntimeEvent_timestamp(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var resourceStateEventImplementors = []string{"ResourceStateEvent"}

func (ec *executionContext) _ResourceStateEvent(ctx context.Context, sel ast.SelectionSet, obj *model.ResourceStateEvent) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, resourceStateEventImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ResourceStateEvent")
		case "id":
			out.Values[i] = ec._ResourceStateEvent_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "type":
			out.Values[i] = ec._ResourceStateEvent_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "previousState":
			out.Values[i] = ec._ResourceStateEvent_previousState(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "newState":
			out.Values[i] = ec._ResourceStateEvent_newState(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "errorMessage":
			out.Values[i] = ec._ResourceStateEvent_errorMessage(ctx, field, obj)
		case "timestamp":
			out.Values[i] = ec._ResourceStateEvent_timestamp(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var resourceUpdatedEventImplementors = []string{"ResourceUpdatedEvent"}

func (ec *executionContext) _ResourceUpdatedEvent(ctx context.Context, sel ast.SelectionSet, obj *model.ResourceUpdatedEvent) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, resourceUpdatedEventImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ResourceUpdatedEvent")
		case "resourceId":
			out.Values[i] = ec._ResourceUpdatedEvent_resourceId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "resourceType":
			out.Values[i] = ec._ResourceUpdatedEvent_resourceType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "routerId":
			out.Values[i] = ec._ResourceUpdatedEvent_routerId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "version":
			out.Values[i] = ec._ResourceUpdatedEvent_version(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "changedFields":
			out.Values[i] = ec._ResourceUpdatedEvent_changedFields(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "changeType":
			out.Values[i] = ec._ResourceUpdatedEvent_changeType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "timestamp":
			out.Values[i] = ec._ResourceUpdatedEvent_timestamp(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var rollbackChangeSetPayloadImplementors = []string{"RollbackChangeSetPayload"}

func (ec *executionContext) _RollbackChangeSetPayload(ctx context.Context, sel ast.SelectionSet, obj *model.RollbackChangeSetPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, rollbackChangeSetPayloadImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RollbackChangeSetPayload")
		case "changeSet":
			out.Values[i] = ec._RollbackChangeSetPayload_changeSet(ctx, field, obj)
		case "success":
			out.Values[i] = ec._RollbackChangeSetPayload_success(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "failedItems":
			out.Values[i] = ec._RollbackChangeSetPayload_failedItems(ctx, field, obj)
		case "errors":
			out.Values[i] = ec._RollbackChangeSetPayload_errors(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var rollbackStepImplementors = []string{"RollbackStep"}

func (ec *executionContext) _RollbackStep(ctx context.Context, sel ast.SelectionSet, obj *model.RollbackStep) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, rollbackStepImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RollbackStep")
		case "itemId":
			out.Values[i] = ec._RollbackStep_itemId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "operation":
			out.Values[i] = ec._RollbackStep_operation(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "restoreState":
			out.Values[i] = ec._RollbackStep_restoreState(ctx, field, obj)
		case "resourceUuid":
			out.Values[i] = ec._RollbackStep_resourceUuid(ctx, field, obj)
		case "success":
			out.Values[i] = ec._RollbackStep_success(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "error":
			out.Values[i] = ec._RollbackStep_error(ctx, field, obj)
		case "rollbackOrder":
			out.Values[i] = ec._RollbackStep_rollbackOrder(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var routeImplementors = []string{"Route", "Node"}

func (ec *executionContext) _Route(ctx context.Context, sel ast.SelectionSet, obj *model.Route) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, routeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Route")
		case "id":
			out.Values[i] = ec._Route_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "destination":
			out.Values[i] = ec._Route_destination(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "gateway":
			out.Values[i] = ec._Route_gateway(ctx, field, obj)
		case "interface":
			out.Values[i] = ec._Route_interface(ctx, field, obj)
		case "distance":
			out.Values[i] = ec._Route_distance(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "routingMark":
			out.Values[i] = ec._Route_routingMark(ctx, field, obj)
		case "routingTable":
			out.Values[i] = ec._Route_routingTable(ctx, field, obj)
		case "type":
			out.Values[i] = ec._Route_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "scope":
			out.Values[i] = ec._Route_scope(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "comment":
			out.Values[i] = ec._Route_comment(ctx, field, obj)
		case "active":
			out.Values[i] = ec._Route_active(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "disabled":
			out.Values[i] = ec._Route_disabled(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var routeDeleteResultImplementors = []string{"RouteDeleteResult"}

func (ec *executionContext) _RouteDeleteResult(ctx context.Context, sel ast.SelectionSet, obj *model.RouteDeleteResult) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, routeDeleteResultImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RouteDeleteResult")
		case "success":
			out.Values[i] = ec._RouteDeleteResult_success(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "message":
			out.Values[i] = ec._RouteDeleteResult_message(ctx, field, obj)
		case "impactAnalysis":
			out.Values[i] = ec._RouteDeleteResult_impactAnalysis(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var routeImpactAnalysisImplementors = []string{"RouteImpactAnalysis"}

func (ec *executionContext) _RouteImpactAnalysis(ctx context.Context, sel ast.SelectionSet, obj *model.RouteImpactAnalysis) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, routeImpactAnalysisImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RouteImpactAnalysis")
		case "isDefaultRoute":
			out.Values[i] = ec._RouteImpactAnalysis_isDefaultRoute(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "affectedTraffic":
			out.Values[i] = ec._RouteImpactAnalysis_affectedTraffic(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "severity":
			out.Values[i] = ec._RouteImpactAnalysis_severity(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "message":
			out.Values[i] = ec._RouteImpactAnalysis_message(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "consequences":
			out.Values[i] = ec._RouteImpactAnalysis_consequences(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var routeMutationResultImplementors = []string{"RouteMutationResult"}

func (ec *executionContext) _RouteMutationResult(ctx context.Context, sel ast.SelectionSet, obj *model.RouteMutationResult) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, routeMutationResultImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RouteMutationResult")
		case "success":
			out.Values[i] = ec._RouteMutationResult_success(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "message":
			out.Values[i] = ec._RouteMutationResult_message(ctx, field, obj)
		case "route":
			out.Values[i] = ec._RouteMutationResult_route(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var routeResourceImplementors = []string{"RouteResource", "Resource", "Node"}

func (ec *executionContext) _RouteResource(ctx context.Context, sel ast.SelectionSet, obj *model.RouteResource) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, routeResourceImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RouteResource")
		case "id":
			out.Values[i] = ec._RouteResource_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "scopedId":
			out.Values[i] = ec._RouteResource_scopedId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "type":
			out.Values[i] = ec._RouteResource_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "category":
			out.Values[i] = ec._RouteResource_category(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "configuration":
			out.Values[i] = ec._RouteResource_configuration(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "validation":
			out.Values[i] = ec._RouteResource_validation(ctx, field, obj)
		case "deployment":
			out.Values[i] = ec._RouteResource_deployment(ctx, field, obj)
		case "runtime":
			out.Values[i] = ec._RouteResource_runtime(ctx, field, obj)
		case "telemetry":
			out.Values[i] = ec._RouteResource_telemetry(ctx, field, obj)
		case "metadata":
			out.Values[i] = ec._RouteResource_metadata(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "relationships":
			out.Values[i] = ec._RouteResource_relationships(ctx, field, obj)
		case "platform":
			out.Values[i] = ec._RouteResource_platform(ctx, field, obj)
		case "dstAddress":
			out.Values[i] = ec._RouteResource_dstAddress(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "gateway":
			out.Values[i] = ec._RouteResource_gateway(ctx, field, obj)
		case "interface":
			out.Values[i] = ec._RouteResource_interface(ctx, field, obj)
		case "distance":
			out.Values[i] = ec._RouteResource_distance(ctx, field, obj)
		case "active":
			out.Values[i] = ec._RouteResource_active(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var routerImplementors = []string{"Router", "Node"}

func (ec *executionContext) _Router(ctx context.Context, sel ast.SelectionSet, obj *model.Router) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, routerImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Router")
		case "id":
			out.Values[i] = ec._Router_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec._Router_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "host":
			out.Values[i] = ec._Router_host(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "port":
			out.Values[i] = ec._Router_port(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "status":
			out.Values[i] = ec._Router_status(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "platform":
			out.Values[i] = ec._Router_platform(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "version":
			out.Values[i] = ec._Router_version(ctx, field, obj)
		case "model":
			out.Values[i] = ec._Router_model(ctx, field, obj)
		case "uptime":
			out.Values[i] = ec._Router_uptime(ctx, field, obj)
		case "lastConnected":
			out.Values[i] = ec._Router_lastConnected(ctx, field, obj)
		case "createdAt":
			out.Values[i] = ec._Router_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updatedAt":
			out.Values[i] = ec._Router_updatedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "capabilities":
			out.Values[i] = ec._Router_capabilities(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var routerAddedEventImplementors = []string{"RouterAddedEvent"}

func (ec *executionContext) _RouterAddedEvent(ctx context.Context, sel ast.SelectionSet, obj *model.RouterAddedEvent) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, routerAddedEventImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RouterAddedEvent")
		case "router":
			out.Values[i] = ec._RouterAddedEvent_router(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "protocolUsed":
			out.Values[i] = ec._RouterAddedEvent_protocolUsed(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "addedBy":
			out.Values[i] = ec._RouterAddedEvent_addedBy(ctx, field, obj)
		case "timestamp":
			out.Values[i] = ec._RouterAddedEvent_timestamp(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var routerCapabilitiesImplementors = []string{"RouterCapabilities"}

func (ec *executionContext) _RouterCapabilities(ctx context.Context, sel ast.SelectionSet, obj *model.RouterCapabilities) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, routerCapabilitiesImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RouterCapabilities")
		case "hardware":
			out.Values[i] = ec._RouterCapabilities_hardware(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "software":
			out.Values[i] = ec._RouterCapabilities_software(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "container":
			out.Values[i] = ec._RouterCapabilities_container(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "capabilities":
			out.Values[i] = ec._RouterCapabilities_capabilities(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "vifRequirements":
			out.Values[i] = ec._RouterCapabilities_vifRequirements(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "supportedFeatures":
			out.Values[i] = ec._RouterCapabilities_supportedFeatures(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "unsupportedFeatures":
			out.Values[i] = ec._RouterCapabilities_unsupportedFeatures(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "routerOSVersion":
			out.Values[i] = ec._RouterCapabilities_routerOSVersion(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "detectedAt":
			out.Values[i] = ec._RouterCapabilities_detectedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "expiresAt":
			out.Values[i] = ec._RouterCapabilities_expiresAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "isRefreshing":
			out.Values[i] = ec._RouterCapabilities_isRefreshing(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var routerConnectionImplementors = []string{"RouterConnection", "Connection"}

func (ec *executionContext) _RouterConnection(ctx context.Context, sel ast.SelectionSet, obj *model.RouterConnection) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, routerConnectionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RouterConnection")
		case "edges":
			out.Values[i] = ec._RouterConnection_edges(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "pageInfo":
			out.Values[i] = ec._RouterConnection_pageInfo(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "totalCount":
			out.Values[i] = ec._RouterConnection_totalCount(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var routerCredentialsImplementors = []string{"RouterCredentials"}

func (ec *executionContext) _RouterCredentials(ctx context.Context, sel ast.SelectionSet, obj *model.RouterCredentials) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, routerCredentialsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RouterCredentials")
		case "routerId":
			out.Values[i] = ec._RouterCredentials_routerId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "username":
			out.Values[i] = ec._RouterCredentials_username(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "hasPassword":
			out.Values[i] = ec._RouterCredentials_hasPassword(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "encryptionStatus":
			out.Values[i] = ec._RouterCredentials_encryptionStatus(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "keyVersion":
			out.Values[i] = ec._RouterCredentials_keyVersion(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "lastUpdated":
			out.Values[i] = ec._RouterCredentials_lastUpdated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createdAt":
			out.Values[i] = ec._RouterCredentials_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var routerEdgeImplementors = []string{"RouterEdge", "Edge"}

func (ec *executionContext) _RouterEdge(ctx context.Context, sel ast.SelectionSet, obj *model.RouterEdge) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, routerEdgeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RouterEdge")
		case "node":
			out.Values[i] = ec._RouterEdge_node(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "cursor":
			out.Values[i] = ec._RouterEdge_cursor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var routerOSInfoImplementors = []string{"RouterOSInfo"}

func (ec *executionContext) _RouterOSInfo(ctx context.Context, sel ast.SelectionSet, obj *model.RouterOSInfo) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, routerOSInfoImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RouterOSInfo")
		case "version":
			out.Values[i] = ec._RouterOSInfo_version(ctx, field, obj)
		case "boardName":
			out.Values[i] = ec._RouterOSInfo_boardName(ctx, field, obj)
		case "architecture":
			out.Values[i] = ec._RouterOSInfo_architecture(ctx, field, obj)
		case "platform":
			out.Values[i] = ec._RouterOSInfo_platform(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var routerOSVersionImplementors = []string{"RouterOSVersion"}

func (ec *executionContext) _RouterOSVersion(ctx context.Context, sel ast.SelectionSet, obj *model.RouterOSVersion) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, routerOSVersionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RouterOSVersion")
		case "raw":
			out.Values[i] = ec._RouterOSVersion_raw(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "major":
			out.Values[i] = ec._RouterOSVersion_major(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "minor":
			out.Values[i] = ec._RouterOSVersion_minor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "patch":
			out.Values[i] = ec._RouterOSVersion_patch(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "channel":
			out.Values[i] = ec._RouterOSVersion_channel(ctx, field, obj)
		case "isCHR":
			out.Values[i] = ec._RouterOSVersion_isCHR(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "supportsFeature":
			out.Values[i] = ec._RouterOSVersion_supportsFeature(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "isAtLeast":
			out.Values[i] = ec._RouterOSVersion_isAtLeast(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var routerStatusEventImplementors = []string{"RouterStatusEvent"}

func (ec *executionContext) _RouterStatusEvent(ctx context.Context, sel ast.SelectionSet, obj *model.RouterStatusEvent) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, routerStatusEventImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RouterStatusEvent")
		case "router":
			out.Values[i] = ec._RouterStatusEvent_router(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "previousStatus":
			out.Values[i] = ec._RouterStatusEvent_previousStatus(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "newStatus":
			out.Values[i] = ec._RouterStatusEvent_newStatus(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "timestamp":
			out.Values[i] = ec._RouterStatusEvent_timestamp(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var runTroubleshootStepPayloadImplementors = []string{"RunTroubleshootStepPayload"}

func (ec *executionContext) _RunTroubleshootStepPayload(ctx context.Context, sel ast.SelectionSet, obj *model.RunTroubleshootStepPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, runTroubleshootStepPayloadImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RunTroubleshootStepPayload")
		case "step":
			out.Values[i] = ec._RunTroubleshootStepPayload_step(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "errors":
			out.Values[i] = ec._RunTroubleshootStepPayload_errors(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var runtimeMetricsImplementors = []string{"RuntimeMetrics"}

func (ec *executionContext) _RuntimeMetrics(ctx context.Context, sel ast.SelectionSet, obj *model.RuntimeMetrics) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, runtimeMetricsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RuntimeMetrics")
		case "bytesIn":
			out.Values[i] = ec._RuntimeMetrics_bytesIn(ctx, field, obj)
		case "bytesOut":
			out.Values[i] = ec._RuntimeMetrics_bytesOut(ctx, field, obj)
		case "packetsIn":
			out.Values[i] = ec._RuntimeMetrics_packetsIn(ctx, field, obj)
		case "packetsOut":
			out.Values[i] = ec._RuntimeMetrics_packetsOut(ctx, field, obj)
		case "errors":
			out.Values[i] = ec._RuntimeMetrics_errors(ctx, field, obj)
		case "drops":
			out.Values[i] = ec._RuntimeMetrics_drops(ctx, field, obj)
		case "throughputIn":
			out.Values[i] = ec._RuntimeMetrics_throughputIn(ctx, field, obj)
		case "throughputOut":
			out.Values[i] = ec._RuntimeMetrics_throughputOut(ctx, field, obj)
		case "custom":
			out.Values[i] = ec._RuntimeMetrics_custom(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var runtimeStateImplementors = []string{"RuntimeState"}

func (ec *executionContext) _RuntimeState(ctx context.Context, sel ast.SelectionSet, obj *model.RuntimeState) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, runtimeStateImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RuntimeState")
		case "isRunning":
			out.Values[i] = ec._RuntimeState_isRunning(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "health":
			out.Values[i] = ec._RuntimeState_health(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "errorMessage":
			out.Values[i] = ec._RuntimeState_errorMessage(ctx, field, obj)
		case "metrics":
			out.Values[i] = ec._RuntimeState_metrics(ctx, field, obj)
		case "lastUpdated":
			out.Values[i] = ec._RuntimeState_lastUpdated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "lastSuccessfulOperation":
			out.Values[i] = ec._RuntimeState_lastSuccessfulOperation(ctx, field, obj)
		case "activeConnections":
			out.Values[i] = ec._RuntimeState_activeConnections(ctx, field, obj)
		case "uptime":
			out.Values[i] = ec._RuntimeState_uptime(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var scanNetworkPayloadImplementors = []string{"ScanNetworkPayload"}

func (ec *executionContext) _ScanNetworkPayload(ctx context.Context, sel ast.SelectionSet, obj *model.ScanNetworkPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, scanNetworkPayloadImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ScanNetworkPayload")
		case "task":
			out.Values[i] = ec._ScanNetworkPayload_task(ctx, field, obj)
		case "errors":
			out.Values[i] = ec._ScanNetworkPayload_errors(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var scanProgressEventImplementors = []string{"ScanProgressEvent"}

func (ec *executionContext) _ScanProgressEvent(ctx context.Context, sel ast.SelectionSet, obj *model.ScanProgressEvent) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, scanProgressEventImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ScanProgressEvent")
		case "taskId":
			out.Values[i] = ec._ScanProgressEvent_taskId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "progress":
			out.Values[i] = ec._ScanProgressEvent_progress(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "devicesFound":
			out.Values[i] = ec._ScanProgressEvent_devicesFound(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "currentIP":
			out.Values[i] = ec._ScanProgressEvent_currentIP(ctx, field, obj)
		case "status":
			out.Values[i] = ec._ScanProgressEvent_status(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "timestamp":
			out.Values[i] = ec._ScanProgressEvent_timestamp(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var scanTaskImplementors = []string{"ScanTask"}

func (ec *executionContext) _ScanTask(ctx context.Context, sel ast.SelectionSet, obj *model.ScanTask) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, scanTaskImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ScanTask")
		case "id":
			out.Values[i] = ec._ScanTask_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "subnet":
			out.Values[i] = ec._ScanTask_subnet(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "status":
			out.Values[i] = ec._ScanTask_status(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "progress":
			out.Values[i] = ec._ScanTask_progress(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "results":
			out.Values[i] = ec._ScanTask_results(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "startTime":
			out.Values[i] = ec._ScanTask_startTime(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "endTime":
			out.Values[i] = ec._ScanTask_endTime(ctx, field, obj)
		case "error":
			out.Values[i] = ec._ScanTask_error(ctx, field, obj)
		case "totalIPs":
			out.Values[i] = ec._ScanTask_totalIPs(ctx, field, obj)
		case "scannedIPs":
			out.Values[i] = ec._ScanTask_scannedIPs(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var sessionImplementors = []string{"Session"}

func (ec *executionContext) _Session(ctx context.Context, sel ast.SelectionSet, obj *model.Session) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, sessionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Session")
		case "id":
			out.Values[i] = ec._Session_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "ipAddress":
			out.Values[i] = ec._Session_ipAddress(ctx, field, obj)
		case "userAgent":
			out.Values[i] = ec._Session_userAgent(ctx, field, obj)
		case "createdAt":
			out.Values[i] = ec._Session_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "lastActivity":
			out.Values[i] = ec._Session_lastActivity(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "isCurrent":
			out.Values[i] = ec._Session_isCurrent(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var setPreferredProtocolPayloadImplementors = []string{"SetPreferredProtocolPayload"}

func (ec *executionContext) _SetPreferredProtocolPayload(ctx context.Context, sel ast.SelectionSet, obj *model.SetPreferredProtocolPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, setPreferredProtocolPayloadImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SetPreferredProtocolPayload")
		case "router":
			out.Values[i] = ec._SetPreferredProtocolPayload_router(ctx, field, obj)
		case "connectionDetails":
			out.Values[i] = ec._SetPreferredProtocolPayload_connectionDetails(ctx, field, obj)
		case "errors":
			out.Values[i] = ec._SetPreferredProtocolPayload_errors(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var softwareInfoImplementors = []string{"SoftwareInfo"}

func (ec *executionContext) _SoftwareInfo(ctx context.Context, sel ast.SelectionSet, obj *model.SoftwareInfo) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, softwareInfoImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SoftwareInfo")
		case "version":
			out.Values[i] = ec._SoftwareInfo_version(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "versionMajor":
			out.Values[i] = ec._SoftwareInfo_versionMajor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "versionMinor":
			out.Values[i] = ec._SoftwareInfo_versionMinor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "versionPatch":
			out.Values[i] = ec._SoftwareInfo_versionPatch(ctx, field, obj)
		case "installedPackages":
			out.Values[i] = ec._SoftwareInfo_installedPackages(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "licenseLevel":
			out.Values[i] = ec._SoftwareInfo_licenseLevel(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updateChannel":
			out.Values[i] = ec._SoftwareInfo_updateChannel(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var startTroubleshootPayloadImplementors = []string{"StartTroubleshootPayload"}

func (ec *executionContext) _StartTroubleshootPayload(ctx context.Context, sel ast.SelectionSet, obj *model.StartTroubleshootPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, startTroubleshootPayloadImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("StartTroubleshootPayload")
		case "session":
			out.Values[i] = ec._StartTroubleshootPayload_session(ctx, field, obj)
		case "errors":
			out.Values[i] = ec._StartTroubleshootPayload_errors(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var staticIPConfigImplementors = []string{"StaticIPConfig", "Node"}

func (ec *executionContext) _StaticIPConfig(ctx context.Context, sel ast.SelectionSet, obj *model.StaticIPConfig) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, staticIPConfigImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("StaticIPConfig")
		case "id":
			out.Values[i] = ec._StaticIPConfig_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "interface":
			out.Values[i] = ec._StaticIPConfig_interface(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "address":
			out.Values[i] = ec._StaticIPConfig_address(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "gateway":
			out.Values[i] = ec._StaticIPConfig_gateway(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "primaryDNS":
			out.Values[i] = ec._StaticIPConfig_primaryDNS(ctx, field, obj)
		case "secondaryDNS":
			out.Values[i] = ec._StaticIPConfig_secondaryDNS(ctx, field, obj)
		case "comment":
			out.Values[i] = ec._StaticIPConfig_comment(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var statsDataPointImplementors = []string{"StatsDataPoint"}

func (ec *executionContext) _StatsDataPoint(ctx context.Context, sel ast.SelectionSet, obj *model.StatsDataPoint) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, statsDataPointImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("StatsDataPoint")
		case "timestamp":
			out.Values[i] = ec._StatsDataPoint_timestamp(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "txBytesPerSec":
			out.Values[i] = ec._StatsDataPoint_txBytesPerSec(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "rxBytesPerSec":
			out.Values[i] = ec._StatsDataPoint_rxBytesPerSec(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "txPacketsPerSec":
			out.Values[i] = ec._StatsDataPoint_txPacketsPerSec(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "rxPacketsPerSec":
			out.Values[i] = ec._StatsDataPoint_rxPacketsPerSec(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "txErrors":
			out.Values[i] = ec._StatsDataPoint_txErrors(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "rxErrors":
			out.Values[i] = ec._StatsDataPoint_rxErrors(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var storageMetricsImplementors = []string{"StorageMetrics"}

func (ec *executionContext) _StorageMetrics(ctx context.Context, sel ast.SelectionSet, obj *model.StorageMetrics) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, storageMetricsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("StorageMetrics")
		case "used":
			out.Values[i] = ec._StorageMetrics_used(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "total":
			out.Values[i] = ec._StorageMetrics_total(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "percentage":
			out.Values[i] = ec._StorageMetrics_percentage(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var subscriptionImplementors = []string{"Subscription"}

func (ec *executionContext) _Subscription(ctx context.Context, sel ast.SelectionSet) func(ctx context.Context) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, subscriptionImplementors)
	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Subscription",
	})
	if len(fields) != 1 {
		ec.Errorf(ctx, "must subscribe to exactly one stream")
		return nil
	}

	switch fields[0].Name {
	case "routerStatusChanged":
		return ec._Subscription_routerStatusChanged(ctx, fields[0])
	case "resourceMetrics":
		return ec._Subscription_resourceMetrics(ctx, fields[0])
	case "interfaceTraffic":
		return ec._Subscription_interfaceTraffic(ctx, fields[0])
	case "resourceUpdated":
		return ec._Subscription_resourceUpdated(ctx, fields[0])
	case "configApplyProgress":
		return ec._Subscription_configApplyProgress(ctx, fields[0])
	case "interfaceStatusChanged":
		return ec._Subscription_interfaceStatusChanged(ctx, fields[0])
	case "connectionHealth":
		return ec._Subscription_connectionHealth(ctx, fields[0])
	case "circuitBreakerChanged":
		return ec._Subscription_circuitBreakerChanged(ctx, fields[0])
	case "scanProgress":
		return ec._Subscription_scanProgress(ctx, fields[0])
	case "changeSetProgress":
		return ec._Subscription_changeSetProgress(ctx, fields[0])
	case "changeSetStatusChanged":
		return ec._Subscription_changeSetStatusChanged(ctx, fields[0])
	case "circuitBreakerStateChanged":
		return ec._Subscription_circuitBreakerStateChanged(ctx, fields[0])
	case "troubleshootProgress":
		return ec._Subscription_troubleshootProgress(ctx, fields[0])
	case "tracerouteProgress":
		return ec._Subscription_tracerouteProgress(ctx, fields[0])
	case "alertEvents":
		return ec._Subscription_alertEvents(ctx, fields[0])
	case "routerAdded":
		return ec._Subscription_routerAdded(ctx, fields[0])
	case "resourceRuntime":
		return ec._Subscription_resourceRuntime(ctx, fields[0])
	case "resourceStateChanged":
		return ec._Subscription_resourceStateChanged(ctx, fields[0])
	case "ipAddressChanged":
		return ec._Subscription_ipAddressChanged(ctx, fields[0])
	case "vlanChanged":
		return ec._Subscription_vlanChanged(ctx, fields[0])
	case "interfaceStatsUpdated":
		return ec._Subscription_interfaceStatsUpdated(ctx, fields[0])
	case "bridgeStpStatusChanged":
		return ec._Subscription_bridgeStpStatusChanged(ctx, fields[0])
	case "bridgePortsChanged":
		return ec._Subscription_bridgePortsChanged(ctx, fields[0])
	case "wanStatusChanged":
		return ec._Subscription_wanStatusChanged(ctx, fields[0])
	case "wanHealthChanged":
		return ec._Subscription_wanHealthChanged(ctx, fields[0])
	default:
		panic("unknown field " + strconv.Quote(fields[0].Name))
	}
}

var tLSStatusImplementors = []string{"TLSStatus"}

func (ec *executionContext) _TLSStatus(ctx context.Context, sel ast.SelectionSet, obj *model.TLSStatus) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, tLSStatusImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TLSStatus")
		case "valid":
			out.Values[i] = ec._TLSStatus_valid(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "issuer":
			out.Values[i] = ec._TLSStatus_issuer(ctx, field, obj)
		case "subject":
			out.Values[i] = ec._TLSStatus_subject(ctx, field, obj)
		case "expiresAt":
			out.Values[i] = ec._TLSStatus_expiresAt(ctx, field, obj)
		case "error":
			out.Values[i] = ec._TLSStatus_error(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var telemetryDataImplementors = []string{"TelemetryData"}

func (ec *executionContext) _TelemetryData(ctx context.Context, sel ast.SelectionSet, obj *model.TelemetryData) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, telemetryDataImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TelemetryData")
		case "bandwidthHistory":
			out.Values[i] = ec._TelemetryData_bandwidthHistory(ctx, field, obj)
		case "uptimeHistory":
			out.Values[i] = ec._TelemetryData_uptimeHistory(ctx, field, obj)
		case "hourlyStats":
			out.Values[i] = ec._TelemetryData_hourlyStats(ctx, field, obj)
		case "dailyStats":
			out.Values[i] = ec._TelemetryData_dailyStats(ctx, field, obj)
		case "dataStartedAt":
			out.Values[i] = ec._TelemetryData_dataStartedAt(ctx, field, obj)
		case "lastUpdatedAt":
			out.Values[i] = ec._TelemetryData_lastUpdatedAt(ctx, field, obj)
		case "retentionDays":
			out.Values[i] = ec._TelemetryData_retentionDays(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var testAllCredentialsPayloadImplementors = []string{"TestAllCredentialsPayload"}

func (ec *executionContext) _TestAllCredentialsPayload(ctx context.Context, sel ast.SelectionSet, obj *model.TestAllCredentialsPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, testAllCredentialsPayloadImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TestAllCredentialsPayload")
		case "totalRouters":
			out.Values[i] = ec._TestAllCredentialsPayload_totalRouters(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "successCount":
			out.Values[i] = ec._TestAllCredentialsPayload_successCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "failureCount":
			out.Values[i] = ec._TestAllCredentialsPayload_failureCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "results":
			out.Values[i] = ec._TestAllCredentialsPayload_results(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var testConnectionPayloadImplementors = []string{"TestConnectionPayload"}

func (ec *executionContext) _TestConnectionPayload(ctx context.Context, sel ast.SelectionSet, obj *model.TestConnectionPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, testConnectionPayloadImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TestConnectionPayload")
		case "success":
			out.Values[i] = ec._TestConnectionPayload_success(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "responseTimeMs":
			out.Values[i] = ec._TestConnectionPayload_responseTimeMs(ctx, field, obj)
		case "version":
			out.Values[i] = ec._TestConnectionPayload_version(ctx, field, obj)
		case "error":
			out.Values[i] = ec._TestConnectionPayload_error(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var testNotificationPayloadImplementors = []string{"TestNotificationPayload"}

func (ec *executionContext) _TestNotificationPayload(ctx context.Context, sel ast.SelectionSet, obj *model.TestNotificationPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, testNotificationPayloadImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TestNotificationPayload")
		case "success":
			out.Values[i] = ec._TestNotificationPayload_success(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "message":
			out.Values[i] = ec._TestNotificationPayload_message(ctx, field, obj)
		case "errors":
			out.Values[i] = ec._TestNotificationPayload_errors(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var throttleConfigImplementors = []string{"ThrottleConfig"}

func (ec *executionContext) _ThrottleConfig(ctx context.Context, sel ast.SelectionSet, obj *model.ThrottleConfig) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, throttleConfigImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ThrottleConfig")
		case "maxAlerts":
			out.Values[i] = ec._ThrottleConfig_maxAlerts(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "periodSeconds":
			out.Values[i] = ec._ThrottleConfig_periodSeconds(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "groupByField":
			out.Values[i] = ec._ThrottleConfig_groupByField(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var topologyEdgeImplementors = []string{"TopologyEdge"}

func (ec *executionContext) _TopologyEdge(ctx context.Context, sel ast.SelectionSet, obj *model.TopologyEdge) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, topologyEdgeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TopologyEdge")
		case "id":
			out.Values[i] = ec._TopologyEdge_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "source":
			out.Values[i] = ec._TopologyEdge_source(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "target":
			out.Values[i] = ec._TopologyEdge_target(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "label":
			out.Values[i] = ec._TopologyEdge_label(ctx, field, obj)
		case "data":
			out.Values[i] = ec._TopologyEdge_data(ctx, field, obj)
		case "style":
			out.Values[i] = ec._TopologyEdge_style(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var topologyEdgeStyleImplementors = []string{"TopologyEdgeStyle"}

func (ec *executionContext) _TopologyEdgeStyle(ctx context.Context, sel ast.SelectionSet, obj *model.TopologyEdgeStyle) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, topologyEdgeStyleImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TopologyEdgeStyle")
		case "stroke":
			out.Values[i] = ec._TopologyEdgeStyle_stroke(ctx, field, obj)
		case "strokeWidth":
			out.Values[i] = ec._TopologyEdgeStyle_strokeWidth(ctx, field, obj)
		case "strokeDasharray":
			out.Values[i] = ec._TopologyEdgeStyle_strokeDasharray(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var topologyNodeImplementors = []string{"TopologyNode"}

func (ec *executionContext) _TopologyNode(ctx context.Context, sel ast.SelectionSet, obj *model.TopologyNode) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, topologyNodeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TopologyNode")
		case "id":
			out.Values[i] = ec._TopologyNode_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "type":
			out.Values[i] = ec._TopologyNode_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "label":
			out.Values[i] = ec._TopologyNode_label(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "sublabel":
			out.Values[i] = ec._TopologyNode_sublabel(ctx, field, obj)
		case "position":
			out.Values[i] = ec._TopologyNode_position(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "data":
			out.Values[i] = ec._TopologyNode_data(ctx, field, obj)
		case "style":
			out.Values[i] = ec._TopologyNode_style(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var topologyNodeStyleImplementors = []string{"TopologyNodeStyle"}

func (ec *executionContext) _TopologyNodeStyle(ctx context.Context, sel ast.SelectionSet, obj *model.TopologyNodeStyle) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, topologyNodeStyleImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TopologyNodeStyle")
		case "fill":
			out.Values[i] = ec._TopologyNodeStyle_fill(ctx, field, obj)
		case "stroke":
			out.Values[i] = ec._TopologyNodeStyle_stroke(ctx, field, obj)
		case "strokeWidth":
			out.Values[i] = ec._TopologyNodeStyle_strokeWidth(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var topologyPositionImplementors = []string{"TopologyPosition"}

func (ec *executionContext) _TopologyPosition(ctx context.Context, sel ast.SelectionSet, obj *model.TopologyPosition) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, topologyPositionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TopologyPosition")
		case "x":
			out.Values[i] = ec._TopologyPosition_x(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "y":
			out.Values[i] = ec._TopologyPosition_y(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var tracerouteHopImplementors = []string{"TracerouteHop"}

func (ec *executionContext) _TracerouteHop(ctx context.Context, sel ast.SelectionSet, obj *model.TracerouteHop) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, tracerouteHopImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TracerouteHop")
		case "hopNumber":
			out.Values[i] = ec._TracerouteHop_hopNumber(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "address":
			out.Values[i] = ec._TracerouteHop_address(ctx, field, obj)
		case "hostname":
			out.Values[i] = ec._TracerouteHop_hostname(ctx, field, obj)
		case "probes":
			out.Values[i] = ec._TracerouteHop_probes(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "status":
			out.Values[i] = ec._TracerouteHop_status(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "avgLatencyMs":
			out.Values[i] = ec._TracerouteHop_avgLatencyMs(ctx, field, obj)
		case "packetLoss":
			out.Values[i] = ec._TracerouteHop_packetLoss(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var tracerouteJobImplementors = []string{"TracerouteJob"}

func (ec *executionContext) _TracerouteJob(ctx context.Context, sel ast.SelectionSet, obj *model.TracerouteJob) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, tracerouteJobImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TracerouteJob")
		case "jobId":
			out.Values[i] = ec._TracerouteJob_jobId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "status":
			out.Values[i] = ec._TracerouteJob_status(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var tracerouteProgressEventImplementors = []string{"TracerouteProgressEvent"}

func (ec *executionContext) _TracerouteProgressEvent(ctx context.Context, sel ast.SelectionSet, obj *model.TracerouteProgressEvent) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, tracerouteProgressEventImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TracerouteProgressEvent")
		case "jobId":
			out.Values[i] = ec._TracerouteProgressEvent_jobId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "eventType":
			out.Values[i] = ec._TracerouteProgressEvent_eventType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "hop":
			out.Values[i] = ec._TracerouteProgressEvent_hop(ctx, field, obj)
		case "result":
			out.Values[i] = ec._TracerouteProgressEvent_result(ctx, field, obj)
		case "error":
			out.Values[i] = ec._TracerouteProgressEvent_error(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var tracerouteResultImplementors = []string{"TracerouteResult"}

func (ec *executionContext) _TracerouteResult(ctx context.Context, sel ast.SelectionSet, obj *model.TracerouteResult) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, tracerouteResultImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TracerouteResult")
		case "target":
			out.Values[i] = ec._TracerouteResult_target(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "targetIp":
			out.Values[i] = ec._TracerouteResult_targetIp(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "protocol":
			out.Values[i] = ec._TracerouteResult_protocol(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "maxHops":
			out.Values[i] = ec._TracerouteResult_maxHops(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "hops":
			out.Values[i] = ec._TracerouteResult_hops(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "completed":
			out.Values[i] = ec._TracerouteResult_completed(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "reachedDestination":
			out.Values[i] = ec._TracerouteResult_reachedDestination(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "totalTimeMs":
			out.Values[i] = ec._TracerouteResult_totalTimeMs(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "startedAt":
			out.Values[i] = ec._TracerouteResult_startedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "completedAt":
			out.Values[i] = ec._TracerouteResult_completedAt(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var troubleshootFixSuggestionImplementors = []string{"TroubleshootFixSuggestion"}

func (ec *executionContext) _TroubleshootFixSuggestion(ctx context.Context, sel ast.SelectionSet, obj *model.TroubleshootFixSuggestion) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, troubleshootFixSuggestionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TroubleshootFixSuggestion")
		case "issueCode":
			out.Values[i] = ec._TroubleshootFixSuggestion_issueCode(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "title":
			out.Values[i] = ec._TroubleshootFixSuggestion_title(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "explanation":
			out.Values[i] = ec._TroubleshootFixSuggestion_explanation(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "confidence":
			out.Values[i] = ec._TroubleshootFixSuggestion_confidence(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "requiresConfirmation":
			out.Values[i] = ec._TroubleshootFixSuggestion_requiresConfirmation(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "isManualFix":
			out.Values[i] = ec._TroubleshootFixSuggestion_isManualFix(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "manualSteps":
			out.Values[i] = ec._TroubleshootFixSuggestion_manualSteps(ctx, field, obj)
		case "command":
			out.Values[i] = ec._TroubleshootFixSuggestion_command(ctx, field, obj)
		case "rollbackCommand":
			out.Values[i] = ec._TroubleshootFixSuggestion_rollbackCommand(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var troubleshootSessionImplementors = []string{"TroubleshootSession"}

func (ec *executionContext) _TroubleshootSession(ctx context.Context, sel ast.SelectionSet, obj *model.TroubleshootSession) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, troubleshootSessionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TroubleshootSession")
		case "id":
			out.Values[i] = ec._TroubleshootSession_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "routerId":
			out.Values[i] = ec._TroubleshootSession_routerId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "steps":
			out.Values[i] = ec._TroubleshootSession_steps(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "currentStepIndex":
			out.Values[i] = ec._TroubleshootSession_currentStepIndex(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "status":
			out.Values[i] = ec._TroubleshootSession_status(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "wanInterface":
			out.Values[i] = ec._TroubleshootSession_wanInterface(ctx, field, obj)
		case "gateway":
			out.Values[i] = ec._TroubleshootSession_gateway(ctx, field, obj)
		case "ispInfo":
			out.Values[i] = ec._TroubleshootSession_ispInfo(ctx, field, obj)
		case "appliedFixes":
			out.Values[i] = ec._TroubleshootSession_appliedFixes(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "startedAt":
			out.Values[i] = ec._TroubleshootSession_startedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "completedAt":
			out.Values[i] = ec._TroubleshootSession_completedAt(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var troubleshootStepImplementors = []string{"TroubleshootStep"}

func (ec *executionContext) _TroubleshootStep(ctx context.Context, sel ast.SelectionSet, obj *model.TroubleshootStep) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, troubleshootStepImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TroubleshootStep")
		case "id":
			out.Values[i] = ec._TroubleshootStep_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec._TroubleshootStep_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec._TroubleshootStep_description(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "status":
			out.Values[i] = ec._TroubleshootStep_status(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "result":
			out.Values[i] = ec._TroubleshootStep_result(ctx, field, obj)
		case "fix":
			out.Values[i] = ec._TroubleshootStep_fix(ctx, field, obj)
		case "startedAt":
			out.Values[i] = ec._TroubleshootStep_startedAt(ctx, field, obj)
		case "completedAt":
			out.Values[i] = ec._TroubleshootStep_completedAt(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var troubleshootStepResultImplementors = []string{"TroubleshootStepResult"}

func (ec *executionContext) _TroubleshootStepResult(ctx context.Context, sel ast.SelectionSet, obj *model.TroubleshootStepResult) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, troubleshootStepResultImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TroubleshootStepResult")
		case "success":
			out.Values[i] = ec._TroubleshootStepResult_success(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "message":
			out.Values[i] = ec._TroubleshootStepResult_message(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "details":
			out.Values[i] = ec._TroubleshootStepResult_details(ctx, field, obj)
		case "executionTimeMs":
			out.Values[i] = ec._TroubleshootStepResult_executionTimeMs(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "issueCode":
			out.Values[i] = ec._TroubleshootStepResult_issueCode(ctx, field, obj)
		case "target":
			out.Values[i] = ec._TroubleshootStepResult_target(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var updateChangeSetItemPayloadImplementors = []string{"UpdateChangeSetItemPayload"}

func (ec *executionContext) _UpdateChangeSetItemPayload(ctx context.Context, sel ast.SelectionSet, obj *model.UpdateChangeSetItemPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, updateChangeSetItemPayloadImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UpdateChangeSetItemPayload")
		case "changeSet":
			out.Values[i] = ec._UpdateChangeSetItemPayload_changeSet(ctx, field, obj)
		case "errors":
			out.Values[i] = ec._UpdateChangeSetItemPayload_errors(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var updateInterfacePayloadImplementors = []string{"UpdateInterfacePayload"}

func (ec *executionContext) _UpdateInterfacePayload(ctx context.Context, sel ast.SelectionSet, obj *model.UpdateInterfacePayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, updateInterfacePayloadImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UpdateInterfacePayload")
		case "interface":
			out.Values[i] = ec._UpdateInterfacePayload_interface(ctx, field, obj)
		case "errors":
			out.Values[i] = ec._UpdateInterfacePayload_errors(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var updateResourcePayloadImplementors = []string{"UpdateResourcePayload"}

func (ec *executionContext) _UpdateResourcePayload(ctx context.Context, sel ast.SelectionSet, obj *model.UpdateResourcePayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, updateResourcePayloadImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UpdateResourcePayload")
		case "resource":
			out.Values[i] = ec._UpdateResourcePayload_resource(ctx, field, obj)
		case "errors":
			out.Values[i] = ec._UpdateResourcePayload_errors(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var updateRouterPayloadImplementors = []string{"UpdateRouterPayload"}

func (ec *executionContext) _UpdateRouterPayload(ctx context.Context, sel ast.SelectionSet, obj *model.UpdateRouterPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, updateRouterPayloadImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UpdateRouterPayload")
		case "router":
			out.Values[i] = ec._UpdateRouterPayload_router(ctx, field, obj)
		case "errors":
			out.Values[i] = ec._UpdateRouterPayload_errors(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var upgradeImpactImplementors = []string{"UpgradeImpact"}

func (ec *executionContext) _UpgradeImpact(ctx context.Context, sel ast.SelectionSet, obj *model.UpgradeImpact) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, upgradeImpactImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UpgradeImpact")
		case "requiresReboot":
			out.Values[i] = ec._UpgradeImpact_requiresReboot(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "estimatedDowntime":
			out.Values[i] = ec._UpgradeImpact_estimatedDowntime(ctx, field, obj)
		case "backupRecommended":
			out.Values[i] = ec._UpgradeImpact_backupRecommended(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "breakingChanges":
			out.Values[i] = ec._UpgradeImpact_breakingChanges(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var upgradeRecommendationImplementors = []string{"UpgradeRecommendation"}

func (ec *executionContext) _UpgradeRecommendation(ctx context.Context, sel ast.SelectionSet, obj *model.UpgradeRecommendation) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, upgradeRecommendationImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UpgradeRecommendation")
		case "featureId":
			out.Values[i] = ec._UpgradeRecommendation_featureId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "featureName":
			out.Values[i] = ec._UpgradeRecommendation_featureName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "currentVersion":
			out.Values[i] = ec._UpgradeRecommendation_currentVersion(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "requiredVersion":
			out.Values[i] = ec._UpgradeRecommendation_requiredVersion(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "isMajorUpgrade":
			out.Values[i] = ec._UpgradeRecommendation_isMajorUpgrade(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "priority":
			out.Values[i] = ec._UpgradeRecommendation_priority(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "steps":
			out.Values[i] = ec._UpgradeRecommendation_steps(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "impact":
			out.Values[i] = ec._UpgradeRecommendation_impact(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "documentationUrl":
			out.Values[i] = ec._UpgradeRecommendation_documentationUrl(ctx, field, obj)
		case "warnings":
			out.Values[i] = ec._UpgradeRecommendation_warnings(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var upgradeStepImplementors = []string{"UpgradeStep"}

func (ec *executionContext) _UpgradeStep(ctx context.Context, sel ast.SelectionSet, obj *model.UpgradeStep) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, upgradeStepImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UpgradeStep")
		case "step":
			out.Values[i] = ec._UpgradeStep_step(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "title":
			out.Values[i] = ec._UpgradeStep_title(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec._UpgradeStep_description(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "command":
			out.Values[i] = ec._UpgradeStep_command(ctx, field, obj)
		case "optional":
			out.Values[i] = ec._UpgradeStep_optional(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var uptimeDataPointImplementors = []string{"UptimeDataPoint"}

func (ec *executionContext) _UptimeDataPoint(ctx context.Context, sel ast.SelectionSet, obj *model.UptimeDataPoint) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, uptimeDataPointImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UptimeDataPoint")
		case "timestamp":
			out.Values[i] = ec._UptimeDataPoint_timestamp(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "isUp":
			out.Values[i] = ec._UptimeDataPoint_isUp(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "periodSeconds":
			out.Values[i] = ec._UptimeDataPoint_periodSeconds(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var userImplementors = []string{"User", "Node"}

func (ec *executionContext) _User(ctx context.Context, sel ast.SelectionSet, obj *model.User) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, userImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("User")
		case "id":
			out.Values[i] = ec._User_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "username":
			out.Values[i] = ec._User_username(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "role":
			out.Values[i] = ec._User_role(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "email":
			out.Values[i] = ec._User_email(ctx, field, obj)
		case "displayName":
			out.Values[i] = ec._User_displayName(ctx, field, obj)
		case "createdAt":
			out.Values[i] = ec._User_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "lastLoginAt":
			out.Values[i] = ec._User_lastLoginAt(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var vIFGuidanceStepImplementors = []string{"VIFGuidanceStep"}

func (ec *executionContext) _VIFGuidanceStep(ctx context.Context, sel ast.SelectionSet, obj *model.VIFGuidanceStep) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, vIFGuidanceStepImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("VIFGuidanceStep")
		case "step":
			out.Values[i] = ec._VIFGuidanceStep_step(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "title":
			out.Values[i] = ec._VIFGuidanceStep_title(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec._VIFGuidanceStep_description(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "completed":
			out.Values[i] = ec._VIFGuidanceStep_completed(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "routerCommand":
			out.Values[i] = ec._VIFGuidanceStep_routerCommand(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var vIFRequirementsImplementors = []string{"VIFRequirements"}

func (ec *executionContext) _VIFRequirements(ctx context.Context, sel ast.SelectionSet, obj *model.VIFRequirements) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, vIFRequirementsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("VIFRequirements")
		case "met":
			out.Values[i] = ec._VIFRequirements_met(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "routerOSVersion":
			out.Values[i] = ec._VIFRequirements_routerOSVersion(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "containerPackage":
			out.Values[i] = ec._VIFRequirements_containerPackage(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "containerEnabled":
			out.Values[i] = ec._VIFRequirements_containerEnabled(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "sufficientStorage":
			out.Values[i] = ec._VIFRequirements_sufficientStorage(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "networkNamespace":
			out.Values[i] = ec._VIFRequirements_networkNamespace(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "missingReasons":
			out.Values[i] = ec._VIFRequirements_missingReasons(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "guidanceSteps":
			out.Values[i] = ec._VIFRequirements_guidanceSteps(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var validateChangeSetPayloadImplementors = []string{"ValidateChangeSetPayload"}

func (ec *executionContext) _ValidateChangeSetPayload(ctx context.Context, sel ast.SelectionSet, obj *model.ValidateChangeSetPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, validateChangeSetPayloadImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ValidateChangeSetPayload")
		case "changeSet":
			out.Values[i] = ec._ValidateChangeSetPayload_changeSet(ctx, field, obj)
		case "validation":
			out.Values[i] = ec._ValidateChangeSetPayload_validation(ctx, field, obj)
		case "errors":
			out.Values[i] = ec._ValidateChangeSetPayload_errors(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var validateResourcePayloadImplementors = []string{"ValidateResourcePayload"}

func (ec *executionContext) _ValidateResourcePayload(ctx context.Context, sel ast.SelectionSet, obj *model.ValidateResourcePayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, validateResourcePayloadImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ValidateResourcePayload")
		case "resource":
			out.Values[i] = ec._ValidateResourcePayload_resource(ctx, field, obj)
		case "validation":
			out.Values[i] = ec._ValidateResourcePayload_validation(ctx, field, obj)
		case "errors":
			out.Values[i] = ec._ValidateResourcePayload_errors(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var validationErrorImplementors = []string{"ValidationError"}

func (ec *executionContext) _ValidationError(ctx context.Context, sel ast.SelectionSet, obj *model.ValidationError) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, validationErrorImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ValidationError")
		case "field":
			out.Values[i] = ec._ValidationError_field(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "code":
			out.Values[i] = ec._ValidationError_code(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "message":
			out.Values[i] = ec._ValidationError_message(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "suggestion":
			out.Values[i] = ec._ValidationError_suggestion(ctx, field, obj)
		case "providedValue":
			out.Values[i] = ec._ValidationError_providedValue(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var validationIssueImplementors = []string{"ValidationIssue"}

func (ec *executionContext) _ValidationIssue(ctx context.Context, sel ast.SelectionSet, obj *model.ValidationIssue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, validationIssueImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ValidationIssue")
		case "code":
			out.Values[i] = ec._ValidationIssue_code(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "message":
			out.Values[i] = ec._ValidationIssue_message(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "field":
			out.Values[i] = ec._ValidationIssue_field(ctx, field, obj)
		case "severity":
			out.Values[i] = ec._ValidationIssue_severity(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "suggestedFix":
			out.Values[i] = ec._ValidationIssue_suggestedFix(ctx, field, obj)
		case "docsUrl":
			out.Values[i] = ec._ValidationIssue_docsUrl(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var validationResultImplementors = []string{"ValidationResult"}

func (ec *executionContext) _ValidationResult(ctx context.Context, sel ast.SelectionSet, obj *model.ValidationResult) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, validationResultImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ValidationResult")
		case "canApply":
			out.Values[i] = ec._ValidationResult_canApply(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "stage":
			out.Values[i] = ec._ValidationResult_stage(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "errors":
			out.Values[i] = ec._ValidationResult_errors(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "warnings":
			out.Values[i] = ec._ValidationResult_warnings(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "conflicts":
			out.Values[i] = ec._ValidationResult_conflicts(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "requiredDependencies":
			out.Values[i] = ec._ValidationResult_requiredDependencies(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "validatedAt":
			out.Values[i] = ec._ValidationResult_validatedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "validationDurationMs":
			out.Values[i] = ec._ValidationResult_validationDurationMs(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var vlanImplementors = []string{"Vlan", "Node"}

func (ec *executionContext) _Vlan(ctx context.Context, sel ast.SelectionSet, obj *model.Vlan) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, vlanImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Vlan")
		case "id":
			out.Values[i] = ec._Vlan_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec._Vlan_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "vlanId":
			out.Values[i] = ec._Vlan_vlanId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "interface":
			out.Values[i] = ec._Vlan_interface(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "mtu":
			out.Values[i] = ec._Vlan_mtu(ctx, field, obj)
		case "macAddress":
			out.Values[i] = ec._Vlan_macAddress(ctx, field, obj)
		case "disabled":
			out.Values[i] = ec._Vlan_disabled(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "running":
			out.Values[i] = ec._Vlan_running(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "comment":
			out.Values[i] = ec._Vlan_comment(ctx, field, obj)
		case "ipAddresses":
			out.Values[i] = ec._Vlan_ipAddresses(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "statistics":
			out.Values[i] = ec._Vlan_statistics(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var vlanDependenciesImplementors = []string{"VlanDependencies"}

func (ec *executionContext) _VlanDependencies(ctx context.Context, sel ast.SelectionSet, obj *model.VlanDependencies) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, vlanDependenciesImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("VlanDependencies")
		case "vlanId":
			out.Values[i] = ec._VlanDependencies_vlanId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "ipAddresses":
			out.Values[i] = ec._VlanDependencies_ipAddresses(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "dhcpServers":
			out.Values[i] = ec._VlanDependencies_dhcpServers(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "firewallRules":
			out.Values[i] = ec._VlanDependencies_firewallRules(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "routes":
			out.Values[i] = ec._VlanDependencies_routes(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "activeConnections":
			out.Values[i] = ec._VlanDependencies_activeConnections(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "hasDependencies":
			out.Values[i] = ec._VlanDependencies_hasDependencies(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var vlanMutationResultImplementors = []string{"VlanMutationResult"}

func (ec *executionContext) _VlanMutationResult(ctx context.Context, sel ast.SelectionSet, obj *model.VlanMutationResult) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, vlanMutationResultImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("VlanMutationResult")
		case "success":
			out.Values[i] = ec._VlanMutationResult_success(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "vlan":
			out.Values[i] = ec._VlanMutationResult_vlan(ctx, field, obj)
		case "preview":
			out.Values[i] = ec._VlanMutationResult_preview(ctx, field, obj)
		case "errors":
			out.Values[i] = ec._VlanMutationResult_errors(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var vlanTopologyImplementors = []string{"VlanTopology"}

func (ec *executionContext) _VlanTopology(ctx context.Context, sel ast.SelectionSet, obj *model.VlanTopology) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, vlanTopologyImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("VlanTopology")
		case "nodes":
			out.Values[i] = ec._VlanTopology_nodes(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "edges":
			out.Values[i] = ec._VlanTopology_edges(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var wANConnectionEventImplementors = []string{"WANConnectionEvent"}

func (ec *executionContext) _WANConnectionEvent(ctx context.Context, sel ast.SelectionSet, obj *model.WANConnectionEvent) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, wANConnectionEventImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("WANConnectionEvent")
		case "id":
			out.Values[i] = ec._WANConnectionEvent_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "wanInterfaceId":
			out.Values[i] = ec._WANConnectionEvent_wanInterfaceId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "eventType":
			out.Values[i] = ec._WANConnectionEvent_eventType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "timestamp":
			out.Values[i] = ec._WANConnectionEvent_timestamp(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "publicIP":
			out.Values[i] = ec._WANConnectionEvent_publicIP(ctx, field, obj)
		case "gateway":
			out.Values[i] = ec._WANConnectionEvent_gateway(ctx, field, obj)
		case "reason":
			out.Values[i] = ec._WANConnectionEvent_reason(ctx, field, obj)
		case "duration":
			out.Values[i] = ec._WANConnectionEvent_duration(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var wANConnectionEventConnectionImplementors = []string{"WANConnectionEventConnection", "Connection"}

func (ec *executionContext) _WANConnectionEventConnection(ctx context.Context, sel ast.SelectionSet, obj *model.WANConnectionEventConnection) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, wANConnectionEventConnectionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("WANConnectionEventConnection")
		case "edges":
			out.Values[i] = ec._WANConnectionEventConnection_edges(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "pageInfo":
			out.Values[i] = ec._WANConnectionEventConnection_pageInfo(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "totalCount":
			out.Values[i] = ec._WANConnectionEventConnection_totalCount(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var wANConnectionEventEdgeImplementors = []string{"WANConnectionEventEdge", "Edge"}

func (ec *executionContext) _WANConnectionEventEdge(ctx context.Context, sel ast.SelectionSet, obj *model.WANConnectionEventEdge) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, wANConnectionEventEdgeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("WANConnectionEventEdge")
		case "node":
			out.Values[i] = ec._WANConnectionEventEdge_node(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "cursor":
			out.Values[i] = ec._WANConnectionEventEdge_cursor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var wANHealthStatusImplementors = []string{"WANHealthStatus"}

func (ec *executionContext) _WANHealthStatus(ctx context.Context, sel ast.SelectionSet, obj *model.WANHealthStatus) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, wANHealthStatusImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("WANHealthStatus")
		case "status":
			out.Values[i] = ec._WANHealthStatus_status(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "target":
			out.Values[i] = ec._WANHealthStatus_target(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "interval":
			out.Values[i] = ec._WANHealthStatus_interval(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "latency":
			out.Values[i] = ec._WANHealthStatus_latency(ctx, field, obj)
		case "packetLoss":
			out.Values[i] = ec._WANHealthStatus_packetLoss(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "successCount":
			out.Values[i] = ec._WANHealthStatus_successCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "failureCount":
			out.Values[i] = ec._WANHealthStatus_failureCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "lastCheck":
			out.Values[i] = ec._WANHealthStatus_lastCheck(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "enabled":
			out.Values[i] = ec._WANHealthStatus_enabled(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var wANInterfaceImplementors = []string{"WANInterface", "Node"}

func (ec *executionContext) _WANInterface(ctx context.Context, sel ast.SelectionSet, obj *model.WANInterface) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, wANInterfaceImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("WANInterface")
		case "id":
			out.Values[i] = ec._WANInterface_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "interface":
			out.Values[i] = ec._WANInterface_interface(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "type":
			out.Values[i] = ec._WANInterface_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "status":
			out.Values[i] = ec._WANInterface_status(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "publicIP":
			out.Values[i] = ec._WANInterface_publicIP(ctx, field, obj)
		case "gateway":
			out.Values[i] = ec._WANInterface_gateway(ctx, field, obj)
		case "primaryDNS":
			out.Values[i] = ec._WANInterface_primaryDNS(ctx, field, obj)
		case "secondaryDNS":
			out.Values[i] = ec._WANInterface_secondaryDNS(ctx, field, obj)
		case "uptime":
			out.Values[i] = ec._WANInterface_uptime(ctx, field, obj)
		case "lastConnected":
			out.Values[i] = ec._WANInterface_lastConnected(ctx, field, obj)
		case "health":
			out.Values[i] = ec._WANInterface_health(ctx, field, obj)
		case "dhcpClient":
			out.Values[i] = ec._WANInterface_dhcpClient(ctx, field, obj)
		case "pppoeClient":
			out.Values[i] = ec._WANInterface_pppoeClient(ctx, field, obj)
		case "staticConfig":
			out.Values[i] = ec._WANInterface_staticConfig(ctx, field, obj)
		case "lteModem":
			out.Values[i] = ec._WANInterface_lteModem(ctx, field, obj)
		case "isDefaultRoute":
			out.Values[i] = ec._WANInterface_isDefaultRoute(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "statistics":
			out.Values[i] = ec._WANInterface_statistics(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var wANLinkImplementors = []string{"WANLink", "Resource", "Node"}

func (ec *executionContext) _WANLink(ctx context.Context, sel ast.SelectionSet, obj *model.WANLink) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, wANLinkImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("WANLink")
		case "id":
			out.Values[i] = ec._WANLink_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "scopedId":
			out.Values[i] = ec._WANLink_scopedId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "type":
			out.Values[i] = ec._WANLink_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "category":
			out.Values[i] = ec._WANLink_category(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "configuration":
			out.Values[i] = ec._WANLink_configuration(ctx, field, obj)
		case "validation":
			out.Values[i] = ec._WANLink_validation(ctx, field, obj)
		case "deployment":
			out.Values[i] = ec._WANLink_deployment(ctx, field, obj)
		case "runtime":
			out.Values[i] = ec._WANLink_runtime(ctx, field, obj)
		case "telemetry":
			out.Values[i] = ec._WANLink_telemetry(ctx, field, obj)
		case "metadata":
			out.Values[i] = ec._WANLink_metadata(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "relationships":
			out.Values[i] = ec._WANLink_relationships(ctx, field, obj)
		case "platform":
			out.Values[i] = ec._WANLink_platform(ctx, field, obj)
		case "wanRuntime":
			out.Values[i] = ec._WANLink_wanRuntime(ctx, field, obj)
		case "interface":
			out.Values[i] = ec._WANLink_interface(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "connectionType":
			out.Values[i] = ec._WANLink_connectionType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "isPrimary":
			out.Values[i] = ec._WANLink_isPrimary(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "failoverPriority":
			out.Values[i] = ec._WANLink_failoverPriority(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var wANLinkRuntimeImplementors = []string{"WANLinkRuntime"}

func (ec *executionContext) _WANLinkRuntime(ctx context.Context, sel ast.SelectionSet, obj *model.WANLinkRuntime) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, wANLinkRuntimeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("WANLinkRuntime")
		case "isRunning":
			out.Values[i] = ec._WANLinkRuntime_isRunning(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "health":
			out.Values[i] = ec._WANLinkRuntime_health(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "errorMessage":
			out.Values[i] = ec._WANLinkRuntime_errorMessage(ctx, field, obj)
		case "lastUpdated":
			out.Values[i] = ec._WANLinkRuntime_lastUpdated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "currentIP":
			out.Values[i] = ec._WANLinkRuntime_currentIP(ctx, field, obj)
		case "gateway":
			out.Values[i] = ec._WANLinkRuntime_gateway(ctx, field, obj)
		case "publicIP":
			out.Values[i] = ec._WANLinkRuntime_publicIP(ctx, field, obj)
		case "dnsServers":
			out.Values[i] = ec._WANLinkRuntime_dnsServers(ctx, field, obj)
		case "uplinkSpeed":
			out.Values[i] = ec._WANLinkRuntime_uplinkSpeed(ctx, field, obj)
		case "downlinkSpeed":
			out.Values[i] = ec._WANLinkRuntime_downlinkSpeed(ctx, field, obj)
		case "uptime":
			out.Values[i] = ec._WANLinkRuntime_uptime(ctx, field, obj)
		case "lastStateChange":
			out.Values[i] = ec._WANLinkRuntime_lastStateChange(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var wANMutationResultImplementors = []string{"WANMutationResult"}

func (ec *executionContext) _WANMutationResult(ctx context.Context, sel ast.SelectionSet, obj *model.WANMutationResult) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, wANMutationResultImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("WANMutationResult")
		case "success":
			out.Values[i] = ec._WANMutationResult_success(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "wanInterface":
			out.Values[i] = ec._WANMutationResult_wanInterface(ctx, field, obj)
		case "preview":
			out.Values[i] = ec._WANMutationResult_preview(ctx, field, obj)
		case "errors":
			out.Values[i] = ec._WANMutationResult_errors(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var wireGuardClientImplementors = []string{"WireGuardClient", "Resource", "Node"}

func (ec *executionContext) _WireGuardClient(ctx context.Context, sel ast.SelectionSet, obj *model.WireGuardClient) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, wireGuardClientImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("WireGuardClient")
		case "id":
			out.Values[i] = ec._WireGuardClient_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "scopedId":
			out.Values[i] = ec._WireGuardClient_scopedId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "type":
			out.Values[i] = ec._WireGuardClient_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "category":
			out.Values[i] = ec._WireGuardClient_category(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "configuration":
			out.Values[i] = ec._WireGuardClient_configuration(ctx, field, obj)
		case "validation":
			out.Values[i] = ec._WireGuardClient_validation(ctx, field, obj)
		case "deployment":
			out.Values[i] = ec._WireGuardClient_deployment(ctx, field, obj)
		case "runtime":
			out.Values[i] = ec._WireGuardClient_runtime(ctx, field, obj)
		case "telemetry":
			out.Values[i] = ec._WireGuardClient_telemetry(ctx, field, obj)
		case "metadata":
			out.Values[i] = ec._WireGuardClient_metadata(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "relationships":
			out.Values[i] = ec._WireGuardClient_relationships(ctx, field, obj)
		case "platform":
			out.Values[i] = ec._WireGuardClient_platform(ctx, field, obj)
		case "config":
			out.Values[i] = ec._WireGuardClient_config(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "wireguardDeployment":
			out.Values[i] = ec._WireGuardClient_wireguardDeployment(ctx, field, obj)
		case "wireguardRuntime":
			out.Values[i] = ec._WireGuardClient_wireguardRuntime(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var wireGuardClientConfigImplementors = []string{"WireGuardClientConfig"}

func (ec *executionContext) _WireGuardClientConfig(ctx context.Context, sel ast.SelectionSet, obj *model.WireGuardClientConfig) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, wireGuardClientConfigImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("WireGuardClientConfig")
		case "name":
			out.Values[i] = ec._WireGuardClientConfig_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "privateKey":
			out.Values[i] = ec._WireGuardClientConfig_privateKey(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "peerPublicKey":
			out.Values[i] = ec._WireGuardClientConfig_peerPublicKey(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "peerEndpoint":
			out.Values[i] = ec._WireGuardClientConfig_peerEndpoint(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "allowedIPs":
			out.Values[i] = ec._WireGuardClientConfig_allowedIPs(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "persistentKeepalive":
			out.Values[i] = ec._WireGuardClientConfig_persistentKeepalive(ctx, field, obj)
		case "listenPort":
			out.Values[i] = ec._WireGuardClientConfig_listenPort(ctx, field, obj)
		case "wanInterface":
			out.Values[i] = ec._WireGuardClientConfig_wanInterface(ctx, field, obj)
		case "killSwitch":
			out.Values[i] = ec._WireGuardClientConfig_killSwitch(ctx, field, obj)
		case "dnsServers":
			out.Values[i] = ec._WireGuardClientConfig_dnsServers(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var wireGuardDeploymentImplementors = []string{"WireGuardDeployment"}

func (ec *executionContext) _WireGuardDeployment(ctx context.Context, sel ast.SelectionSet, obj *model.WireGuardDeployment) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, wireGuardDeploymentImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("WireGuardDeployment")
		case "routerResourceId":
			out.Values[i] = ec._WireGuardDeployment_routerResourceId(ctx, field, obj)
		case "appliedAt":
			out.Values[i] = ec._WireGuardDeployment_appliedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "appliedBy":
			out.Values[i] = ec._WireGuardDeployment_appliedBy(ctx, field, obj)
		case "routerVersion":
			out.Values[i] = ec._WireGuardDeployment_routerVersion(ctx, field, obj)
		case "isInSync":
			out.Values[i] = ec._WireGuardDeployment_isInSync(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "drift":
			out.Values[i] = ec._WireGuardDeployment_drift(ctx, field, obj)
		case "publicKey":
			out.Values[i] = ec._WireGuardDeployment_publicKey(ctx, field, obj)
		case "interfaceName":
			out.Values[i] = ec._WireGuardDeployment_interfaceName(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var wireGuardRuntimeImplementors = []string{"WireGuardRuntime"}

func (ec *executionContext) _WireGuardRuntime(ctx context.Context, sel ast.SelectionSet, obj *model.WireGuardRuntime) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, wireGuardRuntimeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("WireGuardRuntime")
		case "isRunning":
			out.Values[i] = ec._WireGuardRuntime_isRunning(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "health":
			out.Values[i] = ec._WireGuardRuntime_health(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "errorMessage":
			out.Values[i] = ec._WireGuardRuntime_errorMessage(ctx, field, obj)
		case "lastUpdated":
			out.Values[i] = ec._WireGuardRuntime_lastUpdated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "isConnected":
			out.Values[i] = ec._WireGuardRuntime_isConnected(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "lastHandshake":
			out.Values[i] = ec._WireGuardRuntime_lastHandshake(ctx, field, obj)
		case "currentEndpoint":
			out.Values[i] = ec._WireGuardRuntime_currentEndpoint(ctx, field, obj)
		case "bytesIn":
			out.Values[i] = ec._WireGuardRuntime_bytesIn(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "bytesOut":
			out.Values[i] = ec._WireGuardRuntime_bytesOut(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "activePeers":
			out.Values[i] = ec._WireGuardRuntime_activePeers(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __DirectiveImplementors = []string{"__Directive"}

func (ec *executionContext) ___Directive(ctx context.Context, sel ast.SelectionSet, obj *introspection.Directive) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __DirectiveImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Directive")
		case "name":
			out.Values[i] = ec.___Directive_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___Directive_description(ctx, field, obj)
		case "locations":
			out.Values[i] = ec.___Directive_locations(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "args":
			out.Values[i] = ec.___Directive_args(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "isRepeatable":
			out.Values[i] = ec.___Directive_isRepeatable(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __EnumValueImplementors = []string{"__EnumValue"}

func (ec *executionContext) ___EnumValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.EnumValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __EnumValueImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__EnumValue")
		case "name":
			out.Values[i] = ec.___EnumValue_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___EnumValue_description(ctx, field, obj)
		case "isDeprecated":
			out.Values[i] = ec.___EnumValue_isDeprecated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deprecationReason":
			out.Values[i] = ec.___EnumValue_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __FieldImplementors = []string{"__Field"}

func (ec *executionContext) ___Field(ctx context.Context, sel ast.SelectionSet, obj *introspection.Field) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __FieldImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Field")
		case "name":
			out.Values[i] = ec.___Field_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___Field_description(ctx, field, obj)
		case "args":
			out.Values[i] = ec.___Field_args(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "type":
			out.Values[i] = ec.___Field_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "isDeprecated":
			out.Values[i] = ec.___Field_isDeprecated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deprecationReason":
			out.Values[i] = ec.___Field_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __InputValueImplementors = []string{"__InputValue"}

func (ec *executionContext) ___InputValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.InputValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __InputValueImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__InputValue")
		case "name":
			out.Values[i] = ec.___InputValue_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___InputValue_description(ctx, field, obj)
		case "type":
			out.Values[i] = ec.___InputValue_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "defaultValue":
			out.Values[i] = ec.___InputValue_defaultValue(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __SchemaImplementors = []string{"__Schema"}

func (ec *executionContext) ___Schema(ctx context.Context, sel ast.SelectionSet, obj *introspection.Schema) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __SchemaImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Schema")
		case "description":
			out.Values[i] = ec.___Schema_description(ctx, field, obj)
		case "types":
			out.Values[i] = ec.___Schema_types(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "queryType":
			out.Values[i] = ec.___Schema_queryType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "mutationType":
			out.Values[i] = ec.___Schema_mutationType(ctx, field, obj)
		case "subscriptionType":
			out.Values[i] = ec.___Schema_subscriptionType(ctx, field, obj)
		case "directives":
			out.Values[i] = ec.___Schema_directives(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __TypeImplementors = []string{"__Type"}

func (ec *executionContext) ___Type(ctx context.Context, sel ast.SelectionSet, obj *introspection.Type) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __TypeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Type")
		case "kind":
			out.Values[i] = ec.___Type_kind(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec.___Type_name(ctx, field, obj)
		case "description":
			out.Values[i] = ec.___Type_description(ctx, field, obj)
		case "fields":
			out.Values[i] = ec.___Type_fields(ctx, field, obj)
		case "interfaces":
			out.Values[i] = ec.___Type_interfaces(ctx, field, obj)
		case "possibleTypes":
			out.Values[i] = ec.___Type_possibleTypes(ctx, field, obj)
		case "enumValues":
			out.Values[i] = ec.___Type_enumValues(ctx, field, obj)
		case "inputFields":
			out.Values[i] = ec.___Type_inputFields(ctx, field, obj)
		case "ofType":
			out.Values[i] = ec.___Type_ofType(ctx, field, obj)
		case "specifiedByURL":
			out.Values[i] = ec.___Type_specifiedByURL(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

// endregion **************************** object.gotpl ****************************

// region    ***************************** type.gotpl *****************************

func (ec *executionContext) unmarshalNAddBridgePortInput2backendgraphmodelAddBridgePortInput(ctx context.Context, v interface{}) (model.AddBridgePortInput, error) {
	res, err := ec.unmarshalInputAddBridgePortInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNAddChangeSetItemPayload2backendgraphmodelAddChangeSetItemPayload(ctx context.Context, sel ast.SelectionSet, v model.AddChangeSetItemPayload) graphql.Marshaler {
	return ec._AddChangeSetItemPayload(ctx, sel, &v)
}

func (ec *executionContext) marshalNAddChangeSetItemPayload2backendgraphmodelAddChangeSetItemPayload(ctx context.Context, sel ast.SelectionSet, v *model.AddChangeSetItemPayload) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._AddChangeSetItemPayload(ctx, sel, v)
}

func (ec *executionContext) unmarshalNAddRouterInput2backendgraphmodelAddRouterInput(ctx context.Context, v interface{}) (model.AddRouterInput, error) {
	res, err := ec.unmarshalInputAddRouterInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNAddRouterPayload2backendgraphmodelAddRouterPayload(ctx context.Context, sel ast.SelectionSet, v model.AddRouterPayload) graphql.Marshaler {
	return ec._AddRouterPayload(ctx, sel, &v)
}

func (ec *executionContext) marshalNAddRouterPayload2backendgraphmodelAddRouterPayload(ctx context.Context, sel ast.SelectionSet, v *model.AddRouterPayload) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._AddRouterPayload(ctx, sel, v)
}

func (ec *executionContext) marshalNAffectedResource2backendgraphmodelAffectedResource(ctx context.Context, sel ast.SelectionSet, v *model.AffectedResource) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._AffectedResource(ctx, sel, v)
}

func (ec *executionContext) marshalNAlert2backendgraphmodelAlert(ctx context.Context, sel ast.SelectionSet, v []*model.Alert) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNAlert2backendgraphmodelAlert(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNAlert2backendgraphmodelAlert(ctx context.Context, sel ast.SelectionSet, v *model.Alert) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Alert(ctx, sel, v)
}

func (ec *executionContext) unmarshalNAlertAction2backendgraphmodelAlertAction(ctx context.Context, v interface{}) (model.AlertAction, error) {
	var res model.AlertAction
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNAlertAction2backendgraphmodelAlertAction(ctx context.Context, sel ast.SelectionSet, v model.AlertAction) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNAlertCondition2backendgraphmodelAlertCondition(ctx context.Context, sel ast.SelectionSet, v []*model.AlertCondition) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNAlertCondition2backendgraphmodelAlertCondition(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNAlertCondition2backendgraphmodelAlertCondition(ctx context.Context, sel ast.SelectionSet, v *model.AlertCondition) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._AlertCondition(ctx, sel, v)
}

func (ec *executionContext) unmarshalNAlertConditionInput2backendgraphmodelAlertConditionInput(ctx context.Context, v interface{}) (*model.AlertConditionInput, error) {
	res, err := ec.unmarshalInputAlertConditionInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNAlertConnection2backendgraphmodelAlertConnection(ctx context.Context, sel ast.SelectionSet, v model.AlertConnection) graphql.Marshaler {
	return ec._AlertConnection(ctx, sel, &v)
}

func (ec *executionContext) marshalNAlertConnection2backendgraphmodelAlertConnection(ctx context.Context, sel ast.SelectionSet, v *model.AlertConnection) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._AlertConnection(ctx, sel, v)
}

func (ec *executionContext) marshalNAlertEdge2backendgraphmodelAlertEdge(ctx context.Context, sel ast.SelectionSet, v []*model.AlertEdge) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNAlertEdge2backendgraphmodelAlertEdge(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNAlertEdge2backendgraphmodelAlertEdge(ctx context.Context, sel ast.SelectionSet, v *model.AlertEdge) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._AlertEdge(ctx, sel, v)
}

func (ec *executionContext) marshalNAlertEvent2backendgraphmodelAlertEvent(ctx context.Context, sel ast.SelectionSet, v model.AlertEvent) graphql.Marshaler {
	return ec._AlertEvent(ctx, sel, &v)
}

func (ec *executionContext) marshalNAlertEvent2backendgraphmodelAlertEvent(ctx context.Context, sel ast.SelectionSet, v *model.AlertEvent) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._AlertEvent(ctx, sel, v)
}

func (ec *executionContext) marshalNAlertPayload2backendgraphmodelAlertPayload(ctx context.Context, sel ast.SelectionSet, v model.AlertPayload) graphql.Marshaler {
	return ec._AlertPayload(ctx, sel, &v)
}

func (ec *executionContext) marshalNAlertPayload2backendgraphmodelAlertPayload(ctx context.Context, sel ast.SelectionSet, v *model.AlertPayload) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._AlertPayload(ctx, sel, v)
}

func (ec *executionContext) marshalNAlertRule2backendgraphmodelAlertRule(ctx context.Context, sel ast.SelectionSet, v []*model.AlertRule) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNAlertRule2backendgraphmodelAlertRule(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNAlertRule2backendgraphmodelAlertRule(ctx context.Context, sel ast.SelectionSet, v *model.AlertRule) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._AlertRule(ctx, sel, v)
}

func (ec *executionContext) marshalNAlertRulePayload2backendgraphmodelAlertRulePayload(ctx context.Context, sel ast.SelectionSet, v model.AlertRulePayload) graphql.Marshaler {
	return ec._AlertRulePayload(ctx, sel, &v)
}

func (ec *executionContext) marshalNAlertRulePayload2backendgraphmodelAlertRulePayload(ctx context.Context, sel ast.SelectionSet, v *model.AlertRulePayload) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._AlertRulePayload(ctx, sel, v)
}

func (ec *executionContext) unmarshalNAlertSeverity2backendgraphmodelAlertSeverity(ctx context.Context, v interface{}) (model.AlertSeverity, error) {
	var res model.AlertSeverity
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNAlertSeverity2backendgraphmodelAlertSeverity(ctx context.Context, sel ast.SelectionSet, v model.AlertSeverity) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNApplyChangeSetPayload2backendgraphmodelApplyChangeSetPayload(ctx context.Context, sel ast.SelectionSet, v model.ApplyChangeSetPayload) graphql.Marshaler {
	return ec._ApplyChangeSetPayload(ctx, sel, &v)
}

func (ec *executionContext) marshalNApplyChangeSetPayload2backendgraphmodelApplyChangeSetPayload(ctx context.Context, sel ast.SelectionSet, v *model.ApplyChangeSetPayload) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ApplyChangeSetPayload(ctx, sel, v)
}

func (ec *executionContext) marshalNApplyFixPayload2backendgraphmodelApplyFixPayload(ctx context.Context, sel ast.SelectionSet, v model.ApplyFixPayload) graphql.Marshaler {
	return ec._ApplyFixPayload(ctx, sel, &v)
}

func (ec *executionContext) marshalNApplyFixPayload2backendgraphmodelApplyFixPayload(ctx context.Context, sel ast.SelectionSet, v *model.ApplyFixPayload) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ApplyFixPayload(ctx, sel, v)
}

func (ec *executionContext) marshalNApplyResourcePayload2backendgraphmodelApplyResourcePayload(ctx context.Context, sel ast.SelectionSet, v model.ApplyResourcePayload) graphql.Marshaler {
	return ec._ApplyResourcePayload(ctx, sel, &v)
}

func (ec *executionContext) marshalNApplyResourcePayload2backendgraphmodelApplyResourcePayload(ctx context.Context, sel ast.SelectionSet, v *model.ApplyResourcePayload) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ApplyResourcePayload(ctx, sel, v)
}

func (ec *executionContext) marshalNArchiveResourcePayload2backendgraphmodelArchiveResourcePayload(ctx context.Context, sel ast.SelectionSet, v model.ArchiveResourcePayload) graphql.Marshaler {
	return ec._ArchiveResourcePayload(ctx, sel, &v)
}

func (ec *executionContext) marshalNArchiveResourcePayload2backendgraphmodelArchiveResourcePayload(ctx context.Context, sel ast.SelectionSet, v *model.ArchiveResourcePayload) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ArchiveResourcePayload(ctx, sel, v)
}

func (ec *executionContext) marshalNAuthPayload2backendgraphmodelAuthPayload(ctx context.Context, sel ast.SelectionSet, v model.AuthPayload) graphql.Marshaler {
	return ec._AuthPayload(ctx, sel, &v)
}

func (ec *executionContext) marshalNAuthPayload2backendgraphmodelAuthPayload(ctx context.Context, sel ast.SelectionSet, v *model.AuthPayload) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._AuthPayload(ctx, sel, v)
}

func (ec *executionContext) marshalNAuthStatus2backendgraphmodelAuthStatus(ctx context.Context, sel ast.SelectionSet, v *model.AuthStatus) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._AuthStatus(ctx, sel, v)
}

func (ec *executionContext) marshalNBandwidthDataPoint2backendgraphmodelBandwidthDataPoint(ctx context.Context, sel ast.SelectionSet, v *model.BandwidthDataPoint) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._BandwidthDataPoint(ctx, sel, v)
}

func (ec *executionContext) unmarshalNBatchInterfaceAction2backendgraphmodelBatchInterfaceAction(ctx context.Context, v interface{}) (model.BatchInterfaceAction, error) {
	var res model.BatchInterfaceAction
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNBatchInterfaceAction2backendgraphmodelBatchInterfaceAction(ctx context.Context, sel ast.SelectionSet, v model.BatchInterfaceAction) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNBatchInterfaceInput2backendgraphmodelBatchInterfaceInput(ctx context.Context, v interface{}) (model.BatchInterfaceInput, error) {
	res, err := ec.unmarshalInputBatchInterfaceInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNBatchInterfacePayload2backendgraphmodelBatchInterfacePayload(ctx context.Context, sel ast.SelectionSet, v model.BatchInterfacePayload) graphql.Marshaler {
	return ec._BatchInterfacePayload(ctx, sel, &v)
}

func (ec *executionContext) marshalNBatchInterfacePayload2backendgraphmodelBatchInterfacePayload(ctx context.Context, sel ast.SelectionSet, v *model.BatchInterfacePayload) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._BatchInterfacePayload(ctx, sel, v)
}

func (ec *executionContext) unmarshalNBoolean2bool(ctx context.Context, v interface{}) (bool, error) {
	res, err := graphql.UnmarshalBoolean(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	res := graphql.MarshalBoolean(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNBridge2backendgraphmodelBridge(ctx context.Context, sel ast.SelectionSet, v []*model.Bridge) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNBridge2backendgraphmodelBridge(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNBridge2backendgraphmodelBridge(ctx context.Context, sel ast.SelectionSet, v *model.Bridge) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Bridge(ctx, sel, v)
}

func (ec *executionContext) marshalNBridgeMutationResult2backendgraphmodelBridgeMutationResult(ctx context.Context, sel ast.SelectionSet, v model.BridgeMutationResult) graphql.Marshaler {
	return ec._BridgeMutationResult(ctx, sel, &v)
}

func (ec *executionContext) marshalNBridgeMutationResult2backendgraphmodelBridgeMutationResult(ctx context.Context, sel ast.SelectionSet, v *model.BridgeMutationResult) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._BridgeMutationResult(ctx, sel, v)
}

func (ec *executionContext) marshalNBridgePort2backendgraphmodelBridgePort(ctx context.Context, sel ast.SelectionSet, v []*model.BridgePort) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNBridgePort2backendgraphmodelBridgePort(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNBridgePort2backendgraphmodelBridgePort(ctx context.Context, sel ast.SelectionSet, v *model.BridgePort) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._BridgePort(ctx, sel, v)
}

func (ec *executionContext) unmarshalNBridgePortFrameTypes2backendgraphmodelBridgePortFrameTypes(ctx context.Context, v interface{}) (model.BridgePortFrameTypes, error) {
	var res model.BridgePortFrameTypes
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNBridgePortFrameTypes2backendgraphmodelBridgePortFrameTypes(ctx context.Context, sel ast.SelectionSet, v model.BridgePortFrameTypes) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNBridgePortMutationResult2backendgraphmodelBridgePortMutationResult(ctx context.Context, sel ast.SelectionSet, v model.BridgePortMutationResult) graphql.Marshaler {
	return ec._BridgePortMutationResult(ctx, sel, &v)
}

func (ec *executionContext) marshalNBridgePortMutationResult2backendgraphmodelBridgePortMutationResult(ctx context.Context, sel ast.SelectionSet, v *model.BridgePortMutationResult) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._BridgePortMutationResult(ctx, sel, v)
}

func (ec *executionContext) unmarshalNBridgePortVlanInput2backendgraphmodelBridgePortVlanInput(ctx context.Context, v interface{}) (model.BridgePortVlanInput, error) {
	res, err := ec.unmarshalInputBridgePortVlanInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNBridgeStpStatus2backendgraphmodelBridgeStpStatus(ctx context.Context, sel ast.SelectionSet, v model.BridgeStpStatus) graphql.Marshaler {
	return ec._BridgeStpStatus(ctx, sel, &v)
}

func (ec *executionContext) marshalNBridgeStpStatus2backendgraphmodelBridgeStpStatus(ctx context.Context, sel ast.SelectionSet, v *model.BridgeStpStatus) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._BridgeStpStatus(ctx, sel, v)
}

func (ec *executionContext) marshalNBridgeVlan2backendgraphmodelBridgeVlan(ctx context.Context, sel ast.SelectionSet, v []*model.BridgeVlan) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNBridgeVlan2backendgraphmodelBridgeVlan(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNBridgeVlan2backendgraphmodelBridgeVlan(ctx context.Context, sel ast.SelectionSet, v *model.BridgeVlan) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._BridgeVlan(ctx, sel, v)
}

func (ec *executionContext) marshalNBridgeVlanMutationResult2backendgraphmodelBridgeVlanMutationResult(ctx context.Context, sel ast.SelectionSet, v model.BridgeVlanMutationResult) graphql.Marshaler {
	return ec._BridgeVlanMutationResult(ctx, sel, &v)
}

func (ec *executionContext) marshalNBridgeVlanMutationResult2backendgraphmodelBridgeVlanMutationResult(ctx context.Context, sel ast.SelectionSet, v *model.BridgeVlanMutationResult) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._BridgeVlanMutationResult(ctx, sel, v)
}

func (ec *executionContext) marshalNBulkAlertPayload2backendgraphmodelBulkAlertPayload(ctx context.Context, sel ast.SelectionSet, v model.BulkAlertPayload) graphql.Marshaler {
	return ec._BulkAlertPayload(ctx, sel, &v)
}

func (ec *executionContext) marshalNBulkAlertPayload2backendgraphmodelBulkAlertPayload(ctx context.Context, sel ast.SelectionSet, v *model.BulkAlertPayload) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._BulkAlertPayload(ctx, sel, v)
}

func (ec *executionContext) unmarshalNCIDR2backendgraphmodelCIDR(ctx context.Context, v interface{}) (model.CIDR, error) {
	var res model.CIDR
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNCIDR2backendgraphmodelCIDR(ctx context.Context, sel ast.SelectionSet, v model.CIDR) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNCIDR2backendgraphmodelCIDR(ctx context.Context, v interface{}) ([]model.CIDR, error) {
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]model.CIDR, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNCIDR2backendgraphmodelCIDR(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNCIDR2backendgraphmodelCIDR(ctx context.Context, sel ast.SelectionSet, v []model.CIDR) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNCIDR2backendgraphmodelCIDR(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNCPUMetrics2backendgraphmodelCPUMetrics(ctx context.Context, sel ast.SelectionSet, v *model.CPUMetrics) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._CPUMetrics(ctx, sel, v)
}

func (ec *executionContext) marshalNCancelChangeSetPayload2backendgraphmodelCancelChangeSetPayload(ctx context.Context, sel ast.SelectionSet, v model.CancelChangeSetPayload) graphql.Marshaler {
	return ec._CancelChangeSetPayload(ctx, sel, &v)
}

func (ec *executionContext) marshalNCancelChangeSetPayload2backendgraphmodelCancelChangeSetPayload(ctx context.Context, sel ast.SelectionSet, v *model.CancelChangeSetPayload) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._CancelChangeSetPayload(ctx, sel, v)
}

func (ec *executionContext) marshalNCancelScanPayload2backendgraphmodelCancelScanPayload(ctx context.Context, sel ast.SelectionSet, v model.CancelScanPayload) graphql.Marshaler {
	return ec._CancelScanPayload(ctx, sel, &v)
}

func (ec *executionContext) marshalNCancelScanPayload2backendgraphmodelCancelScanPayload(ctx context.Context, sel ast.SelectionSet, v *model.CancelScanPayload) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._CancelScanPayload(ctx, sel, v)
}

func (ec *executionContext) unmarshalNCapability2backendgraphmodelCapability(ctx context.Context, v interface{}) (model.Capability, error) {
	var res model.Capability
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNCapability2backendgraphmodelCapability(ctx context.Context, sel ast.SelectionSet, v model.Capability) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNCapabilityEntry2backendgraphmodelCapabilityEntry(ctx context.Context, sel ast.SelectionSet, v []*model.CapabilityEntry) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNCapabilityEntry2backendgraphmodelCapabilityEntry(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNCapabilityEntry2backendgraphmodelCapabilityEntry(ctx context.Context, sel ast.SelectionSet, v *model.CapabilityEntry) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._CapabilityEntry(ctx, sel, v)
}

func (ec *executionContext) unmarshalNCapabilityLevel2backendgraphmodelCapabilityLevel(ctx context.Context, v interface{}) (model.CapabilityLevel, error) {
	var res model.CapabilityLevel
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNCapabilityLevel2backendgraphmodelCapabilityLevel(ctx context.Context, sel ast.SelectionSet, v model.CapabilityLevel) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNChangeLogEntry2backendgraphmodelChangeLogEntry(ctx context.Context, sel ast.SelectionSet, v *model.ChangeLogEntry) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ChangeLogEntry(ctx, sel, v)
}

func (ec *executionContext) unmarshalNChangeOperation2backendgraphmodelChangeOperation(ctx context.Context, v interface{}) (model.ChangeOperation, error) {
	var res model.ChangeOperation
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNChangeOperation2backendgraphmodelChangeOperation(ctx context.Context, sel ast.SelectionSet, v model.ChangeOperation) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNChangeSetConflict2backendgraphmodelChangeSetConflict(ctx context.Context, sel ast.SelectionSet, v []*model.ChangeSetConflict) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNChangeSetConflict2backendgraphmodelChangeSetConflict(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNChangeSetConflict2backendgraphmodelChangeSetConflict(ctx context.Context, sel ast.SelectionSet, v *model.ChangeSetConflict) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ChangeSetConflict(ctx, sel, v)
}

func (ec *executionContext) marshalNChangeSetItem2backendgraphmodelChangeSetItem(ctx context.Context, sel ast.SelectionSet, v []*model.ChangeSetItem) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNChangeSetItem2backendgraphmodelChangeSetItem(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNChangeSetItem2backendgraphmodelChangeSetItem(ctx context.Context, sel ast.SelectionSet, v *model.ChangeSetItem) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ChangeSetItem(ctx, sel, v)
}

func (ec *executionContext) unmarshalNChangeSetItemInput2backendgraphmodelChangeSetItemInput(ctx context.Context, v interface{}) (model.ChangeSetItemInput, error) {
	res, err := ec.unmarshalInputChangeSetItemInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNChangeSetItemStatus2backendgraphmodelChangeSetItemStatus(ctx context.Context, v interface{}) (model.ChangeSetItemStatus, error) {
	var res model.ChangeSetItemStatus
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNChangeSetItemStatus2backendgraphmodelChangeSetItemStatus(ctx context.Context, sel ast.SelectionSet, v model.ChangeSetItemStatus) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNChangeSetProgressEvent2backendgraphmodelChangeSetProgressEvent(ctx context.Context, sel ast.SelectionSet, v model.ChangeSetProgressEvent) graphql.Marshaler {
	return ec._ChangeSetProgressEvent(ctx, sel, &v)
}

func (ec *executionContext) marshalNChangeSetProgressEvent2backendgraphmodelChangeSetProgressEvent(ctx context.Context, sel ast.SelectionSet, v *model.ChangeSetProgressEvent) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ChangeSetProgressEvent(ctx, sel, v)
}

func (ec *executionContext) unmarshalNChangeSetStatus2backendgraphmodelChangeSetStatus(ctx context.Context, v interface{}) (model.ChangeSetStatus, error) {
	var res model.ChangeSetStatus
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNChangeSetStatus2backendgraphmodelChangeSetStatus(ctx context.Context, sel ast.SelectionSet, v model.ChangeSetStatus) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNChangeSetStatusEvent2backendgraphmodelChangeSetStatusEvent(ctx context.Context, sel ast.SelectionSet, v model.ChangeSetStatusEvent) graphql.Marshaler {
	return ec._ChangeSetStatusEvent(ctx, sel, &v)
}

func (ec *executionContext) marshalNChangeSetStatusEvent2backendgraphmodelChangeSetStatusEvent(ctx context.Context, sel ast.SelectionSet, v *model.ChangeSetStatusEvent) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ChangeSetStatusEvent(ctx, sel, v)
}

func (ec *executionContext) marshalNChangeSetSummary2backendgraphmodelChangeSetSummary(ctx context.Context, sel ast.SelectionSet, v []*model.ChangeSetSummary) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNChangeSetSummary2backendgraphmodelChangeSetSummary(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNChangeSetSummary2backendgraphmodelChangeSetSummary(ctx context.Context, sel ast.SelectionSet, v *model.ChangeSetSummary) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ChangeSetSummary(ctx, sel, v)
}

func (ec *executionContext) marshalNChangeSetValidationError2backendgraphmodelChangeSetValidationError(ctx context.Context, sel ast.SelectionSet, v []*model.ChangeSetValidationError) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNChangeSetValidationError2backendgraphmodelChangeSetValidationError(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNChangeSetValidationError2backendgraphmodelChangeSetValidationError(ctx context.Context, sel ast.SelectionSet, v *model.ChangeSetValidationError) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ChangeSetValidationError(ctx, sel, v)
}

func (ec *executionContext) unmarshalNChangeType2backendgraphmodelChangeType(ctx context.Context, v interface{}) (model.ChangeType, error) {
	var res model.ChangeType
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNChangeType2backendgraphmodelChangeType(ctx context.Context, sel ast.SelectionSet, v model.ChangeType) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNCircuitBreakerEvent2backendgraphmodelCircuitBreakerEvent(ctx context.Context, sel ast.SelectionSet, v model.CircuitBreakerEvent) graphql.Marshaler {
	return ec._CircuitBreakerEvent(ctx, sel, &v)
}

func (ec *executionContext) marshalNCircuitBreakerEvent2backendgraphmodelCircuitBreakerEvent(ctx context.Context, sel ast.SelectionSet, v *model.CircuitBreakerEvent) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._CircuitBreakerEvent(ctx, sel, v)
}

func (ec *executionContext) unmarshalNCircuitBreakerState2backendgraphmodelCircuitBreakerState(ctx context.Context, v interface{}) (model.CircuitBreakerState, error) {
	var res model.CircuitBreakerState
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNCircuitBreakerState2backendgraphmodelCircuitBreakerState(ctx context.Context, sel ast.SelectionSet, v model.CircuitBreakerState) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNCircuitBreakerStatus2backendgraphmodelCircuitBreakerStatus(ctx context.Context, sel ast.SelectionSet, v model.CircuitBreakerStatus) graphql.Marshaler {
	return ec._CircuitBreakerStatus(ctx, sel, &v)
}

func (ec *executionContext) marshalNCircuitBreakerStatus2backendgraphmodelCircuitBreakerStatus(ctx context.Context, sel ast.SelectionSet, v *model.CircuitBreakerStatus) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._CircuitBreakerStatus(ctx, sel, v)
}

func (ec *executionContext) unmarshalNConditionOperator2backendgraphmodelConditionOperator(ctx context.Context, v interface{}) (model.ConditionOperator, error) {
	var res model.ConditionOperator
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNConditionOperator2backendgraphmodelConditionOperator(ctx context.Context, sel ast.SelectionSet, v model.ConditionOperator) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNConfigApplyStatus2backendgraphmodelConfigApplyStatus(ctx context.Context, v interface{}) (model.ConfigApplyStatus, error) {
	var res model.ConfigApplyStatus
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNConfigApplyStatus2backendgraphmodelConfigApplyStatus(ctx context.Context, sel ast.SelectionSet, v model.ConfigApplyStatus) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNConfigProgress2backendgraphmodelConfigProgress(ctx context.Context, sel ast.SelectionSet, v model.ConfigProgress) graphql.Marshaler {
	return ec._ConfigProgress(ctx, sel, &v)
}

func (ec *executionContext) marshalNConfigProgress2backendgraphmodelConfigProgress(ctx context.Context, sel ast.SelectionSet, v *model.ConfigProgress) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ConfigProgress(ctx, sel, v)
}

func (ec *executionContext) unmarshalNConfirmationSeverity2backendgraphmodelConfirmationSeverity(ctx context.Context, v interface{}) (model.ConfirmationSeverity, error) {
	var res model.ConfirmationSeverity
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNConfirmationSeverity2backendgraphmodelConfirmationSeverity(ctx context.Context, sel ast.SelectionSet, v model.ConfirmationSeverity) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNConflictType2backendgraphmodelConflictType(ctx context.Context, v interface{}) (model.ConflictType, error) {
	var res model.ConflictType
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNConflictType2backendgraphmodelConflictType(ctx context.Context, sel ast.SelectionSet, v model.ConflictType) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNConnectRouterPayload2backendgraphmodelConnectRouterPayload(ctx context.Context, sel ast.SelectionSet, v model.ConnectRouterPayload) graphql.Marshaler {
	return ec._ConnectRouterPayload(ctx, sel, &v)
}

func (ec *executionContext) marshalNConnectRouterPayload2backendgraphmodelConnectRouterPayload(ctx context.Context, sel ast.SelectionSet, v *model.ConnectRouterPayload) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ConnectRouterPayload(ctx, sel, v)
}

func (ec *executionContext) marshalNConnectionAttempt2backendgraphmodelConnectionAttempt(ctx context.Context, sel ast.SelectionSet, v []*model.ConnectionAttempt) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNConnectionAttempt2backendgraphmodelConnectionAttempt(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNConnectionAttempt2backendgraphmodelConnectionAttempt(ctx context.Context, sel ast.SelectionSet, v *model.ConnectionAttempt) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ConnectionAttempt(ctx, sel, v)
}

func (ec *executionContext) unmarshalNConnectionErrorCode2backendgraphmodelConnectionErrorCode(ctx context.Context, v interface{}) (model.ConnectionErrorCode, error) {
	var res model.ConnectionErrorCode
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNConnectionErrorCode2backendgraphmodelConnectionErrorCode(ctx context.Context, sel ast.SelectionSet, v model.ConnectionErrorCode) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNConnectionStats2backendgraphmodelConnectionStats(ctx context.Context, sel ast.SelectionSet, v model.ConnectionStats) graphql.Marshaler {
	return ec._ConnectionStats(ctx, sel, &v)
}

func (ec *executionContext) marshalNConnectionStats2backendgraphmodelConnectionStats(ctx context.Context, sel ast.SelectionSet, v *model.ConnectionStats) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ConnectionStats(ctx, sel, v)
}

func (ec *executionContext) unmarshalNConnectionStatus2backendgraphmodelConnectionStatus(ctx context.Context, v interface{}) (model.ConnectionStatus, error) {
	var res model.ConnectionStatus
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNConnectionStatus2backendgraphmodelConnectionStatus(ctx context.Context, sel ast.SelectionSet, v model.ConnectionStatus) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNConnectionTestResult2backendgraphmodelConnectionTestResult(ctx context.Context, sel ast.SelectionSet, v model.ConnectionTestResult) graphql.Marshaler {
	return ec._ConnectionTestResult(ctx, sel, &v)
}

func (ec *executionContext) marshalNConnectionTestResult2backendgraphmodelConnectionTestResult(ctx context.Context, sel ast.SelectionSet, v *model.ConnectionTestResult) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ConnectionTestResult(ctx, sel, v)
}

func (ec *executionContext) marshalNContainerInfo2backendgraphmodelContainerInfo(ctx context.Context, sel ast.SelectionSet, v *model.ContainerInfo) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ContainerInfo(ctx, sel, v)
}

func (ec *executionContext) unmarshalNCreateAlertRuleInput2backendgraphmodelCreateAlertRuleInput(ctx context.Context, v interface{}) (model.CreateAlertRuleInput, error) {
	res, err := ec.unmarshalInputCreateAlertRuleInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNCreateBridgeInput2backendgraphmodelCreateBridgeInput(ctx context.Context, v interface{}) (model.CreateBridgeInput, error) {
	res, err := ec.unmarshalInputCreateBridgeInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNCreateBridgeVlanInput2backendgraphmodelCreateBridgeVlanInput(ctx context.Context, v interface{}) (model.CreateBridgeVlanInput, error) {
	res, err := ec.unmarshalInputCreateBridgeVlanInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNCreateChangeSetInput2backendgraphmodelCreateChangeSetInput(ctx context.Context, v interface{}) (model.CreateChangeSetInput, error) {
	res, err := ec.unmarshalInputCreateChangeSetInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNCreateChangeSetPayload2backendgraphmodelCreateChangeSetPayload(ctx context.Context, sel ast.SelectionSet, v model.CreateChangeSetPayload) graphql.Marshaler {
	return ec._CreateChangeSetPayload(ctx, sel, &v)
}

func (ec *executionContext) marshalNCreateChangeSetPayload2backendgraphmodelCreateChangeSetPayload(ctx context.Context, sel ast.SelectionSet, v *model.CreateChangeSetPayload) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._CreateChangeSetPayload(ctx, sel, v)
}

func (ec *executionContext) unmarshalNCreateResourceInput2backendgraphmodelCreateResourceInput(ctx context.Context, v interface{}) (model.CreateResourceInput, error) {
	res, err := ec.unmarshalInputCreateResourceInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNCreateResourcePayload2backendgraphmodelCreateResourcePayload(ctx context.Context, sel ast.SelectionSet, v model.CreateResourcePayload) graphql.Marshaler {
	return ec._CreateResourcePayload(ctx, sel, &v)
}

func (ec *executionContext) marshalNCreateResourcePayload2backendgraphmodelCreateResourcePayload(ctx context.Context, sel ast.SelectionSet, v *model.CreateResourcePayload) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._CreateResourcePayload(ctx, sel, v)
}

func (ec *executionContext) unmarshalNCreateRouterInput2backendgraphmodelCreateRouterInput(ctx context.Context, v interface{}) (model.CreateRouterInput, error) {
	res, err := ec.unmarshalInputCreateRouterInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNCreateRouterPayload2backendgraphmodelCreateRouterPayload(ctx context.Context, sel ast.SelectionSet, v model.CreateRouterPayload) graphql.Marshaler {
	return ec._CreateRouterPayload(ctx, sel, &v)
}

func (ec *executionContext) marshalNCreateRouterPayload2backendgraphmodelCreateRouterPayload(ctx context.Context, sel ast.SelectionSet, v *model.CreateRouterPayload) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._CreateRouterPayload(ctx, sel, v)
}

func (ec *executionContext) marshalNCredentialTestResult2backendgraphmodelCredentialTestResult(ctx context.Context, sel ast.SelectionSet, v []*model.CredentialTestResult) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNCredentialTestResult2backendgraphmodelCredentialTestResult(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNCredentialTestResult2backendgraphmodelCredentialTestResult(ctx context.Context, sel ast.SelectionSet, v *model.CredentialTestResult) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._CredentialTestResult(ctx, sel, v)
}

func (ec *executionContext) unmarshalNCredentialTestStatus2backendgraphmodelCredentialTestStatus(ctx context.Context, v interface{}) (model.CredentialTestStatus, error) {
	var res model.CredentialTestStatus
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNCredentialTestStatus2backendgraphmodelCredentialTestStatus(ctx context.Context, sel ast.SelectionSet, v model.CredentialTestStatus) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNCredentialUpdatePayload2backendgraphmodelCredentialUpdatePayload(ctx context.Context, sel ast.SelectionSet, v model.CredentialUpdatePayload) graphql.Marshaler {
	return ec._CredentialUpdatePayload(ctx, sel, &v)
}

func (ec *executionContext) marshalNCredentialUpdatePayload2backendgraphmodelCredentialUpdatePayload(ctx context.Context, sel ast.SelectionSet, v *model.CredentialUpdatePayload) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._CredentialUpdatePayload(ctx, sel, v)
}

func (ec *executionContext) unmarshalNCredentialsInput2backendgraphmodelCredentialsInput(ctx context.Context, v interface{}) (model.CredentialsInput, error) {
	res, err := ec.unmarshalInputCredentialsInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNDailyStats2backendgraphmodelDailyStats(ctx context.Context, sel ast.SelectionSet, v *model.DailyStats) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._DailyStats(ctx, sel, v)
}

func (ec *executionContext) unmarshalNDateTime2timeTime(ctx context.Context, v interface{}) (time.Time, error) {
	res, err := graphql.UnmarshalTime(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNDateTime2timeTime(ctx context.Context, sel ast.SelectionSet, v time.Time) graphql.Marshaler {
	res := graphql.MarshalTime(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNDeleteChangeSetPayload2backendgraphmodelDeleteChangeSetPayload(ctx context.Context, sel ast.SelectionSet, v model.DeleteChangeSetPayload) graphql.Marshaler {
	return ec._DeleteChangeSetPayload(ctx, sel, &v)
}

func (ec *executionContext) marshalNDeleteChangeSetPayload2backendgraphmodelDeleteChangeSetPayload(ctx context.Context, sel ast.SelectionSet, v *model.DeleteChangeSetPayload) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._DeleteChangeSetPayload(ctx, sel, v)
}

func (ec *executionContext) marshalNDeletePayload2backendgraphmodelDeletePayload(ctx context.Context, sel ast.SelectionSet, v model.DeletePayload) graphql.Marshaler {
	return ec._DeletePayload(ctx, sel, &v)
}

func (ec *executionContext) marshalNDeletePayload2backendgraphmodelDeletePayload(ctx context.Context, sel ast.SelectionSet, v *model.DeletePayload) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._DeletePayload(ctx, sel, v)
}

func (ec *executionContext) marshalNDeleteResourcePayload2backendgraphmodelDeleteResourcePayload(ctx context.Context, sel ast.SelectionSet, v model.DeleteResourcePayload) graphql.Marshaler {
	return ec._DeleteResourcePayload(ctx, sel, &v)
}

func (ec *executionContext) marshalNDeleteResourcePayload2backendgraphmodelDeleteResourcePayload(ctx context.Context, sel ast.SelectionSet, v *model.DeleteResourcePayload) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._DeleteResourcePayload(ctx, sel, v)
}

func (ec *executionContext) marshalNDeleteResult2backendgraphmodelDeleteResult(ctx context.Context, sel ast.SelectionSet, v model.DeleteResult) graphql.Marshaler {
	return ec._DeleteResult(ctx, sel, &v)
}

func (ec *executionContext) marshalNDeleteResult2backendgraphmodelDeleteResult(ctx context.Context, sel ast.SelectionSet, v *model.DeleteResult) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._DeleteResult(ctx, sel, v)
}

func (ec *executionContext) marshalNDeleteRouterPayload2backendgraphmodelDeleteRouterPayload(ctx context.Context, sel ast.SelectionSet, v model.DeleteRouterPayload) graphql.Marshaler {
	return ec._DeleteRouterPayload(ctx, sel, &v)
}

func (ec *executionContext) marshalNDeleteRouterPayload2backendgraphmodelDeleteRouterPayload(ctx context.Context, sel ast.SelectionSet, v *model.DeleteRouterPayload) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._DeleteRouterPayload(ctx, sel, v)
}

func (ec *executionContext) marshalNDependencyStatus2backendgraphmodelDependencyStatus(ctx context.Context, sel ast.SelectionSet, v []*model.DependencyStatus) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNDependencyStatus2backendgraphmodelDependencyStatus(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNDependencyStatus2backendgraphmodelDependencyStatus(ctx context.Context, sel ast.SelectionSet, v *model.DependencyStatus) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._DependencyStatus(ctx, sel, v)
}

func (ec *executionContext) marshalNDeprecateResourcePayload2backendgraphmodelDeprecateResourcePayload(ctx context.Context, sel ast.SelectionSet, v model.DeprecateResourcePayload) graphql.Marshaler {
	return ec._DeprecateResourcePayload(ctx, sel, &v)
}

func (ec *executionContext) marshalNDeprecateResourcePayload2backendgraphmodelDeprecateResourcePayload(ctx context.Context, sel ast.SelectionSet, v *model.DeprecateResourcePayload) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._DeprecateResourcePayload(ctx, sel, v)
}

func (ec *executionContext) unmarshalNDhcpClientInput2backendgraphmodelDhcpClientInput(ctx context.Context, v interface{}) (model.DhcpClientInput, error) {
	res, err := ec.unmarshalInputDhcpClientInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNDhcpServer2backendgraphmodelDhcpServer(ctx context.Context, sel ast.SelectionSet, v []*model.DhcpServer) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNDhcpServer2backendgraphmodelDhcpServer(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNDhcpServer2backendgraphmodelDhcpServer(ctx context.Context, sel ast.SelectionSet, v *model.DhcpServer) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._DhcpServer(ctx, sel, v)
}

func (ec *executionContext) marshalNDiagnosticReport2backendgraphmodelDiagnosticReport(ctx context.Context, sel ast.SelectionSet, v model.DiagnosticReport) graphql.Marshaler {
	return ec._DiagnosticReport(ctx, sel, &v)
}

func (ec *executionContext) marshalNDiagnosticReport2backendgraphmodelDiagnosticReport(ctx context.Context, sel ast.SelectionSet, v *model.DiagnosticReport) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._DiagnosticReport(ctx, sel, v)
}

func (ec *executionContext) marshalNDiagnosticSuggestion2backendgraphmodelDiagnosticSuggestion(ctx context.Context, sel ast.SelectionSet, v []*model.DiagnosticSuggestion) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNDiagnosticSuggestion2backendgraphmodelDiagnosticSuggestion(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNDiagnosticSuggestion2backendgraphmodelDiagnosticSuggestion(ctx context.Context, sel ast.SelectionSet, v *model.DiagnosticSuggestion) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._DiagnosticSuggestion(ctx, sel, v)
}

func (ec *executionContext) marshalNDisconnectRouterPayload2backendgraphmodelDisconnectRouterPayload(ctx context.Context, sel ast.SelectionSet, v model.DisconnectRouterPayload) graphql.Marshaler {
	return ec._DisconnectRouterPayload(ctx, sel, &v)
}

func (ec *executionContext) marshalNDisconnectRouterPayload2backendgraphmodelDisconnectRouterPayload(ctx context.Context, sel ast.SelectionSet, v *model.DisconnectRouterPayload) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._DisconnectRouterPayload(ctx, sel, v)
}

func (ec *executionContext) marshalNDiscoveredDevice2backendgraphmodelDiscoveredDevice(ctx context.Context, sel ast.SelectionSet, v []*model.DiscoveredDevice) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNDiscoveredDevice2backendgraphmodelDiscoveredDevice(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNDiscoveredDevice2backendgraphmodelDiscoveredDevice(ctx context.Context, sel ast.SelectionSet, v *model.DiscoveredDevice) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._DiscoveredDevice(ctx, sel, v)
}

func (ec *executionContext) unmarshalNDnsLookupInput2backendgraphmodelDNSLookupInput(ctx context.Context, v interface{}) (model.DNSLookupInput, error) {
	res, err := ec.unmarshalInputDnsLookupInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNDnsLookupResult2backendgraphmodelDNSLookupResult(ctx context.Context, sel ast.SelectionSet, v model.DNSLookupResult) graphql.Marshaler {
	return ec._DnsLookupResult(ctx, sel, &v)
}

func (ec *executionContext) marshalNDnsLookupResult2backendgraphmodelDNSLookupResult(ctx context.Context, sel ast.SelectionSet, v *model.DNSLookupResult) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._DnsLookupResult(ctx, sel, v)
}

func (ec *executionContext) unmarshalNDnsLookupStatus2backendgraphmodelDNSLookupStatus(ctx context.Context, v interface{}) (model.DNSLookupStatus, error) {
	var res model.DNSLookupStatus
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNDnsLookupStatus2backendgraphmodelDNSLookupStatus(ctx context.Context, sel ast.SelectionSet, v model.DNSLookupStatus) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNDnsRecord2backendgraphmodelDNSRecord(ctx context.Context, sel ast.SelectionSet, v []*model.DNSRecord) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNDnsRecord2backendgraphmodelDNSRecord(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNDnsRecord2backendgraphmodelDNSRecord(ctx context.Context, sel ast.SelectionSet, v *model.DNSRecord) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._DnsRecord(ctx, sel, v)
}

func (ec *executionContext) unmarshalNDnsRecordType2backendgraphmodelDNSRecordType(ctx context.Context, v interface{}) (model.DNSRecordType, error) {
	var res model.DNSRecordType
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNDnsRecordType2backendgraphmodelDNSRecordType(ctx context.Context, sel ast.SelectionSet, v model.DNSRecordType) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNDnsServer2backendgraphmodelDNSServer(ctx context.Context, sel ast.SelectionSet, v []*model.DNSServer) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNDnsServer2backendgraphmodelDNSServer(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNDnsServer2backendgraphmodelDNSServer(ctx context.Context, sel ast.SelectionSet, v *model.DNSServer) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._DnsServer(ctx, sel, v)
}

func (ec *executionContext) marshalNDnsServers2backendgraphmodelDNSServers(ctx context.Context, sel ast.SelectionSet, v model.DNSServers) graphql.Marshaler {
	return ec._DnsServers(ctx, sel, &v)
}

func (ec *executionContext) marshalNDnsServers2backendgraphmodelDNSServers(ctx context.Context, sel ast.SelectionSet, v *model.DNSServers) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._DnsServers(ctx, sel, v)
}

func (ec *executionContext) unmarshalNDriftAction2backendgraphmodelDriftAction(ctx context.Context, v interface{}) (model.DriftAction, error) {
	var res model.DriftAction
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNDriftAction2backendgraphmodelDriftAction(ctx context.Context, sel ast.SelectionSet, v model.DriftAction) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNDriftField2backendgraphmodelDriftField(ctx context.Context, sel ast.SelectionSet, v []*model.DriftField) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNDriftField2backendgraphmodelDriftField(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNDriftField2backendgraphmodelDriftField(ctx context.Context, sel ast.SelectionSet, v *model.DriftField) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._DriftField(ctx, sel, v)
}

func (ec *executionContext) unmarshalNDuration2backendgraphmodelDuration(ctx context.Context, v interface{}) (model.Duration, error) {
	var res model.Duration
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNDuration2backendgraphmodelDuration(ctx context.Context, sel ast.SelectionSet, v model.Duration) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNExportConfigInput2backendgraphmodelExportConfigInput(ctx context.Context, v interface{}) (model.ExportConfigInput, error) {
	res, err := ec.unmarshalInputExportConfigInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNExportConfigPayload2backendgraphmodelExportConfigPayload(ctx context.Context, sel ast.SelectionSet, v model.ExportConfigPayload) graphql.Marshaler {
	return ec._ExportConfigPayload(ctx, sel, &v)
}

func (ec *executionContext) marshalNExportConfigPayload2backendgraphmodelExportConfigPayload(ctx context.Context, sel ast.SelectionSet, v *model.ExportConfigPayload) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ExportConfigPayload(ctx, sel, v)
}

func (ec *executionContext) marshalNFeatureCompatibilityInfo2backendgraphmodelFeatureCompatibilityInfo(ctx context.Context, sel ast.SelectionSet, v []*model.FeatureCompatibilityInfo) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNFeatureCompatibilityInfo2backendgraphmodelFeatureCompatibilityInfo(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNFeatureCompatibilityInfo2backendgraphmodelFeatureCompatibilityInfo(ctx context.Context, sel ast.SelectionSet, v *model.FeatureCompatibilityInfo) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._FeatureCompatibilityInfo(ctx, sel, v)
}

func (ec *executionContext) marshalNFeatureSupport2backendgraphmodelFeatureSupport(ctx context.Context, sel ast.SelectionSet, v model.FeatureSupport) graphql.Marshaler {
	return ec._FeatureSupport(ctx, sel, &v)
}

func (ec *executionContext) marshalNFeatureSupport2backendgraphmodelFeatureSupport(ctx context.Context, sel ast.SelectionSet, v []*model.FeatureSupport) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNFeatureSupport2backendgraphmodelFeatureSupport(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNFeatureSupport2backendgraphmodelFeatureSupport(ctx context.Context, sel ast.SelectionSet, v *model.FeatureSupport) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._FeatureSupport(ctx, sel, v)
}

func (ec *executionContext) marshalNFirewallRule2backendgraphmodelFirewallRule(ctx context.Context, sel ast.SelectionSet, v []*model.FirewallRule) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNFirewallRule2backendgraphmodelFirewallRule(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNFirewallRule2backendgraphmodelFirewallRule(ctx context.Context, sel ast.SelectionSet, v *model.FirewallRule) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._FirewallRule(ctx, sel, v)
}

func (ec *executionContext) marshalNFirewallRuleResource2backendgraphmodelFirewallRuleResource(ctx context.Context, sel ast.SelectionSet, v []*model.FirewallRuleResource) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNFirewallRuleResource2backendgraphmodelFirewallRuleResource(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNFirewallRuleResource2backendgraphmodelFirewallRuleResource(ctx context.Context, sel ast.SelectionSet, v *model.FirewallRuleResource) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._FirewallRuleResource(ctx, sel, v)
}

func (ec *executionContext) unmarshalNFixApplicationStatus2backendgraphmodelFixApplicationStatus(ctx context.Context, v interface{}) (model.FixApplicationStatus, error) {
	var res model.FixApplicationStatus
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNFixApplicationStatus2backendgraphmodelFixApplicationStatus(ctx context.Context, sel ast.SelectionSet, v model.FixApplicationStatus) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNFixConfidence2backendgraphmodelFixConfidence(ctx context.Context, v interface{}) (model.FixConfidence, error) {
	var res model.FixConfidence
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNFixConfidence2backendgraphmodelFixConfidence(ctx context.Context, sel ast.SelectionSet, v model.FixConfidence) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNFloat2float64(ctx context.Context, v interface{}) (float64, error) {
	res, err := graphql.UnmarshalFloatContext(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNFloat2float64(ctx context.Context, sel ast.SelectionSet, v float64) graphql.Marshaler {
	res := graphql.MarshalFloatContext(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return graphql.WrapContextMarshaler(ctx, res)
}

func (ec *executionContext) unmarshalNFloat2float64(ctx context.Context, v interface{}) ([]float64, error) {
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]float64, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNFloat2float64(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNFloat2float64(ctx context.Context, sel ast.SelectionSet, v []float64) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNFloat2float64(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNFrameTypes2backendgraphmodelFrameTypes(ctx context.Context, v interface{}) (model.FrameTypes, error) {
	var res model.FrameTypes
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNFrameTypes2backendgraphmodelFrameTypes(ctx context.Context, sel ast.SelectionSet, v model.FrameTypes) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNGatewayReachabilityResult2backendgraphmodelGatewayReachabilityResult(ctx context.Context, sel ast.SelectionSet, v model.GatewayReachabilityResult) graphql.Marshaler {
	return ec._GatewayReachabilityResult(ctx, sel, &v)
}

func (ec *executionContext) marshalNGatewayReachabilityResult2backendgraphmodelGatewayReachabilityResult(ctx context.Context, sel ast.SelectionSet, v *model.GatewayReachabilityResult) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._GatewayReachabilityResult(ctx, sel, v)
}

func (ec *executionContext) marshalNHardwareInfo2backendgraphmodelHardwareInfo(ctx context.Context, sel ast.SelectionSet, v *model.HardwareInfo) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._HardwareInfo(ctx, sel, v)
}

func (ec *executionContext) marshalNHealthCheckResult2backendgraphmodelHealthCheckResult(ctx context.Context, sel ast.SelectionSet, v model.HealthCheckResult) graphql.Marshaler {
	return ec._HealthCheckResult(ctx, sel, &v)
}

func (ec *executionContext) marshalNHealthCheckResult2backendgraphmodelHealthCheckResult(ctx context.Context, sel ast.SelectionSet, v *model.HealthCheckResult) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._HealthCheckResult(ctx, sel, v)
}

func (ec *executionContext) unmarshalNHealthCheckStatus2backendgraphmodelHealthCheckStatus(ctx context.Context, v interface{}) (model.HealthCheckStatus, error) {
	var res model.HealthCheckStatus
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNHealthCheckStatus2backendgraphmodelHealthCheckStatus(ctx context.Context, sel ast.SelectionSet, v model.HealthCheckStatus) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNHealthStatus2backendgraphmodelHealthStatus(ctx context.Context, sel ast.SelectionSet, v model.HealthStatus) graphql.Marshaler {
	return ec._HealthStatus(ctx, sel, &v)
}

func (ec *executionContext) marshalNHealthStatus2backendgraphmodelHealthStatus(ctx context.Context, sel ast.SelectionSet, v *model.HealthStatus) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._HealthStatus(ctx, sel, v)
}

func (ec *executionContext) marshalNHopProbe2backendgraphmodelHopProbe(ctx context.Context, sel ast.SelectionSet, v []*model.HopProbe) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNHopProbe2backendgraphmodelHopProbe(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNHopProbe2backendgraphmodelHopProbe(ctx context.Context, sel ast.SelectionSet, v *model.HopProbe) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._HopProbe(ctx, sel, v)
}

func (ec *executionContext) unmarshalNHopStatus2backendgraphmodelHopStatus(ctx context.Context, v interface{}) (model.HopStatus, error) {
	var res model.HopStatus
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNHopStatus2backendgraphmodelHopStatus(ctx context.Context, sel ast.SelectionSet, v model.HopStatus) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNHourlyStats2backendgraphmodelHourlyStats(ctx context.Context, sel ast.SelectionSet, v *model.HourlyStats) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._HourlyStats(ctx, sel, v)
}

func (ec *executionContext) unmarshalNID2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalID(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNID2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalID(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNID2string(ctx context.Context, v interface{}) ([]string, error) {
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNID2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNID2string(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNID2string(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNIPv42backendgraphmodelIPv4(ctx context.Context, v interface{}) (model.IPv4, error) {
	var res model.IPv4
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNIPv42backendgraphmodelIPv4(ctx context.Context, sel ast.SelectionSet, v model.IPv4) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNInt2int(ctx context.Context, v interface{}) (int, error) {
	res, err := graphql.UnmarshalInt(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNInt2int(ctx context.Context, sel ast.SelectionSet, v int) graphql.Marshaler {
	res := graphql.MarshalInt(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNInt2int(ctx context.Context, v interface{}) ([]int, error) {
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]int, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNInt2int(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNInt2int(ctx context.Context, sel ast.SelectionSet, v []int) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNInt2int(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNInterface2backendgraphmodelInterface(ctx context.Context, sel ast.SelectionSet, v []*model.Interface) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNInterface2backendgraphmodelInterface(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNInterface2backendgraphmodelInterface(ctx context.Context, sel ast.SelectionSet, v *model.Interface) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Interface(ctx, sel, v)
}

func (ec *executionContext) marshalNInterfaceConnection2backendgraphmodelInterfaceConnection(ctx context.Context, sel ast.SelectionSet, v model.InterfaceConnection) graphql.Marshaler {
	return ec._InterfaceConnection(ctx, sel, &v)
}

func (ec *executionContext) marshalNInterfaceConnection2backendgraphmodelInterfaceConnection(ctx context.Context, sel ast.SelectionSet, v *model.InterfaceConnection) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._InterfaceConnection(ctx, sel, v)
}

func (ec *executionContext) marshalNInterfaceEdge2backendgraphmodelInterfaceEdge(ctx context.Context, sel ast.SelectionSet, v []*model.InterfaceEdge) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNInterfaceEdge2backendgraphmodelInterfaceEdge(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNInterfaceEdge2backendgraphmodelInterfaceEdge(ctx context.Context, sel ast.SelectionSet, v *model.InterfaceEdge) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._InterfaceEdge(ctx, sel, v)
}

func (ec *executionContext) marshalNInterfaceOperationError2backendgraphmodelInterfaceOperationError(ctx context.Context, sel ast.SelectionSet, v []*model.InterfaceOperationError) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNInterfaceOperationError2backendgraphmodelInterfaceOperationError(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNInterfaceOperationError2backendgraphmodelInterfaceOperationError(ctx context.Context, sel ast.SelectionSet, v *model.InterfaceOperationError) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._InterfaceOperationError(ctx, sel, v)
}

func (ec *executionContext) marshalNInterfaceStats2backendgraphmodelInterfaceStats(ctx context.Context, sel ast.SelectionSet, v model.InterfaceStats) graphql.Marshaler {
	return ec._InterfaceStats(ctx, sel, &v)
}

func (ec *executionContext) marshalNInterfaceStats2backendgraphmodelInterfaceStats(ctx context.Context, sel ast.SelectionSet, v *model.InterfaceStats) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._InterfaceStats(ctx, sel, v)
}

func (ec *executionContext) marshalNInterfaceStatsHistory2backendgraphmodelInterfaceStatsHistory(ctx context.Context, sel ast.SelectionSet, v model.InterfaceStatsHistory) graphql.Marshaler {
	return ec._InterfaceStatsHistory(ctx, sel, &v)
}

func (ec *executionContext) marshalNInterfaceStatsHistory2backendgraphmodelInterfaceStatsHistory(ctx context.Context, sel ast.SelectionSet, v *model.InterfaceStatsHistory) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._InterfaceStatsHistory(ctx, sel, v)
}

func (ec *executionContext) unmarshalNInterfaceStatus2backendgraphmodelInterfaceStatus(ctx context.Context, v interface{}) (model.InterfaceStatus, error) {
	var res model.InterfaceStatus
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNInterfaceStatus2backendgraphmodelInterfaceStatus(ctx context.Context, sel ast.SelectionSet, v model.InterfaceStatus) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNInterfaceStatusEvent2backendgraphmodelInterfaceStatusEvent(ctx context.Context, sel ast.SelectionSet, v model.InterfaceStatusEvent) graphql.Marshaler {
	return ec._InterfaceStatusEvent(ctx, sel, &v)
}

func (ec *executionContext) marshalNInterfaceStatusEvent2backendgraphmodelInterfaceStatusEvent(ctx context.Context, sel ast.SelectionSet, v *model.InterfaceStatusEvent) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._InterfaceStatusEvent(ctx, sel, v)
}

func (ec *executionContext) marshalNInterfaceTrafficEvent2backendgraphmodelInterfaceTrafficEvent(ctx context.Context, sel ast.SelectionSet, v model.InterfaceTrafficEvent) graphql.Marshaler {
	return ec._InterfaceTrafficEvent(ctx, sel, &v)
}

func (ec *executionContext) marshalNInterfaceTrafficEvent2backendgraphmodelInterfaceTrafficEvent(ctx context.Context, sel ast.SelectionSet, v *model.InterfaceTrafficEvent) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._InterfaceTrafficEvent(ctx, sel, v)
}

func (ec *executionContext) unmarshalNInterfaceType2backendgraphmodelInterfaceType(ctx context.Context, v interface{}) (model.InterfaceType, error) {
	var res model.InterfaceType
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNInterfaceType2backendgraphmodelInterfaceType(ctx context.Context, sel ast.SelectionSet, v model.InterfaceType) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNIpAddress2backendgraphmodelIPAddress(ctx context.Context, sel ast.SelectionSet, v []*model.IPAddress) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNIpAddress2backendgraphmodelIPAddress(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNIpAddress2backendgraphmodelIPAddress(ctx context.Context, sel ast.SelectionSet, v *model.IPAddress) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._IpAddress(ctx, sel, v)
}

func (ec *executionContext) marshalNIpAddressChangeEvent2backendgraphmodelIPAddressChangeEvent(ctx context.Context, sel ast.SelectionSet, v model.IPAddressChangeEvent) graphql.Marshaler {
	return ec._IpAddressChangeEvent(ctx, sel, &v)
}

func (ec *executionContext) marshalNIpAddressChangeEvent2backendgraphmodelIPAddressChangeEvent(ctx context.Context, sel ast.SelectionSet, v *model.IPAddressChangeEvent) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._IpAddressChangeEvent(ctx, sel, v)
}

func (ec *executionContext) marshalNIpAddressDeleteResult2backendgraphmodelIPAddressDeleteResult(ctx context.Context, sel ast.SelectionSet, v model.IPAddressDeleteResult) graphql.Marshaler {
	return ec._IpAddressDeleteResult(ctx, sel, &v)
}

func (ec *executionContext) marshalNIpAddressDeleteResult2backendgraphmodelIPAddressDeleteResult(ctx context.Context, sel ast.SelectionSet, v *model.IPAddressDeleteResult) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._IpAddressDeleteResult(ctx, sel, v)
}

func (ec *executionContext) marshalNIpAddressDependencies2backendgraphmodelIPAddressDependencies(ctx context.Context, sel ast.SelectionSet, v model.IPAddressDependencies) graphql.Marshaler {
	return ec._IpAddressDependencies(ctx, sel, &v)
}

func (ec *executionContext) marshalNIpAddressDependencies2backendgraphmodelIPAddressDependencies(ctx context.Context, sel ast.SelectionSet, v *model.IPAddressDependencies) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._IpAddressDependencies(ctx, sel, v)
}

func (ec *executionContext) unmarshalNIpAddressInput2backendgraphmodelIPAddressInput(ctx context.Context, v interface{}) (model.IPAddressInput, error) {
	res, err := ec.unmarshalInputIpAddressInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNIpAddressMutationResult2backendgraphmodelIPAddressMutationResult(ctx context.Context, sel ast.SelectionSet, v model.IPAddressMutationResult) graphql.Marshaler {
	return ec._IpAddressMutationResult(ctx, sel, &v)
}

func (ec *executionContext) marshalNIpAddressMutationResult2backendgraphmodelIPAddressMutationResult(ctx context.Context, sel ast.SelectionSet, v *model.IPAddressMutationResult) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._IpAddressMutationResult(ctx, sel, v)
}

func (ec *executionContext) marshalNIpConflict2backendgraphmodelIPConflict(ctx context.Context, sel ast.SelectionSet, v []*model.IPConflict) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNIpConflict2backendgraphmodelIPConflict(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNIpConflict2backendgraphmodelIPConflict(ctx context.Context, sel ast.SelectionSet, v *model.IPConflict) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._IpConflict(ctx, sel, v)
}

func (ec *executionContext) marshalNIpConflictResult2backendgraphmodelIPConflictResult(ctx context.Context, sel ast.SelectionSet, v model.IPConflictResult) graphql.Marshaler {
	return ec._IpConflictResult(ctx, sel, &v)
}

func (ec *executionContext) marshalNIpConflictResult2backendgraphmodelIPConflictResult(ctx context.Context, sel ast.SelectionSet, v *model.IPConflictResult) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._IpConflictResult(ctx, sel, v)
}

func (ec *executionContext) unmarshalNIpConflictType2backendgraphmodelIPConflictType(ctx context.Context, v interface{}) (model.IPConflictType, error) {
	var res model.IPConflictType
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNIpConflictType2backendgraphmodelIPConflictType(ctx context.Context, sel ast.SelectionSet, v model.IPConflictType) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNJSON2map(ctx context.Context, v interface{}) (map[string]interface{}, error) {
	res, err := graphql.UnmarshalMap(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNJSON2map(ctx context.Context, sel ast.SelectionSet, v map[string]interface{}) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	res := graphql.MarshalMap(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNJobStatus2backendgraphmodelJobStatus(ctx context.Context, v interface{}) (model.JobStatus, error) {
	var res model.JobStatus
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNJobStatus2backendgraphmodelJobStatus(ctx context.Context, sel ast.SelectionSet, v model.JobStatus) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNLANNetworkConfig2backendgraphmodelLANNetworkConfig(ctx context.Context, sel ast.SelectionSet, v *model.LANNetworkConfig) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._LANNetworkConfig(ctx, sel, v)
}

func (ec *executionContext) unmarshalNLteModemInput2backendgraphmodelLteModemInput(ctx context.Context, v interface{}) (model.LteModemInput, error) {
	res, err := ec.unmarshalInputLteModemInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNMemoryMetrics2backendgraphmodelMemoryMetrics(ctx context.Context, sel ast.SelectionSet, v *model.MemoryMetrics) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._MemoryMetrics(ctx, sel, v)
}

func (ec *executionContext) marshalNMissingDependency2backendgraphmodelMissingDependency(ctx context.Context, sel ast.SelectionSet, v []*model.MissingDependency) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNMissingDependency2backendgraphmodelMissingDependency(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNMissingDependency2backendgraphmodelMissingDependency(ctx context.Context, sel ast.SelectionSet, v *model.MissingDependency) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._MissingDependency(ctx, sel, v)
}

func (ec *executionContext) marshalNMutationError2backendgraphmodelMutationError(ctx context.Context, sel ast.SelectionSet, v *model.MutationError) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._MutationError(ctx, sel, v)
}

func (ec *executionContext) marshalNNatRule2backendgraphmodelNatRule(ctx context.Context, sel ast.SelectionSet, v []*model.NatRule) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNNatRule2backendgraphmodelNatRule(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNNatRule2backendgraphmodelNatRule(ctx context.Context, sel ast.SelectionSet, v *model.NatRule) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._NatRule(ctx, sel, v)
}

func (ec *executionContext) marshalNOperationCounts2backendgraphmodelOperationCounts(ctx context.Context, sel ast.SelectionSet, v *model.OperationCounts) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._OperationCounts(ctx, sel, v)
}

func (ec *executionContext) marshalNPageInfo2backendgraphmodelPageInfo(ctx context.Context, sel ast.SelectionSet, v *model.PageInfo) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._PageInfo(ctx, sel, v)
}

func (ec *executionContext) marshalNPlatformCapabilities2backendgraphmodelPlatformCapabilities(ctx context.Context, sel ast.SelectionSet, v *model.PlatformCapabilities) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._PlatformCapabilities(ctx, sel, v)
}

func (ec *executionContext) marshalNPlatformFeature2backendgraphmodelPlatformFeature(ctx context.Context, sel ast.SelectionSet, v *model.PlatformFeature) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._PlatformFeature(ctx, sel, v)
}

func (ec *executionContext) marshalNPlatformLimitation2backendgraphmodelPlatformLimitation(ctx context.Context, sel ast.SelectionSet, v *model.PlatformLimitation) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._PlatformLimitation(ctx, sel, v)
}

func (ec *executionContext) unmarshalNPort2backendgraphmodelPort(ctx context.Context, v interface{}) (model.Port, error) {
	var res model.Port
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNPort2backendgraphmodelPort(ctx context.Context, sel ast.SelectionSet, v model.Port) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNPortMode2backendgraphmodelPortMode(ctx context.Context, v interface{}) (model.PortMode, error) {
	var res model.PortMode
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNPortMode2backendgraphmodelPortMode(ctx context.Context, sel ast.SelectionSet, v model.PortMode) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNPortStatus2backendgraphmodelPortStatus(ctx context.Context, sel ast.SelectionSet, v []*model.PortStatus) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNPortStatus2backendgraphmodelPortStatus(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNPortStatus2backendgraphmodelPortStatus(ctx context.Context, sel ast.SelectionSet, v *model.PortStatus) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._PortStatus(ctx, sel, v)
}

func (ec *executionContext) unmarshalNPppoeClientInput2backendgraphmodelPppoeClientInput(ctx context.Context, v interface{}) (model.PppoeClientInput, error) {
	res, err := ec.unmarshalInputPppoeClientInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNProtocol2backendgraphmodelProtocol(ctx context.Context, v interface{}) (model.Protocol, error) {
	var res model.Protocol
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNProtocol2backendgraphmodelProtocol(ctx context.Context, sel ast.SelectionSet, v model.Protocol) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNProtocol2backendgraphmodelProtocol(ctx context.Context, v interface{}) ([]model.Protocol, error) {
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]model.Protocol, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNProtocol2backendgraphmodelProtocol(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNProtocol2backendgraphmodelProtocol(ctx context.Context, sel ast.SelectionSet, v []model.Protocol) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNProtocol2backendgraphmodelProtocol(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNReconnectRouterPayload2backendgraphmodelReconnectRouterPayload(ctx context.Context, sel ast.SelectionSet, v model.ReconnectRouterPayload) graphql.Marshaler {
	return ec._ReconnectRouterPayload(ctx, sel, &v)
}

func (ec *executionContext) marshalNReconnectRouterPayload2backendgraphmodelReconnectRouterPayload(ctx context.Context, sel ast.SelectionSet, v *model.ReconnectRouterPayload) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ReconnectRouterPayload(ctx, sel, v)
}

func (ec *executionContext) marshalNRefreshCapabilitiesPayload2backendgraphmodelRefreshCapabilitiesPayload(ctx context.Context, sel ast.SelectionSet, v model.RefreshCapabilitiesPayload) graphql.Marshaler {
	return ec._RefreshCapabilitiesPayload(ctx, sel, &v)
}

func (ec *executionContext) marshalNRefreshCapabilitiesPayload2backendgraphmodelRefreshCapabilitiesPayload(ctx context.Context, sel ast.SelectionSet, v *model.RefreshCapabilitiesPayload) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._RefreshCapabilitiesPayload(ctx, sel, v)
}

func (ec *executionContext) marshalNRemoveChangeSetItemPayload2backendgraphmodelRemoveChangeSetItemPayload(ctx context.Context, sel ast.SelectionSet, v model.RemoveChangeSetItemPayload) graphql.Marshaler {
	return ec._RemoveChangeSetItemPayload(ctx, sel, &v)
}

func (ec *executionContext) marshalNRemoveChangeSetItemPayload2backendgraphmodelRemoveChangeSetItemPayload(ctx context.Context, sel ast.SelectionSet, v *model.RemoveChangeSetItemPayload) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._RemoveChangeSetItemPayload(ctx, sel, v)
}

func (ec *executionContext) marshalNResource2backendgraphmodelResource(ctx context.Context, sel ast.SelectionSet, v model.Resource) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Resource(ctx, sel, v)
}

func (ec *executionContext) marshalNResource2backendgraphmodelResource(ctx context.Context, sel ast.SelectionSet, v []model.Resource) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNResource2backendgraphmodelResource(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNResourceCategory2backendgraphmodelResourceCategory(ctx context.Context, v interface{}) (model.ResourceCategory, error) {
	var res model.ResourceCategory
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNResourceCategory2backendgraphmodelResourceCategory(ctx context.Context, sel ast.SelectionSet, v model.ResourceCategory) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNResourceConflict2backendgraphmodelResourceConflict(ctx context.Context, sel ast.SelectionSet, v []*model.ResourceConflict) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNResourceConflict2backendgraphmodelResourceConflict(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNResourceConflict2backendgraphmodelResourceConflict(ctx context.Context, sel ast.SelectionSet, v *model.ResourceConflict) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ResourceConflict(ctx, sel, v)
}

func (ec *executionContext) marshalNResourceConnection2backendgraphmodelResourceConnection(ctx context.Context, sel ast.SelectionSet, v model.ResourceConnection) graphql.Marshaler {
	return ec._ResourceConnection(ctx, sel, &v)
}

func (ec *executionContext) marshalNResourceConnection2backendgraphmodelResourceConnection(ctx context.Context, sel ast.SelectionSet, v *model.ResourceConnection) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ResourceConnection(ctx, sel, v)
}

func (ec *executionContext) marshalNResourceEdge2backendgraphmodelResourceEdge(ctx context.Context, sel ast.SelectionSet, v []*model.ResourceEdge) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNResourceEdge2backendgraphmodelResourceEdge(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNResourceEdge2backendgraphmodelResourceEdge(ctx context.Context, sel ast.SelectionSet, v *model.ResourceEdge) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ResourceEdge(ctx, sel, v)
}

func (ec *executionContext) unmarshalNResourceImpact2backendgraphmodelResourceImpact(ctx context.Context, v interface{}) (model.ResourceImpact, error) {
	var res model.ResourceImpact
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNResourceImpact2backendgraphmodelResourceImpact(ctx context.Context, sel ast.SelectionSet, v model.ResourceImpact) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNResourceLayer2backendgraphmodelResourceLayer(ctx context.Context, v interface{}) (model.ResourceLayer, error) {
	var res model.ResourceLayer
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNResourceLayer2backendgraphmodelResourceLayer(ctx context.Context, sel ast.SelectionSet, v model.ResourceLayer) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNResourceLifecycleState2backendgraphmodelResourceLifecycleState(ctx context.Context, v interface{}) (model.ResourceLifecycleState, error) {
	var res model.ResourceLifecycleState
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNResourceLifecycleState2backendgraphmodelResourceLifecycleState(ctx context.Context, sel ast.SelectionSet, v model.ResourceLifecycleState) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNResourceMetadata2backendgraphmodelResourceMetadata(ctx context.Context, sel ast.SelectionSet, v *model.ResourceMetadata) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ResourceMetadata(ctx, sel, v)
}

func (ec *executionContext) marshalNResourceMetrics2backendgraphmodelResourceMetrics(ctx context.Context, sel ast.SelectionSet, v model.ResourceMetrics) graphql.Marshaler {
	return ec._ResourceMetrics(ctx, sel, &v)
}

func (ec *executionContext) marshalNResourceMetrics2backendgraphmodelResourceMetrics(ctx context.Context, sel ast.SelectionSet, v *model.ResourceMetrics) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ResourceMetrics(ctx, sel, v)
}

func (ec *executionContext) marshalNResourceReference2backendgraphmodelResourceReference(ctx context.Context, sel ast.SelectionSet, v []*model.ResourceReference) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNResourceReference2backendgraphmodelResourceReference(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNResourceReference2backendgraphmodelResourceReference(ctx context.Context, sel ast.SelectionSet, v *model.ResourceReference) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ResourceReference(ctx, sel, v)
}

func (ec *executionContext) marshalNResourceRelationshipEdge2backendgraphmodelResourceRelationshipEdge(ctx context.Context, sel ast.SelectionSet, v []*model.ResourceRelationshipEdge) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNResourceRelationshipEdge2backendgraphmodelResourceRelationshipEdge(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNResourceRelationshipEdge2backendgraphmodelResourceRelationshipEdge(ctx context.Context, sel ast.SelectionSet, v *model.ResourceRelationshipEdge) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ResourceRelationshipEdge(ctx, sel, v)
}

func (ec *executionContext) unmarshalNResourceRelationshipType2backendgraphmodelResourceRelationshipType(ctx context.Context, v interface{}) (model.ResourceRelationshipType, error) {
	var res model.ResourceRelationshipType
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNResourceRelationshipType2backendgraphmodelResourceRelationshipType(ctx context.Context, sel ast.SelectionSet, v model.ResourceRelationshipType) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNResourceRuntimeEvent2backendgraphmodelResourceRuntimeEvent(ctx context.Context, sel ast.SelectionSet, v model.ResourceRuntimeEvent) graphql.Marshaler {
	return ec._ResourceRuntimeEvent(ctx, sel, &v)
}

func (ec *executionContext) marshalNResourceRuntimeEvent2backendgraphmodelResourceRuntimeEvent(ctx context.Context, sel ast.SelectionSet, v *model.ResourceRuntimeEvent) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ResourceRuntimeEvent(ctx, sel, v)
}

func (ec *executionContext) marshalNResourceStateEvent2backendgraphmodelResourceStateEvent(ctx context.Context, sel ast.SelectionSet, v model.ResourceStateEvent) graphql.Marshaler {
	return ec._ResourceStateEvent(ctx, sel, &v)
}

func (ec *executionContext) marshalNResourceStateEvent2backendgraphmodelResourceStateEvent(ctx context.Context, sel ast.SelectionSet, v *model.ResourceStateEvent) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ResourceStateEvent(ctx, sel, v)
}

func (ec *executionContext) marshalNResourceUpdatedEvent2backendgraphmodelResourceUpdatedEvent(ctx context.Context, sel ast.SelectionSet, v model.ResourceUpdatedEvent) graphql.Marshaler {
	return ec._ResourceUpdatedEvent(ctx, sel, &v)
}

func (ec *executionContext) marshalNResourceUpdatedEvent2backendgraphmodelResourceUpdatedEvent(ctx context.Context, sel ast.SelectionSet, v *model.ResourceUpdatedEvent) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ResourceUpdatedEvent(ctx, sel, v)
}

func (ec *executionContext) marshalNRollbackChangeSetPayload2backendgraphmodelRollbackChangeSetPayload(ctx context.Context, sel ast.SelectionSet, v model.RollbackChangeSetPayload) graphql.Marshaler {
	return ec._RollbackChangeSetPayload(ctx, sel, &v)
}

func (ec *executionContext) marshalNRollbackChangeSetPayload2backendgraphmodelRollbackChangeSetPayload(ctx context.Context, sel ast.SelectionSet, v *model.RollbackChangeSetPayload) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._RollbackChangeSetPayload(ctx, sel, v)
}

func (ec *executionContext) unmarshalNRollbackOperation2backendgraphmodelRollbackOperation(ctx context.Context, v interface{}) (model.RollbackOperation, error) {
	var res model.RollbackOperation
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNRollbackOperation2backendgraphmodelRollbackOperation(ctx context.Context, sel ast.SelectionSet, v model.RollbackOperation) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNRollbackStep2backendgraphmodelRollbackStep(ctx context.Context, sel ast.SelectionSet, v []*model.RollbackStep) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNRollbackStep2backendgraphmodelRollbackStep(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNRollbackStep2backendgraphmodelRollbackStep(ctx context.Context, sel ast.SelectionSet, v *model.RollbackStep) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._RollbackStep(ctx, sel, v)
}

func (ec *executionContext) marshalNRoute2backendgraphmodelRoute(ctx context.Context, sel ast.SelectionSet, v []*model.Route) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNRoute2backendgraphmodelRoute(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNRoute2backendgraphmodelRoute(ctx context.Context, sel ast.SelectionSet, v *model.Route) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Route(ctx, sel, v)
}

func (ec *executionContext) marshalNRouteDeleteResult2backendgraphmodelRouteDeleteResult(ctx context.Context, sel ast.SelectionSet, v model.RouteDeleteResult) graphql.Marshaler {
	return ec._RouteDeleteResult(ctx, sel, &v)
}

func (ec *executionContext) marshalNRouteDeleteResult2backendgraphmodelRouteDeleteResult(ctx context.Context, sel ast.SelectionSet, v *model.RouteDeleteResult) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._RouteDeleteResult(ctx, sel, v)
}

func (ec *executionContext) marshalNRouteImpactAnalysis2backendgraphmodelRouteImpactAnalysis(ctx context.Context, sel ast.SelectionSet, v *model.RouteImpactAnalysis) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._RouteImpactAnalysis(ctx, sel, v)
}

func (ec *executionContext) unmarshalNRouteInput2backendgraphmodelRouteInput(ctx context.Context, v interface{}) (model.RouteInput, error) {
	res, err := ec.unmarshalInputRouteInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNRouteMutationResult2backendgraphmodelRouteMutationResult(ctx context.Context, sel ast.SelectionSet, v model.RouteMutationResult) graphql.Marshaler {
	return ec._RouteMutationResult(ctx, sel, &v)
}

func (ec *executionContext) marshalNRouteMutationResult2backendgraphmodelRouteMutationResult(ctx context.Context, sel ast.SelectionSet, v *model.RouteMutationResult) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._RouteMutationResult(ctx, sel, v)
}

func (ec *executionContext) marshalNRouteResource2backendgraphmodelRouteResource(ctx context.Context, sel ast.SelectionSet, v []*model.RouteResource) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNRouteResource2backendgraphmodelRouteResource(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNRouteResource2backendgraphmodelRouteResource(ctx context.Context, sel ast.SelectionSet, v *model.RouteResource) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._RouteResource(ctx, sel, v)
}

func (ec *executionContext) unmarshalNRouteScope2backendgraphmodelRouteScope(ctx context.Context, v interface{}) (model.RouteScope, error) {
	var res model.RouteScope
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNRouteScope2backendgraphmodelRouteScope(ctx context.Context, sel ast.SelectionSet, v model.RouteScope) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNRouteType2backendgraphmodelRouteType(ctx context.Context, v interface{}) (model.RouteType, error) {
	var res model.RouteType
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNRouteType2backendgraphmodelRouteType(ctx context.Context, sel ast.SelectionSet, v model.RouteType) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNRouter2backendgraphmodelRouter(ctx context.Context, sel ast.SelectionSet, v *model.Router) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Router(ctx, sel, v)
}

func (ec *executionContext) marshalNRouterAddedEvent2backendgraphmodelRouterAddedEvent(ctx context.Context, sel ast.SelectionSet, v model.RouterAddedEvent) graphql.Marshaler {
	return ec._RouterAddedEvent(ctx, sel, &v)
}

func (ec *executionContext) marshalNRouterAddedEvent2backendgraphmodelRouterAddedEvent(ctx context.Context, sel ast.SelectionSet, v *model.RouterAddedEvent) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._RouterAddedEvent(ctx, sel, v)
}

func (ec *executionContext) marshalNRouterConnection2backendgraphmodelRouterConnection(ctx context.Context, sel ast.SelectionSet, v model.RouterConnection) graphql.Marshaler {
	return ec._RouterConnection(ctx, sel, &v)
}

func (ec *executionContext) marshalNRouterConnection2backendgraphmodelRouterConnection(ctx context.Context, sel ast.SelectionSet, v *model.RouterConnection) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._RouterConnection(ctx, sel, v)
}

func (ec *executionContext) marshalNRouterEdge2backendgraphmodelRouterEdge(ctx context.Context, sel ast.SelectionSet, v []*model.RouterEdge) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNRouterEdge2backendgraphmodelRouterEdge(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNRouterEdge2backendgraphmodelRouterEdge(ctx context.Context, sel ast.SelectionSet, v *model.RouterEdge) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._RouterEdge(ctx, sel, v)
}

func (ec *executionContext) marshalNRouterOSVersion2backendgraphmodelRouterOSVersion(ctx context.Context, sel ast.SelectionSet, v *model.RouterOSVersion) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._RouterOSVersion(ctx, sel, v)
}

func (ec *executionContext) unmarshalNRouterPlatform2backendgraphmodelRouterPlatform(ctx context.Context, v interface{}) (model.RouterPlatform, error) {
	var res model.RouterPlatform
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNRouterPlatform2backendgraphmodelRouterPlatform(ctx context.Context, sel ast.SelectionSet, v model.RouterPlatform) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNRouterStatusEvent2backendgraphmodelRouterStatusEvent(ctx context.Context, sel ast.SelectionSet, v model.RouterStatusEvent) graphql.Marshaler {
	return ec._RouterStatusEvent(ctx, sel, &v)
}

func (ec *executionContext) marshalNRouterStatusEvent2backendgraphmodelRouterStatusEvent(ctx context.Context, sel ast.SelectionSet, v *model.RouterStatusEvent) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._RouterStatusEvent(ctx, sel, v)
}

func (ec *executionContext) marshalNRunTroubleshootStepPayload2backendgraphmodelRunTroubleshootStepPayload(ctx context.Context, sel ast.SelectionSet, v model.RunTroubleshootStepPayload) graphql.Marshaler {
	return ec._RunTroubleshootStepPayload(ctx, sel, &v)
}

func (ec *executionContext) marshalNRunTroubleshootStepPayload2backendgraphmodelRunTroubleshootStepPayload(ctx context.Context, sel ast.SelectionSet, v *model.RunTroubleshootStepPayload) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._RunTroubleshootStepPayload(ctx, sel, v)
}

func (ec *executionContext) unmarshalNRuntimeHealth2backendgraphmodelRuntimeHealth(ctx context.Context, v interface{}) (model.RuntimeHealth, error) {
	var res model.RuntimeHealth
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNRuntimeHealth2backendgraphmodelRuntimeHealth(ctx context.Context, sel ast.SelectionSet, v model.RuntimeHealth) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNRuntimeState2backendgraphmodelRuntimeState(ctx context.Context, sel ast.SelectionSet, v *model.RuntimeState) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._RuntimeState(ctx, sel, v)
}

func (ec *executionContext) unmarshalNScanNetworkInput2backendgraphmodelScanNetworkInput(ctx context.Context, v interface{}) (model.ScanNetworkInput, error) {
	res, err := ec.unmarshalInputScanNetworkInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNScanNetworkPayload2backendgraphmodelScanNetworkPayload(ctx context.Context, sel ast.SelectionSet, v model.ScanNetworkPayload) graphql.Marshaler {
	return ec._ScanNetworkPayload(ctx, sel, &v)
}

func (ec *executionContext) marshalNScanNetworkPayload2backendgraphmodelScanNetworkPayload(ctx context.Context, sel ast.SelectionSet, v *model.ScanNetworkPayload) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ScanNetworkPayload(ctx, sel, v)
}

func (ec *executionContext) marshalNScanProgressEvent2backendgraphmodelScanProgressEvent(ctx context.Context, sel ast.SelectionSet, v model.ScanProgressEvent) graphql.Marshaler {
	return ec._ScanProgressEvent(ctx, sel, &v)
}

func (ec *executionContext) marshalNScanProgressEvent2backendgraphmodelScanProgressEvent(ctx context.Context, sel ast.SelectionSet, v *model.ScanProgressEvent) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ScanProgressEvent(ctx, sel, v)
}

func (ec *executionContext) unmarshalNScanStatus2backendgraphmodelScanStatus(ctx context.Context, v interface{}) (model.ScanStatus, error) {
	var res model.ScanStatus
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNScanStatus2backendgraphmodelScanStatus(ctx context.Context, sel ast.SelectionSet, v model.ScanStatus) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNScanTask2backendgraphmodelScanTask(ctx context.Context, sel ast.SelectionSet, v []*model.ScanTask) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNScanTask2backendgraphmodelScanTask(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNScanTask2backendgraphmodelScanTask(ctx context.Context, sel ast.SelectionSet, v *model.ScanTask) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ScanTask(ctx, sel, v)
}

func (ec *executionContext) unmarshalNServiceStatus2backendgraphmodelServiceStatus(ctx context.Context, v interface{}) (model.ServiceStatus, error) {
	var res model.ServiceStatus
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNServiceStatus2backendgraphmodelServiceStatus(ctx context.Context, sel ast.SelectionSet, v model.ServiceStatus) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNSession2backendgraphmodelSession(ctx context.Context, sel ast.SelectionSet, v []*model.Session) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNSession2backendgraphmodelSession(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNSession2backendgraphmodelSession(ctx context.Context, sel ast.SelectionSet, v *model.Session) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Session(ctx, sel, v)
}

func (ec *executionContext) marshalNSetPreferredProtocolPayload2backendgraphmodelSetPreferredProtocolPayload(ctx context.Context, sel ast.SelectionSet, v model.SetPreferredProtocolPayload) graphql.Marshaler {
	return ec._SetPreferredProtocolPayload(ctx, sel, &v)
}

func (ec *executionContext) marshalNSetPreferredProtocolPayload2backendgraphmodelSetPreferredProtocolPayload(ctx context.Context, sel ast.SelectionSet, v *model.SetPreferredProtocolPayload) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._SetPreferredProtocolPayload(ctx, sel, v)
}

func (ec *executionContext) unmarshalNSize2backendgraphmodelSize(ctx context.Context, v interface{}) (model.Size, error) {
	var res model.Size
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNSize2backendgraphmodelSize(ctx context.Context, sel ast.SelectionSet, v model.Size) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNSoftwareInfo2backendgraphmodelSoftwareInfo(ctx context.Context, sel ast.SelectionSet, v *model.SoftwareInfo) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._SoftwareInfo(ctx, sel, v)
}

func (ec *executionContext) marshalNStartTroubleshootPayload2backendgraphmodelStartTroubleshootPayload(ctx context.Context, sel ast.SelectionSet, v model.StartTroubleshootPayload) graphql.Marshaler {
	return ec._StartTroubleshootPayload(ctx, sel, &v)
}

func (ec *executionContext) marshalNStartTroubleshootPayload2backendgraphmodelStartTroubleshootPayload(ctx context.Context, sel ast.SelectionSet, v *model.StartTroubleshootPayload) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._StartTroubleshootPayload(ctx, sel, v)
}

func (ec *executionContext) unmarshalNStaticIPInput2backendgraphmodelStaticIPInput(ctx context.Context, v interface{}) (model.StaticIPInput, error) {
	res, err := ec.unmarshalInputStaticIPInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNStatsDataPoint2backendgraphmodelStatsDataPoint(ctx context.Context, sel ast.SelectionSet, v []*model.StatsDataPoint) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNStatsDataPoint2backendgraphmodelStatsDataPoint(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNStatsDataPoint2backendgraphmodelStatsDataPoint(ctx context.Context, sel ast.SelectionSet, v *model.StatsDataPoint) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._StatsDataPoint(ctx, sel, v)
}

func (ec *executionContext) unmarshalNStatsTimeRangeInput2backendgraphmodelStatsTimeRangeInput(ctx context.Context, v interface{}) (model.StatsTimeRangeInput, error) {
	res, err := ec.unmarshalInputStatsTimeRangeInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNStorageMetrics2backendgraphmodelStorageMetrics(ctx context.Context, sel ast.SelectionSet, v *model.StorageMetrics) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._StorageMetrics(ctx, sel, v)
}

func (ec *executionContext) unmarshalNStpPortRole2backendgraphmodelStpPortRole(ctx context.Context, v interface{}) (model.StpPortRole, error) {
	var res model.StpPortRole
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNStpPortRole2backendgraphmodelStpPortRole(ctx context.Context, sel ast.SelectionSet, v model.StpPortRole) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNStpPortState2backendgraphmodelStpPortState(ctx context.Context, v interface{}) (model.StpPortState, error) {
	var res model.StpPortState
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNStpPortState2backendgraphmodelStpPortState(ctx context.Context, sel ast.SelectionSet, v model.StpPortState) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNStpProtocol2backendgraphmodelStpProtocol(ctx context.Context, v interface{}) (model.StpProtocol, error) {
	var res model.StpProtocol
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNStpProtocol2backendgraphmodelStpProtocol(ctx context.Context, sel ast.SelectionSet, v model.StpProtocol) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNString2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNString2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNString2string(ctx context.Context, v interface{}) ([]string, error) {
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNString2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNString2string(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNString2string(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNSuggestionSeverity2backendgraphmodelSuggestionSeverity(ctx context.Context, v interface{}) (model.SuggestionSeverity, error) {
	var res model.SuggestionSeverity
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNSuggestionSeverity2backendgraphmodelSuggestionSeverity(ctx context.Context, sel ast.SelectionSet, v model.SuggestionSeverity) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNTestAllCredentialsPayload2backendgraphmodelTestAllCredentialsPayload(ctx context.Context, sel ast.SelectionSet, v model.TestAllCredentialsPayload) graphql.Marshaler {
	return ec._TestAllCredentialsPayload(ctx, sel, &v)
}

func (ec *executionContext) marshalNTestAllCredentialsPayload2backendgraphmodelTestAllCredentialsPayload(ctx context.Context, sel ast.SelectionSet, v *model.TestAllCredentialsPayload) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._TestAllCredentialsPayload(ctx, sel, v)
}

func (ec *executionContext) marshalNTestConnectionPayload2backendgraphmodelTestConnectionPayload(ctx context.Context, sel ast.SelectionSet, v model.TestConnectionPayload) graphql.Marshaler {
	return ec._TestConnectionPayload(ctx, sel, &v)
}

func (ec *executionContext) marshalNTestConnectionPayload2backendgraphmodelTestConnectionPayload(ctx context.Context, sel ast.SelectionSet, v *model.TestConnectionPayload) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._TestConnectionPayload(ctx, sel, v)
}

func (ec *executionContext) marshalNTestNotificationPayload2backendgraphmodelTestNotificationPayload(ctx context.Context, sel ast.SelectionSet, v model.TestNotificationPayload) graphql.Marshaler {
	return ec._TestNotificationPayload(ctx, sel, &v)
}

func (ec *executionContext) marshalNTestNotificationPayload2backendgraphmodelTestNotificationPayload(ctx context.Context, sel ast.SelectionSet, v *model.TestNotificationPayload) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._TestNotificationPayload(ctx, sel, v)
}

func (ec *executionContext) marshalNTopologyEdge2backendgraphmodelTopologyEdge(ctx context.Context, sel ast.SelectionSet, v []*model.TopologyEdge) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNTopologyEdge2backendgraphmodelTopologyEdge(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNTopologyEdge2backendgraphmodelTopologyEdge(ctx context.Context, sel ast.SelectionSet, v *model.TopologyEdge) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._TopologyEdge(ctx, sel, v)
}

func (ec *executionContext) marshalNTopologyNode2backendgraphmodelTopologyNode(ctx context.Context, sel ast.SelectionSet, v []*model.TopologyNode) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNTopologyNode2backendgraphmodelTopologyNode(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNTopologyNode2backendgraphmodelTopologyNode(ctx context.Context, sel ast.SelectionSet, v *model.TopologyNode) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._TopologyNode(ctx, sel, v)
}

func (ec *executionContext) unmarshalNTopologyNodeType2backendgraphmodelTopologyNodeType(ctx context.Context, v interface{}) (model.TopologyNodeType, error) {
	var res model.TopologyNodeType
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNTopologyNodeType2backendgraphmodelTopologyNodeType(ctx context.Context, sel ast.SelectionSet, v model.TopologyNodeType) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNTopologyPosition2backendgraphmodelTopologyPosition(ctx context.Context, sel ast.SelectionSet, v *model.TopologyPosition) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._TopologyPosition(ctx, sel, v)
}

func (ec *executionContext) unmarshalNTracerouteEventType2backendgraphmodelTracerouteEventType(ctx context.Context, v interface{}) (model.TracerouteEventType, error) {
	var res model.TracerouteEventType
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNTracerouteEventType2backendgraphmodelTracerouteEventType(ctx context.Context, sel ast.SelectionSet, v model.TracerouteEventType) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNTracerouteHop2backendgraphmodelTracerouteHop(ctx context.Context, sel ast.SelectionSet, v []*model.TracerouteHop) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNTracerouteHop2backendgraphmodelTracerouteHop(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNTracerouteHop2backendgraphmodelTracerouteHop(ctx context.Context, sel ast.SelectionSet, v *model.TracerouteHop) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._TracerouteHop(ctx, sel, v)
}

func (ec *executionContext) unmarshalNTracerouteInput2backendgraphmodelTracerouteInput(ctx context.Context, v interface{}) (model.TracerouteInput, error) {
	res, err := ec.unmarshalInputTracerouteInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNTracerouteJob2backendgraphmodelTracerouteJob(ctx context.Context, sel ast.SelectionSet, v model.TracerouteJob) graphql.Marshaler {
	return ec._TracerouteJob(ctx, sel, &v)
}

func (ec *executionContext) marshalNTracerouteJob2backendgraphmodelTracerouteJob(ctx context.Context, sel ast.SelectionSet, v *model.TracerouteJob) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._TracerouteJob(ctx, sel, v)
}

func (ec *executionContext) marshalNTracerouteProgressEvent2backendgraphmodelTracerouteProgressEvent(ctx context.Context, sel ast.SelectionSet, v model.TracerouteProgressEvent) graphql.Marshaler {
	return ec._TracerouteProgressEvent(ctx, sel, &v)
}

func (ec *executionContext) marshalNTracerouteProgressEvent2backendgraphmodelTracerouteProgressEvent(ctx context.Context, sel ast.SelectionSet, v *model.TracerouteProgressEvent) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._TracerouteProgressEvent(ctx, sel, v)
}

func (ec *executionContext) unmarshalNTracerouteProtocol2backendgraphmodelTracerouteProtocol(ctx context.Context, v interface{}) (model.TracerouteProtocol, error) {
	var res model.TracerouteProtocol
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNTracerouteProtocol2backendgraphmodelTracerouteProtocol(ctx context.Context, sel ast.SelectionSet, v model.TracerouteProtocol) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNTroubleshootSession2backendgraphmodelTroubleshootSession(ctx context.Context, sel ast.SelectionSet, v model.TroubleshootSession) graphql.Marshaler {
	return ec._TroubleshootSession(ctx, sel, &v)
}

func (ec *executionContext) marshalNTroubleshootSession2backendgraphmodelTroubleshootSession(ctx context.Context, sel ast.SelectionSet, v *model.TroubleshootSession) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._TroubleshootSession(ctx, sel, v)
}

func (ec *executionContext) unmarshalNTroubleshootSessionStatus2backendgraphmodelTroubleshootSessionStatus(ctx context.Context, v interface{}) (model.TroubleshootSessionStatus, error) {
	var res model.TroubleshootSessionStatus
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNTroubleshootSessionStatus2backendgraphmodelTroubleshootSessionStatus(ctx context.Context, sel ast.SelectionSet, v model.TroubleshootSessionStatus) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNTroubleshootStep2backendgraphmodelTroubleshootStep(ctx context.Context, sel ast.SelectionSet, v []*model.TroubleshootStep) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNTroubleshootStep2backendgraphmodelTroubleshootStep(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNTroubleshootStep2backendgraphmodelTroubleshootStep(ctx context.Context, sel ast.SelectionSet, v *model.TroubleshootStep) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._TroubleshootStep(ctx, sel, v)
}

func (ec *executionContext) unmarshalNTroubleshootStepStatus2backendgraphmodelTroubleshootStepStatus(ctx context.Context, v interface{}) (model.TroubleshootStepStatus, error) {
	var res model.TroubleshootStepStatus
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNTroubleshootStepStatus2backendgraphmodelTroubleshootStepStatus(ctx context.Context, sel ast.SelectionSet, v model.TroubleshootStepStatus) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNTroubleshootStepType2backendgraphmodelTroubleshootStepType(ctx context.Context, v interface{}) (model.TroubleshootStepType, error) {
	var res model.TroubleshootStepType
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNTroubleshootStepType2backendgraphmodelTroubleshootStepType(ctx context.Context, sel ast.SelectionSet, v model.TroubleshootStepType) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNUpdateAlertRuleInput2backendgraphmodelUpdateAlertRuleInput(ctx context.Context, v interface{}) (model.UpdateAlertRuleInput, error) {
	res, err := ec.unmarshalInputUpdateAlertRuleInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNUpdateBridgeInput2backendgraphmodelUpdateBridgeInput(ctx context.Context, v interface{}) (model.UpdateBridgeInput, error) {
	res, err := ec.unmarshalInputUpdateBridgeInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNUpdateBridgePortInput2backendgraphmodelUpdateBridgePortInput(ctx context.Context, v interface{}) (model.UpdateBridgePortInput, error) {
	res, err := ec.unmarshalInputUpdateBridgePortInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNUpdateChangeSetItemInput2backendgraphmodelUpdateChangeSetItemInput(ctx context.Context, v interface{}) (model.UpdateChangeSetItemInput, error) {
	res, err := ec.unmarshalInputUpdateChangeSetItemInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNUpdateChangeSetItemPayload2backendgraphmodelUpdateChangeSetItemPayload(ctx context.Context, sel ast.SelectionSet, v model.UpdateChangeSetItemPayload) graphql.Marshaler {
	return ec._UpdateChangeSetItemPayload(ctx, sel, &v)
}

func (ec *executionContext) marshalNUpdateChangeSetItemPayload2backendgraphmodelUpdateChangeSetItemPayload(ctx context.Context, sel ast.SelectionSet, v *model.UpdateChangeSetItemPayload) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._UpdateChangeSetItemPayload(ctx, sel, v)
}

func (ec *executionContext) unmarshalNUpdateInterfaceInput2backendgraphmodelUpdateInterfaceInput(ctx context.Context, v interface{}) (model.UpdateInterfaceInput, error) {
	res, err := ec.unmarshalInputUpdateInterfaceInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNUpdateInterfacePayload2backendgraphmodelUpdateInterfacePayload(ctx context.Context, sel ast.SelectionSet, v model.UpdateInterfacePayload) graphql.Marshaler {
	return ec._UpdateInterfacePayload(ctx, sel, &v)
}

func (ec *executionContext) marshalNUpdateInterfacePayload2backendgraphmodelUpdateInterfacePayload(ctx context.Context, sel ast.SelectionSet, v *model.UpdateInterfacePayload) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._UpdateInterfacePayload(ctx, sel, v)
}

func (ec *executionContext) unmarshalNUpdateResourceInput2backendgraphmodelUpdateResourceInput(ctx context.Context, v interface{}) (model.UpdateResourceInput, error) {
	res, err := ec.unmarshalInputUpdateResourceInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNUpdateResourcePayload2backendgraphmodelUpdateResourcePayload(ctx context.Context, sel ast.SelectionSet, v model.UpdateResourcePayload) graphql.Marshaler {
	return ec._UpdateResourcePayload(ctx, sel, &v)
}

func (ec *executionContext) marshalNUpdateResourcePayload2backendgraphmodelUpdateResourcePayload(ctx context.Context, sel ast.SelectionSet, v *model.UpdateResourcePayload) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._UpdateResourcePayload(ctx, sel, v)
}

func (ec *executionContext) unmarshalNUpdateRouterInput2backendgraphmodelUpdateRouterInput(ctx context.Context, v interface{}) (model.UpdateRouterInput, error) {
	res, err := ec.unmarshalInputUpdateRouterInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNUpdateRouterPayload2backendgraphmodelUpdateRouterPayload(ctx context.Context, sel ast.SelectionSet, v model.UpdateRouterPayload) graphql.Marshaler {
	return ec._UpdateRouterPayload(ctx, sel, &v)
}

func (ec *executionContext) marshalNUpdateRouterPayload2backendgraphmodelUpdateRouterPayload(ctx context.Context, sel ast.SelectionSet, v *model.UpdateRouterPayload) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._UpdateRouterPayload(ctx, sel, v)
}

func (ec *executionContext) marshalNUpgradeImpact2backendgraphmodelUpgradeImpact(ctx context.Context, sel ast.SelectionSet, v *model.UpgradeImpact) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._UpgradeImpact(ctx, sel, v)
}

func (ec *executionContext) unmarshalNUpgradePriority2backendgraphmodelUpgradePriority(ctx context.Context, v interface{}) (model.UpgradePriority, error) {
	var res model.UpgradePriority
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNUpgradePriority2backendgraphmodelUpgradePriority(ctx context.Context, sel ast.SelectionSet, v model.UpgradePriority) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNUpgradeRecommendation2backendgraphmodelUpgradeRecommendation(ctx context.Context, sel ast.SelectionSet, v []*model.UpgradeRecommendation) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNUpgradeRecommendation2backendgraphmodelUpgradeRecommendation(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNUpgradeRecommendation2backendgraphmodelUpgradeRecommendation(ctx context.Context, sel ast.SelectionSet, v *model.UpgradeRecommendation) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._UpgradeRecommendation(ctx, sel, v)
}

func (ec *executionContext) marshalNUpgradeStep2backendgraphmodelUpgradeStep(ctx context.Context, sel ast.SelectionSet, v []*model.UpgradeStep) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNUpgradeStep2backendgraphmodelUpgradeStep(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNUpgradeStep2backendgraphmodelUpgradeStep(ctx context.Context, sel ast.SelectionSet, v *model.UpgradeStep) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._UpgradeStep(ctx, sel, v)
}

func (ec *executionContext) marshalNUptimeDataPoint2backendgraphmodelUptimeDataPoint(ctx context.Context, sel ast.SelectionSet, v *model.UptimeDataPoint) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._UptimeDataPoint(ctx, sel, v)
}

func (ec *executionContext) marshalNUser2backendgraphmodelUser(ctx context.Context, sel ast.SelectionSet, v *model.User) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._User(ctx, sel, v)
}

func (ec *executionContext) unmarshalNUserRole2backendgraphmodelUserRole(ctx context.Context, v interface{}) (model.UserRole, error) {
	tmp, err := graphql.UnmarshalString(v)
	res := model.UserRole(tmp)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNUserRole2backendgraphmodelUserRole(ctx context.Context, sel ast.SelectionSet, v model.UserRole) graphql.Marshaler {
	res := graphql.MarshalString(string(v))
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNVIFGuidanceStep2backendgraphmodelVIFGuidanceStep(ctx context.Context, sel ast.SelectionSet, v []*model.VIFGuidanceStep) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNVIFGuidanceStep2backendgraphmodelVIFGuidanceStep(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNVIFGuidanceStep2backendgraphmodelVIFGuidanceStep(ctx context.Context, sel ast.SelectionSet, v *model.VIFGuidanceStep) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._VIFGuidanceStep(ctx, sel, v)
}

func (ec *executionContext) marshalNVIFRequirements2backendgraphmodelVIFRequirements(ctx context.Context, sel ast.SelectionSet, v *model.VIFRequirements) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._VIFRequirements(ctx, sel, v)
}

func (ec *executionContext) marshalNValidateChangeSetPayload2backendgraphmodelValidateChangeSetPayload(ctx context.Context, sel ast.SelectionSet, v model.ValidateChangeSetPayload) graphql.Marshaler {
	return ec._ValidateChangeSetPayload(ctx, sel, &v)
}

func (ec *executionContext) marshalNValidateChangeSetPayload2backendgraphmodelValidateChangeSetPayload(ctx context.Context, sel ast.SelectionSet, v *model.ValidateChangeSetPayload) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ValidateChangeSetPayload(ctx, sel, v)
}

func (ec *executionContext) marshalNValidateResourcePayload2backendgraphmodelValidateResourcePayload(ctx context.Context, sel ast.SelectionSet, v model.ValidateResourcePayload) graphql.Marshaler {
	return ec._ValidateResourcePayload(ctx, sel, &v)
}

func (ec *executionContext) marshalNValidateResourcePayload2backendgraphmodelValidateResourcePayload(ctx context.Context, sel ast.SelectionSet, v *model.ValidateResourcePayload) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ValidateResourcePayload(ctx, sel, v)
}

func (ec *executionContext) marshalNValidationError2backendgraphmodelValidationError(ctx context.Context, sel ast.SelectionSet, v *model.ValidationError) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ValidationError(ctx, sel, v)
}

func (ec *executionContext) marshalNValidationIssue2backendgraphmodelValidationIssue(ctx context.Context, sel ast.SelectionSet, v []*model.ValidationIssue) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNValidationIssue2backendgraphmodelValidationIssue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNValidationIssue2backendgraphmodelValidationIssue(ctx context.Context, sel ast.SelectionSet, v *model.ValidationIssue) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ValidationIssue(ctx, sel, v)
}

func (ec *executionContext) unmarshalNValidationSeverity2backendgraphmodelValidationSeverity(ctx context.Context, v interface{}) (model.ValidationSeverity, error) {
	var res model.ValidationSeverity
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNValidationSeverity2backendgraphmodelValidationSeverity(ctx context.Context, sel ast.SelectionSet, v model.ValidationSeverity) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNValidationStage2backendgraphmodelValidationStage(ctx context.Context, v interface{}) (model.ValidationStage, error) {
	var res model.ValidationStage
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNValidationStage2backendgraphmodelValidationStage(ctx context.Context, sel ast.SelectionSet, v model.ValidationStage) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNVlan2backendgraphmodelVlan(ctx context.Context, sel ast.SelectionSet, v model.Vlan) graphql.Marshaler {
	return ec._Vlan(ctx, sel, &v)
}

func (ec *executionContext) marshalNVlan2backendgraphmodelVlan(ctx context.Context, sel ast.SelectionSet, v []*model.Vlan) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNVlan2backendgraphmodelVlan(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNVlan2backendgraphmodelVlan(ctx context.Context, sel ast.SelectionSet, v *model.Vlan) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Vlan(ctx, sel, v)
}

func (ec *executionContext) unmarshalNVlanInput2backendgraphmodelVlanInput(ctx context.Context, v interface{}) (model.VlanInput, error) {
	res, err := ec.unmarshalInputVlanInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNVlanMutationResult2backendgraphmodelVlanMutationResult(ctx context.Context, sel ast.SelectionSet, v model.VlanMutationResult) graphql.Marshaler {
	return ec._VlanMutationResult(ctx, sel, &v)
}

func (ec *executionContext) marshalNVlanMutationResult2backendgraphmodelVlanMutationResult(ctx context.Context, sel ast.SelectionSet, v *model.VlanMutationResult) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._VlanMutationResult(ctx, sel, v)
}

func (ec *executionContext) marshalNWANConnectionEvent2backendgraphmodelWANConnectionEvent(ctx context.Context, sel ast.SelectionSet, v *model.WANConnectionEvent) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._WANConnectionEvent(ctx, sel, v)
}

func (ec *executionContext) marshalNWANConnectionEventConnection2backendgraphmodelWANConnectionEventConnection(ctx context.Context, sel ast.SelectionSet, v model.WANConnectionEventConnection) graphql.Marshaler {
	return ec._WANConnectionEventConnection(ctx, sel, &v)
}

func (ec *executionContext) marshalNWANConnectionEventConnection2backendgraphmodelWANConnectionEventConnection(ctx context.Context, sel ast.SelectionSet, v *model.WANConnectionEventConnection) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._WANConnectionEventConnection(ctx, sel, v)
}

func (ec *executionContext) marshalNWANConnectionEventEdge2backendgraphmodelWANConnectionEventEdge(ctx context.Context, sel ast.SelectionSet, v []*model.WANConnectionEventEdge) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNWANConnectionEventEdge2backendgraphmodelWANConnectionEventEdge(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNWANConnectionEventEdge2backendgraphmodelWANConnectionEventEdge(ctx context.Context, sel ast.SelectionSet, v *model.WANConnectionEventEdge) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._WANConnectionEventEdge(ctx, sel, v)
}

func (ec *executionContext) unmarshalNWANConnectionType2backendgraphmodelWANConnectionType(ctx context.Context, v interface{}) (model.WANConnectionType, error) {
	var res model.WANConnectionType
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNWANConnectionType2backendgraphmodelWANConnectionType(ctx context.Context, sel ast.SelectionSet, v model.WANConnectionType) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNWANEventType2backendgraphmodelWANEventType(ctx context.Context, v interface{}) (model.WANEventType, error) {
	var res model.WANEventType
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNWANEventType2backendgraphmodelWANEventType(ctx context.Context, sel ast.SelectionSet, v model.WANEventType) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNWANHealthCheckInput2backendgraphmodelWANHealthCheckInput(ctx context.Context, v interface{}) (model.WANHealthCheckInput, error) {
	res, err := ec.unmarshalInputWANHealthCheckInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNWANHealthStatus2backendgraphmodelWANHealthStatus(ctx context.Context, sel ast.SelectionSet, v model.WANHealthStatus) graphql.Marshaler {
	return ec._WANHealthStatus(ctx, sel, &v)
}

func (ec *executionContext) marshalNWANHealthStatus2backendgraphmodelWANHealthStatus(ctx context.Context, sel ast.SelectionSet, v *model.WANHealthStatus) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._WANHealthStatus(ctx, sel, v)
}

func (ec *executionContext) marshalNWANInterface2backendgraphmodelWANInterface(ctx context.Context, sel ast.SelectionSet, v model.WANInterface) graphql.Marshaler {
	return ec._WANInterface(ctx, sel, &v)
}

func (ec *executionContext) marshalNWANInterface2backendgraphmodelWANInterface(ctx context.Context, sel ast.SelectionSet, v []*model.WANInterface) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNWANInterface2backendgraphmodelWANInterface(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNWANInterface2backendgraphmodelWANInterface(ctx context.Context, sel ast.SelectionSet, v *model.WANInterface) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._WANInterface(ctx, sel, v)
}

func (ec *executionContext) marshalNWANMutationResult2backendgraphmodelWANMutationResult(ctx context.Context, sel ast.SelectionSet, v model.WANMutationResult) graphql.Marshaler {
	return ec._WANMutationResult(ctx, sel, &v)
}

func (ec *executionContext) marshalNWANMutationResult2backendgraphmodelWANMutationResult(ctx context.Context, sel ast.SelectionSet, v *model.WANMutationResult) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._WANMutationResult(ctx, sel, v)
}

func (ec *executionContext) unmarshalNWANStatus2backendgraphmodelWANStatus(ctx context.Context, v interface{}) (model.WANStatus, error) {
	var res model.WANStatus
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNWANStatus2backendgraphmodelWANStatus(ctx context.Context, sel ast.SelectionSet, v model.WANStatus) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNWireGuardClientConfig2backendgraphmodelWireGuardClientConfig(ctx context.Context, sel ast.SelectionSet, v *model.WireGuardClientConfig) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._WireGuardClientConfig(ctx, sel, v)
}

func (ec *executionContext) marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective(ctx context.Context, sel ast.SelectionSet, v introspection.Directive) graphql.Marshaler {
	return ec.___Directive(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective(ctx context.Context, sel ast.SelectionSet, v []introspection.Directive) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalN__DirectiveLocation2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalN__DirectiveLocation2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalN__DirectiveLocation2string(ctx context.Context, v interface{}) ([]string, error) {
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalN__DirectiveLocation2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalN__DirectiveLocation2string(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__DirectiveLocation2string(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue(ctx context.Context, sel ast.SelectionSet, v introspection.EnumValue) graphql.Marshaler {
	return ec.___EnumValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Field2githubcom99designsgqlgengraphqlintrospectionField(ctx context.Context, sel ast.SelectionSet, v introspection.Field) graphql.Marshaler {
	return ec.___Field(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx context.Context, sel ast.SelectionSet, v introspection.InputValue) graphql.Marshaler {
	return ec.___InputValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v introspection.Type) graphql.Marshaler {
	return ec.___Type(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec.___Type(ctx, sel, v)
}

func (ec *executionContext) unmarshalN__TypeKind2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalN__TypeKind2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalOAffectedResource2backendgraphmodelAffectedResource(ctx context.Context, sel ast.SelectionSet, v []*model.AffectedResource) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNAffectedResource2backendgraphmodelAffectedResource(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOAlert2backendgraphmodelAlert(ctx context.Context, sel ast.SelectionSet, v *model.Alert) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Alert(ctx, sel, v)
}

func (ec *executionContext) unmarshalOAlertConditionInput2backendgraphmodelAlertConditionInput(ctx context.Context, v interface{}) ([]*model.AlertConditionInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*model.AlertConditionInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNAlertConditionInput2backendgraphmodelAlertConditionInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOAlertRule2backendgraphmodelAlertRule(ctx context.Context, sel ast.SelectionSet, v *model.AlertRule) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._AlertRule(ctx, sel, v)
}

func (ec *executionContext) unmarshalOAlertSeverity2backendgraphmodelAlertSeverity(ctx context.Context, v interface{}) (*model.AlertSeverity, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(model.AlertSeverity)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOAlertSeverity2backendgraphmodelAlertSeverity(ctx context.Context, sel ast.SelectionSet, v *model.AlertSeverity) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) marshalOBandwidthDataPoint2backendgraphmodelBandwidthDataPoint(ctx context.Context, sel ast.SelectionSet, v []*model.BandwidthDataPoint) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNBandwidthDataPoint2backendgraphmodelBandwidthDataPoint(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOBoolean2bool(ctx context.Context, v interface{}) (bool, error) {
	res, err := graphql.UnmarshalBoolean(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	res := graphql.MarshalBoolean(v)
	return res
}

func (ec *executionContext) unmarshalOBoolean2bool(ctx context.Context, v interface{}) (*bool, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalBoolean(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOBoolean2bool(ctx context.Context, sel ast.SelectionSet, v *bool) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalBoolean(*v)
	return res
}

func (ec *executionContext) marshalOBridge2backendgraphmodelBridge(ctx context.Context, sel ast.SelectionSet, v *model.Bridge) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Bridge(ctx, sel, v)
}

func (ec *executionContext) marshalOBridgePort2backendgraphmodelBridgePort(ctx context.Context, sel ast.SelectionSet, v *model.BridgePort) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._BridgePort(ctx, sel, v)
}

func (ec *executionContext) marshalOBridgeResource2backendgraphmodelBridgeResource(ctx context.Context, sel ast.SelectionSet, v *model.BridgeResource) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._BridgeResource(ctx, sel, v)
}

func (ec *executionContext) marshalOBridgeStpStatus2backendgraphmodelBridgeStpStatus(ctx context.Context, sel ast.SelectionSet, v *model.BridgeStpStatus) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._BridgeStpStatus(ctx, sel, v)
}

func (ec *executionContext) marshalOBridgeVlan2backendgraphmodelBridgeVlan(ctx context.Context, sel ast.SelectionSet, v *model.BridgeVlan) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._BridgeVlan(ctx, sel, v)
}

func (ec *executionContext) unmarshalOCacheScope2backendgraphmodelCacheScope(ctx context.Context, v interface{}) (*model.CacheScope, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(model.CacheScope)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOCacheScope2backendgraphmodelCacheScope(ctx context.Context, sel ast.SelectionSet, v *model.CacheScope) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) marshalOChangeLogEntry2backendgraphmodelChangeLogEntry(ctx context.Context, sel ast.SelectionSet, v []*model.ChangeLogEntry) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNChangeLogEntry2backendgraphmodelChangeLogEntry(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOChangeSet2backendgraphmodelChangeSet(ctx context.Context, sel ast.SelectionSet, v *model.ChangeSet) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ChangeSet(ctx, sel, v)
}

func (ec *executionContext) marshalOChangeSetError2backendgraphmodelChangeSetError(ctx context.Context, sel ast.SelectionSet, v *model.ChangeSetError) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ChangeSetError(ctx, sel, v)
}

func (ec *executionContext) unmarshalOChangeSetStatus2backendgraphmodelChangeSetStatus(ctx context.Context, v interface{}) (*model.ChangeSetStatus, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(model.ChangeSetStatus)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOChangeSetStatus2backendgraphmodelChangeSetStatus(ctx context.Context, sel ast.SelectionSet, v *model.ChangeSetStatus) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) marshalOChangeSetValidationResult2backendgraphmodelChangeSetValidationResult(ctx context.Context, sel ast.SelectionSet, v *model.ChangeSetValidationResult) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ChangeSetValidationResult(ctx, sel, v)
}

func (ec *executionContext) marshalOCompositeResource2backendgraphmodelCompositeResource(ctx context.Context, sel ast.SelectionSet, v *model.CompositeResource) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._CompositeResource(ctx, sel, v)
}

func (ec *executionContext) marshalOConfigPreview2backendgraphmodelConfigPreview(ctx context.Context, sel ast.SelectionSet, v *model.ConfigPreview) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ConfigPreview(ctx, sel, v)
}

func (ec *executionContext) marshalOConnectionDetails2backendgraphmodelConnectionDetails(ctx context.Context, sel ast.SelectionSet, v *model.ConnectionDetails) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ConnectionDetails(ctx, sel, v)
}

func (ec *executionContext) marshalOConnectionError2backendgraphmodelConnectionError(ctx context.Context, sel ast.SelectionSet, v *model.ConnectionError) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ConnectionError(ctx, sel, v)
}

func (ec *executionContext) unmarshalOConnectionStatus2backendgraphmodelConnectionStatus(ctx context.Context, v interface{}) (*model.ConnectionStatus, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(model.ConnectionStatus)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOConnectionStatus2backendgraphmodelConnectionStatus(ctx context.Context, sel ast.SelectionSet, v *model.ConnectionStatus) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) marshalOConnectionTestResult2backendgraphmodelConnectionTestResult(ctx context.Context, sel ast.SelectionSet, v *model.ConnectionTestResult) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ConnectionTestResult(ctx, sel, v)
}

func (ec *executionContext) unmarshalOCredentialErrorCode2backendgraphmodelCredentialErrorCode(ctx context.Context, v interface{}) (*model.CredentialErrorCode, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(model.CredentialErrorCode)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOCredentialErrorCode2backendgraphmodelCredentialErrorCode(ctx context.Context, sel ast.SelectionSet, v *model.CredentialErrorCode) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) marshalOCurrentItemInfo2backendgraphmodelCurrentItemInfo(ctx context.Context, sel ast.SelectionSet, v *model.CurrentItemInfo) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._CurrentItemInfo(ctx, sel, v)
}

func (ec *executionContext) marshalODHCPServerResource2backendgraphmodelDHCPServerResource(ctx context.Context, sel ast.SelectionSet, v *model.DHCPServerResource) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._DHCPServerResource(ctx, sel, v)
}

func (ec *executionContext) marshalODailyStats2backendgraphmodelDailyStats(ctx context.Context, sel ast.SelectionSet, v []*model.DailyStats) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNDailyStats2backendgraphmodelDailyStats(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalODateTime2timeTime(ctx context.Context, v interface{}) (*time.Time, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalTime(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalODateTime2timeTime(ctx context.Context, sel ast.SelectionSet, v *time.Time) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalTime(*v)
	return res
}

func (ec *executionContext) marshalODeploymentState2backendgraphmodelDeploymentState(ctx context.Context, sel ast.SelectionSet, v *model.DeploymentState) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._DeploymentState(ctx, sel, v)
}

func (ec *executionContext) marshalODevice2backendgraphmodelDevice(ctx context.Context, sel ast.SelectionSet, v *model.Device) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Device(ctx, sel, v)
}

func (ec *executionContext) marshalODhcpClient2backendgraphmodelDhcpClient(ctx context.Context, sel ast.SelectionSet, v *model.DhcpClient) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._DhcpClient(ctx, sel, v)
}

func (ec *executionContext) unmarshalODisconnectReason2backendgraphmodelDisconnectReason(ctx context.Context, v interface{}) (*model.DisconnectReason, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(model.DisconnectReason)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalODisconnectReason2backendgraphmodelDisconnectReason(ctx context.Context, sel ast.SelectionSet, v *model.DisconnectReason) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) marshalODriftInfo2backendgraphmodelDriftInfo(ctx context.Context, sel ast.SelectionSet, v *model.DriftInfo) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._DriftInfo(ctx, sel, v)
}

func (ec *executionContext) unmarshalODuration2backendgraphmodelDuration(ctx context.Context, v interface{}) (*model.Duration, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(model.Duration)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalODuration2backendgraphmodelDuration(ctx context.Context, sel ast.SelectionSet, v *model.Duration) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOErrorCategory2backendgraphmodelErrorCategory(ctx context.Context, v interface{}) (*model.ErrorCategory, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(model.ErrorCategory)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOErrorCategory2backendgraphmodelErrorCategory(ctx context.Context, sel ast.SelectionSet, v *model.ErrorCategory) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) marshalOFeatureDeployment2backendgraphmodelFeatureDeployment(ctx context.Context, sel ast.SelectionSet, v *model.FeatureDeployment) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._FeatureDeployment(ctx, sel, v)
}

func (ec *executionContext) marshalOFeatureRuntime2backendgraphmodelFeatureRuntime(ctx context.Context, sel ast.SelectionSet, v *model.FeatureRuntime) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._FeatureRuntime(ctx, sel, v)
}

func (ec *executionContext) unmarshalOFloat2float64(ctx context.Context, v interface{}) (*float64, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalFloatContext(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOFloat2float64(ctx context.Context, sel ast.SelectionSet, v *float64) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalFloatContext(*v)
	return graphql.WrapContextMarshaler(ctx, res)
}

func (ec *executionContext) unmarshalOFrameTypes2backendgraphmodelFrameTypes(ctx context.Context, v interface{}) (*model.FrameTypes, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(model.FrameTypes)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOFrameTypes2backendgraphmodelFrameTypes(ctx context.Context, sel ast.SelectionSet, v *model.FrameTypes) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) marshalOHealthCheckResult2backendgraphmodelHealthCheckResult(ctx context.Context, sel ast.SelectionSet, v *model.HealthCheckResult) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._HealthCheckResult(ctx, sel, v)
}

func (ec *executionContext) marshalOHourlyStats2backendgraphmodelHourlyStats(ctx context.Context, sel ast.SelectionSet, v []*model.HourlyStats) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNHourlyStats2backendgraphmodelHourlyStats(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOID2string(ctx context.Context, v interface{}) ([]string, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNID2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOID2string(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNID2string(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOID2string(ctx context.Context, v interface{}) ([][]string, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([][]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNID2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOID2string(ctx context.Context, sel ast.SelectionSet, v [][]string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNID2string(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOID2string(ctx context.Context, v interface{}) (*string, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalID(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOID2string(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalID(*v)
	return res
}

func (ec *executionContext) unmarshalOIPv42backendgraphmodelIPv4(ctx context.Context, v interface{}) ([]model.IPv4, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]model.IPv4, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNIPv42backendgraphmodelIPv4(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOIPv42backendgraphmodelIPv4(ctx context.Context, sel ast.SelectionSet, v []model.IPv4) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNIPv42backendgraphmodelIPv4(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOIPv42backendgraphmodelIPv4(ctx context.Context, v interface{}) (*model.IPv4, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(model.IPv4)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOIPv42backendgraphmodelIPv4(ctx context.Context, sel ast.SelectionSet, v *model.IPv4) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) marshalOISPInfo2backendgraphmodelISPInfo(ctx context.Context, sel ast.SelectionSet, v *model.ISPInfo) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ISPInfo(ctx, sel, v)
}

func (ec *executionContext) unmarshalOInt2int(ctx context.Context, v interface{}) ([]int, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]int, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNInt2int(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOInt2int(ctx context.Context, sel ast.SelectionSet, v []int) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNInt2int(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOInt2int(ctx context.Context, v interface{}) (*int, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalInt(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOInt2int(ctx context.Context, sel ast.SelectionSet, v *int) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalInt(*v)
	return res
}

func (ec *executionContext) unmarshalOIntRange2backendgraphmodelIntRange(ctx context.Context, v interface{}) (*model.IntRange, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputIntRange(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOInterface2backendgraphmodelInterface(ctx context.Context, sel ast.SelectionSet, v *model.Interface) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Interface(ctx, sel, v)
}

func (ec *executionContext) marshalOInterfaceStats2backendgraphmodelInterfaceStats(ctx context.Context, sel ast.SelectionSet, v *model.InterfaceStats) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._InterfaceStats(ctx, sel, v)
}

func (ec *executionContext) unmarshalOInterfaceType2backendgraphmodelInterfaceType(ctx context.Context, v interface{}) (*model.InterfaceType, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(model.InterfaceType)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOInterfaceType2backendgraphmodelInterfaceType(ctx context.Context, sel ast.SelectionSet, v *model.InterfaceType) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) marshalOIpAddress2backendgraphmodelIPAddress(ctx context.Context, sel ast.SelectionSet, v *model.IPAddress) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._IpAddress(ctx, sel, v)
}

func (ec *executionContext) marshalOIpAddressImpactAnalysis2backendgraphmodelIPAddressImpactAnalysis(ctx context.Context, sel ast.SelectionSet, v *model.IPAddressImpactAnalysis) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._IpAddressImpactAnalysis(ctx, sel, v)
}

func (ec *executionContext) unmarshalOJSON2map(ctx context.Context, v interface{}) (map[string]interface{}, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalMap(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOJSON2map(ctx context.Context, sel ast.SelectionSet, v map[string]interface{}) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalMap(v)
	return res
}

func (ec *executionContext) marshalOLANNetworkDeployment2backendgraphmodelLANNetworkDeployment(ctx context.Context, sel ast.SelectionSet, v *model.LANNetworkDeployment) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._LANNetworkDeployment(ctx, sel, v)
}

func (ec *executionContext) marshalOLANNetworkRuntime2backendgraphmodelLANNetworkRuntime(ctx context.Context, sel ast.SelectionSet, v *model.LANNetworkRuntime) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._LANNetworkRuntime(ctx, sel, v)
}

func (ec *executionContext) marshalOLteModem2backendgraphmodelLteModem(ctx context.Context, sel ast.SelectionSet, v *model.LteModem) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._LteModem(ctx, sel, v)
}

func (ec *executionContext) unmarshalOMAC2backendgraphmodelMAC(ctx context.Context, v interface{}) (*model.MAC, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(model.MAC)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOMAC2backendgraphmodelMAC(ctx context.Context, sel ast.SelectionSet, v *model.MAC) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) marshalOMutationError2backendgraphmodelMutationError(ctx context.Context, sel ast.SelectionSet, v []*model.MutationError) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNMutationError2backendgraphmodelMutationError(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalONode2backendgraphmodelNode(ctx context.Context, sel ast.SelectionSet, v model.Node) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Node(ctx, sel, v)
}

func (ec *executionContext) unmarshalOPaginationInput2backendgraphmodelPaginationInput(ctx context.Context, v interface{}) (*model.PaginationInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputPaginationInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOPlatformFeature2backendgraphmodelPlatformFeature(ctx context.Context, sel ast.SelectionSet, v []*model.PlatformFeature) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNPlatformFeature2backendgraphmodelPlatformFeature(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOPlatformInfo2backendgraphmodelPlatformInfo(ctx context.Context, sel ast.SelectionSet, v *model.PlatformInfo) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._PlatformInfo(ctx, sel, v)
}

func (ec *executionContext) marshalOPlatformLimitation2backendgraphmodelPlatformLimitation(ctx context.Context, sel ast.SelectionSet, v []*model.PlatformLimitation) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNPlatformLimitation2backendgraphmodelPlatformLimitation(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOPort2backendgraphmodelPort(ctx context.Context, v interface{}) ([]model.Port, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]model.Port, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNPort2backendgraphmodelPort(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOPort2backendgraphmodelPort(ctx context.Context, sel ast.SelectionSet, v []model.Port) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNPort2backendgraphmodelPort(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOPort2backendgraphmodelPort(ctx context.Context, v interface{}) (*model.Port, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(model.Port)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOPort2backendgraphmodelPort(ctx context.Context, sel ast.SelectionSet, v *model.Port) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) marshalOPppoeClient2backendgraphmodelPppoeClient(ctx context.Context, sel ast.SelectionSet, v *model.PppoeClient) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._PppoeClient(ctx, sel, v)
}

func (ec *executionContext) unmarshalOProtocol2backendgraphmodelProtocol(ctx context.Context, v interface{}) (*model.Protocol, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(model.Protocol)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOProtocol2backendgraphmodelProtocol(ctx context.Context, sel ast.SelectionSet, v *model.Protocol) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOProtocolPreference2backendgraphmodelProtocolPreference(ctx context.Context, v interface{}) (*model.ProtocolPreference, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(model.ProtocolPreference)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOProtocolPreference2backendgraphmodelProtocolPreference(ctx context.Context, sel ast.SelectionSet, v *model.ProtocolPreference) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) marshalOQuietHoursConfig2backendgraphmodelQuietHoursConfig(ctx context.Context, sel ast.SelectionSet, v *model.QuietHoursConfig) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._QuietHoursConfig(ctx, sel, v)
}

func (ec *executionContext) unmarshalOQuietHoursConfigInput2backendgraphmodelQuietHoursConfigInput(ctx context.Context, v interface{}) (*model.QuietHoursConfigInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputQuietHoursConfigInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOResource2backendgraphmodelResource(ctx context.Context, sel ast.SelectionSet, v model.Resource) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Resource(ctx, sel, v)
}

func (ec *executionContext) unmarshalOResourceCategory2backendgraphmodelResourceCategory(ctx context.Context, v interface{}) (*model.ResourceCategory, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(model.ResourceCategory)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOResourceCategory2backendgraphmodelResourceCategory(ctx context.Context, sel ast.SelectionSet, v *model.ResourceCategory) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOResourceLayer2backendgraphmodelResourceLayer(ctx context.Context, v interface{}) ([]model.ResourceLayer, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]model.ResourceLayer, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNResourceLayer2backendgraphmodelResourceLayer(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOResourceLayer2backendgraphmodelResourceLayer(ctx context.Context, sel ast.SelectionSet, v []model.ResourceLayer) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNResourceLayer2backendgraphmodelResourceLayer(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOResourceLifecycleState2backendgraphmodelResourceLifecycleState(ctx context.Context, v interface{}) (*model.ResourceLifecycleState, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(model.ResourceLifecycleState)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOResourceLifecycleState2backendgraphmodelResourceLifecycleState(ctx context.Context, sel ast.SelectionSet, v *model.ResourceLifecycleState) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) marshalOResourceReference2backendgraphmodelResourceReference(ctx context.Context, sel ast.SelectionSet, v *model.ResourceReference) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ResourceReference(ctx, sel, v)
}

func (ec *executionContext) marshalOResourceRelationships2backendgraphmodelResourceRelationships(ctx context.Context, sel ast.SelectionSet, v *model.ResourceRelationships) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ResourceRelationships(ctx, sel, v)
}

func (ec *executionContext) unmarshalOResourceRelationshipsInput2backendgraphmodelResourceRelationshipsInput(ctx context.Context, v interface{}) (*model.ResourceRelationshipsInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputResourceRelationshipsInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalORoute2backendgraphmodelRoute(ctx context.Context, sel ast.SelectionSet, v *model.Route) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Route(ctx, sel, v)
}

func (ec *executionContext) unmarshalORouteType2backendgraphmodelRouteType(ctx context.Context, v interface{}) (*model.RouteType, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(model.RouteType)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalORouteType2backendgraphmodelRouteType(ctx context.Context, sel ast.SelectionSet, v *model.RouteType) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) marshalORouter2backendgraphmodelRouter(ctx context.Context, sel ast.SelectionSet, v *model.Router) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Router(ctx, sel, v)
}

func (ec *executionContext) marshalORouterCapabilities2backendgraphmodelRouterCapabilities(ctx context.Context, sel ast.SelectionSet, v *model.RouterCapabilities) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._RouterCapabilities(ctx, sel, v)
}

func (ec *executionContext) marshalORouterCredentials2backendgraphmodelRouterCredentials(ctx context.Context, sel ast.SelectionSet, v *model.RouterCredentials) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._RouterCredentials(ctx, sel, v)
}

func (ec *executionContext) marshalORouterOSInfo2backendgraphmodelRouterOSInfo(ctx context.Context, sel ast.SelectionSet, v *model.RouterOSInfo) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._RouterOSInfo(ctx, sel, v)
}

func (ec *executionContext) unmarshalORouterPlatform2backendgraphmodelRouterPlatform(ctx context.Context, v interface{}) (*model.RouterPlatform, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(model.RouterPlatform)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalORouterPlatform2backendgraphmodelRouterPlatform(ctx context.Context, sel ast.SelectionSet, v *model.RouterPlatform) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) marshalORuntimeMetrics2backendgraphmodelRuntimeMetrics(ctx context.Context, sel ast.SelectionSet, v *model.RuntimeMetrics) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._RuntimeMetrics(ctx, sel, v)
}

func (ec *executionContext) marshalORuntimeState2backendgraphmodelRuntimeState(ctx context.Context, sel ast.SelectionSet, v *model.RuntimeState) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._RuntimeState(ctx, sel, v)
}

func (ec *executionContext) marshalOScanTask2backendgraphmodelScanTask(ctx context.Context, sel ast.SelectionSet, v *model.ScanTask) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ScanTask(ctx, sel, v)
}

func (ec *executionContext) unmarshalOSize2backendgraphmodelSize(ctx context.Context, v interface{}) (*model.Size, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(model.Size)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOSize2backendgraphmodelSize(ctx context.Context, sel ast.SelectionSet, v *model.Size) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) marshalOStaticIPConfig2backendgraphmodelStaticIPConfig(ctx context.Context, sel ast.SelectionSet, v *model.StaticIPConfig) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._StaticIPConfig(ctx, sel, v)
}

func (ec *executionContext) unmarshalOStpProtocol2backendgraphmodelStpProtocol(ctx context.Context, v interface{}) (*model.StpProtocol, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(model.StpProtocol)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOStpProtocol2backendgraphmodelStpProtocol(ctx context.Context, sel ast.SelectionSet, v *model.StpProtocol) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOString2string(ctx context.Context, v interface{}) ([]string, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNString2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOString2string(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNString2string(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOString2string(ctx context.Context, v interface{}) (*string, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalString(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOString2string(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalString(*v)
	return res
}

func (ec *executionContext) marshalOTLSStatus2backendgraphmodelTLSStatus(ctx context.Context, sel ast.SelectionSet, v *model.TLSStatus) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._TLSStatus(ctx, sel, v)
}

func (ec *executionContext) marshalOTelemetryData2backendgraphmodelTelemetryData(ctx context.Context, sel ast.SelectionSet, v *model.TelemetryData) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._TelemetryData(ctx, sel, v)
}

func (ec *executionContext) marshalOThrottleConfig2backendgraphmodelThrottleConfig(ctx context.Context, sel ast.SelectionSet, v *model.ThrottleConfig) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ThrottleConfig(ctx, sel, v)
}

func (ec *executionContext) unmarshalOThrottleConfigInput2backendgraphmodelThrottleConfigInput(ctx context.Context, v interface{}) (*model.ThrottleConfigInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputThrottleConfigInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOTopologyEdgeStyle2backendgraphmodelTopologyEdgeStyle(ctx context.Context, sel ast.SelectionSet, v *model.TopologyEdgeStyle) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._TopologyEdgeStyle(ctx, sel, v)
}

func (ec *executionContext) marshalOTopologyNodeStyle2backendgraphmodelTopologyNodeStyle(ctx context.Context, sel ast.SelectionSet, v *model.TopologyNodeStyle) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._TopologyNodeStyle(ctx, sel, v)
}

func (ec *executionContext) marshalOTracerouteHop2backendgraphmodelTracerouteHop(ctx context.Context, sel ast.SelectionSet, v *model.TracerouteHop) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._TracerouteHop(ctx, sel, v)
}

func (ec *executionContext) unmarshalOTracerouteProtocol2backendgraphmodelTracerouteProtocol(ctx context.Context, v interface{}) (*model.TracerouteProtocol, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(model.TracerouteProtocol)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOTracerouteProtocol2backendgraphmodelTracerouteProtocol(ctx context.Context, sel ast.SelectionSet, v *model.TracerouteProtocol) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) marshalOTracerouteResult2backendgraphmodelTracerouteResult(ctx context.Context, sel ast.SelectionSet, v *model.TracerouteResult) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._TracerouteResult(ctx, sel, v)
}

func (ec *executionContext) marshalOTroubleshootFixSuggestion2backendgraphmodelTroubleshootFixSuggestion(ctx context.Context, sel ast.SelectionSet, v *model.TroubleshootFixSuggestion) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._TroubleshootFixSuggestion(ctx, sel, v)
}

func (ec *executionContext) marshalOTroubleshootSession2backendgraphmodelTroubleshootSession(ctx context.Context, sel ast.SelectionSet, v *model.TroubleshootSession) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._TroubleshootSession(ctx, sel, v)
}

func (ec *executionContext) marshalOTroubleshootStepResult2backendgraphmodelTroubleshootStepResult(ctx context.Context, sel ast.SelectionSet, v *model.TroubleshootStepResult) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._TroubleshootStepResult(ctx, sel, v)
}

func (ec *executionContext) unmarshalOUpdateInterfaceInput2backendgraphmodelUpdateInterfaceInput(ctx context.Context, v interface{}) (*model.UpdateInterfaceInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputUpdateInterfaceInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOUpgradeRecommendation2backendgraphmodelUpgradeRecommendation(ctx context.Context, sel ast.SelectionSet, v *model.UpgradeRecommendation) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._UpgradeRecommendation(ctx, sel, v)
}

func (ec *executionContext) marshalOUptimeDataPoint2backendgraphmodelUptimeDataPoint(ctx context.Context, sel ast.SelectionSet, v []*model.UptimeDataPoint) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNUptimeDataPoint2backendgraphmodelUptimeDataPoint(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOUser2backendgraphmodelUser(ctx context.Context, sel ast.SelectionSet, v *model.User) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._User(ctx, sel, v)
}

func (ec *executionContext) unmarshalOValidateFormat2backendgraphmodelValidateFormat(ctx context.Context, v interface{}) (*model.ValidateFormat, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(model.ValidateFormat)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOValidateFormat2backendgraphmodelValidateFormat(ctx context.Context, sel ast.SelectionSet, v *model.ValidateFormat) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) marshalOValidationError2backendgraphmodelValidationError(ctx context.Context, sel ast.SelectionSet, v []*model.ValidationError) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNValidationError2backendgraphmodelValidationError(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOValidationResult2backendgraphmodelValidationResult(ctx context.Context, sel ast.SelectionSet, v *model.ValidationResult) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ValidationResult(ctx, sel, v)
}

func (ec *executionContext) marshalOVlan2backendgraphmodelVlan(ctx context.Context, sel ast.SelectionSet, v *model.Vlan) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Vlan(ctx, sel, v)
}

func (ec *executionContext) marshalOVlanDependencies2backendgraphmodelVlanDependencies(ctx context.Context, sel ast.SelectionSet, v *model.VlanDependencies) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._VlanDependencies(ctx, sel, v)
}

func (ec *executionContext) unmarshalOVlanFilter2backendgraphmodelVlanFilter(ctx context.Context, v interface{}) (*model.VlanFilter, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputVlanFilter(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOVlanTopology2backendgraphmodelVlanTopology(ctx context.Context, sel ast.SelectionSet, v *model.VlanTopology) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._VlanTopology(ctx, sel, v)
}

func (ec *executionContext) marshalOWANHealthStatus2backendgraphmodelWANHealthStatus(ctx context.Context, sel ast.SelectionSet, v *model.WANHealthStatus) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._WANHealthStatus(ctx, sel, v)
}

func (ec *executionContext) marshalOWANInterface2backendgraphmodelWANInterface(ctx context.Context, sel ast.SelectionSet, v *model.WANInterface) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._WANInterface(ctx, sel, v)
}

func (ec *executionContext) marshalOWANLinkRuntime2backendgraphmodelWANLinkRuntime(ctx context.Context, sel ast.SelectionSet, v *model.WANLinkRuntime) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._WANLinkRuntime(ctx, sel, v)
}

func (ec *executionContext) marshalOWireGuardDeployment2backendgraphmodelWireGuardDeployment(ctx context.Context, sel ast.SelectionSet, v *model.WireGuardDeployment) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._WireGuardDeployment(ctx, sel, v)
}

func (ec *executionContext) marshalOWireGuardRuntime2backendgraphmodelWireGuardRuntime(ctx context.Context, sel ast.SelectionSet, v *model.WireGuardRuntime) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._WireGuardRuntime(ctx, sel, v)
}

func (ec *executionContext) marshalO__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue(ctx context.Context, sel ast.SelectionSet, v []introspection.EnumValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Field2githubcom99designsgqlgengraphqlintrospectionField(ctx context.Context, sel ast.SelectionSet, v []introspection.Field) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Field2githubcom99designsgqlgengraphqlintrospectionField(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Schema2githubcom99designsgqlgengraphqlintrospectionSchema(ctx context.Context, sel ast.SelectionSet, v *introspection.Schema) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.___Schema(ctx, sel, v)
}

func (ec *executionContext) marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.___Type(ctx, sel, v)
}

// endregion ***************************** type.gotpl *****************************
