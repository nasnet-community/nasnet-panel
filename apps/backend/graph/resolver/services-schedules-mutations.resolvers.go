package resolver

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.86

import (
	"backend/graph/model"
	"backend/internal/apperrors"
	"backend/internal/orchestrator/scheduling"
	"context"
)

// CreateSchedule creates a new routing schedule.
func (r *mutationResolver) CreateSchedule(ctx context.Context, routerID string, input model.CreateScheduleInput) (*model.RoutingSchedule, error) {
	r.log.Infow("CreateSchedule mutation called",
		"routerID", routerID,
		"routingID", input.RoutingID)

	// Check authorization: user must be authenticated
	if r.authService == nil {
		return nil, apperrors.NewInternalError("authentication service not available", nil)
	}

	// Check if ScheduleService is available
	if r.ScheduleService == nil {
		return nil, apperrors.NewInternalError("schedule service not available", nil)
	}

	// Convert GraphQL input to service input
	enabled := true // Default to true per schema
	if input.Enabled.IsSet() && input.Enabled.Value() != nil {
		enabled = *input.Enabled.Value()
	}

	serviceInput := scheduling.ScheduleInput{
		RoutingID: input.RoutingID,
		Days:      input.Days,
		StartTime: input.StartTime,
		EndTime:   input.EndTime,
		Timezone:  input.Timezone,
		Enabled:   enabled,
	}

	// Create schedule via service
	schedule, err := r.ScheduleService.CreateSchedule(ctx, serviceInput)
	if err != nil {
		r.log.Errorw("failed to create schedule",
			"error", err,
			"routingID", input.RoutingID)
		return nil, apperrors.Wrap(
			err,
			apperrors.CodeResourceLocked,
			apperrors.CategoryResource,
			"failed to create schedule",
		)
	}

	// Convert to GraphQL model
	result := convertRoutingScheduleToModel(schedule, r.ScheduleEvaluator)

	r.log.Infow("schedule created",
		"scheduleID", result.ID,
		"routingID", result.RoutingID,
		"enabled", result.Enabled)

	return result, nil
}

// UpdateSchedule updates an existing routing schedule.
func (r *mutationResolver) UpdateSchedule(ctx context.Context, routerID string, scheduleID string, input model.UpdateScheduleInput) (*model.RoutingSchedule, error) {
	r.log.Infow("UpdateSchedule mutation called",
		"routerID", routerID,
		"scheduleID", scheduleID)

	// Check authorization: user must be authenticated
	if r.authService == nil {
		return nil, apperrors.NewInternalError("authentication service not available", nil)
	}

	// Check if ScheduleService is available
	if r.ScheduleService == nil {
		return nil, apperrors.NewInternalError("schedule service not available", nil)
	}

	// Get existing schedule to merge with partial update
	existing, err := r.ScheduleService.GetSchedule(ctx, scheduleID)
	if err != nil {
		r.log.Errorw("failed to get existing schedule",
			"error", err,
			"scheduleID", scheduleID)
		return nil, apperrors.Wrap(
			err,
			apperrors.CodeResourceNotFound,
			apperrors.CategoryResource,
			"failed to get existing schedule",
		)
	}

	// Build service input with merged values
	serviceInput := scheduling.ScheduleInput{
		RoutingID: existing.RoutingID, // routing_id is immutable
		Days:      existing.Days,
		StartTime: existing.StartTime,
		EndTime:   existing.EndTime,
		Timezone:  existing.Timezone,
		Enabled:   existing.Enabled,
	}

	// Apply updates from input (Omittable fields)
	if input.Days.IsSet() {
		serviceInput.Days = input.Days.Value()
	}
	if input.StartTime.IsSet() && input.StartTime.Value() != nil {
		serviceInput.StartTime = *input.StartTime.Value()
	}
	if input.EndTime.IsSet() && input.EndTime.Value() != nil {
		serviceInput.EndTime = *input.EndTime.Value()
	}
	if input.Timezone.IsSet() && input.Timezone.Value() != nil {
		serviceInput.Timezone = *input.Timezone.Value()
	}
	if input.Enabled.IsSet() && input.Enabled.Value() != nil {
		serviceInput.Enabled = *input.Enabled.Value()
	}

	// Update schedule via service
	schedule, err := r.ScheduleService.UpdateSchedule(ctx, scheduleID, serviceInput)
	if err != nil {
		r.log.Errorw("failed to update schedule",
			"error", err,
			"scheduleID", scheduleID)
		return nil, apperrors.Wrap(
			err,
			apperrors.CodeResourceLocked,
			apperrors.CategoryResource,
			"failed to update schedule",
		)
	}

	// Convert to GraphQL model
	result := convertRoutingScheduleToModel(schedule, r.ScheduleEvaluator)

	r.log.Infow("schedule updated",
		"scheduleID", result.ID,
		"routingID", result.RoutingID,
		"enabled", result.Enabled)

	return result, nil
}

// DeleteSchedule deletes a routing schedule.
func (r *mutationResolver) DeleteSchedule(ctx context.Context, routerID string, scheduleID string) (bool, error) {
	r.log.Infow("DeleteSchedule mutation called",
		"routerID", routerID,
		"scheduleID", scheduleID)

	// Check authorization: user must be authenticated
	if r.authService == nil {
		return false, apperrors.NewInternalError("authentication service not available", nil)
	}

	// Check if ScheduleService is available
	if r.ScheduleService == nil {
		return false, apperrors.NewInternalError("schedule service not available", nil)
	}

	// Delete schedule via service
	if err := r.ScheduleService.DeleteSchedule(ctx, scheduleID); err != nil {
		r.log.Errorw("failed to delete schedule",
			"error", err,
			"scheduleID", scheduleID)
		return false, apperrors.Wrap(
			err,
			apperrors.CodeResourceLocked,
			apperrors.CategoryResource,
			"failed to delete schedule",
		)
	}

	r.log.Infow("schedule deleted",
		"scheduleID", scheduleID)

	return true, nil
}
