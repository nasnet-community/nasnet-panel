package resolver

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.44

import (
	"context"
	"fmt"

	"backend/ent"
	"backend/ent/router"
	"backend/graph"
	"backend/graph/model"
)

// CreateRouter is the resolver for the createRouter field.
func (r *mutationResolver) CreateRouter(ctx context.Context, input model.CreateRouterInput) (*model.CreateRouterPayload, error) {
	panic(fmt.Errorf("not implemented: CreateRouter - createRouter"))
}

// UpdateRouter is the resolver for the updateRouter field.
func (r *mutationResolver) UpdateRouter(ctx context.Context, id string, input model.UpdateRouterInput) (*model.UpdateRouterPayload, error) {
	panic(fmt.Errorf("not implemented: UpdateRouter - updateRouter"))
}

// DeleteRouter is the resolver for the deleteRouter field.
func (r *mutationResolver) DeleteRouter(ctx context.Context, id string) (*model.DeleteRouterPayload, error) {
	panic(fmt.Errorf("not implemented: DeleteRouter - deleteRouter"))
}

// TestRouterConnection is the resolver for the testRouterConnection field.
func (r *mutationResolver) TestRouterConnection(ctx context.Context, id string) (*model.TestConnectionPayload, error) {
	panic(fmt.Errorf("not implemented: TestRouterConnection - testRouterConnection"))
}

// ConnectRouter is the resolver for the connectRouter field.
// Per AC1: Given a valid router ID, when connectRouter(id) mutation is called,
// then the backend updates the active router context, verifies connectivity,
// and returns the updated router with status CONNECTED.
func (r *mutationResolver) ConnectRouter(ctx context.Context, id string) (*model.ConnectRouterPayload, error) {
	if r.RouterService == nil {
		return &model.ConnectRouterPayload{
			Errors: []*model.MutationError{{
				Code:    "SERVICE_UNAVAILABLE",
				Message: "Router service is not configured",
			}},
		}, nil
	}

	result, err := r.RouterService.Connect(ctx, id)
	if err != nil {
		return &model.ConnectRouterPayload{
			Errors: []*model.MutationError{{
				Code:    "INTERNAL_ERROR",
				Message: err.Error(),
			}},
		}, nil
	}

	if !result.Connected {
		return &model.ConnectRouterPayload{
			Router: entRouterToModel(result.Router),
			Errors: []*model.MutationError{{
				Code:    "CONNECTION_FAILED",
				Message: result.Error,
			}},
		}, nil
	}

	return &model.ConnectRouterPayload{
		Router: entRouterToModel(result.Router),
	}, nil
}

// DisconnectRouter is the resolver for the disconnectRouter field.
// Per AC: When disconnectRouter is called, the connection is closed
// and a RouterDisconnectedEvent is published.
func (r *mutationResolver) DisconnectRouter(ctx context.Context, id string) (*model.DisconnectRouterPayload, error) {
	if r.RouterService == nil {
		return &model.DisconnectRouterPayload{
			Errors: []*model.MutationError{{
				Code:    "SERVICE_UNAVAILABLE",
				Message: "Router service is not configured",
			}},
		}, nil
	}

	result, err := r.RouterService.Disconnect(ctx, id)
	if err != nil {
		return &model.DisconnectRouterPayload{
			Errors: []*model.MutationError{{
				Code:    "INTERNAL_ERROR",
				Message: err.Error(),
			}},
		}, nil
	}

	if !result.Disconnected {
		return &model.DisconnectRouterPayload{
			Errors: []*model.MutationError{{
				Code:    "DISCONNECT_FAILED",
				Message: result.Error,
			}},
		}, nil
	}

	routerEntity, _ := r.RouterService.GetActiveRouter(ctx, result.RouterID)
	if routerEntity == nil {
		return &model.DisconnectRouterPayload{}, nil
	}

	return &model.DisconnectRouterPayload{
		Router: entRouterToModel(routerEntity),
	}, nil
}

// Node is the resolver for the node field.
func (r *queryResolver) Node(ctx context.Context, id string) (model.Node, error) {
	panic(fmt.Errorf("not implemented: Node - node"))
}

// Health is the resolver for the health field.
func (r *queryResolver) Health(ctx context.Context) (*model.HealthStatus, error) {
	panic(fmt.Errorf("not implemented: Health - health"))
}

// Version is the resolver for the version field.
func (r *queryResolver) Version(ctx context.Context) (string, error) {
	panic(fmt.Errorf("not implemented: Version - version"))
}

// Router is the resolver for the router field.
func (r *queryResolver) Router(ctx context.Context, id string) (*model.Router, error) {
	panic(fmt.Errorf("not implemented: Router - router"))
}

// Routers is the resolver for the routers field.
func (r *queryResolver) Routers(ctx context.Context, status *model.ConnectionStatus, pagination *model.PaginationInput) (*model.RouterConnection, error) {
	panic(fmt.Errorf("not implemented: Routers - routers"))
}

// Interface is the resolver for the interface field.
func (r *queryResolver) Interface(ctx context.Context, routerID string, id string) (*model.Interface, error) {
	panic(fmt.Errorf("not implemented: Interface - interface"))
}

// Interfaces is the resolver for the interfaces field.
func (r *queryResolver) Interfaces(ctx context.Context, routerID string, typeArg *model.InterfaceType, pagination *model.PaginationInput) (*model.InterfaceConnection, error) {
	panic(fmt.Errorf("not implemented: Interfaces - interfaces"))
}

// Mutation returns graph.MutationResolver implementation.
func (r *Resolver) Mutation() graph.MutationResolver { return &mutationResolver{r} }

// Query returns graph.QueryResolver implementation.
func (r *Resolver) Query() graph.QueryResolver { return &queryResolver{r} }

// Subscription returns graph.SubscriptionResolver implementation.
func (r *Resolver) Subscription() graph.SubscriptionResolver { return &subscriptionResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type subscriptionResolver struct{ *Resolver }

// entRouterToModel converts an ent.Router entity to a GraphQL model.Router.
func entRouterToModel(r *ent.Router) *model.Router {
	if r == nil {
		return nil
	}

	var status model.ConnectionStatus
	switch r.Status {
	case router.StatusOnline:
		status = model.ConnectionStatusConnected
	case router.StatusOffline:
		status = model.ConnectionStatusDisconnected
	case router.StatusDegraded:
		status = model.ConnectionStatusError
	default:
		status = model.ConnectionStatusDisconnected
	}

	var platform model.RouterPlatform
	switch r.Platform {
	case router.PlatformMikrotik:
		platform = model.RouterPlatformMikrotik
	case router.PlatformOpenwrt:
		platform = model.RouterPlatformOpenwrt
	case router.PlatformVyos:
		platform = model.RouterPlatformVyos
	default:
		platform = model.RouterPlatformMikrotik
	}

	result := &model.Router{
		ID:        r.ID,
		Name:      r.Name,
		Host:      r.Host,
		Port:      r.Port,
		Status:    status,
		Platform:  platform,
		CreatedAt: r.CreatedAt,
		UpdatedAt: r.UpdatedAt,
	}

	if r.Version != "" {
		result.Version = &r.Version
	}
	if r.Model != "" {
		result.Model = &r.Model
	}
	if r.LastSeen != nil {
		result.LastConnected = r.LastSeen
	}

	return result
}

