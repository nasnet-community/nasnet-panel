package resolver


			// This file will be automatically regenerated based on the schema, any resolver implementations
			// will be copied through when generating and any unknown code will be moved to the end.
			// Code generated by github.com/99designs/gqlgen version v0.17.44

import (
"context"
"fmt"
"io"
"strconv"
"time"
"sync"
"errors"
"bytes"
gqlparser "github.com/vektah/gqlparser/v2"
"github.com/vektah/gqlparser/v2/ast"
"github.com/99designs/gqlgen/graphql"
"github.com/99designs/gqlgen/graphql/introspection"
"backend/graph/model"
"backend/graph")


















// CreateRouter is the resolver for the createRouter field.
	func (r *mutationResolver) CreateRouter(ctx context.Context, input model.CreateRouterInput) ( *model.CreateRouterPayload,  error){
		panic(fmt.Errorf("not implemented: CreateRouter - createRouter"))
	}

// UpdateRouter is the resolver for the updateRouter field.
	func (r *mutationResolver) UpdateRouter(ctx context.Context, id string, input model.UpdateRouterInput) ( *model.UpdateRouterPayload,  error){
		panic(fmt.Errorf("not implemented: UpdateRouter - updateRouter"))
	}

// DeleteRouter is the resolver for the deleteRouter field.
	func (r *mutationResolver) DeleteRouter(ctx context.Context, id string) ( *model.DeleteRouterPayload,  error){
		panic(fmt.Errorf("not implemented: DeleteRouter - deleteRouter"))
	}

// TestRouterConnection is the resolver for the testRouterConnection field.
	func (r *mutationResolver) TestRouterConnection(ctx context.Context, id string) ( *model.TestConnectionPayload,  error){
		panic(fmt.Errorf("not implemented: TestRouterConnection - testRouterConnection"))
	}

// ConnectRouter is the resolver for the connectRouter field.
	func (r *mutationResolver) ConnectRouter(ctx context.Context, id string) ( *model.ConnectRouterPayload,  error){
		panic(fmt.Errorf("not implemented: ConnectRouter - connectRouter"))
	}

// DisconnectRouter is the resolver for the disconnectRouter field.
	func (r *mutationResolver) DisconnectRouter(ctx context.Context, id string) ( *model.DisconnectRouterPayload,  error){
		panic(fmt.Errorf("not implemented: DisconnectRouter - disconnectRouter"))
	}

// RefreshCapabilities is the resolver for the refreshCapabilities mutation.
	func (r *mutationResolver) RefreshCapabilities(ctx context.Context, routerID string) ( *model.RefreshCapabilitiesPayload,  error){
		if r.CapabilityService == nil {
		return &model.RefreshCapabilitiesPayload{
			Errors: []*model.MutationError{{
				Code:    "SERVICE_UNAVAILABLE",
				Message: "Capability service not configured",
			}},
		}, nil
	}

	caps, err := r.CapabilityService.RefreshCapabilities(ctx, routerID, r.getRouterPort)
	if err != nil {
		return &model.RefreshCapabilitiesPayload{
			Errors: []*model.MutationError{{
				Code:    "REFRESH_FAILED",
				Message: err.Error(),
			}},
		}, nil
	}

	return &model.RefreshCapabilitiesPayload{
		Capabilities: toGraphQLCapabilities(caps),
	}, nil
	}

// UpdateInterface resolves the updateInterface mutation.
	func (r *mutationResolver) UpdateInterface(ctx context.Context, routerID string, interfaceID string, input model.UpdateInterfaceInput) ( *model.UpdateInterfacePayload,  error){
		// Convert GraphQL input to service input
	serviceInput := services.UpdateInterfaceInput{
		Enabled: input.Enabled,
		MTU:     input.Mtu,
		Comment: input.Comment,
	}

	// Call service
	result, err := r.InterfaceService.UpdateInterface(ctx, routerID, interfaceID, serviceInput)
	if err != nil {
		return &model.UpdateInterfacePayload{
			Interface: nil,
			Errors: []*model.MutationError{
				{
					Code:    "UPDATE_FAILED",
					Message: err.Error(),
				},
			},
		}, nil
	}

	return &model.UpdateInterfacePayload{
		Interface: mapInterfaceDataToGraphQL(result),
		Errors:    []*model.MutationError{},
	}, nil
	}

// EnableInterface resolves the enableInterface mutation.
	func (r *mutationResolver) EnableInterface(ctx context.Context, routerID string, interfaceID string) ( *model.UpdateInterfacePayload,  error){
		// Call service
	result, err := r.InterfaceService.EnableInterface(ctx, routerID, interfaceID)
	if err != nil {
		return &model.UpdateInterfacePayload{
			Interface: nil,
			Errors: []*model.MutationError{
				{
					Code:    "ENABLE_FAILED",
					Message: err.Error(),
				},
			},
		}, nil
	}

	return &model.UpdateInterfacePayload{
		Interface: mapInterfaceDataToGraphQL(result),
		Errors:    []*model.MutationError{},
	}, nil
	}

// DisableInterface resolves the disableInterface mutation.
	func (r *mutationResolver) DisableInterface(ctx context.Context, routerID string, interfaceID string) ( *model.UpdateInterfacePayload,  error){
		// Call service
	result, err := r.InterfaceService.DisableInterface(ctx, routerID, interfaceID)
	if err != nil {
		return &model.UpdateInterfacePayload{
			Interface: nil,
			Errors: []*model.MutationError{
				{
					Code:    "DISABLE_FAILED",
					Message: err.Error(),
				},
			},
		}, nil
	}

	return &model.UpdateInterfacePayload{
		Interface: mapInterfaceDataToGraphQL(result),
		Errors:    []*model.MutationError{},
	}, nil
	}

// BatchInterfaceOperation resolves the batchInterfaceOperation mutation.
	func (r *mutationResolver) BatchInterfaceOperation(ctx context.Context, routerID string, input model.BatchInterfaceInput) ( *model.BatchInterfacePayload,  error){
		// Convert GraphQL action to service action
	var serviceAction services.BatchAction
	switch input.Action {
	case model.BatchInterfaceActionEnable:
		serviceAction = services.BatchActionEnable
	case model.BatchInterfaceActionDisable:
		serviceAction = services.BatchActionDisable
	case model.BatchInterfaceActionUpdate:
		serviceAction = services.BatchActionUpdate
	default:
		return &model.BatchInterfacePayload{
			Succeeded: []*model.Interface{},
			Failed:    []*model.InterfaceOperationError{},
			Errors: []*model.MutationError{
				{
					Code:    "INVALID_ACTION",
					Message: fmt.Sprintf("unknown batch action: %s", input.Action),
				},
			},
		}, nil
	}

	// Convert input if provided (for UPDATE action)
	var serviceInput *services.UpdateInterfaceInput
	if input.Input.IsSet() && input.Input.Value() != nil {
		updateInput := input.Input.Value()
		var enabled *bool
		if updateInput.Enabled.IsSet() {
			enabled = updateInput.Enabled.Value()
		}
		var mtu *int
		if updateInput.Mtu.IsSet() {
			mtu = updateInput.Mtu.Value()
		}
		var comment *string
		if updateInput.Comment.IsSet() {
			comment = updateInput.Comment.Value()
		}

		serviceInput = &services.UpdateInterfaceInput{
			Enabled: enabled,
			MTU:     mtu,
			Comment: comment,
		}
	}

	// Call service
	succeeded, failed, err := r.InterfaceService.BatchOperation(
		ctx,
		routerID,
		input.InterfaceIds,
		serviceAction,
		serviceInput,
	)

	// Handle general errors
	if err != nil {
		return &model.BatchInterfacePayload{
			Succeeded: []*model.Interface{},
			Failed:    []*model.InterfaceOperationError{},
			Errors: []*model.MutationError{
				{
					Code:    "BATCH_OPERATION_FAILED",
					Message: err.Error(),
				},
			},
		}, nil
	}

	// Convert results to GraphQL models
	succeededInterfaces := make([]*model.Interface, len(succeeded))
	for i, iface := range succeeded {
		succeededInterfaces[i] = mapInterfaceDataToGraphQL(iface)
	}

	failedOperations := make([]*model.InterfaceOperationError, len(failed))
	for i, opErr := range failed {
		failedOperations[i] = &model.InterfaceOperationError{
			InterfaceID:   opErr.InterfaceID,
			InterfaceName: opErr.InterfaceName,
			Error:         opErr.Error,
		}
	}

	return &model.BatchInterfacePayload{
		Succeeded: succeededInterfaces,
		Failed:    failedOperations,
		Errors:    []*model.MutationError{},
	}, nil
	}

// Node is the resolver for the node field.
	func (r *queryResolver) Node(ctx context.Context, id string) ( model.Node,  error){
		panic(fmt.Errorf("not implemented: Node - node"))
	}

// Health is the resolver for the health field.
	func (r *queryResolver) Health(ctx context.Context) ( *model.HealthStatus,  error){
		panic(fmt.Errorf("not implemented: Health - health"))
	}

// Version is the resolver for the version field.
	func (r *queryResolver) Version(ctx context.Context) ( string,  error){
		panic(fmt.Errorf("not implemented: Version - version"))
	}

// Device returns the device query resolver.
This resolver is the entry point for fetching a device by ID.
	func (r *queryResolver) Device(ctx context.Context, id string) ( *model.Device,  error){
		// For now, simply return a Device with the given ID.
	// The actual device validation and existence check can be added when
	// the device entity/repository is implemented.
	return &model.Device{
		ID: id,
	}, nil
	}

// Router is the resolver for the router field.
	func (r *queryResolver) Router(ctx context.Context, id string) ( *model.Router,  error){
		panic(fmt.Errorf("not implemented: Router - router"))
	}

// Routers is the resolver for the routers field.
	func (r *queryResolver) Routers(ctx context.Context, status *model.ConnectionStatus, pagination *model.PaginationInput) ( *model.RouterConnection,  error){
		panic(fmt.Errorf("not implemented: Routers - routers"))
	}

// Interface resolves the interface query for a single interface by ID.
	func (r *queryResolver) Interface(ctx context.Context, routerID string, id string) ( *model.Interface,  error){
		// Fetch interface data from service
	interfaceData, err := r.InterfaceService.GetInterface(ctx, routerID, id)
	if err != nil {
		return nil, fmt.Errorf("failed to get interface: %w", err)
	}

	// Convert to GraphQL model
	return mapInterfaceDataToGraphQL(interfaceData), nil
	}

// Interfaces resolves the interfaces query with optional filtering and pagination.
	func (r *queryResolver) Interfaces(ctx context.Context, routerID string, typeArg *model.InterfaceType, pagination *model.PaginationInput) ( *model.InterfaceConnection,  error){
		// Convert GraphQL type to service type
	var serviceType *string
	if interfaceType != nil {
		typeStr := string(*interfaceType)
		serviceType = &typeStr
	}

	// Fetch interfaces from service
	interfaces, err := r.InterfaceService.ListInterfaces(ctx, routerID, serviceType)
	if err != nil {
		return nil, fmt.Errorf("failed to list interfaces: %w", err)
	}

	// Apply pagination (simple offset-based for now)
	start := 0
	limit := len(interfaces)
	if pagination != nil && pagination.First != nil {
		limit = *pagination.First
		if pagination.After != nil {
			// After cursor is base64-encoded offset
			// For simplicity, we'll skip cursor-based pagination for now
		}
	}

	if start >= len(interfaces) {
		start = len(interfaces)
	}
	end := start + limit
	if end > len(interfaces) {
		end = len(interfaces)
	}

	paginatedInterfaces := interfaces[start:end]

	// Build edges
	edges := make([]*model.InterfaceEdge, len(paginatedInterfaces))
	for i, iface := range paginatedInterfaces {
		edges[i] = &model.InterfaceEdge{
			Node:   mapInterfaceDataToGraphQL(iface),
			Cursor: fmt.Sprintf("%d", start+i), // Simple offset-based cursor
		}
	}

	// Build page info
	pageInfo := &model.PageInfo{
		HasNextPage:     end < len(interfaces),
		HasPreviousPage: start > 0,
	}
	if len(edges) > 0 {
		pageInfo.StartCursor = &edges[0].Cursor
		pageInfo.EndCursor = &edges[len(edges)-1].Cursor
	}

	totalCount := len(interfaces)

	return &model.InterfaceConnection{
		Edges:      edges,
		PageInfo:   pageInfo,
		TotalCount: &totalCount,
	}, nil
	}

// RouterCapabilities is the resolver for the routerCapabilities query.
	func (r *queryResolver) RouterCapabilities(ctx context.Context, routerID string) ( *model.RouterCapabilities,  error){
		if r.CapabilityService == nil {
		return nil, nil // Service not configured
	}

	caps, err := r.CapabilityService.GetCapabilities(ctx, routerID, r.getRouterPort)
	if err != nil {
		return nil, err
	}

	return toGraphQLCapabilities(caps), nil
	}

// IsFeatureSupported is the resolver for the isFeatureSupported query.
	func (r *queryResolver) IsFeatureSupported(ctx context.Context, routerID string, featureID string) ( *model.FeatureSupport,  error){
		if r.CapabilityService == nil {
		return &model.FeatureSupport{
			FeatureID: featureID,
			Supported: false,
			Reason:    strPtr("Capability service not configured"),
		}, nil
	}

	caps, err := r.CapabilityService.GetCapabilities(ctx, routerID, r.getRouterPort)
	if err != nil {
		return &model.FeatureSupport{
			FeatureID: featureID,
			Supported: false,
			Reason:    strPtr("Failed to get router capabilities: " + err.Error()),
		}, nil
	}

	integration := r.getVersionIntegration()
	isCHR := detectCHR(caps)
	support := integration.GetFeatureSupport(caps, featureID, isCHR)

	return toGraphQLFeatureSupport(support, featureID), nil
	}

// SupportedFeatures is the resolver for the supportedFeatures query.
	func (r *queryResolver) SupportedFeatures(ctx context.Context, routerID string) ( []*model.FeatureSupport,  error){
		if r.CapabilityService == nil {
		return []*model.FeatureSupport{}, nil
	}

	caps, err := r.CapabilityService.GetCapabilities(ctx, routerID, r.getRouterPort)
	if err != nil {
		return nil, err
	}

	integration := r.getVersionIntegration()
	isCHR := detectCHR(caps)
	supported := integration.GetSupportedFeatures(caps, isCHR)

	result := make([]*model.FeatureSupport, 0, len(supported))
	for _, s := range supported {
		result = append(result, toGraphQLFeatureSupport(&s, s.FeatureID))
	}

	return result, nil
	}

// UnsupportedFeatures is the resolver for the unsupportedFeatures query.
	func (r *queryResolver) UnsupportedFeatures(ctx context.Context, routerID string) ( []*model.FeatureSupport,  error){
		if r.CapabilityService == nil {
		return []*model.FeatureSupport{}, nil
	}

	caps, err := r.CapabilityService.GetCapabilities(ctx, routerID, r.getRouterPort)
	if err != nil {
		return nil, err
	}

	integration := r.getVersionIntegration()
	isCHR := detectCHR(caps)
	unsupported := integration.GetUnsupportedFeatures(caps, isCHR)

	result := make([]*model.FeatureSupport, 0, len(unsupported))
	for _, u := range unsupported {
		result = append(result, toGraphQLFeatureSupport(&u, u.FeatureID))
	}

	return result, nil
	}

// CompatibilityMatrix is the resolver for the compatibilityMatrix query.
	func (r *queryResolver) CompatibilityMatrix(ctx context.Context) ( []*model.FeatureCompatibilityInfo,  error){
		svc := compatibility.DefaultService
	if err := svc.LoadMatrix(); err != nil {
		return nil, err
	}

	matrix := svc.GetMatrix()
	if matrix == nil {
		return []*model.FeatureCompatibilityInfo{}, nil
	}

	result := make([]*model.FeatureCompatibilityInfo, 0, len(matrix.Features))
	for id, fc := range matrix.Features {
		info := &model.FeatureCompatibilityInfo{
			FeatureID:        id,
			Name:             fc.Name,
			MinVersion:       fc.VersionRange.Min,
			RequiredPackages: fc.RequiredPackages,
			DependsOn:        fc.DependsOn,
		}

		if fc.VersionRange.Max != "" {
			info.MaxVersion = strPtr(fc.VersionRange.Max)
		}

		if fc.VersionRangeCHR != nil && fc.VersionRangeCHR.Min != "" {
			info.MinVersionChr = strPtr(fc.VersionRangeCHR.Min)
		}

		if fc.UpgradeURL != "" {
			info.UpgradeURL = strPtr(fc.UpgradeURL)
		}

		// Ensure slices are not nil for GraphQL
		if info.RequiredPackages == nil {
			info.RequiredPackages = []string{}
		}
		if info.DependsOn == nil {
			info.DependsOn = []string{}
		}

		result = append(result, info)
	}

	return result, nil
	}

// UpgradeRecommendation is the resolver for the upgradeRecommendation query.
	func (r *queryResolver) UpgradeRecommendation(ctx context.Context, routerID string, featureID string) ( *model.UpgradeRecommendation,  error){
		if r.CapabilityService == nil {
		return nil, nil
	}

	caps, err := r.CapabilityService.GetCapabilities(ctx, routerID, r.getRouterPort)
	if err != nil {
		return nil, err
	}

	// Get version requirement for the feature
	svc := compatibility.DefaultService
	if err := svc.LoadMatrix(); err != nil {
		return nil, err
	}

	isCHR := detectCHR(caps)
	requiredVersion := svc.GetVersionRequirement(featureID, isCHR)

	// If feature is already supported, no upgrade needed
	integration := r.getVersionIntegration()
	support := integration.GetFeatureSupport(caps, featureID, isCHR)
	if support != nil && support.Supported {
		return nil, nil
	}

	// Build upgrade recommendation
	currentVersion := caps.Software.Version.String()
	return &model.UpgradeRecommendation{
		FeatureID:       featureID,
		FeatureName:     getFeatureName(featureID),
		CurrentVersion:  currentVersion,
		RequiredVersion: requiredVersion,
		IsMajorUpgrade:  isMajorUpgrade(currentVersion, requiredVersion),
		Priority:        model.UpgradePriorityMedium,
	}, nil
	}

// UpgradeRecommendations is the resolver for the upgradeRecommendations query.
	func (r *queryResolver) UpgradeRecommendations(ctx context.Context, routerID string) ( []*model.UpgradeRecommendation,  error){
		if r.CapabilityService == nil {
		return []*model.UpgradeRecommendation{}, nil
	}

	caps, err := r.CapabilityService.GetCapabilities(ctx, routerID, r.getRouterPort)
	if err != nil {
		return nil, err
	}

	// Get all unsupported features and generate recommendations for each
	integration := r.getVersionIntegration()
	isCHR := detectCHR(caps)
	unsupported := integration.GetUnsupportedFeatures(caps, isCHR)

	svc := compatibility.DefaultService
	_ = svc.LoadMatrix()

	currentVersion := caps.Software.Version.String()
	recommendations := make([]*model.UpgradeRecommendation, 0)
	for _, u := range unsupported {
		requiredVersion := svc.GetVersionRequirement(u.FeatureID, isCHR)
		if requiredVersion != "" {
			recommendations = append(recommendations, &model.UpgradeRecommendation{
				FeatureID:       u.FeatureID,
				FeatureName:     getFeatureName(u.FeatureID),
				CurrentVersion:  currentVersion,
				RequiredVersion: requiredVersion,
				IsMajorUpgrade:  isMajorUpgrade(currentVersion, requiredVersion),
				Priority:        model.UpgradePriorityMedium,
			})
		}
	}

	return recommendations, nil
	}

// RouterStatusChanged subscribes to router status change events.
If routerID is provided, only events for that router are streamed.
If routerID is nil, all router status changes are streamed.
	func (r *subscriptionResolver) RouterStatusChanged(ctx context.Context, routerID *string) ( <-chan *model.RouterStatusEvent,  error){
		// Create a buffered channel for events
	ch := make(chan *model.RouterStatusEvent, 10)

	// Subscribe to the event bus
	if r.EventBus != nil {
		handler := func(eventCtx context.Context, event events.Event) error {
			// Type assert to RouterStatusChangedEvent
			statusEvent, ok := event.(*events.RouterStatusChangedEvent)
			if !ok {
				return nil // Skip non-matching events
			}

			// Filter by routerID if specified
			if routerID != nil && statusEvent.RouterID != *routerID {
				return nil
			}

			// Convert to GraphQL model
			graphQLEvent := &model.RouterStatusEvent{
				Router: &model.Router{
					ID: statusEvent.RouterID,
					// Note: Full router data should be loaded from DB in production
					Status: convertRouterStatus(statusEvent.Status),
				},
				PreviousStatus: convertRouterStatus(statusEvent.PreviousStatus),
				NewStatus:      convertRouterStatus(statusEvent.Status),
				Timestamp:      statusEvent.GetTimestamp(),
			}

			// Non-blocking send with context check
			select {
			case <-ctx.Done():
				return ctx.Err()
			case ch <- graphQLEvent:
				return nil
			default:
				// Channel full, log warning but don't block
				log.Printf("[SUBSCRIPTION] RouterStatusChanged channel full, dropping event for router %s", statusEvent.RouterID)
				return nil
			}
		}

		if err := r.EventBus.Subscribe(events.EventTypeRouterStatusChanged, handler); err != nil {
			close(ch)
			return nil, err
		}
	}

	// Clean up when context is cancelled
	go func() {
		<-ctx.Done()
		close(ch)
	}()

	return ch, nil
	}

// ResourceMetrics subscribes to real-time resource metrics updates.
Emits new metrics every 2 seconds per NAS-5.2 AC 5.2.2.
	func (r *subscriptionResolver) ResourceMetrics(ctx context.Context, deviceID string) ( <-chan *model.ResourceMetrics,  error){
		ch := make(chan *model.ResourceMetrics)

	// Start a goroutine that emits metrics every 2 seconds
	go func() {
		defer close(ch)

		// Create a ticker for 2-second intervals (AC 5.2.2)
		ticker := time.NewTicker(2 * time.Second)
		defer ticker.Stop()

		// Send initial metrics immediately
		metrics, err := r.fetchResourceMetrics(deviceID)
		if err == nil {
			select {
			case ch <- metrics:
			case <-ctx.Done():
				return
			}
		}

		// Continue sending metrics every 2 seconds
		for {
			select {
			case <-ctx.Done():
				// Client disconnected
				return
			case <-ticker.C:
				// Fetch and send new metrics
				metrics, err := r.fetchResourceMetrics(deviceID)
				if err != nil {
					// Log error but continue (silent fail per subscription pattern)
					continue
				}

				// Send metrics to channel (non-blocking)
				select {
				case ch <- metrics:
				case <-ctx.Done():
					return
				}
			}
		}
	}()

	return ch, nil
	}

// InterfaceTraffic subscribes to interface traffic updates.
This is a polling subscription that fetches traffic data at regular intervals.
	func (r *subscriptionResolver) InterfaceTraffic(ctx context.Context, routerID string, interfaceID *string) ( <-chan *model.InterfaceTrafficEvent,  error){
		ch := make(chan *model.InterfaceTrafficEvent, 5)

	// Default polling interval from @realtime directive (1000ms)
	interval := 1 * time.Second

	go func() {
		defer close(ch)

		ticker := time.NewTicker(interval)
		defer ticker.Stop()

		for {
			select {
			case <-ctx.Done():
				return
			case <-ticker.C:
				// In production, this would fetch real traffic data from the router
				// For now, we emit placeholder events
				event := &model.InterfaceTrafficEvent{
					InterfaceID:   "placeholder",
					InterfaceName: "eth0",
					TxRate:        "0",
					RxRate:        "0",
					TxTotal:       "0",
					RxTotal:       "0",
					Timestamp:     time.Now(),
				}

				if interfaceID != nil {
					event.InterfaceID = *interfaceID
				}

				select {
				case ch <- event:
				case <-ctx.Done():
					return
				}
			}
		}
	}()

	return ch, nil
	}

// ResourceUpdated subscribes to resource update events (create, update, delete).
If resourceID is provided, only events for that specific resource are streamed.
If resourceID is nil, all resource updates are streamed.
	func (r *subscriptionResolver) ResourceUpdated(ctx context.Context, resourceID *string) ( <-chan *model.ResourceUpdatedEvent,  error){
		ch := make(chan *model.ResourceUpdatedEvent, 20)

	if r.EventBus != nil {
		// Handler for all resource event types
		handler := func(eventCtx context.Context, event events.Event) error {
			resourceEvent, ok := event.(*events.ResourceUpdatedEvent)
			if !ok {
				return nil
			}

			// Filter by resourceID if specified
			if resourceID != nil && resourceEvent.ResourceUUID.String() != *resourceID {
				return nil
			}

			// Convert to GraphQL model
			graphQLEvent := &model.ResourceUpdatedEvent{
				ResourceID:    resourceEvent.ResourceUUID.String(),
				ResourceType:  resourceEvent.ResourceType,
				RouterID:      resourceEvent.RouterID,
				Version:       resourceEvent.NewVersion,
				ChangedFields: resourceEvent.ChangedFields,
				ChangeType:    convertChangeType(resourceEvent.ChangeType),
				Timestamp:     resourceEvent.GetTimestamp(),
			}

			select {
			case <-ctx.Done():
				return ctx.Err()
			case ch <- graphQLEvent:
				return nil
			default:
				log.Printf("[SUBSCRIPTION] ResourceUpdated channel full, dropping event for resource %s", resourceEvent.ResourceUUID)
				return nil
			}
		}

		// Subscribe to all resource event types
		for _, eventType := range []string{
			events.EventTypeResourceCreated,
			events.EventTypeResourceUpdated,
			events.EventTypeResourceDeleted,
		} {
			if err := r.EventBus.Subscribe(eventType, handler); err != nil {
				close(ch)
				return nil, err
			}
		}
	}

	go func() {
		<-ctx.Done()
		close(ch)
	}()

	return ch, nil
	}

// ConfigApplyProgress subscribes to configuration apply progress events.
This streams real-time progress updates for a specific configuration apply operation.
	func (r *subscriptionResolver) ConfigApplyProgress(ctx context.Context, operationID string) ( <-chan *model.ConfigProgress,  error){
		ch := make(chan *model.ConfigProgress, 10)

	if r.EventBus != nil {
		handler := func(eventCtx context.Context, event events.Event) error {
			progressEvent, ok := event.(*events.ConfigApplyProgressEvent)
			if !ok {
				return nil
			}

			// Filter by operationID
			if progressEvent.OperationID != operationID {
				return nil
			}

			// Convert to GraphQL model
			graphQLEvent := &model.ConfigProgress{
				OperationID: progressEvent.OperationID,
				Status:      convertConfigApplyStatus(progressEvent.Stage),
				Percentage:  progressEvent.Progress,
				Message:     progressEvent.Message,
				CurrentStep: &progressEvent.ResourcesApplied,
				TotalSteps:  &progressEvent.ResourcesTotal,
				Timestamp:   progressEvent.GetTimestamp(),
			}

			select {
			case <-ctx.Done():
				return ctx.Err()
			case ch <- graphQLEvent:
				return nil
			default:
				log.Printf("[SUBSCRIPTION] ConfigApplyProgress channel full, dropping event for operation %s", operationID)
				return nil
			}
		}

		if err := r.EventBus.Subscribe(events.EventTypeConfigApplyProgress, handler); err != nil {
			close(ch)
			return nil, err
		}
	}

	go func() {
		<-ctx.Done()
		close(ch)
	}()

	return ch, nil
	}

// InterfaceStatusChanged subscribes to interface status change events.
If routerID is provided, only events for that router are streamed.
If interfaceID is provided, only events for that specific interface are streamed.
	func (r *subscriptionResolver) InterfaceStatusChanged(ctx context.Context, routerID string, interfaceID *string) ( <-chan *model.InterfaceStatusEvent,  error){
		// Create a buffered channel for events
	ch := make(chan *model.InterfaceStatusEvent, 10)

	// Subscribe to the event bus
	if r.EventBus != nil {
		handler := func(eventCtx context.Context, event events.Event) error {
			// Type assert to InterfaceStatusChangedEvent
			statusEvent, ok := event.(*events.InterfaceStatusChangedEvent)
			if !ok {
				return nil // Skip non-matching events
			}

			// Filter by routerID
			if statusEvent.RouterID != routerID {
				return nil
			}

			// Filter by interfaceID if specified
			if interfaceID != nil && statusEvent.InterfaceID != *interfaceID {
				return nil
			}

			// Convert to GraphQL model
			graphQLEvent := &model.InterfaceStatusEvent{
				InterfaceID:    statusEvent.InterfaceID,
				InterfaceName:  statusEvent.InterfaceName,
				Status:         mapInterfaceStatusToGraphQL(statusEvent.Status),
				PreviousStatus: mapInterfaceStatusToGraphQL(statusEvent.PreviousStatus),
				Timestamp:      statusEvent.GetTimestamp(),
			}

			// Non-blocking send with context check
			select {
			case <-ctx.Done():
				return ctx.Err()
			case ch <- graphQLEvent:
				return nil
			default:
				// Channel full, log warning but don't block
				log.Printf("[SUBSCRIPTION] InterfaceStatusChanged channel full, dropping event for interface %s", statusEvent.InterfaceID)
				return nil
			}
		}

		if err := r.EventBus.Subscribe(events.EventTypeInterfaceStatusChanged, handler); err != nil {
			close(ch)
			return nil, err
		}
	}

	// Clean up when context is cancelled
	go func() {
		<-ctx.Done()
		close(ch)
	}()

	return ch, nil
	}



// Mutation returns graph.MutationResolver implementation.
	func (r *Resolver) Mutation() graph.MutationResolver { return &mutationResolver{r} }
// Query returns graph.QueryResolver implementation.
	func (r *Resolver) Query() graph.QueryResolver { return &queryResolver{r} }
// Subscription returns graph.SubscriptionResolver implementation.
	func (r *Resolver) Subscription() graph.SubscriptionResolver { return &subscriptionResolver{r} }


type mutationResolver struct { *Resolver }
type queryResolver struct { *Resolver }
type subscriptionResolver struct { *Resolver }



    // !!! WARNING !!!
    // The code below was going to be deleted when updating resolvers. It has been copied here so you have
    // one last chance to move it out of harms way if you want. There are two reasons this happens:
	//  - When renaming or deleting a resolver the old code will be put in here. You can safely delete
	//    it when you're done.
	//  - You have helper methods in this file. Move them out to keep these resolver files clean.
	func (r *mutationResolver) RefreshCapabilities(ctx context.Context, routerID string) ( *model.RefreshCapabilitiesPayload,  error){
		if r.CapabilityService == nil {
		return &model.RefreshCapabilitiesPayload{
			Errors: []*model.MutationError{{
				Code:    "SERVICE_UNAVAILABLE",
				Message: "Capability service not configured",
			}},
		}, nil
	}

	caps, err := r.CapabilityService.RefreshCapabilities(ctx, routerID, r.getRouterPort)
	if err != nil {
		return &model.RefreshCapabilitiesPayload{
			Errors: []*model.MutationError{{
				Code:    "REFRESH_FAILED",
				Message: err.Error(),
			}},
		}, nil
	}

	return &model.RefreshCapabilitiesPayload{
		Capabilities: toGraphQLCapabilities(caps),
	}, nil
	}
func (r *mutationResolver) UpdateInterface(ctx context.Context, routerID string, interfaceID string, input model.UpdateInterfaceInput) ( *model.UpdateInterfacePayload,  error){
		// Convert GraphQL input to service input
	serviceInput := services.UpdateInterfaceInput{
		Enabled: input.Enabled,
		MTU:     input.Mtu,
		Comment: input.Comment,
	}

	// Call service
	result, err := r.InterfaceService.UpdateInterface(ctx, routerID, interfaceID, serviceInput)
	if err != nil {
		return &model.UpdateInterfacePayload{
			Interface: nil,
			Errors: []*model.MutationError{
				{
					Code:    "UPDATE_FAILED",
					Message: err.Error(),
				},
			},
		}, nil
	}

	return &model.UpdateInterfacePayload{
		Interface: mapInterfaceDataToGraphQL(result),
		Errors:    []*model.MutationError{},
	}, nil
	}
func (r *mutationResolver) EnableInterface(ctx context.Context, routerID string, interfaceID string) ( *model.UpdateInterfacePayload,  error){
		// Call service
	result, err := r.InterfaceService.EnableInterface(ctx, routerID, interfaceID)
	if err != nil {
		return &model.UpdateInterfacePayload{
			Interface: nil,
			Errors: []*model.MutationError{
				{
					Code:    "ENABLE_FAILED",
					Message: err.Error(),
				},
			},
		}, nil
	}

	return &model.UpdateInterfacePayload{
		Interface: mapInterfaceDataToGraphQL(result),
		Errors:    []*model.MutationError{},
	}, nil
	}
func (r *mutationResolver) DisableInterface(ctx context.Context, routerID string, interfaceID string) ( *model.UpdateInterfacePayload,  error){
		// Call service
	result, err := r.InterfaceService.DisableInterface(ctx, routerID, interfaceID)
	if err != nil {
		return &model.UpdateInterfacePayload{
			Interface: nil,
			Errors: []*model.MutationError{
				{
					Code:    "DISABLE_FAILED",
					Message: err.Error(),
				},
			},
		}, nil
	}

	return &model.UpdateInterfacePayload{
		Interface: mapInterfaceDataToGraphQL(result),
		Errors:    []*model.MutationError{},
	}, nil
	}
func (r *mutationResolver) BatchInterfaceOperation(ctx context.Context, routerID string, input model.BatchInterfaceInput) ( *model.BatchInterfacePayload,  error){
		// Convert GraphQL action to service action
	var serviceAction services.BatchAction
	switch input.Action {
	case model.BatchInterfaceActionEnable:
		serviceAction = services.BatchActionEnable
	case model.BatchInterfaceActionDisable:
		serviceAction = services.BatchActionDisable
	case model.BatchInterfaceActionUpdate:
		serviceAction = services.BatchActionUpdate
	default:
		return &model.BatchInterfacePayload{
			Succeeded: []*model.Interface{},
			Failed:    []*model.InterfaceOperationError{},
			Errors: []*model.MutationError{
				{
					Code:    "INVALID_ACTION",
					Message: fmt.Sprintf("unknown batch action: %s", input.Action),
				},
			},
		}, nil
	}

	// Convert input if provided (for UPDATE action)
	var serviceInput *services.UpdateInterfaceInput
	if input.Input.IsSet() && input.Input.Value() != nil {
		updateInput := input.Input.Value()
		var enabled *bool
		if updateInput.Enabled.IsSet() {
			enabled = updateInput.Enabled.Value()
		}
		var mtu *int
		if updateInput.Mtu.IsSet() {
			mtu = updateInput.Mtu.Value()
		}
		var comment *string
		if updateInput.Comment.IsSet() {
			comment = updateInput.Comment.Value()
		}

		serviceInput = &services.UpdateInterfaceInput{
			Enabled: enabled,
			MTU:     mtu,
			Comment: comment,
		}
	}

	// Call service
	succeeded, failed, err := r.InterfaceService.BatchOperation(
		ctx,
		routerID,
		input.InterfaceIds,
		serviceAction,
		serviceInput,
	)

	// Handle general errors
	if err != nil {
		return &model.BatchInterfacePayload{
			Succeeded: []*model.Interface{},
			Failed:    []*model.InterfaceOperationError{},
			Errors: []*model.MutationError{
				{
					Code:    "BATCH_OPERATION_FAILED",
					Message: err.Error(),
				},
			},
		}, nil
	}

	// Convert results to GraphQL models
	succeededInterfaces := make([]*model.Interface, len(succeeded))
	for i, iface := range succeeded {
		succeededInterfaces[i] = mapInterfaceDataToGraphQL(iface)
	}

	failedOperations := make([]*model.InterfaceOperationError, len(failed))
	for i, opErr := range failed {
		failedOperations[i] = &model.InterfaceOperationError{
			InterfaceID:   opErr.InterfaceID,
			InterfaceName: opErr.InterfaceName,
			Error:         opErr.Error,
		}
	}

	return &model.BatchInterfacePayload{
		Succeeded: succeededInterfaces,
		Failed:    failedOperations,
		Errors:    []*model.MutationError{},
	}, nil
	}
This resolver is the entry point for fetching a device by ID.
	func (r *queryResolver) Device(ctx context.Context, id string) ( *model.Device,  error){
		// For now, simply return a Device with the given ID.
	// The actual device validation and existence check can be added when
	// the device entity/repository is implemented.
	return &model.Device{
		ID: id,
	}, nil
	}

// Router is the resolver for the router field.
	func (r *queryResolver) Router(ctx context.Context, id string) ( *model.Router,  error){
		panic(fmt.Errorf("not implemented: Router - router"))
	}

// Routers is the resolver for the routers field.
	func (r *queryResolver) Routers(ctx context.Context, status *model.ConnectionStatus, pagination *model.PaginationInput) ( *model.RouterConnection,  error){
		panic(fmt.Errorf("not implemented: Routers - routers"))
	}

// Interface resolves the interface query for a single interface by ID.
	func (r *queryResolver) Interface(ctx context.Context, routerID string, id string) ( *model.Interface,  error){
		// Fetch interface data from service
	interfaceData, err := r.InterfaceService.GetInterface(ctx, routerID, id)
	if err != nil {
		return nil, fmt.Errorf("failed to get interface: %w", err)
	}

	// Convert to GraphQL model
	return mapInterfaceDataToGraphQL(interfaceData), nil
	}

// Interfaces resolves the interfaces query with optional filtering and pagination.
	func (r *queryResolver) Interfaces(ctx context.Context, routerID string, typeArg *model.InterfaceType, pagination *model.PaginationInput) ( *model.InterfaceConnection,  error){
		// Convert GraphQL type to service type
	
var serviceType *string
if interfaceType != nil {
		typeStr := string(*interfaceType)
		serviceType = &typeStr
	}

	// Fetch interfaces from service
	interfaces, err := r.InterfaceService.ListInterfaces(ctx, routerID, serviceType)
	if err != nil {
		return nil, fmt.Errorf("failed to list interfaces: %w", err)
	}

	// Apply pagination (simple offset-based for now)
	start := 0
	limit := len(interfaces)
	if pagination != nil && pagination.First != nil {
		limit = *pagination.First
		if pagination.After != nil {
			// After cursor is base64-encoded offset
			// For simplicity, we'll skip cursor-based pagination for now
		}
	}

	if start >= len(interfaces) {
		start = len(interfaces)
	}
	end := start + limit
	if end > len(interfaces) {
		end = len(interfaces)
	}

	paginatedInterfaces := interfaces[start:end]

	// Build edges
	edges := make([]*model.InterfaceEdge, len(paginatedInterfaces))
	for i, iface := range paginatedInterfaces {
		edges[i] = &model.InterfaceEdge{
			Node:   mapInterfaceDataToGraphQL(iface),
			Cursor: fmt.Sprintf("%d", start+i), // Simple offset-based cursor
		}
	}

	// Build page info
	pageInfo := &model.PageInfo{
		HasNextPage:     end < len(interfaces),
		HasPreviousPage: start > 0,
	}
	if len(edges) > 0 {
		pageInfo.StartCursor = &edges[0].Cursor
		pageInfo.EndCursor = &edges[len(edges)-1].Cursor
	}

	totalCount := len(interfaces)

	return &model.InterfaceConnection{
		Edges:      edges,
		PageInfo:   pageInfo,
		TotalCount: &totalCount,
	}, nil
	}

// RouterCapabilities is the resolver for the routerCapabilities query.
	func (r *queryResolver) RouterCapabilities(ctx context.Context, routerID string) ( *model.RouterCapabilities,  error){
		if r.CapabilityService == nil {
		return nil, nil // Service not configured
	}

	caps, err := r.CapabilityService.GetCapabilities(ctx, routerID, r.getRouterPort)
	if err != nil {
		return nil, err
	}

	return toGraphQLCapabilities(caps), nil
	}

// IsFeatureSupported is the resolver for the isFeatureSupported query.
	func (r *queryResolver) IsFeatureSupported(ctx context.Context, routerID string, featureID string) ( *model.FeatureSupport,  error){
		if r.CapabilityService == nil {
		return &model.FeatureSupport{
			FeatureID: featureID,
			Supported: false,
			Reason:    strPtr("Capability service not configured"),
		}, nil
	}

	caps, err := r.CapabilityService.GetCapabilities(ctx, routerID, r.getRouterPort)
	if err != nil {
		return &model.FeatureSupport{
			FeatureID: featureID,
			Supported: false,
			Reason:    strPtr("Failed to get router capabilities: " + err.Error()),
		}, nil
	}

	integration := r.getVersionIntegration()
	isCHR := detectCHR(caps)
	support := integration.GetFeatureSupport(caps, featureID, isCHR)

	return toGraphQLFeatureSupport(support, featureID), nil
	}

// SupportedFeatures is the resolver for the supportedFeatures query.
	func (r *queryResolver) SupportedFeatures(ctx context.Context, routerID string) ( []*model.FeatureSupport,  error){
		if r.CapabilityService == nil {
		return []*model.FeatureSupport{}, nil
	}

	caps, err := r.CapabilityService.GetCapabilities(ctx, routerID, r.getRouterPort)
	if err != nil {
		return nil, err
	}

	integration := r.getVersionIntegration()
	isCHR := detectCHR(caps)
	supported := integration.GetSupportedFeatures(caps, isCHR)

	result := make([]*model.FeatureSupport, 0, len(supported))
	for _, s := range supported {
		result = append(result, toGraphQLFeatureSupport(&s, s.FeatureID))
	}

	return result, nil
	}

// UnsupportedFeatures is the resolver for the unsupportedFeatures query.
	func (r *queryResolver) UnsupportedFeatures(ctx context.Context, routerID string) ( []*model.FeatureSupport,  error){
		if r.CapabilityService == nil {
		return []*model.FeatureSupport{}, nil
	}

	caps, err := r.CapabilityService.GetCapabilities(ctx, routerID, r.getRouterPort)
	if err != nil {
		return nil, err
	}

	integration := r.getVersionIntegration()
	isCHR := detectCHR(caps)
	unsupported := integration.GetUnsupportedFeatures(caps, isCHR)

	result := make([]*model.FeatureSupport, 0, len(unsupported))
	for _, u := range unsupported {
		result = append(result, toGraphQLFeatureSupport(&u, u.FeatureID))
	}

	return result, nil
	}

// CompatibilityMatrix is the resolver for the compatibilityMatrix query.
	func (r *queryResolver) CompatibilityMatrix(ctx context.Context) ( []*model.FeatureCompatibilityInfo,  error){
		svc := compatibility.DefaultService
	if err := svc.LoadMatrix(); err != nil {
		return nil, err
	}

	matrix := svc.GetMatrix()
	if matrix == nil {
		return []*model.FeatureCompatibilityInfo{}, nil
	}

	result := make([]*model.FeatureCompatibilityInfo, 0, len(matrix.Features))
	for id, fc := range matrix.Features {
		info := &model.FeatureCompatibilityInfo{
			FeatureID:        id,
			Name:             fc.Name,
			MinVersion:       fc.VersionRange.Min,
			RequiredPackages: fc.RequiredPackages,
			DependsOn:        fc.DependsOn,
		}

		if fc.VersionRange.Max != "" {
			info.MaxVersion = strPtr(fc.VersionRange.Max)
		}

		if fc.VersionRangeCHR != nil && fc.VersionRangeCHR.Min != "" {
			info.MinVersionChr = strPtr(fc.VersionRangeCHR.Min)
		}

		if fc.UpgradeURL != "" {
			info.UpgradeURL = strPtr(fc.UpgradeURL)
		}

		// Ensure slices are not nil for GraphQL
		if info.RequiredPackages == nil {
			info.RequiredPackages = []string{}
		}
		if info.DependsOn == nil {
			info.DependsOn = []string{}
		}

		result = append(result, info)
	}

	return result, nil
	}

// UpgradeRecommendation is the resolver for the upgradeRecommendation query.
	func (r *queryResolver) UpgradeRecommendation(ctx context.Context, routerID string, featureID string) ( *model.UpgradeRecommendation,  error){
		if r.CapabilityService == nil {
		return nil, nil
	}

	caps, err := r.CapabilityService.GetCapabilities(ctx, routerID, r.getRouterPort)
	if err != nil {
		return nil, err
	}

	// Get version requirement for the feature
	svc := compatibility.DefaultService
	if err := svc.LoadMatrix(); err != nil {
		return nil, err
	}

	isCHR := detectCHR(caps)
	requiredVersion := svc.GetVersionRequirement(featureID, isCHR)

	// If feature is already supported, no upgrade needed
	integration := r.getVersionIntegration()
	support := integration.GetFeatureSupport(caps, featureID, isCHR)
	if support != nil && support.Supported {
		return nil, nil
	}

	// Build upgrade recommendation
	currentVersion := caps.Software.Version.String()
	return &model.UpgradeRecommendation{
		FeatureID:       featureID,
		FeatureName:     getFeatureName(featureID),
		CurrentVersion:  currentVersion,
		RequiredVersion: requiredVersion,
		IsMajorUpgrade:  isMajorUpgrade(currentVersion, requiredVersion),
		Priority:        model.UpgradePriorityMedium,
	}, nil
	}

// UpgradeRecommendations is the resolver for the upgradeRecommendations query.
	func (r *queryResolver) UpgradeRecommendations(ctx context.Context, routerID string) ( []*model.UpgradeRecommendation,  error){
		if r.CapabilityService == nil {
		return []*model.UpgradeRecommendation{}, nil
	}

	caps, err := r.CapabilityService.GetCapabilities(ctx, routerID, r.getRouterPort)
	if err != nil {
		return nil, err
	}

	// Get all unsupported features and generate recommendations for each
	integration := r.getVersionIntegration()
	isCHR := detectCHR(caps)
	unsupported := integration.GetUnsupportedFeatures(caps, isCHR)

	svc := compatibility.DefaultService
	_ = svc.LoadMatrix()

	currentVersion := caps.Software.Version.String()
	recommendations := make([]*model.UpgradeRecommendation, 0)
	for _, u := range unsupported {
		requiredVersion := svc.GetVersionRequirement(u.FeatureID, isCHR)
		if requiredVersion != "" {
			recommendations = append(recommendations, &model.UpgradeRecommendation{
				FeatureID:       u.FeatureID,
				FeatureName:     getFeatureName(u.FeatureID),
				CurrentVersion:  currentVersion,
				RequiredVersion: requiredVersion,
				IsMajorUpgrade:  isMajorUpgrade(currentVersion, requiredVersion),
				Priority:        model.UpgradePriorityMedium,
			})
		}
	}

	return recommendations, nil
	}

// RouterStatusChanged subscribes to router status change events.
If routerID is provided, only events for that router are streamed.
If routerID is nil, all router status changes are streamed.
	func (r *subscriptionResolver) RouterStatusChanged(ctx context.Context, routerID *string) ( <-chan *model.RouterStatusEvent,  error){
		// Create a buffered channel for events
	ch := make(chan *model.RouterStatusEvent, 10)

	// Subscribe to the event bus
	if r.EventBus != nil {
		handler := func(eventCtx context.Context, event events.Event) error {
			// Type assert to RouterStatusChangedEvent
			statusEvent, ok := event.(*events.RouterStatusChangedEvent)
			if !ok {
				return nil // Skip non-matching events
			}

			// Filter by routerID if specified
			if routerID != nil && statusEvent.RouterID != *routerID {
				return nil
			}

			// Convert to GraphQL model
			graphQLEvent := &model.RouterStatusEvent{
				Router: &model.Router{
					ID: statusEvent.RouterID,
					// Note: Full router data should be loaded from DB in production
					Status: convertRouterStatus(statusEvent.Status),
				},
				PreviousStatus: convertRouterStatus(statusEvent.PreviousStatus),
				NewStatus:      convertRouterStatus(statusEvent.Status),
				Timestamp:      statusEvent.GetTimestamp(),
			}

			// Non-blocking send with context check
			select {
			case <-ctx.Done():
				return ctx.Err()
			case ch <- graphQLEvent:
				return nil
			default:
				// Channel full, log warning but don't block
				log.Printf("[SUBSCRIPTION] RouterStatusChanged channel full, dropping event for router %s", statusEvent.RouterID)
				return nil
			}
		}

		if err := r.EventBus.Subscribe(events.EventTypeRouterStatusChanged, handler); err != nil {
			close(ch)
			return nil, err
		}
	}

	// Clean up when context is cancelled
	go func() {
		<-ctx.Done()
		close(ch)
	}()

	return ch, nil
	}

// ResourceMetrics subscribes to real-time resource metrics updates.
Emits new metrics every 2 seconds per NAS-5.2 AC 5.2.2.
	func (r *subscriptionResolver) ResourceMetrics(ctx context.Context, deviceID string) ( <-chan *model.ResourceMetrics,  error){
		ch := make(chan *model.ResourceMetrics)

	// Start a goroutine that emits metrics every 2 seconds
	go func() {
		defer close(ch)

		// Create a ticker for 2-second intervals (AC 5.2.2)
		ticker := time.NewTicker(2 * time.Second)
		defer ticker.Stop()

		// Send initial metrics immediately
		metrics, err := r.fetchResourceMetrics(deviceID)
		if err == nil {
			select {
			case ch <- metrics:
			case <-ctx.Done():
				return
			}
		}

		// Continue sending metrics every 2 seconds
		for {
			select {
			case <-ctx.Done():
				// Client disconnected
				return
			case <-ticker.C:
				// Fetch and send new metrics
				metrics, err := r.fetchResourceMetrics(deviceID)
				if err != nil {
					// Log error but continue (silent fail per subscription pattern)
					continue
				}

				// Send metrics to channel (non-blocking)
				select {
				case ch <- metrics:
				case <-ctx.Done():
					return
				}
			}
		}
	}()

	return ch, nil
	}

// InterfaceTraffic subscribes to interface traffic updates.
This is a polling subscription that fetches traffic data at regular intervals.
	func (r *subscriptionResolver) InterfaceTraffic(ctx context.Context, routerID string, interfaceID *string) ( <-chan *model.InterfaceTrafficEvent,  error){
		ch := make(chan *model.InterfaceTrafficEvent, 5)

	// Default polling interval from @realtime directive (1000ms)
	interval := 1 * time.Second

	go func() {
		defer close(ch)

		ticker := time.NewTicker(interval)
		defer ticker.Stop()

		for {
			select {
			case <-ctx.Done():
				return
			case <-ticker.C:
				// In production, this would fetch real traffic data from the router
				// For now, we emit placeholder events
				event := &model.InterfaceTrafficEvent{
					InterfaceID:   "placeholder",
					InterfaceName: "eth0",
					TxRate:        "0",
					RxRate:        "0",
					TxTotal:       "0",
					RxTotal:       "0",
					Timestamp:     time.Now(),
				}

				if interfaceID != nil {
					event.InterfaceID = *interfaceID
				}

				select {
				case ch <- event:
				case <-ctx.Done():
					return
				}
			}
		}
	}()

	return ch, nil
	}

// ResourceUpdated subscribes to resource update events (create, update, delete).
If resourceID is provided, only events for that specific resource are streamed.
If resourceID is nil, all resource updates are streamed.
	func (r *subscriptionResolver) ResourceUpdated(ctx context.Context, resourceID *string) ( <-chan *model.ResourceUpdatedEvent,  error){
		ch := make(chan *model.ResourceUpdatedEvent, 20)

	if r.EventBus != nil {
		// Handler for all resource event types
		handler := func(eventCtx context.Context, event events.Event) error {
			resourceEvent, ok := event.(*events.ResourceUpdatedEvent)
			if !ok {
				return nil
			}

			// Filter by resourceID if specified
			if resourceID != nil && resourceEvent.ResourceUUID.String() != *resourceID {
				return nil
			}

			// Convert to GraphQL model
			graphQLEvent := &model.ResourceUpdatedEvent{
				ResourceID:    resourceEvent.ResourceUUID.String(),
				ResourceType:  resourceEvent.ResourceType,
				RouterID:      resourceEvent.RouterID,
				Version:       resourceEvent.NewVersion,
				ChangedFields: resourceEvent.ChangedFields,
				ChangeType:    convertChangeType(resourceEvent.ChangeType),
				Timestamp:     resourceEvent.GetTimestamp(),
			}

			select {
			case <-ctx.Done():
				return ctx.Err()
			case ch <- graphQLEvent:
				return nil
			default:
				log.Printf("[SUBSCRIPTION] ResourceUpdated channel full, dropping event for resource %s", resourceEvent.ResourceUUID)
				return nil
			}
		}

		// Subscribe to all resource event types
		for _, eventType := range []string{
			events.EventTypeResourceCreated,
			events.EventTypeResourceUpdated,
			events.EventTypeResourceDeleted,
		} {
			if err := r.EventBus.Subscribe(eventType, handler); err != nil {
				close(ch)
				return nil, err
			}
		}
	}

	go func() {
		<-ctx.Done()
		close(ch)
	}()

	return ch, nil
	}

// ConfigApplyProgress subscribes to configuration apply progress events.
This streams real-time progress updates for a specific configuration apply operation.
	func (r *subscriptionResolver) ConfigApplyProgress(ctx context.Context, operationID string) ( <-chan *model.ConfigProgress,  error){
		ch := make(chan *model.ConfigProgress, 10)

	if r.EventBus != nil {
		handler := func(eventCtx context.Context, event events.Event) error {
			progressEvent, ok := event.(*events.ConfigApplyProgressEvent)
			if !ok {
				return nil
			}

			// Filter by operationID
			if progressEvent.OperationID != operationID {
				return nil
			}

			// Convert to GraphQL model
			graphQLEvent := &model.ConfigProgress{
				OperationID: progressEvent.OperationID,
				Status:      convertConfigApplyStatus(progressEvent.Stage),
				Percentage:  progressEvent.Progress,
				Message:     progressEvent.Message,
				CurrentStep: &progressEvent.ResourcesApplied,
				TotalSteps:  &progressEvent.ResourcesTotal,
				Timestamp:   progressEvent.GetTimestamp(),
			}

			select {
			case <-ctx.Done():
				return ctx.Err()
			case ch <- graphQLEvent:
				return nil
			default:
				log.Printf("[SUBSCRIPTION] ConfigApplyProgress channel full, dropping event for operation %s", operationID)
				return nil
			}
		}

		if err := r.EventBus.Subscribe(events.EventTypeConfigApplyProgress, handler); err != nil {
			close(ch)
			return nil, err
		}
	}

	go func() {
		<-ctx.Done()
		close(ch)
	}()

	return ch, nil
	}

// InterfaceStatusChanged subscribes to interface status change events.
If routerID is provided, only events for that router are streamed.
If interfaceID is provided, only events for that specific interface are streamed.
	func (r *subscriptionResolver) InterfaceStatusChanged(ctx context.Context, routerID string, interfaceID *string) ( <-chan *model.InterfaceStatusEvent,  error){
		// Create a buffered channel for events
	ch := make(chan *model.InterfaceStatusEvent, 10)

	// Subscribe to the event bus
	if r.EventBus != nil {
		handler := func(eventCtx context.Context, event events.Event) error {
			// Type assert to InterfaceStatusChangedEvent
			statusEvent, ok := event.(*events.InterfaceStatusChangedEvent)
			if !ok {
				return nil // Skip non-matching events
			}

			// Filter by routerID
			if statusEvent.RouterID != routerID {
				return nil
			}

			// Filter by interfaceID if specified
			if interfaceID != nil && statusEvent.InterfaceID != *interfaceID {
				return nil
			}

			// Convert to GraphQL model
			graphQLEvent := &model.InterfaceStatusEvent{
				InterfaceID:    statusEvent.InterfaceID,
				InterfaceName:  statusEvent.InterfaceName,
				Status:         mapInterfaceStatusToGraphQL(statusEvent.Status),
				PreviousStatus: mapInterfaceStatusToGraphQL(statusEvent.PreviousStatus),
				Timestamp:      statusEvent.GetTimestamp(),
			}

			// Non-blocking send with context check
			select {
			case <-ctx.Done():
				return ctx.Err()
			case ch <- graphQLEvent:
				return nil
			default:
				// Channel full, log warning but don't block
				log.Printf("[SUBSCRIPTION] InterfaceStatusChanged channel full, dropping event for interface %s", statusEvent.InterfaceID)
				return nil
			}
		}

		if err := r.EventBus.Subscribe(events.EventTypeInterfaceStatusChanged, handler); err != nil {
			close(ch)
			return nil, err
		}
	}

	// Clean up when context is cancelled
	go func() {
		<-ctx.Done()
		close(ch)
	}()

	return ch, nil
	}



// Mutation returns graph.MutationResolver implementation.
	func (r *Resolver) Mutation() graph.MutationResolver { return &mutationResolver{r} }
// Query returns graph.QueryResolver implementation.
	func (r *Resolver) Query() graph.QueryResolver { return &queryResolver{r} }
// Subscription returns graph.SubscriptionResolver implementation.
	func (r *Resolver) Subscription() graph.SubscriptionResolver { return &subscriptionResolver{r} }

