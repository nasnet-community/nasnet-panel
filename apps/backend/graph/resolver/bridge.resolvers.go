package resolver

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.44

import (
	"backend/graph/model"
	"backend/internal/services"
	"context"
	"encoding/json"
	"fmt"
)

// CreateBridge resolves the createBridge mutation.
func (r *mutationResolver) CreateBridge(ctx context.Context, routerID string, input model.CreateBridgeInput) (*model.BridgeMutationResult, error) {
	// Convert GraphQL input to service input
	serviceInput := &services.CreateBridgeInput{
		Name:          input.Name,
		Comment:       stringPtrValue(input.Comment),
		Protocol:      mapStpProtocolToString(input.Protocol),
		Priority:      intPtrValue(input.Priority),
		VlanFiltering: boolPtrValue(input.VlanFiltering),
		PVID:          intPtrValue(input.Pvid),
		MTU:           intPtrValue(input.Mtu),
	}

	// Call service
	bridge, operationID, err := r.BridgeService.CreateBridge(ctx, routerID, serviceInput)
	if err != nil {
		return &model.BridgeMutationResult{
			Success: false,
			Bridge:  nil,
			Errors: []*model.MutationError{
				{
					Code:    "CREATE_FAILED",
					Message: err.Error(),
				},
			},
		}, nil
	}

	// Marshal previous state (nil for create)
	var previousState *string

	return &model.BridgeMutationResult{
		Success:       true,
		Bridge:        mapBridgeDataToGraphQL(bridge),
		Errors:        []*model.MutationError{},
		PreviousState: previousState,
		OperationID:   &operationID,
	}, nil
}

// UpdateBridge resolves the updateBridge mutation.
func (r *mutationResolver) UpdateBridge(ctx context.Context, uuid string, input model.UpdateBridgeInput) (*model.BridgeMutationResult, error) {
	// Convert GraphQL input to service input
	serviceInput := &services.UpdateBridgeInput{
		Comment:       input.Comment,
		Protocol:      mapStpProtocolPtrToStringPtr(input.Protocol),
		Priority:      input.Priority,
		VlanFiltering: input.VlanFiltering,
		PVID:          input.Pvid,
		MTU:           input.Mtu,
		Disabled:      input.Disabled,
	}

	// Call service
	bridge, operationID, err := r.BridgeService.UpdateBridge(ctx, uuid, serviceInput)
	if err != nil {
		return &model.BridgeMutationResult{
			Success: false,
			Bridge:  nil,
			Errors: []*model.MutationError{
				{
					Code:    "UPDATE_FAILED",
					Message: err.Error(),
				},
			},
		}, nil
	}

	// Marshal previous state from service result
	previousStateBytes, _ := json.Marshal(bridge)
	previousStateStr := string(previousStateBytes)

	return &model.BridgeMutationResult{
		Success:       true,
		Bridge:        mapBridgeDataToGraphQL(bridge),
		Errors:        []*model.MutationError{},
		PreviousState: &previousStateStr,
		OperationID:   &operationID,
	}, nil
}

// DeleteBridge resolves the deleteBridge mutation.
func (r *mutationResolver) DeleteBridge(ctx context.Context, uuid string) (*model.DeleteResult, error) {
	// Call service
	operationID, err := r.BridgeService.DeleteBridge(ctx, uuid)
	if err != nil {
		return &model.DeleteResult{
			Success: false,
			Errors: []*model.MutationError{
				{
					Code:    "DELETE_FAILED",
					Message: err.Error(),
				},
			},
		}, nil
	}

	return &model.DeleteResult{
		Success:     true,
		Errors:      []*model.MutationError{},
		OperationID: &operationID,
	}, nil
}

// UndoBridgeOperation resolves the undoBridgeOperation mutation.
func (r *mutationResolver) UndoBridgeOperation(ctx context.Context, operationID string) (*model.BridgeMutationResult, error) {
	// Call service
	bridge, err := r.BridgeService.UndoBridgeOperation(ctx, operationID)
	if err != nil {
		return &model.BridgeMutationResult{
			Success: false,
			Bridge:  nil,
			Errors: []*model.MutationError{
				{
					Code:    "UNDO_FAILED",
					Message: err.Error(),
				},
			},
		}, nil
	}

	return &model.BridgeMutationResult{
		Success: true,
		Bridge:  mapBridgeDataToGraphQL(bridge),
		Errors:  []*model.MutationError{},
	}, nil
}

// AddBridgePort resolves the addBridgePort mutation.
func (r *mutationResolver) AddBridgePort(ctx context.Context, bridgeID string, input model.AddBridgePortInput) (*model.BridgePortMutationResult, error) {
	// Convert GraphQL input to service input
	serviceInput := &services.AddBridgePortInput{
		InterfaceID:      input.InterfaceID,
		PVID:             intPtrValue(input.Pvid),
		FrameTypes:       mapFrameTypesToString(input.FrameTypes),
		IngressFiltering: input.IngressFiltering,
	}

	// Call service
	port, operationID, err := r.BridgeService.AddBridgePort(ctx, bridgeID, serviceInput)
	if err != nil {
		return &model.BridgePortMutationResult{
			Success: false,
			Port:    nil,
			Errors: []*model.MutationError{
				{
					Code:    "ADD_PORT_FAILED",
					Message: err.Error(),
				},
			},
		}, nil
	}

	// Marshal previous state (nil for create)
	var previousState *string

	return &model.BridgePortMutationResult{
		Success:       true,
		Port:          mapBridgePortDataToGraphQL(port),
		Errors:        []*model.MutationError{},
		PreviousState: previousState,
		OperationID:   &operationID,
	}, nil
}

// UpdateBridgePort resolves the updateBridgePort mutation.
func (r *mutationResolver) UpdateBridgePort(ctx context.Context, portID string, input model.UpdateBridgePortInput) (*model.BridgePortMutationResult, error) {
	// Convert GraphQL input to service input
	serviceInput := &services.UpdateBridgePortInput{
		PVID:             input.Pvid,
		FrameTypes:       mapFrameTypesPtrToStringPtr(input.FrameTypes),
		IngressFiltering: input.IngressFiltering,
		TaggedVlans:      input.TaggedVlans,
		UntaggedVlans:    input.UntaggedVlans,
		Edge:             input.Edge,
		PathCost:         input.PathCost,
	}

	// Call service
	port, operationID, err := r.BridgeService.UpdateBridgePort(ctx, portID, serviceInput)
	if err != nil {
		return &model.BridgePortMutationResult{
			Success: false,
			Port:    nil,
			Errors: []*model.MutationError{
				{
					Code:    "UPDATE_PORT_FAILED",
					Message: err.Error(),
				},
			},
		}, nil
	}

	// Marshal previous state
	previousStateBytes, _ := json.Marshal(port)
	previousStateStr := string(previousStateBytes)

	return &model.BridgePortMutationResult{
		Success:       true,
		Port:          mapBridgePortDataToGraphQL(port),
		Errors:        []*model.MutationError{},
		PreviousState: &previousStateStr,
		OperationID:   &operationID,
	}, nil
}

// RemoveBridgePort resolves the removeBridgePort mutation.
func (r *mutationResolver) RemoveBridgePort(ctx context.Context, portID string) (*model.DeleteResult, error) {
	// Call service
	operationID, err := r.BridgeService.RemoveBridgePort(ctx, portID)
	if err != nil {
		return &model.DeleteResult{
			Success: false,
			Errors: []*model.MutationError{
				{
					Code:    "REMOVE_PORT_FAILED",
					Message: err.Error(),
				},
			},
		}, nil
	}

	return &model.DeleteResult{
		Success:     true,
		Errors:      []*model.MutationError{},
		OperationID: &operationID,
	}, nil
}

// CreateBridgeVlan resolves the createBridgeVlan mutation.
func (r *mutationResolver) CreateBridgeVlan(ctx context.Context, bridgeID string, input model.CreateBridgeVlanInput) (*model.BridgeVlanMutationResult, error) {
	// Convert GraphQL input to service input
	serviceInput := &services.CreateBridgeVlanInput{
		VlanID:          input.VlanID,
		TaggedPortIDs:   input.TaggedPortIDs,
		UntaggedPortIDs: input.UntaggedPortIDs,
	}

	// Call service
	vlan, err := r.BridgeService.CreateBridgeVlan(ctx, bridgeID, serviceInput)
	if err != nil {
		return &model.BridgeVlanMutationResult{
			Success: false,
			Vlan:    nil,
			Errors: []*model.MutationError{
				{
					Code:    "CREATE_VLAN_FAILED",
					Message: err.Error(),
				},
			},
		}, nil
	}

	return &model.BridgeVlanMutationResult{
		Success: true,
		Vlan:    mapBridgeVlanDataToGraphQL(vlan),
		Errors:  []*model.MutationError{},
	}, nil
}

// DeleteBridgeVlan resolves the deleteBridgeVlan mutation.
func (r *mutationResolver) DeleteBridgeVlan(ctx context.Context, uuid string) (*model.DeleteResult, error) {
	// Call service
	err := r.BridgeService.DeleteBridgeVlan(ctx, uuid)
	if err != nil {
		return &model.DeleteResult{
			Success: false,
			Errors: []*model.MutationError{
				{
					Code:    "DELETE_VLAN_FAILED",
					Message: err.Error(),
				},
			},
		}, nil
	}

	return &model.DeleteResult{
		Success: true,
		Errors:  []*model.MutationError{},
	}, nil
}

// Bridges resolves the bridges query to list all bridges on a router.
func (r *queryResolver) Bridges(ctx context.Context, routerID string) ([]*model.Bridge, error) {
	// Fetch bridges from service
	bridges, err := r.BridgeService.GetBridges(ctx, routerID)
	if err != nil {
		return nil, fmt.Errorf("failed to get bridges: %w", err)
	}

	// Convert to GraphQL models
	result := make([]*model.Bridge, len(bridges))
	for i, bridge := range bridges {
		result[i] = mapBridgeDataToGraphQL(bridge)
	}

	return result, nil
}

// Bridge resolves the bridge query for a single bridge by UUID.
func (r *queryResolver) Bridge(ctx context.Context, uuid string) (*model.Bridge, error) {
	// Fetch bridge data from service
	bridgeData, err := r.BridgeService.GetBridge(ctx, uuid)
	if err != nil {
		return nil, fmt.Errorf("failed to get bridge: %w", err)
	}

	// Convert to GraphQL model
	return mapBridgeDataToGraphQL(bridgeData), nil
}

// BridgePorts resolves the bridgePorts query to list ports for a bridge.
func (r *queryResolver) BridgePorts(ctx context.Context, bridgeID string) ([]*model.BridgePort, error) {
	// Fetch ports from service
	ports, err := r.BridgeService.GetBridgePorts(ctx, bridgeID)
	if err != nil {
		return nil, fmt.Errorf("failed to get bridge ports: %w", err)
	}

	// Convert to GraphQL models
	result := make([]*model.BridgePort, len(ports))
	for i, port := range ports {
		result[i] = mapBridgePortDataToGraphQL(port)
	}

	return result, nil
}

// BridgeVlans resolves the bridgeVlans query to list VLANs for a bridge.
func (r *queryResolver) BridgeVlans(ctx context.Context, bridgeID string) ([]*model.BridgeVlan, error) {
	// Fetch VLANs from service
	vlans, err := r.BridgeService.GetBridgeVlans(ctx, bridgeID)
	if err != nil {
		return nil, fmt.Errorf("failed to get bridge VLANs: %w", err)
	}

	// Convert to GraphQL models
	result := make([]*model.BridgeVlan, len(vlans))
	for i, vlan := range vlans {
		result[i] = mapBridgeVlanDataToGraphQL(vlan)
	}

	return result, nil
}

// AvailableInterfacesForBridge resolves the query for interfaces not in any bridge.
func (r *queryResolver) AvailableInterfacesForBridge(ctx context.Context, routerID string) ([]*model.Interface, error) {
	// Fetch available interfaces from service
	interfaceNames, err := r.BridgeService.GetAvailableInterfaces(ctx, routerID)
	if err != nil {
		return nil, fmt.Errorf("failed to get available interfaces: %w", err)
	}

	// For now, return simple Interface objects with just the name
	// Full implementation would fetch full interface details
	result := make([]*model.Interface, len(interfaceNames))
	for i, name := range interfaceNames {
		result[i] = &model.Interface{
			UUID: name, // Temporary - should be actual UUID
			Name: name,
		}
	}

	return result, nil
}

// BridgeStpStatusChanged is the resolver for the bridgeStpStatusChanged field.
func (r *subscriptionResolver) BridgeStpStatusChanged(ctx context.Context, bridgeID string) (<-chan *model.BridgeStpStatus, error) {
	panic(fmt.Errorf("not implemented: BridgeStpStatusChanged - bridgeStpStatusChanged"))
}

// BridgePortsChanged is the resolver for the bridgePortsChanged field.
func (r *subscriptionResolver) BridgePortsChanged(ctx context.Context, bridgeID string) (<-chan []*model.BridgePort, error) {
	panic(fmt.Errorf("not implemented: BridgePortsChanged - bridgePortsChanged"))
}

// !!! WARNING !!!
// The code below was going to be deleted when updating resolvers. It has been copied here so you have
// one last chance to move it out of harms way if you want. There are two reasons this happens:
//   - When renaming or deleting a resolver the old code will be put in here. You can safely delete
//     it when you're done.
//   - You have helper methods in this file. Move them out to keep these resolver files clean.
func (r *bridgeResolver) Ports(ctx context.Context, obj *model.Bridge) ([]*model.BridgePort, error) {
	// Fetch ports for this bridge
	ports, err := r.BridgeService.GetBridgePorts(ctx, obj.UUID)
	if err != nil {
		return nil, fmt.Errorf("failed to get bridge ports: %w", err)
	}

	// Convert to GraphQL models
	result := make([]*model.BridgePort, len(ports))
	for i, port := range ports {
		result[i] = mapBridgePortDataToGraphQL(port)
	}

	return result, nil
}
func (r *bridgeResolver) Vlans(ctx context.Context, obj *model.Bridge) ([]*model.BridgeVlan, error) {
	// Fetch VLANs for this bridge
	vlans, err := r.BridgeService.GetBridgeVlans(ctx, obj.UUID)
	if err != nil {
		return nil, fmt.Errorf("failed to get bridge VLANs: %w", err)
	}

	// Convert to GraphQL models
	result := make([]*model.BridgeVlan, len(vlans))
	for i, vlan := range vlans {
		result[i] = mapBridgeVlanDataToGraphQL(vlan)
	}

	return result, nil
}
func (r *bridgeResolver) StpStatus(ctx context.Context, obj *model.Bridge) (*model.BridgeStpStatus, error) {
	// Only fetch STP status if protocol is not NONE
	if obj.Protocol == model.StpProtocolNone {
		return nil, nil
	}

	// Fetch STP status for this bridge
	stpStatus, err := r.BridgeService.GetStpStatus(ctx, obj.UUID)
	if err != nil {
		// STP status might not be available yet, return nil instead of error
		return nil, nil
	}

	return mapStpStatusDataToGraphQL(stpStatus), nil
}
func (r *bridgeResolver) DependentDhcpServers(ctx context.Context, obj *model.Bridge) ([]*model.DhcpServer, error) {
	// TODO: Implement when DHCP server service is available
	return []*model.DhcpServer{}, nil
}
func (r *bridgeResolver) DependentRoutes(ctx context.Context, obj *model.Bridge) ([]*model.Route, error) {
	// TODO: Implement when Route service is available
	return []*model.Route{}, nil
}
func (r *bridgeResolver) IpAddresses(ctx context.Context, obj *model.Bridge) ([]*model.IPAddress, error) {
	// TODO: Implement when full IP address integration is available
	return []*model.IPAddress{}, nil
}
func (r *Resolver) Bridge() BridgeResolver {
	return &bridgeResolver{r}
}

type bridgeResolver struct{ *Resolver }
type BridgeResolver interface {
	Ports(ctx context.Context, obj *model.Bridge) ([]*model.BridgePort, error)
	Vlans(ctx context.Context, obj *model.Bridge) ([]*model.BridgeVlan, error)
	StpStatus(ctx context.Context, obj *model.Bridge) (*model.BridgeStpStatus, error)
	DependentDhcpServers(ctx context.Context, obj *model.Bridge) ([]*model.DhcpServer, error)
	DependentRoutes(ctx context.Context, obj *model.Bridge) ([]*model.Route, error)
	IpAddresses(ctx context.Context, obj *model.Bridge) ([]*model.IPAddress, error)
}

func mapBridgeDataToGraphQL(data *services.BridgeData) *model.Bridge {
	if data == nil {
		return nil
	}

	return &model.Bridge{
		UUID:          data.UUID,
		Name:          data.Name,
		Comment:       stringToPtr(data.Comment),
		Disabled:      data.Disabled,
		Running:       data.Running,
		MacAddress:    stringToPtr(data.MacAddress),
		Mtu:           intToPtr(data.MTU),
		Protocol:      mapStringToStpProtocol(data.Protocol),
		Priority:      intToPtr(data.Priority),
		VlanFiltering: data.VlanFiltering,
		Pvid:          intToPtr(data.PVID),
	}
}
func mapBridgePortDataToGraphQL(data *services.BridgePortData) *model.BridgePort {
	if data == nil {
		return nil
	}

	return &model.BridgePort{
		UUID:             data.UUID,
		Pvid:             data.PVID,
		FrameTypes:       mapStringToFrameTypes(data.FrameTypes),
		IngressFiltering: data.IngressFiltering,
		TaggedVlans:      data.TaggedVlans,
		UntaggedVlans:    data.UntaggedVlans,
		Role:             mapStringToStpPortRole(data.Role),
		State:            mapStringToStpPortState(data.State),
		PathCost:         data.PathCost,
		Edge:             data.Edge,
	}
}
func mapBridgeVlanDataToGraphQL(data *services.BridgeVlanData) *model.BridgeVlan {
	if data == nil {
		return nil
	}

	return &model.BridgeVlan{
		UUID:   data.UUID,
		VlanID: data.VlanID,
	}
}
func mapStpStatusDataToGraphQL(data *services.BridgeStpStatusData) *model.BridgeStpStatus {
	if data == nil {
		return nil
	}

	return &model.BridgeStpStatus{
		RootBridge:          data.RootBridge,
		RootBridgeID:        stringToPtr(data.RootBridgeID),
		RootPort:            stringToPtr(data.RootPort),
		RootPathCost:        data.RootPathCost,
		TopologyChangeCount: data.TopologyChangeCount,
		LastTopologyChange:  data.LastTopologyChange,
	}
}
func mapStpProtocolToString(protocol *model.StpProtocol) string {
	if protocol == nil {
		return "none"
	}
	switch *protocol {
	case model.StpProtocolNone:
		return "none"
	case model.StpProtocolStp:
		return "stp"
	case model.StpProtocolRstp:
		return "rstp"
	case model.StpProtocolMstp:
		return "mstp"
	default:
		return "none"
	}
}
func mapStpProtocolPtrToStringPtr(protocol *model.StpProtocol) *string {
	if protocol == nil {
		return nil
	}
	str := mapStpProtocolToString(protocol)
	return &str
}
func mapStringToStpProtocol(s string) model.StpProtocol {
	switch s {
	case "stp":
		return model.StpProtocolStp
	case "rstp":
		return model.StpProtocolRstp
	case "mstp":
		return model.StpProtocolMstp
	default:
		return model.StpProtocolNone
	}
}
func mapFrameTypesToString(frameTypes *model.FrameTypes) string {
	if frameTypes == nil {
		return "admit-all"
	}
	switch *frameTypes {
	case model.FrameTypesAdmitAll:
		return "admit-all"
	case model.FrameTypesAdmitOnlyUntaggedAndPriority:
		return "admit-only-untagged-and-priority"
	case model.FrameTypesAdmitOnlyVlanTagged:
		return "admit-only-vlan-tagged"
	default:
		return "admit-all"
	}
}
func mapFrameTypesPtrToStringPtr(frameTypes *model.FrameTypes) *string {
	if frameTypes == nil {
		return nil
	}
	str := mapFrameTypesToString(frameTypes)
	return &str
}
func mapStringToFrameTypes(s string) model.FrameTypes {
	switch s {
	case "admit-only-untagged-and-priority":
		return model.FrameTypesAdmitOnlyUntaggedAndPriority
	case "admit-only-vlan-tagged":
		return model.FrameTypesAdmitOnlyVlanTagged
	default:
		return model.FrameTypesAdmitAll
	}
}
func mapStringToStpPortRole(s string) model.StpPortRole {
	switch s {
	case "root":
		return model.StpPortRoleRoot
	case "designated":
		return model.StpPortRoleDesignated
	case "alternate":
		return model.StpPortRoleAlternate
	case "backup":
		return model.StpPortRoleBackup
	default:
		return model.StpPortRoleDisabled
	}
}
func mapStringToStpPortState(s string) model.StpPortState {
	switch s {
	case "blocking":
		return model.StpPortStateBlocking
	case "listening":
		return model.StpPortStateListening
	case "learning":
		return model.StpPortStateLearning
	case "forwarding":
		return model.StpPortStateForwarding
	default:
		return model.StpPortStateDisabled
	}
}
func stringToPtr(s string) *string {
	if s == "" {
		return nil
	}
	return &s
}
func intToPtr(i int) *int {
	if i == 0 {
		return nil
	}
	return &i
}
func stringPtrValue(s *string) string {
	if s == nil {
		return ""
	}
	return *s
}
func intPtrValue(i *int) int {
	if i == nil {
		return 0
	}
	return *i
}
func boolPtrValue(b *bool) bool {
	if b == nil {
		return false
	}
	return *b
}
