package resolver

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.86

import (
	"backend/graph/model"
	"backend/internal/apperrors"
	"backend/internal/events"
	"backend/internal/templates"
	"context"
	"encoding/json"
	"fmt"
	"time"
)

// InstallServiceTemplate installs a service template on a router
func (r *mutationResolver) InstallServiceTemplate(ctx context.Context, input model.InstallServiceTemplateInput) (*model.TemplateInstallResult, error) {
	r.log.Infow("InstallServiceTemplate mutation called",
		"routerID", input.RouterID,
		"templateID", input.TemplateID,
		"dryRun", input.DryRun)

	// Validate inputs
	if input.RouterID == "" {
		return nil, apperrors.Wrap(nil, apperrors.CodeValidationFailed, apperrors.CategoryValidation, "router ID is required")
	}
	if input.TemplateID == "" {
		return nil, apperrors.Wrap(nil, apperrors.CodeValidationFailed, apperrors.CategoryValidation, "template ID is required")
	}

	// Check if TemplateInstaller is available
	if r.TemplateInstaller == nil {
		return nil, apperrors.Wrap(nil, apperrors.CodeResourceNotFound, apperrors.CategoryInternal, "template installer not available")
	}

	// Dry run - just validate
	if input.DryRun.IsSet() && input.DryRun.Value() != nil && *input.DryRun.Value() {
		if err := r.TemplateInstaller.ValidateTemplate(ctx, input.TemplateID, input.Variables); err != nil {
			return nil, apperrors.Wrap(err, apperrors.CodeValidationFailed, apperrors.CategoryValidation, "template validation failed")
		}

		return &model.TemplateInstallResult{
			Success: true,
		}, nil
	}

	// Get router info for architecture and resources
	// TODO: Query router from database for actual values
	// For now, use reasonable defaults
	routerOSVersion := "7.0"
	architecture := "arm64"
	availableMemoryMB := 2048
	availableDiskMB := 10000

	// Get user ID from context (if available)
	requestedByUID := "system"
	if userID, ok := ctx.Value("user_id").(string); ok {
		requestedByUID = userID
	}

	// Install template
	resp, err := r.TemplateInstaller.InstallTemplate(ctx, templates.InstallTemplateRequest{
		RouterID:          input.RouterID,
		TemplateID:        input.TemplateID,
		Variables:         input.Variables,
		RouterOSVersion:   routerOSVersion,
		Architecture:      architecture,
		AvailableMemoryMB: availableMemoryMB,
		AvailableDiskMB:   availableDiskMB,
		RequestedByUID:    requestedByUID,
	})

	if err != nil {
		r.log.Errorw("template installation failed", "error", err, "templateID", input.TemplateID)
		return &model.TemplateInstallResult{
			Success: false,
			Errors:  []string{fmt.Sprintf("Installation failed: %v", err)},
		}, nil
	}

	r.log.Infow("template installation completed",
		"templateID", input.TemplateID,
		"instanceCount", len(resp.InstanceIDs))

	// Convert map[string]string to map[string]any
	serviceMapping := make(map[string]any, len(resp.ServiceMapping))
	for k, v := range resp.ServiceMapping {
		serviceMapping[k] = v
	}

	return &model.TemplateInstallResult{
		Success:        true,
		InstanceIDs:    resp.InstanceIDs,
		ServiceMapping: serviceMapping,
	}, nil
}

// ExportAsTemplate exports existing service instances as a reusable template
func (r *mutationResolver) ExportAsTemplate(ctx context.Context, input model.ExportAsTemplateInput) (*model.ServiceTemplate, error) {
	r.log.Infow("ExportAsTemplate mutation called",
		"routerID", input.RouterID,
		"instanceCount", len(input.InstanceIDs))

	// Validate inputs
	if input.RouterID == "" {
		return nil, apperrors.Wrap(nil, apperrors.CodeValidationFailed, apperrors.CategoryValidation, "router ID is required")
	}
	if len(input.InstanceIDs) == 0 {
		return nil, apperrors.Wrap(nil, apperrors.CodeValidationFailed, apperrors.CategoryValidation, "at least one instance ID is required")
	}
	if input.Name == "" {
		return nil, apperrors.Wrap(nil, apperrors.CodeValidationFailed, apperrors.CategoryValidation, "template name is required")
	}

	// Check if TemplateExporter is available
	if r.TemplateExporter == nil {
		return nil, apperrors.Wrap(nil, apperrors.CodeResourceNotFound, apperrors.CategoryInternal, "template exporter not available")
	}

	// Build export request
	exportReq := templates.ExportTemplateRequest{
		InstanceIDs:  input.InstanceIDs,
		RouterID:     input.RouterID,
		TemplateName: input.Name,
		Description:  input.Description,
		Category:     string(input.Category),
	}

	// Export template
	tmpl, err := r.TemplateExporter.ExportAsTemplate(ctx, exportReq)
	if err != nil {
		r.log.Errorw("template export failed", "error", err)
		return nil, apperrors.Wrap(err, apperrors.CodeResourceNotFound, apperrors.CategoryInternal, "failed to export template")
	}

	r.log.Infow("template export completed",
		"templateID", tmpl.ID,
		"templateName", tmpl.Name,
		"services", len(tmpl.Services))

	// Convert to GraphQL model
	return convertTemplateToGraphQL(tmpl), nil
}

// ImportServiceTemplate imports a service template from JSON
func (r *mutationResolver) ImportServiceTemplate(ctx context.Context, input model.ImportServiceTemplateInput) (*model.ServiceTemplate, error) {
	r.log.Infow("ImportServiceTemplate mutation called", "routerID", input.RouterID)

	// Validate inputs
	if input.RouterID == "" {
		return nil, apperrors.Wrap(nil, apperrors.CodeValidationFailed, apperrors.CategoryValidation, "router ID is required")
	}
	if len(input.TemplateData) == 0 {
		return nil, apperrors.Wrap(nil, apperrors.CodeValidationFailed, apperrors.CategoryValidation, "template data is required")
	}

	// Check if TemplateImporter is available
	if r.TemplateImporter == nil {
		return nil, apperrors.Wrap(nil, apperrors.CodeResourceNotFound, apperrors.CategoryInternal, "template importer not available")
	}

	// Convert template data map to JSON string
	templateJSON, err := json.Marshal(input.TemplateData)
	if err != nil {
		return nil, apperrors.Wrap(err, apperrors.CodeInvalidFormat, apperrors.CategoryValidation, "failed to marshal template data")
	}

	// Import template
	tmpl, err := r.TemplateImporter.ImportTemplate(ctx, templates.ImportTemplateRequest{
		RouterID:     input.RouterID,
		TemplateJSON: string(templateJSON),
	})

	if err != nil {
		r.log.Errorw("template import failed", "error", err)
		return nil, apperrors.Wrap(err, apperrors.CodeResourceNotFound, apperrors.CategoryInternal, "failed to import template")
	}

	r.log.Infow("template import completed",
		"templateID", tmpl.ID,
		"templateName", tmpl.Name)

	// Convert to GraphQL model
	return convertTemplateToGraphQL(tmpl), nil
}

// DeleteServiceTemplate deletes a user-created service template
func (r *mutationResolver) DeleteServiceTemplate(ctx context.Context, routerID string, templateID string) (bool, error) {
	r.log.Infow("DeleteServiceTemplate mutation called",
		"routerID", routerID,
		"templateID", templateID)

	// Validate inputs
	if routerID == "" {
		return false, apperrors.Wrap(nil, apperrors.CodeValidationFailed, apperrors.CategoryValidation, "router ID is required")
	}
	if templateID == "" {
		return false, apperrors.Wrap(nil, apperrors.CodeValidationFailed, apperrors.CategoryValidation, "template ID is required")
	}

	// Check if TemplateImporter is available
	if r.TemplateImporter == nil {
		return false, apperrors.Wrap(nil, apperrors.CodeResourceNotFound, apperrors.CategoryInternal, "template importer not available")
	}

	// Delete custom template (the importer will reject deletion of built-in templates)
	if err := r.TemplateImporter.DeleteCustomTemplate(ctx, routerID, templateID); err != nil {
		r.log.Errorw("template deletion failed", "error", err, "templateID", templateID)
		return false, apperrors.Wrap(err, apperrors.CodeResourceNotFound, apperrors.CategoryInternal, "failed to delete template")
	}

	r.log.Infow("template deletion completed", "templateID", templateID)
	return true, nil
}

// ServiceTemplates lists all service templates (built-in + user-created)
func (r *queryResolver) ServiceTemplates(ctx context.Context, routerID *string, category *model.ServiceTemplateCategory, scope *model.TemplateScope) ([]*model.ServiceTemplate, error) {
	r.log.Infow("ServiceTemplates query called",
		"routerID", routerID,
		"category", category,
		"scope", scope)

	// Check if ServiceTemplateService is available
	if r.ServiceTemplateService == nil {
		return nil, apperrors.Wrap(nil, apperrors.CodeResourceNotFound, apperrors.CategoryInternal, "template service not available")
	}

	// Convert GraphQL enums to Go types
	var goCategory *templates.TemplateCategory
	if category != nil {
		cat := templates.TemplateCategory(category.String())
		goCategory = &cat
	}

	var goScope *templates.TemplateScope
	if scope != nil {
		scp := templates.TemplateScope(scope.String())
		goScope = &scp
	}

	// Get templates from service
	templatesList, err := r.ServiceTemplateService.ListTemplates(ctx, goCategory, goScope)
	if err != nil {
		r.log.Errorw("failed to list templates", "error", err)
		return nil, apperrors.Wrap(err, apperrors.CodeResourceNotFound, apperrors.CategoryInternal, "failed to list templates")
	}

	// Convert to GraphQL model
	result := make([]*model.ServiceTemplate, len(templatesList))
	for i, tmpl := range templatesList {
		result[i] = convertTemplateToGraphQL(tmpl)
	}

	r.log.Infow("ServiceTemplates query completed", "count", len(result))
	return result, nil
}

// ServiceTemplate gets a specific template by ID
func (r *queryResolver) ServiceTemplate(ctx context.Context, id string) (*model.ServiceTemplate, error) {
	r.log.Infow("ServiceTemplate query called", "id", id)

	// Validate inputs
	if id == "" {
		return nil, apperrors.Wrap(nil, apperrors.CodeValidationFailed, apperrors.CategoryValidation, "template ID is required")
	}

	// Check if ServiceTemplateService is available
	if r.ServiceTemplateService == nil {
		return nil, apperrors.Wrap(nil, apperrors.CodeResourceNotFound, apperrors.CategoryInternal, "template service not available")
	}

	// Get template from service
	tmpl, err := r.ServiceTemplateService.GetTemplate(ctx, id)
	if err != nil {
		r.log.Errorw("failed to get template", "error", err, "id", id)
		return nil, apperrors.Wrap(err, apperrors.CodeResourceNotFound, apperrors.CategoryResource, "template not found")
	}

	result := convertTemplateToGraphQL(tmpl)
	r.log.Infow("ServiceTemplate query completed", "id", id)
	return result, nil
}

// TemplateInstallProgress subscribes to template installation progress
//
//nolint:gocyclo // resolver logic requires branching
func (r *subscriptionResolver) TemplateInstallProgress(ctx context.Context, routerID string) (<-chan *model.TemplateInstallProgress, error) {
	r.log.Infow("TemplateInstallProgress subscription started", "routerID", routerID)

	// Create channel for GraphQL subscription
	ch := make(chan *model.TemplateInstallProgress, 10)

	// Subscribe to template installation events from EventBus
	eventHandler := func(ctx context.Context, event events.Event) error {
		// Convert event to GraphQL model based on event type
		switch evt := event.(type) {
		case *events.TemplateInstallStartedEvent:
			if evt.RouterID != routerID {
				return nil // Skip events for other routers
			}

			now := time.Now()
			progress := &model.TemplateInstallProgress{
				TemplateID:     evt.TemplateID,
				TotalServices:  evt.TotalServices,
				InstalledCount: 0,
				Status:         model.TemplateInstallationStatusInProgress,
				StartedAt:      now,
			}

			select {
			case ch <- progress:
			case <-ctx.Done():
				return ctx.Err()
			}

		case *events.TemplateInstallProgressEvent:
			if evt.RouterID != routerID {
				return nil
			}

			currentSvc := evt.CurrentService
			progress := &model.TemplateInstallProgress{
				TemplateID:     evt.TemplateID,
				TotalServices:  evt.TotalServices,
				InstalledCount: evt.InstalledCount,
				CurrentService: &currentSvc,
				Status:         model.TemplateInstallationStatusInProgress,
				StartedAt:      evt.StartedAt,
			}

			select {
			case ch <- progress:
			case <-ctx.Done():
				return ctx.Err()
			}

		case *events.TemplateInstallCompletedEvent:
			if evt.RouterID != routerID {
				return nil
			}

			completedAt := evt.CompletedAt
			progress := &model.TemplateInstallProgress{
				TemplateID:     evt.TemplateID,
				TotalServices:  evt.TotalServices,
				InstalledCount: evt.InstalledCount,
				Status:         model.TemplateInstallationStatusCompleted,
				StartedAt:      evt.StartedAt,
				CompletedAt:    &completedAt,
			}

			select {
			case ch <- progress:
			case <-ctx.Done():
				return ctx.Err()
			}

			// Close channel after completion
			close(ch)

		case *events.TemplateInstallFailedEvent:
			if evt.RouterID != routerID {
				return nil
			}

			errMsg := evt.ErrorMessage
			failedAt := evt.FailedAt
			progress := &model.TemplateInstallProgress{
				TemplateID:     evt.TemplateID,
				TotalServices:  evt.TotalServices,
				InstalledCount: evt.InstalledCount,
				Status:         model.TemplateInstallationStatusFailed,
				ErrorMessage:   &errMsg,
				StartedAt:      evt.StartedAt,
				CompletedAt:    &failedAt,
			}

			select {
			case ch <- progress:
			case <-ctx.Done():
				return ctx.Err()
			}

			// Close channel after failure
			close(ch)
		}

		return nil
	}

	// Subscribe to event bus
	if r.EventBus != nil {
		if err := r.EventBus.SubscribeAll(eventHandler); err != nil {
			r.log.Errorw("failed to subscribe to template events", "error", err)
			close(ch)
			return nil, apperrors.Wrap(err, apperrors.CodeResourceNotFound, apperrors.CategoryInternal, "failed to subscribe to template events")
		}
	}

	// Cleanup when context is canceled
	go func() {
		<-ctx.Done()
		r.log.Infow("TemplateInstallProgress subscription ended", "routerID", routerID)
		close(ch)
	}()

	return ch, nil
}
