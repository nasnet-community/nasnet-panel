package resolver

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.86

import (
	"backend/graph/model"
	"backend/internal/events"
	"context"
	"time"
)

// UpdateProgress subscribes to real-time update progress events for a given instance.
func (r *subscriptionResolver) UpdateProgress(ctx context.Context, routerID string) (<-chan *model.UpdateProgress, error) {
	progressChan := make(chan *model.UpdateProgress, 10)

	// If no EventBus is available, fall back to a no-op subscription that just waits for context cancellation (canceled when context done).
	if r.EventBus == nil {
		go func() {
			<-ctx.Done()
			close(progressChan)
		}()
		return progressChan, nil
	}

	// handler converts a generic event into a model.UpdateProgress and sends it on the channel
	// if it matches the requested routerID (matched via event metadata).
	handler := func(eventCtx context.Context, event events.Event) error {
		// Filter by instance/router if we can extract it from metadata
		meta := event.GetSource()
		_ = meta // source is a string; no structured filter available without type assertion

		// Build the progress update
		progress := &model.UpdateProgress{
			InstanceID:  routerID, // use routerID as the correlation key
			FeatureID:   "",
			FromVersion: "",
			ToVersion:   "",
			Stage:       mapEventTypeToStage(event.GetType()),
			Progress:    mapEventTypeToProgress(event.GetType()),
			Message:     mapEventTypeToMessage(event.GetType()),
			Timestamp:   event.GetTimestamp(),
		}

		select {
		case progressChan <- progress:
		case <-ctx.Done():
			return nil
		default:
			// Channel full; drop to avoid blocking the event bus
		}
		return nil
	}

	// Subscribe to all update event types
	for _, eventType := range updateEventTypes {
		if err := r.EventBus.Subscribe(eventType, handler); err != nil {
			// Non-fatal: log and continue
			r.log.Infow("failed to subscribe to event type",
				"event_type", eventType,
				"error", err)
		}
	}

	// Send an initial "waiting" event so the client gets an immediate response
	initial := &model.UpdateProgress{
		InstanceID: routerID,
		FeatureID:  "",
		Stage:      model.UpdateStageStaging,
		Progress:   0,
		Message:    "Waiting for update to start",
		Timestamp:  time.Now(),
	}
	select {
	case progressChan <- initial:
	case <-ctx.Done():
		close(progressChan)
		return progressChan, nil
	}

	// Goroutine to close channel when context is canceled
	go func() {
		defer func() {
			if panicErr := recover(); panicErr != nil {
				// Log panic but don't crash service
				r.log.Errorw("panic in update progress subscription goroutine",
					"panic", panicErr)
			}
			close(progressChan)
		}()
		<-ctx.Done()
	}()

	return progressChan, nil
}
