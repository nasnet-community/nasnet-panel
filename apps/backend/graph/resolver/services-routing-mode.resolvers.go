package resolver

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.86

import (
	graphql1 "backend/graph/model"
	"backend/internal/apperrors"
	"context"
)

// SetupDualVLANBridge is the resolver for the setupDualVLANBridge field.
func (r *mutationResolver) SetupDualVLANBridge(ctx context.Context, input graphql1.SetupDualVLANBridgeInput) (*graphql1.VirtualInterface, error) {
	if r.BridgeOrchestrator == nil {
		return nil, apperrors.NewProtocolError(
			"BRIDGE_ORCHESTRATOR_NOT_INIT",
			"bridge orchestrator not initialized",
			"graphql",
		)
	}

	// Fetch service instance from database
	inst, err := r.db.ServiceInstance.Get(ctx, input.InstanceID)
	if err != nil {
		return nil, apperrors.Wrap(err, "INSTANCE_NOT_FOUND", apperrors.CategoryInternal, "failed to fetch service instance")
	}

	// Get feature manifest
	featureRegistry := r.FeatureRegistry
	if featureRegistry == nil {
		return nil, apperrors.NewProtocolError("FEATURE_REGISTRY_NOT_INIT", "feature registry not initialized", "graphql")
	}

	manifest, err := featureRegistry.GetManifest(inst.FeatureID)
	if err != nil {
		return nil, apperrors.Wrap(err, "MANIFEST_NOT_FOUND", apperrors.CategoryInternal, "failed to fetch feature manifest")
	}

	// Call BridgeOrchestrator
	bridgeName := ""
	if input.BridgeName.IsSet() {
		if v := input.BridgeName.Value(); v != nil {
			bridgeName = *v
		}
	}

	vif, err := r.BridgeOrchestrator.SetupDualVLANBridge(ctx, inst, manifest, input.EgressVlanIds, bridgeName)
	if err != nil {
		wrappedErr := apperrors.Wrap(err, "SETUP_DUAL_VLAN_BRIDGE_FAILED", apperrors.CategoryInternal, "failed to setup dual-VLAN bridge")
		return nil, wrappedErr
	}

	// Convert ent model to GraphQL model
	if vif == nil {
		return nil, apperrors.NewProtocolError("VIF_CONVERSION_FAILED", "virtual interface is nil", "graphql")
	}

	return convertEntVIFToGraphQL(vif), nil
}

// TeardownDualVLANBridge is the resolver for the teardownDualVLANBridge field.
func (r *mutationResolver) TeardownDualVLANBridge(ctx context.Context, instanceID string) (bool, error) {
	if r.BridgeOrchestrator == nil {
		return false, apperrors.NewProtocolError("BRIDGE_ORCHESTRATOR_NOT_INIT", "bridge orchestrator not initialized", "graphql")
	}

	err := r.BridgeOrchestrator.TeardownDualVLANBridge(ctx, instanceID)
	if err != nil {
		wrappedErr := apperrors.Wrap(err, "TEARDOWN_DUAL_VLAN_BRIDGE_FAILED", apperrors.CategoryInternal, "failed to teardown dual-VLAN bridge")
		return false, wrappedErr
	}

	return true, nil
}

// AddIngressToBridge is the resolver for the addIngressToBridge field.
func (r *mutationResolver) AddIngressToBridge(ctx context.Context, vlanID int, bridgeName string) (bool, error) {
	if r.IngressService == nil {
		return false, apperrors.NewProtocolError("INGRESS_SERVICE_NOT_INIT", "ingress service not initialized", "graphql")
	}

	err := r.IngressService.AddToBridge(ctx, vlanID, bridgeName)
	if err != nil {
		wrappedErr := apperrors.Wrap(err, "ADD_INGRESS_TO_BRIDGE_FAILED", apperrors.CategoryInternal, "failed to add ingress VLAN to bridge")
		return false, wrappedErr
	}

	return true, nil
}

// RemoveIngressFromBridge is the resolver for the removeIngressFromBridge field.
func (r *mutationResolver) RemoveIngressFromBridge(ctx context.Context, vlanID int) (bool, error) {
	if r.IngressService == nil {
		return false, apperrors.NewProtocolError("INGRESS_SERVICE_NOT_INIT", "ingress service not initialized", "graphql")
	}

	err := r.IngressService.RemoveFromBridge(ctx, vlanID)
	if err != nil {
		wrappedErr := apperrors.Wrap(err, "REMOVE_INGRESS_FROM_BRIDGE_FAILED", apperrors.CategoryInternal, "failed to remove ingress VLAN from bridge")
		return false, wrappedErr
	}

	return true, nil
}
