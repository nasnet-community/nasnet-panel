package resolver

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.86

import (
	"backend/generated/ent/serviceinstance"
	graphql1 "backend/graph/model"
	"backend/internal/apperrors"
	"backend/internal/orchestrator/resources"
	"context"

	"go.uber.org/zap"
)

// SystemResources is the resolver for the systemResources field.
// Returns system-wide memory statistics including total RAM, available RAM, allocated RAM,
// and per-instance resource usage for all running service instances.
// Actual resource usage is read from cgroups if available (Linux only); otherwise synthesized from limits.
//
//nolint:gocyclo // complex logic required for resource resolution
func (r *queryResolver) SystemResources(ctx context.Context, routerID string) (*graphql1.SystemResources, error) {
	if r.db == nil {
		return nil, apperrors.NewResourceError(apperrors.CodeResourceNotFound, "database not available", "service", "database")
	}

	// Get running service instances from database
	instances, err := r.db.ServiceInstance.
		Query().
		Where(serviceinstance.StatusEQ(serviceinstance.StatusRunning)).
		All(ctx)
	if err != nil {
		return nil, apperrors.Wrap(err, apperrors.CodeCommandFailed, apperrors.CategoryProtocol, "failed to query running instances")
	}

	// Build per-instance resource usage list
	instanceUsages := make([]*graphql1.InstanceResourceUsage, 0, len(instances))
	var totalAllocatedRAM int

	limiter := r.ResourceLimiter

	for _, inst := range instances {
		// Convert memory_limit from bytes to MB
		limitMB := 0
		if inst.MemoryLimit != nil {
			limitMB = int(*inst.MemoryLimit / (1024 * 1024))
		}
		totalAllocatedRAM += limitMB

		// Try to read actual usage via ResourceLimiter (Linux only, may be nil)
		var usage *graphql1.ResourceUsage
		//nolint:nestif // nested conditions required for feature logic
		if limiter != nil {
			// ResourceLimiter.GetResourceUsage requires a PID which is runtime state.
			// We attempt to find the process via the supervisor if available.
			pid := 0
			if r.InstanceManager != nil {
				sup := r.InstanceManager.Supervisor()
				if sup != nil {
					if proc, ok := sup.Get(inst.ID); ok {
						pid = proc.GetPID()
					}
				}
			}

			if pid > 0 {
				if ru, ruErr := limiter.GetResourceUsage(pid); ruErr == nil {
					currentMB := int(ru.MemoryMB)
					usagePct := 0.0
					if limitMB > 0 {
						usagePct = float64(currentMB) / float64(limitMB) * 100
					}

					status := graphql1.ResourceStatusOk
					if usagePct >= 90 {
						status = graphql1.ResourceStatusCritical
					} else if usagePct >= 80 {
						status = graphql1.ResourceStatusWarning
					}

					usage = &graphql1.ResourceUsage{
						CurrentMb:    currentMB,
						LimitMb:      limitMB,
						UsagePercent: usagePct,
						Status:       status,
					}
				}
			}
		}

		// If we couldn't read actual usage, synthesize from limit
		if usage == nil {
			usage = &graphql1.ResourceUsage{
				CurrentMb:    0,
				LimitMb:      limitMB,
				UsagePercent: 0,
				Status:       graphql1.ResourceStatusOk,
			}
		}

		instanceUsages = append(instanceUsages, &graphql1.InstanceResourceUsage{
			InstanceID:   inst.ID,
			InstanceName: inst.InstanceName,
			FeatureID:    inst.FeatureID,
			Usage:        usage,
		})
	}

	// Get system-wide memory info via ResourceManager
	totalRAM := resources.DefaultSystemMemoryMB
	availableRAM := resources.DefaultAvailableMemoryMB

	rm, rmErr := resources.NewResourceManager(resources.ResourceManagerConfig{
		Store:  r.db,
		Logger: zap.NewNop(),
	})
	if rmErr == nil {
		if sysRes, sysErr := rm.GetSystemResources(ctx); sysErr == nil {
			totalRAM = sysRes.TotalMemoryMB
			availableRAM = sysRes.AvailableMemoryMB
		}
	}

	return &graphql1.SystemResources{
		TotalRAM:     totalRAM,
		AvailableRAM: availableRAM,
		AllocatedRAM: totalAllocatedRAM,
		Instances:    instanceUsages,
	}, nil
}

// ResourceUsageChanged is the resolver for the resourceUsageChanged field.
// Subscribes to real-time resource usage changes for a specific service instance.
// Emits ResourceUsage events whenever memory usage crosses significant thresholds.
// TODO(NAS-8.19): Implement event bus integration for resource usage notifications.
// Requires: EventBus subscription to resource usage events filtered by routerID and instanceID.
func (r *subscriptionResolver) ResourceUsageChanged(ctx context.Context, routerID string, instanceID string) (<-chan *graphql1.ResourceUsage, error) {
	return nil, apperrors.NewResourceError(apperrors.CodeInvalidStateTransition, "resource usage subscription not yet implemented", "feature", "subscription")
}
