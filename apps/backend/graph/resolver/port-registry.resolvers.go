package resolver

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.86

import (
	graphql1 "backend/graph/model"
	"backend/internal/errors"
	"backend/internal/network"
	"context"
	"time"
)

// CleanupOrphanedPorts is the resolver for the cleanupOrphanedPorts field.
// Detects and removes orphaned port allocations for a router.
// Orphaned ports are those allocated to service instances that no longer exist.
// If routerID is not provided, returns empty payload (per-router cleanup required).
func (r *mutationResolver) CleanupOrphanedPorts(ctx context.Context, input graphql1.CleanupOrphanedPortsInput) (*graphql1.OrphanCleanupPayload, error) {
	if r.PortRegistry == nil {
		return nil, errors.NewValidationError("portRegistry", "[REDACTED]", "unavailable")
	}

	routerID := ""
	if input.RouterID.IsSet() && input.RouterID.Value() != nil {
		routerID = *input.RouterID.Value()
	}

	if routerID == "" {
		// No routerID: per-router cleanup required; return empty payload without error.
		return &graphql1.OrphanCleanupPayload{
			CleanedCount:         0,
			DeletedAllocationIDs: []string{},
		}, nil
	}

	// Detect orphans first to collect IDs before deletion
	orphans, err := r.PortRegistry.DetectOrphans(ctx, routerID)
	if err != nil {
		return nil, errors.Wrap(err, errors.CodeProtocolError, errors.CategoryProtocol, "failed to detect orphaned ports")
	}

	// Collect orphaned allocation IDs
	deletedIDs := make([]string, 0, len(orphans))
	for _, o := range orphans {
		deletedIDs = append(deletedIDs, o.GetID())
	}

	// Perform cleanup
	cleaned, err := r.PortRegistry.CleanupOrphans(ctx, routerID)
	if err != nil {
		return nil, errors.Wrap(err, errors.CodeProtocolError, errors.CategoryProtocol, "failed to cleanup orphaned ports")
	}

	// deletedIDs is always initialized above, but ensure empty slice is returned (not nil)
	if len(deletedIDs) == 0 {
		deletedIDs = []string{}
	}

	return &graphql1.OrphanCleanupPayload{
		CleanedCount:         cleaned,
		DeletedAllocationIDs: deletedIDs,
	}, nil
}

// PortAllocations is the resolver for the portAllocations field.
// Returns port allocations for a specific router, with optional filtering by protocol and service type.
// If routerID is not provided, returns an empty list (per-router queries required).
func (r *queryResolver) PortAllocations(ctx context.Context, routerID *string, protocol *graphql1.PortProtocol, serviceType *string) ([]*graphql1.PortAllocation, error) {
	if r.PortRegistry == nil {
		return nil, errors.NewValidationError("portRegistry", "[REDACTED]", "unavailable")
	}

	if routerID == nil || *routerID == "" {
		// PortRegistry only supports per-router queries; return empty list without routerID.
		return []*graphql1.PortAllocation{}, nil
	}

	entities, err := r.PortRegistry.GetAllocationsByRouter(ctx, *routerID)
	if err != nil {
		return nil, errors.Wrap(err, errors.CodeProtocolError, errors.CategoryProtocol, "failed to list port allocations")
	}

	results := make([]*graphql1.PortAllocation, 0, len(entities))
	for _, entity := range entities {
		// Apply protocol filter
		if protocol != nil && graphql1.PortProtocol(entity.GetProtocol()) != *protocol {
			continue
		}

		// Apply serviceType filter using the extended interface if available
		if serviceType != nil {
			ext, ok := entity.(portEntityExtended)
			if !ok || ext.GetServiceType() != *serviceType {
				// Skip: extended interface not available or service type doesn't match
				continue
			}
		}

		alloc := entityToPortAllocation(entity)
		results = append(results, alloc)
	}

	return results, nil
}

// IsPortAvailable is the resolver for the isPortAvailable field.
// Validates port range (1-65535) and checks if the port is available on the specified router.
// Note: Privileged ports (<1024) may require elevated permissions on the router.
func (r *queryResolver) IsPortAvailable(ctx context.Context, input graphql1.CheckPortAvailabilityInput) (*graphql1.PortAvailability, error) {
	if r.PortRegistry == nil {
		return nil, errors.NewValidationError("portRegistry", "[REDACTED]", "unavailable")
	}

	// Validate input parameters
	if input.RouterID == "" {
		return nil, errors.NewValidationError("routerID", "[REDACTED]", "required")
	}

	if input.Port <= 0 || input.Port > 65535 {
		return nil, errors.NewValidationError("port", "[REDACTED]", "must be between 1 and 65535")
	}

	protocol := string(input.Protocol)
	if protocol == "" {
		return nil, errors.NewValidationError("protocol", "[REDACTED]", "required")
	}

	// Check port availability
	available := r.PortRegistry.IsPortAvailable(ctx, input.RouterID, input.Port, protocol)

	result := &graphql1.PortAvailability{
		Port:      input.Port,
		Protocol:  input.Protocol,
		Available: available,
	}

	// Provide reason if port is not available
	if !available {
		reason := "port is already allocated or reserved"
		result.Reason = &reason
	}

	return result, nil
}

// DetectOrphanedPorts is the resolver for the detectOrphanedPorts field.
// Scans port allocations and identifies orphaned ports whose associated service instances
// no longer exist or are marked for deletion. If routerID is not provided, returns empty list.
func (r *queryResolver) DetectOrphanedPorts(ctx context.Context, routerID *string) ([]*graphql1.OrphanedPort, error) {
	if r.PortRegistry == nil {
		return nil, errors.NewValidationError("portRegistry", "[REDACTED]", "unavailable")
	}

	rid := ""
	if routerID != nil {
		rid = *routerID
	}

	orphans, err := r.PortRegistry.DetectOrphans(ctx, rid)
	if err != nil {
		return nil, errors.Wrap(err, errors.CodeProtocolError, errors.CategoryProtocol, "failed to detect orphaned ports")
	}

	results := make([]*graphql1.OrphanedPort, 0, len(orphans))
	for _, orphan := range orphans {
		results = append(results, &graphql1.OrphanedPort{
			Allocation: entityToPortAllocation(orphan),
			Reason:     "service instance not found or is being deleted",
		})
	}

	return results, nil
}

type portEntityExtended interface {
	network.PortAllocationEntity
	GetServiceType() string
	GetNotes() string
	GetAllocatedAt() time.Time
}

func entityToPortAllocation(entity network.PortAllocationEntity) *graphql1.PortAllocation {
	allocatedAt := time.Now()

	alloc := &graphql1.PortAllocation{
		ID:          entity.GetID(),
		RouterID:    entity.GetRouterID(),
		Port:        entity.GetPort(),
		Protocol:    graphql1.PortProtocol(entity.GetProtocol()),
		InstanceID:  entity.GetInstanceID(),
		AllocatedAt: allocatedAt,
	}

	// Check for extended interface with optional fields
	if ext, ok := entity.(portEntityExtended); ok {
		alloc.ServiceType = ext.GetServiceType()
		// Use the actual allocation time from the entity if available
		if actualTime := ext.GetAllocatedAt(); !actualTime.IsZero() {
			alloc.AllocatedAt = actualTime
		}
		// Only set notes if they are provided
		if notes := ext.GetNotes(); notes != "" {
			n := notes
			alloc.Notes = &n
		}
	}

	return alloc
}
