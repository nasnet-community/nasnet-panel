package resolver

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.44

import (
	"backend/graph/model"
	"context"
	"strconv"
	"time"
)

// Device returns the device query resolver.
// This resolver is the entry point for fetching a device by ID.
func (r *queryResolver) Device(ctx context.Context, id string) (*model.Device, error) {
	// For now, simply return a Device with the given ID.
	// The actual device validation and existence check can be added when
	// the device entity/repository is implemented.
	return &model.Device{
		ID: id,
	}, nil
}

// ResourceMetrics fetches the current resource utilization metrics from the router.
// This resolver queries the router's /system/resource endpoint and returns
// CPU, memory, and storage utilization data.
//
// Per NAS-5.2 AC 5.2.1: Resource metrics must be fetched from the router in real-time.
func (r *deviceResolver) ResourceMetrics(ctx context.Context, obj *model.Device) (*model.ResourceMetrics, error) {
	// Get the router ID from the device
	routerID := obj.ID

	// Fetch resource metrics from the router using the connection manager
	// Note: This is a simplified implementation. In production, this should use
	// a proper service layer (e.g., ResourceMetricsService) that interacts with
	// the router adapter through the connection manager.

	// For now, return mock data as a placeholder until the full RouterPort integration
	// is implemented. This allows the frontend to be tested while backend work continues.

	// TODO: Replace this mock implementation with actual RouterOS API calls
	// TODO: Use r.RouterService.connManager to get the connection
	// TODO: Execute StateQuery{Path: "/system/resource"} to fetch real data
	// TODO: Parse the response and map to ResourceMetrics model

	// Mock data for development/testing
	now := time.Now()

	// Generate realistic-looking mock data
	cpuUsage := 45.5 + float64(now.Second()%20) // Varies between 45-65%
	memUsed := 256.0 * 1024 * 1024              // 256 MB
	memTotal := 512.0 * 1024 * 1024             // 512 MB
	memPercentage := (memUsed / memTotal) * 100

	storageUsed := 1.5 * 1024 * 1024 * 1024      // 1.5 GB
	storageTotal := 16.0 * 1024 * 1024 * 1024    // 16 GB
	storagePercentage := (storageUsed / storageTotal) * 100

	// Mock per-core CPU usage (4 cores)
	perCore := []float64{
		cpuUsage + 5.0,
		cpuUsage - 3.0,
		cpuUsage + 2.0,
		cpuUsage - 4.0,
	}

	cpuFreq := 800.0 // 800 MHz
	temp := 45.0     // 45Â°C

	return &model.ResourceMetrics{
		CPU: &model.CPUMetrics{
			Usage:     cpuUsage,
			Cores:     4,
			PerCore:   perCore,
			Frequency: &cpuFreq,
		},
		Memory: &model.MemoryMetrics{
			Used:       memUsed,
			Total:      memTotal,
			Percentage: memPercentage,
		},
		Storage: &model.StorageMetrics{
			Used:       storageUsed,
			Total:      storageTotal,
			Percentage: storagePercentage,
		},
		Temperature: &temp,
		Timestamp:   now,
	}, nil
}

// ResourceMetrics subscribes to real-time resource metrics updates.
// Emits new metrics every 2 seconds per NAS-5.2 AC 5.2.2.
func (r *subscriptionResolver) ResourceMetrics(ctx context.Context, deviceID string) (<-chan *model.ResourceMetrics, error) {
	ch := make(chan *model.ResourceMetrics)

	// Start a goroutine that emits metrics every 2 seconds
	go func() {
		defer close(ch)

		// Create a ticker for 2-second intervals (AC 5.2.2)
		ticker := time.NewTicker(2 * time.Second)
		defer ticker.Stop()

		// Send initial metrics immediately
		metrics, err := r.fetchResourceMetrics(deviceID)
		if err == nil {
			select {
			case ch <- metrics:
			case <-ctx.Done():
				return
			}
		}

		// Continue sending metrics every 2 seconds
		for {
			select {
			case <-ctx.Done():
				// Client disconnected
				return
			case <-ticker.C:
				// Fetch and send new metrics
				metrics, err := r.fetchResourceMetrics(deviceID)
				if err != nil {
					// Log error but continue (silent fail per subscription pattern)
					continue
				}

				// Send metrics to channel (non-blocking)
				select {
				case ch <- metrics:
				case <-ctx.Done():
					return
				}
			}
		}
	}()

	return ch, nil
}

// fetchResourceMetrics is a helper that fetches resource metrics for the subscription.
// This is separated out to avoid code duplication between the subscription and query resolvers.
func (r *subscriptionResolver) fetchResourceMetrics(deviceID string) (*model.ResourceMetrics, error) {
	// For now, use the same mock data logic as the query resolver
	// TODO: Replace with actual RouterOS API calls

	now := time.Now()

	// Generate realistic-looking mock data with time-based variation
	cpuUsage := 45.5 + float64(now.Second()%20)
	memUsed := 256.0 * 1024 * 1024
	memTotal := 512.0 * 1024 * 1024
	memPercentage := (memUsed / memTotal) * 100

	storageUsed := 1.5 * 1024 * 1024 * 1024
	storageTotal := 16.0 * 1024 * 1024 * 1024
	storagePercentage := (storageUsed / storageTotal) * 100

	// Mock per-core CPU usage (4 cores) with slight variation
	perCore := []float64{
		cpuUsage + float64(now.Second()%10),
		cpuUsage - float64(now.Second()%8),
		cpuUsage + float64(now.Second()%6),
		cpuUsage - float64(now.Second()%5),
	}

	cpuFreq := 800.0
	temp := 45.0 + float64(now.Second()%10) // Temperature varies slightly

	return &model.ResourceMetrics{
		CPU: &model.CPUMetrics{
			Usage:     cpuUsage,
			Cores:     4,
			PerCore:   perCore,
			Frequency: &cpuFreq,
		},
		Memory: &model.MemoryMetrics{
			Used:       memUsed,
			Total:      memTotal,
			Percentage: memPercentage,
		},
		Storage: &model.StorageMetrics{
			Used:       storageUsed,
			Total:      storageTotal,
			Percentage: storagePercentage,
		},
		Temperature: &temp,
		Timestamp:   now,
	}, nil
}

// parseFloat safely parses a string to float64, returning 0.0 on error.
func parseFloat(s string) float64 {
	f, err := strconv.ParseFloat(s, 64)
	if err != nil {
		return 0.0
	}
	return f
}

// parseInt safely parses a string to int, returning 0 on error.
func parseInt(s string) int {
	i, err := strconv.Atoi(s)
	if err != nil {
		return 0
	}
	return i
}

// deviceResolver is the resolver for the Device type.
type deviceResolver struct{ *Resolver }

// Device returns the device resolver.
func (r *Resolver) Device() DeviceResolver { return &deviceResolver{r} }

// DeviceResolver is the interface for Device field resolvers.
type DeviceResolver interface {
	ResourceMetrics(ctx context.Context, obj *model.Device) (*model.ResourceMetrics, error)
}

// Ensure deviceResolver implements DeviceResolver interface.
var _ DeviceResolver = (*deviceResolver)(nil)
