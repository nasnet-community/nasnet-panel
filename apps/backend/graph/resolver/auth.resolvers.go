package resolver

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.44

import (
	"backend/graph/model"
	"backend/internal/auth"
	"backend/internal/middleware"
	"context"
)

// Login is the resolver for the login mutation
func (r *mutationResolver) Login(ctx context.Context, username string, password string) (*model.AuthPayload, error) {
	if r.authService == nil {
		return nil, newGQLError("AUTH.NOT_CONFIGURED", "Authentication service not configured")
	}

	// Get request metadata
	ip := getClientIP(ctx)
	userAgent := getUserAgent(ctx)

	// Attempt login
	result, err := r.authService.Login(ctx, auth.LoginInput{
		Username:  username,
		Password:  password,
		IP:        ip,
		UserAgent: userAgent,
	})
	if err != nil {
		// Return generic error to prevent user enumeration
		return nil, newGQLError(auth.ErrCodeInvalidCredentials, "Invalid username or password")
	}

	// Convert to GraphQL types
	return &model.AuthPayload{
		Token:     result.Token,
		User:      convertToGraphQLUser(result.User),
		ExpiresAt: result.ExpiresAt,
	}, nil
}

// Logout is the resolver for the logout mutation
func (r *mutationResolver) Logout(ctx context.Context) (bool, error) {
	user := middleware.UserFromContext(ctx)
	if user == nil {
		return false, newGQLError(auth.ErrCodeInvalidCredentials, "Not authenticated")
	}

	session := middleware.SessionFromContext(ctx)
	if session == nil {
		return true, nil // Already logged out
	}

	if r.authService == nil {
		return false, newGQLError("AUTH.NOT_CONFIGURED", "Authentication service not configured")
	}

	ip := getClientIP(ctx)
	userAgent := getUserAgent(ctx)

	err := r.authService.Logout(ctx, session.ID, ip, userAgent)
	if err != nil {
		return false, err
	}

	return true, nil
}

// ChangePassword is the resolver for the changePassword mutation
func (r *mutationResolver) ChangePassword(ctx context.Context, currentPassword string, newPassword string) (bool, error) {
	user := middleware.UserFromContext(ctx)
	if user == nil {
		return false, newGQLError(auth.ErrCodeInvalidCredentials, "Not authenticated")
	}

	if r.authService == nil {
		return false, newGQLError("AUTH.NOT_CONFIGURED", "Authentication service not configured")
	}

	// Validate new password against policy
	if err := r.authService.ValidatePassword(newPassword); err != nil {
		return false, newGQLError(auth.ErrCodePasswordTooShort, err.Error())
	}

	session := middleware.SessionFromContext(ctx)
	currentSessionID := ""
	if session != nil {
		currentSessionID = session.ID
	}

	ip := getClientIP(ctx)
	userAgent := getUserAgent(ctx)

	err := r.authService.ChangePassword(ctx, auth.ChangePasswordInput{
		UserID:          user.ID,
		CurrentPassword: currentPassword,
		NewPassword:     newPassword,
		CurrentSession:  currentSessionID,
		IP:              ip,
		UserAgent:       userAgent,
	})
	if err != nil {
		if err == auth.ErrPasswordMismatch {
			return false, newGQLError(auth.ErrCodePasswordMismatch, "Current password is incorrect")
		}
		return false, newGQLError("AUTH.PASSWORD_CHANGE_FAILED", err.Error())
	}

	return true, nil
}

// RevokeAllSessions is the resolver for the revokeAllSessions mutation
func (r *mutationResolver) RevokeAllSessions(ctx context.Context, userID string) (bool, error) {
	user := middleware.UserFromContext(ctx)
	if user == nil {
		return false, newGQLError(auth.ErrCodeInvalidCredentials, "Not authenticated")
	}

	// Check admin role
	if user.Role != auth.RoleAdmin {
		return false, newGQLError(auth.ErrCodeInsufficientRole, "Admin access required")
	}

	if r.authService == nil {
		return false, newGQLError("AUTH.NOT_CONFIGURED", "Authentication service not configured")
	}

	ip := getClientIP(ctx)
	userAgent := getUserAgent(ctx)

	err := r.authService.RevokeAllSessions(ctx, userID, user.ID, ip, userAgent)
	if err != nil {
		return false, err
	}

	return true, nil
}

// RevokeSession is the resolver for the revokeSession mutation
func (r *mutationResolver) RevokeSession(ctx context.Context, sessionID string) (bool, error) {
	user := middleware.UserFromContext(ctx)
	if user == nil {
		return false, newGQLError(auth.ErrCodeInvalidCredentials, "Not authenticated")
	}

	if r.authService == nil {
		return false, newGQLError("AUTH.NOT_CONFIGURED", "Authentication service not configured")
	}

	ip := getClientIP(ctx)
	userAgent := getUserAgent(ctx)

	// Get the session to verify ownership
	sessions, err := r.authService.GetUserSessions(ctx, user.ID)
	if err != nil {
		return false, err
	}

	// Check if the session belongs to the user
	found := false
	for _, s := range sessions {
		if s.ID == sessionID {
			found = true
			break
		}
	}

	// If not found and not admin, deny
	if !found && user.Role != auth.RoleAdmin {
		return false, newGQLError(auth.ErrCodeInsufficientRole, "Cannot revoke sessions for other users")
	}

	err = r.authService.Logout(ctx, sessionID, ip, userAgent)
	if err != nil {
		return false, err
	}

	return true, nil
}

// Me is the resolver for the me query
func (r *queryResolver) Me(ctx context.Context) (*model.User, error) {
	user := middleware.UserFromContext(ctx)
	if user == nil {
		return nil, nil // Return nil, not error, for unauthenticated
	}

	if r.authService == nil {
		return nil, newGQLError("AUTH.NOT_CONFIGURED", "Authentication service not configured")
	}

	// Get full user from database
	fullUser, err := r.authService.GetCurrentUser(ctx, user.ID)
	if err != nil {
		return nil, err
	}

	return convertToGraphQLUser(fullUser), nil
}

// MySessions is the resolver for the mySessions query
func (r *queryResolver) MySessions(ctx context.Context) ([]*model.Session, error) {
	user := middleware.UserFromContext(ctx)
	if user == nil {
		return nil, newGQLError(auth.ErrCodeInvalidCredentials, "Not authenticated")
	}

	if r.authService == nil {
		return nil, newGQLError("AUTH.NOT_CONFIGURED", "Authentication service not configured")
	}

	sessions, err := r.authService.GetUserSessions(ctx, user.ID)
	if err != nil {
		return nil, err
	}

	// Get current session ID to mark it
	currentSession := middleware.SessionFromContext(ctx)
	currentSessionID := ""
	if currentSession != nil {
		currentSessionID = currentSession.ID
	}

	result := make([]*model.Session, len(sessions))
	for i, s := range sessions {
		result[i] = &model.Session{
			ID:           s.ID,
			IPAddress:    stringPtr(s.IPAddress),
			UserAgent:    stringPtr(s.UserAgent),
			CreatedAt:    s.CreatedAt,
			LastActivity: s.LastActivity,
			IsCurrent:    s.ID == currentSessionID,
		}
	}

	return result, nil
}

// !!! WARNING !!!
// The code below was going to be deleted when updating resolvers. It has been copied here so you have
// one last chance to move it out of harms way if you want. There are two reasons this happens:
//   - When renaming or deleting a resolver the old code will be put in here. You can safely delete
//     it when you're done.
//   - You have helper methods in this file. Move them out to keep these resolver files clean.
func convertToGraphQLUser(u *auth.User) *model.User {
	return &model.User{
		ID:          u.ID,
		Username:    u.Username,
		Role:        convertRole(u.Role),
		Email:       stringPtr(u.Email),
		DisplayName: stringPtr(u.DisplayName),
		CreatedAt:   u.CreatedAt,
		LastLoginAt: u.LastLogin,
	}
}
func convertRole(r auth.Role) model.UserRole {
	switch r {
	case auth.RoleAdmin:
		return model.UserRoleAdmin
	case auth.RoleOperator:
		return model.UserRoleOperator
	default:
		return model.UserRoleViewer
	}
}
func stringPtr(s string) *string {
	if s == "" {
		return nil
	}
	return &s
}

type gqlError struct {
	*model.MutationError
}

func (e *gqlError) Error() string {
	return e.Message
}
func newGQLError(code, message string) error {
	return &gqlError{&model.MutationError{Code: code, Message: message}}
}
func getClientIP(ctx context.Context) string {
	// Try to get from context (set by middleware)
	if ip, ok := ctx.Value("client_ip").(string); ok {
		return ip
	}
	return "unknown"
}
func getUserAgent(ctx context.Context) string {
	// Try to get from context (set by middleware)
	if ua, ok := ctx.Value("user_agent").(string); ok {
		return ua
	}
	return "unknown"
}
