package resolver

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.86

import (
	"backend/graph/model"
	"backend/internal/apperrors"
	"backend/internal/auth"
	"context"
)

// Login is the resolver for the login field.
func (r *mutationResolver) Login(ctx context.Context, username string, password string) (*model.AuthPayload, error) {
	if r.authService == nil {
		return nil, apperrors.NewProtocolError(apperrors.CodeCommandFailed, "auth service not configured", "graphql")
	}

	if username == "" || password == "" {
		return nil, apperrors.NewValidationError("credentials", "", "username and password are required")
	}

	// Get client info from context
	ip, ua := getClientInfoFromContext(ctx)

	// Login through auth service (never log passwords)
	result, err := r.authService.Login(ctx, auth.LoginInput{
		Username:  username,
		Password:  password,
		IP:        ip,
		UserAgent: ua,
	})
	if err != nil {
		// Don't expose auth error details to client
		return nil, apperrors.NewValidationError("authentication", "", "authentication failed")
	}

	if result == nil || result.Token == "" {
		return nil, apperrors.NewProtocolError(apperrors.CodeCommandFailed, "failed to generate authentication token", "graphql")
	}

	return &model.AuthPayload{
		Token: result.Token,
		User: &model.User{
			ID:       result.User.ID,
			Username: result.User.Username,
		},
	}, nil
}

// Logout is the resolver for the logout field.
func (r *mutationResolver) Logout(ctx context.Context) (bool, error) {
	if r.authService == nil {
		return false, apperrors.NewProtocolError(apperrors.CodeCommandFailed, "auth service not configured", "graphql")
	}

	// Extract session ID from context
	sessionID, err := getSessionIDFromContext(ctx)
	if err != nil {
		return false, err
	}

	// Get client info from context
	ip, ua := getClientInfoFromContext(ctx)

	// Logout through auth service
	if err := r.authService.Logout(ctx, sessionID, ip, ua); err != nil {
		return false, apperrors.Wrap(err, apperrors.CodeProtocolError, apperrors.CategoryProtocol, "logout failed")
	}

	return true, nil
}

// ChangePassword is the resolver for the changePassword field.
func (r *mutationResolver) ChangePassword(ctx context.Context, currentPassword string, newPassword string) (bool, error) {
	if r.authService == nil {
		return false, apperrors.NewProtocolError(apperrors.CodeCommandFailed, "auth service not configured", "graphql")
	}

	// Extract user ID and session ID from context
	userID, err := getUserIDFromContext(ctx)
	if err != nil {
		return false, err
	}

	sessionID, err := getSessionIDFromContext(ctx)
	if err != nil {
		return false, err
	}

	// Validate passwords
	if currentPassword == "" || newPassword == "" {
		return false, apperrors.NewValidationError("passwords", "", "current and new passwords are required")
	}

	if currentPassword == newPassword {
		return false, apperrors.NewValidationError("newPassword", "", "new password must differ from current password")
	}

	// Validate new password policy
	if err := r.authService.ValidatePassword(newPassword); err != nil {
		return false, apperrors.Wrap(err, apperrors.CodeProtocolError, apperrors.CategoryProtocol, "new password does not meet policy requirements")
	}

	// Get client info from context
	ip, ua := getClientInfoFromContext(ctx)

	// Change password through auth service
	if err := r.authService.ChangePassword(ctx, auth.ChangePasswordInput{
		UserID:          userID,
		CurrentPassword: currentPassword,
		NewPassword:     newPassword,
		CurrentSession:  sessionID,
		IP:              ip,
		UserAgent:       ua,
	}); err != nil {
		return false, apperrors.Wrap(err, apperrors.CodeProtocolError, apperrors.CategoryProtocol, "password change failed")
	}

	return true, nil
}

// RevokeAllSessions is the resolver for the revokeAllSessions field.
func (r *mutationResolver) RevokeAllSessions(ctx context.Context, userID string) (bool, error) {
	if r.authService == nil {
		return false, apperrors.NewProtocolError(apperrors.CodeCommandFailed, "auth service not configured", "graphql")
	}

	if userID == "" {
		return false, apperrors.NewValidationError("userID", userID, "user ID is required")
	}

	// Extract current user ID from context for authorization check
	currentUserID, err := getUserIDFromContext(ctx)
	if err != nil {
		return false, err
	}

	// Only allow users to revoke their own sessions
	// TODO: Admin override should check admin role from context
	if currentUserID != userID {
		return false, apperrors.NewValidationError("authorization", userID, "unauthorized: can only revoke your own sessions")
	}

	// Get client info from context
	ip, ua := getClientInfoFromContext(ctx)

	// Revoke all sessions for the user
	if err := r.authService.RevokeAllSessions(ctx, userID, currentUserID, ip, ua); err != nil {
		return false, apperrors.Wrap(err, apperrors.CodeProtocolError, apperrors.CategoryProtocol, "revoke all sessions failed")
	}

	return true, nil
}

// RevokeSession is the resolver for the revokeSession field.
func (r *mutationResolver) RevokeSession(ctx context.Context, sessionID string) (bool, error) {
	if r.authService == nil {
		return false, apperrors.NewProtocolError(apperrors.CodeCommandFailed, "auth service not configured", "graphql")
	}

	if sessionID == "" {
		return false, apperrors.NewValidationError("sessionID", sessionID, "session ID is required")
	}

	ip, ua := getClientInfoFromContext(ctx)
	// Use Logout to revoke the specific session (marks it as revoked)
	if err := r.authService.Logout(ctx, sessionID, ip, ua); err != nil {
		return false, apperrors.Wrap(err, apperrors.CodeProtocolError, apperrors.CategoryProtocol, "revoke session failed")
	}

	return true, nil
}

// Me is the resolver for the me field.
func (r *queryResolver) Me(ctx context.Context) (*model.User, error) {
	if r.authService == nil {
		return nil, apperrors.NewProtocolError(apperrors.CodeCommandFailed, "auth service not configured", "graphql")
	}

	// Extract user ID from context
	userID, err := getUserIDFromContext(ctx)
	if err != nil {
		return nil, err
	}

	// Fetch user details through auth service
	user, err := r.authService.GetCurrentUser(ctx, userID)
	if err != nil {
		return nil, apperrors.Wrap(err, apperrors.CodeProtocolError, apperrors.CategoryProtocol, "failed to fetch user details")
	}

	if user == nil {
		return nil, apperrors.NewValidationError("user", userID, "user not found")
	}

	return &model.User{
		ID:       user.ID,
		Username: user.Username,
	}, nil
}

// MySessions is the resolver for the mySessions field.
func (r *queryResolver) MySessions(ctx context.Context) ([]*model.Session, error) {
	if r.authService == nil {
		return nil, apperrors.NewProtocolError(apperrors.CodeCommandFailed, "auth service not configured", "graphql")
	}

	// Extract user ID from context
	userID, err := getUserIDFromContext(ctx)
	if err != nil {
		return nil, err
	}

	// Fetch sessions for the current user through auth service
	sessions, err := r.authService.GetUserSessions(ctx, userID)
	if err != nil {
		return nil, apperrors.Wrap(err, apperrors.CodeProtocolError, apperrors.CategoryProtocol, "failed to fetch user sessions")
	}

	if sessions == nil {
		sessions = []*auth.Session{}
	}

	// Convert auth service sessions to GraphQL model
	result := make([]*model.Session, len(sessions))
	for i, session := range sessions {
		ipAddr := session.IPAddress
		userAgent := session.UserAgent
		result[i] = &model.Session{
			ID:           session.ID,
			IPAddress:    &ipAddr,
			UserAgent:    &userAgent,
			CreatedAt:    session.CreatedAt,
			LastActivity: session.LastActivity,
		}
	}

	return result, nil
}
