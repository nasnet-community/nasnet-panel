package resolver

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.86

import (
	"backend/generated/ent"
	"backend/generated/ent/serviceinstance"
	"backend/generated/ent/virtualinterface"
	graphql1 "backend/graph/model"
	"backend/internal/apperrors"
	"context"
)

// AvailableServices is the resolver for the availableServices field.
func (r *queryResolver) AvailableServices(ctx context.Context, category *string, architecture *string) ([]*graphql1.AvailableService, error) {
	cat := ""
	if category != nil {
		cat = *category
	}
	arch := ""
	if architecture != nil {
		arch = *architecture
	}

	manifests := r.FeatureRegistry.ListManifests(cat, arch)

	result := make([]*graphql1.AvailableService, len(manifests))
	for i, m := range manifests {
		result[i] = convertManifestToAvailableService(m)
	}
	return result, nil
}

// ServiceInstances is the resolver for the serviceInstances field.
func (r *queryResolver) ServiceInstances(ctx context.Context, routerID string, status *graphql1.ServiceInstanceStatus, featureID *string) ([]*graphql1.ServiceInstance, error) {
	q := r.db.ServiceInstance.Query().
		Where(serviceinstance.RouterIDEQ(routerID))

	if status != nil {
		entStatus := convertGraphQLStatusToEnt(*status)
		q = q.Where(serviceinstance.StatusEQ(entStatus))
	}

	if featureID != nil {
		q = q.Where(serviceinstance.FeatureIDEQ(*featureID))
	}

	instances, err := q.All(ctx)
	if err != nil {
		return nil, apperrors.Wrap(err, "QUERY_INSTANCES_FAILED", apperrors.CategoryInternal, "failed to query service instances")
	}

	result := make([]*graphql1.ServiceInstance, len(instances))
	for i, inst := range instances {
		result[i] = convertEntInstanceToGraphQL(inst)
	}
	return result, nil
}

// ServiceInstance is the resolver for the serviceInstance field.
func (r *queryResolver) ServiceInstance(ctx context.Context, routerID string, instanceID string) (*graphql1.ServiceInstance, error) {
	inst, err := r.db.ServiceInstance.Query().
		Where(serviceinstance.IDEQ(instanceID)).
		Where(serviceinstance.RouterIDEQ(routerID)).
		Only(ctx)
	if err != nil {
		if ent.IsNotFound(err) {
			return nil, apperrors.NewResourceError("INSTANCE_NOT_FOUND", "service instance not found", "ServiceInstance", instanceID)
		}
		return nil, apperrors.Wrap(err, "QUERY_INSTANCE_FAILED", apperrors.CategoryInternal, "failed to query service instance")
	}
	return convertEntInstanceToGraphQL(inst), nil
}

// InstanceVerificationStatus is the resolver for the instanceVerificationStatus field.
func (r *queryResolver) InstanceVerificationStatus(ctx context.Context, routerID string) ([]*graphql1.BinaryVerification, error) {
	instances, err := r.db.ServiceInstance.Query().
		Where(serviceinstance.RouterIDEQ(routerID)).
		All(ctx)
	if err != nil {
		return nil, apperrors.Wrap(err, "QUERY_INSTANCES_FAILED", apperrors.CategoryInternal, "failed to query service instances")
	}

	result := make([]*graphql1.BinaryVerification, 0, len(instances))
	for _, inst := range instances {
		result = append(result, convertEntInstanceToBinaryVerification(inst))
	}
	return result, nil
}

// VirtualInterfaces is the resolver for the virtualInterfaces field.
func (r *queryResolver) VirtualInterfaces(ctx context.Context, routerID string) ([]*graphql1.VirtualInterface, error) {
	instanceIDs, err := r.db.ServiceInstance.Query().
		Where(serviceinstance.RouterIDEQ(routerID)).
		IDs(ctx)
	if err != nil {
		return nil, apperrors.Wrap(err, "QUERY_INSTANCES_FAILED", apperrors.CategoryInternal, "failed to query service instances for router")
	}

	if len(instanceIDs) == 0 {
		return []*graphql1.VirtualInterface{}, nil
	}

	vifs, err := r.db.VirtualInterface.Query().
		Where(virtualinterface.InstanceIDIn(instanceIDs...)).
		All(ctx)
	if err != nil {
		return nil, apperrors.Wrap(err, "QUERY_VIFS_FAILED", apperrors.CategoryInternal, "failed to query virtual interfaces")
	}

	result := make([]*graphql1.VirtualInterface, len(vifs))
	for i, vif := range vifs {
		result[i] = convertEntVIFToGraphQL(vif)
	}
	return result, nil
}

// VirtualInterface is the resolver for the virtualInterface field.
func (r *queryResolver) VirtualInterface(ctx context.Context, routerID string, instanceID string) (*graphql1.VirtualInterface, error) {
	vif, err := r.db.VirtualInterface.Query().
		Where(virtualinterface.InstanceIDEQ(instanceID)).
		Only(ctx)
	if err != nil {
		if ent.IsNotFound(err) {
			return nil, apperrors.NewResourceError("VIF_NOT_FOUND", "virtual interface not found for instance", "VirtualInterface", instanceID)
		}
		return nil, apperrors.Wrap(err, "QUERY_VIF_FAILED", apperrors.CategoryInternal, "failed to query virtual interface")
	}
	return convertEntVIFToGraphQL(vif), nil
}

// BridgeStatus is the resolver for the bridgeStatus field.
func (r *queryResolver) BridgeStatus(ctx context.Context, routerID string, instanceID string) (*graphql1.BridgeStatus, error) {
	vif, err := r.db.VirtualInterface.Query().
		Where(virtualinterface.InstanceIDEQ(instanceID)).
		Only(ctx)
	if err != nil {
		if ent.IsNotFound(err) {
			return &graphql1.BridgeStatus{
				Interface:      nil,
				IsReady:        false,
				GatewayRunning: false,
				Errors:         []string{"virtual interface not found for instance"},
			}, nil
		}
		return nil, apperrors.Wrap(err, "QUERY_VIF_FAILED", apperrors.CategoryInternal, "failed to query virtual interface")
	}

	gqlVIF := convertEntVIFToGraphQL(vif)
	isReady := vif.Status == virtualinterface.StatusActive
	gatewayRunning := vif.GatewayStatus == virtualinterface.GatewayStatusRunning

	return &graphql1.BridgeStatus{
		Interface:      gqlVIF,
		IsReady:        isReady,
		GatewayRunning: gatewayRunning,
		Errors:         []string{},
	}, nil
}

// GatewayStatus is the resolver for the gatewayStatus field.
func (r *queryResolver) GatewayStatus(ctx context.Context, instanceID string) (*graphql1.GatewayInfo, error) {
	if r.GatewayManager == nil {
		return &graphql1.GatewayInfo{
			State: graphql1.GatewayStateStopped,
		}, nil
	}

	status, err := r.GatewayManager.GetStatus(instanceID)
	if err != nil {
		//nolint:nilerr // returns structured error in payload per GraphQL convention
		return &graphql1.GatewayInfo{
			State: graphql1.GatewayStateStopped,
		}, nil
	}

	return convertGatewayStatusToGraphQL(status), nil
}
