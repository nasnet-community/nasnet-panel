package resolver

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.86

import (
	graphql1 "backend/graph/model"
	"backend/internal/apperrors"
	"backend/internal/common/ulid"
	"backend/internal/events"
	"backend/internal/orchestrator/resources"
	"context"
	"fmt"
	"os"
	"path/filepath"
	"time"
)

// RunServiceDiagnostics is the resolver for the runServiceDiagnostics field.
func (r *mutationResolver) RunServiceDiagnostics(ctx context.Context, input graphql1.RunDiagnosticsInput) (*graphql1.RunDiagnosticsPayload, error) {
	if r.InstanceManager == nil {
		return nil, apperrors.NewResourceError(
			apperrors.CodeResourceNotFound,
			"instance manager not available",
			"service",
			"instance_manager",
		)
	}

	// Verify instance exists in DB
	instance, err := r.db.ServiceInstance.Get(ctx, input.InstanceID)
	if err != nil {
		return nil, apperrors.Wrap(err, apperrors.CodeResourceNotFound, apperrors.CategoryResource, "instance not found")
	}

	// Get health status from instance manager
	healthStatus, err := r.InstanceManager.GetInstanceHealthStatus(input.InstanceID)
	if err != nil {
		healthStatus = "UNKNOWN"
	}

	runGroupID := ulid.NewString()
	now := time.Now()

	// Build a basic health diagnostic result based on current instance state
	status := string(instance.Status)
	diagStatus := graphql1.DiagnosticStatusPass
	message := fmt.Sprintf("Instance is %s (health: %s)", status, healthStatus)
	if healthStatus == "FAILING" || healthStatus == "CRASHED" {
		diagStatus = graphql1.DiagnosticStatusFail
		message = fmt.Sprintf("Instance is unhealthy: %s", healthStatus)
	}

	errMsg := instance.UnavailableReason
	var errMsgPtr *string
	if errMsg != "" {
		errMsgPtr = &errMsg
	}

	result := &graphql1.DiagnosticResult{
		ID:           ulid.NewString(),
		InstanceID:   input.InstanceID,
		TestName:     "process_health",
		Status:       diagStatus,
		Message:      message,
		DurationMs:   0,
		RunGroupID:   &runGroupID,
		ErrorMessage: errMsgPtr,
		CreatedAt:    now,
	}

	overallStatus := graphql1.DiagnosticStatusPass
	if diagStatus == graphql1.DiagnosticStatusFail {
		overallStatus = graphql1.DiagnosticStatusFail
	}

	// Emit a diagnostics progress event
	if err := r.EventBus.Publish(ctx, events.NewGenericEvent(
		"service.diagnostics.completed",
		events.PriorityNormal,
		"graphql-resolver",
		map[string]interface{}{
			"instanceId": input.InstanceID,
			"runGroupId": runGroupID,
			"status":     string(overallStatus),
		},
	)); err != nil {
		// Log event publish error but don't fail the operation
		fmt.Printf("failed to publish diagnostics event: %v\n", err)
	}

	return &graphql1.RunDiagnosticsPayload{
		Success:    true,
		Results:    []*graphql1.DiagnosticResult{result},
		RunGroupID: &runGroupID,
	}, nil
}

// ServiceLogFile is the resolver for the serviceLogFile field.
func (r *queryResolver) ServiceLogFile(ctx context.Context, routerID string, instanceID string, maxLines *int) (*graphql1.ServiceLogFile, error) {
	if r.InstanceManager == nil {
		return nil, apperrors.NewResourceError(
			apperrors.CodeResourceNotFound,
			"instance manager not available",
			"service",
			"instance_manager",
		)
	}

	// Query instance from DB
	instance, err := r.db.ServiceInstance.Get(ctx, instanceID)
	if err != nil {
		return nil, apperrors.Wrap(err, apperrors.CodeResourceNotFound, apperrors.CategoryResource, "instance not found")
	}

	// Resolve log file path using the path resolver
	pathResolver := r.InstanceManager.PathResolver()
	logDir := pathResolver.LogsPath(instance.FeatureID)
	logFileName := fmt.Sprintf("%s-%s.log", instance.FeatureID, instanceID)
	logFilePath := filepath.Join(logDir, logFileName)

	// Stat the log file
	fileInfo, err := os.Stat(logFilePath)
	if err != nil {
		if os.IsNotExist(err) {
			// Return empty log file response when log doesn't exist yet
			return &graphql1.ServiceLogFile{
				InstanceID:  instanceID,
				ServiceName: instance.FeatureID,
				FilePath:    logFilePath,
				SizeBytes:   0,
				LineCount:   0,
				Entries:     []*graphql1.LogEntry{},
				CreatedAt:   time.Now(),
				LastUpdated: time.Now(),
			}, nil
		}
		return nil, apperrors.Wrap(err, apperrors.CodeResourceNotFound, apperrors.CategoryInternal, "failed to stat log file")
	}

	// Determine max lines to read
	limit := resources.MaxTailLines
	if maxLines != nil && *maxLines > 0 && *maxLines < resources.MaxTailLines {
		limit = *maxLines
	}

	// Read last N lines from log file
	entries, lineCount, err := readLastNLines(logFilePath, instance.FeatureID, limit)
	if err != nil {
		return nil, apperrors.Wrap(
			err,
			apperrors.CodeResourceNotFound,
			apperrors.CategoryInternal,
			"failed to read log file",
		)
	}

	return &graphql1.ServiceLogFile{
		InstanceID:  instanceID,
		ServiceName: instance.FeatureID,
		FilePath:    logFilePath,
		SizeBytes:   int(fileInfo.Size()),
		LineCount:   lineCount,
		Entries:     entries,
		CreatedAt:   fileInfo.ModTime(), // use mod time as approximation
		LastUpdated: fileInfo.ModTime(),
	}, nil
}

// DiagnosticHistory is the resolver for the diagnosticHistory field.
func (r *queryResolver) DiagnosticHistory(ctx context.Context, routerID string, instanceID string, limit *int) ([]*graphql1.StartupDiagnostics, error) {
	// Diagnostic history is not currently persisted in the DB.
	// Return an empty list - this will be populated when diagnostic persistence is implemented.
	return []*graphql1.StartupDiagnostics{}, nil
}

// AvailableDiagnostics is the resolver for the availableDiagnostics field.
func (r *queryResolver) AvailableDiagnostics(ctx context.Context, serviceName string) (*graphql1.DiagnosticSuite, error) {
	if r.FeatureRegistry == nil {
		return nil, apperrors.NewResourceError(
			apperrors.CodeResourceNotFound,
			"feature registry not available",
			"service",
			"feature_registry",
		)
	}

	// Look up manifest for the service
	manifest, err := r.FeatureRegistry.GetManifest(serviceName)
	if err != nil {
		// Service not found in registry - return empty suite rather than error
		//nolint:nilerr // intentional: service not found returns empty suite
		return &graphql1.DiagnosticSuite{
			ServiceName: serviceName,
			Tests:       []*graphql1.DiagnosticTest{},
		}, nil
	}

	// Build available diagnostic tests from manifest health spec
	var tests []*graphql1.DiagnosticTest

	// Always include process health check
	tests = append(tests, &graphql1.DiagnosticTest{
		Name:        "process_health",
		Description: "Checks whether the service process is running",
		Category:    "health",
	})

	// Add connectivity check if health check spec is defined
	if manifest.HealthCheck != nil {
		tests = append(tests, &graphql1.DiagnosticTest{
			Name:        "connectivity",
			Description: "Checks service connectivity via health probe",
			Category:    "connectivity",
		})
	}

	return &graphql1.DiagnosticSuite{
		ServiceName: serviceName,
		Tests:       tests,
	}, nil
}

// ServiceLogs is the resolver for the serviceLogs field.
func (r *subscriptionResolver) ServiceLogs(ctx context.Context, routerID string, instanceID string, levelFilter *graphql1.LogLevel) (<-chan *graphql1.LogEntry, error) {
	logChan := make(chan *graphql1.LogEntry, 50)

	if r.EventBus == nil {
		go func() {
			defer close(logChan)
			<-ctx.Done()
		}()
		return logChan, nil
	}

	go func() {
		defer close(logChan)

		// Subscribe to log appended events from the event bus
		logEntryChan := make(chan *graphql1.LogEntry, 50)

		err := r.EventBus.Subscribe(
			events.EventTypeLogAppended,
			func(evtCtx context.Context, event events.Event) error {
				logEvt, ok := event.(*events.LogAppendedEvent)
				if !ok {
					return nil
				}

				// Filter by instance/router: LogAppendedEvent has RouterID, use it for basic filtering
				if logEvt.RouterID != routerID {
					return nil
				}

				// Map event log level to GraphQL model level
				lvl := mapEventLevelToModel(logEvt.Level)

				// Apply level filter if specified
				if levelFilter != nil && lvl != *levelFilter {
					return nil
				}

				entry := &graphql1.LogEntry{
					Timestamp: event.GetTimestamp(),
					Level:     lvl,
					Message:   logEvt.Message,
					Source:    logEvt.Topic,
					RawLine:   logEvt.Message,
				}

				select {
				case logEntryChan <- entry:
				default:
					// Buffer full, drop entry
				}
				return nil
			},
		)
		if err != nil {
			// If subscription fails, just close the channel
			return
		}

		for {
			select {
			case <-ctx.Done():
				return
			case entry, ok := <-logEntryChan:
				if !ok {
					return
				}
				select {
				case logChan <- entry:
				case <-ctx.Done():
					return
				}
			}
		}
	}()

	return logChan, nil
}

// DiagnosticsProgress is the resolver for the diagnosticsProgress field.
func (r *subscriptionResolver) DiagnosticsProgress(ctx context.Context, routerID string, instanceID string) (<-chan *graphql1.DiagnosticsProgress, error) {
	progressChan := make(chan *graphql1.DiagnosticsProgress, 10)

	if r.EventBus == nil {
		go func() {
			defer close(progressChan)
			<-ctx.Done()
		}()
		return progressChan, nil
	}

	go func() {
		defer close(progressChan)

		diagChan := make(chan *graphql1.DiagnosticsProgress, 10)

		// Subscribe to diagnostic completion events
		err := r.EventBus.Subscribe(
			"service.diagnostics.completed",
			func(evtCtx context.Context, event events.Event) error {
				genEvt, ok := event.(*events.GenericEvent)
				if !ok {
					return nil
				}

				instID, _ := genEvt.Data["instanceId"].(string) //nolint:errcheck // zero value acceptable on failed type assertion
				if instID != instanceID {
					return nil
				}

				runGroupID, _ := genEvt.Data["runGroupId"].(string) //nolint:errcheck // zero value acceptable on failed type assertion
				progress := &graphql1.DiagnosticsProgress{
					InstanceID:     instanceID,
					RunGroupID:     runGroupID,
					Progress:       100,
					CompletedTests: 1,
					TotalTests:     1,
					Timestamp:      event.GetTimestamp(),
				}

				select {
				case diagChan <- progress:
				default:
				}
				return nil
			},
		)
		if err != nil {
			return
		}

		for {
			select {
			case <-ctx.Done():
				return
			case prog, ok := <-diagChan:
				if !ok {
					return
				}
				select {
				case progressChan <- prog:
				case <-ctx.Done():
					return
				}
			}
		}
	}()

	return progressChan, nil
}
