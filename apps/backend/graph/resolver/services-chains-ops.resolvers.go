package resolver

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.86

import (
	graphql1 "backend/graph/model"
	"backend/internal/apperrors"
	"backend/internal/events"
	"context"
	"fmt"
)

// CreateRoutingChain is the resolver for the createRoutingChain field.
func (r *mutationResolver) CreateRoutingChain(ctx context.Context, routerID string, input graphql1.CreateRoutingChainInput) (*graphql1.RoutingChainMutationResult, error) {
	// Validate inputs
	if routerID == "" {
		return nil, apperrors.NewValidationError("routerID", routerID, "required")
	}
	if input.DeviceID == "" {
		return nil, apperrors.NewValidationError("deviceID", input.DeviceID, "required")
	}
	if len(input.Hops) == 0 {
		return nil, apperrors.NewValidationError("hops", len(input.Hops), "at least one hop is required")
	}

	if r.ChainRouter == nil {
		return nil, apperrors.NewResourceError(apperrors.CodeResourceNotFound, "chain router service not available", "service", "chain_router")
	}

	chainInput := convertCreateRoutingChainInput(input)

	chain, err := r.ChainRouter.CreateRoutingChain(ctx, routerID, chainInput)
	if err != nil {
		return nil, fmt.Errorf("failed to create routing chain: %w", err)
	}

	gqlChain := convertEntRoutingChainToGraphQL(chain)
	msg := "Routing chain created successfully"
	return &graphql1.RoutingChainMutationResult{
		Success: true,
		Message: &msg,
		Chain:   gqlChain,
	}, nil
}

// UpdateRoutingChain is the resolver for the updateRoutingChain field.
func (r *mutationResolver) UpdateRoutingChain(ctx context.Context, routerID string, chainID string, input graphql1.CreateRoutingChainInput) (*graphql1.RoutingChainMutationResult, error) {
	// Validate inputs
	if routerID == "" {
		return nil, apperrors.NewValidationError("routerID", routerID, "required")
	}
	if chainID == "" {
		return nil, apperrors.NewValidationError("chainID", chainID, "required")
	}
	if input.DeviceID == "" {
		return nil, apperrors.NewValidationError("deviceID", input.DeviceID, "required")
	}
	if len(input.Hops) == 0 {
		return nil, apperrors.NewValidationError("hops", len(input.Hops), "at least one hop is required")
	}

	if r.ChainRouter == nil {
		return nil, apperrors.NewResourceError(apperrors.CodeResourceNotFound, "chain router service not available", "service", "chain_router")
	}

	chainInput := convertCreateRoutingChainInput(input)

	chain, err := r.ChainRouter.UpdateRoutingChain(ctx, chainID, chainInput)
	if err != nil {
		return nil, fmt.Errorf("failed to update routing chain: %w", err)
	}

	gqlChain := convertEntRoutingChainToGraphQL(chain)
	msg := "Routing chain updated successfully"
	return &graphql1.RoutingChainMutationResult{
		Success: true,
		Message: &msg,
		Chain:   gqlChain,
	}, nil
}

// RemoveRoutingChain is the resolver for the removeRoutingChain field.
func (r *mutationResolver) RemoveRoutingChain(ctx context.Context, routerID string, chainID string) (*graphql1.RoutingChainMutationResult, error) {
	// Validate inputs
	if routerID == "" {
		return nil, apperrors.NewValidationError("routerID", routerID, "required")
	}
	if chainID == "" {
		return nil, apperrors.NewValidationError("chainID", chainID, "required")
	}

	if r.ChainRouter == nil {
		return nil, apperrors.NewResourceError(apperrors.CodeResourceNotFound, "chain router service not available", "service", "chain_router")
	}

	if err := r.ChainRouter.RemoveRoutingChain(ctx, chainID); err != nil {
		return nil, fmt.Errorf("failed to remove routing chain: %w", err)
	}

	msg := "Routing chain removed successfully"
	return &graphql1.RoutingChainMutationResult{
		Success: true,
		Message: &msg,
	}, nil
}

// RoutingChain is the resolver for the routingChain field.
func (r *queryResolver) RoutingChain(ctx context.Context, routerID string, deviceID string) (*graphql1.RoutingChain, error) {
	// Validate inputs
	if routerID == "" {
		return nil, apperrors.NewValidationError("routerID", routerID, "required")
	}
	if deviceID == "" {
		return nil, apperrors.NewValidationError("deviceID", deviceID, "required")
	}

	if r.ChainRouter == nil {
		return nil, apperrors.NewResourceError(apperrors.CodeResourceNotFound, "chain router service not available", "service", "chain_router")
	}

	chain, err := r.ChainRouter.GetRoutingChain(ctx, routerID, deviceID)
	if err != nil {
		return nil, apperrors.Wrap(err, apperrors.CodeCommandFailed, apperrors.CategoryProtocol, "failed to get routing chain")
	}

	return convertEntRoutingChainToGraphQL(chain), nil
}

// RoutingChains is the resolver for the routingChains field.
func (r *queryResolver) RoutingChains(ctx context.Context, routerID string) ([]*graphql1.RoutingChain, error) {
	// Validate inputs
	if routerID == "" {
		return nil, apperrors.NewValidationError("routerID", routerID, "required")
	}

	if r.ChainRouter == nil {
		return nil, apperrors.NewResourceError(apperrors.CodeResourceNotFound, "chain router service not available", "service", "chain_router")
	}

	chains, err := r.ChainRouter.ListRoutingChains(ctx, routerID)
	if err != nil {
		return nil, apperrors.Wrap(err, apperrors.CodeCommandFailed, apperrors.CategoryProtocol, "failed to list routing chains")
	}

	result := make([]*graphql1.RoutingChain, len(chains))
	for i, chain := range chains {
		result[i] = convertEntRoutingChainToGraphQL(chain)
	}
	return result, nil
}

// RoutingChainChanged is the resolver for the routingChainChanged field.
//
//nolint:gocyclo // resolver logic requires branching for event filtering and data extraction
func (r *subscriptionResolver) RoutingChainChanged(ctx context.Context, routerID string) (<-chan *graphql1.RoutingChain, error) {
	// Validate inputs
	if routerID == "" {
		return nil, apperrors.NewValidationError("routerID", routerID, "required")
	}

	if r.EventBus == nil {
		return nil, apperrors.NewResourceError(apperrors.CodeResourceNotFound, "event bus not available", "bus", "event")
	}

	eventChan := make(chan *graphql1.RoutingChain, 10)

	err := r.EventBus.Subscribe("routing.chain.*", func(ctx context.Context, event events.Event) error {
		genEvt, ok := event.(*events.GenericEvent)
		if !ok {
			return nil
		}

		chainRouterID, _ := genEvt.Data["router_id"].(string) //nolint:errcheck // zero value acceptable on failed type assertion
		if chainRouterID != "" && chainRouterID != routerID {
			return nil
		}

		chainID, _ := genEvt.Data["chain_id"].(string) //nolint:errcheck // zero value acceptable on failed type assertion
		if chainID == "" {
			return nil
		}

		// For removed chains, emit a minimal placeholder with just the ID
		if event.GetType() == events.EventTypeRoutingChainRemoved {
			select {
			case eventChan <- &graphql1.RoutingChain{ID: chainID}:
			case <-ctx.Done():
			}
			return nil
		}

		if r.ChainRouter != nil {
			deviceID, _ := genEvt.Data["device_id"].(string) //nolint:errcheck // zero value acceptable on failed type assertion
			if deviceID != "" {
				chain, err := r.ChainRouter.GetRoutingChain(ctx, routerID, deviceID)
				if err == nil {
					select {
					case eventChan <- convertEntRoutingChainToGraphQL(chain):
					case <-ctx.Done():
					}
				}
			}
		}
		return nil
	})
	if err != nil {
		close(eventChan)
		return eventChan, apperrors.Wrap(err, apperrors.CodeCommandFailed, apperrors.CategoryProtocol, "failed to subscribe to routing chain events")
	}

	go func() {
		<-ctx.Done()
		close(eventChan)
	}()

	return eventChan, nil
}
