package resolver

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.44

import (
	"context"
	"fmt"
	"time"

	"backend/graph/model"
	"backend/internal/events"
)

// =============================================================================
// Device Scan Resolvers
// =============================================================================
// GraphQL resolvers for ARP device scanning with real-time progress streaming.

// RunDeviceScan is the resolver for the runDeviceScan mutation.
func (r *mutationResolver) RunDeviceScan(ctx context.Context, input model.DeviceScanInput) (*model.DeviceScanResult, error) {
	if r.ARPScannerService == nil {
		return &model.DeviceScanResult{
			Errors: []*model.MutationError{{
				Code:    "SERVICE_UNAVAILABLE",
				Message: "ARP scanner service not initialized",
			}},
		}, nil
	}

	// Validate input
	if input.DeviceID == nil || *input.DeviceID == "" {
		return &model.DeviceScanResult{
			Errors: []*model.MutationError{{
				Code:    "INVALID_INPUT",
				Message: "deviceId is required",
				Field:   strPtr("deviceId"),
			}},
		}, nil
	}

	if input.Subnet == "" {
		return &model.DeviceScanResult{
			Errors: []*model.MutationError{{
				Code:    "INVALID_INPUT",
				Message: "subnet is required",
				Field:   strPtr("subnet"),
			}},
		}, nil
	}

	// Set defaults
	interfaceName := ""
	if input.Interface != nil {
		interfaceName = *input.Interface
	}

	// Start scan
	scanID, err := r.ARPScannerService.StartScan(
		ctx,
		*input.DeviceID,
		input.Subnet,
		interfaceName,
	)

	if err != nil {
		return &model.DeviceScanResult{
			Errors: []*model.MutationError{{
				Code:    "SCAN_FAILED",
				Message: err.Error(),
			}},
		}, nil
	}

	return &model.DeviceScanResult{
		ScanID: &scanID,
		Status: model.ScanStatusPending,
	}, nil
}

// CancelDeviceScan is the resolver for the cancelDeviceScan mutation.
func (r *mutationResolver) CancelDeviceScan(ctx context.Context, scanID string) (*model.CancelScanResult, error) {
	if r.ARPScannerService == nil {
		return &model.CancelScanResult{
			Success: false,
		}, fmt.Errorf("scanner service not initialized")
	}

	err := r.ARPScannerService.CancelScan(ctx, scanID)
	return &model.CancelScanResult{
		Success: err == nil,
	}, err
}

// AddKnownDevice is the resolver for the addKnownDevice mutation.
func (r *mutationResolver) AddKnownDevice(ctx context.Context, input model.KnownDeviceInput) (*model.KnownDevice, error) {
	// This mutation is for future feature to store known devices
	// For now, return success without persistence
	return &model.KnownDevice{
		ID:   generateID(),
		Name: input.Name,
		Mac:  input.Mac,
	}, nil
}

// DeviceScanProgress is the resolver for the deviceScanProgress subscription.
func (r *subscriptionResolver) DeviceScanProgress(ctx context.Context, scanID string) (<-chan *model.DeviceScanProgress, error) {
	progressChan := make(chan *model.DeviceScanProgress, 20)

	if r.EventBus == nil {
		close(progressChan)
		return progressChan, fmt.Errorf("event bus not available")
	}

	// Subscribe to device scan events
	handler := func(eventCtx context.Context, event events.Event) error {
		// Handle different event types
		switch e := event.(type) {
		case *events.DeviceScanStartedEvent:
			if e.ScanID != scanID {
				return nil
			}
			graphQLEvent := &model.DeviceScanProgress{
				ScanID:            e.ScanID,
				Status:            model.ScanStatusPending,
				Progress:          0,
				ScannedCount:      0,
				TotalCount:        0,
				DiscoveredDevices: []*model.DiscoveredDevice{},
				ElapsedTime:       0,
			}
			return sendProgress(ctx, progressChan, graphQLEvent)

		case *events.DeviceScanProgressEvent:
			if e.ScanID != scanID {
				return nil
			}
			graphQLEvent := &model.DeviceScanProgress{
				ScanID:            e.ScanID,
				Status:            convertStringScanStatus(string(e.Status)),
				Progress:          e.Progress,
				ScannedCount:      e.ScannedCount,
				TotalCount:        e.TotalCount,
				DiscoveredDevices: convertDevices(e.Devices),
				ElapsedTime:       e.ElapsedTime,
			}
			return sendProgress(ctx, progressChan, graphQLEvent)

		case *events.DeviceScanCompletedEvent:
			if e.ScanID != scanID {
				return nil
			}
			graphQLEvent := &model.DeviceScanProgress{
				ScanID:            e.ScanID,
				Status:            model.ScanStatusCompleted,
				Progress:          100,
				ScannedCount:      e.DevicesFound,
				TotalCount:        e.DevicesFound,
				DiscoveredDevices: convertDevices(e.Devices),
				ElapsedTime:       e.Duration,
			}
			return sendProgress(ctx, progressChan, graphQLEvent)

		case *events.DeviceScanFailedEvent:
			if e.ScanID != scanID {
				return nil
			}
			errorMsg := e.Error
			graphQLEvent := &model.DeviceScanProgress{
				ScanID:            e.ScanID,
				Status:            model.ScanStatusError,
				Progress:          0,
				ScannedCount:      0,
				TotalCount:        0,
				DiscoveredDevices: []*model.DiscoveredDevice{},
				ElapsedTime:       0,
				Error:             &errorMsg,
			}
			return sendProgress(ctx, progressChan, graphQLEvent)

		case *events.DeviceScanCancelledEvent:
			if e.ScanID != scanID {
				return nil
			}
			graphQLEvent := &model.DeviceScanProgress{
				ScanID:            e.ScanID,
				Status:            model.ScanStatusCancelled,
				Progress:          0,
				ScannedCount:      0,
				TotalCount:        0,
				DiscoveredDevices: []*model.DiscoveredDevice{},
				ElapsedTime:       0,
			}
			return sendProgress(ctx, progressChan, graphQLEvent)
		}

		return nil
	}

	// Subscribe to all device scan event types
	eventTypes := []string{
		events.EventTypeDeviceScanStarted,
		events.EventTypeDeviceScanProgress,
		events.EventTypeDeviceScanCompleted,
		events.EventTypeDeviceScanFailed,
		events.EventTypeDeviceScanCancelled,
	}

	for _, eventType := range eventTypes {
		if err := r.EventBus.Subscribe(eventType, handler); err != nil {
			close(progressChan)
			return nil, fmt.Errorf("failed to subscribe to %s: %w", eventType, err)
		}
	}

	// Cleanup on context done
	go func() {
		<-ctx.Done()
		close(progressChan)
	}()

	return progressChan, nil
}

// -----------------------------------------------------------------------------
// Helper Functions
// -----------------------------------------------------------------------------

// sendProgress sends a progress event to the channel with non-blocking semantics.
func sendProgress(ctx context.Context, ch chan<- *model.DeviceScanProgress, event *model.DeviceScanProgress) error {
	select {
	case <-ctx.Done():
		return ctx.Err()
	case ch <- event:
		return nil
	default:
		// Channel full - log and skip
		return nil
	}
}

// convertStringScanStatus converts internal string status to GraphQL ScanStatus.
func convertStringScanStatus(status string) model.ScanStatus {
	switch status {
	case "PENDING":
		return model.ScanStatusPending
	case "SCANNING":
		return model.ScanStatusScanning
	case "COMPLETED":
		return model.ScanStatusCompleted
	case "CANCELLED":
		return model.ScanStatusCancelled
	case "FAILED":
		return model.ScanStatusError
	default:
		return model.ScanStatusPending
	}
}

// convertDevices converts internal DiscoveredDevice list to GraphQL format.
func convertDevices(devices []events.DiscoveredDevice) []*model.DiscoveredDevice {
	result := make([]*model.DiscoveredDevice, len(devices))
	for i, d := range devices {
		device := &model.DiscoveredDevice{
			IP:           d.IP,
			Mac:          d.MAC,
			Interface:    d.Interface,
			ResponseTime: d.ResponseTime,
			FirstSeen:    d.FirstSeen.Format("2006-01-02T15:04:05Z"),
		}

		// Optional fields
		if d.Hostname != "" {
			device.Hostname = &d.Hostname
		}

		result[i] = device
	}
	return result
}

// generateID generates a unique ID using ULID.
func generateID() string {
	return "known-" + fmt.Sprintf("%d", time.Now().UnixNano())
}
